With timestamps:

00:00 - dr charles severance is one of the
00:01 - world's most popular software
00:03 - instructors and he's the instructor for
00:05 - this c programming course this course is
00:08 - a little different than some of our
00:09 - other courses dr chuck is going to take
00:11 - you through a classic and important book
00:14 - on c programming you will occasionally
00:16 - have to pause the video to do some
00:18 - assignments to check your comprehension
00:20 - it's going to be a challenge but it will
00:22 - definitely be worth it if you want to
00:23 - have a deep understanding of the c
00:25 - programming language and if you're
00:27 - completely new to programming you may
00:29 - want to watch dr chuck's python for
00:31 - everybody course first
00:33 - welcome to c programming for everybody
00:34 - my name is charles severance and i'm
00:36 - your instructor for this course
00:38 - this course and website is dedicated to
00:40 - learning the classic version of c
00:42 - programming language from the 1978 book
00:45 - written by brian w kernighan and dennis
00:47 - m ritchie
00:48 - this book places the reader in the
00:50 - middle of the 1970s transition from a
00:52 - hardware-centered computer science to a
00:54 - focus on writing portable and efficient
00:57 - software c was used to develop operating
01:00 - systems like unix minix and linux
01:03 - programming languages like perl python
01:05 - java and javascript and ruby are all
01:07 - written in c
01:09 - software like early tcp networking stack
01:11 - implementations that made the internet
01:13 - possible were written in c
01:15 - and the first web browsers and web
01:17 - servers were written in c
01:20 - writing software in c enabled major
01:22 - advances in computer architecture and
01:23 - performance
01:25 - operating systems compilers and
01:26 - utilities could be recompiled to work on
01:28 - a new hardware platform once we had a c
01:31 - compiler for the new hardware
01:33 - so much software has been written in c
01:35 - over the past 40 years that there's a
01:37 - very good chance that much of the
01:39 - software that you use every day was
01:41 - either written in c or written in a
01:44 - programming language that was written in
01:46 - c
01:47 - so we study c less as a programming
01:49 - language to use on a daily basis and
01:51 - more as the foundation of modern
01:52 - software and computing
01:54 - in many ways c is the technology
01:56 - equivalent of the rosetta stone in that
01:58 - it provides a connection between the
02:00 - programming languages of the past and
02:02 - the programming languages of the present
02:04 - the name cc4e in www.cc4e.com
02:09 - refers to the original unix command cc
02:12 - which was the command that you used to
02:14 - compile your c program
02:16 - cc stood for c compiler and it is
02:19 - featured on the first page of the first
02:21 - chapter of the knrc book
02:24 - programmers like me from the 1970s and
02:26 - 1980s typed cc on unix systems like the
02:30 - att 3b2 to compile and run their first
02:33 - hello world program in c
02:36 - this material is being presented under
02:38 - fair use as we are making use of
02:39 - material from a copyrighted work that is
02:41 - out of print and not broadly available
02:43 - in any format the book is also not
02:45 - available in any accessible format we
02:47 - are making use of this material in a
02:49 - teaching and research context with a
02:50 - focus on studying its contribution to
02:53 - computing history
02:54 - the material is available for free and
02:56 - online to anyone who wants to learn
02:58 - about the history of a c language
03:00 - computing and computer architecture
03:02 - welcome to the course
03:04 - [Music]
03:09 - welcome to c programming for everybody
03:12 - my name is charles severance and this is
03:14 - my reading of the 1978 c programming
03:17 - book written by brian kernighan and
03:19 - dennis ritchie at times i add my own
03:21 - interpretation of the material from a
03:23 - historical perspective
03:25 - chapter 0 introduction
03:28 - c is a general purpose programming
03:30 - language it has been closely associated
03:32 - with the unix system since it was
03:34 - developed on that system and since unix
03:36 - and its software are written in c
03:38 - the language however is not tied to any
03:41 - one operating system or machine and
03:43 - although it has been called a system
03:45 - programming language because it is
03:47 - useful for writing operating systems it
03:49 - has been used equally well to write
03:51 - major numerical text processing and
03:54 - database programs
03:56 - c is a relatively low level language
03:58 - this characterization is not pejorative
04:01 - it simply means that c deals with the
04:02 - same sort of objects that most computers
04:05 - do namely characters numbers and
04:08 - addresses
04:09 - these may be combined and moved about
04:12 - with the usual arithmetic and logical
04:14 - operators implemented by actual machines
04:17 - c provides no operations to deal
04:19 - directly with composite objects such as
04:22 - character strings sets lists or arrays
04:25 - considered as a whole
04:26 - there is no analog for example of the
04:29 - pl1 operations which manipulate an
04:32 - entire array or string
04:34 - the language does not define any storage
04:36 - allocation facility other than static
04:38 - definition and the stack discipline
04:40 - provided by the local variables of
04:41 - functions there is no heap or garbage
04:44 - collection like that provided by algol
04:46 - 68.
04:48 - finally c itself provides no input
04:51 - output facilities there are no read or
04:53 - write statements and no wired in file
04:56 - access methods
04:57 - all of these higher level mechanisms
05:00 - must be provided by explicitly called
05:02 - functions
05:04 - i would note that the lack of a heap or
05:06 - garbage collection feature in c is both
05:09 - one of the great strengths of the
05:11 - language and at the same time is likely
05:13 - the reason that the average programmer
05:15 - will never develop or maintain a major c
05:18 - application during their career
05:20 - c provides a simple feature using malloc
05:23 - and free functions that allow a
05:25 - programmer to request a certain amount
05:27 - of memory be allocated dynamically use
05:29 - the memory and then return the memory to
05:32 - the c runtime library for reuse
05:34 - for example to convert a jpeg image to a
05:37 - png image our application will read the
05:39 - jpeg data into memory then convert the
05:42 - image into a png image in memory and
05:44 - then write the png data out to a file
05:47 - we don't know how large the images will
05:49 - be in advance so we request whatever
05:52 - size we need from c and then give it
05:54 - back when we're done
05:56 - the term heap refers to the memory that
05:59 - c manages on our behalf when we need to
06:01 - borrow a bit of memory and give it back
06:03 - later
06:04 - there are a couple of issues with a
06:06 - simple heap implementation
06:08 - first if we forget to call free when we
06:11 - are done with a memory we have created a
06:13 - memory leak and our program will
06:15 - eventually run out of memory and abort
06:18 - c places the onus of giving back any
06:20 - dynamically allocated memory on the
06:22 - programmer
06:24 - modern languages like java javascript
06:26 - and python keep track of when we stop
06:29 - using dynamic memory using a dynamic
06:31 - memory layer that can automatically
06:33 - reclaim the memory
06:36 - the more difficult problem is after a
06:38 - series of calls to malik and free the
06:40 - heap space becomes fragmented and some
06:42 - cleanup is needed this cleanup is called
06:45 - garbage collection
06:47 - efficient memory allocation and garbage
06:49 - collection has been the subject of
06:51 - decades of computer science research
06:54 - the java language has built a number of
06:57 - increasingly effective garbage
06:59 - collection approaches over the years
07:01 - kernighan and ritchie in one simple
07:03 - paragraph define most of the problem as
07:05 - out of scope for the c language which
07:08 - makes it a bit challenging for us to
07:10 - make good use of dynamic memory
07:11 - allocation in c but when we do it
07:13 - properly it performs very well
07:16 - if you are currently using a language
07:19 - like java python or php
07:22 - every time you create a new string
07:24 - through concatenation without thinking
07:26 - about memory allocation remember to
07:28 - appreciate the decades of work by
07:30 - computer scientists that made it easy
07:32 - for you
07:33 - kernighan and ritchie knew that garbage
07:35 - collection was difficult so they left it
07:38 - out of the c language and put it into a
07:40 - run time library
07:42 - back to chapter zero
07:44 - similarly c offers only straightforward
07:47 - single thread control flow constructions
07:50 - tests loops grouping and subprograms but
07:53 - not multi-programming parallel
07:55 - operations synchronization or
07:57 - co-routines
07:59 - though the absence of some of these
08:00 - features may seem like a grave
08:02 - deficiency you mean i have to call a
08:04 - function to compare two character
08:06 - strings
08:07 - keeping the language down to modest
08:09 - dimensions has brought real benefits
08:12 - since c is relatively small it can be
08:14 - described in a small space and learned
08:16 - quickly
08:17 - a compiler for c can be simple and
08:19 - compact compilers are also easily
08:22 - written using current technology one can
08:24 - expect to prepare a compiler for a new
08:26 - machine in a couple of months and to
08:28 - find that eighty percent of the code of
08:30 - a new compiler is common with existing
08:33 - ones
08:34 - this provides a high degree of language
08:36 - mobility because the data types and
08:38 - control structures provided by c are
08:40 - supported directly by most existing
08:42 - computers the runtime library required
08:45 - to implement self-contained programs is
08:47 - tiny on the pdp-11 for example it
08:50 - contains only the routines to do 32-bit
08:53 - multiplication and division and to
08:55 - perform subroutine entry and exit
08:57 - sequences
08:58 - of course each implementation provides a
09:01 - comprehensible compatible library of
09:03 - functions to carry out input output
09:05 - string handling and storage allocation
09:08 - operations but since they are only
09:10 - called explicitly they can be avoided if
09:12 - required and they can also be written
09:14 - portably in c itself
09:17 - again because the language reflects the
09:19 - capabilities of current computers c
09:21 - programs tend to be efficient enough
09:23 - that there is no compulsion to write
09:25 - assembly language instead the most
09:28 - obvious example of this is the unix
09:30 - operating system itself which is written
09:32 - almost entirely in c
09:34 - of 13 000 lines of system code only
09:38 - about 800 lines at the very lowest level
09:41 - are an assembler
09:42 - in addition essentially all of the unix
09:45 - application software is written in c
09:47 - the vast majority of unix users
09:50 - including one of the authors of this
09:52 - book do not even know the pdp-11
09:55 - assembly language
09:57 - i would note that in this preface the
09:59 - authors are carefully explaining the
10:01 - fact that many of the well-established
10:04 - programming languages of the 1960s and
10:06 - 1970s like fortran cobalt pascal algol
10:10 - and pl1 were solving many of the use
10:13 - cases that were needed by us programmers
10:16 - by adding syntax to the languages the
10:18 - creators of c and unix were advocating
10:20 - for a more minimal set of programming
10:22 - language constructs and more reliance on
10:24 - calling function in provided runtime
10:27 - libraries to meet programmer use cases
10:30 - it may have seemed a strange approach
10:32 - for experienced programmers in the 1980s
10:34 - but over time it has allowed c to expand
10:38 - to meet a very wide range of programmer
10:40 - needs without requiring major revisions
10:42 - to the core language or
10:44 - compiler back to chapter 0.
10:47 - although c matches the capabilities of
10:50 - many computers it is independent of any
10:52 - particular machine architecture and so
10:54 - with a little care it is easy to write
10:57 - portable programs that is programs which
10:59 - can be run without change on a variety
11:01 - of hardware
11:03 - it is now routine in our environment
11:05 - that software developed on unix is
11:06 - transported to local honeywell ibm and
11:09 - inner data systems in fact the c
11:12 - compilers and runtime support on these
11:14 - four machines are much more compatible
11:16 - than the supposedly ansi standard
11:19 - versions of fortran the unix operating
11:21 - system itself now runs on both the
11:24 - pdp-11 and the interdata 832
11:27 - outside of programs which are
11:29 - necessarily somewhat machine dependent
11:31 - like the compiler assembler and debugger
11:34 - software written in c is identical on
11:36 - both machines
11:37 - within the operating system itself the 7
11:40 - 000 lines of code outside of the
11:42 - assembly language support and the i o
11:44 - device handlers is about 95 percent
11:46 - identical
11:49 - as a note before unix and c if you are
11:51 - running the vendor operating system and
11:54 - writing in the best language for systems
11:56 - like the pdp 11 and inner data 732 the
11:59 - user experience was completely different
12:02 - today we take for granted that we expect
12:04 - to be able to download the same
12:06 - application for windows mac os or a
12:09 - linux system even in the 1970s those
12:12 - that were using unix and c could write
12:14 - code once and move it between two
12:16 - hardware platforms and expect that it
12:19 - would work with no or relatively few
12:22 - changes
12:23 - back to chapter zero
12:25 - for programmers familiar with other
12:26 - languages it may prove helpful to
12:29 - mention a few historical technical and
12:31 - philosophical aspects of c for contrast
12:34 - and comparison
12:36 - many of the most important ideas of c
12:38 - stem from the considerably older but
12:40 - still quite vital language bcpl
12:43 - developed by martin richards the
12:45 - influence of bcpl on c proceeded
12:48 - indirectly through the language b which
12:50 - was written by ken thompson in 1970 for
12:53 - the first unix system on the pdp-7
12:57 - although it shares several
12:58 - characteristic features with bcpl c is
13:01 - in no sense a dialect of it
13:03 - bcpl and b are typeless language
13:06 - the only data type is the machine word
13:09 - and access to other kinds of objects is
13:11 - by special operators or function calls
13:14 - in c the fundamental data objects are
13:16 - characters integers of several sizes and
13:19 - floating point numbers in addition there
13:22 - is a hierarchy of derived data types
13:24 - created with pointers arrays structures
13:26 - unions and functions
13:29 - c provides the fundamental control
13:31 - constructions required for
13:32 - well-structured programs
13:34 - statement grouping decision making with
13:36 - if
13:37 - looping with termination test at the top
13:39 - using for and while or at the bottom
13:41 - using do and selecting one of a set of
13:44 - possible cases switch
13:46 - all of these were provided in bcpl as
13:48 - well
13:49 - though with somewhat different syntax
13:51 - that language anticipated the vogue for
13:54 - structured programming by several years
13:57 - c provides pointers in the ability to do
13:59 - address arithmetic the arguments to
14:01 - functions are passed by copying the
14:03 - value of an argument and is impossible
14:05 - for the called function to change the
14:07 - actual argument in the caller
14:09 - when it is desired to achieve call by
14:11 - reference a pointer may be passed
14:13 - explicitly and the function may change
14:15 - the object to which the pointer points
14:17 - array names are passed as the location
14:20 - of the array origin so array arguments
14:22 - are effectively call by reference
14:25 - any function can be called recursively
14:27 - and its local variables are typically
14:29 - automatic or created anew with each
14:32 - invocation
14:33 - function definitions may not be nested
14:35 - but variables may be be declared in a
14:38 - block structured fashion
14:39 - the functions of a c program may be
14:42 - compiled separately
14:43 - variables may be internal to a function
14:46 - external but known only within a single
14:48 - source file or completely global
14:50 - internal variables may be automatic or
14:52 - static
14:53 - automatic variables may be placed in
14:55 - registers for increased efficiency but
14:58 - the register declaration is only a hint
15:00 - to the compiler and does not refer to
15:02 - specific machine registers
15:06 - c is not a strongly typed language in
15:08 - the sense of pascal or algol 68 it is
15:11 - relatively permissive about data
15:13 - conversion although it will not
15:15 - automatically convert data types with
15:16 - the wild abandon of pl1
15:19 - existing compilers provide no run time
15:21 - checking of array subscripts or argument
15:24 - types
15:24 - etc for those situations where strong
15:27 - type checking is desirable a separate
15:29 - version of the compiler is used this
15:31 - program is called lint
15:33 - apparently because it picks up bits of
15:35 - fluff from one's program lint does not
15:38 - generate code but instead
15:40 - applies a very strict check as to many
15:43 - aspects of the program as can be
15:45 - verified at compile and load time it
15:48 - detects
15:48 - type mismatches inconsistent argument
15:51 - use
15:52 - unused or apparently uninitialized
15:55 - variables potential portability
15:57 - difficulties and the like programs which
15:59 - pass unscathed through lint enjoy with
16:02 - few exceptions freedom from type errors
16:05 - about as complete as do for example
16:07 - alcohol 68 programs we will mention
16:10 - other lint capabilities as the
16:12 - occasion arises
16:14 - i would note that separately checking
16:16 - for things that might be wrong into the
16:18 - lint program keeps the c compiler simple
16:21 - and easy to port to a new computer
16:24 - the lint program was naturally a very
16:26 - portable text processing application
16:29 - while there's some overlap between a
16:31 - lint program and a compiler
16:34 - over time there's quite distinct
16:35 - research and expertise in how to lint
16:38 - versus how to compile
16:40 - modern lint programs look at programs in
16:42 - far more detail than most compilers
16:45 - separating concerns of lint and the c
16:47 - compiler also allowed lint programs to
16:51 - use more memory and take more time to
16:53 - execute than compilers
16:55 - since the typical developer might use
16:57 - the compiler many times per day and run
16:59 - lint less often it was nice for the
17:01 - compiler to run quickly and make light
17:03 - use of computer resources
17:06 - we call this idea of building two
17:08 - smaller complementary programs that each
17:10 - specialize in one task
17:12 - separation of concerns and it is an
17:14 - important principle in computer science
17:17 - by keeping each component simple in
17:18 - focus we can more easily build test and
17:22 - verify each component
17:24 - unix and c showed the benefits of taking
17:27 - many small components approach to solve
17:29 - an overall set of problems
17:32 - back to chapter zero
17:34 - finally
17:35 - c like any other language has its
17:37 - blemishes some of the operators have the
17:39 - wrong precedence
17:41 - some of the syntax could be better there
17:43 - are several versions of the language
17:45 - extent differing in minor ways
17:48 - nonetheless c has proven to be an
17:50 - extremely effective and expressive
17:52 - language for a wide variety of
17:54 - programming applications
17:56 - the rest of this book is organized as
17:58 - follows chapter 1 is a tutorial
18:00 - introduction to the central part of c
18:03 - the purpose is to get the reader started
18:05 - as quickly as possible since we believe
18:07 - strongly that the only way to learn a
18:09 - new language is to write programs in it
18:12 - this tutorial does assume a working
18:14 - knowledge of the basic elements of
18:16 - programming there is no explanation of
18:18 - computers of compilation nor the meaning
18:22 - of an expression like n equals n plus
18:23 - one
18:24 - although we have tried where possible to
18:26 - show useful programming techniques the
18:28 - book is not intended to be a reference
18:30 - work on data structures and algorithms
18:33 - when forced to make a choice we have
18:34 - concentrated on the language
18:38 - chapters two through six discuss the
18:39 - various aspects of c in more detail and
18:42 - rather more formally than does chapter 1
18:44 - although the emphasis is still on
18:46 - working examples of complete useful
18:48 - programs rather than isolated fragments
18:51 - chapter 2 deals with basic data types
18:54 - operators and expressions and chapter 3
18:56 - treats control flow if else while 4 etc
19:01 - chapter 4 covers functions and program
19:03 - structure external variables scope rules
19:06 - and so on
19:07 - chapter 5 discusses pointers and address
19:09 - arithmetic and chapter 6 contains the
19:12 - details of structures and unions
19:14 - chapter 7 describes the standard cio
19:17 - library which provides a common
19:19 - interface to the operating system this
19:21 - io library is supported on all machines
19:23 - that support c so programs which use it
19:26 - for input output and other system
19:28 - functions can be moved from one system
19:30 - to another
19:32 - essentially without change
19:34 - chapter eight describes the interface
19:36 - between c programs
19:38 - and the unix operating system
19:40 - concentrating on input output the file
19:42 - system and portability
19:44 - although some of this chapter is unix
19:46 - specific programmers who are not using
19:48 - unix systems should still find useful
19:50 - material here
19:51 - including some insight on how one
19:53 - version of the standard library is
19:55 - implemented and suggestions on achieving
19:57 - portable code
19:59 - appendix a contains the c reference
20:01 - manual this is the official statement of
20:03 - the syntax and semantics of c and except
20:07 - for one owns compiler the final arbiter
20:09 - of any ambiguities and omissions from
20:11 - earlier chapters
20:13 - since c is an evolving language that
20:15 - exists on a variety of systems some of
20:17 - the material in this book may not
20:19 - correspond to the current state of
20:21 - developments for a particular system
20:23 - we have tried to steer clear of such
20:26 - problems and warn of potential
20:27 - difficulties when in doubt however we
20:30 - have chosen generally to describe the
20:32 - pdp-11 unix system
20:34 - since that is the environment of the
20:36 - majority of c programmers appendix a
20:38 - also describes implementation
20:40 - differences on the major c systems
20:46 - chapter 1 a tutorial introduction
20:48 - let us begin with a quick introduction
20:50 - to c our aim is to show the essential
20:53 - elements of the language in real
20:54 - programs but without getting bogged down
20:57 - in details formal rules and exceptions
21:00 - at this point we are not trying to be
21:02 - complete or even precise
21:05 - we want you to get as quickly as
21:07 - possible to the point where you can
21:08 - write useful programs
21:10 - and to do that we have to concentrate on
21:12 - the basics
21:14 - variables and constants arithmetic
21:16 - control flow functions and the rudiments
21:18 - of input and output
21:20 - we are quite intentionally leaving out
21:22 - of this chapter features of c which are
21:25 - of vital importance for writing bigger
21:27 - programs these include pointers
21:30 - structures and most of c's rich set of
21:33 - operators
21:34 - several control flow statements and a
21:36 - myriad of details
21:39 - this approach has its drawbacks of
21:41 - course
21:42 - most notable is that the complete story
21:44 - on any particular language feature is
21:46 - not found in a single place
21:48 - the tutorial by being brief may also
21:51 - mislead
21:52 - and because they cannot use the full
21:54 - power of c the examples are not as
21:57 - concise and elegant as they might be
21:59 - we have tried to minimize these effects
22:02 - but be warned
22:03 - another drawback is that later chapters
22:05 - will necessarily repeat some of this
22:07 - chapter
22:08 - in any case experienced programmers
22:11 - should be able to extrapolate from the
22:12 - material in this chapter to their own
22:14 - programming needs
22:16 - beginners should supplement it by
22:17 - writing small similar programs of their
22:19 - own
22:20 - both groups can use it as a framework on
22:23 - which to hang the more detailed
22:24 - descriptions that begin in chapter 2.
22:27 - 1.1 getting started
22:31 - the only way to learn a new programming
22:32 - language is by writing programs in it
22:35 - the first program to write is the same
22:37 - for all languages print the words hello
22:41 - world
22:42 - this is the basic hurdle
22:44 - to leap over it you have to be able to
22:46 - create the program text somewhere
22:48 - compile it successfully
22:50 - load it
22:51 - run it and find out where your output
22:53 - went
22:54 - with these mechanical details mastered
22:57 - everything else is comparatively easy
23:01 - in traditional c
23:02 - the program to print hello world is
23:06 - main open parenthesis closed parenthesis
23:09 - open curly brace
23:11 - printf parentheses double quote hello
23:14 - comma space world backslash n double
23:17 - quote
23:18 - close parentheses semicolon close curly
23:21 - brace
23:23 - the modern minimal version of this
23:24 - program needs a bit more syntax we add a
23:27 - single line at the beginning
23:30 - hashtag
23:31 - include space
23:33 - left angle brackets
23:36 - stdio.h right angle bracket pound
23:39 - include
23:40 - stdio.h we have to add that line for the
23:43 - modern program
23:45 - back to the book
23:47 - just how to run this program depends on
23:49 - the system that you're using
23:51 - as a specific example on the unix
23:53 - operating system you must create the
23:56 - source program in a file whose name ends
23:58 - in dot c such as hello dot c
24:02 - and then you compile it with the command
24:04 - cc
24:06 - space hello.c
24:08 - if you haven't botched anything such as
24:10 - omitting a character or misspelling
24:12 - something the compilation will proceed
24:14 - silently and make an executable file
24:17 - called a dot out
24:19 - running that by the command
24:21 - a dot out will produce hello comma world
24:24 - as its output
24:26 - on other systems the rules will be
24:28 - different check with a local expert on
24:32 - modern systems we use the gcc compiler
24:35 - with the dash ansi option to accept the
24:37 - legacy syntax of c
24:40 - so we use gcc space minus ansi
24:44 - space hello.c
24:47 - and to run the resulting a dot out file
24:49 - you usually you need to prepend the
24:51 - local directory because most shell
24:54 - configurations do not include the
24:55 - current path in the paths to search for
24:58 - applications so you need to write
25:00 - dot slash a dot out
25:05 - now for some explanations about the
25:07 - program itself
25:08 - a c program whatever its size consists
25:12 - of one or more functions which specify
25:14 - the actual computing operations that are
25:16 - to be done
25:18 - c functions are similar to functions and
25:20 - subroutines of a fortran program or the
25:23 - procedures of pl1 pascal etc
25:27 - in our example main is such a function
25:30 - normally you are at liberty give
25:32 - functions whatever names you like but
25:34 - main is a special name
25:36 - your program begins executing at the
25:38 - beginning of main
25:40 - this means every program must have a
25:42 - main somewhere
25:44 - main will usually invoke other functions
25:46 - to perform its job
25:48 - some coming from the same program and
25:51 - others from libraries of previously
25:53 - written functions
25:55 - one method of communicating data between
25:58 - functions is by arguments
26:00 - the parentheses following the function
26:02 - name surround the argument list here
26:05 - main is a function of no arguments
26:08 - indicated by open parentheses close
26:11 - parentheses
26:12 - the curly braces enclose the statements
26:15 - that make up the function they're
26:17 - analogous to the due end of pl1 or the
26:20 - begin end of algol or pascal and so on
26:24 - a function is invoked by naming it
26:27 - followed by a parenthesized list of
26:29 - arguments
26:30 - there is no call statement as there is
26:33 - in fortran or pl1 the parentheses must
26:36 - be present even if there are no
26:38 - arguments
26:40 - in the above text the authors were
26:42 - making connections to the popular
26:44 - general purpose programming languages of
26:46 - the time
26:47 - when the book was written it was not all
26:49 - assured that c and c like languages
26:52 - would ever evolve past writing high
26:54 - performance applications
26:56 - like operating system kernels and device
26:58 - drivers
26:59 - by comparing c to these more general
27:02 - purpose languages the authors are trying
27:04 - to plant the seed that c could have
27:07 - value as a general purpose language
27:10 - back to the text
27:12 - the line that says
27:13 - printf parentheses double quote hello
27:16 - comma space world backslash and double
27:19 - quote close parentheses semicolon
27:22 - is a function call
27:24 - which calls a function named printf
27:27 - with the argument
27:28 - hello world
27:30 - printf is a library function which
27:31 - prints the output to the terminal unless
27:34 - some other destination is specified
27:37 - in this case it prints the string of
27:38 - characters that make up its argument
27:42 - any sequence of any number of characters
27:44 - enclosed in double quotes is called a
27:46 - character string or string constant
27:50 - for the moment our only use of the
27:52 - character strings will be as arguments
27:54 - to printf and other functions
27:56 - the sequence backslash n
27:59 - in the string is c notation for the new
28:02 - line character
28:03 - which when printed advances the terminal
28:06 - to the left margin on the next line
28:08 - if you leave out the backslash n
28:11 - a worthwhile experiment by the way you
28:13 - will find that your output is not
28:15 - terminated by a line feed the only way
28:17 - to get a new line character into the
28:19 - printf argument is with backslash n
28:23 - if you try to break it into two lines
28:26 - like printf quote hello world and then
28:29 - just hit the return
28:31 - double quote
28:33 - close parentheses
28:35 - semicolon on a new line the c compiler
28:37 - will print out unfriendly diagnostics
28:39 - about missing quotes
28:41 - printf never supplies a new line
28:43 - automatically so multiple calls can be
28:46 - used to build up an output line in
28:47 - stages
28:49 - our first program could have just as
28:51 - well been written as
28:53 - main open parenthesis closed parenthesis
28:55 - open curly brace
28:57 - printf quote hello quote
29:00 - semicolon
29:02 - printf quote world quote semicolon print
29:05 - f backslash n semicolon and then on a
29:10 - sixth line closed curly brace and it
29:12 - would have produced the identical output
29:15 - note that backslash n represents only a
29:18 - single character an escape sequence like
29:20 - backslash n provides a general and
29:23 - extensible mechanism for representing
29:25 - hard to get or invisible characters
29:28 - among the others that c provides are
29:30 - backslash t for tab
29:32 - backslash b for backspace
29:35 - backslash double quote for double quote
29:37 - and backslash backslash for the
29:39 - backslash itself
29:42 - 1.2
29:43 - page 8
29:45 - variables and arithmetic
29:47 - the next program prints the following
29:49 - table of fahrenheit temperatures in
29:51 - their centigrade or celsius equivalents
29:53 - using the formula c equals parenthesis 5
29:56 - divided by 9
29:58 - closed parenthesis parenthesis f minus
30:00 - 32.
30:03 - the table contains fahrenheit of 0
30:05 - celsius of negative 17.8 fahrenheit at
30:08 - 20 celsius of negative 6.7 fahrenheit of
30:12 - 40 celsius of 4.4 and so forth here is
30:16 - the program itself
30:18 - for reference this program is on page 29
30:22 - of the textbook
30:25 - so it starts with pound include stdio.h
30:29 - to include the standard library then it
30:31 - has a comment that says print the
30:32 - fahrenheit celsius table for f equals
30:35 - zero comma twenty comma dot dot dot
30:37 - comma three hundred
30:40 - close comment
30:42 - main open parenthesis close parenthesis
30:45 - open curly brace
30:47 - int
30:48 - lower comma upper comma step semicolon
30:52 - float
30:53 - far
30:54 - comma celsius
30:56 - lower equals zero semicolon followed by
30:59 - a comment
31:01 - upper equals 300 semicolon followed by a
31:04 - comment
31:05 - step equals 20 semicolon followed by a
31:08 - comment
31:10 - far equals lower
31:12 - and then
31:14 - while open parenthesis far less than or
31:17 - equal to upper closed parenthesis open
31:19 - curly brace
31:21 - celsius equals parenthesis 5.0 slash 9.0
31:26 - closed parenthesis
31:28 - asterisk
31:30 - open parenthesis far minus 32.0
31:34 - close parentheses semicolon
31:38 - then a printf statement printf open
31:41 - parentheses double quote percent 4.0 f
31:46 - space percent 6.1 f
31:50 - backslash n close quote comma far
31:53 - comma celsius
31:55 - close parentheses semicolon
31:58 - far equals far plus step
32:03 - and then a closing curly brace to finish
32:05 - the while statement and then a closing
32:07 - curly brace to finish the main statement
32:11 - the first two lines
32:13 - slash star print fahrenheit to celsius
32:16 - table for f equals zero comma twenty dot
32:19 - dot dot three hundred
32:21 - star slash are a comment
32:24 - which in this case explains briefly what
32:26 - the program does any characters between
32:30 - star and star slash are ignored by the
32:32 - compiler they may be used to freely make
32:35 - the program easier to understand
32:38 - comments may appear anywhere a blank or
32:40 - new line can
32:42 - in c all variables must be declared
32:45 - before use
32:46 - usually at the beginning of a function
32:49 - before any executable statements
32:51 - if you forget a declaration you will get
32:53 - a diagnostic from the compiler a
32:56 - declaration considered consists of a
32:58 - type and a list of variables that have
33:01 - that type as in
33:02 - int
33:03 - lower comma upper comma step semicolon
33:07 - float far celsius semicolon
33:11 - the type int
33:13 - implies that the variables listed are
33:15 - integers
33:16 - float stands for floating point i.e
33:19 - numbers which may have a fractional part
33:22 - the precision of both int and float
33:24 - depends on the particular machine that
33:26 - you are using
33:27 - on the pdp-11 for instance an int is a
33:30 - 16-bit signed number
33:32 - that is one that lies between negative
33:35 - 32
33:37 - eight
33:38 - and positive thirty two thousand seven
33:40 - sixty seven
33:42 - a float number is a thirty two bit
33:44 - quantity which amounts to about seven
33:46 - significant digits with a magnitude of
33:49 - about ten to the minus thirty eight
33:51 - and
33:53 - 10 plus 38.
33:55 - chapter 2 lists the sizes
33:58 - for other machines
34:00 - i would note that the 1970s was a time
34:03 - of transition in the amount of memory
34:05 - installed in computers
34:06 - the c language int type was 16 bits in
34:10 - the older but more generally available
34:11 - computers like the pdp-11
34:14 - c could be used to write programs like
34:16 - the unix operating system that made
34:18 - efficient use of available memory in
34:21 - particular the 1978 version of c did not
34:25 - require that computers support 32-bit
34:27 - integers
34:29 - but
34:30 - 32768 is a pretty small number the size
34:33 - of an integer affected the maximum size
34:35 - of arrays and strings
34:37 - a lot of early c programs use the long
34:40 - type to get at least a 32-bit integer
34:42 - capable of representing numbers up to
34:45 - about 2 billion
34:47 - in modern modern computers and databases
34:49 - we tend to choose between 32-bit and
34:52 - 64-bit integers
34:54 - back to the text
34:55 - c provides several other basic data
34:58 - types besides int and float
35:00 - char
35:01 - is a character a single byte short is a
35:04 - short integer
35:06 - long is a long integer and double is a
35:09 - double precision floating point
35:12 - size of these objects are also machine
35:14 - dependent and details are in chapter 2.
35:17 - there are also arrays structures and
35:19 - unions of these basic types and pointers
35:22 - to them and functions that return them
35:24 - all of which we will meet in due course
35:28 - the actual computation in our
35:29 - temperature conversion program begins
35:31 - with the assignments lower equals zero
35:34 - upper equals 300 step equals 20
35:38 - far equals lower all ending with
35:40 - semicolon
35:42 - these set the variables to their
35:44 - starting vari values
35:46 - individual statements are terminated by
35:48 - semicolons
35:50 - each line of the table is computed in
35:52 - the same way so we use a loop which
35:54 - repeats once per line this is the
35:57 - purpose of the while statement
36:00 - while parentheses far less than or equal
36:03 - upper close parentheses open curly brace
36:06 - then the body of the loop and then close
36:08 - curly brace
36:10 - the condition in the parentheses is
36:12 - tested if it is true i.e far is less
36:15 - than or equal to upper the body of the
36:17 - loop
36:18 - all of the statements included between
36:20 - the open curly brace and the closed
36:22 - curly brace are executed
36:24 - and the condition is retested if true
36:27 - the body is executed again
36:29 - when the test becomes false i.e
36:32 - far exceeds upper the loop ends and
36:35 - execution continues at the statement
36:36 - that follows the loop
36:38 - there are no further statements in the
36:40 - program so it terminates
36:43 - the body of a while loop can be one or
36:45 - more statements enclosed in braces as
36:47 - the temperature converter
36:49 - or a single statement without braces as
36:52 - in
36:53 - while open parentheses i less than j
36:56 - closed parenthesis i equals two times i
36:59 - semicolon
37:01 - in either case the statements controlled
37:03 - by the while are indented by one tab
37:06 - stop so you can see at a glance what
37:09 - statements are inside the loop
37:11 - the indentation emphasizes the logical
37:14 - structure of the program
37:16 - although c is quite permissive about
37:18 - statement positioning proper indentation
37:21 - and the use of white space are critical
37:23 - in making programs easy for people to
37:25 - read
37:26 - we recommend writing only one statement
37:29 - per line and usually leaving blanks
37:31 - around operators the position of the
37:34 - braces is less important we have chosen
37:37 - one of the several popular styles pick a
37:40 - style that suits you and then use it
37:42 - consistently
37:45 - i would add that with these words the
37:47 - authors triggered a great debate about
37:50 - how to best indent code and use curly
37:53 - braces that continues to this day
37:55 - the intention style used in this book is
37:58 - often referred to as the k and r style
38:01 - it tends to put open braces at the end
38:03 - of statements like if and while to keep
38:06 - code more compact in terms of the number
38:08 - of lines of code
38:09 - the best advice is not to debate at all
38:13 - when you modify someone else's code just
38:15 - imitate the style that they used when
38:17 - they wrote their code
38:20 - back to the text
38:24 - most of the work gets done in the body
38:26 - of the loop
38:27 - the celsius temperature is computed and
38:29 - assigned to the celsius variable by the
38:31 - statement celsius equals open
38:34 - parenthesis 5.0 slash 9.0 close
38:38 - parenthesis
38:39 - asterisk open parenthesis far
38:42 - minus
38:43 - 32.0 close parentheses semicolon
38:46 - the reason for using 5.0
38:49 - 9.0 instead of the simpler looking five
38:52 - slash nine is that in c as in many other
38:55 - languages
38:56 - integer division truncates so that any
38:59 - fractional part is discarded thus
39:02 - five slash nine
39:04 - is zero
39:05 - and of course so would then all the
39:07 - temperatures be zero
39:09 - a decimal point in a constant indicates
39:11 - that it is floating point so that 5.0
39:15 - over 9.0 is
39:18 - 0.555 repeating which is what we want
39:22 - we also wrote 32.0 instead of 32
39:26 - even though since far is a float 32
39:29 - would automatically be converted to flow
39:31 - before the subtraction
39:33 - but as a matter of style it's wise to
39:35 - write floating point constants with
39:37 - explicit decimal points even when they
39:39 - have integral values it emphasizes their
39:42 - floating point nature for human readers
39:45 - and ensures the compiler will see things
39:47 - the way you do as well
39:49 - i would note that for those of you
39:51 - familiar with python
39:53 - before python 3
39:55 - integer division truncated and returned
39:58 - an integer just like c
40:01 - in python 3 one of the major
40:03 - improvements was that the division of
40:05 - two integers performed the division
40:07 - operation in floating point and returns
40:10 - a floating point result
40:13 - c and python 2 made the choice because
40:16 - of efficiency
40:17 - integer division with truncation
40:19 - especially for 16-bit numbers was quite
40:21 - fast in the 1970s computers compared to
40:24 - floating point division that kept the
40:26 - fractional part intact
40:29 - early pdp-11 computers did integer
40:31 - division in hardware
40:33 - while all floating point was done with
40:35 - loops and functions so it was far slower
40:38 - if you wanted to write fast code in the
40:40 - 1970s you avoided floating point numbers
40:43 - except for special situations
40:47 - modern computers usually do 64-bit
40:49 - floating-point operations almost at the
40:52 - same speed as integer division so we
40:54 - don't need to allow programmers to avoid
40:56 - using floating point computations in
40:59 - their code
41:00 - the detailed rules for when integers are
41:02 - converted to floating point are in
41:04 - chapter 2.
41:05 - for now notice that the assignment far
41:09 - equals lower semicolon
41:11 - and the test while far less than or
41:14 - equals upper
41:15 - both work as expected the int is
41:18 - converted to a float before the
41:19 - operation is done
41:22 - this example also shows a bit more of
41:25 - how printf works printf is actually a
41:28 - general purpose format conversion
41:30 - function
41:31 - which we will describe completely in
41:33 - chapter 7.
41:34 - its first argument is a string of
41:36 - characters to be printed with each
41:39 - percent sign indicating where one of the
41:42 - other second third etc arguments is to
41:45 - be substituted and what form it is to be
41:47 - printed in
41:49 - for instance in the statement
41:51 - printf
41:52 - parentheses double quote percent 4.0 f
41:56 - space percent 6.1 f
41:59 - backslash n double quote comma far comma
42:02 - celsius
42:03 - the conversion specification percent 4.0
42:07 - f says that a floating point number is
42:09 - to be printed in a space at least four
42:11 - characters wide with no digits after the
42:14 - decimal point percent 6.1 f describes
42:19 - another number to occupy at least six
42:21 - spaces with one digit after the decimal
42:24 - point
42:25 - analogous to the f 6.1 of fortran
42:29 - or the f parentheses six comma one of
42:32 - pl1
42:34 - parts of a specification may be omitted
42:37 - percent six f says that the number is to
42:39 - be at least six characters wide
42:42 - percent.2f requests two places after the
42:45 - decimal point but the width is not
42:47 - constrained
42:49 - and merely
42:50 - percent f says to print the number
42:52 - itself as floating point
42:54 - printf also recognizes percent d for
42:57 - decimal integers percent o for octal
43:00 - percent x for hexadecimal and percent c
43:02 - for characters and percent s for a
43:05 - character string and percent percent for
43:08 - the percent itself
43:10 - each percent construction in the first
43:13 - argument of printf is paired with its
43:15 - corresponding second third etc
43:18 - argument
43:19 - they must line up properly by number and
43:21 - type or else you'll get meaningless
43:23 - answers
43:25 - by the way
43:26 - printf is not part of the c language
43:29 - there is no input or output defined in c
43:31 - itself
43:33 - there is nothing magic about printf it's
43:35 - just a useful function which is part of
43:38 - the standard library of routines that
43:40 - are normally accessible to c programs
43:43 - in order to concentrate on c itself we
43:45 - might we won't talk much about io
43:49 - until chapter seven
43:51 - in particular we'll defer formatted
43:54 - input until then
43:55 - if you have to input numbers read the
43:58 - discussion of the function scanf in
44:00 - chapter 7 section 7.4
44:03 - scanf is much like printf except that it
44:06 - reads input instead of writing output
44:09 - the balance between building a feature
44:12 - into the language itself and providing
44:14 - it as a function in a library is
44:16 - something that computer language
44:17 - designers struggle with many years later
44:20 - for example in python 2
44:23 - print was a language element
44:26 - in python 3 one of the non-upwards
44:28 - compatible and somewhat unpopular
44:30 - changes was changing print to be a
44:33 - function
44:34 - many programmers feel that a print
44:36 - statement is a more elegant way to
44:38 - express printing but from a compiler and
44:40 - language design perspective a function
44:43 - call with a variable number of
44:44 - parameters is seen as technically more
44:46 - elegant and flexible
44:49 - with kernighan and richie focused on
44:51 - keeping everything small and portable
44:53 - they opted to keep all input output
44:55 - functionality in libraries the syntax is
44:58 - a little more complex
45:00 - but given how computing has changed in
45:02 - the past 30 years it is the right choice
45:06 - section 1.3 the for statement
45:09 - as you might expect there are plenty of
45:11 - different ways to write a program let's
45:13 - try a variation on the temperature
45:15 - converter
45:16 - this is sample code is on page 11 of the
45:19 - textbook
45:21 - pound sign include less than stdio.h
45:24 - greater than
45:26 - main open parentheses closed parenthesis
45:29 - open curly brace
45:31 - int
45:33 - bar that is f a h r semicolon
45:38 - four open parenthesis far equals zero
45:41 - semicolon
45:42 - far less than or equal to three hundred
45:45 - semicolon
45:46 - far equals far plus 20 close parenthesis
45:50 - printf
45:51 - open parentheses
45:53 - double quote percent 4d space percent
45:56 - 6.1 f backslash n close print a close
46:00 - quote
46:02 - comma far
46:05 - comma open parenthesis 5.0 slash 9.0
46:09 - close parentheses
46:10 - asterisk open parenthesis far minus 32
46:14 - close parentheses close parenthesis
46:17 - semicolon
46:19 - this code produces the same answers as
46:21 - the one before but it certainly looks
46:22 - different one major change is the
46:24 - elimination of most of the variables
46:26 - only far fahr remains as an int to show
46:30 - the percent d conversion in printf
46:33 - the lower and upper limits of the step
46:35 - size appear only as constants in the for
46:37 - statement itself
46:39 - the 4 is a new construction and the
46:41 - expression that computes the celsius
46:43 - temperature now appears as the third
46:45 - argument of printf
46:46 - instead of in a separate assignment
46:48 - statement
46:51 - this last change is an instance of a
46:53 - quite general rule in c in any context
46:57 - where it is permission permissible to
46:59 - use the value of a variable of some type
47:01 - you can use an expression of that type
47:04 - since the third argument of printf has
47:07 - to be a floating point value to match
47:08 - the percent 6.1 f
47:11 - any floating point expression can occur
47:14 - there
47:15 - the 4 itself is a loop a generalization
47:19 - of while
47:20 - if you compare it to the earlier while
47:22 - its operation should be clear
47:24 - it contains three parts separated by
47:27 - semicolons the first part far equals
47:29 - zero is done once
47:31 - before the loop proper is entered the
47:33 - second part is the test or condition
47:35 - that controls the loop
47:37 - far less than or equal to 300.
47:40 - this condition is evaluated if it is
47:42 - true the body of a loop in this case a
47:45 - single printf is executed then the
47:47 - reinitialization step
47:49 - far equals far plus 20 is done and the
47:52 - condition is reevaluated
47:54 - the loop terminates when the condition
47:56 - becomes false
47:57 - as with the while the body of the loop
48:00 - can be a single statement or a group of
48:02 - statements enclosed in braces
48:04 - the initialization and re-initialization
48:07 - parts can be any single expression
48:10 - the choice between while and four is
48:12 - arbitrary and should be based on what
48:14 - seems clearer
48:15 - the four is usually appropriate for
48:17 - loops in which the initialization and
48:19 - reinitialization
48:20 - are single statements and logically
48:22 - related since it is more compact than
48:24 - while and keeps the loop control
48:27 - statements together in one place
48:31 - i would note that the syntax of the for
48:33 - and while loop is a feature of c and
48:36 - derived c like languages
48:38 - in modern languages we tend to have two
48:41 - kinds of loop structures
48:42 - determinant and indeterminate
48:45 - the four and the while loop structures
48:47 - in c are both indeterminate because you
48:50 - must read them closely to make sure they
48:52 - are properly constructed and for example
48:55 - are not unintentionally infinite loops
48:58 - an example of a determinant loop is the
49:01 - for each loop in php or the for loop in
49:04 - python the semantics of both of these
49:06 - loops is to iterate all the elements in
49:08 - a collection
49:10 - but since collections are never infinite
49:13 - you can be assured that these
49:14 - determinant loops will not run forever
49:17 - section 1.4 symbolic constants
49:21 - a final observation before we leave
49:23 - temperature conversion
49:25 - it's a bad practice to bury magic
49:27 - numbers or magic constants like 320
49:31 - or
49:32 - 320 in a program they convey little
49:35 - information to someone who might read
49:36 - the program later and they're hard to
49:39 - change in a systematic way
49:41 - fortunately
49:42 - c provides a way to avoid such magic
49:45 - numbers
49:46 - with the pound sign defined construction
49:48 - at the beginning of a program we can
49:50 - define a symbolic name or symbolic
49:52 - constant to be a particular string of
49:55 - characters thereafter the compiler will
49:57 - replace all unquoted occurrences of the
50:00 - name by the corresponding string
50:02 - the replacement for the name can
50:04 - actually be any text at all it's not
50:06 - related to numbers
50:09 - so this is a sample code on page 13 of
50:12 - the text
50:13 - pound sign include
50:16 - less than stdio.h greater than
50:20 - next line pound define space lower space
50:23 - zero
50:24 - next line pound define space upper space
50:28 - 300
50:29 - pound define space step space 20.
50:33 - for these pound sign statements i would
50:35 - note
50:36 - that they have to start in the first
50:38 - column
50:40 - the rest of this sample code is the code
50:42 - itself
50:43 - main open parenthesis closed parenthesis
50:45 - open curly brace
50:47 - int
50:48 - far fahr
50:51 - for
50:52 - open parentheses far equals uppercase
50:55 - lower
50:56 - semicolon far less than or equal to
51:00 - uppercase upper
51:02 - semicolon far equals far plus uppercase
51:06 - step then the same print statement
51:09 - printf
51:10 - open parentheses double quote percent 4d
51:13 - space percent 6.1 f backslash n quote
51:17 - comma
51:18 - far
51:19 - comma
51:20 - percent 5.0 9.0
51:24 - close parentheses asterisk open
51:27 - parenthesis
51:28 - far minus 32 close parenthesis close
51:30 - parenthesis semicolon and then to end
51:33 - the program close curly brace the
51:36 - quantities uppercase lower uppercase
51:38 - upper and uppercase step are constants
51:41 - so they do not appear in declarations
51:44 - symbolic names are commonly written in
51:46 - uppercase so they can be readily
51:48 - distinguished from lowercase variable
51:50 - names
51:51 - notice that there is no semicolon at the
51:54 - end of a pound defined statement
51:56 - since the whole line after the defined
51:58 - name is substituted there would be too
52:00 - many semicolons in the four
52:03 - section 1.5 a collection of useful
52:06 - programs
52:07 - we are now going to consider a family of
52:09 - related programs for doing simple
52:11 - operations on character data
52:14 - you will find that many programs are
52:15 - just expanded versions of the prototypes
52:18 - we discuss here
52:19 - character input and output
52:22 - the standard library provides functions
52:23 - for reading and writing a character at a
52:25 - time getchar
52:27 - fetches the next input character each
52:30 - time it is called and returns the
52:32 - character as its value that is
52:34 - after c equals get char open parentheses
52:38 - close parenthesis the variable c
52:40 - contains the next character of input
52:42 - these characters normally come from the
52:44 - terminal or keyboard but that need not
52:46 - concern us until chapter 7.
52:48 - the function put char open parentheses c
52:51 - close parenthesis is the complement of
52:53 - getchar
52:55 - put chair open parenthesis c close
52:58 - parenthesis
52:59 - prints the content of the variable c on
53:01 - some output medium again usually the
53:04 - terminal or screen
53:06 - calls to put char in printf may be
53:08 - interleaved the output may be a p will
53:10 - appear in the order in which the calls
53:12 - are made as with printf there is nothing
53:16 - special about gachar and putchar they
53:18 - are not part of the c language but they
53:20 - are universally available
53:24 - once again i would note that the authors
53:26 - are making the case that the syntax of
53:28 - the language should not include syntax
53:30 - for input output operations but instead
53:33 - call library functions
53:35 - keeping the compiler small and easy to
53:37 - port new systems was important to the
53:39 - creators of c
53:41 - and even if something like put char was
53:43 - part of the language syntax it would be
53:46 - translated at runtime to call a function
53:49 - programming languages from the 1960s
53:51 - tended to have a small set of use cases
53:53 - read some input run some calculation and
53:55 - then write some output
53:57 - so it seemed like a few language
53:58 - elements would be sufficient to describe
54:00 - all programs
54:01 - but as programs started to make network
54:03 - connections draw buttons on a screen or
54:06 - respond to api calls over the network
54:08 - it would have been difficult to keep
54:10 - expanding the core language syntax for
54:12 - each new use case
54:14 - but it was extremely natural to add new
54:16 - libraries to languages like c with
54:18 - functions to call to accomplish these
54:21 - new use cases
54:23 - file copying given getchar input char
54:26 - you can write a surprising amount of
54:27 - useful code without knowing anything
54:29 - more about input output the simplest
54:32 - example is a program which copies its
54:34 - input to its output one character at a
54:36 - time in outline here's what we do
54:40 - get a character
54:42 - while the character is not the end of
54:44 - file signal
54:45 - i'll put the character we just read and
54:47 - then get a new character
54:50 - converting this into c gives us the
54:52 - sample code on page 14 of the textbook
54:55 - pound includes stdio.h
54:59 - main open parentheses closed parentheses
55:01 - open curly brace
55:03 - int
55:03 - c
55:04 - semicolon c equals get char open
55:07 - parenthesis close parenthesis semicolon
55:10 - while c
55:12 - not equal eof uppercase eof close
55:15 - parenthesis open curly brace put char c
55:19 - c equals get char semicolon close
55:22 - parentheses close curly brace
55:25 - the relational
55:28 - operator exclamation equals means not
55:31 - equal to
55:34 - the main problem is detecting the end of
55:36 - the input by convention getchar returns
55:39 - the value which is a not a valid
55:41 - character when it encounters the end of
55:42 - input
55:43 - in this way programs can detect when
55:46 - they did not get a character and they've
55:48 - actually simply run out of input
55:50 - the only complication which is a serious
55:52 - nuisance is that there are two
55:54 - conventions in common use about what
55:56 - that endophile value really is
55:59 - we have deferred this issue by using the
56:02 - symbolic name eof capital eof for the
56:05 - value whatever it might be
56:07 - in practice eof will be either negative
56:10 - one or zero so the program must be pro
56:14 - seated by the appropriate pound define
56:17 - eof -1 or pound-defying eof0 to work
56:22 - properly by using the symbolic constant
56:24 - eof to represent the value that getcha
56:27 - returns when the end of file occurs we
56:29 - are assured that only one thing in the
56:31 - program defines on the specific depends
56:35 - on the specific value
56:37 - numeric value of eof
56:41 - i would
56:42 - note most of that is incorrect modern c
56:46 - compilers actually define eof in the
56:48 - stdio.h include file so you never define
56:51 - eof in your code
56:52 - in modern c the value of eof is minus
56:55 - one
56:56 - you should just include stdio.h and use
56:58 - predefined eof constant to check for end
57:00 - to file
57:01 - the nuisance of different values for eof
57:04 - was resolved shortly after 1978.
57:08 - continuing with the text
57:10 - we also declare c to be an int not a
57:12 - chair char so that it can hold the value
57:15 - which get char returns as we'll see in
57:17 - chapter two the value is actually an int
57:20 - because it must be capable of
57:21 - representing and defile in addition to
57:23 - all possible characters
57:26 - so the program for copying could
57:28 - actually be written more concisely by
57:30 - experienced c programmers in c
57:34 - any assignment such as c equals get char
57:37 - open parentheses close parenthesis can
57:39 - be used in an expression
57:41 - its value is simply the residual value
57:45 - being assigned to the left hand side
57:48 - if the assignment of a character to the
57:50 - variable c is put inside the test part
57:52 - of a while statement the file copy
57:54 - program can be written as shown in the
57:57 - example code on page 15 of the textbook
58:01 - pound include stdio.h
58:04 - main open parenthesis close parenthesis
58:07 - open curly brace
58:08 - int space c semicolon
58:11 - while open parenthesis open parenthesis
58:15 - c equals get char open parenthesis close
58:17 - parenthesis close parenthesis not equal
58:20 - eof close parenthesis put char c
58:24 - parentheses c close parenthesis
58:26 - semicolon close curly brace
58:28 - the program gets a character assigns it
58:31 - to c and then tests whether the
58:33 - character was the end of file signal
58:35 - if it was not the body of the wireless
58:37 - executed printing the character
58:40 - the while then repeats when the input is
58:42 - end of input is finally reached the wild
58:45 - terminal terminates and so does main
58:48 - this virtual version centralizes the
58:50 - input there is now only one call to get
58:52 - char and shrinks the program
58:55 - nesting an assignment is a test of one
58:57 - of the places where c
58:59 - permits a valuable conciseness it is
59:01 - possible to get carried away and create
59:04 - impenetrable code
59:05 - though a tendency that we will try
59:07 - though that is a tendency we will try to
59:10 - curb
59:11 - it's important to recognize that the
59:13 - parentheses around the assignment within
59:15 - the conditional are really necessary the
59:18 - precedence of exclamation equal not
59:21 - equals is higher than that of equals the
59:23 - assignment operator which means that in
59:26 - absence of parentheses the relational
59:28 - test exclamation equals would be done
59:30 - before the assignment
59:32 - equals
59:33 - so the statement
59:35 - c equals get char parentheses open
59:37 - parentheses close parenthesis not equal
59:38 - eof is equivalent to
59:41 - c equals get char open no sorry
59:45 - is equivalent to
59:46 - c equals open parenthesis get char open
59:49 - press the close parenthesis not equal
59:51 - eof
59:52 - close parenthesis
59:53 - this has the undefined desired effect of
59:57 - setting
59:59 - [Music]
60:01 - it is important to recognize that the
60:03 - parentheses around the assignment within
60:05 - the conditional are really necessary the
60:08 - precedence of exclamation equals is
60:10 - higher than that of
60:12 - equals which means that in the absence
60:15 - of parentheses the relational test not
60:18 - equals would be done before the
60:19 - assignment so the statement c equals get
60:22 - char not equal eof is equivalent to
60:26 - c equals open parenthesis getchar not
60:28 - equal eof close parenthesis
60:31 - this has the undesired effect of setting
60:33 - c to zero or one depending on whether or
60:36 - not the call of getchar encountered the
60:39 - end of file
60:40 - more on this in chapter 2.
60:43 - the next program counts characters it is
60:45 - a small elaboration of the copy program
60:48 - this sample code is on page 16 of the
60:50 - textbook
60:52 - pound include stdio.h
60:54 - main open parenthesis close parenthesis
60:57 - open curly brace
60:59 - long
61:00 - nc semicolon
61:02 - and c equals 0 semicolon
61:05 - while
61:06 - open parenthesis get char open
61:08 - parentheses close parenthesis
61:10 - exclamation equal eof
61:13 - plus plus nc semicolon
61:16 - printf
61:17 - double quote percent ld backslash n
61:21 - double quote comma nc parentheses
61:24 - semicolon close curly brace
61:27 - the statement plus plus nc semicolon
61:30 - shows a new operator plus plus
61:33 - which means increment by one
61:35 - you could write nc equals nc plus one
61:39 - but plus plus nc is more concise and
61:43 - often more efficient there is a
61:45 - corresponding operator minus minus to
61:47 - decrement by one
61:49 - the operators plus plus
61:53 - and minus minus can either be prefix
61:55 - operators
61:57 - plus plus c and c or postfix
62:01 - and c plus plus
62:03 - these two forms have different values
62:04 - and expressions as will be shown in
62:06 - chapter two but plus plus nc and nc plus
62:10 - plus
62:10 - both increment and c for the moment
62:13 - we'll stick to the prefix form
62:17 - the character counting program
62:18 - accumulates its count in a long variable
62:21 - instead of an int
62:22 - on a pdp 11 the maximum value of an int
62:25 - is 32
62:27 - 767 and it would take relatively little
62:30 - input to overflow that counter if it
62:32 - were declared as an int in honeywell and
62:35 - ibm c
62:36 - long and int are synonymous and much
62:38 - larger the conversion specification
62:41 - percent ld signals to printf that the
62:44 - corresponding argument is a long integer
62:48 - we again as a note we again see another
62:51 - reference to the fact that the number of
62:53 - bits of the int type is in transition in
62:55 - 1978.
62:57 - the older pdp-11 used a 16-bit integer
62:59 - to save limited memory on a small
63:02 - almost obsolete computer while later
63:04 - computers from ibm and honeywell have
63:06 - already switched to their int type to be
63:09 - 32 bits this allowed code originally for
63:12 - written for the pdp-11 like unix or even
63:15 - the c compiler to be recompiled on the
63:17 - ibm or honeywell with very few changes
63:21 - to cope with bigger numbers you can use
63:24 - a double which is a double length float
63:27 - we will also use a for statement instead
63:29 - of a while to illustrate an alternate
63:31 - way to write a while loop
63:33 - this code is the second sample code on
63:36 - page 16 of the textbook
63:39 - pound include stdio.h
63:41 - main open parentheses closed parentheses
63:43 - open curly brace
63:45 - double
63:46 - nc semicolon four open parenthesis nc
63:50 - equals zero semicolon
63:52 - get our open parenthesis close
63:54 - parenthesis not equal eof semicolon plus
63:58 - plus nc
63:59 - close parenthesis
64:01 - and then a semicolon the semicolon in
64:03 - this case is an empty statement because
64:05 - there's nothing in the body of the of
64:07 - the for loop and at the end we say
64:10 - printf double quote
64:12 - percent dot zero f backslash n
64:17 - double quote comma nc close parentheses
64:20 - semicolon
64:21 - close curly bracket
64:24 - printf uses percent f for both float and
64:26 - double
64:28 - percent.0f
64:30 - suppresses printing of the non-existent
64:32 - fraction part
64:34 - the body of the for loop here is empty
64:36 - because all the work is done in the test
64:38 - and reinitialization parts of the for
64:40 - loop
64:41 - but the grammatical rules of c require
64:44 - that a for statement have a body the
64:46 - isolated simply semicolon technically a
64:49 - null statement is there to satisfy that
64:52 - syntax requirement we put it on a
64:54 - separate line to make it more visible
64:57 - before we leave the character counting
64:59 - program observe that if the input
65:01 - contains no characters the while or for
65:05 - test fails on the very first call to get
65:07 - char so that the loop program produces
65:10 - zero the right answer
65:13 - this is an important observation
65:15 - one of the nice things about while and
65:17 - four is they are tested at the top of
65:20 - the loop proceed before proceeding with
65:22 - the body
65:23 - if there is nothing to do
65:25 - nothing is done
65:27 - even if that means never going through
65:28 - the loop body
65:30 - programs should act intelligently
65:33 - when hand handed input like no
65:35 - characters
65:36 - the while and the four statements help
65:38 - ensure that they do reasonable things
65:40 - with boundary conditions
65:44 - line counting the next program counts
65:46 - lines in its input input lines are
65:48 - assumed to be terminated by the newline
65:51 - character backslash n that has been
65:53 - carefully appended to every line written
65:55 - out
65:56 - this is sample code on line 17 of the
65:58 - textbook
65:59 - pound includes
66:01 - stdio.h
66:03 - main open parenthesis close parenthesis
66:05 - open curly brace
66:08 - int
66:09 - c comma nl semicolon
66:12 - nl equals zero semicolon
66:15 - while
66:16 - open parenthesis open parenthesis c
66:18 - equals get char open parentheses close
66:20 - parenthesis close parenthesis not equal
66:23 - eof close parenthesis
66:26 - if open parenthesis c
66:28 - double equals single quote backslash n
66:31 - single quote close parentheses
66:33 - plus plus nl semicolon
66:37 - printf
66:38 - double quote percent d backslash n
66:40 - double quote comma nl
66:43 - close parentheses semicolon close curly
66:45 - brace
66:47 - the body of the while loop now consists
66:49 - of an if
66:50 - which in turn controls the increment
66:52 - plus plus nl
66:54 - the if statement tests its parenthesized
66:57 - condition and if true does the statement
67:00 - or group of statements inside braces
67:02 - that follow
67:03 - we have again indented to show what is
67:06 - controlled by what
67:08 - the double equal sign in is the c
67:10 - notation for is equal to like fortrans
67:13 - dot eq dot
67:15 - this symbol is used to distinguish the
67:17 - equality test
67:18 - the question being asked from the single
67:21 - equal sign used for assignment
67:23 - since assignment is about twice as
67:25 - frequently used as equality testing in
67:28 - typical c programs
67:29 - it's appropriate that the operator be
67:31 - half as long
67:34 - a single character can be written
67:36 - between single quotes to produce a value
67:38 - equal to the numerical value of the
67:39 - character in the machine's character set
67:41 - this is called a character constant
67:44 - so for example single quote a single
67:47 - quote is a character constant in the
67:48 - ascii character set its value is 65 the
67:52 - internal representation of the character
67:54 - a
67:55 - of course
67:56 - double single quote a single quote is to
67:59 - be preferred over 65 its meaning is
68:01 - obvious and it is independent of a
68:03 - particular character set
68:06 - these escape sequences that are used in
68:08 - character strings are also legal in
68:10 - character constants so in tests and
68:12 - arithmetic expression expressions
68:15 - single quote backslash n single quote
68:18 - stands for the value of a new line
68:20 - character
68:21 - you should note carefully that single
68:23 - quote backslash n is a single quer
68:26 - character
68:27 - and an expressions is equivalent to a
68:29 - single integer on the other hand double
68:32 - quote backslash n double quote is a
68:34 - character string which happens to
68:36 - contain only one character the topics of
68:40 - strings versus characters is discussed
68:42 - further in chapter two
68:45 - the numeric values that are shown for
68:47 - characters are using the ascii character
68:49 - set
68:50 - the character sets in the 1970s were
68:52 - quite intricate most were eight bits
68:55 - long to conserve computer memory and
68:56 - only support a hundred or so latin-like
68:59 - characters
69:00 - this is why early programming languages
69:02 - use special characters like asterisk and
69:05 - curly brace in their syntax very
69:07 - carefully they needed to choose
69:09 - characters
69:10 - that were commonly available on computer
69:12 - keyboards from different manufacturers
69:15 - modern programming languages like python
69:17 - 3 and ruby store internal string values
69:19 - using the unicode character set so they
69:22 - are all able to represent all the
69:24 - characters in all languages around the
69:26 - world
69:28 - modern languages tend to represent 8-bit
69:31 - values in the range from 0 to 256 using
69:34 - a byte or similar type
69:36 - python 2 strings were stored as 8 bit
69:39 - bytes and python 3 strings are stored as
69:42 - 32-bit unicode characters
69:44 - moving to unicode was a major effort in
69:47 - the python 2 to python 3 transition
69:52 - word counting
69:54 - the fourth in our series of useful
69:55 - programs counts lines words and
69:58 - characters
69:59 - with a loose definition that a word is
70:01 - any sequence of characters that does not
70:03 - contain a blank a tab or a new line
70:07 - this is a very very bare bones version
70:10 - of the unix utility wc
70:14 - this example is on
70:16 - page 18 in the textbook
70:20 - pound include stdio.h pound define yes
70:24 - 1 pound to find no
70:26 - 0.
70:28 - main
70:29 - open parenthesis close parenthesis open
70:31 - curly brace
70:32 - int
70:33 - c comma nl comma nw comma nc come in
70:37 - word
70:40 - inward equals no
70:43 - l equals nw equals nc equals zero
70:47 - while
70:48 - open parenthesis open parenthesis c
70:50 - equals get char
70:52 - not equal to eof
70:55 - open curly brace plus plus nc
70:59 - if
71:00 - parentheses c double equals
71:02 - quote backslash n quote parenthesis plus
71:06 - plus nl
71:08 - if
71:09 - open parenthesis c
71:11 - double equals
71:12 - single quote space single quote
71:15 - double vertical bar
71:18 - c
71:19 - double equals
71:21 - single quote backslash n
71:23 - single quote
71:25 - double vertical bar
71:26 - c
71:27 - equals equals
71:29 - single quote backslash t
71:31 - single quote close parenthesis
71:33 - inward equals no
71:36 - else if open parenthesis inward
71:38 - equal equal no
71:40 - close parenthesis open curly brace
71:43 - inward equals yes semicolon plus plus nw
71:48 - semicolon
71:50 - close curly brace close curly brace
71:53 - printf
71:54 - open parenthesis
71:56 - double quote percent d space percent d
71:59 - space percent d backslash n double quote
72:02 - comma
72:03 - nl
72:05 - comma nw comma nc close
72:08 - curly brace
72:11 - every time the program encounters the
72:14 - first character of a word it counts it
72:17 - the variable inward records whether the
72:20 - program is currently in a word or not
72:23 - initially it is not in a word which
72:26 - which is assigned the value no
72:28 - we prefer the symbolic constants yes and
72:30 - no to the literal values one and zero
72:32 - because they make the program more
72:34 - readable
72:35 - of course in a program as tiny as this
72:37 - it makes little difference but in larger
72:38 - programs the increase of clarity is well
72:41 - worth the modest
72:43 - effort to write it this way to make it
72:45 - more readable
72:47 - you will also find that it's easier to
72:49 - make changes to programs where numbers
72:51 - appear only as symbolic constants
72:54 - the line
72:56 - nl
72:56 - equals nw equals nc equals zero
73:02 - sets all three variables to zero this is
73:04 - not a special case
73:06 - but a consequence of the fact that an
73:08 - assignment has a value and assignments
73:11 - associate right to left
73:14 - it's really as if we had written nc
73:17 - equals open parenthesis nl equals open
73:20 - parenthesis nw equals zero close
73:23 - parentheses close parenthesis semicolon
73:27 - the operator double vertical bar
73:29 - vertical bar vertical bar means or so
73:31 - the line
73:32 - if open parenthesis
73:34 - c double equals
73:36 - single quote space single quote vertical
73:39 - bar vertical bar c double equals single
73:42 - quote backslash n single quote double
73:44 - vertical bar c double equals quote
73:48 - backslash t
73:50 - quote parenthesis says
73:52 - if c is a blank or c is a new line or c
73:54 - is a tab
73:56 - the escape sequence backslash t is a
73:58 - visible representation of the tab
73:59 - character
74:01 - there is a corresponding operator which
74:02 - is double ampersand for and
74:05 - expressions connected by
74:07 - double ampersand or double vertical bar
74:09 - are evaluated left to right and it is
74:11 - guaranteed that the evaluation will stop
74:14 - as true as true soon as the truth or
74:17 - falsehood for the overall expression is
74:20 - known
74:21 - thus if c contains a blank there is no
74:24 - need to test whether contends contains a
74:26 - new line or tab so these tests are not
74:29 - made this isn't particularly important
74:31 - here but is very significant in more
74:33 - complicated situations as we will soon
74:36 - see
74:39 - i would note that the double vertical
74:40 - bar and double ampersand are the norm
74:42 - for boolean operators in c like
74:44 - languages when a new language was being
74:46 - designed it was really easy to just
74:48 - adopt the c convention for logical
74:49 - operators because while they may seem
74:51 - cryptic
74:52 - millions of software developers were
74:55 - already familiar with the operators in
74:57 - this way the relationship between c and
75:00 - c like languages is like the
75:02 - relationship between latin and romance
75:04 - languages including english
75:07 - back to the text
75:09 - the example also shows the c else
75:11 - statement which specifies an alternative
75:14 - action to be done if the condition part
75:16 - of an if statement is false the general
75:18 - form is
75:19 - if
75:20 - open parenthesis expression close
75:22 - parenthesis statement one
75:24 - else statement two
75:26 - one and only one of the two statements
75:28 - associated with an if then else is done
75:31 - if the expression is true statement one
75:33 - is executed if not statement two is
75:36 - executed
75:37 - each statement can actually be in fact
75:39 - quite complicated in the word count
75:41 - problem the one after the else is an if
75:45 - that controls two statements in braces
75:49 - section 1.6 arrays
75:52 - understanding the capabilities and
75:54 - limitations of c arrays is one of the
75:56 - most important topics
75:58 - in our historical look at the c
76:00 - programming language
76:02 - most importantly the number of elements
76:04 - in an array declaration must be a
76:06 - constant at compile time and the size of
76:10 - an array cannot be adjusted using an
76:13 - array declaration while the program's
76:14 - running
76:15 - this inability to automatically resize c
76:18 - arrays as data is added leads to a class
76:22 - of security laws that are generally
76:24 - referred to as buffer overflow where a
76:27 - program reads more data in that can fit
76:30 - into an array and is tricked to
76:31 - overriding other data or code in
76:33 - compromising an application
76:36 - later in this book we will create
76:37 - dynamic array-like structures in c using
76:40 - pointers and the standard library cialoc
76:44 - function
76:45 - python has support for a non-dynamic
76:47 - arrays buffers python buffers are
76:49 - generally not used except for
76:51 - programmers writing library code
76:53 - that talks to low-level code written in
76:55 - a language other than python or talking
76:57 - to operating system things like linux
77:00 - the more commonly used python list and
77:04 - dictionary structures can change their
77:06 - sizes automatically
77:08 - as elements are added and deleted at
77:10 - runtime
77:11 - java has support for non-dynamic arrays
77:15 - like c which are
77:17 - given a length at the moment they are
77:18 - created and the array length cannot be
77:20 - increased nor decreased without making a
77:22 - new array and copying all the elements
77:24 - from the first to the second array
77:27 - java does provide list and map
77:29 - structures that automatically adjust
77:30 - their length as data is added or removed
77:33 - java has a class called arraylist which
77:36 - can be dynamically extended but provides
77:39 - array-like linear access
77:42 - it is a list internally but it can be
77:45 - used like an array externally
77:48 - the underlying technique that is used to
77:51 - implement language structures like
77:52 - python's list
77:54 - is dynamic memory allocation in a linked
77:56 - list structure
77:57 - linked lists are one of the most
77:58 - important data structures in all of
78:00 - computer science
78:02 - we will cover dynamic allocation and
78:04 - implementing data structures in c
78:06 - in chapter 6.
78:08 - for now we will merely examine the
78:11 - syntax of c arrays but keep in mind that
78:14 - allocating an array in c is very
78:17 - different than creating a list
78:20 - in python
78:22 - back to the text
78:24 - let us write a program to count the
78:26 - number of occurrences of each digit of
78:29 - white space characters blank tab and new
78:31 - line and all other characters
78:33 - this is an artificial problem to solve
78:36 - but it permits us to illustrate several
78:38 - aspects of c
78:40 - in one program
78:42 - there are 12 categories of input so it
78:45 - is convenient
78:46 - to use an array to hold the number of
78:48 - occurrences of each digit rather than 10
78:51 - individual variables
78:53 - actually 12 individual variables
78:55 - here is one version of the program on
78:57 - page 21
78:59 - in the textbook
79:01 - and i would note that
79:03 - as these programs get larger and larger
79:05 - it is harder and harder for you to just
79:07 - listen to me read them and you have to
79:09 - go look at them in the textbook
79:12 - so i recommend that you go check out the
79:14 - textbook in page 20 and find this
79:17 - actual code
79:19 - found include
79:21 - io dot h
79:23 - main open parenthesis closed parenthesis
79:24 - open curly brace
79:26 - int
79:27 - c
79:28 - comma i comma n white comma n other
79:32 - semicolon int
79:34 - n digit
79:35 - open square bracket 10 close square
79:37 - bracket semicolon
79:40 - and white equals n other equals 0
79:43 - semicolon
79:44 - 4 open parenthesis i equals 0 semicolon
79:48 - i less than 10 semicolon plus plus i
79:51 - open let me close parenthesis
79:54 - end digit open square bracket
79:56 - i close square bracket equals zero
79:59 - semicolon
80:02 - now we're going to have a loop to read
80:04 - all of our input
80:06 - while double open parentheses c equals
80:08 - get char open parenthesis close
80:10 - parentheses and another closed
80:11 - parenthesis not equal eof close
80:14 - parenthesis
80:16 - if open parentheses c greater than or
80:19 - equal to
80:20 - single quote 0 single quote
80:23 - double ampersand
80:24 - c less than or equal single quote 9
80:27 - single quote close parenthesis
80:29 - plus plus
80:30 - in digit
80:32 - open square bracket c minus single quote
80:35 - 0 single quote close square bracket
80:38 - semicolon
80:39 - else if
80:41 - open parenthesis c double equals space
80:45 - quote space quote
80:48 - or double vertical bar c double equals
80:52 - single quote backslash n single quote
80:54 - double vertical bar c double equals
80:57 - single quote backslash t single quote
80:59 - close parenthesis
81:01 - plus plus
81:02 - and white
81:04 - semicolon
81:05 - else plus plus in other
81:08 - that if statement was a sort of three
81:09 - branches if checking to see if we were
81:11 - doing a digit
81:13 - a white space character or some other
81:16 - character
81:17 - at the end of the while loop or not the
81:19 - end of the while loop and so we say
81:20 - printf
81:21 - parentheses double quote digits equals
81:24 - double quote close parenthesis semicolon
81:26 - now we'll note in this that there is no
81:29 - new line so we can have these print defs
81:31 - kind of concatenate outward without
81:33 - going to a separate line
81:36 - four parenthesis i equals zero semicolon
81:39 - i less than 10 semicolon plus plus i
81:43 - close parenthesis
81:44 - printf
81:45 - double quote space percent d double
81:48 - quote
81:49 - comma n digit
81:51 - open square bracket i close square
81:54 - bracket close parenthesis semicolon
81:58 - printf open parenthesis
82:00 - double quote backslash n white space
82:03 - equals percent d
82:05 - comma other equals percent d backslash n
82:09 - double quote comma
82:10 - and white comma n other closed
82:13 - parentheses semicolon close curly brace
82:17 - let's go through the code
82:19 - the declaration int in digit open square
82:22 - bracket 10 closed square bracket
82:24 - semicolon declares n digit to be an
82:27 - array of 10 integers
82:30 - array of subscripts always start and 0
82:33 - in c rather than 1 as in fortran or pl1
82:36 - so the elements are end digit sub zero
82:38 - and digit sub one dot dot dot end digit
82:41 - sub nine
82:43 - square brackets are the sub
82:45 - this is reflected in the for loops which
82:47 - initialize and print the array
82:50 - a subscript can be integer any integer
82:53 - expression which of course includes
82:54 - integer variables like i and integer
82:57 - constants
82:59 - this particular program
83:01 - relies heavily on the properties of
83:04 - character representation of the digits
83:06 - for example
83:08 - if c greater than or equal to single
83:11 - quote 0 single quote double ampersand c
83:14 - less than or equal to single quote 9
83:17 - single quote close parenthesis
83:19 - determines whether it's a digit
83:22 - that is if the numeric value of the
83:24 - digit
83:26 - and the numeric value of the digit is
83:29 - c minus double quote 0 double quote this
83:31 - only works if double quote 0 double
83:34 - quote 1
83:35 - etc are positive and increasing order
83:38 - and there's nothing but digits between 0
83:39 - and 9.
83:41 - fortunately this is true for all
83:43 - conventional character sets
83:45 - by definition
83:47 - arithmetic involving chars and ends
83:50 - converts everything to int before
83:51 - proceeding so char variables and
83:53 - constants are identically
83:56 - essentially identical to instant
83:58 - arithmetic contexts
84:00 - this is quite natural and convenient for
84:02 - example c minus single quote 0 single
84:04 - quote is an integer expression that
84:07 - gives us a value between 0 and 9 an
84:09 - integer value between 0 and 9
84:11 - corresponding to the character quote 0
84:13 - quote to quote 9 quote stored in c and
84:16 - is thus a valid subscript for the ten
84:20 - element array and digit
84:23 - the decision as to whether the character
84:25 - is a digit a white space or something
84:26 - else is made by the sequence if open
84:29 - parenthesis c greater than or equal to
84:32 - quote zero quote double ampersand c less
84:35 - than or equal
84:37 - quote zero quote i quote nine quote
84:39 - close parentheses
84:41 - plus plus end digit open square bracket
84:43 - c minus quote zero quote close bracket
84:47 - semicolon else if
84:50 - c double equals single quote or
84:53 - c double equals single quote backslash n
84:56 - or c double equals single quote
84:58 - backslash t
85:00 - plus plus n white else
85:02 - plus plus and other
85:04 - the pattern
85:06 - if
85:07 - in parentheses condition statement else
85:10 - if parentheses conditions statement
85:12 - else statement occurs frequently in
85:14 - programs as a way to express a multi-way
85:17 - decision the code is simply read from
85:19 - the top of the bot to until the bottom
85:22 - until some condition is satisfied at
85:24 - that point the corresponding statement
85:26 - part is executed and the entire
85:28 - construction is finished
85:30 - of course
85:31 - statement can be several statements in
85:33 - closed embraces
85:35 - if none of the conditions are satisfied
85:37 - the statement after the final else is
85:39 - executed if present
85:41 - if the final else and statement are
85:43 - omitted as in the word count program no
85:45 - action takes place
85:47 - there can be an arbitrary number of else
85:50 - if
85:51 - condition
85:52 - statements groups between the initial if
85:54 - and the final else
85:56 - as a matter of style it is advisable to
85:58 - format this construction as we have
86:00 - shown with proper indentation so that
86:03 - long decisions do not march off the
86:05 - right side of the page
86:07 - the switch statement to be discussed in
86:09 - chapter 3 provides another way to write
86:11 - multi-way branching that is particularly
86:13 - suitable when the condition being tested
86:16 - is simply whether some integer or
86:18 - character expression
86:20 - matches one of a set of constants
86:23 - for contrast we will present a switch
86:25 - version of this program in chapter three
86:29 - functions in c a function is equivalent
86:32 - to a subroutine or function in fortran
86:34 - or a procedure in pl1 pascal etc
86:38 - a function provides a convenient way to
86:40 - encapsulate some computation in a black
86:42 - box which can then be used without
86:44 - worrying about its innards
86:46 - functions are really the only way to
86:48 - cope with the potential complexity of
86:50 - large programs
86:51 - with properly designed functions it is
86:54 - possible to ignore how a job gets done
86:56 - knowing what is done is sufficient
87:00 - c is designed to make the use of
87:02 - functions easy convenient and efficient
87:05 - you will often see a function only a few
87:07 - lines long called only once just because
87:10 - it clarifies some piece of code
87:13 - so far we have used functions like
87:15 - printf
87:16 - getchar and put char
87:18 - that have been provided for us
87:20 - now it's time to write a few of our own
87:22 - since c has no exponentiation operator
87:25 - like the double asterisk of fortran or
87:27 - pl1
87:28 - let us illustrate the mechanics of
87:30 - function definition by writing a
87:32 - function
87:33 - power open parenthesis m comma n close
87:36 - parenthesis to raise an integer
87:39 - into a positive power n
87:42 - that is the value of power parentheses 2
87:45 - comma 5 is 32.
87:48 - this function certainly doesn't do the
87:50 - whole job of
87:52 - exponentiation since it only handles
87:54 - positive powers of small integers
87:57 - but it is best to confuse only one issue
87:59 - at a time
88:01 - here is the function power and a main
88:03 - program to exercise it so you can see
88:05 - the whole structure at once
88:07 - this sample code is on page 23 of the
88:10 - textbook
88:11 - pound include stdio.h
88:14 - main open curly brace
88:17 - int i semicolon
88:19 - for for parenthesis i equals 0 semicolon
88:23 - i less than 10 semicolon plus plus i
88:26 - close parentheses
88:27 - printf
88:29 - double quote percent d space percent d
88:31 - space percent d backslash n double quote
88:34 - comma
88:35 - i comma power open parenthesis two comma
88:38 - i close parenthesis comma
88:41 - power
88:42 - open parenthesis negative three comma i
88:45 - close parenthesis close parenthesis
88:47 - semicolon close curly brace the end of
88:50 - the main now we begin the function
88:53 - power open parenthesis x comma n close
88:56 - parenthesis
88:58 - int
88:59 - x comma n semicolon open curly brace
89:03 - int i comma p
89:05 - p equals one
89:08 - four
89:10 - open parenthesis i equals 1 semicolon i
89:12 - less than or equal to n semicolon plus
89:15 - plus i
89:17 - p equals p times x semicolon return open
89:22 - parenthesis p close parenthesis
89:24 - semicolon close curly brace
89:27 - each function has the same form
89:29 - function name open parenthesis argument
89:32 - list if any
89:35 - followed by argument declarations
89:37 - if any
89:39 - followed by the body of the function
89:40 - which includes declarations and
89:42 - statements
89:44 - the functions can appear in either order
89:46 - and in one source file or two
89:49 - if of course the source file appears in
89:50 - two files you will have to say more to
89:52 - compile and load it when it fall appears
89:54 - in one but that's an operating system
89:56 - matter not a language attribute
89:59 - for the moment we'll just assume that
90:00 - both function functions are in the same
90:02 - file so whatever you learned about c
90:05 - programs running them will not change
90:08 - the function power is called twice in
90:10 - the line printf open parenthesis double
90:13 - quote percent d space percent d space
90:16 - percent d backslash n double quote comma
90:19 - i comma power open parenthesis two comma
90:22 - i close parenthesis comma power open
90:26 - parenthesis negative three comma i close
90:28 - parenthesis close parenthesis
90:31 - each call passes two arguments to the
90:34 - power function which each time returns
90:36 - an integer to be formatted and printed
90:38 - in the expression power open parenthesis
90:41 - two comma i
90:42 - is just an integer
90:44 - as two and i are
90:46 - not all functions produce an integer
90:47 - value and we'll take this up in more
90:49 - detail in chapter four
90:51 - in power
90:53 - the arguments have to be cleared
90:54 - appropriately so their types are known
90:56 - before the beginning of the body of the
90:58 - function
90:59 - this is done by the line int x comma n
91:03 - semicolon
91:04 - that follows the function name
91:06 - the argument declarations go between the
91:09 - argument list and the opening left brace
91:12 - each declaration is terminated by a
91:14 - semicolon the names used for power and
91:17 - for its arguments are purely local to
91:19 - power and not accessible to any other
91:21 - functions
91:22 - other routines can use the same names
91:24 - for their variables without conflict
91:27 - this is also true of the variables i and
91:29 - p within the function the i in power is
91:33 - unrelated to the i in main
91:35 - the value that power
91:37 - computes is returned to main by the
91:39 - return statement
91:41 - which is just as in pl1 any expression
91:45 - must occur within the parentheses
91:48 - a function need not return a value a
91:50 - return statement with no expression
91:52 - causes control but no useful value to be
91:55 - returned to the call caller as does
91:57 - falling off the end of a function by
92:00 - reaching the terminating right curly
92:03 - brace
92:05 - section 1.8 arguments call by value
92:09 - one aspect of c function which may be
92:11 - unfamiliar to programmers who are used
92:13 - to other languages particularly fortran
92:15 - and pl1
92:16 - in c all function arguments are passed
92:19 - by value
92:21 - this means that the called function is
92:23 - given the values of its arguments in
92:25 - temporary variables actually on a stack
92:28 - rather than their addresses
92:30 - this leads to some different properties
92:33 - than are seen with call by reference
92:35 - languages like fortran and pl1
92:38 - in which the called routine has handled
92:40 - the address of the argument not its
92:42 - value
92:44 - it may seem strange
92:46 - that the authors are calling so much
92:47 - attention to the fact that function
92:49 - arguments are passed call by value in
92:51 - the very first chapter
92:53 - most modern programming languages like
92:55 - python php or java pass single value
92:59 - arguments by value by default
93:01 - and to pass in an argument by reference
93:03 - you need to do something special like
93:05 - adding the ampersand in the function
93:07 - declaration in php
93:10 - passing by reference was the norm before
93:13 - c and passing by value was the norm
93:16 - after c
93:17 - since modern languages were deeply
93:19 - influenced by and often written in c
93:22 - passing by value is the norm for modern
93:24 - languages
93:26 - it's nice because it isolates the data
93:28 - in the calling code from the called code
93:31 - so the called code can't easily mess
93:33 - with its arguments either intentionally
93:36 - or by mistake and create an unexpected
93:39 - side effect and possibly a bug or
93:41 - security flaw in the calling code
93:44 - it was a bit of work to make pass by
93:47 - value work and see c implements a call
93:50 - stack
93:50 - where a bit of memory is automatically
93:53 - allocated at each function call and c
93:55 - makes a copy of the values in the
93:57 - calling code to pass them into the call
93:59 - code in a way that the calling code can
94:01 - see the values and change their local
94:03 - copies without affecting the values in
94:05 - the calling code
94:07 - the same call stack that made it
94:09 - possible
94:10 - for c function arguments to be passed by
94:12 - value
94:13 - also made it possible for a function to
94:15 - call itself
94:16 - recursively fortran functions could not
94:19 - be called recursively until the 1990
94:21 - version of fortran
94:23 - if you know your python you know that
94:26 - simple variables like integers and
94:27 - strings are passed by value while
94:30 - structured data like dictionaries and
94:31 - lists are passed by reference i.e the
94:34 - called function can modify its arguments
94:37 - we will later see this in c as well
94:41 - talking about call stacks recursive
94:43 - functions and the fact that arrays and
94:45 - structures are called by reference is
94:47 - jumping ahead somewhat
94:49 - so for now
94:50 - let's just remember the author's point
94:52 - that normal valuable
94:54 - values like integers and floats
94:57 - are passed by value in c back to the
95:00 - text
95:01 - the main distinction is that in c the
95:04 - called function cannot alter a variable
95:06 - in the calling function it can only
95:08 - alter its private temporary copy
95:11 - call by value is an asset however not a
95:14 - liability
95:15 - it usually leads to more compact
95:17 - programs with fewer extraneous variables
95:20 - because arguments can be treated as
95:21 - conveniently initialized local variables
95:23 - in the called routine
95:25 - for example here is a version of power
95:28 - which makes use of this fact
95:31 - this code is on page 24 of the text
95:36 - power
95:37 - open parenthesis x comma n close
95:40 - parenthesis
95:41 - and
95:42 - x comma n semicolon open curly brace int
95:46 - i comma p semicolon
95:49 - for
95:50 - open parenthesis p equals one semicolon
95:53 - n greater than zero semicolon minus
95:56 - minus n close parentheses
95:59 - p
95:59 - equals p times x
96:02 - semicolon
96:03 - return open parenthesis p close
96:05 - parenthesis semicolon
96:07 - close curly brace the argument n is used
96:11 - as a temporary variable and is counted
96:13 - down until it becomes zero
96:16 - there is no longer a need for the
96:18 - variable i as in the previous example
96:20 - whatever is done to end inside the power
96:23 - function has no effect on the argument
96:25 - that power was originally called with
96:28 - when necessary it is possible to arrange
96:30 - for a function to modify the variable in
96:32 - the calling routine
96:34 - the caller must provide the address of
96:36 - their variable to be set technically a
96:39 - pointer to the variable
96:41 - and the called function must declare the
96:43 - argument to be a pointer and reference
96:46 - the actual variable indirectly through
96:48 - it
96:49 - we will cover this in detail in chapter
96:52 - 5.
96:53 - when the name of an array is used as an
96:55 - argument the value passed to the
96:57 - function is actually the location
97:00 - or address of the beginning of the array
97:03 - there is no copying of the elements in
97:05 - the array
97:06 - by subscripting this value the function
97:09 - can access and alter
97:11 - any element of the array in the calling
97:14 - code
97:15 - this is the topic of the next section
97:19 - now i would recommend that you're
97:21 - careful looking at the code samples in
97:23 - the rest of this chapter recall
97:25 - that in c array sizes do not grow and
97:28 - shrink dynamically at all after they're
97:30 - allocated the authors statically
97:32 - allocate character arrays capable of
97:34 - handling up to 1 000 characters long
97:38 - their code works but it is somewhat
97:40 - brittle so look at the next two sections
97:42 - as examples of c syntax with many
97:45 - important concepts about character
97:47 - strings stored as arrays and calling
97:49 - patterns when passing arrays to
97:51 - functions as parameters that but not
97:53 - exactly the best practice when handling
97:56 - dynamically sized data
97:58 - back to the text
98:00 - probably the most common type of array
98:02 - in c is an array of characters to
98:04 - illustrate the use of character arrays
98:06 - and functions to manipulate them let's
98:08 - write a program that reads a set of
98:09 - lines and prints the longest the basic
98:12 - outline is simple enough
98:14 - while there's another line
98:16 - if it's longer than the previous longest
98:19 - save it and its length and at the very
98:21 - end print the longest line
98:24 - the outline makes it clear that the
98:25 - program divides naturally into pieces
98:28 - one piece gets a new line another checks
98:30 - it another saves it and then the rest
98:32 - controls the process
98:34 - since things divide so nicely it'd be
98:37 - it would be well to write them that way
98:39 - too
98:40 - accordingly let's write first a separate
98:43 - function called getline to fetch the
98:46 - next line of input this is a
98:47 - generalization of getchar
98:50 - to make the function useful in other
98:52 - contexts we'll try to make it as
98:53 - flexible as possible
98:55 - at the minimum
98:56 - getline has to return a signal but
98:59 - possible end of file
99:01 - a more generally useful design would be
99:02 - to return the length of the lan
99:04 - line or zero if the end of file is
99:07 - encountered
99:08 - zero is never a valid line length since
99:10 - every line has at least one character
99:13 - even a line containing only a new line
99:15 - has length one
99:17 - i would note that here in chapter one we
99:19 - have changed the book's original use of
99:21 - the function name getline to get
99:23 - underscore line in the code examples
99:25 - because it conflicts with stead the
99:27 - stdio.h
99:29 - that defines getline as a library
99:31 - function
99:32 - in this chapter the authors are
99:33 - providing examples around function
99:35 - naming and linking in later chapters
99:37 - code samples will simply use the
99:39 - built-in git line without an underscore
99:42 - to read an input
99:45 - when we find a line that is longer than
99:47 - the previous longest it must be saved
99:49 - somewhere this suggests a second
99:51 - function copy to copy the new line to a
99:54 - safe place
99:55 - finally we need a main program to
99:57 - control getline and copy
100:00 - here is the result
100:02 - the sample code for this is on page 26.
100:06 - and it's a bit long so you might want to
100:08 - show take a look at the sample code in a
100:11 - browser
100:13 - pound include stdio.h
100:16 - pound define max line 1000
100:20 - main
100:20 - open for an enclosed paren
100:23 - open curly brace
100:24 - int len
100:26 - semicolon which is the current line
100:27 - length
100:28 - int max semicolon which is the maximum
100:32 - length we've seen so far
100:34 - char
100:35 - line open square bracket
100:37 - max line close square bracket semicolon
100:41 - a character array that's the current
100:42 - input line
100:44 - and then char
100:45 - save
100:46 - open square bracket max line close
100:48 - square bracket semicolon
100:50 - which is a character array that has the
100:52 - longest line where we're going to save
100:54 - it
100:56 - onto the code
100:58 - max equals zero
101:00 - while
101:02 - open parenthesis open parenthesis len
101:04 - equals get line open parenthesis line
101:06 - comma max line close parenthesis close
101:09 - parenthesis greater than zero
101:12 - if
101:13 - len is greater than max
101:16 - open curly brace max equals len to save
101:20 - it and then copy line comma save
101:25 - close curly brace
101:27 - if open parenthesis max greater than
101:29 - zero
101:31 - i.e there was a line
101:33 - print f open parenthesis
101:35 - double quote percent s
101:38 - double quote comma save
101:39 - close curly brace to end the main
101:41 - program
101:43 - now we're in the first function
101:45 - get line open parenthesis s comma limb
101:49 - close parenthesis
101:51 - char
101:52 - s open bracket close bracket semicolon
101:56 - since it's being passed in as an
101:58 - argument
101:59 - we don't need to know the length of it
102:02 - and the
102:03 - next argument is int
102:05 - lim semicolon so getline takes
102:09 - a character array
102:11 - of unknown length and a limit that tells
102:14 - us the length of the character array
102:16 - open curly brace
102:18 - int
102:19 - c comma i semicolon
102:22 - four
102:23 - open parenthesis i equals zero semicolon
102:26 - i less than lim minus one
102:30 - double ampersand
102:31 - parenthesis
102:33 - c equals get char open parentheses close
102:35 - parenthesis close parenthesis not equal
102:38 - e o f
102:39 - and
102:40 - double ampersand c not equal
102:45 - single quote backslash n back
102:47 - single quote semicolon plus plus i
102:53 - and in the body of the loop it's s
102:56 - open square bracket i closed square
102:59 - bracket equals c
103:01 - from now on i'll read that s sub i
103:03 - equals c
103:07 - at the end of the loop we say if open
103:10 - parenthesis c double equals single quote
103:12 - backslash n single quote close
103:14 - parenthesis open curly brace
103:17 - s sub i equals c
103:20 - plus plus i close curly brace
103:24 - s sub i equals quote backslash zero
103:29 - quote semicolon
103:32 - return open parenthesis i close
103:34 - parenthesis semicolon
103:36 - close curly brace and that's the end of
103:38 - the get line function
103:41 - and now we're on to the copy function
103:44 - copy open parenthesis s1
103:47 - s2 close parenthesis the purpose of this
103:49 - function is copy s1 to s2 assume that s2
103:53 - is big enough
103:55 - the declaration is char s1
103:58 - open square bracket close square bracket
104:00 - comma s2 open square bracket close
104:02 - square bracket
104:06 - a note these arrays have a size we just
104:08 - don't know what they are and we hope
104:10 - that they're large enough
104:12 - the body of the copy function starts
104:15 - with open curly brace
104:17 - int i
104:18 - semicolon
104:20 - i equals zero
104:23 - while
104:24 - open parenthesis open parenthesis s two
104:27 - sub i equals s one sub i close
104:30 - parenthesis not equal
104:33 - single quote backslash zero single quote
104:35 - plus plus i
104:37 - close curly brace to end the copy
104:39 - function
104:42 - main and getline communicate both
104:44 - through a pair of arguments and a
104:45 - returned value in getline the arguments
104:48 - are declared by the lines char
104:51 - s
104:52 - open square bracket close square bracket
104:53 - semicolon int
104:55 - lim semicolon
104:57 - which specify that the first argument is
104:59 - an array
105:00 - of unknown length and the second is an
105:03 - integer
105:04 - the length of the array s is not
105:06 - specified in getline since it's
105:08 - determined in main
105:10 - getline
105:12 - uses return to send a value back to the
105:14 - caller just as the function power did
105:17 - some functions return a useful value
105:19 - others like copy are only used for their
105:22 - effect and return no value
105:24 - getline puts the character backslash 0
105:27 - the null character whose integer value
105:30 - is zero at the end of the array it's
105:32 - creating to mark the end of the string
105:34 - of characters
105:35 - this convention is also used by the c
105:38 - compiler
105:39 - with a when a string constant like
105:41 - double quote
105:42 - h-e-l-l-o backslash n double quote is
105:46 - written in a c program the compiler
105:49 - creates an array of characters
105:51 - containing the characters of the string
105:53 - and adds a backslash zero
105:56 - at the end to terminate it so that
105:58 - functions such as printf can detect the
106:00 - end
106:02 - so
106:03 - that would lead to an array that has
106:06 - h e
106:08 - l
106:09 - l o backslash n backslash zero so it's a
106:14 - five character array
106:16 - with a new line which is a sixth
106:18 - character and then backslash zero which
106:20 - is an actual character again
106:22 - we don't know the arrays don't know
106:24 - their length and so you use the
106:26 - backslash 0
106:27 - as the indicator of the end of a string
106:31 - the percent s format specification in
106:33 - printf expects a string represented in
106:36 - exactly this form if you examine copy
106:39 - you will discover that it too relies on
106:41 - the fact that its input argument s1 is
106:44 - terminated by backslash zero
106:47 - and it copies this character backslash
106:50 - zero
106:50 - into the argument
106:52 - output argument s2
106:55 - all of this implies that backslash 0
106:58 - is not part of normal text it's merely a
107:00 - marker
107:02 - it is worth mentioning in passing
107:04 - that even a program as small as this one
107:08 - presents some sticky design problems
107:11 - for example
107:12 - what should maine do if it encounters a
107:14 - line which is bigger than its limit
107:17 - getline
107:19 - works properly and then it stops
107:21 - collecting when the array is full
107:23 - even if no new line has been seen
107:26 - by testing the length in the last
107:27 - character returned main can determine
107:31 - whether the line was too long then cope
107:32 - with it as it wishes
107:34 - in interest of brevity we have ignored
107:37 - this issue
107:40 - there is also no way for a user of
107:42 - getline function to know in advance how
107:45 - long an input line might be
107:47 - so getline checks for overflow on the
107:50 - other hand a user of the copy function
107:52 - already knows or should be able to find
107:54 - out how big the strings are so we have
107:57 - have chosen not to add error checking to
108:00 - it
108:03 - section
108:05 - section 1.10 scope
108:08 - external variables
108:09 - the variables in main
108:11 - line save etc are private or local to
108:16 - main
108:17 - because they are declared within main no
108:19 - other function can have direct access to
108:21 - them
108:22 - the same is true of the variables in the
108:24 - other functions for example the variable
108:26 - i in getline is unrelated to the i in
108:29 - copy
108:31 - each local variable in a routine comes
108:33 - into existence only when a function is
108:35 - called and disappears when the function
108:37 - is exited
108:39 - it is for this reason that such
108:41 - variables are usually known as automatic
108:43 - variables following terminology in other
108:46 - languages
108:47 - we'll use the term automatic henceforth
108:50 - to refer to these dynamic local
108:52 - variables
108:53 - chapter 4 discusses the static storage
108:55 - class in which local variables do retain
108:58 - their values between function
108:59 - invocations
109:01 - because automatic variables come and go
109:03 - with function in invocation
109:06 - they do not retain their values from one
109:08 - call to the next and must be explicitly
109:10 - set upon each entry
109:12 - if they are not set they will contain
109:15 - garbage
109:16 - as an alternative to automatic variables
109:19 - it is possible to define variables which
109:21 - are external to all functions that is
109:23 - global variables which can be accessed
109:26 - by name by any function that cares to
109:29 - this function is rather like fortran
109:31 - common or pl1 external
109:34 - because external variables are globally
109:36 - accessible they can be used instead of
109:38 - arguments to communicate data between
109:40 - functions furthermore because external
109:43 - variables remain in existence
109:45 - permanently rather than appearing and
109:47 - disappearing as functions are called and
109:48 - exited they retain their values even
109:51 - after the functions that set them are
109:54 - done
109:55 - an external variable has to be defined
109:57 - outside of any function this allocates
110:01 - actual storage for it the function also
110:03 - must be declared and each function that
110:05 - wants to access it
110:07 - this may be done either by an explicit
110:10 - extern declaration or implicitly by
110:13 - context
110:14 - to make the discussion concrete let's
110:16 - rewrite the longest line program with
110:19 - line save and max
110:22 - as external variables this requires
110:24 - changing the calls declarations and
110:27 - bodies of all three functions
110:30 - this sample code is on page 29 of the
110:33 - textbook and it's pretty long but i'll
110:36 - read it for you pound include stdio.h
110:40 - pound define max line 1000.
110:44 - and we're still outside of main char
110:46 - line
110:47 - open bracket max line close bracket
110:50 - semicolon
110:52 - char save open bracket max line
110:55 - semicolon
110:56 - int max semicolon those are our three
110:59 - global variables
111:01 - starting the main
111:03 - main open friend close paren
111:05 - open curly brace
111:08 - intlen
111:10 - extern int max so we're saying that this
111:13 - is an integer but it's also not to be
111:15 - allocated inside of main
111:18 - extern char save
111:20 - open
111:21 - square bracket close square bracket
111:24 - the line length the length of the save
111:27 - array is defined above so we don't need
111:29 - to define it here
111:32 - max equals zero semicolon
111:34 - while
111:35 - double parenthesis land double left
111:37 - parenthesis len equals get line
111:40 - parenthesis greater than zero
111:42 - parenthesis
111:43 - if parenthesis len greater than max
111:47 - open curly brace
111:48 - max equals len
111:50 - copy open parenthesis no parenthesis
111:53 - semicolon no parameters to copy
111:55 - because it's going to simply talk to the
111:57 - global variables
111:58 - close curly brace
112:00 - after the loop finishes we say if open
112:02 - parenthesis max greater than zero
112:05 - then printf
112:07 - open parentheses double quote percent s
112:09 - double quote comma save
112:12 - close parenthesis semicolon
112:14 - close close curly brace and that is the
112:17 - end of the main
112:19 - so now we have the getline function
112:20 - which is specialized to deal with
112:23 - external variables
112:25 - okay
112:28 - so
112:29 - we start get line open parentheses close
112:31 - parenthesis no parameters open curly
112:34 - brace int comma c comma int c comma i
112:39 - semicolon these are local variables
112:41 - extern char line open curly brace closed
112:45 - curly brace semicolon
112:48 - this is the our reference inside of
112:51 - getline to the global variable line
112:55 - four open parenthesis i equals 0
112:58 - semicolon i less than max line minus 1
113:02 - max line minus 1 max line is a
113:04 - predefined constant at compile time
113:09 - for i less than max line -1 double
113:11 - ampersand parenthesis c equals get char
113:14 - open parenthesis close parenthesis close
113:16 - parenthesis not equal eof
113:19 - double ampersand
113:21 - i.e and
113:22 - c not equal single quote backslash n
113:26 - single quote semicolon plus plus i
113:29 - lines sub i equals c
113:32 - that's the for loop that in effect reads
113:34 - characters one at a time and puts them
113:35 - in line
113:38 - after the for loop
113:40 - we say if open parenthesis c double
113:43 - equals
113:44 - single quote backslash n single quote
113:46 - close parentheses open curly brace
113:48 - line sub i equals c plus plus i
113:52 - close curly brace this ensures that we
113:55 - append the new line to the function
113:59 - line sub i
114:01 - equals
114:03 - single quote backslash zero backslash
114:05 - that's semicolon the
114:07 - that's the string termination character
114:10 - return i
114:12 - return open parenthesis i close
114:14 - parentheses this is the length that
114:16 - getline is returning and then close
114:18 - curly brace to end the getline function
114:21 - and then we have the copy function and
114:22 - it's again it takes no parameters copy
114:25 - open parentheses close parenthesis curly
114:27 - brace and i
114:29 - extern
114:30 - char
114:31 - line
114:32 - open bracket close bracket
114:34 - comma save open bracket close bracket
114:37 - semicolon
114:38 - i equals 0
114:40 - while
114:41 - parentheses open parenthesis open
114:43 - parenthesis save sub i
114:45 - equals line sub i
114:48 - close parenthesis is not equal
114:50 - quote backslash zero quote
114:53 - plus plus i
114:56 - close curly brace for copy
114:59 - so the external variables in main
115:01 - getline and copy are defined by the very
115:04 - first lines in the example above outside
115:07 - of main which state their type and cause
115:10 - storage to be allocated for them
115:12 - syntactically
115:13 - external definitions are just like the
115:15 - declarations we used previously but
115:18 - because they occur outside of any
115:20 - function including outside the main
115:22 - function the variables are external
115:24 - before a function can use or access an
115:27 - external variable the name of the
115:29 - variable must be made known to the
115:31 - function one way to do this is to write
115:34 - an extern declaration in the function
115:36 - the declaration is the same as before
115:38 - except for the added keyword
115:41 - extern
115:42 - in certain circumstances the extern
115:45 - declaration can be admitted omitted
115:48 - if the external definition of the
115:49 - variable occurs in the same source file
115:52 - before it's used in a particular
115:54 - function then there's no need for an
115:56 - extern declaration in the function
115:58 - the extern declarations in main and
116:00 - getline and copy are thus redundant in
116:02 - fact common practice is to place all
116:05 - definition of all external variables at
116:08 - the beginning of the source file and
116:10 - then omit all extern declarations
116:14 - if the program is in several source
116:16 - files and a variable is defined in say
116:18 - file 1 and used in file 2 then an extern
116:22 - declaration is needed in file 2 to
116:24 - connect the two occurrences of the
116:26 - variables
116:27 - this topic is discussed at length in
116:29 - chapter 4.
116:30 - you should note that we are using the
116:32 - words declaration and definition very
116:35 - carefully when we refer to external
116:36 - variables in this section
116:38 - definition refers to the place where the
116:40 - variable is actually created or assigned
116:42 - storage declaration
116:45 - refers to places where the nature of the
116:46 - variable is stated but no storage is
116:49 - allocated
116:50 - by the way there is a tendency to make
116:52 - everything inside an extern variable
116:54 - because it appears to simplify things
116:57 - argument lists are short and variables
116:59 - are always there when you want them but
117:01 - external variables are always there
117:03 - also when you don't want them the style
117:06 - of coding is fraught with peril since it
117:08 - leads to programs whose data connections
117:10 - are not at all obvious
117:12 - variables can be changed in unexpected
117:14 - and even inadvertent ways and the
117:16 - program is hard to modify when it
117:18 - becomes necessary the second version of
117:21 - the longest line program is inferior to
117:23 - the first partly because of these
117:25 - reasons and partly because it destroys
117:28 - the general at generality of two quite
117:30 - useful functions by hardwiring them into
117:33 - the names of the variables they will
117:35 - manipulate
117:37 - section 1.11
117:39 - summary
117:40 - at this point we have covered what might
117:42 - be called the conventional core of c
117:44 - with this handful of building blocks
117:46 - it's possible to write useful programs
117:48 - of considerable size
117:51 - it probably a good idea if you paused
117:53 - long enough to do so the exercises that
117:56 - follow are intended to give you
117:57 - suggestions for programs of somewhat
118:00 - greater complexity than the ones
118:02 - presented in this chapter
118:04 - after you have this much sea under
118:06 - control it will be well worth your
118:08 - effort to read on for the features
118:11 - covered in the next few chapters are
118:13 - where the power and expressiveness of
118:15 - the language begin to become
118:18 - apparent this work
118:21 - is based on the 1978 c programming book
118:24 - written by brian w kernighan and dennis
118:26 - m ritchie
118:27 - their book is copyright all rights
118:29 - reserved by att
118:31 - but is used in this work under fair use
118:33 - because of the book's historical and
118:35 - scholarly significance
118:37 - its lack of availability and the lack of
118:39 - an accessible version of the book
118:41 - the book is augmented in places to help
118:43 - understand its rightful place in a
118:45 - historical context amidst the major
118:47 - changes of the 1970s and 1980s as
118:50 - computer science evolved from a
118:52 - hardware-first vendor-centered approach
118:54 - to a software-centered approach where
118:56 - portable operating systems and
118:58 - applications written in c could run on
119:00 - any hardware
119:02 - this is not the ideal book to learn c
119:04 - programming because the 1978 edition
119:07 - does not reflect the modern c language
119:09 - using an obsolete book gives us an
119:11 - opportunity to take students back in
119:13 - time and understand how the c language
119:16 - was evolving as it laid the groundwork
119:18 - for a future with portable applications
119:24 - chapter 2 types operators and
119:26 - expressions
119:28 - variables and constants are the basic
119:30 - data objects manipulated in a program
119:33 - declarations list the variables to be
119:34 - used and state what type they have and
119:36 - perhaps what their initial values are
119:39 - operators specify what is to be done to
119:41 - them expressions combine variables and
119:43 - constants to produce new values these
119:46 - are the topics of this chapter
119:48 - section 2.1 variable names
119:52 - although we didn't come out and say so
119:54 - there are some restrictions on variable
119:56 - and symbolic constant names
119:58 - names are made up of letters and digits
120:00 - the first character must be a letter
120:02 - the underscore counts as a letter it is
120:05 - useful for improving the readability of
120:07 - long variable names
120:08 - upper and lower case are different
120:11 - traditional c practice is to use
120:12 - lowercase for variable names in all
120:14 - uppercase for symbolic constants
120:18 - only the first eight characters of an
120:19 - internal name are significant although
120:21 - more may be used for external names such
120:24 - as function names and external variables
120:26 - the number must be less than 8 because
120:28 - external names are used by various
120:30 - assemblers and loaders
120:32 - appendix a lists the details furthermore
120:35 - keywords like if else int float etc are
120:39 - reserved you can't use them as variable
120:41 - names and they must be in lower case
120:44 - i would note that in modern c languages
120:46 - the limitation of the first eight
120:48 - characters of a variable name being
120:49 - unique has been extended in most c
120:51 - variants
120:53 - at least 30 characters of a variable are
120:55 - treated as unique the it character
120:57 - limitation was to reflect the typical
120:59 - limitation of identifier length in
121:00 - assembly language programming and
121:02 - runtime linkers of the time
121:05 - naturally it's wise to choose variable
121:07 - names that mean something that are
121:08 - related to the purpose of the variable
121:10 - and are unlikely to get mixed up
121:12 - typographically
121:14 - section 2.2 data types and sizes
121:17 - there are only a few basic data types in
121:20 - c
121:20 - char which is a single byte
121:23 - capable of holding one character in the
121:24 - local character set
121:26 - and
121:27 - an integer typically reflecting the
121:29 - natural size of integers on the host
121:31 - machine
121:32 - float a single precision floating point
121:35 - and double is a double precision
121:37 - floating point
121:38 - in addition there are a number of
121:40 - qualifiers which can be applied to end
121:42 - short
121:43 - long and unsigned
121:45 - short and long refer to different sizes
121:47 - of integers
121:49 - unsigned numbers
121:50 - obey the arithmetic of modulo 2 to the n
121:53 - where n is the number of bits in an int
121:56 - unsigned numbers are always positive
121:59 - the declarations for qualifiers look
122:00 - like
122:02 - short int x semicolon
122:05 - long int y semicolon
122:08 - unsigned and z semicolon
122:13 - the word in can be omitted in such
122:15 - situations and typically is the
122:18 - precision of these objects depends on
122:19 - the machine at hand the table below
122:22 - shows some representative values
122:25 - on a dec pdp 11 a char is 8 bits on into
122:29 - 16 a short is 16 a char is 32 a float is
122:33 - 32 a double is 64.
122:36 - on a honeywell 6000
122:38 - which uses ascii character set a char is
122:40 - 9 bits an int is 36 bits as short as 36
122:44 - bits a char is 36 bits and a float is 36
122:47 - bits and a double is 32 bits
122:50 - on the ibm 370 which is ebcdic
122:54 - in its character set a char is 8 bits
122:56 - and int is 32 bits as short is 16 bits a
123:00 - char is 32 bits a float is 32 bits and a
123:03 - double is 64 bits
123:05 - and so on the intent is that short and
123:08 - long should provide different lengths of
123:09 - integers where practical
123:12 - int will normally reflect the most
123:14 - natural size of a particular machine
123:17 - as you can see each compiler is free to
123:20 - interpret short and long as appropriate
123:21 - for their own hardware
123:23 - about all you should count on is that
123:25 - short is no longer than long
123:30 - in this table we see that in the
123:31 - mid-1970s
123:33 - c was designed to support a range of
123:35 - computer generations the pdp-11 was a
123:37 - common previous generation computer that
123:40 - had less memory so variable sizes were
123:42 - kept small
123:43 - the more modern computers in the chart
123:45 - had a bit more memory and could afford
123:47 - to have slightly larger larger sizes
123:49 - the idea of a natural size is the size
123:52 - that could be loaded computed and stored
123:55 - in usually of single machine language
123:58 - instruction
123:59 - you knew as a programmer that when used
124:00 - int the machine code you would generate
124:03 - would not need to include an extra
124:05 - instructions for a simple line of code
124:07 - like x equals x plus one semicolon
124:11 - modern int values in c are 32 bits long
124:13 - and long values are 64 bits long
124:16 - even though modern computers can do
124:18 - 64-bit computations in a single
124:20 - instruction using the shorter int type
124:22 - when appropriate can save on memory
124:24 - storage and memory bandwidth using int
124:26 - values
124:27 - interestingly the length of a 32-bit int
124:30 - leads to a unix and c problem with dates
124:34 - that is called the year 2038 problem a
124:37 - common way to represent time in unix c
124:39 - programs was as a 32-bit integer of the
124:42 - number of seconds since
124:44 - january first 1970. it was quick and
124:47 - easy to compare or add or subtract
124:51 - these second counter dates in code and
124:53 - even in databases but the number of
124:55 - seconds since january 1st 1970 will
124:58 - overflow a 30-bit number on the 19th of
125:01 - january in 2038.
125:03 - by now in order to avoid systems in
125:06 - order to avoid problems most systems
125:08 - have converted to storing these number
125:10 - of second values in long or 64-bit
125:13 - values
125:14 - which gives us almost 300 billion years
125:16 - until we need to worry about overflowing
125:18 - second timer counters again
125:21 - back when c was developed we had two
125:23 - different character sets and two
125:25 - different character variable lengths the
125:27 - world generally standardized on the
125:29 - ascii character set for the core western
125:31 - characters and the unicode utf-8 to
125:34 - represent all characters in all
125:36 - languages worldwide
125:38 - but that is a story for another time for
125:40 - now just think of the char type as also
125:43 - a byte type it is 8 bits in length and
125:46 - can store ascii
125:48 - modern languages like python or java
125:50 - have excellent support for wide
125:52 - character sets in our historical look at
125:54 - c we will not cover wide or multi-byte
125:57 - characters
125:59 - also if you look at the float and double
126:00 - types you will see different bit sizes
126:04 - even worse
126:06 - each of these computers in the 1970s did
126:08 - floating point computation using
126:10 - slightly different hardware
126:11 - implementations and the same code run on
126:14 - different computers would give slightly
126:16 - different results and have unpredictable
126:18 - behavior on overflow underflow and other
126:21 - extraordinary floating point operations
126:24 - this was solved by the introduction of
126:26 - the ieee 754
126:29 - standard in 1985 which standardized
126:31 - floating point format
126:33 - this standardized both the length of the
126:35 - float and the double but also ensured
126:37 - that the same set of floating point
126:39 - calculations would produce the exact
126:41 - same result
126:43 - on different processors
126:45 - 2.3 constants int and float constants
126:49 - have already been disposed of except to
126:51 - note that the usual
126:54 - 123.456 e minus 7 or
126:58 - 0.12
127:00 - e3 scientific notation for floats is
127:04 - also legal
127:05 - every floating point constant is taken
127:07 - to be double so the e notation
127:10 - serves for both float and double
127:13 - long constants are written in the style
127:15 - 1 2 3 capital l
127:17 - an ordinary integer constant that is too
127:20 - long to fit into an int is also assumed
127:23 - to be a long
127:24 - there is a notation for octal and
127:26 - hexadecimal constants
127:28 - a leading zero on an int constant
127:31 - implies octal
127:33 - and a leading zero x or zero x upper
127:36 - case indicates hexadecimal
127:39 - for example the decimal 31 can be
127:41 - written as 037 in octal and 0x1 f
127:47 - or 0x1 f where f is capitalized in hex
127:51 - hexadecimal and octal constants may also
127:54 - be followed by the letter l to make them
127:57 - long
127:58 - a character constant is a single
128:00 - character written in single quotes as in
128:02 - quote x quote the value of the character
128:05 - constant is the numeric value of the
128:07 - character in the machine's character set
128:10 - for example the ascii character set
128:12 - 0
128:13 - or quote 0 quote is 48 and an ebcdic
128:17 - quote 0 quote is 240. both quite
128:20 - different from the numeric value zero
128:23 - writing quote zero quote instead of a
128:25 - numeric value like 48 or 240 makes the
128:28 - program independent of the particular
128:30 - value
128:31 - character constants participate in
128:33 - numeric operations just like any other
128:36 - numbers
128:37 - although they are most often used in
128:38 - comparisons with other characters
128:42 - a later section treats conversion rules
128:46 - certain non-graphic characters can be
128:48 - represented in character constants by
128:50 - escape sequence like backslash n for
128:53 - newline backslash t for tab backslash
128:56 - zero for null backslash backslash for
128:58 - backslash itself and backslash quote for
129:01 - single quote etc these look like two
129:04 - characters but they're actually only one
129:07 - in addition an arbitrary byte space bit
129:10 - pattern can be generated by writing
129:14 - single quote backslash and then three
129:16 - digits single quote where the three
129:19 - digits is one to three octal digits as
129:21 - in
129:22 - pound define space form feed single
129:26 - quote backslash zero one four
129:28 - single quote which is ascii for a form
129:31 - feed
129:32 - we mentioned
129:34 - form feed here because in the 1970s we
129:36 - sent much of our output to printers
129:38 - physical printers a form feed was the
129:41 - character we would send to the printer
129:42 - to
129:44 - advance to the top of a new page
129:47 - the character constant quote backslash
129:50 - zero quote
129:52 - represents the character with the value
129:54 - zero
129:56 - quote backslash zero quote is often
129:59 - written instead of zero to emphasize the
130:01 - character nature of some expression
130:05 - a constant expression is an expression
130:07 - that only involves constants
130:10 - such expressions are evaluated at
130:11 - compile time rather than run time and
130:14 - accordingly may be used in
130:16 - any place a constant maybe as in
130:19 - pound define
130:20 - max line 1000
130:23 - char
130:25 - line open bracket max line plus 1 close
130:28 - bracket
130:31 - semicolon
130:32 - or
130:33 - seconds equals 60 times 60 times hours
130:39 - a string constant is a sequence of zero
130:42 - or more characters surrounded by double
130:44 - quotes as in double quote i
130:47 - space am space a space string double
130:50 - quote
130:52 - or
130:52 - double quote double quote which is a way
130:55 - to show an empty string
130:57 - the quotes are not part of the string
130:59 - but only serve to delimit it the same
131:02 - escape sequences used for character
131:04 - constants apply in strings
131:06 - backslash double quote represents the
131:08 - double quote character
131:10 - technically a string is an array whose
131:13 - elements are single characters
131:15 - the compiler automatically places the
131:17 - null character backslash zero at the end
131:20 - of each such string so programs can
131:22 - conveniently find the end this
131:24 - representation means that there is no
131:26 - real limit on how long a string can be
131:29 - but programs have to scan one to
131:31 - completely determine its length
131:34 - the physical storage required is one
131:36 - more location than the number of
131:38 - characters written between the quotes
131:40 - the following function sterlin
131:43 - taking the parameter s returns the
131:45 - length of the character string s
131:47 - excluding the terminal backslash zero
131:51 - sterling open parentheses s close
131:53 - parenthesis
131:55 - char
131:56 - s
131:57 - open bracket close bracket semicolon
131:59 - open curly brace
132:01 - int space i semicolon
132:04 - i equals zero semicolon
132:08 - while parentheses s
132:10 - sub i
132:12 - exclamation equals
132:14 - quote backslash zero quote close
132:17 - parentheses
132:18 - plus plus i semicolon
132:21 - return parentheses i parentheses
132:24 - semicolon close curly brace
132:27 - be careful to distinguish between the
132:29 - character constant and a string that
132:31 - contains a single character single quote
132:34 - x single quote is not the same as double
132:36 - quote x double quote the former is a
132:39 - single character used to produce the
132:41 - numerical value of the letter x of the
132:42 - machine's character set the latter is a
132:45 - character string that contains one
132:46 - character the letter x and a backslash
132:49 - zero
132:51 - section 2.4
132:53 - all variables must be declared before
132:55 - use although certain declarations can be
132:57 - made implicitly by context
132:59 - a declaration specifies a type and is
133:02 - followed by a list of one or more
133:04 - variables of that type as in
133:06 - int
133:08 - lower comma upper comma step semicolon
133:11 - char
133:12 - c comma line
133:15 - open bracket 1000 close bracket
133:17 - semicolon
133:19 - variables can be distributed among
133:20 - declaration in any fashion the list
133:23 - above could we could be equally well
133:25 - written as
133:27 - int lower semicolon in upper semicolon
133:30 - in step semicolon char c semicolon char
133:35 - line open bracket 1000 close bracket
133:37 - semicolon the latter form takes more
133:40 - room but it is convenient for adding a
133:42 - comment to each declaration or for
133:44 - subsequent modifications
133:47 - variables may also be initialized in
133:49 - their declaration although there are
133:51 - some restrictions
133:52 - if the name is followed by an equal sign
133:54 - in a constant that serves as an
133:56 - initializer as in char
133:59 - backslash equals
134:01 - single quote backslash backslash single
134:03 - quote semicolon
134:05 - int
134:06 - i equals 0 semicolon
134:09 - float eps equals 1.0 e minus 5 semicolon
134:15 - if the variable in question is external
134:17 - or static the initialization is done
134:20 - once only conceptually before the
134:22 - program starts executing
134:24 - explicitly initialized automatic
134:26 - variables are initialized each time the
134:28 - function they are in is called
134:30 - automatic variables for which there is
134:32 - no explicit initializer have undefined
134:35 - that is garbage values
134:37 - external and static variables are
134:39 - initialized to zero by default but it is
134:41 - a good style to state the initialization
134:44 - anyway
134:45 - we will discuss initialization further
134:47 - as new data types are introduced
134:51 - section
134:52 - 2.5 arithmetic operators
134:56 - the binary operators
134:58 - are
134:58 - plus
135:00 - minus
135:00 - asterisk and slash
135:03 - and the modulus operator percent
135:05 - there is a unary minus but no unary plus
135:10 - integer division truncates any
135:12 - fractional fractional part the
135:15 - expression x percent y
135:18 - produces the remainder when x is divided
135:20 - by y and is thus zero when y divides x
135:24 - exactly
135:26 - for example a year is a leap year if it
135:29 - is divisible by 4 but not by 100
135:32 - except that years divisible by 4 are
135:34 - leap years therefore
135:37 - if parentheses year percent for equal
135:40 - equal zero
135:42 - and and
135:43 - year percent
135:45 - 100 not equal zero
135:48 - or
135:49 - year percent 400 equal equal zero it's a
135:53 - leap year
135:54 - else it's not
135:56 - the percent operator cannot be applied
135:58 - to float or double
136:01 - the plus and minus operators have the
136:03 - same precedence
136:04 - which is lower than the identical
136:07 - precedence of asterisk slash and percent
136:10 - which are in turn lower than unary minus
136:14 - arithmetic operators group from left to
136:16 - right a table at the end of this chapter
136:19 - summarizes precedence and associativity
136:21 - for all operators
136:23 - the order of evaluation is not specified
136:26 - for associative and commutative
136:28 - operators like asterisk and plus
136:31 - the compiler may rearrange a
136:33 - parenthesized computation involving
136:35 - these thus
136:37 - a plus open parenthesis b plus c closed
136:39 - parenthesis can be evaluated as
136:43 - open parenthesis a plus b close
136:44 - parentheses plus c
136:46 - this rarely makes any difference but if
136:49 - a particular order is required explicit
136:52 - temporary variables might be used
136:54 - the action on overflow or underflow
136:57 - depends on the machine at hand
137:00 - i would note that the above
137:02 - paragraph allows the compiler
137:09 - i would note that the above paragraph
137:11 - allowing the compiler to reorder
137:13 - computations even in the parentheses
137:15 - presence of parentheses is known as the
137:17 - knr c arrangement license
137:21 - as the authors state it almost never
137:23 - makes a difference unless an expression
137:25 - contains a value computed in a function
137:27 - call or is there a pointered lookup to
137:29 - find a value for the computation that
137:31 - might fail
137:32 - the rule was subtly adjusted in the iso
137:35 - version of c but iso c still does not
137:38 - strictly force the order of otherwise
137:40 - commutative operations even in the pr
137:43 - presence of parentheses
137:46 - the good news is that as long as you
137:47 - keep your expression simple you don't
137:49 - have to worry about this rule sometimes
137:50 - the real value of parentheses is to
137:52 - communicate your intentions to the human
137:54 - readers of your code
137:56 - if you are writing code that depends on
137:58 - the order of overflow
138:00 - function calls and pointer dereferences
138:02 - in a single mathematical expression
138:04 - perhaps you should break your expression
138:07 - into multiple
138:08 - statements section 2.6 relational and
138:12 - logical operators the relational
138:14 - operators are greater than greater than
138:17 - or equal
138:18 - less than less than or equal
138:20 - they all have the same precedence
138:22 - just below them in precedence are the
138:24 - equality operators double equals and
138:27 - exclamation equals which have the same
138:29 - precedence
138:30 - relationals have lower precedence than
138:33 - arithmetic operators so expressions like
138:35 - i less than limb minus 1 are taken as i
138:39 - less than open parenthesis limb minus 1
138:42 - close parenthesis as would be expected
138:45 - more interesting are the logical
138:47 - connectives double ampersand and double
138:50 - vertical bar and an or
138:53 - expressions connected by double
138:55 - ampersand or double vertical bar are
138:56 - evaluated left to right and the
138:58 - evaluation stops as soon as the truth or
139:01 - falsehood of the result is known
139:04 - these properties are critical in writing
139:07 - programs that work
139:09 - for example
139:10 - here is a loop from the input function
139:12 - get line which we wrote in chapter one
139:14 - for parenthesis i equals zero semicolon
139:18 - i less than lim minus one double
139:20 - ampersand
139:21 - parenthesis
139:23 - c equals get char open parenthesis close
139:25 - parenthesis close parenthesis not equal
139:28 - single quote backslash n single quote
139:31 - double ampersand
139:33 - c exclamation equal e o f semicolon plus
139:37 - plus i
139:39 - close parenthesis
139:41 - s sub i equals c
139:44 - clearly before reading a new character
139:46 - it is necessary to check that there's
139:48 - room to store the array so the test i
139:50 - less than lim minus 1 must be made first
139:54 - not only but if this test fails
139:58 - we must not go on and read another
139:59 - character
140:00 - similarly it would be unfortunate if c
140:03 - were tested against eof before getchar
140:05 - was called
140:06 - the call must occur before the character
140:09 - c is checked against dof
140:12 - the precedence of double ampersand and
140:15 - is greater than that of double vertical
140:17 - bar or and both are lower than the
140:20 - relational inequality operators so
140:22 - expressions like i
140:24 - less than limb minus one double
140:26 - ampersand parenthesis c equals char open
140:29 - print close paren close paren not equal
140:32 - single quote backslash n single quote
140:35 - double ampersand c not equal eof needs
140:38 - no extra parenthesis but since the
140:40 - parentheses of
140:42 - not equals is higher than assignment
140:44 - parentheses do need to be added in
140:46 - open print c equals get char open print
140:49 - close paren close print not equal
140:51 - backslash n
140:53 - to achieve the desired result
140:56 - let's take a brief digression
141:00 - one of the great debates of the 1970s
141:02 - was how to use structured programming
141:05 - to avoid any use of go-to statements
141:07 - that lead to completely unreadable
141:09 - spaghetti code
141:10 - structured code was easier to read debug
141:13 - and validate structured code advocated
141:16 - for if then else else if while do loops
141:19 - and do while loops where the loop exit
141:21 - test was at the top or the bottom of the
141:23 - loops respectively
141:26 - there was a move from flowcharts with
141:28 - lines boxes and arrows to to structure
141:30 - programming techniques
141:31 - like nashi schneiderman diagrams that
141:33 - you did used nested boxes to emphasize
141:36 - the structured nature of the code
141:39 - the proponents of each approach tended
141:41 - to approach the problem based on the
141:42 - language they used
141:44 - algol and pascal programmers were strong
141:46 - advocates of structured programming and
141:48 - those languages had syntax that
141:50 - encouraged the approach
141:52 - fortran programs
141:54 - had decades of flowchart use and style
141:57 - flowchart style thinking intended to
142:00 - avoid full adoption of structured
142:01 - programming
142:03 - kurdian and ritchie chose a middle path
142:05 - and made it so that c could support both
142:07 - approaches to avoid angering either side
142:10 - of the structure programming debate
142:13 - one area where the structured code
142:14 - movement kept hitting a snag
142:16 - was implementing a loop that reads a
142:18 - file and processes data until it reaches
142:21 - the end file
142:23 - the loop must be able to handle an empty
142:25 - file or no data at all
142:29 - there are three ways to construct a read
142:31 - and process until eof loop and none of
142:33 - the approaches are ideal
142:36 - the loop constructions that you can do
142:38 - are a top tested loop with prime a
142:40 - priming read before the loop
142:42 - a bottom tested loop with a read as the
142:44 - first statement in the loop and then if
142:46 - then else is the rest of the body of the
142:48 - loop
142:49 - a top tested infinite loop with a
142:51 - priming read and a middle test and exit
142:53 - and a top tested loop with a side effect
142:56 - read in the test of the loop
142:58 - which is the way that kernighan and
142:59 - ritchie chose to document
143:01 - in this chapter
143:03 - all of this
143:04 - serves to explain the syntax
143:06 - while
143:07 - open parenthesis open parenthesis c
143:10 - equals get char open paren close print
143:12 - close parenthesis not equal eof close
143:15 - parenthesis open curly brace body of the
143:18 - loop close curly brace this construct is
143:21 - a topped tested loop which most
143:23 - programmers prefer
143:24 - and it folds the priming read and puts
143:27 - its value inside the variable c
143:31 - but since the getchar might also return
143:33 - eof we need to check if we actually
143:35 - receive no data at all and need to avoid
143:37 - executing the body of the loop
143:39 - or exit the loop
143:41 - if eof were defined as zero instead of
143:45 - minus 1. the loop could have been
143:46 - written
143:47 - while open parenthesis c equals get char
143:50 - open paren close paren close parenthesis
143:53 - open curly brace body of the loop close
143:55 - curly brace
143:56 - now
143:58 - the get jar function returns a character
143:59 - or zero and the test itself is looking
144:01 - at the side effect or residual value of
144:04 - the assignment statement to decide to
144:06 - start and or continue the loop body
144:09 - the problem with using zero is end of
144:11 - file if you are reading a binary file
144:13 - like jpeg data a zero character might
144:16 - make perfect sense and we would not want
144:18 - to incorrectly end the loop because of a
144:21 - zero character in input data that does
144:23 - not end a file
144:25 - so we get the double parentheses syntax
144:28 - the side effect call to getchar and test
144:30 - the return value
144:32 - within the while test
144:34 - i'm quite confident that this is far
144:36 - more detail that you wanted here in
144:37 - chapter two but as it is as good a time
144:40 - as any to understand how much thought
144:42 - goes into a programming language how it
144:44 - is designed and documented
144:46 - by the time we finish chapter 3 and look
144:48 - at the break and continue statements
144:50 - which are in languages like python and
144:52 - java you will see that this 50 year old
144:55 - structured programming debate
144:58 - debate is still unresolved in the minds
145:00 - of many software developers
145:03 - back to the book
145:05 - the unary negation operator logical
145:08 - negation operator converts a non-zero or
145:11 - true operand into zero in a zero or
145:13 - false operand into one
145:16 - a common use of exclamation which we
145:18 - often call bang is in constructions like
145:21 - if open parenthesis exclamation point in
145:24 - word close parenthesis
145:26 - rather than if open parenthesis inward
145:29 - equal equals zero
145:31 - it is hard to generalize about which of
145:32 - these two forms is better construction
145:35 - like exclamation inward read quite
145:37 - nicely as if not in word
145:40 - but more complicated ones can be hard to
145:42 - understand
145:44 - section 2.7 type conversions
145:48 - when operands of different types appear
145:50 - in expressions they are converted to a
145:51 - common type according to a small number
145:54 - of rules
145:55 - in general the only conversions that
145:57 - happen automatically are those that make
145:59 - sense such as converting an integer to a
146:01 - floating point in an expression like f
146:04 - plus i expressions that don't make sense
146:07 - like using a float in a subscript are
146:10 - disallowed
146:12 - first
146:13 - chars and inst may be freely intermixed
146:16 - in arithmetic expressions
146:18 - every chart in an expression is
146:19 - automatically converted to an end
146:22 - this permits considerable flexibility in
146:24 - certain kinds of character
146:25 - transformations
146:27 - one is exemplified by the function a to
146:29 - i which converts a string of digits into
146:32 - its numeric equivalent
146:34 - a to y open parenthesis s close
146:36 - parenthesis
146:37 - char s open bracket close bracket
146:40 - semicolon
146:42 - open curly brace int i comma n semicolon
146:46 - n equals zero
146:48 - four parenthesis i equals zero semicolon
146:51 - s sub i greater than or equal to quote
146:54 - zero quote double ampersand
146:57 - s sub i less than or equal to double
147:00 - quote nine quote semicolon plus plus i
147:04 - close parentheses
147:06 - n equals 10
147:09 - asterisk n plus
147:11 - s sub i minus single quote 0 single
147:14 - quote semicolon
147:16 - return open parenthesis and close
147:18 - parentheses semicolon close curly brace
147:21 - to end the function
147:22 - as we discussed in chapter 1 the
147:24 - expression s sub i minus quote 0 quote
147:28 - gives the numeric value of the character
147:30 - stored in sub i because the values 0
147:33 - 1 etc form a continuously increasing
147:36 - positive sequence positive sequence
147:39 - another example
147:41 - of the card chart in conversion is the
147:43 - function lower which match a single
147:46 - character to lower case for the ascii
147:48 - character set only
147:50 - if the character is not an upper case
147:52 - letter lower is returned unchanged
147:55 - here's a function
147:56 - lower open parentheses c closed
147:58 - parenthesis
148:00 - int c semicolon open curly brace
148:04 - if open parenthesis c greater than or
148:07 - equal to quote capital a quote
148:10 - double ampersand c
148:12 - less than or equal to quote z quote
148:15 - uppercase z
148:17 - parenthesis return
148:20 - open parenthesis c plus
148:22 - quote lowercase a quote minus quote
148:25 - uppercase a quote close parentheses
148:28 - semicolon else return c
148:31 - this works for ascii because the
148:33 - corresponding upper and lowercase
148:35 - letters are a fixed distance apart as
148:38 - numeric values and each alphabet is
148:40 - contiguous
148:41 - there is nothing but letters between a
148:43 - and z
148:44 - this latter observation is not true of
148:47 - the ebcdic character set on ibm 360 370
148:50 - architectures so this code fails on such
148:52 - systems it converts more than letters
148:56 - there is one subtle point about the
148:57 - conversion of characters to integer
149:00 - the language does not specify whether
149:02 - character where the variables of type
149:04 - char are signed or unsigned quantities
149:07 - when char is converted to an int
149:10 - can it ever produce a negative number
149:13 - unfortunately this varies from machine
149:15 - to machine reflecting differences in
149:17 - architecture
149:18 - on some machines
149:21 - for instance a char whose left most bit
149:24 - is one will be converted to negative
149:27 - integer using sign extension
149:29 - on others a char is promoted to an in by
149:31 - adding zeros at the left end and is thus
149:34 - always positive
149:38 - the definition of c guarantees that any
149:40 - character in the machine standard
149:42 - character set will never appear to be
149:44 - negative so these characters may be used
149:46 - freely in expressions as positive
149:48 - quantities but
149:49 - arbitrary bit patterns stored in
149:51 - character variables may appear to be
149:53 - negative on some machines yet positive
149:56 - on others
149:58 - the most common occurrence of this
149:59 - situation is when the value negative 1
150:02 - is used for eof consider the code
150:05 - char
150:06 - c semicolon
150:08 - c equals get char open print close paren
150:11 - semicolon if open print c double equals
150:15 - eof close paren dot dot dot
150:18 - on a machine which does not do sign
150:20 - extension c is always positive because
150:23 - it returns a char
150:24 - yet eof is negative as a result this
150:27 - test always fails to avoid this we have
150:29 - been careful to use int instead of char
150:32 - for any variable which holds a value
150:35 - returned by the function getchar
150:38 - the real reason for using int instead of
150:40 - char is not related to any questions of
150:42 - possible sign extensions it is simply
150:45 - that getchar must return all possible
150:47 - characters so that it can be root used
150:49 - to read arbitrary input and in addition
150:52 - a distinct eof value
150:54 - thus its value cannot be represented as
150:56 - a care
150:57 - char but must instead be stored as an
151:00 - int
151:02 - as an aside since the book was written
151:05 - before the getchar function was
151:06 - standardized the text is somewhat vague
151:08 - in this section
151:10 - shortly after the book was published
151:11 - getchar was put into the stdio.h library
151:15 - and declared to return an integer so as
151:18 - to accommodate
151:19 - all possible characters and the integer
151:21 - -1 value to indicate the end file
151:25 - the above code would be better written
151:27 - with c declared as an integer
151:30 - intc semicolon
151:32 - c equals get char open paren close paren
151:34 - semicolon
151:36 - if
151:37 - open print c double equal eof close
151:39 - paren dot dot
151:41 - while the conversion from char to int
151:43 - may or may not have sign extension and
151:46 - yes it still depends on the
151:47 - implementation 50 years later the
151:50 - conversion from into char is predictable
151:52 - with the top bits being simply discarded
151:56 - if you're using the library function get
151:58 - s to read a file line by line we don't
152:00 - need to worry about this conversion
152:02 - since git s returns a pointer to a
152:04 - character array i.e a string it
152:07 - indicates that reach has reached end of
152:09 - file by returning the null pointer i.e
152:11 - there is no more data to give
152:15 - back to the textbook
152:18 - another useful form of automatic type
152:20 - conversions is that relational
152:21 - expressions like i greater than j and
152:24 - logical expressions constructed by
152:26 - double ampersand and double vertical bar
152:28 - and and or respectively are defined to
152:30 - have the value 1 if true and 0 if false
152:33 - thus the assignment
152:36 - is digit equals c greater than or equal
152:39 - to quote 0 quote double ampersand c less
152:42 - than or equal to quote 9 quote sets the
152:44 - variable is digit to 1 if c is a digit
152:47 - and 0 if it's not
152:50 - in the if test of a
152:52 - in a test part of an if while or four
152:55 - true just means non-zero
152:59 - implicit arithmetic conversions would
153:01 - work much as expected
153:03 - in general if an operator likes c or
153:05 - asterisk for multiplication which takes
153:08 - two operators i.e a binary operator if
153:10 - it has operated operands of different
153:13 - types the lower type is promoted to the
153:15 - higher type before the operation
153:16 - proceeds and the result is the higher
153:18 - type
153:19 - more precisely for each arithmetic
153:21 - operator the following sequence of
153:24 - conversion rules
153:25 - is applied
153:26 - char and short are converted to int and
153:29 - float is converted to double
153:31 - then if either operand is double the
153:33 - other is converted to double and the
153:34 - result is double
153:36 - otherwise if either operand is long and
153:38 - the other is converted to long the
153:39 - result is long
153:40 - otherwise if either operand is
153:42 - operand is unsigned the other is
153:44 - converted to unsigned and the result is
153:46 - unsigned otherwise
153:49 - the operands must be int and the result
153:51 - isn't
153:52 - note that all float values in an
153:54 - expression are converted to double all
153:56 - floating point arithmetic in c is done
153:59 - in double precision
154:01 - conversions take place across
154:03 - assignments
154:04 - the value of the right side is converted
154:06 - to the type of the left
154:08 - which is the type of the result a
154:10 - character is converted to an integer
154:12 - either by sign extension or not as
154:14 - described above the reverse operation
154:17 - into char is well behaved excess high
154:19 - order bits are simply discarded thus in
154:22 - int i semicolon char c semicolon i
154:26 - equals c
154:27 - c equals i the value of c is unchanged
154:31 - and this is true whether or not sign
154:33 - extension is involved
154:35 - if x is float and i is int then x equals
154:39 - i and i equals x both cause conversions
154:44 - float to end causes truncation of any
154:46 - fractional part
154:48 - double is converted to float by rounding
154:50 - longer ins are converted
154:52 - to shorter ones by or to charge by
154:55 - dropping excess high order bits
154:58 - since a function argument is an
155:00 - expression type conversions also take
155:03 - place when arguments are passed to
155:04 - functions
155:06 - in particular char and short become int
155:08 - and float becomes double and that is why
155:10 - we have declared function arguments to
155:12 - be int and double even when the function
155:15 - is called with char and float
155:17 - finally
155:18 - explicit type conversions can be forced
155:22 - also we call it coerced in any
155:24 - expression with a construct called the
155:26 - cast
155:28 - in the construction open parenthesis
155:30 - type name close parentheses expression
155:32 - the expression is converted to the named
155:34 - type by the conversion rules above
155:37 - the precise meaning of cast is in fact
155:40 - as if the expression were assigned to a
155:42 - variable of the specified type which is
155:45 - then used in place of the whole
155:47 - construction
155:48 - for example the library square root sqrt
155:52 - expects a double argument and will
155:54 - produce nonsense if inadvertently handed
155:56 - something else so if n is an integer
156:01 - sqrt open parenthesis open parenthesis
156:04 - double close parenthesis n close
156:06 - parenthesis converts n to double before
156:09 - passing it to sqrt
156:12 - note that the cast produces the value of
156:14 - n in the proper type the actual content
156:16 - of n is not altered the cast operator
156:20 - has the same
156:21 - precedence as other unary operations as
156:24 - is summarized in the table at the end of
156:26 - this chapter
156:29 - section 2.8 increment and decrement
156:32 - operators
156:33 - c provides two unusual operators for
156:35 - incrementing and decrementing variables
156:38 - the increment operator plus plus adds
156:40 - one to its operand the decrement
156:43 - operator minus minus subtracts one
156:45 - we have frequently used plus plus
156:47 - increment variables as in if open
156:50 - parentheses c equals equals single quote
156:53 - backslash n single quote closed
156:54 - parenthesis
156:56 - plus plus nl semicolon
156:59 - the unusual aspect is that plus plus and
157:01 - minus minus may be used either as prefix
157:04 - operators ie before the variable as in
157:07 - plus plus n or postfix after the
157:09 - variable n plus plus
157:12 - in both cases the effect is to increment
157:14 - n
157:15 - but the expression the residual value of
157:18 - the expression plus plus n
157:20 - increments n before using its value
157:23 - while n plus plus increments and after
157:26 - its value has been used
157:28 - this means that in a context
157:30 - where the value is used
157:32 - not just the effect
157:34 - plus plus n and n plus plus are
157:36 - different if n is 5
157:38 - then x equals n plus plus semicolon sets
157:42 - x to 5 the old value
157:44 - but x equals plus plus n semicolon sets
157:49 - x to 6
157:50 - the new value
157:51 - in both cases n becomes 6.
157:54 - the increment and decrement operators
157:56 - can only be applied to variables
157:59 - an expression like x equals open
158:01 - parenthesis i plus j close parenthesis
158:03 - parenthesis plus plus is illegal
158:08 - in a context where no value is wanted
158:10 - just incrementing effect as in if open
158:13 - parentheses c double equals single quote
158:15 - backslash n
158:17 - single quote close parenthesis and l
158:19 - plus plus semicolon
158:20 - choose prefix or postfix according to
158:22 - taste
158:23 - but there are situations where one or
158:25 - the other is specifically called for for
158:28 - example consider the function squeeze s
158:31 - comma c which removes all occurrences of
158:34 - the character c from the string s
158:39 - squeeze open parenthesis s comma c close
158:41 - parenthesis
158:42 - char
158:44 - s
158:45 - open
158:45 - bracket close bracket semicolon int c
158:48 - semicolon open curly brace int i comma j
158:52 - semicolon
158:54 - for parenthesis i equals j equals zero
158:58 - semicolon
159:00 - s sub i
159:02 - not equal to
159:04 - single quote backslash zero single quote
159:06 - semicolon i plus plus close parentheses
159:10 - if
159:11 - open parenthesis s sub i
159:13 - not equal to c close parenthesis
159:16 - s sub j plus plus
159:19 - close parenthesis equals s sub i
159:23 - and outside the for loop totally s sub j
159:26 - equals
159:27 - backslash quote
159:32 - s sub j
159:34 - equals quote backslash zero quote
159:36 - semicolon close curly brace
159:40 - each time a non-c a character other than
159:44 - what's in the variable c occurs is
159:46 - copied into the current j position and
159:49 - only then is j incremented to be ready
159:51 - for the next character this is exactly
159:53 - equivalent to
159:55 - if open parenthesis s sub i not equal to
159:57 - c close parenthesis open curly brace
160:00 - s sub j equals s sub i
160:04 - semicolon j plus plus semicolon close
160:07 - curly brace
160:09 - another example of a similar
160:11 - construction comes from the getline
160:12 - function we wrote in chapter one where
160:14 - we can replace if open parenthesis c
160:16 - double equals quote backslash n quote
160:20 - close parenthesis open curly brace s sub
160:22 - i equals c
160:24 - semicolon plus plus i semicolon close
160:27 - parenthesis by the far more compact
160:30 - if parentheses c double equals quote
160:33 - backslash end quote close parentheses s
160:36 - sub i plus plus equals c semicolon
160:40 - in a third example the function stir cat
160:43 - concatenates the string t to the end of
160:45 - the string s
160:46 - stir cat does assume that there's enough
160:48 - space in s to hold the combination
160:52 - here's the code
160:53 - stir cat open parentheses s comma t
160:56 - close parenthesis
160:58 - char
160:59 - s open bracket close bracket comma t
161:02 - open bracket close bracket semicolon
161:05 - open curly brace int i comma j semicolon
161:10 - i equals j equals 0 semicolon
161:14 - while open paren
161:16 - s sub i not equal
161:19 - single quote backslash zero single quote
161:21 - close paren i plus plus
161:24 - in this we'd find the end of s
161:27 - while open parenthesis open parenthesis
161:30 - s sub i plus plus equals
161:33 - t sub j plus plus close parenthesis not
161:36 - equal backslash zero
161:38 - close parentheses semicolon
161:41 - that code copies the rest of t
161:43 - into s
161:44 - close curly brace
161:46 - as each character is copied from t to s
161:48 - the postfix plus plus is applied to both
161:51 - i and j to make sure they are in
161:53 - position for the next pass
161:55 - through the loop
161:58 - section 2.9 bitwise logical operators
162:01 - c provides a number of operators for bit
162:04 - manipulation
162:05 - these may not be applied to float or
162:07 - double
162:09 - ampersand is bitwise and vertical bar is
162:12 - bitwise inclusive or
162:15 - carrot is bitwise exclusive or
162:18 - less than less than is left shift and
162:20 - greater than greater than is right shift
162:22 - and tild is one complements and it's a
162:25 - unary operator
162:26 - the bitwise and operator
162:29 - ampersand is often used to mask off some
162:31 - set of bits for example
162:34 - c equals n ampersand 0 1 7 7 sets to 0
162:40 - all but the lower 7 bits of n the
162:43 - bitwise or operator is used to turn bits
162:45 - on
162:46 - x equals x vertical bar mask
162:50 - sets to 1 the x bits that are set to one
162:53 - in mask
162:55 - you should carefully distinguish the
162:57 - bitwise operator ampersand and vertical
162:59 - bar from the logical connectives double
163:01 - ampersand and double vertical bar which
163:04 - imply left to right evaluation of a
163:06 - truth value
163:07 - for example if x is 1 and y is 2 then x
163:12 - single ampersand y is 0
163:15 - while x double ampersand y is 1.
163:18 - think about that for a moment
163:21 - the shift operators less than less than
163:23 - and greater than greater than
163:25 - perform left and right shifts
163:27 - respectively of their left operand by
163:29 - the number of bit positions given by the
163:31 - right operand
163:32 - thus
163:33 - x less than less than 2 shifts x left by
163:37 - two positions filling the vacated bits
163:39 - with zero
163:41 - this is the equivalent to multiplication
163:43 - by four
163:44 - right shifting an unsigned quantity
163:46 - fills the vacated bits with zero
163:49 - right shifting a sine quantity will fill
163:51 - the sine bits
163:53 - arithmetic shift on some machines such
163:55 - as pdp 11 and with and with zero bits
163:58 - logical shift on other
164:01 - the unary operator tilled
164:03 - yields the ones complement of an integer
164:06 - that is
164:07 - it converts each one bit into a zero bit
164:10 - and vice versa
164:11 - this operator typically finds use in
164:14 - expressions like
164:15 - x
164:16 - ampersand tilled
164:19 - 077
164:20 - which masks the last six
164:23 - bits of x to zero
164:25 - note that x ampersand tilde 0 7 7 is
164:29 - independent of word length
164:31 - and is thus preferable to for example
164:35 - x
164:36 - ampersand 0 1 7 7 7 0 0 which assumes
164:40 - that x is a 16 bit quantity
164:43 - the portable form involves no extra
164:45 - cause since killed zero seven seven is a
164:48 - constant expression and thus evaluated
164:50 - at compile time
164:53 - to illustrate the use of sum of the bit
164:55 - operators consider the function get bets
164:58 - open parenthesis x comma p comma n which
165:01 - returns the right adjusted n bit field
165:03 - of x that visit begins at position p
165:07 - we assume that position
165:09 - 0 is at the right end and that n and p
165:12 - are sensible positive values for example
165:15 - get bits
165:16 - open print x comma 4 comma 3
165:19 - close print returns the three bits in
165:22 - bit positions 4 3 and 2 write adjusted
165:27 - here we go with the code
165:28 - get bits open print x comma p comma n
165:32 - unsigned x comma p comma n semicolon
165:35 - open curly brace
165:38 - return
165:40 - open parenthesis open parenthesis x
165:42 - greater than greater than open
165:44 - parenthesis p plus 1 minus n close
165:46 - parenthesis close parenthesis
165:48 - and ampersand
165:50 - tild open parenthesis till 0
165:54 - less than less than in closed
165:56 - parenthesis close parenthesis semicolon
165:58 - close curly brace
166:00 - x greater than greater than parenthesis
166:03 - p plus one minus n
166:05 - close parenthesis moves the desired
166:06 - field to the right end of the word
166:08 - declaring the argument to be x
166:11 - declaring the argument x to be unsigned
166:13 - ensures that when it is right shifted
166:15 - vacated bits will be filled with zeros
166:17 - not sign bits regardless of the machine
166:19 - the program is run on
166:21 - tilde zero is all one bits shifting it
166:25 - left n bit positions with tilde 0 left
166:28 - shift
166:29 - tilde 0 less than less than n creates a
166:32 - mask with the zeros in the right most n
166:34 - bits and ones everywhere else
166:36 - complementing that with tilled makes a
166:39 - mask with ones in the right most bits
166:43 - bitwise operators may seem unnecessary
166:45 - for modern computers
166:47 - but if you look at the internal
166:48 - structure of tcpip packets the values
166:51 - are packed very tightly into the headers
166:52 - in order to save space
166:54 - c made it possible to write portable
166:57 - tcpi implementations on a wide range of
166:59 - hardware architectures
167:01 - bitwise operators also play an important
167:04 - role in encryption decryption and
167:06 - checksum calculations
167:08 - modern languages like java and python
167:10 - support bitwise operators following the
167:12 - same patterns that we established in c
167:15 - so that things like tcpip and encryption
167:17 - algorithms can also be implemented in
167:19 - these languages
167:21 - by defining these operators it kept
167:23 - software developers from needing to
167:25 - write non-portable assembly language to
167:27 - implement these low-level features in
167:29 - operating systems and libraries
167:32 - section 2.10 assignment operators and
167:35 - expressions
167:37 - expressions such as i equals i plus 2 in
167:40 - which the left-hand side is repeated on
167:42 - the right can be written in the
167:44 - compressed form i plus equals 2 using an
167:47 - assignment operator like plus equals
167:50 - most binary operators operators like
167:53 - plus that have a left and right operand
167:55 - have a corresponding
167:57 - assignment operator op equals where op
168:00 - is one of plus
168:01 - minus
168:03 - asterisk for multiplication slash for
168:05 - division percent for modulo
168:08 - less than less than
168:09 - left shift
168:11 - greater than greater than right shift
168:14 - ampersand bitwise and
168:16 - carrot exclusive or
168:17 - vertical bar bitwise or
168:20 - if e1 and e2 are expressions then e1
168:25 - operand equals e2 is equivalent to e1
168:28 - equals e1 operand e2
168:31 - except that e1 is only computed once
168:33 - note the parentheses around e2
168:38 - x
168:39 - star equals y plus 1 is actually
168:42 - x equals x times parenthesis y plus 1
168:46 - close parenthesis rather than
168:48 - x times y plus 1.
168:51 - as an example function bit count counts
168:53 - the number of one bits in its integer
168:55 - argument
168:57 - here's the code
168:59 - bit count open parentheses in close
169:01 - parenthesis unsigned and semicolon
169:05 - open curly brace into b
169:09 - four open parenthesis b equals 0
169:11 - semicolon
169:13 - and exclamation equals 0 semicolon
169:16 - n
169:18 - greater than greater than equal 1
169:21 - close parenthesis
169:24 - if open parenthesis in ampersand
169:27 - 0 1
169:28 - close parenthesis
169:30 - b plus plus semicolon
169:33 - return
169:34 - open print b close print semicolon curly
169:37 - brace
169:38 - quite apart from its conciseness
169:41 - assignment operators have the advantage
169:43 - and that they correspond better to way
169:45 - the way people think we said we say add
169:47 - 2 to i or increment i by 2 not take i
169:51 - add 2 and put the result back in i
169:53 - thus
169:54 - i plus equal to
169:56 - in addition for a complicated expression
169:58 - like
170:00 - yy val
170:01 - open
170:02 - bracket yypv open bracket p3 plus p4
170:07 - close bracket plus yypv
170:10 - open bracket p1 plus 2 p2 close bracket
170:14 - close bracket plus equals 2
170:16 - the assignment operator makes it code
170:18 - easier to understand since the reader
170:20 - doesn't have to check painstakingly that
170:22 - too long expressions are indeed the same
170:25 - or wonder why they're not
170:27 - an assignment operator may even help the
170:29 - compiler to produce more efficient code
170:32 - we have already used the fact that the
170:34 - assignments statement has a side effect
170:36 - value and can occur in expressions the
170:39 - most common example is while open
170:42 - parentheses open parenthesis c equals
170:44 - get char open parenthesis close
170:46 - parenthesis close parenthesis
170:48 - exclamation equal eof close parentheses
170:51 - and then the rest of the loop
170:53 - assignments using other assignment
170:55 - operators plus equal minus sql can also
170:57 - occur in expressions although it's a
170:59 - less frequent occurrence
171:01 - the type of an assignment expression is
171:03 - the type of its left operand
171:05 - section 2.11 conditional expressions
171:09 - the statements
171:10 - if parentheses a greater than b
171:13 - close parentheses c equals a semicolon
171:16 - else z equals b semicolon of course
171:20 - compute z in the maximum of a and b
171:23 - the conditional expression written with
171:25 - a ternary operator which is question
171:27 - mark and colon provides an alternate way
171:29 - to write this and similar constructions
171:32 - in the expression e1 question mark e2
171:36 - colon e3
171:37 - the expression e1 is evaluated first
171:40 - if it is non-zero true then the
171:42 - expression e2 is evaluated and that is
171:45 - the value of the conditional expression
171:47 - otherwise e3 is evaluated and that is
171:49 - the value only one of e 2 and e 3 are
171:52 - evaluated thus to set the z to set z to
171:56 - the maximum of a and b we say
171:59 - z equals parentheses a greater than b
172:02 - close parentheses question mark a
172:05 - colon b
172:07 - and this implements z equals max of a
172:10 - and b
172:11 - it should be noted that the conditional
172:13 - expression is indeed an expression and
172:15 - can be used just as any other expression
172:18 - if e1 and if e2 and e3 are different
172:21 - types their type of the result is
172:23 - determined by the conversion rules
172:24 - described earlier in this chapter for
172:27 - example if f is a float and n is an end
172:29 - then the expression
172:31 - parentheses n greater than zero closed
172:33 - parenthesis
172:34 - question mark f colon n
172:37 - is of type double regardless of whether
172:40 - n is positive or not
172:42 - parentheses are not necessary around the
172:44 - first expression of a conventional
172:46 - expression since the precedence of
172:48 - question mark colon is very low just
172:50 - above assignment they are advisable
172:53 - anyway however since they make the
172:54 - condition part of the expression easier
172:57 - to see
172:58 - the conditional expression often leads
173:00 - to succinct code for example
173:03 - this loop print prints n elements of an
173:06 - array 10 per line with each column
173:08 - separated by one blank and with each
173:10 - line including the last terminated by
173:12 - exactly one new line
173:14 - here's the code four parentheses i
173:17 - equals zero semicolon i less than n
173:20 - semicolon i plus plus close parentheses
173:24 - printf open parentheses double quote
173:26 - percent 6d percent c
173:30 - double quote comma
173:32 - a sub i
173:34 - comma
173:36 - open parenthesis
173:37 - i percent 10
173:39 - double equal 9
173:41 - or double vertical bar i double equal n
173:44 - minus 1 close parenthesis question mark
173:48 - single quote backslash n single quote
173:50 - colon single quote space single quote
173:54 - close parenthesis semicolon
173:56 - a new line is printed after every tenth
173:58 - element
173:59 - and after the nth and all elements are
174:01 - followed by one blank although this
174:03 - might look tricky it's instructive to
174:05 - try to write it without the conditional
174:07 - expression section 2.12 precedence in
174:11 - order of evaluation
174:12 - the table below summarizes the rules for
174:14 - precedence and associativity of all
174:17 - operators including those which we have
174:19 - not yet discussed
174:20 - operators on the same line have the same
174:22 - precedence
174:23 - rows are in order of decreasing
174:25 - precedence so for example
174:28 - asterisk slash and percent all have the
174:31 - same precedence which is higher than
174:33 - that of plus and minus
174:37 - parentheses
174:38 - square brackets
174:39 - the arrow operator and the dot operator
174:42 - are first with the right left to right
174:45 - associativity
174:47 - next precedence is exclamation
174:50 - tilled
174:51 - plus plus
174:52 - minus minus
174:54 - single minus
174:59 - the cast
175:01 - multiplication
175:03 - bitwise and size of with left with right
175:06 - to left
175:07 - associativity
175:09 - then
175:10 - multiplication division and modulo with
175:12 - left right associativity
175:15 - then plus and minus with left to right
175:17 - associativity
175:19 - then
175:20 - left shift which is less than less than
175:22 - and right shift which is right
175:24 - greater than greater than with left to
175:26 - right associativity
175:28 - then logical operators less than less
175:30 - than or equal to greater than or greater
175:32 - than or equal to with left to right
175:33 - associativity
175:35 - then comparison double equals
175:38 - not equal exclamation equal left to
175:40 - right
175:41 - then we have some bitwise operators the
175:44 - bitwise and with left to right
175:46 - associativity
175:47 - then the bitwise exclusive or with left
175:50 - right associativity which is a carrot
175:53 - then the single vertical bar which is
175:55 - bitwise or with left to right
175:57 - associativity
175:58 - then we have amber sand ampersand which
176:01 - is and the logical and left to right
176:03 - associativity then double vertical bar
176:06 - which is the logical or with left to
176:08 - right associativity then the ternary
176:10 - operator which is question mark and
176:12 - colon with right to left associativity
176:15 - then the assignments
176:18 - equals plus equals minus sets equals etc
176:21 - with right to left associativity and
176:23 - then the comma which we'll cover in the
176:25 - next chapter with left to right
176:26 - associativity the operators
176:29 - dash
176:30 - greater than and dot are used to access
176:32 - members of structures they'll be covered
176:34 - in chapter six along with size of
176:37 - in chat
176:38 - and then in chapter five we'll discuss
176:40 - asterisk indirection and ampersand
176:43 - address of
176:45 - note that the precedence of the bitwise
176:47 - logical operators ampersand carrot and
176:49 - vertical bar falls below
176:51 - double equals and exclamation equals
176:54 - that this implies that bis bit testing
176:56 - expressions like if
176:59 - parentheses parentheses x ampersand mass
177:02 - close parenthesis
177:03 - equal equals zero close parenthesis must
177:06 - be fully parenthesized to get proper
177:08 - results
177:10 - as mentioned before expressions
177:12 - involving one or more of the associative
177:14 - and commutative operators like multiply
177:17 - plus
177:18 - bit y z end bit lies orbit li and
177:21 - bitwise exclusive or can be rearranged
177:23 - even when parenthesized in most cases
177:25 - this makes no difference whatsoever in
177:28 - situations where it might explicit
177:30 - temporary variables can use
177:32 - to force a particular order of
177:33 - evaluation
177:35 - c like most languages does not specify
177:38 - in what order operands of an operator
177:40 - are evaluated for example
177:42 - in a statement like x equals f open
177:45 - parentheses close parentheses plus g
177:47 - open parentheses close parenthesis
177:48 - semicolon f may be evaluated before v g
177:53 - or vice versa
177:54 - thus if f or g
177:56 - alters an external variable that the
177:58 - other depends on
178:00 - x can depend on the order value of
178:02 - evaluation again
178:04 - intermediate results can be stored in
178:06 - temporary variables to ensure a
178:08 - particular sequence
178:10 - similarly the order which function
178:12 - arguments are evaluated is not specified
178:16 - so
178:17 - the statement
178:18 - printf open parentheses double quote
178:21 - percent d space percent d backslash n
178:24 - double quote comma
178:25 - plus plus n comma power open parenthesis
178:29 - two comma n close parentheses close
178:31 - parentheses
178:32 - is wrong
178:34 - it can and often does produce different
178:35 - results on different machines depending
178:38 - on whether or not n is incremented
178:39 - before power is called the solution of
178:42 - course is to write
178:44 - plus plus n semicolon
178:46 - printf open parentheses double quote
178:48 - percent d space percent d backslash n
178:51 - double quote comma
178:53 - n comma power open parenthesis two comma
178:56 - n close parentheses close parenthesis
178:59 - function calls nested assignment
179:01 - statements and increment and decrement
179:02 - operators cause side effects
179:05 - some variables change as a byproduct of
179:07 - the evaluation of an expression
179:10 - in any expression involving side effects
179:12 - there can be subtle dependencies on the
179:15 - order in which variables taking part in
179:17 - the expression are stored
179:20 - one unhappy situation is typified by the
179:22 - statement
179:23 - a sub i equals i plus plus
179:27 - the question is whether or not the
179:29 - subscript
179:30 - is the old value of i or the new value
179:33 - the compiler can do this in different
179:35 - ways and generate different answers
179:37 - depending on its interpretation
179:40 - when side effects i.e assignment to
179:42 - actual variables takes place is left to
179:44 - the discretion of the compiler since the
179:46 - best order strongly depends on machine
179:49 - architecture
179:50 - the moral of this discussion is writing
179:52 - code which depends on the order of
179:54 - evaluation is a bad programming practice
179:57 - in any language
179:59 - naturally it is necessary to know what
180:01 - things to avoid
180:03 - but if you don't know how they are done
180:04 - on various machines that innocence may
180:07 - help to protect you
180:08 - the c verifier lint
180:10 - will detect most dependencies on order
180:13 - of evaluation
180:15 - i would add that the real moral of the
180:17 - story is to use side effect operators
180:19 - very carefully
180:21 - they are generally only used in
180:22 - idiomatic situations and then use it
180:25 - written using simple code
180:27 - the authors are happy to tell you
180:30 - everything that you can do and see in
180:32 - great detail
180:33 - and they are also suggesting that just
180:35 - because you can do something does not
180:37 - mean that you should do something
180:39 - remember that a key aspect of writing
180:41 - programs is to communicate with future
180:43 - human readers of your code
180:45 - including you reading your own code in
180:47 - the future
180:48 - with modern day compilers and optimizers
180:51 - you gain little performance by writing
180:53 - dense or obtuse code
180:56 - write the code describe what you want
180:57 - done and let the compiler find the best
180:59 - way to do it
181:01 - one of the reasons that a common senior
181:03 - project in many computer science degrees
181:04 - was to write a compiler is to make sure
181:07 - that all computer scientists
181:09 - understand that they can trust the
181:11 - compiler to generate great code
181:16 - this work
181:17 - is based on the 1978 c programming book
181:20 - written by brian w kernighan and dennis
181:22 - m ritchie
181:23 - their book is copyright all rights
181:25 - reserved by at t
181:27 - but is used in this work under fair use
181:30 - because of the book's historical and
181:31 - scholarly significance
181:33 - its lack of availability and the lack of
181:36 - an accessible version of the book
181:38 - the book is augmented in places to help
181:39 - understand its rightful place in a
181:41 - historical context amidst the major
181:43 - changes of the 1970s and 1980s as
181:47 - computer science evolved from a hardware
181:49 - first vendor-centered approach to a
181:51 - software-centered approach where
181:53 - portable operating systems and
181:54 - applications written in c could run on
181:56 - any hardware
181:58 - this is not the ideal book to learn c
182:00 - programming because the 1978 edition
182:03 - does not reflect the modern c language
182:06 - using an obsolete book gives us an
182:08 - opportunity to take students back in
182:09 - time and understand how the c language
182:12 - was evolving as it laid the groundwork
182:14 - for a future with portable applications
182:20 - chapter 3 control flow
182:23 - the control flow statements of a
182:25 - language specify the order in which the
182:27 - computations are done
182:29 - we have already met the most common
182:31 - control flow constructions of c in
182:33 - earlier examples
182:35 - here we will complete the set and be
182:36 - more precise about the ones discussed
182:38 - above
182:40 - 3.1 statements and blocks an expression
182:45 - such as x equals zero or i plus plus or
182:49 - printf open paren
182:51 - dot dot dot close paren becomes a
182:53 - statement when it is followed by a
182:55 - semicolon as in
182:57 - x equals zero semicolon
183:00 - i plus plus semicolon
183:02 - printf open parentheses something closed
183:05 - parentheses semicolon
183:07 - in c the semicolon is a statement
183:10 - terminator rather than a separator as it
183:13 - is in algol like languages
183:16 - the braces the curly braces open curly
183:20 - brace and closed curly brace are used to
183:22 - group declarations and statements
183:24 - together into a compound statement or
183:27 - block so that they are syntactically
183:29 - equivalent to a single statement
183:32 - the braces that actually surround the
183:33 - statements of a function are one obvious
183:36 - example
183:37 - braces around multiple statements after
183:39 - an if
183:40 - else while or four are another
183:43 - variables can actually be declared
183:45 - inside any block we will talk about this
183:48 - in chapter four
183:50 - there is never a semicolon after the
183:52 - right curly brace that ends the block
183:56 - ah see how do i love thee let me count
183:59 - the ways
184:00 - quote by dr chuck with homage to
184:03 - elizabeth barrett browning
184:06 - the humble semicolon is why spacing and
184:08 - line ends do not matter in c and c like
184:10 - languages it means that we as
184:13 - programmers can focus all of our white
184:15 - space and line ends on communicating our
184:18 - intent to humans
184:21 - this freedom is not an excuse to write
184:23 - obtuse code or dense code
184:26 - for example see the obfusicated pearl
184:28 - contest but instead
184:30 - freedom to describe what we mean or use
184:33 - spacing to help us understand or
184:35 - maintain our code
184:37 - we can take a quick look at how a few
184:39 - other c like languages that came after c
184:42 - treat the semicolon java is just like c
184:45 - in that the semicolon terminates
184:46 - statements
184:47 - python treats the semicolon as a
184:49 - separator like alcohol allowing more
184:52 - than one statement on a single line but
184:54 - since
184:55 - python treats the end of a line as a
184:57 - statement separator you generally never
185:00 - use semicolon in python
185:02 - but for people like me who automatically
185:04 - add a semicolon when typing code too
185:06 - fast at least python ignores the few
185:09 - semicolons i mistakenly add to my code
185:11 - out of habit
185:13 - javascript treats the semicolon as a
185:15 - separator but since javascript ignores
185:18 - the end of the line it's treated as
185:20 - white space semicolons are required when
185:22 - a block of code consists of more than
185:25 - one statement
185:27 - when i write javascript i meticulously
185:29 - include semicolons at the end of all
185:32 - statements because any good programmer
185:34 - can write c in any language
185:39 - back to the text 3.2
185:42 - if else
185:44 - the ifl statement is used to make
185:45 - decisions
185:46 - formally the syntax is
185:49 - if parentheses expression parentheses
185:52 - statement 1
185:54 - else statement 2 where the else part is
185:57 - optional
185:58 - the expression in parentheses is
186:00 - evaluated if it evaluates to true that
186:03 - is the expression has a non-zero value
186:06 - statement one is done if it is false the
186:09 - expression is zero
186:11 - and there's an else part statement two
186:12 - is executed instead
186:15 - since an if simply tests the numeric
186:18 - value of the expression certain coding
186:21 - shortcuts are possible the most obvious
186:23 - is writing if open parentheses
186:26 - expression
186:27 - instead of if open parenthesis
186:29 - expression not equal zero close
186:32 - parenthesis
186:34 - sometimes this is natural and clear
186:36 - other times it's cryptic
186:40 - because the else part of an if else is
186:42 - optional there is an ambiguity
186:44 - when an else is omitted from a nested if
186:47 - sequence
186:49 - this is resolved the usual way the else
186:52 - is a cl associated with the closest
186:54 - closest previous else list if
186:59 - for example
187:01 - if
187:02 - open parenthesis n greater than zero
187:04 - closed parenthesis
187:06 - if
187:07 - open parenthesis a greater than b close
187:09 - parentheses
187:10 - z equals a semicolon
187:13 - else z equals b
187:16 - the else with the z equals b goes with
187:18 - the inner if as we have shown by the
187:20 - indentation in the above example
187:22 - if that's not what you want braces must
187:24 - be used to force the proper association
187:28 - if n greater than zero open curly brace
187:32 - if a greater than b
187:34 - z equals a semicolon closed curly brace
187:37 - else z equals b
187:40 - this ambiguity is especially pernicious
187:43 - in situations like
187:45 - if open parenthesis n greater than zero
187:48 - for open parenthesis i equals 0
187:50 - semicolon i less than n semicolon i plus
187:53 - plus closed parenthesis
187:56 - if open parenthesis
187:58 - s sub i greater than 0 close parentheses
188:00 - open curly brace printf
188:03 - string dot
188:05 - parenthesis semicolon return open
188:08 - parenthesis i close parenthesis
188:09 - semicolon close curly brace
188:13 - else and this is where it's wrong
188:15 - printf
188:16 - open parenthesis error and is zero
188:19 - closed parenthesis semicolon
188:22 - the indentation in the above example
188:24 - shows unequivocally what you want but
188:26 - the compiler does not get the message
188:29 - and associates the else with the inner
188:31 - if
188:32 - this bug can be very hard to find
188:35 - by the way
188:38 - notice that there is a semicolon after z
188:40 - equals a in
188:42 - if open parenthesis a greater than b
188:45 - close parenthesis z equals a semicolon
188:48 - else z equals b semicolon
188:52 - that is because grammatically a
188:53 - statement follows the if and an
188:55 - expression like z equals a is always
188:59 - terminated by a semicolon
189:03 - section 3.3
189:05 - else if
189:07 - the construction if open parenthesis
189:10 - expression close parentheses statement
189:12 - else blank if open parentheses
189:16 - expression close parentheses statement
189:19 - else if
189:20 - open parenthesis
189:22 - expression close parentheses statement
189:24 - else statement occurs so often that it's
189:27 - worth a brief separate discussion the
189:30 - sequence of ifs is the most general way
189:32 - of writing a multi-way decision the
189:34 - expressions are evaluated in order
189:37 - if any expression is true the statement
189:39 - associated with it is executed and this
189:41 - terminates the whole chain the code for
189:45 - each statement
189:47 - is either a single statement or a group
189:48 - of statements in phrases
189:50 - the last else
189:52 - handles the none of the above or default
189:54 - case where none of the other conditions
189:56 - was satisfied
189:57 - sometimes there is no explicit action
189:59 - for the default in that case the
190:01 - trailing else statement can be omitted
190:05 - or it may be used for error checking to
190:07 - catch an impossible condition
190:10 - to illustrate three-way decision
190:12 - here is a binary search function that
190:14 - decides if a particular value x occurs
190:17 - in the sorted array v
190:19 - the elements of v must be in increasing
190:22 - order the function returns the position
190:24 - a number between 0 and n minus 1 if x
190:27 - occurs in v n minus 1 if not
190:31 - this sample code is on page 54. it is
190:34 - the first example on page 54 in the book
190:38 - binary open parenthesis x comma v comma
190:42 - n close parenthesis
190:44 - int x
190:46 - comma v
190:47 - open square bracket close square bracket
190:49 - comma n semicolon open curly brace
190:54 - int
190:54 - low comma high comma mid semicolon
190:58 - low equals zero semicolon high equals n
191:02 - minus one semicolon
191:05 - while open parenthesis low less than or
191:07 - equal to high close parenthesis
191:10 - open curly brace
191:11 - mid
191:12 - equals open parenthesis low plus high
191:15 - close parenthesis
191:16 - slash 2 semicolon
191:19 - if
191:20 - open parenthesis x less than
191:22 - v submid close parenthesis
191:26 - high equals mid minus 1 semicolon
191:30 - else if open parenthesis x greater than
191:34 - v sub mid close parenthesis low equals
191:37 - mid plus one
191:39 - else
191:41 - return open parenthesis mid close
191:43 - parenthesis semicolon close curly brace
191:45 - closing the while
191:48 - and then return open parenthesis -1
191:50 - close parentheses semicolon close curly
191:52 - brace to end the function
191:55 - the fundamental decision in this code is
191:57 - whether x is less than greater than or
192:00 - equal to the middle element v submit at
192:02 - each step
192:03 - this is a natural for elsa
192:09 - i would note that in the above examples
192:11 - the else and the if in c are two
192:14 - language constructs that are just being
192:16 - used idiomatically to construct a
192:19 - multi-way branch or else if pattern with
192:22 - indentation that captures the idiom
192:25 - if we are pedantic about the indentation
192:27 - above the of the above sequence we would
192:30 - be separating the else and if and
192:32 - indenting each succeeding block further
192:34 - as follows with brackets or added for
192:37 - clarity
192:39 - if
192:40 - open parenthesis expression close
192:41 - parentheo parentheses open curly brace
192:43 - statement close curly brace else
192:47 - open curly brace if open parenthesis
192:50 - expression close parenthesis open curly
192:52 - brace statement close curly brace else
192:56 - open curly brace and now we're quite
192:58 - indented at this point if open
193:00 - parenthesis expression close parentheses
193:03 - open curly brace statement closed curly
193:05 - brace
193:06 - else open curly brace statement close
193:09 - curly brace close curly brace glows
193:11 - curly brace
193:14 - java and javascript keep the else and if
193:16 - as separate language elements and
193:18 - document their idiomatic usage and
193:20 - indentation just like c
193:23 - but in python
193:25 - life is a single keyword in a new
193:28 - language construct that achieves the
193:31 - same idiom as shown below
193:34 - if open parenthesis expression close
193:36 - parentheses colon block
193:38 - lf
193:40 - open parenthesis expression close
193:41 - parenthesis
193:42 - colon block
193:43 - alif
193:45 - if lf parentheses expression parentheses
193:49 - colon block else colon block
193:52 - the c
193:54 - java javascript and python idioms
193:56 - thankfully look the same when the
193:58 - idiomatic indentation is used
194:01 - even fortran 77 supports elf the else if
194:05 - construct to implement multi-way logic
194:14 - section 3.4 switch
194:17 - the switch statement is a special
194:18 - multi-way decision maker that tests
194:20 - whether an expression matches
194:23 - one of a number of constant values and
194:25 - branches accordingly
194:27 - in chapter one we wrote a program to
194:29 - count the occurrences of each digit
194:31 - white space and all other characters
194:34 - using a sequence of if else if else
194:38 - here's the same program with a switch
194:41 - this is the first example program on
194:43 - page 55.
194:47 - pound include
194:49 - less than stdio.h
194:53 - main open parentheses closed parenthesis
194:55 - open curly brace
194:57 - int c comma i
195:00 - come n white comma n other comma n digit
195:03 - open square bracket 10 close square
195:05 - bracket
195:06 - a 10 element array
195:09 - and white equals and other equals 0
195:12 - for i equals 0
195:14 - i less than 10 i plus plus and digit sub
195:17 - i equals 0.
195:21 - while parentheses parenthesis c equals
195:24 - get char open paren close paren close
195:26 - paren not equal e o f
195:28 - close paren
195:30 - switch
195:31 - open parentheses c close parenthesis
195:33 - open curly brace
195:36 - case quote zero quote colon case quote
195:39 - one quote colon
195:41 - case
195:42 - quote two qu quote colon case quote
195:45 - three quote colon case quote four quote
195:49 - colon case quote five quote colon case
195:53 - quote six quote colon case quote seven
195:57 - quote colon case quote eight quote colon
196:01 - case quote nine quote colon
196:05 - end digit sub c minus quote zero quote
196:08 - close bracket plus plus
196:11 - break
196:13 - now that that bit of code right there
196:14 - was to take all the of zero through nine
196:17 - and
196:18 - guide it to the line of code that
196:20 - incremented the particular element of
196:22 - the end digit array by one
196:26 - continuing after the break semicolon
196:28 - case quote space
196:30 - quote colon
196:31 - case quote backslash end quote colon
196:34 - case quote backslash t quote colon
196:38 - and white
196:39 - plus plus semicolon break
196:42 - default colon and other plus plus colon
196:46 - break semicolon
196:50 - close curly brace
196:52 - print f
196:53 - open parenthesis double quote digits
196:56 - equals double quote close parenthesis
196:58 - semicolon
197:00 - 4 open print i equals 0
197:02 - i less than 10
197:04 - i
197:05 - semicolon i plus plus close parenthesis
197:08 - printf
197:09 - open parenthesis percent space percent d
197:13 - close double quote comma end digit sub i
197:17 - close parenthesis semicolon
197:20 - printf
197:21 - quote backslash n white space equals
197:24 - percent d comma other equals percent d
197:28 - backslash n double quote comma and white
197:31 - comma n other closed parenthesis
197:33 - semicolon close curly brace
197:39 - the switch statement evaluates the
197:41 - integer expression in parentheses in
197:43 - this case the character c and compares
197:45 - its value
197:47 - simultaneously to all the cases each
197:50 - case must be labeled by an integer or
197:52 - character constant or constant
197:54 - expression
197:55 - if a case matches the expression value
197:58 - execution starts at that case the case
198:01 - labeled default is executed if none of
198:03 - the other cases is satisfied
198:06 - default is optional if there isn't if it
198:08 - isn't there and none of the cases
198:10 - matches no action at all takes place
198:13 - cases in default can occur in any order
198:16 - cases must all be different
198:19 - the break statement causes an immediate
198:21 - exit from the switch
198:23 - because the cases serve as labels
198:26 - after the code for one case is done
198:30 - execution falls through to the next
198:33 - unless you take explicit action to
198:35 - escape
198:36 - break and return are the most common
198:38 - ways to leave a switch
198:40 - a break statement can be used to force
198:43 - an immediate exit from a while four and
198:46 - do loops as well as will be discussed
198:48 - later in this chapter
198:52 - falling through the cases is a mixed
198:54 - blessing
198:55 - on the positive side
198:56 - it allows multiple cases for a single
198:58 - action as with blank tab or new line in
199:00 - this example but it also implies that
199:03 - normally each case what must end with a
199:05 - break to prevent falling through to the
199:07 - next
199:08 - falling through from one case to another
199:10 - is not robust being prone to
199:12 - disintegration when the program is
199:14 - modified
199:15 - with the exception of multiple labels
199:17 - for a single computation fall throughs
199:20 - should be used sparingly
199:22 - as a matter of good form put a break
199:25 - after the last case in this case default
199:28 - although it's logically unnecessary
199:30 - someday when another case gets added at
199:32 - the end this bit of defensive
199:34 - programming will save you
199:38 - uh the switch statement what is there to
199:40 - say i think that the switch statement
199:43 - was added to c c to compete with the
199:45 - earlier fortran computed go to statement
199:48 - or just to keep low level assembly
199:50 - language programmers from switching into
199:52 - assembly language to implement the
199:53 - concept of a branch table
199:56 - the authors spend most of the previous
199:58 - section apologizing for the switch
199:59 - statement so you should perhaps take
200:01 - this as a hint and never use it
200:05 - there are very few situations where a
200:07 - branch table outperforms a series of
200:09 - this if then else checks and those are
200:13 - likely deep in a library or operating
200:15 - system code
200:16 - programmers should only use switch if
200:19 - they understand what a branch table is
200:22 - and why a branch table is more efficient
200:24 - for the particular bit of a program
200:26 - they're writing
200:27 - otherwise
200:28 - just use elsif and do the readers of
200:31 - your code a favor
200:35 - 3.5 loops while and four
200:39 - we have already excounted the while and
200:42 - for loops in while open parenthesis
200:44 - expression close parentheses statement
200:46 - the expression is evaluated if it is
200:49 - nonzero the statement is executed and
200:51 - the expression is reevaluated this cycle
200:54 - continues until the expression becomes a
200:56 - zero at which point execution return
200:58 - resumes after the statement
201:01 - the for statement four open parenthesis
201:04 - expression one semicolon expression two
201:07 - semicolon expression three closed
201:10 - parentheses statement is equivalent to
201:12 - expression one semicolon while open
201:15 - parenthesis expression two closed
201:17 - parenthesis open curly brace
201:19 - statement
201:21 - expression three semicolon close curly
201:24 - brace
201:25 - grammatically the three components of
201:27 - the four are expressions
201:30 - most commonly expression one and
201:31 - expression three are assignments or
201:33 - function calls and expression two is a
201:35 - relational expression
201:37 - any of the three parts can be omitted
201:39 - although the semicolons must remain
201:42 - expression if expression one or
201:44 - expression three is left out
201:47 - it is simply dropped from the expansion
201:50 - if the test expression two is not
201:51 - present it is taken as permanently true
201:54 - so the code
201:56 - for open parenthesis semicolon semicolon
201:59 - closed parenthesis open curly brace dot
202:01 - dot close curly brace is an infinite
202:03 - loop
202:04 - presumably to be broken by some other
202:06 - means such as a break or a return
202:10 - whether to use while or for is largely a
202:13 - matter of taste
202:14 - for example
202:16 - in the code
202:17 - while open parentheses open parenthesis
202:19 - c equals get char open paren close paren
202:21 - close parenthesis equal equal
202:24 - quote space quote
202:26 - or
202:26 - c equal equal quote backslash end quote
202:30 - or
202:31 - c equal equal quote backslash t quote
202:34 - close parentheses semicolon
202:36 - skipping white characters
202:38 - there is no initialization or
202:40 - re-initialization so a while seems more
202:42 - natural
202:44 - the four is clearly superior when there
202:46 - is simple initialization and
202:48 - reinitialization
202:50 - since it keeps the loop control
202:51 - statements close together and visible at
202:54 - the top of the loop this is the most
202:56 - obvious in
202:57 - 4
202:58 - open paren i equals 0 semicolon i less
203:01 - than n semicolon i plus plus close paren
203:04 - which is the c idiom for processing the
203:08 - first n elements of an array
203:10 - the analog of a fortran or pl1 do loop
203:14 - the analogy is not perfect however since
203:16 - the limits of a for loop can be altered
203:18 - within the loop and the controlling
203:20 - variable i retains its value when the
203:22 - loop terminates for any reason
203:25 - because the components of the four are
203:27 - arbitrary expressions for loops are not
203:30 - restricted to arithmetic progressions
203:33 - nonetheless is bad style to force
203:35 - unrelated computations into a four it is
203:38 - best reserved for loot control
203:41 - operations
203:44 - as a larger example here is another
203:46 - version of the a to i function for
203:49 - converting a string to its numeric
203:50 - equivalent
203:52 - this one is more general it
203:54 - copes with optional leading white space
203:57 - and an optional plus or minus sign
204:00 - chapter 4
204:01 - shows a to f which does the same
204:03 - conversion for floating point numbers
204:06 - the basic structure of the program
204:07 - reflects the form of the input
204:09 - skip white space if any get the sign if
204:12 - any get the integer part and convert it
204:15 - each step does its part and leaves a
204:17 - clean slate for the next the whole
204:19 - process terminates on the first
204:21 - character that would not be part of a
204:23 - number
204:25 - this is the first example
204:27 - on page 58 of the textbook
204:32 - a to i open paren s close paren which is
204:35 - going to convert s to an integer
204:37 - char
204:38 - s open square bracket close square
204:41 - bracket semicolon
204:43 - open curly brace int
204:45 - i comma n comma sine semicolon
204:49 - 4
204:50 - i equals 0
204:52 - s sub i equal equal
204:55 - quote space quote or s sub i equals
204:59 - equals quote backslash end quote or
205:02 - s sub i equals equals backslash quote
205:05 - backslash t quote semicolon
205:07 - i plus plus
205:09 - semicolon
205:11 - skip white space this is a for loop with
205:14 - an empty loop body
205:16 - sine equals one semicolon
205:19 - if s sub i equal equal plus or
205:24 - s sub i equal equal quote minus quote
205:27 - close parenthesis
205:29 - sine
205:30 - equals
205:32 - and here we use a
205:33 - ternary operator
205:35 - open parentheses s sub i plus plus equal
205:39 - equal quote plus quote close parenthesis
205:43 - question mark 1 colon minus 1 semicolon
205:49 - for open parentheses n equals 0
205:52 - semicolon s sub i greater than or equal
205:54 - to quote 0 quote and s sub i less than
205:58 - or equal to quote 9 quote i plus plus
206:01 - close parenthesis
206:03 - n equals 10 times
206:06 - n plus s sub i minus quote 0 quote
206:10 - semicolon
206:12 - return open parenthesis sine times n
206:15 - close parenthesis semicolon close curly
206:18 - brace to end the function
206:20 - the advantages of keeping loop control
206:22 - centralized are even more obvious when
206:24 - there are separate several nested loops
206:27 - the following function is a shell sort
206:29 - for sorting an array of integers the
206:31 - basic idea
206:32 - of the shell
206:34 - sort is that in early stages far apart
206:36 - elements are compared rather than
206:37 - adjacent ones as in simple interchange
206:39 - sorts this tends to eliminate large
206:42 - amounts of disorder quickly so later
206:44 - stages have less work to do the interval
206:46 - between the compared elements is
206:48 - gradually decreased to 1 at which point
206:51 - the sort becomes an effectively an
206:52 - adjacent interchange method
206:55 - this sample code is the second example
206:58 - in page 58 of the textbook
207:02 - shell open parentheses v comma and close
207:05 - parenthesis int v open square bracket
207:08 - close square bracket comma n semicolon
207:11 - open curly brace
207:13 - int
207:14 - gap comma i comma j comma temp
207:19 - four open paren gap equals n divided by
207:22 - two semicolon gap
207:25 - greater than zero semicolon
207:27 - gap
207:29 - slash equals to close parenthesis
207:32 - 4 open parenthesis i equals gap
207:35 - semicolon i less than n
207:38 - i plus
207:40 - close parenthesis
207:42 - 4
207:43 - and now we're 3d nested in the for loops
207:46 - 4 open parenthesis j equals i minus gap
207:49 - semicolon j greater than or equal to 0
207:52 - and
207:54 - v sub j
207:56 - greater than v sub j plus gap semicolon
207:59 - j minus equals gap close parenthesis
208:03 - open curly brace
208:04 - temp equals v sub j
208:07 - v sub j equals v sub j plus gap
208:11 - semicolon v sub j plus gap equals temp
208:14 - semicolon just a swap of v and v b sub j
208:17 - plus gap p sub j and v sub j plus cap
208:20 - close curly brace and that close the
208:23 - inner innermost for loop and
208:26 - and then the next closed curly brace
208:27 - closes the function
208:30 - there are three nested loops
208:32 - the outermost loop controls the gap
208:34 - between the compared elements shrinking
208:36 - it from n over two by a factor of two
208:38 - each pass until it becomes zero the
208:40 - middle loop compares each pair of
208:42 - elements that is separated by cap
208:44 - the innermost loop reverses any elements
208:46 - that are out of order
208:48 - since gap is eventually reduced to one
208:50 - all elements are eventually ordered
208:52 - correctly
208:53 - note that the generality of the 4 makes
208:56 - the outer loop fit the same form as the
208:58 - others
208:59 - even though it is not an arithmetic
209:01 - progression
209:06 - one final c operator is the comma
209:09 - which most often finds use in the for
209:11 - statement
209:12 - a pair of expressions separated by a
209:14 - comma is evaluated left to right and the
209:17 - type and value of the result are the
209:20 - type and value of the right operand thus
209:23 - in a for statement it is possible to
209:25 - place multiple expressions in the
209:26 - various parts
209:28 - for example to process two parallel
209:30 - indices
209:32 - this is illustrated in the function
209:33 - reverse which reverses the function
209:35 - string in place
209:38 - this code is from page 59 of the
209:41 - textbook and it is the first example on
209:43 - page 59.
209:45 - pound include less than string.h greater
209:48 - than
209:49 - reverse open paren s close paren
209:52 - char
209:53 - s open square bracket close square
209:55 - bracket semicolon
209:57 - open curly brace int c comma i comma j
210:02 - for open parenthesis i equals zero comma
210:05 - j equals stirling sub s minus one
210:10 - semicolon
210:11 - i less than j semicolon i plus plus
210:15 - comma j minus minus close parenthesis
210:18 - open curly brace
210:20 - c equals s sub i s sub i equals s sub j
210:23 - semicolon s sub j equals c semicolon
210:27 - close curly brace
210:29 - close curly brace to end the function
210:31 - the commas that separate the function
210:33 - arguments variables declarations etc are
210:36 - not comma operators and do not guarantee
210:39 - left to right evaluation
210:42 - section 3.6 loops do while
210:46 - the while and for loops share the
210:48 - desirable attribute of testing the
210:50 - termination condition at the top rather
210:52 - than at the bottom as we discussed in
210:53 - chapter one
210:55 - the third loop in c the do while tests
210:57 - at the bottom after making each pass
210:59 - through the loop body the body is always
211:01 - executed at least once
211:04 - the syntax is as follows
211:06 - do
211:07 - statement while open parenthesis
211:09 - expression close parenthesis semicolon
211:12 - the statement is executed then the
211:14 - expression is evaluated if it is true
211:16 - statement is evaluated again and so on
211:19 - if the expression becomes false the loop
211:21 - terminates
211:23 - as might be expected do while is much
211:26 - less used than while in four accounting
211:28 - perhaps five percent of all loops
211:31 - nonetheless it is from time to time
211:33 - valuable as the following as in the
211:35 - following function i to a which converts
211:37 - a number to a character string the
211:39 - inverse of a to i the job is slightly
211:41 - more complicated than it might be
211:42 - thought at first
211:44 - because the easy methods of generating
211:45 - the digits generate them in the wrong
211:47 - order
211:48 - we've chosen to generate the string
211:50 - backwards and then reverse it
211:53 - this is the first sample code on page 61
211:57 - page 60 of the textbook
212:00 - i to a open parenthesis n comma s close
212:04 - parenthesis char
212:06 - s open square bracket close square
212:07 - bracket semicolon
212:09 - int n semicolon
212:12 - open curly brace
212:13 - int i comma sine semicolon
212:17 - if
212:19 - open parenthesis open parenthesis sine
212:22 - equals n
212:23 - close parenthesis less than zero
212:26 - close parenthesis
212:28 - n equals minus n semicolon that's a bit
212:31 - of a complex if i would say there
212:33 - it has an assignment statement that both
212:35 - copies n into sine
212:38 - and then evaluates as to whether or not
212:40 - it's less than zero the n or sign is
212:42 - less than zero because it's a side
212:44 - effect assignment statement for the
212:45 - residual value
212:48 - but the net result is sign contains n
212:51 - and then it's negated um
212:53 - then n is made positive
212:55 - so continuing
212:57 - i equals 0 semicolon
212:59 - do
213:00 - open curly brace
213:02 - s sub i plus plus
213:05 - equals n
213:06 - modulo 10
213:08 - plus
213:10 - quote 0 quote
213:12 - semicolon
213:14 - close curly brace while
213:16 - parenthesis parenthesis n slash equals
213:19 - 10
213:20 - close parenthesis
213:21 - greater than zero close parenthesis
213:24 - semicolon
213:26 - if open parenthesis sine less than zero
213:29 - close parenthesis
213:31 - s sub i plus plus
213:33 - equals quote dash quote
213:36 - or minus sign semicolon
213:39 - s sub i
213:40 - equals quote
213:42 - 0 quote semicolon in a sense to
213:44 - terminate the string and then we call
213:46 - the function reverse reverse open
213:48 - parenthesis s close parenthesis
213:50 - semicolon close curly brace
213:54 - the do while is necessary or at least
213:56 - convenient since at least one character
213:58 - must be installed in the array s
214:00 - regardless of the value of n
214:03 - we have also used braces around the
214:04 - single statement that makes up the body
214:06 - of the do while even though they are
214:08 - unnecessary so the hasty reader will not
214:10 - mistaken mistake the while part for the
214:13 - beginning of a while loop
214:16 - i would note that it's important for any
214:18 - language to provide top tested loops and
214:19 - bottom tested loops but don't feel bad
214:22 - if you write code for years and never
214:24 - feel like a bottom tested loop is the
214:26 - right way to solve a problem you're
214:27 - facing it is usually rare to write a
214:29 - loop that you insist will run once
214:32 - regardless of its input data
214:37 - section 3.7 break
214:41 - it is sometimes convenient to be able to
214:44 - control loop exits other than by testing
214:46 - at the top or the bottom
214:49 - the break statement provides an early
214:51 - exit from a for while or do just as it
214:54 - does from the switch statement
214:56 - a break statement causes the innermost
214:58 - enclosing loop or switch to be executed
215:01 - immediately
215:02 - the following program removes trailing
215:05 - blanks and tabs from the end of each
215:07 - line of input using a break to exit from
215:09 - a loop
215:10 - when the rightmost character is
215:11 - non-blank non-tab is found
215:14 - this example code is on page 61 of the
215:17 - textbook and it is the first example on
215:19 - that page
215:21 - pound include less than stdio.h
215:25 - pound define max line 1000
215:28 - main open parenthesis close parenthesis
215:31 - open curly brace
215:33 - int
215:34 - n
215:35 - semicolon char
215:37 - line open bracket
215:39 - max line close bracket
215:44 - semicolon
215:45 - while open paren open paren n equals get
215:48 - line open paren line comma max line
215:51 - close paren close brand greater than
215:52 - zero close brand open curly brace
215:55 - while open cur open parenthesis
215:59 - minus minus n greater than or equal to
216:02 - zero close parenthesis
216:03 - if open parenthesis line sub n not
216:06 - equals a quote space quote and
216:09 - line sub n not equal quote backslash t
216:12 - quote and
216:14 - line sub n not equal quote backslash end
216:17 - quote
216:19 - close parenthesis break
216:21 - line
216:22 - sub n plus one equals quote backslash
216:25 - zero quote semicolon
216:27 - printf
216:29 - double quote percent s backslash n
216:31 - double quote comma line close
216:33 - parenthesis semicolon
216:35 - close curly brace to end the while and
216:37 - then close curly brace to end the main
216:41 - getline returns the length of the line
216:44 - the inner while loop starts at the last
216:46 - character of line
216:47 - recall that minus minus n decrements end
216:50 - before using the value and scans
216:53 - backwards looking for the first
216:54 - character that is not a blank tab or new
216:56 - line the loop is broken when one is
217:00 - found or when n becomes negative that is
217:03 - when the entire line has been scanned
217:06 - you should verify that this is the
217:07 - correct behavior even when the line
217:09 - contains only white space characters
217:12 - an alternative to break is to put the
217:14 - testing in the loop itself
217:19 - while open parenthesis open parenthesis
217:21 - n equals get line open parenthesis line
217:23 - comma max line close parenthesis close
217:25 - parenthesis greater than zero close
217:27 - parenthesis open curly brace
217:31 - while open paren minus minus n greater
217:34 - than
217:34 - equal to zero and open for n line sub n
217:38 - equal equal
217:39 - quote space quote or line sub n equals
217:43 - quote backslash t quote or line sub n
217:46 - equals
217:48 - quote backslash n quote close paren
217:50 - close paren semicolon
217:53 - dot dot
217:54 - close curly brace this is inferior to
217:57 - the previous version because the test is
217:59 - harder to understand
218:01 - tests which require a mixture of and or
218:06 - not
218:06 - and parentheses should generally be
218:10 - avoided 3.8 continue
218:15 - the continue statement is related to
218:17 - break but less often used it causes the
218:20 - next iteration of the enclosing loop for
218:22 - a while or do to begin
218:24 - in the while and do this means that the
218:25 - test part is executed immediately
218:28 - in the four control passes to the
218:30 - re-initialization step
218:32 - control by the way continue applies only
218:34 - to loops not to switch a continue inside
218:37 - a switch statement inside of a loop
218:40 - causes the next loop iteration
218:42 - as an example
218:43 - this fragment processes only positive
218:46 - elements in the array a negative values
218:48 - are skipped
218:51 - 4 open paren i equals 0 semicolon i less
218:54 - than n semicolon i plus plus close paren
218:58 - open curly brace
219:00 - if open paren a sub i less than 0 close
219:03 - paren
219:04 - continue
219:06 - this line skips the negative elements
219:08 - and then the rest of the body of the
219:10 - loop taut is
219:12 - will run only for the positive elements
219:14 - of the loop and the loop finishes with a
219:16 - close curly brace
219:19 - the continue statement is often used
219:21 - when part of the loop that follows is
219:23 - complicated so that reversing a test and
219:24 - indenting another level would nest the
219:26 - program too deeply
219:30 - it's time for a bit of an aside
219:32 - now that we have seen the break and
219:34 - continue language structures in c that
219:36 - also have made it into c like languages
219:38 - and learned about middle tested loops it
219:40 - is time to revisit the structured
219:42 - programming debate
219:43 - and the need for priming operations when
219:45 - a program must process all data until it
219:48 - finishes and still handle the there is
219:50 - no data at all situation
219:53 - in the previous chapter the author
219:54 - somewhat skirted the issue by using a
219:56 - top tested while loop and a side effect
219:58 - statement with residual value that was
220:00 - compared to eof to decide when to exit
220:03 - the loop
220:04 - int c colon while open parenthesis open
220:08 - parenthesis c equals get char open paren
220:10 - close paren close parenthesis not equal
220:12 - eof close parenthesis open curly brace
220:15 - process your data
220:16 - close curly brace
220:18 - and just for fun now that we do know
220:20 - about the for loop let's rewrite this
220:22 - loop as a for loop to make sure we
220:24 - really understand how for loops work
220:28 - in c semicolon for
220:31 - friend c equals get char open print
220:33 - close print semicolon
220:35 - c not equal eof semicolon c equals get
220:38 - char open print close paren close paren
220:41 - curly brace process your data close
220:44 - curly brace for the for loop
220:46 - now you will almost never see a read all
220:49 - characters until eof written this way
220:51 - because because it is not the way knr
220:54 - told us
220:55 - knr told us to reuse a while loop for
220:57 - this
220:58 - but the for loop formulation is probably
221:00 - clearer to many
221:02 - than the while formulation especially to
221:04 - a reader who's not familiar with the
221:06 - assignment side effect idiom commonly
221:08 - used in c
221:09 - in particular the four formulation does
221:11 - not require
221:13 - that the assignment statement has a
221:15 - residual value of the value that was
221:17 - assigned
221:19 - the first part of the four is a priming
221:20 - read the second part of the four is a
221:22 - top text tested exit criteria that works
221:25 - both for no data and after all data has
221:27 - been read and processed and the third
221:29 - part of the four is done at the bottom
221:31 - of the loop to advance to the next
221:32 - character
221:34 - or encounter eof before going back to
221:36 - the top and doing the loop test the call
221:38 - to get char is
221:40 - done twice in the for formulation of the
221:42 - read all available data loop and while
221:45 - we don't like to repeat ourselves in
221:46 - code it is a if it is a small and
221:48 - obvious bit of code perhaps this code
221:51 - is more clear with a bit of repetition
221:56 - so with all this is background
221:58 - you can take this page of the document
222:00 - and sit down with a friend at a coffee
222:02 - shop and debate as long as you like
222:05 - about which is the better formulation
222:06 - for the read all available
222:08 - data but if at that coffee shop you
222:11 - asked dr chuck's opinion neither of
222:13 - these is ideal because in the real world
222:15 - we build data oriented loops that
222:16 - usually do a lot more than get one
222:18 - character from standard input
222:21 - my formulation of a data loop will upset
222:23 - the structured programming purists and
222:26 - probably upset kernighan enrichy as well
222:29 - but i write code in the real world so
222:30 - here is my version
222:34 - int
222:35 - c semicolon
222:37 - while open paren one close print open
222:40 - curly brace
222:41 - c equals get char
222:43 - if open friends c double equals eof
222:46 - close paren break
222:48 - process your data and then close curly
222:50 - brace to end the loop and if i wanted to
222:52 - skip blanks and new lines i could use
222:55 - both break and continue further angered
222:58 - angering the structured programming
222:59 - purists
223:02 - int c semicolon while open parenthesis
223:05 - one closed parenthesis open curly brace
223:07 - c equals get char open
223:09 - parenthesis close parenthesis semicolon
223:12 - if
223:13 - open parenthesis c equal equal eof close
223:16 - parenthesis break
223:17 - if open parenthesis c equal equal quote
223:20 - space quote or
223:22 - c equal equal quote backslash end quote
223:25 - close parenthesis continue
223:27 - then process your data
223:28 - close parenthesis
223:30 - i use this middle tested approach
223:32 - because usually the data i am processing
223:34 - is coming from a more complex source
223:36 - than the keyboard and i don't want a
223:38 - function with two to three parameters
223:40 - stuck inside of a sine side effect
223:42 - statement in a while test
223:44 - and also sometimes you want to exit loop
223:46 - not just based on the return value from
223:48 - the function
223:49 - but instead based on the complex
223:51 - structure that came back from the
223:53 - function itself
223:55 - as these data processing loops get more
223:57 - complex the middle tested loop is a
223:59 - tried and true pattern
224:01 - even kernighan and ritchie point out its
224:03 - benefits above
224:05 - and with that i have now triggered
224:08 - endless coffee shop conversations about
224:10 - the best way to write a data handling
224:13 - loop
224:18 - section 3.9 go to's and labels
224:22 - c provides the infinitely abusable go-to
224:26 - statement and labels to branch to
224:28 - formally the go-to is never necessary
224:32 - and in practice
224:33 - it is almost always easy to write code
224:36 - without it we have not used go to in
224:38 - this book
224:39 - nevertheless we will suggest a few
224:41 - situations where go-to's might find a
224:44 - place the most common
224:45 - use is to abandon processing in some
224:48 - deeply nested structure such as breaking
224:50 - out of two loops at once
224:52 - the break statement cannot be used
224:53 - directly since it leaves the only the
224:55 - most inter innermost loop thus
224:59 - four open parentheses.close parenthesis
225:02 - four open parenthesis.close parenthesis
225:04 - open curly brace do some stuff if open
225:07 - parenthesis disaster close parenthesis
225:09 - go to error semicolon
225:12 - close curly brace dot dot dot dot dot
225:14 - and then error colon
225:17 - and then clean up the mess
225:18 - this organization is handy if the
225:21 - error handling code is non-trivial and
225:23 - if errors can occur in several places a
225:25 - label has the same form as a variable
225:27 - name and is followed by a colon
225:29 - it can be attached to any statement in
225:32 - the same function as the go to
225:37 - another example
225:38 - consider the possibility of finding the
225:40 - first negative element in a
225:42 - two-dimensional array
225:43 - multi-dimensional arrays are discussed
225:45 - in chapter five
225:47 - one possibility is four
225:49 - open parenthesis i equals zero semicolon
225:52 - i less than n
225:54 - semicolon i plus plus close parentheses
225:57 - four open parenthesis j equals zero
226:00 - semicolon j less than m semicolon j plus
226:04 - plus close parenthesis
226:05 - if open parenthesis v sub i sub j less
226:09 - than zero close parenthesis go to found
226:13 - other one and then you handle and you
226:15 - keep going and then found colon
226:18 - include is where it comes to uh jumps to
226:22 - code involving a go to can always be
226:24 - written without want but though perhaps
226:27 - at the price of somewhat repeated tests
226:28 - or an extra variable for example the
226:31 - array search becomes
226:33 - found equals zero four open parenthesis
226:37 - i equals zero semicolon i less than n
226:40 - ampersand ampersand exclamation found
226:43 - semicolon i plus plus
226:46 - four open parenthesis j equals zero
226:48 - semicolon j less than m ampersand
226:51 - ampersand exclamation found
226:53 - semicolon j plus plus
226:56 - found equals v sub i sub j less than
226:59 - zero
227:00 - if found
227:01 - continue else not found although we are
227:04 - not dogmatic about the matter it does
227:07 - seem that go to go to statements should
227:09 - not should be used sparingly at if at
227:11 - all
227:13 - i would add before we leave control flow
227:16 - i need to say that i agree with
227:17 - structured programming experts as well
227:19 - as kernighan and ritchie in that the
227:21 - go-to is universally a bad idea
227:24 - there are a lot of little details that
227:26 - make them a real problem
227:28 - things like how the stack works in
227:29 - function calls and how code blocks
227:31 - happen and patching the stack up
227:33 - correctly when a go to happens in the
227:35 - middle of a deeply nested mess
227:38 - you might be tempted to use a go to when
227:40 - you want to exit multiple nested loops
227:42 - in a single statement break and continue
227:44 - only exit the innermost loop the authors
227:46 - use this example above
227:48 - but are quite lukewarm when describing
227:50 - it as the use of go to
227:53 - usually if your problem is that complex
227:56 - putting things in a function and using
227:58 - return or adding a few if statements is
228:00 - a better choice
228:01 - the dr chuck middle tested loop data
228:03 - processing solves this because the loop
228:06 - is always the innermost loop
228:08 - also as new languages were built the
228:11 - concept of exceptions became part of
228:13 - language design and was by a by far more
228:16 - elegant solution
228:17 - to a path of some deeply nested code
228:19 - that just needs to get out
228:21 - so most of the time you think the go-to
228:24 - might be a good idea you should lean
228:26 - towards a throw catch pattern to make
228:28 - your intention clear
228:30 - it is one of the reasons why we prefer
228:32 - languages like java or python over c
228:35 - when writing general purpose code
228:41 - this work
228:42 - is based on the 1978 c programming book
228:45 - written by brian w kernighan and dennis
228:47 - m ritchie
228:48 - their book is copyright all rights
228:50 - reserved by at t
228:52 - but is used in this work under fair use
228:55 - because of the book's historical and
228:56 - scholarly significance
228:58 - its lack of availability and the lack of
229:01 - an accessible version of the book
229:03 - the book is augmented in places to help
229:05 - understand its rightful place in a
229:06 - historical context amidst the major
229:08 - changes of the 1970s and 1980s as
229:12 - computer science evolved from a hardware
229:14 - first vendor-centered approach to a
229:16 - software-centered approach where
229:18 - portable operating systems and
229:19 - applications written in c could run on
229:22 - any
229:22 - hardware this is not the ideal book to
229:25 - learn c programming because the 1978
229:28 - edition does not reflect the modern c
229:30 - language
229:31 - using an obsolete book gives us an
229:33 - opportunity to take students back in
229:34 - time and understand how the c language
229:37 - was evolving as it laid the groundwork
229:40 - for a future with portable applications
229:45 - chapter 4 functions in program structure
229:48 - functions break large computing tasks
229:50 - into smaller ones and enable people to
229:53 - build on what others have done instead
229:54 - of starting over from scratch
229:56 - appropriate functions can often hide
229:58 - details of operation from parts of the
230:00 - program that don't need to know about
230:02 - them thus clarifying the whole and
230:04 - easing the pain of making changes
230:07 - c has been designed to make functions
230:09 - efficient and easy to use
230:12 - c programs generally consist of numerous
230:14 - small functions rather than a few big
230:15 - ones
230:16 - a program may reside on one or more
230:18 - source files in any convenient way
230:21 - the source files may be compiled
230:23 - separately and loaded together along
230:25 - with previously compiled functions from
230:27 - libraries we will not go into that
230:29 - process here since the details vary
230:31 - according to the local system most
230:34 - programmers are familiar with library
230:36 - functions for input and output like get
230:38 - char input chart and numerical
230:40 - computations like sine cosine and square
230:43 - root in this chapter we will show more
230:46 - about writing new functions
230:49 - 4.1 basics
230:51 - to begin let us design and write a
230:54 - program to print each line of input that
230:56 - contains a particular pattern or string
230:58 - of characters
230:59 - this is a special function of the unix
231:02 - utility program grap
231:04 - for example searching for the pattern
231:06 - the in the set of lines now is the time
231:09 - for all good men to come to the aid of
231:12 - their party we'll produce the output now
231:15 - is the time
231:17 - men to come to the aid of their party
231:20 - the basic structure of the task falls
231:23 - neatly into three pieces
231:25 - while there's another line
231:26 - if that line contains a pattern print it
231:30 - although it's certainly possible to put
231:32 - the code for all of this in one main
231:33 - routine
231:34 - a better way is to use the natural
231:36 - structure to advantage by making each
231:38 - part a separate function
231:40 - three small pieces are easier to deal
231:42 - with than the one big one because
231:44 - irrelevant details can be buried in the
231:47 - functions and the chance of unwanted
231:49 - interactions minimized and the pieces
231:51 - might even be useful later in their own
231:54 - right
231:56 - while there is another line is getline a
231:58 - function we wrote in chapter one and
232:00 - printed is printf which someone has
232:03 - already provided for us
232:04 - this means that we need to only write a
232:06 - routine which decides if the line
232:09 - contains an occurrence of the pattern
232:11 - we can solve that problem
232:13 - by stealing a design from pl1 the
232:16 - function index
232:18 - s comma t returns the position or index
232:21 - in the string s where the string t
232:23 - begins
232:24 - or -1 if s doesn't contain t
232:28 - we use 0 rather than 1 as the starting
232:30 - position in s because c arrays always
232:33 - begin at position 0.
232:35 - when we later need more sophisticated
232:37 - pattern matching
232:38 - we only have to replace index the rest
232:40 - of the code can remain the same
232:43 - recall that because the modern stdio.h
232:47 - defines a getline function whenever the
232:49 - book writes this function to teach a
232:51 - feature of functions we rename it to get
232:54 - underscore line
232:56 - given this much design filling in the
232:58 - details of the program is
233:00 - straightforward here's the whole thing
233:02 - so you can see how the pieces fit
233:03 - together
233:04 - for now the pattern to be searched for
233:07 - is a literal string in the argument of
233:09 - index which is not the most general of
233:11 - mechanisms
233:12 - we will return shortly to a discussion
233:14 - of how to initialize character arrays
233:16 - and in chapter 5 we will show how to
233:18 - make the pattern
233:19 - a parameter that is set when the program
233:21 - is run
233:23 - this is also a new version of getline
233:25 - you might find it instructive to compare
233:27 - it to the one in chapter one
233:31 - pound include stdio.h
233:33 - pound define max line 1000
233:36 - main open parenthesis closed parenthesis
233:38 - open curly brace
233:40 - char
233:41 - line open square bracket max line close
233:44 - square bracket semicolon
233:46 - while parentheses get line open
233:48 - parenthesis line comma max line close
233:51 - parenthesis greater than zero
233:53 - close parenthesis
233:54 - if
233:55 - open parenthesis index open parenthesis
233:57 - line comma double quote the double quote
234:01 - close parenthesis greater than or equal
234:03 - to zero
234:05 - close parenthesis printf open
234:07 - parenthesis double quote percent s
234:10 - double quote comma line
234:12 - close parenthesis semicolon
234:15 - and a close curly brace to finish the
234:16 - main function
234:20 - next function is get line
234:22 - get
234:23 - line open parenthesis s comma limb close
234:26 - parenthesis
234:27 - char s
234:28 - open square bracket close square bracket
234:30 - semicolon available
234:46 - c equals get char open frame close paren
234:48 - close paren not equal e o f
234:51 - double ampersand
234:53 - c not equal
234:55 - double quote backslash n double quote
234:57 - semicolon plus plus i close parentheses
235:00 - s sub i equals c
235:04 - that loop basically read until it found
235:06 - a new line or end of file
235:09 - if
235:11 - open parenthesis c double equals
235:13 - quote backslash end quote close
235:15 - parenthesis open curly brace
235:17 - s sub i equals c
235:19 - plus plus i semicolon close curly brace
235:22 - closing the f
235:28 - s sub i equals quote backslash zero
235:31 - quote
235:32 - semicolon to terminate the string
235:34 - properly return
235:36 - open paren
235:38 - i close paren
235:40 - semicolon to return the length of the
235:43 - line and then close curly brace to
235:45 - finish the getline function
235:47 - and now the new code
235:49 - index open parenthesis s comma t close
235:52 - parenthesis char
235:54 - s
235:54 - open square bracket close square bracket
235:56 - comma t open square bracket close square
235:59 - bracket semicolon i would note that
236:02 - when we are declaring a character array
236:05 - and we don't give the length of the
236:06 - array that means that we're inside of a
236:09 - function the length of the array exists
236:11 - but it was from the callings calling
236:13 - code
236:14 - so
236:15 - char
236:16 - s
236:17 - open square bracket close square bracket
236:19 - t open square bracket close square
236:21 - bracket semicolon means
236:23 - parameters s and t are strings of some
236:26 - length and we will use backslash 0 to
236:28 - know when that length is done
236:30 - beginning the code in index with an open
236:33 - curly brace int
236:35 - i comma j comma k
236:37 - semicolon
236:39 - and then we have two nested for loops
236:42 - four open print i equals zero
236:44 - s sub i not equal to quote backslash
236:47 - zero quote semicolon i plus plus open
236:50 - curly brace
236:53 - four
236:54 - j equals i comma k equals zero
236:57 - semicolon
236:59 - t s t sub k not equal to backslash zero
237:03 - and double ampersand s sub j double
237:07 - equals t sub k semicolon j plus plus k
237:11 - plus plus
237:12 - semicolon
237:15 - if open print t sub k double equals
237:18 - quote backslash zero quote close paren
237:21 - return open paren i close paren
237:24 - semicolon close curly brace
237:27 - return
237:28 - open paren minus one close paren
237:30 - semicolon curly brace
237:36 - each function has the form
237:38 - name
237:39 - argument list if any
237:42 - in parentheses
237:43 - argument declarations if any open curly
237:46 - brace declarations and statements if any
237:48 - close curly price as suggested various
237:51 - parts may be absent a minimal function
237:53 - is dummy open paren close paren open
237:56 - curly brace closed curly brace which
237:59 - does nothing a do nothing function is
238:02 - sometimes useful as a placeholder during
238:04 - program development the function name
238:06 - may also be preceded by a type if the
238:08 - vert function returns something other
238:10 - than an integer value this is the topic
238:12 - of the next section
238:15 - a program is just a set of individual
238:18 - function definitions communication
238:19 - between the functions is in this case by
238:22 - arguments and values returned by the
238:24 - functions it can also be via external
238:27 - variables the functions can occur in any
238:29 - order in the source file and the source
238:31 - program can be split into multiple files
238:33 - so long as no function is split
238:36 - the return statement is the mechanism
238:38 - for returning a residual value from the
238:41 - called function to its caller
238:43 - any expression can follow return
238:46 - return open parentheses expression close
238:48 - parentheses
238:50 - the calling function is free to ignore
238:52 - the return value if it wishes
238:54 - furthermore there need
238:57 - there is no need to have an expression
238:59 - after the return
239:00 - in that case no value is returned to the
239:02 - caller control also returns to the
239:04 - caller with no value when execution
239:07 - falls off the end of the function by
239:09 - reaching the right closing brace it is
239:12 - not illegal but probably a sign of
239:14 - trouble if a function returns a value
239:16 - from one place and no value from another
239:19 - place
239:20 - in any case
239:21 - the residual value of a function which
239:23 - does not return one is certain to be
239:25 - garbage
239:26 - the c verifier lint checks for such
239:29 - errors
239:31 - the mechanics of how to compile and load
239:33 - a c program which resides on multiple
239:35 - source files vary from one system to the
239:37 - next on the unix system for example the
239:40 - cc command mentioned in chapter one does
239:42 - the job
239:43 - suppose that three functions are in
239:45 - three files called main.c
239:47 - getline.c and index.c then the command
239:51 - cc main.c getline.c index.c compiles the
239:56 - three files and places the resulting
239:58 - relocatable object code in files main.o
240:02 - getline.o and index.o and loads them all
240:04 - into an executable file named a dot out
240:08 - if there is an error say in main.c that
240:11 - file can be recompiled by itself and the
240:13 - result loaded with the previous object
240:15 - files with the command cc main.c
240:19 - getline.o index.o
240:21 - the cc command uses the dot c suffix
240:23 - versus the dot o suffix naming
240:25 - convention to distinguish source files
240:28 - from object files
240:30 - i would note that this cc example
240:32 - exactly as the authors wrote it does not
240:34 - quite work as described in modern c
240:36 - compilers if you want to compile your
240:39 - source code and leave the compiled
240:40 - object code around after the compile you
240:43 - add the minus c option to the compiler
240:45 - column
240:46 - modern c compilers generally do accept
240:48 - multiple files with either dot c or dot
240:50 - o suffixes and conv combine them into a
240:54 - runnable application
240:55 - section 4.2 functions returning
240:58 - non-integers
241:00 - so far none of our programs has
241:02 - contained any declaration of the type of
241:04 - a function
241:05 - this is because by default a function is
241:08 - implicitly declared by its appearance in
241:10 - an expression or statement such as while
241:14 - open paren get line open paren line
241:16 - comma max line close paren greater than
241:18 - zero close print
241:20 - if a name which has not been previously
241:22 - declared occurs in an expression and is
241:25 - followed by a left parenthesis it is
241:27 - declared by context to be a function
241:29 - name
241:30 - furthermore
241:31 - by default the function is assumed to
241:33 - return an int
241:35 - since char promotes to int in
241:37 - expressions there is no need to declare
241:39 - functions that return char these
241:42 - assumptions cover the majority of
241:43 - classes including all of our examples so
241:45 - far
241:48 - i would add
241:49 - that's not true quite true anymore in
241:52 - modern c languages you are required to
241:54 - provide a type for each function if you
241:56 - leave off the type for a function
241:58 - declaration at a minimum you will give
242:00 - us get a stern warning message
242:02 - but sometimes functions do not intend to
242:04 - return anything at all and so the void
242:07 - type was invented to indicate that a
242:10 - function returns nothing
242:11 - the rule of requiring a type on a modern
242:14 - function definition in c
242:16 - even if it's void allows the compiler to
242:18 - check to make sure all of your return
242:19 - values in a function
242:21 - match the expected return type
242:25 - back to the text
242:27 - but what happens if a function must
242:28 - return some other type
242:31 - many numerical functions like square
242:33 - roots sine and cosine return double
242:35 - other specialized functions return other
242:37 - types to illustrate how to deal with
242:39 - this let us write and use the function a
242:42 - to f
242:43 - which converts its argument string s to
242:46 - its double precision floating point
242:48 - equivalent
242:49 - a2f is an extension of a to i
242:52 - which we wrote versions of in chapters
242:54 - two and three
242:55 - it handles an optional sign and decimal
242:57 - point and the presence or absence of
242:59 - either the integer or fractional part
243:03 - we note that this is not a high quality
243:05 - input conversion routine it takes doing
243:07 - everything takes a bit more space than
243:09 - we care to use here in this book
243:11 - first
243:12 - a to f must declare the type of the
243:14 - value it returns since it's not int
243:17 - because float is converted to double in
243:19 - expressions there is no point in saying
243:20 - that a to f returns float we might as
243:23 - well make use of the extra precision and
243:24 - thus declare it to return double
243:27 - the type name precedes the function name
243:29 - like this
243:31 - double
243:32 - a to f
243:33 - open parenthesis s close parenthesis
243:36 - char
243:36 - s open square bracket close square
243:39 - bracket open curly brace
243:41 - double val comma power
243:43 - int i comma sine semicolon
243:46 - for
243:47 - i equals zero semicolon s sub i double
243:50 - equals quote space quote or
243:53 - s sub i double equals quote backslash
243:56 - end quote or
243:58 - s sub i
243:59 - eq double equals quote backslash t quote
244:02 - semicolon i plus plus
244:05 - semicolon
244:06 - that skips the white space
244:08 - sine equals one
244:10 - if s sub i double equals quote plus
244:14 - quote or
244:15 - s sub i double equals quote minus quote
244:19 - sine equals
244:20 - and now we're going to use a ternary
244:22 - operator here paren s sub i plus plus
244:26 - close
244:27 - bracket
244:28 - double equals quote plus quote close
244:30 - paren
244:31 - question mark
244:32 - 1 colon minus one semicolon
244:36 - and that basically tells us it it makes
244:39 - sine be one or negative one based on the
244:41 - presence or absence of a plus or minus
244:46 - for val equals zero semicolon
244:48 - s sub i greater than or equal to quote
244:50 - zero quote double ampersand s sub i less
244:53 - than or equal to double quote nine quote
244:55 - i plus plus
244:57 - close paren
244:59 - val equals 10 times val
245:02 - plus s sub i minus quote zero quote
245:05 - semicolon
245:06 - what this is doing is multiplying the
245:08 - current value by 10 in effect shifting
245:10 - it left and then adding in that new
245:12 - lower empty spot
245:14 - the digit that we're encountering which
245:16 - is somewhere between the character 0 and
245:17 - the character 9.
245:19 - continuing
245:20 - if parentheses s sub i double equals
245:23 - quote dot quote close parentheses
245:26 - i plus plus
245:30 - four open parenthesis power equals one
245:34 - semicolon s sub i greater than or equal
245:37 - to quote zero quote double ampersand s
245:40 - sub i less than or equal to quote nine
245:43 - quote semicolon i plus plus
245:45 - open curly brace
245:47 - val equals 10 times val plus s sub i
245:51 - minus quote zero quote
245:54 - again shifting the number to the left as
245:57 - its as we encounter characters
245:59 - power star equals 10 semicolon
246:03 - close curly brace
246:05 - return
246:06 - open parenthesis sine times val
246:10 - over power close parenthesis
246:13 - semicolon
246:14 - close curly brace
246:18 - second and just as important the calling
246:20 - routine must state that a to f returns a
246:23 - non-end value the declaration is shown
246:25 - in the following primitive desk
246:27 - calculator
246:28 - barely adequate for checkbook balancing
246:31 - which reads one number per line
246:33 - optionally preceded by sign and adds
246:34 - them all up printing the sum after each
246:37 - input
246:40 - this example is from page 70 of the
246:42 - textbook
246:43 - pound include
246:45 - stdio.h pound define max line 100
246:49 - main open parenthesis close parenthesis
246:52 - open curly brace double sum comma a to f
246:56 - open parenthesis close parenthesis
246:57 - semicolon
246:59 - char line open square bracket max line
247:02 - close square bracket semicolon
247:04 - sum equals zero
247:06 - while open parenthesis get line open
247:08 - parenthesis line comma max line close
247:10 - parenthesis greater than zero
247:13 - close parenthesis
247:15 - printf
247:16 - quote backslash t
247:19 - percent.2f
247:21 - backslash n comma sum plus equals a to f
247:26 - open parenthesis line close parenthesis
247:29 - close parenthesis
247:30 - semicolon
247:32 - close curly brace
247:34 - that code used the plus a plus equals
247:36 - side effect operator and merge the call
247:39 - to a to f right into the parameter of
247:42 - the second parameter of printf
247:45 - the declaration double sum a to f open
247:48 - parentheses close parentheses says that
247:50 - sum is a double variable and that a to f
247:53 - is a function that returns a double
247:55 - value
247:56 - as a mnemonic it suggests that sum and a
247:58 - to f parenthesis dot dot are both double
248:01 - precision floating point values unless a
248:04 - to f is explicitly declared in both
248:06 - places c assumes it returns an integer
248:09 - and you will get nonsense answers
248:13 - if a to f itself and the call to it in
248:16 - main aren't typed inconsistently with
248:18 - this with in the same source file it
248:20 - will be detected by the compiler but if
248:22 - as is more likely a to f were compiled
248:25 - separately the mismatch would not be
248:27 - detected and a to f would return a
248:29 - double which maine would treat as an end
248:32 - and meaningless answers would result
248:35 - lind catches this error
248:38 - given a to f we could in principle write
248:40 - a to i to convert a string to an integer
248:43 - in terms of it
248:45 - int a to i open parentheses s close
248:48 - parentheses char s open square bracket
248:51 - close square bracket semicolon open
248:53 - curly brace double
248:55 - a to f open parenthesis close
248:57 - parenthesis semicolon
248:59 - return open parenthesis
249:01 - a to f
249:02 - close parentheses s close parentheses
249:04 - close parentheses semicolon close curly
249:07 - brace
249:08 - note the structure of the declarations
249:10 - in the return statement the value in the
249:12 - expression in return expression is
249:14 - always converted to the type of the
249:16 - function before the return is taken
249:19 - therefore the value of a to f
249:21 - a double is converted automatically to
249:24 - int when it appears
249:26 - in a return since the function a to i
249:29 - returns an end
249:32 - the conversion of a floating point value
249:33 - to in truncates
249:35 - any fractional part as we discussed in
249:37 - chapter two
249:38 - more on function arguments
249:41 - in chapter one we discuss the fact that
249:43 - function arguments are passed by value
249:45 - that is the called function receives a
249:48 - private temporary copy of each argument
249:51 - not its address
249:52 - this means that the function cannot
249:54 - affect the original argument in the
249:56 - calling function
249:57 - within a function each argument is in
250:00 - effect a local variable initialized to
250:02 - the value with which the function was
250:04 - called
250:05 - when an array name appears as an
250:07 - argument to a function the location of
250:09 - the beginning of the array is passed
250:12 - elements are not copied the function can
250:15 - alter elements of the array by
250:17 - subscripting from this location
250:19 - the effect is that arrays are always
250:21 - passed by reference
250:23 - in chapter 5 we will discuss the use of
250:26 - pointers to permit functions to affect
250:29 - non-arrays in calling functions
250:32 - a bit of a digression
250:35 - since including array as an argument
250:37 - passes the location or memory address of
250:39 - the array into the function the function
250:41 - cannot can change the items in the array
250:43 - using array subscripts
250:45 - in particular the array contents are not
250:48 - copied when an array is passed into a c
250:50 - function
250:51 - when we get destructs in a future
250:53 - chapter we will find that the content of
250:55 - structs
250:56 - also are passed using the address of the
250:58 - entire struct so structs are passed by
251:00 - reference as well
251:03 - when thinking about past by reference or
251:05 - pass by value remember that a char
251:07 - variable is a single item similar to int
251:09 - and passed by value i.e is copied in c
251:13 - strings are arrays of characters so they
251:16 - are passed by reference
251:18 - python follows this design for the same
251:21 - efficiency reason as c
251:23 - normal single variables like int or
251:25 - float are copied before being passed
251:27 - into a function and therefore passed by
251:30 - value
251:31 - collections like list or dict are passed
251:34 - into functions by reference so the
251:36 - contents can be changed within a
251:38 - function
251:39 - python strings are not technically
251:41 - copied when being passed into a function
251:43 - but the way assignments happen in python
251:46 - make it seem like strings are passed by
251:48 - value
251:49 - since they can never be modified
251:52 - you can learn more with a bit of web
251:54 - research but the easy way is to imagine
251:56 - in python that strings are passed by
251:58 - value with a clever trick to avoid
252:01 - requiring a copy for every function call
252:04 - php follows the same pattern of passing
252:06 - numbers and strings by value and passing
252:08 - arrays as reference
252:10 - php passes strings by value without
252:13 - recover without requiring a copy again
252:16 - using clever runtime code
252:18 - because in java javascript and php
252:21 - strings are objects of course which we
252:24 - haven't discussed much yet
252:26 - those languages can make sure that
252:28 - strings act as if they were passed by
252:30 - value and not passed by reference the
252:32 - way they are always passed in c
252:35 - c made decisions on its run time based
252:37 - on getting the maximum performance out
252:39 - of the hardware of the 1970s at the
252:41 - expense of making it too easy to write
252:44 - code that overwrites memory and leads to
252:46 - corrupted programs that have dangerous
252:48 - and undefined behavior
252:50 - languages like php java and javascript
252:53 - add a small amount of runtime overhead
252:56 - to do things like store the length of an
252:57 - array and make sure we programmers don't
253:01 - over reference the array and overwrite
253:03 - random bits of our program's code or
253:05 - data
253:07 - the creators of c placed more priority
253:09 - on speed and efficient use of memory
253:12 - than safety
253:13 - it is like driving an autom automobile
253:16 - in the rain without abs automatic
253:18 - braking system it is fast but dangerous
253:21 - and should be reserved by highly skilled
253:24 - and very careful programmers
253:26 - and drivers and those drivers should
253:28 - probably be on a race course
253:31 - by the way
253:32 - back to the text
253:34 - by the way there is no entirely
253:36 - satisfactory way to write a portable
253:38 - function that accepts a variable number
253:40 - of arguments because there is no
253:41 - portable way for the called function to
253:43 - determine how many arguments were
253:45 - actually passed in a given call
253:48 - thus you can't write a truly portable
253:50 - function that will compute the maximum
253:52 - of an arbitrary number of arguments as
253:55 - will the max functions that are built in
253:57 - to fortran and pl1
254:00 - it is generally safe to deal with a
254:01 - variable number of arguments if the
254:03 - called function doesn't use an argument
254:05 - that was not actually supplied and if
254:07 - the types are consistent printf the most
254:11 - common c function with a variable number
254:12 - of arguments uses information from the
254:15 - first argument which is the formatting
254:17 - string to determine how many other
254:20 - arguments are present and what their
254:21 - types are it fails badly if the caller
254:24 - does not supply enough arguments or if
254:26 - types are not what the first argument
254:28 - says it is also
254:30 - non-portable and therefore must be
254:32 - modified for different programming
254:34 - environments
254:36 - alternatively if arguments are of known
254:38 - types it is possible to mark the end of
254:40 - the argument list in some agreed-upon
254:42 - way such as a special argument value
254:45 - often zero that stands for the end of
254:47 - the arguments
254:49 - interestingly modern languages like
254:51 - python php and java go to great lengths
254:54 - to make variable length argument lists
254:56 - work predictably and portably the syntax
254:58 - for variable length argument lists in
255:00 - these language can be a bit obtuse at
255:02 - times but at least it's allowed
255:04 - documented reliable
255:06 - and portable
255:08 - section 4 external variables
255:11 - a c program consists of a set of
255:14 - external objects which are either
255:16 - variables or functions the adjective
255:18 - external
255:20 - is used primarily in contrast to
255:22 - internal which describes arguments and
255:24 - automatic variables defined inside
255:26 - functions
255:28 - external variables are defined outside
255:30 - any function and are thus potentially
255:32 - available to many functions
255:35 - functions themselves are always external
255:37 - because c does not allow functions to be
255:39 - defined inside other functions
255:42 - by default external variables are also
255:45 - global so that all references to such a
255:47 - variable by the same name
255:49 - even from functions that are compiled
255:50 - separately are references to the same
255:53 - thing
255:54 - in as this sense external variables are
255:56 - analogous to fortran common or pl1
255:59 - external
256:01 - we will later see how to define external
256:02 - variables and functions that are not
256:04 - globally available but instead only
256:06 - visible within a single source file
256:10 - because external variables are globally
256:12 - accessible they provide an alternative
256:15 - to function arguments and return values
256:17 - for communicating data between function
256:20 - any function may access an external
256:21 - variable by referring it to by name
256:25 - if the name has been declared somehow if
256:28 - a large number of variables must be
256:30 - shared among functions external
256:31 - variables are a more convenient and
256:33 - efficient than long argument lists
256:36 - as pointed out in chapter 1 however this
256:38 - reasoning should be applied with some
256:40 - caution for it can have a bad effect on
256:43 - program structure and lead to programs
256:45 - with many data connections between
256:48 - functions
256:49 - a second
256:50 - reason for using external variables
256:53 - concerns initialization in particular
256:55 - external arrays may be initialized but
256:57 - automatic
256:59 - ie internal arrays may not we will treat
257:01 - initialization near the end of this
257:03 - chapter
257:05 - the third reason for using external
257:07 - variables is their scope and lifetime
257:10 - automatic variables are internal to a
257:12 - function
257:13 - they come into existence
257:15 - when the routine is entered and
257:16 - disappear when it's left
257:18 - external variables on the other hand are
257:20 - permanent they do not come and go so
257:22 - they retain values from one function
257:24 - invocation to the next
257:26 - thus if two functions must share some
257:28 - data yet neither calls the other it is
257:30 - often most convenient if the shared data
257:33 - is kept in external variables rather
257:35 - than passed in and out via arguments
257:39 - let's examine this issue further with a
257:40 - larger example
257:42 - the problem is to write another
257:44 - calculator program better than the
257:46 - previous one
257:47 - this one permits plus minus asterisk and
257:51 - slash
257:52 - and equals
257:54 - equals will print our answer
257:56 - because it is somewhat easier to
257:57 - implement the calculator will you use
257:59 - reverse polish notation instead of in
258:02 - fixed notation
258:04 - reverse polish notation is the scheme
258:06 - used by for example hewlett-packard
258:09 - pocket calculators
258:11 - in reverse polish notation each operator
258:14 - follows its operators
258:16 - operands
258:17 - an infix expression like open
258:19 - parenthesis 1 minus 2 close parentheses
258:22 - c star open parenthesis 4 plus 5
258:25 - close parenthesis equals is entered as
258:28 - 1
258:29 - 2
258:30 - minus
258:31 - 4
258:32 - 5 plus star equals
258:36 - parentheses are not needed in reverse
258:38 - polish notation the implementation is
258:41 - quite simple
258:43 - each operand is pushed onto a stack
258:46 - when an operator arrives the proper
258:48 - number of operands two for binary
258:50 - operators are popped
258:52 - the operator applied to them and the
258:54 - result is pushed back onto the stack
258:56 - in the example above one and two are
258:59 - pushed then replaced by their difference
259:01 - negative one
259:02 - next four and five are pushed then
259:04 - replaced by their sum nine
259:06 - and then the product of negative one and
259:08 - nine which is negative nine replaces
259:10 - them on the stack and then the equal
259:12 - sign operator prints the top element
259:15 - without removing it
259:17 - so intermediate steps in a calculation
259:19 - can be checked
259:21 - the operations of pushing and popping a
259:23 - stack are trivial but by the time error
259:26 - detection and recovery are added they're
259:28 - long enough so it's better to put each
259:30 - in a separate function than to repeat
259:31 - the code throughout the whole program
259:34 - and there should be a separate function
259:35 - for effects fetching the next input
259:37 - operator or operand
259:39 - thus the overall structure of the
259:40 - program is
259:41 - while
259:43 - next operator or operand is not into
259:45 - file if it's a number push it
259:48 - else if it's an operator pop operands do
259:51 - the opera operation and push the result
259:53 - else error
259:55 - the main design decision that has not
259:56 - yet been discussed is where the stack is
259:59 - that is what routines access it directly
260:03 - one possibility is to keep it in main
260:05 - and pass the stack and current stack
260:07 - position to the retrains that push and
260:08 - pop it
260:10 - but maine doesn't need to know about the
260:11 - variables that control the stack it
260:13 - should only think about pushing and
260:15 - popping so we
260:16 - have decided to make the stack and its
260:19 - associated information
260:21 - external variables accessible to push
260:23 - and pop but not to main
260:26 - translating this outline to code is easy
260:28 - enough the main program is primarily a
260:31 - big switch
260:32 - on the type of operator or operand this
260:35 - is a more typical use of switch than the
260:37 - one shown in chapter 3.
260:40 - this sample code is from page 74 of the
260:44 - textbook
260:47 - pound include stdio.h
260:50 - pound define maxop 20 pound defined
260:53 - number quote zero quote
260:56 - this is going to be a single we found a
260:57 - number and pound to find two big quote
260:59 - nine quote a signal that the string is
261:01 - too big
261:04 - main open parenthesis close parenthesis
261:07 - open curly brace
261:09 - int
261:10 - type semicolon
261:12 - char s open square bracket max op close
261:15 - square bracket semicolon
261:17 - double
261:18 - opt 2
261:20 - a to f open parenthesis close
261:21 - parenthesis
261:22 - comma pop open parenthesis close
261:24 - parenthesis comma push open parenthesis
261:27 - close parenthesis semicolon
261:32 - while open parenthesis open parenthesis
261:34 - type equals get up open parenthesis s
261:36 - comma max op
261:38 - close parenthesis close parenthesis not
261:40 - equal e o f close parenthesis
261:44 - switch open parenthesis type close
261:46 - parenthesis open curly brace
261:48 - case number colon
261:51 - note that number is a predefined
261:53 - constant above
261:54 - push open parenthesis a to f open
261:57 - parenthesis s close parenthesis close
261:59 - parenthesis semicolon break
262:02 - case quote plus quote
262:05 - colon
262:06 - push open parenthesis pop open paren
262:09 - close paren plus pop open for n close
262:11 - paren close paren
262:13 - semicolon break semicolon
262:16 - case
262:17 - quote asterisk quote colon
262:20 - push open paren pop open paren close
262:23 - paren
262:24 - asterisk pop open paren close paren
262:28 - close paren semicolon break semicolon
262:30 - that was the multiplication
262:32 - case
262:34 - quote minus quote colon
262:37 - op 2 equals pop open for n close paren
262:41 - push open paren pop minus op2
262:45 - close print semicolon
262:47 - break semicolon that was subtraction
262:50 - case open print slash close paren
262:54 - colon op 2 equals pop open paren
262:58 - semicolon if up to
263:02 - not equal 0.0 push open print
263:06 - pop open paren close print slash opt2
263:10 - close paren semicolon else
263:12 - printf double quote zero divisor popped
263:16 - backslash n double quote
263:18 - close paren semicolon break
263:22 - case quote equal
263:25 - quote colon printf open paren double
263:28 - quote backslash t percent f backslash n
263:32 - double quote comma
263:33 - push open paren pop open friend close
263:36 - paren close paren close friend semicolon
263:39 - so to print it we pop it and
263:42 - push it and then print the residual
263:44 - value of the push function
263:46 - the next line is break semicolon
263:49 - case
263:50 - quote c quote colon
263:52 - clear open paren close print
263:54 - semicolon break semicolon
263:57 - case too big
263:59 - colon
264:00 - print f
264:02 - double quote percent dot 20 s
264:06 - space dot dot dot is too long backslash
264:08 - n double quote comma s close paren
264:11 - semicolon break semicolon
264:14 - default colon
264:15 - print f
264:17 - open paren double quote unknown command
264:19 - percent c backslash n
264:21 - double quote comma type open print close
264:24 - print semicolon break semicolon close
264:27 - paren close curly brace to finish the
264:29 - switch statement and then close
264:31 - curly brace to finish
264:34 - the main
264:36 - so now we're going to have a separate
264:38 - file that has some of these functions
264:39 - defined
264:41 - this file is on page 75 of the textbook
264:47 - this file will be compiled separately
264:49 - but then later linked all together with
264:51 - the main program but we're going to
264:52 - define
264:54 - push
264:54 - pop and clear in this file
264:58 - pound include
264:59 - stdio.h pawn define maxval 100
265:04 - maximum value that would be the maximum
265:06 - value of our stack the maximum size of
265:08 - our stack maximum depth of our stack
265:10 - now we are declaring variables outside
265:13 - of any function these are the external
265:15 - variables
265:16 - int sp equals zero
265:19 - double val open square bracket max val
265:22 - close square bracket semicolon
265:25 - and so those variables are external
265:27 - variables and they're outside of all of
265:29 - the functions but we can use them in any
265:31 - function and there's just one copy no
265:33 - matter what function we're using it so
265:34 - now we define our functions
265:37 - double push open paren f close paren
265:41 - double f semicolon open curly brace if
265:44 - open paren sp
265:47 - less than max val close paren return
265:49 - open paren val open square bracket sp
265:52 - plus plus close square bracket equals f
265:56 - close paren semicolon
265:58 - else
265:59 - open curly brace
266:01 - printf double quote air colon stack full
266:04 - backslash n double quote closed paren
266:06 - semicolon
266:08 - clear open paren close print semicolon
266:11 - return open print zero close paren
266:13 - semicolon close curly brace
266:16 - to finish the else and then close curly
266:19 - brace to finish the double function the
266:21 - push function
266:24 - and now we define the pop
266:26 - double pop open print close paren open
266:30 - curly brace if open paren sp greater
266:32 - than zero close paren return open paren
266:36 - val open square bracket minus minus sp
266:40 - close square bracket close curly brace
266:42 - semicolon else open curly brace printf
266:48 - open paren double quote error colon
266:50 - stack empty backslash n close quote
266:54 - close double quote
266:55 - close paren semicolon clear open paren
266:58 - close paren semicolon return open print
267:01 - zero close paren semicolon close curly
267:04 - brace to finish the else and then close
267:06 - curly brace to finish the double
267:09 - and the last function we're going to
267:10 - define is the clear function
267:12 - which is quite simple clear open paren
267:14 - close paren open curly brace sp equals
267:17 - zero semicolon
267:20 - close paren
267:21 - i would note that
267:23 - just read this one carefully
267:25 - they're very good at using side effect
267:28 - operators and side effect assignments
267:30 - and to keep this code very simple and
267:32 - succinct
267:34 - and you really have to understand a lot
267:36 - of the other stuff that you've
267:37 - covered in the book up to this point
267:40 - back to the text
267:42 - the command c clears the stack with the
267:44 - function clear which can also be used by
267:47 - push and pop in case of error we'll
267:49 - return to get op in a moment
267:52 - as discussed in chapter one a variable
267:54 - is external if it is desi defined
267:57 - outside the body of any function
268:00 - thus the stack and stack pointer which
268:02 - must be shared by push pop and clear are
268:05 - defined outside the three functions but
268:08 - if main itself does not refer to the
268:10 - stack or stack pointer their
268:11 - representation is carefully hidden
268:14 - thus the code for the equal operator
268:16 - must use
268:18 - push
268:19 - open print pop parentheses parentheses
268:21 - close parenthesis close parenthesis
268:23 - semicolon to examine the top of the
268:25 - stack without disturbing it notice also
268:27 - that because plus and multiplication are
268:30 - commutative operators the order in which
268:32 - the popped operands are combined is
268:33 - irrelevant but for the minus and slash
268:35 - operators the left and right operands
268:37 - must be distinguished
268:40 - this example code above shows why it's
268:42 - important to remember the k and r c
268:45 - arrange rearrangement license as it
268:47 - applies to operators that are
268:48 - associative and commutative
268:50 - if the code for the minus operator were
268:52 - written written push open paren pop open
268:55 - print close print minus pop open print
268:58 - close paren
268:59 - close print semicolon there is no
269:02 - guarantee that the left pop will run
269:05 - before the right pop
269:07 - and since these functions access global
269:09 - variables and have side effects
269:11 - it is important to force the compiler
269:14 - not to rearrange the order of the
269:15 - function calls to force the evaluation
269:17 - order the code is broken into two
269:19 - statements op2 equals pop open print
269:22 - close print semicolon push open open
269:25 - paren
269:26 - pop open paren close paren minus op2
269:29 - close paren semicolon now you might
269:31 - think that the lesson here is that the k
269:33 - rc arrangement license which was done to
269:36 - allow optimization and performance is a
269:38 - bad idea
269:40 - but the more important lesson is that
269:41 - writing low level utility functions like
269:44 - push and pop that use global variables
269:46 - and have side effects is a dangerous
269:49 - pattern in any programming language
269:52 - section 4.5
269:54 - scope rules
269:55 - the functions and external variables
269:57 - that make up a c program need not all be
270:00 - compiled at the same time the source
270:02 - text of the program may be kept in
270:04 - several files and previously compiled
270:06 - routines may be loaded from libraries
270:09 - the two questions of interest are
270:11 - how are declarations written so that
270:13 - variables are properly declared during
270:15 - compilation and how our declarations set
270:19 - up so that all the pieces will be
270:21 - properly linked or connected when the
270:23 - program is loaded
270:25 - the scope of a name is the part of the
270:28 - program over which the name is defined
270:31 - for an automatic variable
270:33 - declared at the beginning of a function
270:35 - the scope is the function in which the
270:36 - name is declared and variables of the
270:39 - same name in different functions are
270:41 - unrelated
270:42 - the same is true of the arguments of the
270:44 - function
270:46 - the scope of an external variable lasts
270:48 - from the point at which is it is
270:50 - declared in a source file to the end of
270:52 - that file
270:54 - for example if val sp push pop and clear
270:58 - are defined in one file in the order
271:00 - shown above that is intsp equals zero
271:04 - double val open square bracket maxval
271:06 - close square bracket semicolon
271:08 - double push open print f close paren
271:11 - open curly brace dot dot close curly
271:13 - brace double pop open print close paren
271:16 - open curly brace dot dot dot close curly
271:18 - brace clear open paren close paren open
271:21 - curly brace dot dot dot close
271:23 - curly brace then the variables val and s
271:26 - p may be used in push pop and clear
271:29 - simply by naming them and no further
271:31 - declarations are needed
271:33 - on the other hand
271:35 - if an external variable is to be
271:37 - referenced before it is defined or it is
271:39 - defined in a different source file from
271:41 - the one in which it's being used then an
271:43 - extern declaration is mandatory
271:46 - it is very important to distinguish
271:48 - between the declaration of an external
271:51 - variable and its definition
271:53 - a declaration announces the property of
271:55 - the variable its type its size etc
271:59 - a definition also causes storage to be
272:02 - allocated
272:03 - if the lines int
272:05 - sp semicolon
272:07 - double val open square bracket maxval
272:10 - close square bracket semicolon appear
272:12 - outside any function they define the
272:15 - external variables sp and val
272:17 - and cause the storage to be allocated
272:20 - and also serve as the declaration
272:22 - for the rest of that source file
272:25 - on the other hand the lines extern int
272:28 - sp
272:29 - extern double val open square bracket
272:32 - close score bracket semicolon
272:34 - declare for the rest of the source file
272:36 - that sp is an int and val is a double
272:39 - array whose size is determined and
272:41 - allocated elsewhere
272:43 - but they do not create variables or
272:45 - allocate storage for them there must be
272:49 - only one definition of an external
272:52 - variable among all the files that make
272:54 - up the source program
272:55 - other files may contain extern
272:57 - declarations to access it
273:00 - there may also be an extern declaration
273:02 - in the file containing the definition
273:05 - any initialization of an external
273:08 - variable goes only with the definition
273:11 - array sizes must be specified with the
273:14 - definition but are optional with the
273:17 - extern declaration
273:19 - although it is not a likely organization
273:22 - for this program
273:23 - val and sp could be defined and
273:26 - initialized in one file and the
273:28 - functions push pop and clear defined in
273:31 - another
273:33 - then these definitions and declarations
273:35 - would be necessary to tie them together
273:38 - in file 1 we would see int sp 0
273:42 - semicolon double val open square bracket
273:45 - max val close square bracket semicolon
273:48 - and then in file 2
273:50 - x turn in sp semicolon x turn double val
273:54 - open square bracket close square bracket
273:56 - semicolon
273:57 - double push open print f close paren
274:00 - open curly brace dot dot close curly
274:02 - brace
274:03 - double pop open frame close paren
274:06 - open curly brace dot dot dot close curly
274:08 - brace
274:10 - clear open friend close paren open curly
274:13 - brace dot dot dot close curly brace
274:15 - because the x turned declarations in
274:18 - file two lie ahead and outside the three
274:20 - functions they apply to all
274:23 - one set of declarations suffices for all
274:26 - of file 2.
274:29 - for larger programs the pound include
274:32 - file inclusion facility discussed later
274:34 - in this chapter allows one to keep only
274:37 - a single copy of the extern declarations
274:40 - for the program and have that inserted
274:42 - in each source file it's as it's being
274:45 - compiled
274:46 - let us now turn to the implementation of
274:48 - getup the function that
274:51 - fetches the next operator or operand the
274:54 - basic task is easy
274:56 - skip blanks
274:57 - tabs and new lines if the character is
275:00 - not a digit or a decimal point return it
275:03 - otherwise collect a string of digits
275:05 - that might include a decimal point and
275:07 - return number a single signal that a
275:11 - number has been collected
275:15 - the routine is substantially complicated
275:17 - by an attempt to handle the situation
275:19 - properly when the input number is too
275:20 - long
275:22 - get up reads digits perhaps with an
275:25 - intervening decimal point until it
275:27 - doesn't see anymore but only stores the
275:29 - ones that fit
275:30 - if there was no overflow it returns
275:33 - number in the string of digits
275:35 - if the number was too long however getup
275:37 - discards the rest of the input line so
275:39 - the user can simply retype the line from
275:41 - the point of error it returns too big as
275:44 - the overflow signal
275:50 - this example code
275:52 - is from page 78
275:54 - of the textbook and you can view it at
275:57 - www.cc4e.com
276:01 - code
276:03 - page 78
276:05 - get up
276:06 - open friend s comma lim close paren char
276:10 - s open square bracket close square back
276:12 - at semicolon
276:13 - int lim semicolon open curly brace
276:17 - int i comma c semicolon
276:20 - while open paren open paren c equals get
276:23 - ch open paren close paren close paren
276:26 - double equals quote space quote or
276:29 - c double equals quote backslash t quote
276:32 - or c double equals quote backslash end
276:35 - quote close paren semicolon
276:38 - skip all the blanks
276:41 - if c is not equal
276:44 - quote dot quote and
276:47 - open paren c less than quote zero quote
276:50 - vertical bar vertical bar c greater than
276:53 - quote nine quote close paren close paren
276:55 - return s return open paren c close paren
276:59 - s sub zero equals c
277:01 - four paren i equals one semicolon open
277:04 - paren c equals get chart open paren
277:07 - close paren close print greater than or
277:09 - equal to quote zero quote and c less
277:12 - than or equal to quote nine quote
277:14 - semicolon i plus plus
277:17 - inside the for loop
277:19 - if i less than limb
277:22 - s sub i equals c
277:24 - if open for n c double equals quote dot
277:27 - quote
277:29 - close paren open curly brace we begin to
277:31 - collect the fraction
277:33 - if
277:34 - open print i
277:35 - less than limb
277:37 - close paren s sub i equals c
277:41 - four open paren i plus plus
277:45 - c equals get char open paren close paren
277:47 - close paren greater than or equal to
277:49 - quote zero quote
277:51 - ampersand ampersand c less than or equal
277:53 - to quote nine quote
277:55 - semicolon i plus plus closed paren
277:58 - if open prime i less than limb close
278:01 - paren s sub i equals c
278:04 - close curly brace to close the if
278:06 - statement where we're collecting the
278:07 - fraction
278:09 - if open paren i less than limb close
278:12 - paren open curly brace
278:15 - this means the number is good
278:17 - ungetch is ch open friends c close paren
278:21 - semicolon
278:22 - s sub i equals quote backslash zero
278:25 - quote semicolon
278:27 - return
278:28 - open paren number close print and recall
278:30 - that number is a predefined constant
278:33 - close curly brace else open curly brace
278:37 - if it's too big we're going to skip to
278:39 - the end of the line
278:40 - while open paren c not equal
278:43 - quote backslash end quote and c not
278:47 - equal eof open paren
278:49 - c equals get char open for enclosed
278:52 - paren semicolon
278:53 - s sublim minus one equals quote
278:56 - backslash zero quote semicolon
278:58 - return too big semicolon close curly
279:02 - brace to finish the if and then close
279:04 - curly brace to finish the function
279:06 - recall that too big is a
279:08 - constant that indicates that we've read
279:10 - too much
279:12 - back to the text
279:14 - what are get ch and unget ch well it is
279:17 - often the case that a programming
279:19 - reading input cannot determine that is
279:21 - read enough until it is read too much
279:23 - one instance is collecting characters
279:25 - that make up a number
279:27 - until the first non-digit is seen the
279:29 - number is not complete but then the
279:31 - program has read one character too far
279:34 - and that is a character it is not
279:36 - prepared for
279:37 - the problem would be solved if it were
279:39 - possible to unread the unwanted
279:40 - character then every time the program
279:42 - reads one character too many it could
279:44 - push it back on the input so that the
279:46 - rest of the code would behave as if it
279:48 - never been read
279:50 - fortunately it is easy to simulate
279:52 - ungetting a character by writing a pair
279:54 - of cooperating functions getch delivers
279:57 - the next input character to be
279:59 - considered
280:00 - ungetch puts the character back on the
280:02 - input so the next call to get ch will
280:04 - return it again
280:06 - how they work together is simple
280:09 - unget ch puts puts the pushed back
280:11 - characters into a shared buffer a
280:13 - character array gets the ch reads from
280:15 - the buffer is there's anything there and
280:17 - then it calls get char if the buffer is
280:19 - empty
280:20 - there must be an index variable which
280:21 - records the position of the current
280:23 - character in the buffer
280:25 - since the buffer and index are shared by
280:27 - get ch and unget ch and must retain
280:29 - their values between calls they must be
280:32 - external to both routines
280:34 - thus we can write getch and ungetch and
280:37 - their shared variables as follows
280:40 - this is on page 79 of the textbook you
280:43 - can see the code at www.cc4e.com
280:47 - code and go to page 79
280:50 - pound include
280:51 - stdio.h
280:53 - found to find buff size 100
280:56 - char buff open square bracket buff size
280:58 - close square bracket semicolon
281:00 - int buff p equals zero semicolon those
281:04 - are the external variables outside any
281:05 - function
281:08 - here's the first function get ch open
281:10 - friend close paren open curly brace
281:13 - return open parenthesis open parenthesis
281:16 - buff p greater than zero close
281:18 - parenthesis question mark
281:20 - buff
281:22 - open square bracket minus minus buff p
281:24 - close square bracket colon
281:27 - get char open paren close paren close
281:29 - paren semicolon close curly brace to
281:31 - finish the get ch function
281:34 - the unget ch function pushes a character
281:36 - back on input
281:39 - ch open paren c close paren into c
281:42 - semicolon
281:43 - open curly brace
281:45 - if open paren buff p greater than buff
281:48 - size printf
281:49 - open prin double quote unget ch colon
281:53 - too many characters backslash n double
281:56 - quote
281:56 - close paren semicolon else
281:59 - buff
282:00 - open square bracket buff p plus plus
282:03 - close square bracket equals c semicolon
282:06 - and then close curly brace to finish the
282:08 - ungetch function
282:11 - we have used an array for pushback
282:12 - rather than a single character since the
282:14 - generality may come in handy later
282:18 - section 4.6 static variables static
282:22 - variables are a third class of storage
282:25 - in addition to the x turn and automatic
282:28 - that we've already met
282:30 - static variables may either be internal
282:33 - or external
282:34 - internal static variables are local to a
282:36 - particular function just like automatic
282:38 - variables are but unlike automatics they
282:41 - remain in existence rather than coming
282:44 - and going each time the function's
282:45 - activated
282:46 - this means that internal static
282:48 - variables provide private permanent
282:51 - storage in a function
282:52 - character strings that appear within a
282:54 - function such as the arguments of printf
282:57 - are internal static
282:59 - an external static
283:01 - variable is known within the remainder
283:03 - of the source file in which it's
283:05 - declared but not in any other file
283:08 - external static thus provides a way to
283:10 - hide names like buff and buff p in the
283:13 - get ch unget ch combination
283:16 - which must be external so they can be
283:18 - shared
283:19 - yet which should not be visible to users
283:21 - of get ch and unguess ch so there's no
283:23 - possibility of conflict if the two
283:26 - routines are compiled in one file as in
283:29 - static char buff open square bracket
283:32 - buff size close square bracket semicolon
283:35 - static int buff p equals zero semicolon
283:39 - get ch open frame close paren open curly
283:42 - brace dot dot close curly brace unget ch
283:45 - open paren c close paren open curly
283:47 - brace dot dot dot close curly brace then
283:49 - no other routine will be able to access
283:52 - buff and buff p
283:54 - in fact
283:55 - they will not conflict with the same
283:57 - names in other files of the same program
284:01 - static storage whether internal or
284:03 - external is specified by prefixing the
284:07 - normal declaration with the word static
284:09 - the variable is external if it's defined
284:12 - outside of any function and internal if
284:14 - defined inside a function
284:16 - normally functions are external objects
284:19 - their names are known globally
284:21 - it is possible for a function however to
284:23 - be declared static
284:25 - this makes its name unknown outside the
284:28 - file in which it's declared
284:31 - in c
284:32 - static
284:33 - connotates
284:35 - not only
284:36 - permanence but also a degree of what
284:39 - might be called
284:40 - privacy internal static objects are
284:44 - known only inside one function
284:46 - external static objects variables or
284:49 - function are are known only within the
284:51 - source file in which they appear their
284:54 - names do not interfere with variables or
284:57 - functions
284:58 - of the same name in other files
285:01 - external static variables and functions
285:04 - provide a way to conceal data objects
285:07 - and any internal routines that
285:09 - manipulate them so that other routines
285:11 - and data cannot conflict even
285:13 - inadvertently
285:15 - for example getch and ungetch form a
285:18 - module for character input and pushback
285:21 - buff and buff p should be static so
285:23 - they're inaccessible from the outside
285:26 - in the same way push pop and clear form
285:29 - a module for stack manipulations
285:32 - val and sp should also be external
285:35 - static
285:37 - 4.7
285:38 - register variables
285:40 - the fourth and final storage class is
285:42 - called register
285:44 - a registered declaration advises the
285:46 - compiler that the variable in question
285:48 - will be heavily used when possible
285:51 - register variables are placed in machine
285:53 - registers
285:54 - which may result in smaller and faster
285:57 - programs
285:58 - the register declaration looks like
286:00 - register int x
286:03 - semicolon
286:04 - register char c semicolon and so on the
286:08 - in part may be omitted register can only
286:10 - be applied to automatic variables and
286:12 - the formal parameters of a function
286:14 - in this latter case the function
286:16 - declaration looks like
286:18 - f open paren c comma n close paren
286:22 - register int c comma n semicolon open
286:25 - curly brace register int i semicolon and
286:28 - then dot dot
286:29 - close curly brace
286:32 - in practice there are some restrictions
286:34 - on register variables reflecting the
286:36 - realities of the underlying hardware
286:39 - only a few variables in each function
286:41 - may be kept in registers and only
286:42 - certain types are allowed
286:44 - the word register is ignored for excess
286:47 - or disallowed declarations
286:49 - and it is not possible to take the
286:51 - address of a register variable a topic
286:53 - that will be covered in chapter 5. the
286:55 - specific restrictions vary from machine
286:58 - to machine
286:59 - as an example on the pdp-11
287:02 - only the first three registered
287:03 - declarations in a function are
287:06 - effective and the types must be int char
287:09 - or pointer
287:12 - as a quick aside the description of the
287:14 - details of the implementation of the
287:16 - register modder modifier on the pdp-11
287:18 - is a delightful peek into how the c
287:22 - compiler generated runtime code on that
287:24 - particular system in the 1970s
287:27 - as compilers have become more
287:28 - sophisticated the compiler could decide
287:31 - which variables to keep in registers far
287:33 - better than the programmer could
287:35 - and since
287:37 - how variables would be allocated to
287:38 - registers might be different on
287:40 - different hardware architectures the
287:42 - register indication is generally ignored
287:43 - by modern c compilers so you should
287:46 - probably never use it in your code
287:48 - as a matter of fact
287:49 - i wrote the following sample c program
287:52 - and compiled it with the minus capital s
287:54 - option so i could see the generated
287:56 - assembly language with and without the
287:58 - register declaration
288:00 - with optimization there was no
288:02 - difference between the code generated
288:04 - with or without the registered
288:05 - declaration
288:07 - the reason the generated assembly code
288:09 - was identical once you take a look at it
288:11 - was regardless of the use the register
288:13 - keyboard was that the c optimizer on my
288:16 - arm based computer in 2022 realized the
288:19 - best way to implement the code was to
288:20 - keep both of the variables in registers
288:23 - because the loop code was so simple and
288:25 - the cpu in my computer has plenty of
288:27 - registers and optimized any loading and
288:29 - storing of the data for these variables
288:32 - right out of the program
288:34 - in 1978 the authors likely included the
288:38 - register function as a feature to
288:40 - convince the experienced assembly
288:43 - language programmers that they should
288:45 - write all but the lowest lowest level
288:48 - code in c
288:50 - so write a little tiny bit in c and then
288:52 - i mean write a little tiny bit in
288:54 - assembly language and write everything
288:56 - else in c
288:57 - so here's an example that's not in the
288:59 - textbook it's on page 81 if it were in
289:02 - the textbook you can see this code at
289:05 - www.cc4ed
289:08 - code page 81
289:11 - and this is code that i wrote to play
289:13 - with the register keyword to mostly
289:16 - convince myself it was pointless to use
289:18 - it but here we go
289:20 - pound include stdio dot h
289:23 - int
289:24 - main open prime close print open curly
289:27 - brace
289:28 - int compute semicolon
289:30 - register end enter
289:33 - semicolon scanf open for n double quote
289:36 - percent d
289:38 - close quote comma ampersand compute
289:41 - close parenthesis semicolon
289:43 - printf open parenthesis double quote
289:45 - compute space percent d backslash n
289:48 - double quote comma compute close
289:50 - parenthesis semicolon
289:52 - four
289:53 - open print iter equals zero semicolon
289:56 - enter less than one thousand semicolon
289:58 - iter plus plus close parenthesis open
290:01 - curly brace compute equals open
290:03 - parenthesis compute times 22 close
290:05 - parenthesis times seven
290:08 - if compute
290:09 - greater than one thousand compute equals
290:12 - compute modulo one thousand
290:15 - close curly brace printf
290:18 - open paren double quote compute space
290:20 - percent d backslash n close quote comma
290:24 - compute
290:25 - semicolon close curly brace now some of
290:27 - these i wrote this code in a way
290:30 - that
290:31 - tries to convince the
290:33 - uh the the optimizer that i'm actually
290:35 - going to use these values that's why i
290:37 - read the value from input as compared to
290:40 - a constant it would actually optim the
290:41 - optimizer so so so smart that it would
290:43 - just eliminate all the constant
290:45 - calculations so
290:47 - but that's my sample
290:49 - playing with register
290:52 - section 4.8 block structure
290:55 - c is not a block structured language in
290:58 - the sense of pl1 or algol in that
291:01 - functions may not be defined within
291:02 - other functions
291:04 - on the other hand variables can be
291:06 - defined in a block structured fashion
291:08 - declarations of variables including
291:10 - initializations may follow the left
291:12 - brace that introduces any compound
291:15 - statement
291:16 - not just the one that begins a function
291:18 - variables declared this this way
291:21 - supersede any identically named
291:23 - variables in outer blocks and remain in
291:26 - existence until the matching right race
291:29 - for example
291:31 - if open parentheses n greater than zero
291:33 - close parenthesis open curly brace int i
291:36 - semicolon
291:37 - declare a new i
291:39 - four open parenthesis i equals 0
291:42 - semicolon i less than n semicolon i plus
291:45 - plus
291:46 - close parenthesis and dot dot the rest
291:48 - of the for loop and then a closed curly
291:50 - brace for the if
291:51 - the scope of the variable i
291:54 - is in the true branch of the if this i
291:57 - is unrelated to any other i in the
292:00 - program
292:01 - block structure also applies to external
292:03 - variables given the declarations
292:06 - int x semicolon f open parenthesis
292:10 - closed parenthesis open curly brace
292:12 - double x
292:13 - semicolon dot dot dot close parenthesis
292:17 - then within the function f occurrences
292:19 - of x refer to the internal double
292:22 - variable outside of f they refer to the
292:25 - external integer this is
292:28 - same is true of the names of formal
292:30 - parameters
292:32 - for example
292:34 - in z semicolon outside of any function
292:37 - f open parenthesis z close parenthesis
292:40 - double z semicolon open curly brace dot
292:43 - dot close curly brace within function f
292:47 - z
292:48 - refers to the formal parameter not the
292:50 - external variable
292:52 - section 4.9 initialization
292:55 - initialization has been mentioned in
292:57 - passing many times so far but always
293:00 - peripherally to some other topic this
293:02 - section summarized some of the rules now
293:05 - that we have discussed the various
293:06 - storage classes
293:08 - in absence of explicit initialization
293:10 - external and static variables are
293:12 - guaranteed to be initialized to zero
293:15 - automatic and register variables have
293:17 - undefined or garbage values
293:20 - simple variables not arrays or
293:22 - structures may be initialized when they
293:24 - are declared by following the name with
293:27 - an equal sign and a constant expression
293:30 - int x equals one semicolon jar s quote
293:34 - equals single quote backslash single
293:37 - quote single quote semicolon
293:40 - a constant of a single character that is
293:42 - a single quote itself
293:45 - long day equals 60 times 24 semicolon
293:49 - which is the minutes in a day
293:51 - for external and static variables the
293:53 - initialization is done once conceptually
293:56 - at compile time for automatic and
293:58 - register variables it is done each time
294:00 - the function or block is entered
294:02 - for automatic and register variables the
294:04 - initializer is not restricted to being a
294:06 - constant it may in fact be any valid
294:10 - expression involving previously defined
294:12 - values
294:13 - even function calls
294:15 - for example the initializations of the
294:17 - binary search program that we wrote in
294:20 - chapter 3 could be written as
294:22 - binary open parenthesis x comma
294:25 - v comma n close parenthesis int
294:29 - x comma v open square bracket close
294:32 - square bracket comma n semicolon
294:35 - open curly brace
294:37 - int low equals zero semicolon and high
294:40 - equals n minus one semicolon and in mid
294:43 - followed by the rest of the function and
294:45 - then close curly brace
294:47 - instead of
294:51 - initializing these as the first
294:52 - executable statements and we would do
294:54 - this with binary open paren x comma v
294:58 - comma n close paren int x comma v open
295:02 - square bracket close square bracket
295:04 - comma n semicolon
295:06 - open curly brace
295:08 - int low comma mid comma high
295:11 - semicolon low equals 0 semicolon high
295:15 - equals n minus 1 semicolon and so forth
295:19 - in effect initializations of automatic
295:21 - variables are just shorthand for
295:23 - assignment statements
295:25 - which form to prefer is largely a matter
295:27 - of taste we have generally used explicit
295:30 - assignments because initializers and
295:32 - declarations are harder to see
295:35 - automatic arrays may not be initialized
295:37 - external and static arrays may be
295:39 - initialized by following the declaration
295:42 - with a list of initializers enclosed in
295:45 - braces and separated by commas
295:47 - for example the character counting
295:50 - program of chapter 1 which originally
295:52 - was
295:53 - main open parentheses closed princely
295:56 - open curly brace
295:57 - int c comma i comma n white comma n
296:01 - other
296:02 - int n digit open square bracket 10 close
296:05 - square bracket semicolon
296:07 - n white equals n other equals zero
296:12 - four open parenthesis i equals zero
296:14 - semicolon i less than ten semicolon i
296:17 - plus plus closed parenthesis
296:19 - and digit sub i equals 0 and then the
296:22 - rest of the code
296:23 - followed by a closed curly brace
296:25 - finishing main
296:28 - this could be written instead using
296:30 - initializers as follows int and white
296:33 - equals 0 semicolon int and other equals
296:36 - zero semicolon int n digit open square
296:39 - bracket 10 close square bracket equals
296:41 - open curly brace
296:43 - zero com zero comma zero comma zero
296:46 - comma zero comma zero comma zero comma
296:48 - zero comma zero comma zero
296:51 - close curly brace
296:53 - ten zeros in a row and
296:55 - separated by commas and in braces
297:00 - and then the main code is simply main
297:02 - open paren close paren open curly brace
297:05 - in comma c comma i and then the rest of
297:07 - the main code close curly brace the idea
297:09 - is is that with the initializers and
297:11 - with the external variables outside of
297:13 - the main function you do not need to
297:15 - initialize them even with a for loop in
297:18 - the beginning of the main program
297:20 - these initializations are actually all
297:23 - unnecessary since they're all zero
297:25 - anyways but it's a good form to make
297:27 - them explicit anyway
297:28 - if there are fewer initializers than the
297:30 - specialized size the others will be zero
297:33 - it is an error to have too many
297:35 - initializers
297:37 - regrettably there is no way to
297:39 - specify the repetition of an initializer
297:41 - nor to initialize an element in the
297:43 - middle of the ray without supplying all
297:45 - the intermeaning intervening values as
297:47 - well
297:49 - character arrays are a special case of
297:51 - initialization
297:53 - a string may be used instead of the
297:55 - braces in commas notation
297:58 - as in
297:59 - char
298:00 - pattern open square bracket close square
298:02 - bracket equals double quote th e double
298:05 - quote semicolon
298:07 - this is a shorthand for the longer but
298:10 - equivalent char pattern open square
298:12 - bracket close square bracket equals open
298:15 - curly brace single quote t single quote
298:18 - comma single quote h single quote comma
298:22 - single quote e single quote comma single
298:24 - quote backslash zero single quote close
298:27 - curly brace semicolon
298:30 - when the size of an array of any type is
298:33 - omitted the compiler will compute the
298:35 - length of the array by counting the
298:37 - initial
298:38 - initializers in this specific case
298:41 - the size of pattern is four
298:43 - three actual characters plus the
298:45 - terminating backslash zero
298:49 - i would note that the primary difference
298:51 - between c and c influence like languages
298:54 - like java php and javascript this key is
298:58 - that c
298:59 - strings are character arrays while in
299:01 - the other languages strings are objects
299:04 - these string objects do have inside
299:07 - themselves an array of bytes or
299:09 - characters but they also keep track of
299:11 - things like the length of the string and
299:13 - provide functionality like extract a
299:16 - substring in the methods in these
299:17 - objects
299:19 - in c
299:20 - there is a set of library functions that
299:21 - perform string operations like compare
299:23 - two strings
299:25 - while cut string comparison is built
299:26 - into the string objects in each of the
299:28 - other languages
299:30 - strings as character arrays allow
299:32 - programmers to build very fast low-level
299:35 - code in libraries and operating systems
299:38 - but to write the code well you need to
299:39 - understand what is really going on at
299:42 - the low level
299:44 - section 4.10 recursion
299:47 - c functions may be used recursively that
299:50 - is a function may call itself either
299:52 - directly or indirectly
299:55 - one traditional example involves
299:57 - printing of a number as a character
299:58 - string as we mentioned before
300:00 - the digits are generated in the wrong
300:02 - order
300:04 - low order digits are available before
300:06 - four high order digits but they have to
300:08 - be printed in the other way around
300:11 - there are two solutions to this problem
300:13 - one is to store the digits in an array
300:15 - as they are generated and then print
300:17 - them in reverse order as we did in
300:18 - chapter 3 with eye to a
300:21 - the first version of print d follows
300:23 - this pattern
300:24 - this is sample code on page 85 of the
300:27 - textbook you can view the sample code at
300:33 - com www.cc4e.com code page 85 example
300:36 - one
300:38 - pound include stdo dot h
300:41 - print d open paren and close paren
300:44 - in
300:46 - open curly brace char
300:48 - s open square bracket 10 close square
300:51 - bracket semicolon and i semicolon
300:55 - if parenthesis n less than 0 parenthesis
300:58 - open curly brace put char
301:01 - open prin single quote dash
301:03 - single quote close paren semicolon
301:06 - n equals minus n semicolon close curly
301:09 - brace
301:11 - i equals zero
301:13 - semicolon
301:14 - do open curly brace
301:16 - s sub i plus plus
301:19 - equals n modulo 10 plus quote zero quote
301:24 - which gets the next character while
301:27 - parentheses parenthesis
301:30 - equal 10 close parenthesis greater than
301:32 - zero
301:34 - close parenthesis semicolon
301:37 - then we reverse the string while open
301:39 - print minus minus i greater than equal
301:41 - to zero close paren put char open paren
301:45 - s sub i
301:46 - close paren semicolon close curly brace
301:49 - to end the print d function
301:53 - the alternative is a recursive solution
301:56 - in which each call of print d first its
301:58 - calls itself to cope with any leading
302:00 - digits then prints the trailing digit
302:03 - after that call returns
302:05 - this is an example on page 85 of the
302:08 - textbook in its example
302:11 - pound include
302:13 - stdio.h print d open paren n close paren
302:18 - int n semicolon open curly brace
302:22 - int i semicolon if open friend n less
302:26 - than zero close paren open curly brace
302:29 - put chair
302:30 - open paren single quote dash single
302:32 - quote close paren semicolon
302:36 - n equals minus n semicolon close curly
302:39 - brace to finish the if
302:42 - if
302:43 - open paren open print i equals n over 10
302:47 - close print not equal 0
302:51 - close print
302:52 - print d
302:53 - open print i closed paren semicolon
302:55 - that's the recursive call
302:57 - and after the recursive call comes back
302:59 - we do put char open paren
303:01 - n modulo 10 plus
303:04 - single quote 0 single quote close paren
303:06 - semicolon close curly brace to end the
303:08 - print d function
303:11 - when a function calls itself recursively
303:13 - each invocation gets a fresh set of all
303:16 - the automatic variables quite
303:17 - independent of the previous set
303:20 - thus in print d 123
303:23 - the first print d has n equals 123.
303:27 - it passes 12 to a second print e
303:29 - then prints three when that one returns
303:31 - in the same way the second print d
303:33 - passes one to a third which prints it
303:36 - and then prints 2.
303:38 - recursion generally provides no saving
303:40 - in storage since somewhere a stack of
303:42 - values is being processed or has to be
303:44 - maintained nor will it be faster but
303:47 - recursive code is more compact and often
303:50 - much easier to write and understand
303:52 - recursion is especially convenient for
303:55 - recursively defined data structures like
303:57 - trees we will see a nice example in
303:59 - chapter 6.
304:02 - as an aside ah recursion recursion
304:06 - recursion
304:07 - recursion is a beloved concept in
304:10 - computer science
304:11 - it is often taught early in most
304:13 - programming courses because it is just
304:15 - so cool
304:17 - most examples are sadly like computing
304:20 - factorial or the example above
304:22 - converting an integer to a string and
304:24 - they're not good uses a recursion
304:26 - actually
304:27 - but when you do finally find yourself in
304:29 - need of traversing a tree-based
304:31 - structure like an xml document or
304:33 - parsing a mathematical expression with
304:35 - parentheses recursion is the ideal
304:38 - solution so the problem in a sense is
304:40 - not recursion but when it is taught and
304:43 - what examples are used
304:46 - interestingly kernighan and ritchie
304:48 - include the correct warning about using
304:51 - recursion when it is not
304:54 - the best solution in the above text
304:56 - and it bears another read
304:59 - back to the book
305:02 - recursion generally provides no saving
305:05 - in storage since somewhere a stack of
305:07 - values is being processed or has to be
305:09 - maintained nor will it be faster
305:11 - but recursive code is more compact and
305:14 - often much easier to write and
305:16 - understand
305:17 - recursion is especially convenient for
305:19 - recursively defined data structures
305:21 - like trees we will see a nice example in
305:24 - chapter 6.
305:27 - i couldn't have said it better
305:32 - section 4.11 the c
305:36 - preprocessor
305:37 - c provides certain language extensions
305:40 - by means of a simple macro preprocessor
305:44 - the pound defined capability which we
305:46 - have used is the most common of these
305:47 - extensions
305:49 - another is the ability to include the
305:50 - entire contents of other files during
305:52 - compilation
305:54 - file inclusion
305:56 - to facilitate handling of pound defines
305:58 - and declarations among other things c
306:01 - provides a file inclusion feature
306:03 - any line that looks like pound include
306:06 - space double quote file name double
306:08 - quote
306:09 - is replaced by the contents of the file
306:11 - name the quotes are indeed mandatory
306:14 - often a line or two of this form appears
306:16 - at the very beginning of each source
306:17 - file to include common pound-defined
306:19 - statements and extern declarations for
306:21 - global variables pound includes may be
306:24 - nested
306:25 - pound include is the preferred way to
306:27 - tie declarations together for a large
306:29 - problem and in a large program
306:31 - it guarantees that all the source files
306:33 - will be supplied with the same
306:35 - definitions and variable declarations
306:37 - thus eliminating a particularly nasty
306:39 - kind of bug
306:40 - of course when an include file is
306:42 - changed all the files that depend on it
306:44 - must be recompiled
306:48 - macro substitution
306:50 - a definition of the form pound define
306:53 - yes one calls for a macro substitution
306:56 - of the simplest kind
306:59 - repeat replacing a logical name by a
307:02 - string of characters names in the pound
307:05 - of fine have the same forms as the c
307:07 - identifiers the replacement text is
307:09 - arbitrarily normally the replacement
307:11 - text is the rest of the line
307:14 - a long definition may be continued by
307:16 - pasting a backslash at the end of the
307:18 - line to be continued the scope of the
307:20 - name defined with pound define is from
307:22 - from its point of definition to the end
307:25 - of the source file
307:26 - names may be redefined and a definition
307:28 - may use previous definitions
307:31 - substitutions do not place take place
307:34 - within quoted strings so for example if
307:37 - yes is a defined name there would be no
307:40 - substitution in printf open paren double
307:42 - quote yes double quote close paren
307:46 - since implementation of pound define is
307:48 - a macro pre-pass not part of the
307:51 - compiler proper there are very few
307:53 - grammatical restrictions on what can be
307:55 - defined for example
307:57 - alcohol fans can say
307:59 - pound define
308:00 - then and then nothing
308:03 - pound define begin
308:05 - open curly brace
308:07 - pound define end
308:09 - semicolon close curly brace and then
308:11 - write
308:12 - approximate algo
308:14 - if
308:15 - paren i greater than zero close paren
308:17 - then begin
308:19 - a equals one semicolon
308:22 - b equals two
308:24 - end
308:27 - it is also possible to define macular
308:29 - macros with arguments so the replacement
308:31 - text depends on the way the macro is
308:33 - called
308:34 - as an example define a macro called max
308:37 - like this
308:38 - pound define max open paren a comma b
308:44 - open paren open paren a close paren
308:46 - greater than open paren b close print
308:49 - question mark open parent a closed paren
308:52 - colon open paren b close paren close
308:55 - paren
308:56 - now the line x equals max open paren p
309:00 - plus q comma r plus s close paren
309:03 - semicolon will be replaced in the
309:06 - preprocessor by the line
309:08 - x equals open paren open paren p plus q
309:12 - close paren greater than open paren r
309:14 - plus s close paren question mark open
309:17 - paren p plus q close print colon open
309:20 - paren r plus s close paren close print
309:23 - semicolon
309:24 - this provides a maximum function that
309:27 - expands into inline code rather than a
309:29 - function call
309:31 - so long as the arguments are treated
309:33 - consistently this macro will serve for
309:35 - any data type there is no need for
309:37 - different kinds of macs for different
309:39 - data types as there would be with
309:41 - functions
309:42 - of course if you examine the expansion
309:44 - of max above you will notice some
309:46 - pitfalls the expressions are evaluated
309:49 - twice it is bad if they involve side
309:51 - effects like function calls increment
309:54 - operators or perhaps push and pop like
309:56 - we've used before
309:57 - some care has to be taken with
309:59 - parentheses to make sure the order order
310:01 - of evaluation is preserved
310:04 - consider the macro
310:06 - pound defined square open paren x close
310:09 - paren equals
310:11 - x times x
310:13 - when it is invoked as square open paren
310:17 - z plus one
310:19 - close paren
310:20 - there are even some purely lexical
310:22 - problems
310:23 - there can be no space between the macro
310:25 - name and left parenthesis that
310:26 - introduces the argument list
310:28 - nevertheless macros are quite valuable
310:31 - one practical example is the standard io
310:33 - library to be described in chapter 7 in
310:36 - which git char and put char are defined
310:38 - as macros obviously put chart needs an
310:41 - argument thus avoiding the overhead of a
310:44 - function call per character profit
310:46 - process
310:47 - other capabilities of the macro
310:49 - processor are described in appendix a
310:54 - as a bit of a long aside
310:57 - in this section we are talking about the
310:59 - preprocessor
311:00 - it's probably a good time to talk a bit
311:02 - about why we use this terminology
311:05 - for those of you with a computer science
311:07 - degree from back in the day many of you
311:09 - wrote a compiler as a senior project
311:10 - just like i did
311:12 - building a compiler was a great project
311:14 - because part of the goal of computer
311:16 - science is to understand the
311:17 - technologies that make programming
311:19 - process possible from the language
311:21 - syntax down to the hardware
311:23 - the compiler that translates our source
311:25 - code into machine code is an essential
311:28 - part of the technology stack that we use
311:31 - early compilers for languages like the
311:33 - early fortran variants tended to be
311:35 - translators they just translated code
311:37 - one line at a time from a high-level
311:38 - language to assembly language
311:40 - you could think of early fortran
311:42 - programs in the 1950s and the 1960s as
311:45 - just more convenient ways to write
311:47 - assembly language for programmers that
311:49 - knew assembly language you always needed
311:51 - to be aware of assembly language and the
311:53 - translation
311:55 - that it was going to write
311:57 - fast fortran
311:59 - programs were small and optimization was
312:01 - done at the fortran level often leading
312:03 - to some hard to understand code
312:06 - by the mid-1970s programming languages
312:09 - were based on parsing theory and we used
312:11 - what is called a grammar to define the
312:13 - language
312:14 - kernighan and ritchie kept io statements
312:16 - out of the c language to keep its formal
312:18 - definition i.e its grammar as simple as
312:21 - possible
312:22 - as these new languages emerge they
312:24 - allowed for more theoretical and
312:26 - powerful approach to converting source
312:27 - code to machine language
312:30 - the theoretical advances in compiler and
312:32 - language design meant that parts of the
312:34 - compiler might be reusable across
312:37 - multiple programming languages
312:39 - each language could have its own syntax
312:41 - and grammar rules and they could be
312:43 - plugged into the compiler and poof you
312:45 - would have a new programming language
312:47 - it got to the point where unix system
312:50 - unix systems had a tool called yak which
312:53 - stood for yet another compiler compiler
312:56 - you would give it a grammar for your new
312:57 - language and it would make a compiler
312:59 - for you
313:00 - as a matter of fact the javascript
313:02 - language that was created in 10 days
313:04 - back in 1995 was possible because
313:07 - brendan ike had a lot of experience with
313:09 - compiler generators
313:11 - he defined a grammar for javascript and
313:13 - generated his first compiler
313:15 - part of what made a compiler generate
313:17 - generator possible is the idea of a
313:19 - multi-step compiler or the tasks of a
313:22 - compiler were broken down into a series
313:24 - of simpler and more well-defined steps
313:27 - here are the steps of a typical c
313:29 - compiler in the 1970s
313:32 - first a preprocessor step that takes c
313:34 - code with syntax like pound define and
313:36 - pout include as its input and produces
313:38 - raw c code output with o's instructions
313:41 - processed and or expanded the
313:43 - preprocessor processor was a c to c
313:46 - transformation
313:48 - next
313:49 - a parser step that took the raw c code
313:51 - applied the grammar to the language and
313:53 - created what is called a parse tree
313:55 - think of the tree as a hierarchy of
313:57 - statements grouped into blocks grouped
313:59 - into functions etc of things like a loop
314:01 - or just one node in a parse tree
314:04 - after that a code generation would turn
314:06 - the parse tree into some kind of
314:08 - simplistic
314:09 - portable internal code that expanded
314:11 - things like loops and if-then-else
314:12 - statements into code
314:15 - after that a code optimization that
314:18 - looked at the internal code and moved
314:19 - things around
314:21 - eliminating any redundant computations
314:24 - say don't compute the same things twice
314:26 - this step is why the authors make such a
314:28 - big fuss about how there are times where
314:30 - c might do things in a slightly
314:32 - different order in an expression even in
314:34 - the presence of parentheses remember the
314:37 - knrc arrangement license back in chapter
314:39 - 2
314:41 - that rule removes constraints on the
314:42 - compiler's optimization step so it can
314:45 - generate the most efficient code
314:48 - i would note that all the steps up to
314:50 - this point did not depend in any way on
314:53 - the actual machine language of the
314:54 - system that they were running on this
314:56 - meant a preprocessor parser code
314:59 - generator and code optimizer could
315:01 - literally be written in c and used on
315:03 - any architecture
315:05 - the final step is a code generator
315:08 - that takes the optimized intermediate
315:11 - code and generates the actual assembly
315:13 - and machine language for the processor
315:15 - for fun you can add the minus capital s
315:17 - parameter to your c compiler and see the
315:19 - resulting assembly language output for
315:21 - your system
315:23 - if you look at the machine language
315:24 - generated on intel or amd processor
315:27 - and compare it to the machine language
315:29 - on an arm processor it will look very
315:31 - different
315:33 - because all but the final compiler steps
315:35 - did not depend on the computer where the
315:36 - program is being run you could actually
315:38 - create a c compiler on a new computer
315:40 - architecture by writing a code generator
315:43 - on the new computer then running all but
315:45 - the last step of the compiler on one
315:46 - computer then copying the internal code
315:49 - generated by the compiler to the new
315:50 - compiler and running the code generation
315:52 - step on the new computer
315:55 - then you actually have a working c
315:57 - compiler
315:58 - on the new computer and the first step
316:00 - is usually to recompile the c compiler
316:02 - itself from source code to produce a
316:04 - fully native c compiler on the new
316:06 - computer that can compile all the rest
316:08 - of the c code you have including
316:10 - possibly the mostly portable elements of
316:13 - the unix operating system on the new
316:15 - compiler
316:17 - yes describing how to cross compile and
316:18 - bootstrap a c compiler onto a new
316:20 - computer hardware architecture can give
316:22 - you a headache if you think about it too
316:24 - much
316:25 - but this notion of bootstrapping a c
316:26 - compiler onto a new architecture was an
316:29 - important technique to move c and then
316:31 - unix to a wide range of very different
316:34 - computer architectures
316:36 - we see this in action as the unix-like
316:38 - mac os operating system over the past 20
316:40 - years was delivered initially on a
316:42 - motorola 68 000 family processors then
316:46 - on powerpc processors and then on intel
316:49 - processors and most recently on
316:51 - arm-based processors built by apple
316:54 - using the software portability patterns
316:56 - that come from c and unix and described
316:58 - by kernighan and ritchie in this book
317:00 - apple now makes their own hardware that
317:03 - can be tuned and evolved over time as
317:06 - their operating system and their
317:08 - applications requirements
317:10 - dictate
317:11 - the use of a grammar by the way is to
317:13 - define a programming language is one of
317:15 - the reasons that syntax errors are so
317:17 - obtuse
317:18 - the compiler is not looking at your code
317:20 - like a human it is following a very set
317:24 - of simple rules to parse your code and
317:26 - it's stuck with something
317:27 - logical and gives you a message like
317:29 - unexpect
317:31 - unexpected statement block or constant
317:34 - on line 17 and the error is nowhere near
317:36 - line 17.
317:39 - modern compilers are more sophisticated
317:42 - of course than the steps above but these
317:43 - steps give you a sense the compiler does
317:45 - many things to make it so your code can
317:48 - actually run
317:49 - very efficiently
317:51 - and given that kernighan and richie were
317:52 - building a programming language c a more
317:54 - mostly portable operating system written
317:56 - in c unix and a mostly portable c
317:58 - compiler written in c
318:01 - some of their innovative work and
318:03 - research into compiler design finds it
318:06 - its way into this book so we have a
318:08 - section in this chapter called the c
318:10 - preprocessor
318:12 - so here we are at the end of chapter
318:14 - four
318:15 - and it's a good time to talk about the
318:17 - word address
318:19 - up to this point in the book if you
318:20 - count them the word address has been
318:22 - used 10 times without a precise
318:24 - definition beyond the notion that data
318:27 - is stored in memory and the address of
318:29 - the data is where the data is stored in
318:30 - memory
318:33 - in the next chapter this notion of the
318:35 - address where the data is stored becomes
318:38 - very real and tangible as we explore
318:41 - pointers as well as the ampersand and
318:43 - asterisk operators
318:46 - up to now
318:47 - an experienced javascript php or java
318:49 - programmer can view c as just another
318:52 - set of similar syntax rules with a few
318:55 - quirky runtime bits
318:57 - but in the next chapter
318:59 - we will deeply explore the concept of
319:01 - data allocation and location
319:04 - it turns out that every programming
319:07 - language pays a lot of attention to data
319:09 - allocation and location but the runtime
319:11 - environments of modern languages work
319:14 - very hard not to expose you to those
319:16 - details
319:17 - just because modern languages hide the
319:19 - difficult bits from us it does not mean
319:22 - that those languages solve the problem
319:24 - using magic
319:26 - eventually the problem needs to be
319:28 - solved
319:30 - and that is why the compiler and
319:32 - low-level runtime elements of language
319:34 - like php
319:35 - javascript and java are usually written
319:37 - in c
319:39 - so the builders of those languages can
319:41 - solve the difficult data storage and
319:43 - allocation problems
319:45 - for you
319:47 - this work
319:48 - is based on the 1978 c programming book
319:51 - written by brian w kernighan and dennis
319:54 - m ritchie
319:55 - their book is copyright all rights
319:57 - reserved by at t
319:58 - but is used in this work under fair use
320:01 - because of the book's historical and
320:03 - scholarly significance
320:05 - its lack of availability and the lack of
320:07 - an accessible version of the book
320:09 - the book is augmented in places to help
320:11 - understand its rightful place in a
320:13 - historical context amidst the major
320:15 - changes of the 1970s and 1980s as
320:18 - computer science evolved from a hardware
320:20 - first vendor-centered approach to a
320:22 - software centered approach where
320:24 - portable operating systems and
320:26 - applications written in c could run on
320:28 - any hardware
320:30 - this is not the ideal book to learn c
320:32 - programming because the 1978 edition
320:34 - does not reflect the modern c language
320:37 - using an obsolete book gives us an
320:39 - opportunity to take students back in
320:41 - time and understand how the c language
320:44 - was evolving as it laid the groundwork
320:46 - for a future with portable applications
320:52 - chapter 5 pointers and arrays
320:55 - before we start chapter 5 a quick note
320:58 - from your narrator
320:59 - from time to time i have been adding
321:01 - some of my interpretation to this book
321:04 - but i won't be adding anything to this
321:06 - chapter
321:07 - i think that sections 5.1 through 5.6
321:11 - contain some of the most elegantly
321:13 - written text in the book
321:15 - the concepts are clearly stated and the
321:17 - example code is short direct and easy to
321:21 - understand
321:22 - pointers are the essential difference
321:24 - between c and any other modern
321:27 - programming language
321:28 - so pay close attention to this chapter
321:31 - and make sure that you understand it
321:33 - before continuing
321:35 - this chapter is as strong now as it was
321:37 - in 1978
321:39 - and so without further ado we read and
321:41 - listen as kernighan and ritchie teach us
321:44 - about pointers and arrays
321:48 - a pointer is a variable that contains
321:50 - the address of another variable
321:52 - pointers are very much used in c
321:55 - partly because they are sometimes the
321:57 - only way to express a computation
322:00 - and partly because they usually lead to
322:02 - more compact and efficient code than can
322:05 - be obtained in other ways
322:08 - pointers have been lumped with a go-to
322:10 - statement as a marvelous way to create
322:12 - impossible to understand programs
322:15 - this is certainly true when they are
322:17 - used carelessly and it is easy to create
322:20 - pointers that point somewhere unexpected
322:23 - with discipline however pointers can
322:25 - also be used to achieve clarity and
322:28 - simplicity
322:29 - this
322:30 - is the app aspect that we will try to
322:32 - illustrate
322:35 - section 5.1
322:37 - pointers and addresses
322:40 - since a pointer contains the address of
322:42 - an object it is possible to access the
322:45 - object indirectly through the pointer
322:48 - suppose that x is a variable say int
322:51 - and that px is a pointer created in
322:55 - some as yet unspecified way
322:58 - the unary operator ampersand gives the
323:01 - address of an object so the statement
323:04 - px equals ampersand x semicolon
323:08 - assigns the address of x to the variable
323:11 - px
323:12 - px is now said to point to x
323:16 - the ampersand operator can be applied
323:18 - only to variables and array elements
323:21 - construct like ampersand open paren x 1
323:24 - close paren and ampersand 3 are illegal
323:29 - it is also illegal to take the address
323:31 - of a register variable
323:34 - the unit the unary operator asterisk
323:36 - treats its operand as the address of the
323:39 - ultimate target
323:40 - and accesses that address to fetch the
323:42 - contents thus
323:44 - if y is also an int
323:48 - y equals star p x semicolon
323:52 - assigns to y the contents of whatever px
323:56 - points to
323:57 - so the sequence
323:59 - px equals ampersand x semicolon
324:02 - y equals star px semicolon assigns the
324:06 - same value to y as does y equals x
324:12 - it is also necessary to declare the
324:14 - variables that participate in all of
324:15 - this
324:16 - int x comma y semicolon int star px
324:21 - semicolon the declaration of x and y is
324:24 - what we have seen all along
324:26 - the declaration of the pointer px is new
324:30 - int star px semicolon
324:33 - is intended as a mnemonic
324:35 - it says that the combination star px is
324:38 - an end
324:39 - that is if px occurs in the context star
324:43 - px it is equivalent to a variable of
324:46 - type int
324:47 - in effect the syntax of the declaration
324:50 - for a variable
324:51 - mimics the syntax of expressions in
324:54 - which the variable might appear
324:56 - this reasoning is useful in all cases
324:59 - involving complicated declarations
325:02 - for example double a to f open
325:05 - parenthesis close parenthesis comma star
325:07 - dp semicolon
325:09 - says that in a particular expression a
325:12 - to f open friend close friend and star
325:14 - dp have values of type double
325:18 - you should also note the implication in
325:20 - the direction declaration
325:23 - that a pointer is constrained to point
325:24 - to a particular kind of objects
325:28 - pointers can occur in expressions for
325:30 - example
325:31 - if px points to the integer x then star
325:35 - px
325:36 - can occur in any context where x could
325:39 - y equal star px plus 1
325:43 - sets y to 1 more than x
325:48 - printf open parenthesis double quote
325:50 - percent d backslash n double quote comma
325:54 - star px close paren prints the current
325:57 - value of x
325:59 - and
326:00 - d equals square root open paren open
326:03 - paren double
326:04 - close paren star p x close paren
326:08 - produces in d the square root of x which
326:11 - is coerced into a double before being
326:13 - passed to square root
326:16 - in expressions like y equals star px
326:20 - plus 1 the unary operators
326:22 - star and ampersand bind more tightly
326:26 - than arithmetic operators so this
326:28 - expression takes whatever px points at
326:31 - adds one and assigns it to y
326:33 - we will return shortly to what
326:36 - y equals star open paren px plus one
326:39 - close paren might mean
326:43 - pointer references can also occur on the
326:46 - left side of assignments
326:47 - if px points to x
326:50 - then
326:51 - star px equals zero sets x to zero
326:55 - and star px plus equals one
326:58 - increments it as does open paren star px
327:02 - close paren plus plus
327:04 - the parentheses are necessary in this
327:06 - last example without them
327:08 - the ink expression would increment px
327:11 - instead of what it points to because
327:13 - unary operators like star
327:16 - and plus plus are evaluated right to
327:19 - left
327:21 - finally since pointers are variables
327:23 - they can be manipulated as other
327:25 - variables can
327:27 - if py is another pointer to int
327:30 - then py equals px
327:33 - copies the contents of px into py
327:37 - thus making py point to whatever px
327:40 - points to
327:42 - section 5.2 pointers and function
327:45 - arguments
327:47 - since c passes arguments to functions
327:50 - by call by value there is no direct way
327:54 - for the called function
327:55 - to alter the variable in the calling
327:57 - function
327:59 - what do you do if you really have to
328:02 - change an ordinary argument
328:04 - for example
328:05 - a sorting routine might exchange two out
328:07 - of order elements with a function called
328:09 - swap
328:10 - it's not enough to write swap open
328:12 - parentheses a comma b close parentheses
328:15 - semicolon where the swap function is
328:18 - defined as and this is sample source
328:20 - code on page 91 of the textbook and you
328:23 - can see it at www.cc4e.com
328:27 - code
328:29 - this is a wrong swap by the way this
328:31 - this is showing you the code that you're
328:33 - not supposed to do
328:35 - swap open paren x comma y close paren
328:39 - int x comma y
328:41 - semicolon open curly brace
328:43 - int temp semicolon temp equals x x
328:47 - equals y semicolon y equals temp
328:50 - semicolon close curly brace
328:53 - because of call by value swap can't
328:56 - affect the arguments a and b in the
328:58 - routine that called it
329:00 - fortunately there is a way to obtain the
329:03 - desired effect
329:05 - the calling point program passes
329:08 - pointers to the values to be changed
329:10 - the call is swap open parentheses
329:13 - ampersand a comma ampersand b close
329:16 - parentheses semicolon
329:18 - since the operator ampersand gives the
329:21 - address of a variable
329:22 - ampersand a is a pointer to a
329:25 - in swap itself the arguments are
329:27 - declared to be pointers and the actual
329:29 - operands are accessed through them
329:32 - so the correct code is on page 92
329:36 - swap open paren px comma py close paren
329:41 - int star px comma star py semicolon
329:46 - open curly brace
329:47 - int temp semicolon
329:50 - temp equals star px semicolon
329:53 - star px equals star py semicolon
329:57 - star py equals temp semicolon and closed
330:01 - curly brace
330:05 - one common use of pointer arguments is
330:07 - in functions that must return more than
330:09 - a single value
330:11 - you might say that swap actually returns
330:13 - two values the new values of its
330:14 - arguments
330:16 - as an example consider a function getint
330:19 - which performs a free format input
330:21 - conversion by breaking a stream of
330:22 - characters into integer values one
330:25 - integer per call
330:27 - getint
330:28 - has to return the value that it found or
330:30 - an end to file signal when there is no
330:32 - more input
330:33 - these values have to be returned as
330:35 - separate objects for no matter what
330:38 - value is used for eof that could also
330:41 - be a value of the integer
330:44 - one solution which is based on the input
330:46 - function scanf that we will describe in
330:48 - chapter seven
330:50 - is to have get in to return eof as its
330:53 - function value it finds end of file and
330:55 - other any other return value singles a
330:58 - normal integer
330:59 - the numeric
331:01 - value of the integer it found is
331:02 - returned through an argument which then
331:04 - must be a pointer to an integer
331:07 - this organization
331:08 - separates the end of file status from
331:10 - the returned numeric value
331:14 - the following loop fills an array with
331:16 - integers by calls to getint
331:19 - int
331:20 - n comma array open print size close
331:22 - paren semicolon
331:24 - for n equals zero
331:27 - n
331:28 - less than size
331:30 - double ampersand
331:31 - get int open paren ampersand v close
331:34 - print not equal eof semicolon and plus
331:37 - plus close parentheses
331:40 - array sub n equals v
331:44 - each call sets v to the next integer
331:46 - found in the input
331:48 - notice that is essential to write
331:51 - ampersand v instead of v as the argument
331:54 - to get int
331:55 - using plane v is likely to cause an
331:57 - addressing error since getint believes
332:00 - that it's been handed a valid pointer
332:03 - getint is an obvious modification to a
332:06 - to i which we wrote earlier
332:09 - the sample code is on page 93 of the
332:12 - textbook and you can see this sample
332:13 - code at
332:17 - dot www.cc4e.com slash code
332:20 - pound include stdio.h
332:22 - getint open paren pn
332:25 - close print
332:26 - int star pn
332:29 - semicolon
332:30 - open for open curly brace
332:33 - int c comma sign
332:36 - while open print open print c equals get
332:38 - ch open praying close paren close print
332:41 - double equals quote space quote
332:44 - or
332:45 - c double equals quote backslash n quote
332:49 - or
332:50 - c double equals backslash t
332:53 - quote
332:55 - close paren semicolon this loop we've
332:57 - done before and it skips the white space
333:01 - sine equals one semicolon if open paren
333:04 - c double equals quote plus quote or
333:08 - c double equals quote minus quote close
333:10 - paren open curly brace
333:13 - equals open parenthesis double equals
333:16 - quote plus quote close paren question
333:19 - mark 1 colon -1 semicolon
333:23 - c equals gut ch
333:26 - to advance the character
333:27 - semicolon
333:29 - and then close curly brace that those
333:31 - four lines record the sign
333:34 - now
333:35 - four
333:36 - star pn equals zero
333:38 - c greater than or equal to quote zero
333:40 - quote and c less than or equal to quote
333:42 - 9 quote
333:43 - colon
333:44 - semicolon c equals get ch open paren
333:48 - close paren close curly brace
333:51 - star pn equals 10 times star pn plus
333:56 - c minus quote zero quote
334:00 - star pn star equals sine
334:06 - if open paren c not equal to eof close
334:10 - print on get ch open paren c close paren
334:13 - semicolon
334:15 - return c
334:20 - throughout get int star pn is used as an
334:23 - ordinary int variable
334:26 - we have also used getch and ungetch as
334:29 - described in chapter four
334:31 - so the one extra character that must be
334:33 - read can be pushed backed on to the
334:34 - input section 5.3 pointers and arrays
334:38 - and see there is a strong relationship
334:40 - between pointers and arrays
334:42 - strong enough that pointers and arrays
334:45 - should really be treated simultaneously
334:48 - any operation which can be achieved by
334:50 - array subscripting can also be done with
334:53 - pointers
334:55 - the pointer version will in general be
334:57 - faster
334:58 - but at least to the uninitiated somewhat
335:00 - harder to grasp immediately
335:03 - the declaration int a sub 10
335:07 - defines an array a of size 10 that is a
335:11 - block of 10 consecutive objects named a
335:14 - sub 0
335:15 - a sub 1
335:17 - dot dot a sub 9. the notation a sub i
335:20 - means the element of the array i
335:23 - positions from the beginning
335:25 - if
335:27 - p a
335:28 - is
335:30 - a pointer to an integer
335:33 - declared as int star pa
335:36 - then the assignment
335:38 - pa
335:39 - equals
335:40 - ampersand a
335:42 - sub zero
335:43 - sets pa to 0.2 the zeroth element of a
335:49 - that is pa contains the address of a sub
335:53 - zero
335:55 - now the assignment
335:56 - x equals star pa will copy the contents
336:00 - of a sub 0 into x
336:04 - if pay a points to a particular element
336:07 - of array a
336:08 - then by definition pa
336:11 - points to the next element
336:13 - nope
336:18 - if pa points to a particular element of
336:21 - an array a then by definition pa plus 1
336:25 - points to the next element
336:27 - and in general
336:29 - a minus i points to i elements before p
336:32 - a and p a plus i
336:35 - points to i elements after
336:37 - thus if p a points to a sub zero
336:42 - star parentheses pa plus 1 closed
336:46 - parenthesis refers to the contents of a
336:49 - sub 1.
336:51 - pa plus i is the address of a sub i
336:56 - and star print
337:01 - and star open paren pa plus i
337:05 - is the contents of a sub i
337:08 - these remarks are true regardless of the
337:10 - type of the variables in the array a
337:13 - the definition of adding one to a
337:15 - pointer and by extension all pointer
337:18 - arithmetic
337:19 - is that the increment is scaled by the
337:21 - size of the storage of the object that
337:23 - is pointed to
337:26 - thus in pa plus i
337:28 - i is multiplied by the size of the
337:31 - objects that pa points to before being
337:33 - added to pa
337:35 - the correspondence between indexing and
337:38 - pointer arithmetic is evidently very
337:41 - close
337:42 - in fact a reference to an array is
337:44 - converted by the compiler
337:46 - to a pointer to the beginning of the
337:48 - array
337:49 - the effect is that the array name is a
337:52 - pointer expression this has quite a few
337:55 - useful implications
337:57 - since the name of an array is a synonym
337:59 - for the location of the zeroth element
338:03 - the assignment
338:04 - pa equals
338:07 - ampersand a sub zero can also be written
338:10 - as p a
338:12 - equals a
338:16 - rather more surprising at least at first
338:18 - sight is the fact that a reference to a
338:20 - sub i can also be written as
338:23 - star open paren a plus i close paren
338:27 - in evaluating a sub i
338:30 - c converts it to star open paren a plus
338:33 - i close paren immediately the two forms
338:37 - are completely equivalent
338:39 - applying the operator ampersand to both
338:41 - parts of this equivalence it follows
338:43 - that ampersand a sub i and a plus i are
338:46 - also identical
338:48 - a plus i is the address of the ith
338:51 - element beyond a
338:53 - as on the other side of this coin if p a
338:56 - is a pointer
338:57 - expressions may use it with a subscript
339:00 - p a sub i
339:02 - is identical to star open paren pa plus
339:06 - i close print
339:08 - in short
339:09 - any array and index expression
339:12 - can be rewritten as a pointer and an
339:14 - offset and vice versa even in the same
339:17 - statement
339:19 - there is one difference between an array
339:21 - name and a pointer that must be kept in
339:23 - mind
339:24 - a pointer is a variable
339:27 - so pa equals a
339:29 - and pa plus plus are sensible operations
339:34 - but an array name is a constant not a
339:36 - variable constructions like a equals pa
339:40 - or a plus plus
339:42 - or
339:42 - p equals ampersand a
339:45 - are illegal
339:47 - when an array name is passed to a
339:49 - function
339:50 - what is passed is the location of the
339:52 - beginning of the array
339:54 - within the call function this argument
339:56 - is a variable just like any other
339:59 - variable and so an arrayname argument is
340:02 - truly a pointer that is a variable
340:05 - containing an address
340:07 - we can use this fact to write a new
340:09 - version of stirlin
340:11 - which computes the length of the string
340:14 - the sample code is on page 95 of the
340:16 - book and you can see it in www.cc4e.com
340:21 - code
340:23 - page 95.
340:25 - int stirlin open paren s close prin
340:29 - char
340:30 - star s semicolon
340:33 - open curly brace
340:35 - int n semicolon
340:38 - four
340:39 - open parenthesis n equals zero semicolon
340:42 - star s not equal quote backslash zero
340:46 - quote semicolon
340:48 - s plus plus
340:49 - close paren
340:51 - n plus plus
340:53 - return open print and close paren
340:56 - semicolon
340:57 - close curly brace
341:00 - incrementing s is perfectly legal since
341:03 - it's a pointer variable
341:05 - s plus plus has no effect on the
341:08 - character string in the function that
341:10 - called sterlin but merely increments the
341:12 - stir lens private copy of the address
341:16 - as the formal parameters in a function
341:18 - definition
341:19 - char
341:20 - s open square bracket close square
341:22 - bracket
341:23 - semicolon and
341:25 - char
341:26 - star s semicolon are exactly equivalent
341:31 - which one should be written is
341:32 - determined largely by how expressions
341:34 - will be written in the function
341:36 - when an array name is passed to a
341:38 - function the function can at its
341:40 - convenience believe that has been handed
341:42 - either an array or a pointer and
341:43 - manipulated accordingly
341:45 - it can even use both kinds of operations
341:48 - if it seems appropriate
341:50 - and clear
341:52 - it is possible to pass part of an array
341:55 - to a function
341:56 - by passing a pointer to the beginning of
341:59 - the subarray
342:01 - for example if a is an array
342:04 - f open friend ampersand a sub 2 close
342:08 - print
342:09 - and
342:10 - f open paren a plus 2 close print
342:14 - both pass to the function f the address
342:16 - of the element a sub 2
342:19 - because ampersand a sub 2 and a plus 2
342:22 - are both pointer expressions that refer
342:25 - to the third element of a
342:29 - within f the argument declaration can
342:32 - read
342:34 - f open paren
342:36 - array
342:37 - close paren int array open bracket close
342:40 - bracket semicolon
342:42 - dot dot dot or
342:45 - f
342:45 - open paren
342:47 - array closed paren and star array
342:50 - semicolon
342:53 - so far as f is concerned the fact that
342:55 - the argument
342:57 - really refers to part of a larger array
343:00 - is really of no consequence
343:04 - section 5.4 address arithmetic if p is a
343:08 - pointer then p plus plus increments p to
343:11 - point to the next element of whatever
343:13 - kind of object p points to
343:16 - and p plus equals i increments p to the
343:20 - point i elements beyond where it
343:22 - currently does
343:23 - these and similar constructions are the
343:25 - simplest and most common form forms of
343:28 - pointer or address arithmetic
343:30 - c is consistent and regular in its
343:33 - approach to address arithmetic its
343:35 - integration of pointers arrays and
343:37 - address arithmetic is one of the major
343:40 - strengths of the language
343:42 - let us illustrate some of the properties
343:44 - by writing a rudimentary storage
343:46 - allocator but useful in spite of its
343:48 - simplicity
343:50 - there are two routines alec open paren
343:52 - and close paren returns a pointer p to n
343:56 - consecutive character positions which
343:58 - can be used by the caller of alec for
344:00 - storing characters
344:02 - free open paren p close print releases
344:05 - the storage thus acquired so it can
344:07 - later be reused
344:09 - these routines are rudimentary because
344:12 - the calls to free must be made in the
344:14 - opposite order to the calls on alec
344:17 - that is storage managed by alec and free
344:20 - is a stack or last in first out
344:24 - the standard c library provides
344:25 - analogous functions which have no such
344:27 - restrictions and in chapter 8 we'll show
344:30 - how improved versions as well in the
344:32 - meantime however
344:33 - many applications really only need a
344:35 - trivial alec to dispense little pieces
344:37 - of storage of unpredictable sizes at
344:40 - unpredictable times
344:42 - the simplest
344:44 - implementation is to have alec hand out
344:46 - pieces of a large character array which
344:48 - we will call alec buff
344:50 - this array is private to allocan free
344:53 - since they deal in pointers and not
344:55 - array indices no other routine need know
344:57 - the name of the array which can be
344:59 - declared as external static that is
345:01 - local to the source file containing
345:03 - allocan free and invisible outside it
345:06 - in practical implementations the array
345:08 - may well not even have a name it might
345:11 - be obtained by asking the operating
345:13 - system for a pointer to some unnamed
345:15 - block of storage
345:18 - the other information needed is how much
345:20 - alec buff has been used we use a pointer
345:23 - to the next free element called alex cp
345:26 - when alec is asked for n characters it
345:28 - checks to see if there is enough room
345:31 - left in alec buff
345:33 - if so alec returns the current value of
345:35 - alec p ie the beginning of the free
345:37 - block and then increments it by n to
345:40 - point to the next free area
345:42 - free p
345:43 - merely sets alec p to p
345:46 - if p is inside alec buff
345:49 - this next code example is on page 97 of
345:52 - the textbook
345:53 - you can see the code at www.cc4e.com
345:58 - code
346:00 - pound include stdio.h
346:04 - to find null zero it's a pointer value
346:06 - for in the error report
346:08 - pound define alec size 1000 the size of
346:11 - the available space
346:13 - static char alec buff open square
346:16 - bracket alex size close square bracket
346:18 - semicolon
346:19 - static chair
346:21 - char star alec p equals alec buff next
346:25 - free position initialized to the start
346:27 - of the array
346:29 - char
346:30 - star alec open paren
346:32 - and close paren return a pointer to n
346:35 - characters
346:36 - int n semicolon open curly brace
346:40 - if alec cp plus n
346:43 - less than or equal to
346:45 - alec buff plus alec size close paren
346:48 - open curly brace
346:50 - meaning we have space
346:52 - alex cp plus equals n return
346:55 - alex cp minus n close parenthesis
346:58 - semicolon
347:00 - close curly brace else if there's not
347:02 - enough room return open paren null close
347:05 - paren semicolon close curly brace
347:09 - free open paren p close print this
347:12 - function will free the storage pointed
347:13 - to by p
347:15 - char star p
347:16 - open curly brace if open paren p greater
347:20 - than equal to alec buff and
347:23 - p less than alec buff plus alex size
347:26 - alex cp equals p
347:28 - close curly brace
347:31 - some explanations
347:33 - in general a pointer can be initialized
347:35 - just as any other variable can though
347:37 - normally only meaningful values are null
347:39 - discussed below or an expression
347:41 - involving the address of a previously
347:43 - defined data of the appropriate type
347:46 - the declaration static char star alex cp
347:50 - equals alec buff
347:51 - defines alex cp
347:55 - to be a character pointer and
347:56 - initializes it to point to alec buff
347:59 - which is the next free position when the
348:01 - program starts
348:03 - this could also have been written
348:05 - static char stala star alex cp equals
348:09 - ampersand alec buff sub-zero semicolon
348:12 - since the array name is the address of
348:15 - the zeroth element
348:17 - whichever is more natural
348:19 - the test
348:20 - if open paren alec p
348:24 - plus n less than or equal to alec buff
348:27 - plus alex size checks if there's enough
348:29 - room to satisfy a request for n
348:31 - characters if there is
348:33 - the new value of alec p
348:35 - would be at most one beyond the end of
348:38 - alec buff if the request can be
348:40 - satisfied
348:41 - alec returns a normal pointer notice the
348:44 - declaration of the function itself
348:46 - if not alec must return some kind of
348:49 - signal that there's no space left c
348:52 - guarantees that no pointer that validly
348:54 - points to data will ever contain a zero
348:56 - so a return value of zero can be used to
348:59 - signal an abnormal event
349:02 - in this case no space we write null
349:04 - instead of zero however to indicate more
349:07 - clearly that this is a special value for
349:09 - a pointer
349:11 - in general integers cannot be
349:13 - meaningfully assigned to pointers but
349:15 - zero is a special case
349:18 - tests like if open for n alec p plus n
349:22 - less than or equal to alec buff plus
349:24 - alex size and
349:26 - if open paren p greater than or equal to
349:29 - alec buff and p less than alec buff plus
349:32 - alex size shows several important facets
349:36 - of pointer arithmetic first
349:38 - pointers may be compared on certain
349:40 - circumstances
349:42 - if p and q point to members of the same
349:45 - array then relations like less than
349:47 - greater than equal etc work properly
349:52 - p greater than q is true for example if
349:56 - p points to an earlier member of the
349:58 - array than q
350:00 - the relations double equals and not
350:02 - equals exclamation equals also work
350:05 - any pointer can be meaningly compared
350:08 - for equality or inequality with null
350:12 - but all bets are off if you do
350:14 - arithmetic or compu comparisons with
350:16 - pointers that point to different arrays
350:19 - if you're lucky you get obvious nonsense
350:21 - on all machines
350:23 - if you're unlucky your code will work on
350:25 - one machine but collapse mysteriously on
350:27 - another
350:29 - second we've already observed that a
350:31 - pointer and an integer can be added or
350:33 - subtracted the construction p plus n
350:37 - means the nth object beyond the one p
350:40 - currently points to this is true
350:42 - regardless of the kind of object p is
350:44 - declared to point at the compiler scales
350:47 - n according to the size of the objects p
350:50 - points to
350:51 - which is determined by the declaration
350:53 - of p
350:54 - for example on the pdp 11 the factors
350:58 - are one for char
350:59 - two for int and short and four for long
351:02 - float and dub and float and eight for
351:04 - double
351:05 - pointer subtraction is also valid
351:08 - if p and q point to members of the same
351:11 - array
351:12 - p minus q is the number of elements
351:15 - between p and q
351:17 - this fact can be used to write yet
351:19 - another version of sterlin
351:23 - sterling open for n s close paren char
351:26 - star s semicolon open curly brace
351:30 - char star p
351:32 - equals s semicolon while star p not
351:35 - equal backslash
351:37 - a single quote backslash zero single
351:40 - quote close paren p plus plus semicolon
351:44 - return
351:45 - open print p minus s close paren
351:47 - semicolon close curly brace
351:51 - in its declaration p is initialized s
351:54 - that is to point to the first character
351:57 - in the while loop each character in turn
352:00 - is examined until backslash zero at the
352:02 - end is seen
352:03 - since backslash zero is zero and since
352:06 - while tests only whether the expression
352:08 - is zero it is possible to omit the
352:11 - explicit test and such loops are often
352:14 - written as
352:15 - while open paren star p close paren p
352:19 - plus plus semicolon
352:21 - because p points to characters p plus
352:24 - plus advances p up to the next character
352:26 - each time
352:28 - and p minus f's gives the number of
352:30 - characters advanced over that is the
352:32 - string length
352:33 - pointer arithmetic is consistent if we'd
352:36 - been dealing with floats which occupying
352:38 - more storage than chars and if p were a
352:40 - pointer to a float p plus plus would
352:42 - advance to the next float
352:44 - thus we could write another version of
352:46 - alec which maintains say floats instead
352:48 - of chars merely by changing char to
352:50 - float throughout alec and free
352:53 - all the pointer manipulations
352:55 - automatically take into the account the
352:57 - size of the object pointed to so nothing
353:00 - else has to be altered
353:02 - other than the operations mentioned here
353:04 - adding or subtracting a pointer in an
353:06 - integer subtracting or comparing two
353:08 - pointers
353:09 - all other pointer arithmetic is illegal
353:12 - it is not permitted to add two pointers
353:14 - or to multiply or divide or shift or
353:16 - mask them or add float or double to them
353:22 - section 5.5 character pointers and
353:25 - functions
353:27 - a string constant written as double
353:29 - quote i am a string double quote is an
353:32 - array of characters in the internal
353:34 - representation the compiler terminates
353:36 - the array with the character backslash
353:38 - zero so programs can find the end
353:40 - the length in storage is thus one more
353:43 - than the number of characters between
353:44 - the double quotes
353:46 - perhaps the most common occurrence of a
353:48 - string constant is arguments to
353:50 - functions as in printf open paren double
353:53 - quote hello comma world backslash n
353:56 - double quote
353:57 - when a character string appears like
353:59 - this in a program
354:00 - access to it is through a character
354:02 - pointer what printf receives is a
354:05 - pointer to the character array
354:08 - character arrays of course need not be
354:10 - function arguments if message is
354:12 - declared as char star message
354:16 - then the statement
354:17 - message equals double quote now is the
354:19 - time double quote semicolon assigns
354:22 - message to a pointer to the actual
354:24 - characters this is not a string copy
354:28 - only pointers are involved
354:30 - c does not provide any operators for
354:32 - processing an entire string of
354:34 - characters as a unit in the language
354:38 - we will illustrate more aspects of
354:40 - pointers and arrays by studying two
354:42 - useful functions from the standard i o
354:44 - library to be discussed in chapter 7.
354:47 - the first function is stir copy open
354:49 - paren s comma t which copies the string
354:52 - t to the string s
354:54 - the arguments are written in this order
354:56 - by analogy to assignment where one would
354:59 - say s equals t
355:01 - to assign t to s
355:02 - the array version is first
355:06 - stir copy open paren s comma t close
355:10 - paren char s open square bracket close
355:12 - square bracket comma t open square
355:15 - bracket close square bracket semicolon
355:17 - open curly brace
355:19 - int i semicolon
355:21 - i equals zero semicolon while open paren
355:25 - open for n s sub i
355:27 - equals t sub i
355:29 - close paren not equal quote backslash 0
355:32 - quote close parenthesis i plus plus
355:35 - semicolon
355:36 - close curly brace
355:40 - you'll note in that while statement that
355:41 - there is a
355:42 - copying of the actual characters as an
355:45 - assignment and then the side effect of
355:46 - the result of that assignment is
355:48 - compared to the new line at the end of
355:50 - string which terminates the while loop
355:54 - for contrast here is a version of stir
355:56 - copy with pointers and this is on page
355:59 - 100 of the textbook and you can see all
356:02 - the code in the textbook at www.cc4e
356:07 - code and again this is example number
356:09 - two on page 100.
356:12 - stir copy open paren s comma t close
356:15 - paren
356:17 - char
356:18 - star s comma star t semicolon open curly
356:21 - brace while open paren open paren star s
356:25 - equals star t
356:26 - close prin not equal single quote
356:29 - backslash zero single quote close print
356:31 - open curly brace
356:33 - s plus plus comma
356:35 - semicolon t plus plus semicolon close
356:38 - curly brace
356:39 - close curly brace to end the function
356:42 - because the arguments are passed by
356:44 - value stir copy can use s and t in any
356:48 - way it pleases here they are
356:50 - conveniently initialized pointers which
356:52 - are marched along the arrays a character
356:54 - at a time
356:55 - until the backslash terminates
356:58 - then t has been copied to s
357:01 - in practice their copy would not be
357:03 - written as we showed above
357:05 - a second possibility might be and this
357:07 - is the third example on page 100 of the
357:10 - textbook
357:11 - stir copy open vern s comma t close
357:14 - paren char star s comma star t semicolon
357:18 - open curly brace while
357:20 - paren paren star s plus plus
357:24 - equals star t plus plus close prin
357:28 - not equal quote backslash zero quote
357:32 - close paren
357:34 - semicolon curly brace
357:36 - this moves the increment and s and t
357:38 - into the test part the value of star t
357:41 - plus plus is the character that t
357:43 - pointed to before t was incremented
357:46 - the post fix plus plus doesn't change t
357:50 - until after this character has been
357:51 - fetched
357:52 - in the same way the character is stored
357:55 - in the old position of s before s is
357:57 - incremented
357:58 - the character is also the value that is
358:01 - compared against backslash zero to
358:03 - control the loop
358:04 - the net effect
358:06 - is that the characters are copied from t
358:09 - to s up to and including the terminating
358:12 - backslash zero
358:14 - as the final abbreviation
358:18 - of this solving this problem
358:21 - we can observe that the comparison
358:22 - against backslash zero is redundant so
358:24 - the function is often written as and now
358:26 - this is the first sample code on page
358:29 - 101
358:31 - of the textbook
358:33 - stir copy open paren s comma t close
358:36 - paren char star s comma star t semicolon
358:40 - open curly brace
358:42 - while open paren
358:44 - star s plus plus
358:47 - equals
358:48 - star t plus plus closed paren semicolon
358:52 - curly brace
358:55 - although this may seem cryptic at first
358:57 - the notational convenience is
358:59 - considerable and the idiom should be
359:01 - mastered
359:02 - if for no other reason then you will see
359:04 - it frequently in c programs
359:07 - the second routine
359:09 - is stir comp open for n s comma t
359:13 - which compares the character strings s
359:15 - and t
359:17 - and returns
359:19 - negative zero or positive according to
359:21 - as s is lexigraphically less than equal
359:24 - to or greater than t
359:26 - the value returned is obtained by
359:27 - subtracting the characters at the first
359:29 - position
359:31 - where s and t disagree
359:33 - this is the second example on page 101
359:37 - of the textbook
359:39 - which you can see at www.cc4e.com
359:43 - code
359:45 - stir comp open paren s comma t close
359:48 - parent
359:49 - char s open square bracket close square
359:52 - square bracket comma t open square
359:54 - bracket close square bracket semicolon
359:57 - open curly brace int i semicolon i
360:01 - equals zero semicolon
360:03 - while
360:04 - s sub i double equals t sub i
360:07 - close paren open print s sub i plus plus
360:11 - double equals single quote backslash
360:14 - zero single quote close paren return
360:16 - zero return open paren s sub i minus t
360:20 - sub i
360:21 - close paren semicolon close curly brace
360:25 - the pointer version of stir comb
360:27 - is the first example on page 102 of the
360:30 - textbook
360:31 - stir comp open paren s comma t close
360:34 - paren char star s comma star t
360:38 - open curly brace
360:40 - 4
360:41 - open paren
360:42 - semicolon
360:44 - star s double equals star t
360:47 - semicolon s plus plus comma t plus plus
360:51 - close paren
360:52 - if open for n star s equal equal single
360:56 - quote backslash zero single quote close
360:58 - paren
360:59 - return open print 0 close paren
361:02 - return open print star s minus star t
361:06 - close paren semicolon close curly brace
361:09 - since plus plus and minus minus are
361:11 - either prefix or postfix operators the
361:14 - combination of star and plus plus and
361:17 - minus minus occur although less
361:20 - frequently
361:21 - for example star
361:23 - plus plus p
361:26 - increments p before fetching the
361:28 - character that p points to
361:31 - star minus minus p decrements p first
361:36 - section 5.6 pointers are not integers
361:41 - you may notice in older c programs a
361:43 - rather cavalier attitude towards copying
361:46 - pointers
361:47 - it has generally been true that on most
361:49 - machines a pointer may be assigned to an
361:52 - integer and back again without changing
361:54 - it no scaling or conversion takes place
361:56 - and no bits are lost
361:58 - regrettably this has led to the taking
362:00 - of liberties with routines that return
362:02 - pointers which are then merely passed to
362:04 - other routines
362:06 - the requisite pointer declarations are
362:07 - often left out for example consider the
362:10 - function stir save open paren s close
362:13 - paren which copies the string s into a
362:15 - safe place obtained by a call to alec
362:18 - and returns a pointer to it properly
362:20 - this should be written as
362:22 - this is the first example on page 103 of
362:25 - the textbook you can see the sample code
362:27 - at www.ccfree.com
362:30 - code
362:32 - pound include stdlib.h
362:35 - char star serv stir save open print s
362:38 - close paren save a string somewhere
362:41 - char star s semicolon open curly brace
362:45 - char star p star alec open paren close
362:48 - paren semicolon if open paren open paren
362:52 - p equals alec open paren sterling open
362:55 - paren s close paren plus one close paren
362:58 - close print not equal null
363:00 - close paren stir copy open paren p comma
363:03 - s
363:04 - close
363:05 - paren semicolon return open paren p
363:09 - close paren semicolon curly brace
363:12 - in practice
363:13 - there would be a strong tendency
363:16 - mistaken tendency that is to emit
363:18 - declarations this is the example 2 on
363:22 - page 103
363:24 - pound include stdlib dot h
363:27 - stir save open paren s close paren
363:31 - open curly brace char star p semicolon
363:34 - if parentheses parentheses
363:37 - p equals alec
363:39 - open paren sterlin open paren s
363:42 - close print plus one close print close
363:45 - print not equal no close paren stir copy
363:47 - open paren p comma s
363:50 - close paren semicolon return open paren
363:52 - p close print semicolon
363:56 - this will work on many machines since
363:58 - the default type for functions and
364:00 - arguments is int
364:02 - an int and pointer can usually be safely
364:05 - assigned back and forth
364:06 - nonetheless
364:08 - this kind of code is inherently risky
364:10 - for it depends on the details of the
364:12 - implementation and machine architecture
364:15 - which may not hold for the particular
364:16 - compiler you use
364:18 - it is wiser to be complete in all
364:20 - declarations the program lind will warn
364:23 - of such constructions in case they creep
364:25 - in inadvertently
364:28 - section 5.7 multi-dimensional arrays
364:32 - in general
364:33 - rectangular multi-dimensional arrays are
364:35 - used in computational programs like a
364:37 - weather simulation
364:39 - and were
364:40 - a way
364:41 - back in the day to write c code that
364:43 - could accept fortran multi-dimensional
364:45 - arrays as parameters so that
364:46 - computational or statistical libraries
364:49 - can be written in c
364:51 - arrays of pointers are a better mapping
364:53 - to the typical operating system in
364:55 - string manipulation use cases that are
364:57 - more the core of c applications
365:00 - we also call these ragged arrays because
365:02 - each row can be a different length
365:04 - this also works well as data is
365:06 - dynamically allocated in c as compared
365:08 - to the more static allocation approach
365:11 - that's typical in fortran's
365:12 - multi-dimensional arrays
365:16 - now to the textbook
365:18 - c provides for rectangular
365:19 - multi-dimensional arrays although in
365:21 - practice they tend to be much less used
365:23 - than the arrays of pointers in this
365:25 - section we will show some of their
365:27 - properties
365:28 - consider the problem of date conversion
365:30 - from the day of the month to the day of
365:32 - the year and vice versa for example
365:35 - march 1st is the 60th day of a non-leap
365:38 - year and 60 first day of a leap year
365:41 - let us define two functions to do the
365:43 - conversions day of year converts month
365:45 - and day to the day of the year and month
365:48 - day converts the day of the year into
365:49 - the month and the day
365:51 - since this ladder function returns two
365:52 - values the month and day arguments will
365:54 - be pointers
365:56 - month day open parenthesis 1977 comma 60
366:01 - ampersand m comma ampersand d close
366:04 - parentheses
366:05 - sets m to three and d to one which is
366:08 - march first
366:11 - these functions both need the same
366:12 - information a table of the number of
366:14 - days in each month 30 days half
366:17 - september et cetera since the number of
366:19 - days per month differs for leap years
366:22 - and non-leap years it's easier to
366:24 - separate them into two rows of a
366:26 - two-dimensional array rather than try to
366:28 - keep track of what happens in february
366:30 - during computation
366:31 - the array and the functions performing
366:33 - the transformations are as follows
366:36 - this is example
366:38 - number one on page 104 of the textbook
366:41 - and you can see the code at www.cc4e.com
366:46 - code
366:50 - static int day tab
366:53 - open paren to close print open paren 13
366:57 - close print equals
366:59 - open curly brace
367:01 - open curly brace
367:02 - 0 comma 31 and then a number of numbers
367:06 - close curly brace comma open curly brace
367:09 - 0 comma 31 29 and then a bunch of
367:12 - numbers close curly brace close curly
367:15 - brace semicolon
367:18 - day of the year
367:20 - open paren year come a month come a day
367:23 - int year come a month comedy semicolon
367:25 - open curly brace
367:27 - int i comma leap semicolon
367:30 - leap
367:31 - equals 0 year modulo 4 double equals 0
367:36 - and
367:37 - year modulo 100 not equal 0 or year
367:41 - modulo 400 equals equals 0
367:44 - semicolon for open paren i equals one
367:48 - i less than month i plus plus close
367:51 - paren
367:52 - day plus equals day tab open square
367:55 - bracket leap close square bracket
367:58 - open square bracket i close square
368:00 - bracket semicolon
368:02 - return open paren day close paren
368:05 - semicolon close curly brace
368:08 - then the month day function
368:10 - month day open paren year come a year
368:13 - day come a p month come a p day close
368:15 - paren
368:17 - int
368:18 - year come a year day star p month comma
368:22 - star p day
368:23 - semicolon
368:24 - open curly brace int i come a leap
368:27 - semicolon
368:29 - leap equals year
368:31 - percent four double equals zero
368:34 - and year percent 100 not equal zero or
368:38 - year percent 1400
368:41 - double equals zero
368:43 - for i equals one year day greater than
368:46 - date tab open square bracket leap close
368:49 - square bracket open square bracket i
368:51 - close square bracket semicolon i plus
368:54 - plus close parenthesis your day minus
368:57 - equal day tab open square parenthesis
369:00 - open square bracket leap close square
369:02 - bracket open square bracket i close
369:04 - square bracket semicolon star p month
369:07 - equals i
369:09 - p day equals year day semicolon close
369:13 - paren
369:15 - the array day tab has to be external to
369:17 - both day of year and month day so they
369:19 - can both use it
369:21 - date tab is the first two dimensional
369:23 - array we've dealt with
369:25 - in c by definition a two-dimensional
369:27 - array is really a one-dimensional array
369:30 - each of which elements is also an array
369:33 - hence subscripts are written as day tab
369:36 - open square bracket i close square
369:38 - bracket open square bracket j close
369:40 - square bracket
369:42 - rather than
369:43 - day tab
369:44 - open square bracket i comma j close
369:46 - square bracket as in most languages
369:50 - other than this a two-dimensional array
369:52 - can be treated much the same in the same
369:54 - way as other languages elements are
369:56 - stored by rows that is the rightmost
369:58 - subscript varies fastest as elements are
370:02 - accessed in storage order
370:04 - an array is initialized by list of
370:06 - initializers and braces each row of a
370:09 - two-dimensional array is
370:11 - initialized by a corresponding sub-list
370:13 - we started the array day tab with a
370:15 - column of 0 so that month numbers can
370:18 - run from the natural 1 to 12 instead of
370:20 - 0 to 11. since space is not a premium
370:23 - here this is easier than adjusting
370:25 - indices
370:27 - if a 2 dimensional array is to be passed
370:28 - to a function
370:30 - the argument definition
370:32 - declaration in the function must include
370:34 - the column dimension the row dimension
370:36 - is irrelevant since what is passed in as
370:39 - before
370:40 - it is a pointer
370:41 - this is in this particular case it's a
370:43 - pointer to objects which are arrays of
370:45 - 13 ins thus the array day tab
370:49 - if it's to be passed to a function f the
370:51 - declaration would be
370:52 - f open friend date tab close paren int
370:56 - day tab
370:57 - open square bracket 2 close square
370:59 - bracket open square bracket 13 close
371:01 - square bracket semicolon
371:03 - open curly brace dot dot dot close curly
371:06 - brace
371:07 - the argument declaration in f could also
371:10 - be int date tab
371:12 - open square bracket close square bracket
371:14 - open square bracket 13 closed square
371:16 - bracket semicolon
371:18 - since the number of rows is actually
371:20 - irrelevant
371:21 - it could also be seen as
371:23 - int open print star day tab close print
371:27 - open bracket 13 closed bracket
371:31 - semicolon which says that the argument
371:33 - is a pointer
371:34 - to an array of 13 integers
371:36 - the parentheses are necessary since the
371:38 - brackets have higher precedence than
371:40 - asterisk without parentheses the
371:43 - declaration int star day tab sub 13
371:48 - close square bracket
371:50 - semicolon is an array of 13 pointers to
371:52 - integers as we shall see
371:54 - in the next section
371:56 - section 5.8 pointer arrays pointers to
371:59 - pointers
372:01 - since pointers are variables themselves
372:03 - you might expect that there would be
372:05 - uses for arrays of pointers
372:08 - this is indeed the case let us
372:10 - illustrate by writing a program that
372:12 - will sort
372:13 - a set of text lines into alphabetic
372:15 - order than a stripped-down version of
372:18 - the unix utility sort
372:20 - in chapter three we presented a shell
372:22 - sort function that would sort an array
372:24 - of integers this same algorithm will
372:27 - work except that now we have to deal
372:29 - with lines of text which are of
372:30 - different lengths and which unlike
372:32 - integers can't be compared or moved in a
372:34 - single operation
372:36 - we will need a data representation data
372:39 - structure that will cope efficiently and
372:41 - conveniently with variable length text
372:43 - lines
372:44 - this is where an
372:46 - array of pointers enters
372:48 - if the lines to be sorted are stored and
372:51 - in one long character array maintained
372:52 - by alec perhaps then each line can be
372:55 - accessed by a pointer to its first
372:57 - character
372:58 - the pointers themselves can be stored in
373:00 - an array
373:02 - two lines can be
373:03 - compared by passing their pointers to
373:05 - stir comp
373:07 - when two out of order lines have to be
373:09 - swapped or exchanged the pointers in the
373:12 - pointer array are exchanged not the text
373:14 - lines themselves
373:15 - this eliminates the twin problems of
373:17 - complex storage management and high
373:20 - overhead that would go with moving the
373:22 - text of the actual lines
373:24 - the sorting process involves three steps
373:27 - read all the lines of input
373:29 - sort them and then print them in order
373:32 - as usual it's best to divide the program
373:35 - into functions that match this natural
373:36 - division with the main routine
373:38 - controlling things
373:40 - let us defer the sorting step for a
373:42 - moment and concentrate on the data
373:43 - structures and the input in output
373:46 - the input routine has to collect and
373:47 - save the characters in each line and
373:49 - build an array of pointers to the lines
373:51 - it will also have to count the number of
373:53 - input lines since that information is
373:55 - also needed for sorting and printing
373:57 - since the input function can only cope
373:59 - with a finite number of input lines it
374:01 - can return some illegal line count like
374:03 - negative 1 if too much input is
374:05 - presented the output routine only has to
374:08 - print the lines in order in the order in
374:10 - which they appear in the array of
374:12 - pointers
374:14 - this next code segment
374:16 - is actually a combination of three
374:18 - successive sample code segments uh
374:21 - starting on page 106 of the textbook and
374:23 - it's pretty complex
374:25 - so you might be best it might be best
374:28 - for you to see them on www.cc4e.com
374:32 - slash code line 106 example one
374:36 - okay
374:38 - pound include stdio.h pound includes
374:41 - string.h pound define lines 100. the
374:45 - maximum lines of support
374:46 - to be sorted
374:48 - main open paren close paren
374:50 - char
374:51 - line ptr
374:53 - open brick ombud square bracket lines
374:55 - close square bracket semicolon int n
374:57 - lines which is the number of lines read
375:01 - if
375:02 - open paren open paren n lines equals
375:04 - read lines open paren line ptr comma
375:07 - lines close praying close paren greater
375:09 - than or equal to zero
375:11 - close paren open curly brace sort open
375:14 - paren line ptr comma n lines close paren
375:18 - write lines open print line ptr comma n
375:20 - lines close paren semicolon
375:23 - close curly brace else
375:25 - print f
375:26 - open paren double quote input too big to
375:29 - sort
375:30 - backslash n
375:32 - close double quote
375:34 - close paren semicolon and close curly
375:36 - brace to end the main program
375:39 - this next routine is actually from page
375:41 - 107 of the textbook but we combined them
375:44 - into one
375:45 - pound defined maxland1000
375:48 - readlines openpren line ptr comma max
375:52 - lines close paren
375:54 - char star line ptr open square bracket
375:57 - close for a square bracket semicolon
375:59 - this is an array of pointers to
376:01 - characters
376:03 - an array of pointers pointers being you
376:05 - know long like four bytes characters
376:07 - being generally one byte int max line
376:10 - semicolon open curly brace
376:13 - int
376:14 - len comma n lines
376:16 - semicolon char star p
376:19 - star alec open print close paren comma
376:21 - line
376:22 - open square bracket max lane close
376:24 - square bracket semicolon
376:28 - so
376:28 - just to recall alec is a function we do
376:31 - we did later i mean did earlier that
376:33 - allows us to allocate uh
376:36 - some text of a
376:38 - varying length and then lines so maxlen
376:40 - is a place that we're going to
376:42 - read each line into
376:45 - beginning the code of read lines
376:47 - n lines equals zero while open paren
376:50 - open paren
376:51 - len equals get line open paren line
376:54 - comma max len close paren close friend
376:56 - greater than or equal to zero close
376:58 - paren
376:59 - if
377:01 - open print n lines greater than equal to
377:03 - max lines close paren return open paren
377:05 - minus one close paren semicolon
377:08 - else if
377:10 - open print open paren p equals alec open
377:13 - paren len close paren close paren
377:16 - double equals null
377:17 - close paren return minus one
377:20 - so those two tests basically make sure
377:22 - that we
377:23 - don't get too many lines and that we
377:26 - have enough space in our
377:28 - al dynamic data area that alec is
377:31 - managing for us
377:33 - so continuing with the if we're at the
377:35 - else opens curly brace line sub len
377:39 - minus one
377:41 - equals
377:42 - quote backslash zero quote semicolon
377:45 - stir copy
377:47 - p
377:48 - comma line
377:49 - close paren semicolon
377:52 - line ptr sub n lines plus plus equals p
377:56 - semicolon
377:57 - close curly brace that finishes the else
378:00 - segment return n lines semicolon and
378:04 - close curly brace
378:05 - to finish the read lines function
378:08 - now
378:09 - at a high level we're reading a line
378:13 - into a
378:14 - allocated automatic variable line
378:17 - and then we are
378:19 - calling alec to get another
378:22 - cop place to copy that line then we're
378:24 - making a copy of that line
378:26 - and then we are remembering the pointer
378:28 - to the beginning of that line in line
378:30 - ptr and that's the
378:31 - essence of it
378:34 - okay
378:39 - write lines open paren line ptr comma n
378:42 - lines close paren char star line ptr
378:46 - open square bracket close square bracket
378:47 - semicolon
378:49 - again
378:50 - an array of pointer characters
378:53 - int n lines semicolon
378:55 - which is the number of character
378:57 - pointers in line ptr open curly brace
379:00 - int i semicolon
379:02 - four paren i equals zero semicolon i
379:05 - less than n lines semicolon i plus plus
379:08 - close paren printf open paren
379:11 - double quote percent s backslash n
379:13 - double quote comma line ptr sub i close
379:17 - paren semicolon close curly brace a
379:20 - simple loop that goes through the array
379:22 - of character pointers and then prints
379:24 - each one out using printf
379:27 - the main new thing is the declaration
379:30 - for
379:32 - line ptr char starline ptr sub
379:36 - open square bracket lines close square
379:38 - bracket semicolon says that line ptr is
379:41 - an array of lines elements each element
379:44 - of which is a pointer to a char
379:46 - that is line ptr sub i is a character
379:50 - pointer and star line pr ptr sub i
379:54 - accesses a character
379:57 - since line ptr itself is an array that
380:00 - was passed to right lines it can be
380:02 - treated as a pointer exactly in the same
380:04 - manner as our earlier examples and the
380:06 - function can be written instead as
380:08 - right lines open paren line ptr comma n
380:12 - lines close paren
380:14 - char starline ptr open square bracket
380:16 - close square bracket semicolon int and
380:19 - line semicolon open curly brace
380:22 - while open paren minus minus n lines
380:25 - greater than or equal to zero close
380:27 - paren
380:28 - printf
380:29 - open paren double quote percent s
380:32 - backslash n double quote comma star line
380:35 - ptr plus plus close paren semicolon
380:39 - that code by the way was on page 108
380:42 - example one
380:44 - of the textbook
380:47 - starline ptr points initially to the
380:49 - first line but each increment of
380:53 - line ptr advances it to the next line
380:56 - while n lines is counted down
380:59 - with input and output under control
381:02 - we can proceed to sorting
381:04 - the shell sort from chapter 3 needs
381:06 - minor changes
381:08 - the declarations have to be modified and
381:10 - the comparison operation must be moved
381:13 - into a function but the basic algorithm
381:15 - remains the same which gives us some
381:17 - confidence that it will still work
381:19 - and this is the second example on page
381:22 - 108 of the textbook and you can see this
381:24 - example at www.cc4e.com
381:29 - code
381:31 - start sort open paren v comma n close
381:34 - paren
381:36 - char star v open square bracket close
381:38 - square bracket semicolon
381:41 - and and semicolon open curly brace
381:44 - so we're getting an array of pointers to
381:46 - the beginnings of lines
381:48 - and how many of those pointers matter
381:51 - and the rest of it is shell sort
381:54 - with the stir comp being used
381:57 - to do the string comparison so it's a
382:00 - three nested for loop
382:02 - with a simple if test in it
382:05 - so here we go
382:07 - open curly brace for the sort function
382:09 - int gap comma i comma j semicolon char
382:12 - star
382:14 - semicolon and that's a pointer to a
382:16 - character
382:17 - four open paren gap equals n over two
382:20 - slash i mean semicolon
382:23 - gap greater than zero semicolon gap
382:25 - slash equals two close parenthesis 4
382:29 - i equals gap semicolon i less than n
382:32 - semicolon i plus plus close parenthesis
382:36 - for open paren j equals i minus gap
382:39 - semicolon j greater than or equal to
382:41 - zero semicolon
382:43 - j minus equals gap close paren open
382:46 - curly brace
382:48 - so that's sort of the shell part of the
382:50 - shell sort and now we have to do our
382:52 - comparison if
382:54 - open paren stir comp open print
382:59 - v sub j comma v sub j plus gap
383:03 - close paren less than or equal to zero
383:06 - close paren break and note that that's
383:09 - only breaking the
383:11 - third deep for loop which it just goes
383:13 - and then runs the next iteration of the
383:15 - second for loop
383:17 - now we do the swapping
383:18 - temp equals b sub j semicolon v sub j
383:22 - equals a v sub j plus gap semicolon
383:25 - v sub j plus gap equals temp now that's
383:28 - just swapping
383:30 - pointer values so the the strings that
383:32 - are pointed to by these two pointers v
383:34 - sub j and v sub j plus gap
383:37 - if they're out of order we're going to
383:39 - swap
383:40 - the pointers in the array and move them
383:42 - so that
383:43 - if you then go through like we did in
383:45 - write lines earlier
383:46 - then um they come out in order but we
383:49 - literally read the data once
383:52 - we copy it once into the its final
383:55 - destination using alec alec and stir
383:57 - copy but once we sort it which is the
384:00 - most complex part of the calculation
384:03 - we're only moving the pointers back and
384:04 - forth so the sort is very efficient and
384:07 - requires no extra
384:09 - memory than what we had before the sort
384:12 - so that's really nice and it sorts in
384:13 - place
384:16 - so back to the text since any individual
384:19 - element of v
384:20 - which is an alias to line pointer ptr
384:23 - is a character pointer temp could also
384:26 - should also be one so one can be copied
384:28 - to the other
384:29 - we wrote the program about as
384:30 - straightforwardly as possible so as to
384:32 - get it working quickly it might be
384:34 - faster for instance to copy the incoming
384:36 - lines directly into an array made by
384:39 - read lines rather than copying them into
384:40 - line and then to a hidden place
384:42 - maintained by alec but it's wiser to
384:45 - make the first draft of something easy
384:47 - to understand
384:48 - and worry about efficiency later
384:51 - the way to make this program
384:52 - significantly faster is probably not by
384:55 - avoiding an unnecessary copy of the
384:57 - input lines
384:58 - just instead replacing the shell store
385:01 - sort by something quicker and better
385:03 - like quick sort is much more likely to
385:05 - make a real difference that matters
385:08 - in chapter one we pointed out that
385:10 - because while in for loops test the
385:11 - termination condition before executing
385:13 - the loop body even once they help to
385:16 - ensure that the programs will work at
385:17 - their boundaries in particular with no
385:20 - input
385:21 - it's illuminating to walk through the
385:23 - functions of the sorting program
385:25 - checking what happens if there is no
385:28 - input text at all
385:30 - section 5.9 initialization of pointer
385:34 - arrays
385:35 - consider the problem of writing a
385:37 - function month name open paren and close
385:40 - paren which returns a pointer to a
385:42 - character string containing the name of
385:43 - the mf month
385:45 - this is an ideal application for an
385:47 - internal static array
385:49 - month name contains a private array of
385:51 - character strings and returns a pointer
385:52 - to the proper one when called the topic
385:55 - of this section is how
385:57 - that array of names is initialized
386:00 - the syntax is quite similar to the
386:02 - previous initializations this is sample
386:05 - code from page 109 of the textbook which
386:07 - you can see
386:08 - at
386:10 - www.cc4e.com code
386:13 - char
386:14 - star month name open paren close print
386:18 - so the return value for this function is
386:19 - a character pointer
386:21 - int
386:22 - n semicolon open curly brace static char
386:27 - star name open square bracket close
386:29 - square bracket equals open curly brace
386:32 - quote
386:33 - illegal month quote
386:35 - comma
386:36 - double quote january double quote comma
386:39 - double quote february double quote comma
386:42 - and so forth down to double quote
386:44 - december double quote
386:46 - close curly brace semicolon
386:49 - the body of the
386:51 - function is one line return open paren
386:54 - open paren n less than 1 or n greater
386:57 - than 12 close paren question mark
387:00 - name sub 0
387:01 - colon
387:02 - name sub n
387:04 - close paren semicolon close curly brace
387:08 - the declaration of name which is an
387:10 - array of character pointers is the same
387:12 - as line ptr in the sorting example
387:15 - the initializer is simply a list of
387:17 - character strings
387:18 - each assigned
387:20 - to the corresponding position in the
387:22 - array more precisely the characters of
387:25 - the i string are placed somewhere else
387:27 - and a pointer to them
387:29 - is stored in name sub i
387:31 - since the name size of the array name is
387:34 - not specified the compiler itself counts
387:36 - the initializers and fills in the
387:38 - correct number
387:40 - section 5.10 pointers versus
387:43 - multi-dimensional arrays
387:46 - newcomers to see are sometimes confused
387:48 - about the difference between a
387:50 - two-dimensional array and an array of
387:52 - pointers such as name in the example
387:54 - above
387:55 - given the declarations int
387:58 - a open square bracket 10 close square
388:01 - bracket open square bracket 10 close
388:03 - square bracket semicolon and int star b
388:06 - open square bracket 10 close square
388:09 - bracket semicolon
388:11 - the usage of a and b may be similar
388:14 - in that a sub 5 5 and b sub 5 5 are both
388:18 - legal references to a single integer
388:21 - but a is a true array all 100 storage
388:24 - cells have been allocated and the
388:26 - conventional rectangular substrip
388:28 - calculation is done to find any given
388:30 - element for b however the declaration
388:33 - only allocates 10 pointers
388:36 - each must be set to point to an array of
388:38 - integers
388:39 - assuming that each does point to a 10
388:42 - element array
388:43 - then there will be 100 storage cells set
388:46 - aside plus the 10 cells for the pointers
388:49 - thus the array of pointers uses slightly
388:52 - more space and may require an explicit
388:54 - initialization step but it has two
388:57 - advantages
388:58 - accessing an element is done by
389:00 - indirection through a pointer rather
389:01 - than by a multiplication and an addition
389:04 - and the rows of the array may be of
389:05 - different lengths that is each element
389:08 - of b need not point to a 10 element
389:11 - vector some may point to two elements
389:13 - others may point to 20 and some to none
389:15 - at all
389:16 - although we have phrased this discussion
389:18 - in terms of integers by far the most
389:20 - frequent use of arrays of pointers is
389:22 - like that shown in month name to store
389:25 - character strings of a diverse lengths
389:28 - section
389:29 - 5.11
389:31 - command line arguments
389:33 - in environments that support c there is
389:36 - a way to pass command line arguments or
389:38 - parameters to a program when it begins
389:40 - executing
389:41 - when main is called to begin execution
389:43 - it is called with two arguments
389:46 - the first conventionally called arg c is
389:48 - the number of command line arguments the
389:50 - program was invoked with the second arg
389:53 - v is a pointer to an array of character
389:55 - strings that contain the arguments one
389:57 - per string
389:59 - manipulating these character strings is
390:01 - a common use of multiple levels of
390:03 - pointers
390:05 - i would note that back in 1978 the two
390:08 - largest bodies of c code were likely the
390:10 - at t unix kernel itself and unix
390:12 - utilities like grep
390:14 - ls or the login shell
390:16 - so writing an operating system was fresh
390:18 - on the mind of the authors while writing
390:20 - this book
390:21 - these topics find their way into the
390:23 - text of this book
390:25 - in a sense a likely second order goal of
390:28 - the book was to train programmers that
390:29 - might learn c
390:30 - and then might help build and maintain
390:32 - unix
390:33 - the 1978 edition of this textbook fits
390:36 - nicely into a series of att bell labs
390:39 - technic reports like the portability of
390:42 - c programs in the unix system written by
390:44 - stephen c johnson and dennis m ritchie
390:46 - published in the bell system technical
390:48 - journal volume 57 number six part two
390:52 - july through august 1978 pages
390:55 - 2021 through 2048.
390:58 - you can see this one online if you
391:00 - search for it
391:03 - back to the
391:04 - textbook the simplest illustration of
391:07 - the necessary declarations
391:09 - and use is in the program echo which
391:12 - simply echoes its command line arguments
391:14 - in a single line separated by blanks
391:17 - that is if the command echo hello comma
391:20 - world is given the output is hello comma
391:23 - world
391:24 - by convention arg v sub 0 is the name by
391:28 - which the program was invoked so argc is
391:30 - at least 1.
391:31 - in the above example argc is three and
391:34 - args arc v sub zero arc v sub one and
391:37 - args v sub two are echo
391:41 - hello comma and world respectively
391:45 - the first real argument is arc v sub 1
391:47 - and the last is
391:48 - arg v
391:50 - sub rxc minus 1
391:52 - and if argc is 1 there are no command
391:55 - line arguments after the program name
391:58 - this is shown in the source code to echo
392:00 - and this source code is on page 111 of
392:02 - the textbook and you can see this source
392:04 - code at www.cc4e.com
392:08 - code
392:10 - pound include stdio.h
392:13 - pound includes string.h
392:15 - main open paren argc comma arc fee close
392:18 - paren int argc semicolon char star argv
392:23 - open square bracket close square bracket
392:24 - semicolon
392:26 - open curly brace int i semicolon
392:29 - for open paren i equals one semicolon i
392:33 - less than rxc semicolon i plus plus
392:37 - close paren
392:39 - print f open paren
392:41 - double quote percent s percent c
392:45 - double quote comma
392:47 - arg v sub i
392:50 - comma
392:51 - open paren i less than r c minus one
392:54 - close paren question mark
392:56 - single quote space single quote colon
392:58 - single quotes
393:00 - backslash n single quote close
393:02 - parenthesis
393:03 - semicolon close curly brace to end it
393:07 - since argv is a pointer to an array of
393:10 - pointers there are several ways to write
393:12 - this program that involve manipulating
393:14 - the pointer rather than indexing an
393:16 - array
393:17 - let us show two variations and this is
393:19 - the example
393:20 - number two on page 111 of the textbook
393:24 - pawn include stdio.h pawn includes
393:27 - string.h
393:29 - main open paren rxc comma argv close
393:32 - paren
393:33 - int argc semicolon char star argv open
393:37 - square bracket close square bracket
393:39 - semicolon
393:40 - open curly brace
393:42 - while open paren minus minus arg c
393:45 - greater than zero close paren printf
393:48 - open paren double quote percent s
393:50 - percent c
393:51 - double quote comma star
393:55 - plus plus arg v comma open paren rxc
393:59 - greater than one close paren question
394:00 - mark single quote space single quote
394:03 - colon single quote backslash n single
394:06 - quote close paren semicolon
394:08 - close curly brace
394:10 - since
394:11 - arc v is a pointer to the beginning of
394:13 - an array of argument strings
394:15 - incrementing it by one plus plus rv
394:18 - makes it point to the at the original
394:21 - array arc v sub one instead of arc b sub
394:24 - zero
394:25 - each successive increment moves it along
394:27 - to the next argument
394:29 - star arc v is then the pointer to that
394:31 - argument
394:32 - at the same time argc is decremented and
394:35 - when it becomes zero there are no
394:37 - arguments left to print
394:40 - another version the third version on
394:43 - page 111 of the textbook
394:46 - pound include stdio.h pound includes
394:49 - string.h main open paren arg c com argv
394:53 - close paren
394:55 - int argc semicolon char star arc v open
394:59 - square bracket close square bracket
395:00 - semicolon open curly brace while
395:04 - open paren minus minus arg c greater
395:06 - than zero close paren
395:09 - print f open paren open paren argc
395:12 - greater than one close paren question
395:14 - mark double quote percent s blank double
395:17 - quote colon
395:19 - double quote percent s backslash n
395:22 - double quote comma
395:23 - star plus plus arg v close paren
395:26 - semicolon close curly brace
395:29 - this
395:30 - version so shows that the format
395:32 - argument of printf can be an expression
395:34 - just like any of the others this usage
395:37 - is not very frequent but worth
395:38 - remembering
395:40 - as a second example
395:43 - let's make some example enhancements to
395:45 - the pattern finding program from chapter
395:47 - 4.
395:48 - if you recall we wired the search
395:50 - pattern deep into the program
395:52 - and this is an obviously unsatisfactory
395:54 - arrangement for flexible code following
395:57 - the lead of the unix utility grep which
396:00 - stands for the generalized regular
396:02 - expression parser
396:04 - let us change the program so that the
396:06 - pattern to be matched is specified by
396:07 - the first argument on the command line
396:11 - this is example one on page 112 of the
396:13 - book which you can see at www.cc4e.com
396:18 - code
396:20 - pound include sddio.h
396:22 - pound includes string.h upon define max
396:25 - line 1000
396:27 - main open paren arg c comma arg v close
396:30 - paren int r c semicolon char star arc v
396:33 - open square bracket close square bracket
396:35 - semicolon open curly brace
396:37 - char line open open square bracket max
396:41 - line close square bracket semicolon
396:44 - if open paren argc not equal to close
396:47 - paren printf
396:48 - double quote usage colon find pattern
396:51 - backslash n
396:53 - double quote close paren semicolon else
396:56 - while open pren getline open print line
397:00 - comma max line close paren greater than
397:02 - zero close paren
397:03 - if
397:04 - index open paren line comma arg v
397:07 - sub 1 close paren greater than or equal
397:10 - to 0 close paren printf
397:13 - open paren double quote percent s double
397:16 - quote comma line close paren semicolon
397:19 - close curly brace
397:22 - the basic model can now be elaborated to
397:24 - illustrate further pointer constructions
397:26 - suppose we want to allow two optional
397:29 - arguments
397:30 - one says print all the lines except
397:33 - those that match the pattern
397:34 - the second says precede its print each
397:37 - printed line with its line number
397:40 - a common convention for c programs is
397:43 - that an argument beginning with a minus
397:45 - sign introduces an optional flag or
397:47 - parameter
397:48 - if we choose minus x for accept to
397:52 - signal the inversion and minus n number
397:55 - to request line numbering then the
397:57 - command find space minus x space minus n
398:01 - the with the input now is the time for
398:04 - all good men to come to the aid of their
398:07 - party should produce
398:09 - two comma for all good men
398:15 - optional arguments should be permitted
398:16 - in any order and the rest of the program
398:18 - should be insensitive to the number of
398:20 - arguments which were actually present
398:22 - in particular the call to index should
398:24 - not refer to arg v sub 2 where a single
398:27 - flag argument and to arc v sub 1 when
398:30 - there was no single flag furthermore
398:32 - it's convenient for users if option
398:35 - arguments can be concatenated and as in
398:38 - find space dash nx space the
398:43 - here is the program
398:46 - and this program is on
398:48 - page 113 of the textbook
398:51 - and it is complex enough that i suggest
398:53 - that you take a look at it at
398:55 - www.cc4e.com
398:59 - code
399:01 - it's it's about 35 lines long
399:05 - the commentary on the program hopefully
399:07 - now you're watching looking at it arc v
399:10 - is incremented before each optional
399:11 - argument and argc is decremented if
399:14 - there are no errors at the end of the
399:16 - loop arg c should be 1 and star argv
399:18 - should point to the
399:20 - point to the pattern
399:21 - note that
399:23 - star plus plus arc v is a pointer to an
399:26 - argument string
399:27 - open paren star plus plus arc v close
399:30 - paren
399:31 - open square bracket zero square square
399:33 - bracket
399:34 - is its first character the parentheses
399:37 - are necessary for without them the
399:39 - expression would be star plus plus open
399:41 - paren arg v sub subzero
399:44 - close paren which is quite different and
399:47 - wrong
399:48 - an alternate valid form would be star
399:51 - star
399:52 - plus plus arg v
399:55 - section 5.12 pointers to functions in c
399:59 - a function itself is not a variable but
400:01 - it is possible to define a pointer to a
400:03 - function which can be manipulated passed
400:06 - to functions placed in arrays and so on
400:09 - we will illustrate this by modifying the
400:11 - sorting procedure written earlier in
400:13 - this chapter so that if the optional
400:15 - argument minus n is given it will sort
400:18 - the input lines numerically instead of
400:20 - lexographically
400:21 - a sort often consists of three parts a
400:24 - comparison
400:25 - which determines the ordering of any
400:27 - pair of objects
400:29 - an exchange which reverses their order
400:31 - and a sorting algorithm which makes
400:33 - comparisons and exchanges until the
400:35 - objects are in order
400:37 - the sorting algorithm is independent of
400:39 - the comparison and exchange operations
400:42 - so by passing different comparison and
400:44 - exchange functions to it we can arrange
400:45 - to sort by different criteria this
400:48 - approach is taken in our new sort
400:51 - the lexigraphic comparison of the two
400:53 - lines is done by stir comp and swapping
400:55 - by swap as before
400:57 - we'll also need a routine num comp which
401:00 - compares two lines on the basis of
401:01 - numeric value and returns the same kind
401:04 - of condition indication as stir comp
401:05 - does
401:06 - these three functions are declared in
401:08 - main and pointers to them are passed to
401:10 - sort
401:11 - sort in turn calls the functions via
401:13 - pointers we have skimped on error
401:15 - processing processing for arguments so
401:17 - as to concentrate on the main issues
401:21 - this sample code is from page 115 of the
401:23 - textbook which you can view at
401:25 - www.cc4e.com
401:30 - code
401:32 - pound include stdio.h
401:34 - pawn include string.h pawn defined lines
401:37 - 100
401:38 - main open paren rxc comma arg v close
401:42 - current
401:43 - int argc semicolon
401:45 - char star arg fee open square bracket
401:48 - close square bracket semicolon open
401:50 - curly brace
401:52 - char star line ptr open for open bracket
401:57 - lines close square bracket semicolon
401:59 - this is the pointers to the text lines
402:01 - so we're going to be reading
402:03 - in the lines saving them and keeping an
402:05 - array of the pointer and then we're
402:06 - going to sort that way
402:08 - int n lines semicolon
402:10 - int stir comp open paren close print
402:13 - comma num comp
402:14 - open paren close paren which are
402:16 - comparison functions
402:19 - and swap open paren close print
402:21 - semicolon int numeric equals zero and
402:24 - this is going to be one if it's a
402:25 - numeric sort
402:27 - first we parse the arguments
402:30 - if open paren arg c greater than one
402:32 - ampersand ampersand arg v sub one sub
402:35 - zero equal equal
402:37 - quote minus quote
402:39 - and arg v opens bracket one close
402:42 - bracket open bracket one close bracket
402:45 - double equals quote end quote close
402:48 - paren numeric equals one
402:53 - if open paren open paren n lines equals
402:56 - read lines open paren line ptr comma
402:58 - lines close paren close paren greater
403:00 - than or equal to zero close paren open
403:03 - curly brace
403:05 - if open paren numeric close paren sort
403:08 - open print line ptr n lines num comp
403:11 - comma swap close paren semicolon else
403:15 - sort open print line ptr
403:17 - comma n lines
403:19 - comma stir comp comma swap close paren
403:22 - write lines line pr ptr comma n lines
403:25 - close paren
403:27 - close curly brace else print f open
403:30 - paren double quote input too big to sort
403:33 - backslash n
403:35 - double quote close paren semicolon
403:39 - stir comp num comp and swap are
403:42 - addresses of functions
403:43 - since they're known to be functions the
403:45 - ampersand operator is not necessary in
403:48 - the same way that it is not needed
403:50 - before an array name
403:51 - the compiler arranges for the address of
403:54 - the function to be passed
403:56 - the second step is to modify our sort
403:58 - function
404:00 - and this is the first example on page
404:02 - 116 of the textbook
404:05 - sort open paren v comma n comma comp
404:09 - comma e x c h exchange
404:12 - close paren
404:14 - char
404:15 - star v open square bracket close work
404:18 - square bracket
404:19 - semicolon that's our pointer
404:23 - array of pointers
404:24 - int
404:25 - and semicolon
404:28 - int open friends start comp
404:31 - close paren open print close paren comma
404:34 - open paren star exchange
404:36 - close paren open prayer and close paren
404:38 - semicolon that declared the
404:41 - type and the fact that these are
404:42 - pointers to functions it's a little more
404:44 - complex here in the called code
404:49 - open curly brace int gap comma i comma j
404:52 - semicolon
404:54 - and now we're going to do the three
404:56 - nested for loops for the
404:58 - quick sort no shell sort
405:01 - um
405:02 - and then the only really change is in
405:04 - the code checking to see if the
405:07 - uh two items pair of items are out of
405:09 - order and then what we do so
405:11 - four open paren gap equals n over two
405:14 - semicolon cap greater than zero
405:16 - semicolon graph gap slash equals two
405:19 - close paren
405:21 - for open print i equals gap semicolon i
405:24 - less than n semicolon i plus plus closed
405:26 - paren
405:28 - four open paren j equals i minus gap
405:31 - semicolon j greater than or equal to
405:33 - zero semicolon j minus equals gap close
405:36 - paren open curly brace and now here
405:39 - starts the different code
405:41 - if open print open print star comp
405:44 - close print
405:46 - open paren v sub j comma v sub j plus
405:49 - gap
405:50 - close paren less than or equal to zero
405:54 - close paren break
405:57 - open print star ex exchange
406:00 - close prin open print ampersand v sub j
406:04 - comma ampersand v sub j plus gap
406:09 - close paren semicolon close curly brace
406:12 - for the for loop and then close curly
406:14 - brace
406:15 - for the sort function
406:17 - and so really all we're doing is we're
406:19 - checking the order of the two items b
406:22 - sub j and b sub j plus gap
406:24 - and if they're out of order i.e less
406:26 - than or equal to zero i mean greater
406:28 - than or equal to uh greater than zero
406:31 - then we just exchange them with the
406:33 - provided exchange function and so the
406:34 - key thing here is it looks exactly like
406:36 - the previous time we wrote this code
406:38 - except we're calling
406:39 - the pointer to the comparison function
406:41 - and the pointer to the exchange function
406:44 - which
406:45 - is makes this flexible
406:47 - so it can handle different kinds of data
406:51 - back to the textbook
406:54 - the declaration should be studied with
406:55 - some care
406:57 - int open paren star comp close paren
407:00 - open paren close paren says that comp
407:03 - is a pointer to a function that returns
407:06 - an int
407:07 - the first set of parentheses are
407:09 - necessary without them int star comp
407:12 - open prank close paren
407:14 - would say that comp is a function
407:16 - returning a pointer to an end which is a
407:18 - quite different thing
407:20 - the use of comp in the line if open
407:23 - paren open paren star com close paren
407:26 - open print v
407:27 - sub j comma v sub j plus gap close print
407:31 - less than or equal to zero close paren
407:34 - is consistent with the declaration
407:36 - comp is a pointer to the function and
407:38 - star comp is the function
407:41 - and
407:42 - open paren star comp close paren
407:45 - open paren v sub j comma v sub j plus
407:48 - gap close
407:49 - paren is the call to it the parentheses
407:52 - are needed so the components are
407:54 - correctly associated
407:56 - we've only we've already shown stir comp
407:59 - which compares two strings
408:00 - here is num comp which compares two
408:03 - strings on a leading numeric value
408:06 - this is sample code from page 117 of the
408:08 - textbook
408:09 - which you can
408:11 - see at www.cc4e.com
408:15 - code
408:16 - numcomp open paren s1 comma s2 close
408:20 - paren char star s1 comma star s2
408:23 - semicolon
408:25 - open curly brace double a to f open
408:28 - frame close paren comma v1 comma v2
408:32 - v1 equals a to f open paren s1 close
408:35 - paren
408:36 - semicolon v2 equals a to f open print s2
408:40 - close paren semicolon if
408:43 - open paren v1 less than v2 close print
408:46 - return open print -1
408:48 - else if open print v1 greater than v2
408:52 - close paren return open print 1 close
408:55 - paren semicolon else
408:57 - return open paren
409:00 - 0 close paren semicolon close curly
409:02 - price
409:05 - the final step is to add the function
409:07 - swap which exchanges the two pointers
409:09 - this is adapted directly from what we
409:11 - presented earlier in the chapter
409:14 - swap open paren px comma py close paren
409:18 - char star px
409:20 - open square bracket close square bracket
409:22 - comma star py open square bracket close
409:25 - square bracket semicolon
409:27 - open curly brace char star temp
409:30 - semicolon
409:31 - temp equals star px semicolon star px
409:34 - equals star py semicolon star py equals
409:38 - temp semicolon close curly brace
409:41 - there are a variety of other options
409:43 - that can be added to the sorting program
409:46 - some make challenging exercises
409:48 - [Music]
409:50 - this work
409:52 - is based on the 1978 c programming book
409:55 - written by brian w kernighan and dennis
409:57 - m ritchie
409:58 - their book is copyright all rights
410:00 - reserved by at t
410:02 - but is used in this work under fair use
410:04 - because of the book's historical and
410:06 - scholarly significance
410:08 - its lack of availability and the lack of
410:10 - an accessible version of the book
410:12 - the book is augmented in places to help
410:14 - understand its rightful place in a
410:16 - historical context amidst the major
410:18 - changes of the 1970s and 1980s as
410:22 - computer science evolved from a
410:23 - hardware-first vendor-centered approach
410:26 - to a software-centered approach where
410:28 - portable operating systems and
410:29 - applications written in c could run on
410:31 - any hardware
410:33 - this is not the ideal book to learn c
410:35 - programming because the 1978 edition
410:38 - does not reflect the modern c language
410:40 - using an obsolete book gives us an
410:42 - opportunity to take students back in
410:44 - time and understand how the c language
410:47 - was evolving as it laid the groundwork
410:49 - for a future with portable applications
410:55 - chapter 6 structures
410:57 - a structure is a collection of one or
410:59 - more variables possibly of different
411:01 - types grouped together under a single
411:03 - name for convenient handling
411:05 - while we talk about data structures and
411:07 - how to use them in every language
411:09 - this section is about understanding how
411:11 - software developers carefully control
411:13 - the low level shape of their data items
411:15 - to solve their problems
411:17 - when you first learn about the c struct
411:19 - keyword you might think it's equivalent
411:20 - to a python dict
411:22 - a dynamic key value store like a php
411:24 - array java myapp or javascript object
411:27 - but nothing is further from the truth
411:29 - these other languages provide us with
411:31 - easy to use data structures where all
411:33 - the challenging problems are solved
411:36 - this chapter tells or told the creators
411:40 - of python php java and javascript how to
411:43 - solve the complex problems and build
411:45 - convenient and flexible data structures
411:47 - which we now all use in those
411:49 - object-oriented languages
411:51 - one way to look at this code in this
411:53 - chapter is to think of it as a lesson on
411:55 - how one might build python's list and
411:58 - dict data structures
412:00 - if the code in the chapter takes you a
412:02 - little while to figure out
412:04 - mentally make a note of thanks for all
412:06 - the hard work that modern languages
412:09 - invest to make their high level data
412:11 - structures flexible and easy to use
412:14 - back to the textbook
412:16 - the traditional example
412:18 - of a structure is a payroll record an
412:21 - employee is described as a set of
412:22 - attributes such as name address social
412:24 - security number salary etc
412:26 - some of these in turn could be
412:28 - structures a name has several components
412:30 - as does an address and even a salary
412:33 - structures help organize complicated
412:35 - data particularly in large programs
412:38 - because in many situations they permit a
412:40 - group of related variables to be treated
412:42 - as a unit
412:43 - instead of separate entities in this
412:45 - chapter we'll try to illustrate how
412:47 - structures are used
412:48 - the programs that we will use are bigger
412:50 - than many others in the book but are
412:52 - still of modest size section 6.1 basics
412:56 - let us revisit the date conversion
412:58 - routines of chapter 5.
413:00 - a date consists of several parts such as
413:02 - the day month and year and perhaps the
413:04 - day of the year and the month name
413:06 - these five variables can all be placed
413:09 - in a single structure like this
413:11 - struct
413:12 - date open curly brace
413:15 - in day semicolon in month semicolon in
413:19 - int year semicolon and year day
413:21 - semicolon char
413:23 - mun name
413:25 - open square bracket for closed square
413:26 - bracket semicolon curly brace semicolon
413:30 - the keyword struct introduces a
413:32 - structure declaration which is a list of
413:34 - declarations
413:36 - enclosed embraces an optional name
413:39 - called the structure tag may follow the
413:40 - word struct as with date here the tag
413:43 - names this kind of a structure and can
413:46 - subsequently be used as shorthand for
413:48 - the detailed declaration
413:50 - the elements or variables mentioned in a
413:52 - structure are called its members
413:54 - a structure member or tag and ordinary
413:58 - ie non-member variable can have the same
414:00 - name without conflict since they are
414:02 - always distinguished by context
414:05 - of course as a matter of style one would
414:07 - normally use the same names only for
414:09 - closely related objects
414:12 - the right brace that terminates the list
414:14 - of members may be followed by a list of
414:16 - variables just as for any basic type
414:19 - that is struct open curly brace dot dot
414:22 - dot close curly brace
414:24 - x comma y comma z semicolon
414:27 - is syntactically analogous to int
414:30 - x comma y comma z semicolon in the sense
414:33 - that each statement declares x y and z
414:36 - to be variables of the named type and
414:38 - causes space to be allocated for them
414:41 - a structured declaration that is not
414:43 - followed by a list of variables
414:45 - allocates no storage it merely describes
414:47 - a template or the shape of the structure
414:50 - if the declaration is tagged however the
414:52 - tag can be used in later definitions of
414:54 - the actual instances of the structure
414:57 - for example given the declaration of
414:59 - date above
415:01 - struct date d
415:03 - defines a variable d which is a
415:05 - structure of type
415:06 - date an external or static structure can
415:09 - be initialized by the following by
415:11 - following its definition with a list of
415:12 - initializers for the components
415:15 - struct date d
415:18 - equals open curly brace 14 comma 7 comma
415:21 - 1776 comma 186 comma double quote j u l
415:26 - double quote close curly brace semicolon
415:30 - a member of a particular structure
415:32 - is referred to in an expression by
415:34 - construction of the form structure name
415:37 - dot member
415:39 - the structure member operator dot
415:41 - connects the structure name in the
415:43 - member name to set leap from the date in
415:46 - structure d for example
415:48 - leap equals d dot year modulo four
415:51 - double equals zero
415:53 - and d dot year modulo 100 not equal to
415:56 - zero or d dot year modulo 400
416:00 - double equal zero semicolon
416:03 - or to check the month name
416:05 - if open paren stir comp
416:07 - open paren d dot mun name comma
416:10 - double quote aug double quote close
416:13 - paren double equals zero
416:15 - close paren dot dot
416:17 - or to convert the first character of the
416:19 - month named lower case
416:21 - d dot mon name sub zero equals lower
416:25 - open paren d dot name sub zero close
416:28 - paren semicolon
416:32 - structures may be nested a payroll
416:34 - record might actually look like struct
416:36 - person open curly brace char name open
416:40 - square bracket name size close square
416:42 - bracket semicolon char address open
416:44 - square bracket adder size
416:46 - close square bracket semicolon long zip
416:49 - code semicolon
416:51 - long ss number semicolon double salary
416:55 - struct date birth date semicolon struct
416:58 - date hire date
417:00 - semicolon close curly brace semicolon
417:04 - the person structure contains two dates
417:07 - if we declare emp as struct person amp
417:11 - semicolon then emp.birthdate.month
417:15 - refers to the month of birth
417:18 - the structure member operator
417:20 - dot associates left to right
417:23 - section 6.2 structures and functions
417:27 - there are a number of restrictions on c
417:29 - structures the essential rules are that
417:31 - only operations you can perform on a
417:33 - structure are to take its address with
417:35 - ampersand and access one of its members
417:38 - this implies that structures may not be
417:40 - assigned or copied to as a unit and that
417:43 - they cannot be passed or returned
417:45 - from functions
417:47 - these restrictions will be removed in
417:49 - forthcoming versions furnace
417:50 - destructures do not suffer these
417:52 - limitations however so structures and
417:54 - functions do work together comfortably
417:56 - finally automatic structures like
417:59 - automatic arrays cannot be initialized
418:01 - only external or static structures can
418:04 - this prediction was indeed accurate
418:06 - modern c compilers do support the
418:07 - copying of a structure with a single
418:09 - assignment statement given that a c
418:11 - structure is just a fixed length block
418:13 - of memory it's easy easy to generate
418:15 - machine code to copy it a key bit to
418:17 - remember that when the c structure is
418:19 - copied it is done as a shallow copy
418:22 - a shallow copy copies the values of the
418:24 - variables and the pointers in the
418:25 - structure but does not make copies of
418:27 - any data which the pointers point to
418:30 - a structure that contains other
418:32 - structures i.e not pointers to
418:34 - structures and those structures are
418:36 - shallow copied as well
418:38 - back to the text
418:40 - let us investigate some of these points
418:42 - by rewriting the date conversion
418:44 - functions in the last chapter to use
418:45 - structures since the rules prohibit
418:47 - passing of a structure to a function
418:49 - directly we must either pass the
418:51 - component separately or pass a pointer
418:53 - to the whole thing
418:55 - the first
418:56 - alternative uses of de avere which as we
418:58 - wrote in chapter 5
419:01 - d year day equals
419:03 - day of year open for n d year comma d
419:07 - dot month comma d dot day close paren
419:10 - semicolon
419:11 - the other way is to pass a pointer if
419:13 - we've declared higher date as struct
419:16 - date higher date semicolon and rewritten
419:18 - day of year we could then say
419:20 - higherdate.year day equals day of year
419:22 - open paren ampersand higher date close
419:25 - paren semicolon
419:27 - to pass a pointer to higher date to day
419:29 - of year the function has to be modified
419:31 - because its argument is now a pointer
419:33 - rather than a list of variables
419:36 - this example code is on page 122 of the
419:39 - textbook and you can see it at
419:41 - www.cc4e.com
419:44 - code
419:46 - struct date open curly brace
419:48 - int day semicolon int month semicolon
419:53 - in
419:54 - ear semicolon int year day semicolon and
419:58 - mun name open square bracket four close
420:00 - spread square bracket
420:02 - semicolon closed curly brace semicolon
420:06 - static int day tab
420:08 - open square bracket two close square
420:10 - bracket open square bracket 13 close
420:12 - square bracket equals open curly brace
420:15 - open curly brace zero come at 31 come at
420:18 - 28 come a 31 come a 30 come at 31 come
420:20 - with 30 come a 31
420:22 - 31 come a 30
420:24 - come a 31 come a 30 31 close curly brace
420:28 - comma and then another list just as long
420:30 - as that co with a closed curly brace and
420:33 - a semicolon that just initialized the
420:36 - lookup table for the days in each month
420:39 - now on to the function
420:41 - day of year open paren pd close paren
420:44 - struct date star pd semicolon open curly
420:48 - brace
420:49 - and i come a day come a leap semicolon
420:53 - day
420:54 - equals pd
420:56 - minus
420:57 - greater than day semicolon
421:00 - leap equals pd minus greater than year
421:04 - percent for double equals zero
421:07 - and
421:08 - pd
421:09 - minus greater than year percent 100 not
421:12 - equal to zero
421:14 - or
421:15 - pd
421:16 - minus greater than year percent 400
421:19 - double equal zero semicolon
421:23 - four open paren i equals one semicolon i
421:26 - less than pd
421:28 - minus greater than month semicolon i
421:31 - plus plus close paren
421:33 - day plus equals day tab
421:37 - open square bracket leap close square
421:39 - bracket open square bracket i close
421:41 - square bracket semicolon
421:43 - return open paren day close paren
421:46 - semicolon close curly brace
421:50 - the
421:50 - declaration struct date star pd says
421:53 - that pd is a pointer to a structure of
421:56 - type date
421:57 - the notion exemplified by pd
422:00 - minus
422:01 - greater than year
422:03 - i think i'll call that at this point pd
422:06 - right arrow because that's really what
422:07 - it is it's the minus greater than looks
422:09 - like an arrow to the right so i'm going
422:11 - to call it right arrow but it's really
422:12 - two characters
422:14 - pd right arrow year is new
422:17 - if p is a pointer to a structure then pd
422:20 - right arrow member of structure refers
422:22 - to the particular
422:24 - member the operator right arrow is a
422:27 - minus sign followed by a greater than
422:30 - since pd points to the structure the
422:32 - year member could also be referenced as
422:35 - open paren star pd closed paren dot ear
422:39 - but pointers to structures are so
422:41 - frequently used that the right arrow
422:43 - notation is provided both
422:45 - as a convenient shorthand the
422:47 - parentheses are necessary in open paren
422:50 - star pd close paren dot ear because the
422:52 - precedence of the structure member
422:54 - operator dot is higher than
422:57 - the pointer lookup operator asterisk
422:59 - both right arrow and dot associate to
423:02 - left from left to right so
423:05 - p right arrow q right arrow mem
423:09 - and
423:10 - emp dot birthdate dot month r open paren
423:14 - p right arrow q close paren right arrow
423:17 - mem and open parent emp dot birth date
423:20 - close paren dot month
423:22 - for completeness here is the other
423:25 - function month day rewritten to use the
423:27 - structure
423:29 - this is the first example on page 123 of
423:31 - the text which you can look at the
423:33 - source code at www.cc4e.com
423:36 - code
423:38 - i won't read the struct and the date the
423:40 - destruct date definition in the struct
423:42 - in
423:43 - static in day tab definition we'll just
423:45 - go month day
423:47 - month day open paren pd close paren
423:50 - struct date star pd semicolon
423:53 - open curly brace
423:55 - end i comma leap
423:58 - semicolon
423:59 - leap equals pd right arrow year
424:03 - percent four double equals zero and pd
424:05 - right arrow year percent 100 not equal
424:08 - to zero or pd right arrow year
424:11 - percent 400 double equals 0 semicolon
424:15 - pd right arrow day equals pd right arrow
424:18 - year day
424:20 - four open print i equals one semicolon
424:24 - pd right arrow day greater than day tab
424:27 - subleap sub i semicolon
424:30 - i plus plus close paren
424:32 - pd right arrow day minus equals
424:35 - day tab subleap sub i semicolon
424:39 - pd right arrow month equals i semicolon
424:43 - close curly brace
424:46 - the structure operators
424:48 - right arrow and dot together with
424:50 - parentheses for argument lists and
424:52 - square brackets for subscripts are the
424:54 - top of the precedence hierarchy and then
424:56 - thus bind very tightly
424:59 - for example given the declaration struct
425:01 - open curly brace
425:03 - int x int star y
425:06 - semicolon close
425:08 - curly brace star p semicolon then
425:12 - plus plus p right arrow x increments x
425:16 - not p
425:18 - because the implied parenthesization is
425:20 - plus plus open paren p right arrow x
425:23 - close paren
425:24 - parentheses can be used after the
425:26 - binding
425:27 - open paren plus plus p
425:30 - right arrow x increments p before
425:32 - accessing x and open paren p plus plus
425:36 - close paren right arrow x increments p
425:38 - afterward
425:39 - the last set of parentheses is
425:41 - unnecessary
425:43 - in the same way star p right arrow y
425:46 - fetches whatever y points to star
425:50 - p right arrow y plus plus increments y
425:53 - after what
425:55 - after accessing whatever it points to
425:57 - just like star s plus plus
426:00 - open paren star p
426:02 - right arrow y
426:04 - close paren plus plus increments
426:06 - whatever y points to and star p
426:10 - plus plus right arrow y
426:12 - increments p after accessing whatever y
426:15 - points to
426:17 - section 6.3 arrays of structures
426:21 - structures are especially suitable for
426:23 - managing arrays of related variables
426:26 - for instance consider a program to count
426:28 - the occurrences of each c keyword
426:31 - we need an array of character strings to
426:32 - hold the names and an array of integers
426:34 - to hold the counts
426:36 - one possibility is to use two parallel
426:39 - arrays keyword and key count as in
426:42 - char star keyword open square bracket n
426:45 - keys close square bracket semicolon
426:48 - int key count open square bracket n keys
426:51 - close square bracket semicolon but the
426:53 - very fact that the arrays are parallel
426:55 - indicates a different organization is
426:57 - possible
426:58 - each keyword entry is really a pair
427:01 - char star keyword semicolon
427:03 - int key count semicolon and there's an
427:06 - array of the pairs
427:08 - the structure declaration struct key
427:11 - open curly brace char star keyword
427:13 - semicolon int key count semicolon close
427:16 - curly brace key tab open square bracket
427:19 - n keys close square bracket semicolon
427:23 - defines an array key tab of structures
427:24 - of this type and allocate storage to
427:26 - them each element of the array is a
427:28 - structure this could also be written
427:31 - struct key open curly brace char star
427:35 - keyword semicolon int key count
427:38 - semicolon
427:39 - close curly brace semicolon
427:41 - struct key key tab open square bracket
427:44 - and keys close square bracket semicolon
427:49 - since the structure key tab actually
427:51 - contains a constant set of names it's
427:52 - easiest to initialize it once and for
427:54 - all when it's defined
427:56 - the structural initialization is quite
427:57 - analogous to the earlier ones the
427:59 - definition is followed by a list of
428:00 - initializers and closed embraces
428:04 - struct key open curly brace char star
428:07 - keyword semicolon int key count
428:10 - semicolon close curly brace
428:13 - key tab open square bracket close square
428:15 - bracket equals open curly brace
428:17 - double quote break comma 0 comma double
428:21 - quote case comma 0 comma double quote
428:24 - char comma 0 comma
428:27 - and so forth
428:28 - down to double quote unsigned double
428:30 - quote comma 0 comma double quote while
428:34 - double quote comma 0
428:36 - closed curly brace semicolon
428:39 - these
428:41 - initializers are listed in pairs
428:43 - corresponding to the structure members
428:45 - it would be more precise to enclose
428:47 - initializers for each row or structure
428:49 - in the braces as in
428:51 - open curly brace double quote break
428:53 - double quote comma zero close curly
428:56 - brace comma open curly brace double
428:58 - quote case double quote comma zero
429:02 - close curly brace comma and so forth
429:05 - but the inner braces are not necessarily
429:07 - when the initializers are simple
429:08 - variables or character strings and when
429:10 - all are present
429:12 - as usual the compiler will compute the
429:14 - number of entries in the array key tab
429:15 - if the initializer is present and the
429:17 - open square bracket close square bracket
429:19 - is left
429:20 - empty the keyword counting program which
429:23 - begins with a definition of key tab the
429:26 - main routine reads the input repeatedly
429:27 - by calling a function get word that
429:30 - fetches input one word at a time each
429:32 - word is looked up in key tab
429:35 - with a version of binary the binary
429:36 - search function we wrote in chapter
429:38 - three
429:39 - of course the list of keywords has to be
429:41 - given in increasing order for this to
429:43 - work
429:45 - here is the first example on page 125 of
429:49 - the textbook
429:50 - you can see this
429:53 - at www.cc4e.com
429:56 - code
429:58 - pound include stdio.h
430:01 - pound define max word 20
430:05 - pound defined letter quote a quote
430:08 - main open prem close paren open curly
430:11 - brace
430:12 - int n comma t semicolon
430:15 - char word open square bracket max word
430:18 - close square bracket semicolon
430:21 - while open paren open print t equals get
430:24 - word open paren word comma max word
430:27 - close paren close paren not equal eof
430:29 - close paren
430:31 - if open friend t double equal letter
430:34 - close paren
430:35 - if double
430:37 - open paren open paren n equals
430:40 - binary open paren word come a key tab
430:42 - comma n keys close paren close paren
430:44 - greater than or equal to zero
430:46 - close paren
430:47 - key tab sub n dot key count plus plus
430:52 - four open paren n equals zero semicolon
430:57 - and less than n keys semicolon and plus
430:59 - plus
431:00 - if open open paren key tab sub n dot key
431:03 - count greater than zero close paren
431:06 - print f
431:08 - double quote percent for d space percent
431:10 - s backslash n double quote comma
431:13 - key tab sub n dot key count comma key
431:17 - tab sub n dot keyword close paren
431:20 - semicolon and then a closed curly brace
431:22 - to finish main
431:25 - binary
431:26 - to find the word in the in the table
431:29 - binary open paren word comma tab comma n
431:32 - close paren
431:33 - char star word
431:35 - semicolon struct key tab open square
431:38 - bracket close work square bracket
431:40 - semicolon
431:41 - int n
431:43 - open curly brace
431:44 - int low comma high comma mid comma cond
431:48 - low equals zero semicolon high equals n
431:51 - minus one semicolon
431:53 - while open paren low less than or equal
431:56 - to high close paren open curly brace
431:59 - mid equals paren low plus high close
432:02 - paren over to
432:05 - semicolon
432:06 - if
432:07 - open paren open paren conned equals stir
432:10 - comp open paren word
432:12 - comma tab comma open square bracket mid
432:15 - close square bracket dot keyword close
432:17 - print close friend less than zero close
432:19 - paren hi
432:21 - equals mid minus one semicolon else if
432:25 - open paren con
432:27 - greater than zero close paren low equals
432:29 - mid plus one semicolon else
432:32 - return open paren mid close paren
432:34 - semicolon
432:35 - close curly brace to finish the while
432:37 - and then return open paren minus one
432:39 - close paren semicolon
432:42 - close curly brace and that's really a
432:43 - rewrite of the binary function
432:46 - from the earlier part where we're just
432:49 - taking the keyword and count and
432:53 - and look in and looking up in the array
432:56 - but then using the dot keyword to find
432:58 - the actual keyword
433:00 - back to the text we'll show function get
433:03 - word in a moment for now it suffices to
433:05 - say it returns letter each time it finds
433:07 - a word and copies the word into its
433:10 - first argument
433:11 - the quantity n keys is the number of
433:13 - keywords in key tab although we could
433:15 - count this by hand it's a lot easier and
433:17 - safer to do it by machine especially if
433:20 - the list is subject to change
433:22 - one possibility would be to terminate
433:24 - the list of initializers with a null
433:25 - pointer and then the loop along key tab
433:27 - just runs until the end is found
433:30 - but this is more than as needed since
433:32 - the size of the array is completely
433:34 - determined at compile time the number of
433:37 - entries is just the size of key tab
433:39 - divided by the size of the struct key
433:43 - c provides a compile time op unary
433:46 - operator called sizeof which can be used
433:48 - to compute the size of any object
433:51 - the expression size of open paren object
433:54 - close paren yields an integer equal to
433:56 - the size of the specified object
433:59 - the size is given in unspecified units
434:01 - called bytes which are the same size as
434:04 - a char closed paren
434:07 - the object can be an actual variable or
434:08 - an array or structure or the name of a
434:11 - basic type like int or double or the
434:13 - name of a derived type like a structure
434:15 - in our case the number of keywords is
434:18 - the array size
434:19 - divided by the size of one array element
434:22 - and this computation is used in a pound
434:24 - define statement to set the value of n
434:26 - keys
434:28 - pound define n keys
434:30 - open paren size of open or print key tab
434:33 - close print
434:34 - divided by size of open paren struct key
434:38 - close paren close paren
434:41 - now for the function get word we have
434:43 - actually written a more general get word
434:45 - than is necessary for this program
434:47 - but it is not really much more
434:49 - complicated
434:50 - get word returns the next word from the
434:52 - input where a word is either a string or
434:55 - of letters or digits beginning with a
434:57 - letter or a single character the type of
434:59 - the object that is is the returned
435:01 - function as a function value
435:04 - it is the letter if the token is a word
435:06 - eof render file or the character itself
435:09 - if it's non-alphabetic
435:13 - this sample code is on page 127 of the
435:15 - textbook which you can see at
435:17 - www.cc4e.com
435:20 - code
435:22 - pound define letter quote a quote pound
435:25 - defined digit quote zero quote
435:27 - get word open paren w comma limb close
435:31 - paren
435:32 - char
435:33 - star w
435:34 - colon semicolon
435:36 - int lim semicolon open curly brace int c
435:41 - comma t semicolon
435:43 - if open paren type open paren c equals
435:47 - star w plus plus equals get ch open
435:50 - paren close paren close paren not equal
435:53 - letter close print open curly brace
435:56 - start w
435:58 - equals quote backslash zero quote
436:00 - semicolon
436:02 - return open for nc close paren semicolon
436:05 - close curly brace
436:07 - that if statement has got some stuff
436:09 - going on in it you might want to look at
436:10 - it very closely
436:12 - while open paren minus minus limb
436:15 - greater than zero close paren open curly
436:18 - brace
436:18 - t
436:19 - equals type open friend c
436:21 - equals star w
436:23 - plus plus equals get ch open paren close
436:26 - paren
436:27 - close point semicolon
436:29 - if if open friend t not equal letter and
436:33 - t not equal digit close paren
436:36 - open curly brace unget ch open paren c
436:39 - close paren semicolon
436:42 - break semicolon close curly brace star
436:45 - open paren w minus one close paren
436:48 - equals quote backslash zero quote
436:51 - semicolon
436:52 - return open paren letter close paren
436:55 - semicolon
436:56 - close curly brace close curly brace
437:00 - that that example code
437:02 - has a lot of stuff about pointers and
437:04 - incrementing pointers and dereferencing
437:05 - pointers etc so take a good look at that
437:08 - code
437:10 - back to the text
437:11 - get word uses the routines get ch and
437:13 - unget ch which we wrote in chapter 4.
437:16 - when the collection of alphabetic of an
437:18 - alphabetic token stops get word has gone
437:20 - one character too far that call to unget
437:23 - ch pushes that character back on the
437:25 - input for the next call
437:27 - getword calls another function called
437:29 - type to determine the type of each
437:30 - individual character for input
437:32 - here is a version that's only for ascii
437:36 - this code is the second example on page
437:38 - 127 of the textbook at www.cc4e.com
437:44 - code
437:46 - type open paren c close paren in c
437:50 - semicolon
437:51 - yeah open curly brace if
437:53 - open paren c greater than or equal to
437:55 - quote a quote and c less than or equal
437:58 - to quote z quote or
438:01 - c greater than or equal to quote
438:03 - uppercase a quote and c less than or
438:05 - equal to
438:06 - quote uppercase z quote close paren
438:09 - return
438:10 - letter semicolon
438:13 - else if open paren c greater than or
438:15 - equal to quote zero quote and c less
438:18 - than or equal to quote nine quote close
438:19 - paren return open friend digit close
438:22 - paren semicolon
438:24 - else
438:25 - return open paren c close paren
438:28 - semicolon
438:29 - close curly brace
438:31 - the symbolic constants letter and digits
438:34 - can have any values that do not conflict
438:36 - with
438:36 - non-alphanumeric values and eof the
438:39 - obvious choices are
438:41 - quote a quote and quote zero quote
438:44 - get word can be faster if calls to the
438:46 - function type are replaced by references
438:48 - to the appropriate array type the
438:50 - standard c library provides macros like
438:53 - is alpha and is digit which operate in
438:55 - this manner
438:57 - section 6.4 pointers to structures
439:00 - to illustrate some of the considerations
439:02 - involved with pointers and arrays of
439:04 - structures let us write a keyword
439:06 - counting program again
439:08 - this time using pointers instead of
439:10 - array indices
439:12 - as an aside i would note that it's a
439:14 - classic early assignment in any
439:16 - programming language to do a word
439:17 - frequency program here is a python
439:19 - program from my python for everybody
439:21 - course to count words from an input
439:23 - stream
439:24 - handle
439:25 - equals open
439:27 - open parenthesis single quote romeo dot
439:29 - txt close single quote comma quote r
439:32 - quote close parenthesis
439:34 - words equals handle dot read open print
439:37 - close print dot split open friend close
439:39 - paren
439:40 - counts equals dict open paren close
439:43 - paren
439:44 - four word in words colon
439:48 - counts subword equals
439:51 - get open paren word comma zero close
439:54 - paren plus one print open parent counts
439:57 - close paren
439:58 - this section in this book implements a
440:01 - less general word counting program in c
440:04 - the code depends on several functions
440:05 - from earlier in the book and the code
440:07 - below is pretty complex where the
440:09 - programmer only has access to low-level
440:11 - language without powerful and
440:12 - easy-to-use data types like python's
440:14 - list or dict
440:16 - it is likely that keto van rossen read
440:18 - this book took a long look at this code
440:21 - and designed the dick data structure in
440:22 - python so the rest of us can write a
440:25 - data parsing and word frequency
440:26 - programming program in the above six
440:29 - lines of code without worrying about
440:31 - dynamic memory allocation pointer
440:33 - management string length and a myriad of
440:35 - other details that must be solved when
440:37 - you're solving this program in c
440:41 - since python is open source you can
440:43 - actually look at the c code that
440:45 - implements the dict object in a file
440:47 - called dict object dot c
440:49 - it is almost 6 000 lines of code and
440:51 - includes other files or utility code
440:55 - there thankfully we only have to write
440:57 - one line of python to use it counts
440:59 - equals dict open friend close paren
441:02 - we will leave the complex bits to the c
441:04 - programmers that build and maintain
441:07 - this section is not showing us how to
441:09 - use the python dict object
441:11 - rather it is showing how one would build
441:13 - a dick like structure using c
441:18 - so
441:18 - continuing with section 6.4 pointers to
441:21 - structures
441:23 - the external definition of key tab do
441:25 - not need to change but main and binary
441:27 - do need modification this is
441:30 - example on page 129 of the textbook
441:34 - and that is available at www.cc4e.com
441:38 - code
441:42 - pointer version of counting c keywords
441:45 - main open paren close paren open curly
441:47 - brace int t semicolon
441:50 - char word open square bracket max word
441:52 - close square bracket semicolon struct
441:55 - key star binary open paren close paren
441:58 - comma star p semicolon
442:01 - while open paren open paren t equals get
442:04 - word open paren word comma max word
442:06 - close paren close paren
442:08 - not equal e o f close paren
442:11 - if open print t equal equal letter close
442:15 - paren
442:16 - if open paren open paren b equals binary
442:19 - open paren word comma key tab comma n
442:22 - keys close paren close paren not equal
442:25 - null close paren
442:26 - p right arrow key count plus plus
442:30 - for p equals key tab p less than key tab
442:34 - plus n keys semicolon p plus plus close
442:37 - parenthesis
442:38 - if open paren p right arrow key count
442:41 - greater than zero
442:42 - close paren printf
442:44 - open paren
442:46 - double quote percent for d space percent
442:48 - s backslash n
442:50 - double quote comma
442:52 - p right arrow key count comma p right
442:55 - arrow keyword
442:58 - and now we look at the binary search
443:04 - struct key star binary open paren word
443:07 - come tab comma n close paren
443:10 - char star word struct key tab open
443:13 - square bracket close square bracket
443:15 - semicolon
443:16 - int n
443:18 - open curly brace
443:20 - int cond semicolon
443:22 - struct key star low equals ampersand tab
443:26 - sub zero
443:27 - semicolon struct key star high equals
443:30 - ampersand tab sub n minus one semicolon
443:34 - struct key equals mid
443:38 - while open paren low less than or equal
443:40 - to high close paren open curly brace
443:43 - mid equals low plus high minus low
443:48 - divided by 2.
443:50 - if open paren open for n cond
443:53 - equals stir comp word comma mid
443:56 - right arrow keyword close print close
443:58 - paren
444:00 - less than zero close paren
444:02 - hi
444:02 - equals mid minus one semicolon else if
444:06 - close print con greater than zero close
444:08 - paren
444:09 - low equals mid plus one semicolon
444:12 - else return open paren mid close print
444:15 - semicolon
444:17 - close curly brace to finish the while
444:19 - and then return open paren null close
444:22 - paren
444:24 - close curly brace
444:26 - there are several things worthy of note
444:28 - here first the declaration of binary
444:31 - must indicate that it returns a pointer
444:34 - to the structure type key instead of an
444:36 - integer this is declared both in main
444:38 - and in binary if binary finds the word
444:41 - it returns a pointer to it if it fails
444:43 - it returns null
444:45 - second
444:47 - all the accessing elements of key dab is
444:50 - done by pointers
444:51 - this causes one very significant change
444:53 - in binary
444:55 - the computation of the middle element
444:57 - can no longer be simply mid equals paren
445:00 - low plus high close paren
445:02 - divided by two
445:04 - because the addition of two pointers
445:05 - will not produce any kind of useful
445:08 - answer even when divided by two and is
445:10 - fact illegal this must be changed to
445:13 - mid equals low plus open paren high
445:16 - minus low close paren divided by two
445:19 - which sets mid to the point to point to
445:22 - the element halfway between low and high
445:25 - you should also study the initializers
445:27 - for low and high
445:29 - it is possible to initialize a pointer
445:32 - to the address of a previously defined
445:34 - object and that is precisely what we
445:36 - have done here
445:38 - in main we wrote four open paren p
445:41 - equals key tab semicolon p less than key
445:44 - tab plus n keys semicolon p plus plus
445:48 - close paren
445:50 - if p is a pointer to a structure any
445:52 - arithmetic on p takes into the account
445:54 - the actual size of the structure so
445:57 - p plus plus increments p by the correct
445:59 - amount to get to the next element in the
446:01 - array of structures
446:03 - but don't assume that the size of a
446:04 - structure is the sum of the sizes of its
446:06 - members because alignment requirements
446:08 - for different objects
446:10 - potentially may cause holes in the
446:12 - structure
446:13 - finally an aside on program format when
446:17 - a function returns a complicated type as
446:19 - instruct key star binary open paren word
446:23 - comma tab comma n close paren
446:26 - the function name can kind of be hard to
446:28 - see and or find with a text editor
446:31 - alternately
446:33 - another style is sometimes used
446:35 - on two lines now struct key star on the
446:38 - first line in binary open paren word
446:41 - comma tab comma n close paren
446:44 - the spacing is mostly a matter of
446:46 - personal taste pick the form you like
446:48 - and hold to it
446:50 - section 6.5 self-referential structures
446:54 - before we start this section a slightly
446:56 - longer aside from your narrator
446:59 - up to now i've resisted the temptation
447:01 - to augment the book with my own bits of
447:03 - code
447:04 - but we have reached the single point in
447:06 - the book where i feel that there is too
447:07 - big of a conceptual leap between two
447:10 - sections so i'm going to add some of my
447:12 - own narrative between sections 6.4 and
447:14 - 6.5
447:16 - the rest of this chapter talks very
447:17 - nicely about binary trees and hash
447:19 - tables both essential low-level data
447:22 - structures in computer science and both
447:24 - excellent ways to understand pointers
447:26 - and how c can be used to build data
447:28 - structures like the python dictionary
447:30 - however
447:31 - the authors skip separately describing
447:33 - the structure of a dynamic dynamically
447:36 - constructed linked list which is the
447:38 - first and foundational collection data
447:40 - structure in computer science it should
447:42 - be understand be understood before
447:44 - moving to tree and hash map structures
447:48 - linked lists form the foundation of the
447:50 - python list object java array object php
447:53 - numeric key arrays and javascript arrays
447:55 - the linked list can be dynamically
447:58 - extended and items can be added in the
448:00 - middle efficiently as well as being
448:02 - pushed or popped on or off the front or
448:04 - back of the list
448:06 - linked lists are used also to implement
448:08 - cues as well as other aspects of
448:10 - operating system
448:11 - i will attempt to mimic the author's
448:14 - writing style in this new section of the
448:15 - book i'll write some sample code using a
448:17 - more modern dialect of c so it's easier
448:19 - to run on a modern compiler
448:23 - section
448:25 - 6.5.1 linked lists bonus
448:28 - content suppose we want to read a file
448:31 - and print the file in reverse order we
448:33 - don't know how many lines will be in the
448:35 - file before we read the file so we can't
448:37 - simply use an array of pointers to
448:39 - strings and character arrays like lines
448:42 - in a sense we need a dynamic array that
448:45 - grows as we encounter new lines when we
448:47 - reach the end of the file we then just
448:48 - loop through our stored lines from the
448:50 - end to the beginning so we can print
448:52 - them out in reverse order
448:54 - one solution is to make a data structure
448:56 - called a doubly linked list of character
448:58 - strings
448:59 - in addition to each line of data we will
449:01 - store a pointer to the previous line and
449:04 - the next line as well
449:05 - as well as a pointer to the first item
449:08 - we add to the list and then we'll call
449:10 - this the head of the list and then the
449:11 - most recent item we've added to the list
449:13 - which we'll call the tail of the list
449:16 - we will see a singly linked list as part
449:18 - of the hashmap data structure in a
449:20 - following section
449:22 - a single link list can only be traversed
449:24 - in a forward direction a doubly linked
449:26 - list can be traversed either forwards or
449:28 - backwards
449:29 - given that our linked list of strings
449:30 - will keep expanding as we get new lines
449:33 - we avoid hard coding array sizes like
449:35 - pound define maxlen1000 in the previous
449:37 - chapter we were building a program to
449:40 - sort a file
449:41 - going back to the description of a line
449:43 - in our doubly linked list it is clearly
449:45 - a structure with three components struct
449:48 - l node open curly brace char star text
449:51 - semicolon struct l node star prev
449:54 - semicolon struct l node star next
449:57 - semicolon close curly brace
450:01 - this recursive definition of l node
450:04 - might look chancy but it's actually
450:06 - quite correct it is illegal
450:08 - for a structure contained to contain an
450:10 - instance of itself but struct l node
450:13 - star prev declares preeve to be a
450:15 - pointer to an l node not an l node
450:18 - itself
450:20 - we'll write this code in a more modern c
450:22 - dialect using modern memory allocation i
450:24 - o routines provided by the standard c
450:26 - library
450:27 - this code is on page 130 of the textbook
450:31 - available at
450:35 - slash www.cc4e.com
450:37 - pound include stdio.h pound include std
450:41 - live.h pawn includes string.h
450:44 - pound define max line 1000 this is the
450:47 - length of the line not the number of
450:48 - lines struct l node open curly brace
450:52 - char star text semicolon
450:55 - struct l node star preview semicolon
450:58 - struct l node star next semicolon close
451:02 - curly brace semicolon
451:04 - now we have our main program to print
451:06 - the lines in reverse
451:08 - and we will use int main open paren
451:10 - close paren because we're coding in a
451:13 - modern dialect of c
451:15 - open curly brace struct l node star head
451:19 - equals null semicolon struct l node star
451:22 - tail equals null semicolon char line sub
451:26 - max line semicolon
451:29 - while
451:30 - open paren f get s open paren line comma
451:33 - max line comma s t d i n close paren not
451:36 - equal null close print open curly brace
451:41 - char star save equals open print char
451:45 - star
451:46 - close prin malloc open prin sterlin open
451:49 - print line close paren plus one close
451:52 - paren semicolon
451:54 - stir copy
451:56 - save come align
451:58 - struct l node star new equals
452:02 - open paren struct l node star close
452:04 - paren malloc open paren size of struct l
452:07 - node close paren close paren semicolon
452:10 - new right arrow text equals save new
452:13 - right arrow next equals null
452:15 - new right arrow preview equals tail and
452:18 - tail equals new
452:20 - if
452:21 - head
452:22 - equals equals null
452:24 - close paren head equals new semicolon
452:28 - close curly brace to finish the while
452:31 - now we'll print it all out
452:33 - four open paren struct l node star
452:36 - current equals tail semicolon current
452:39 - not equal to null
452:40 - semicolon current equals current right
452:43 - arrow prev
452:44 - close parenthesis open curly brace
452:47 - printf open paren double quote
452:49 - s close
452:51 - double quote comma current right arrow
452:54 - text close paren semicolon
452:57 - close curly brace to finish the four and
452:58 - then close curly brace
453:00 - to finish the main
453:03 - interestingly if we wanted to print the
453:05 - list in forward order or if we did have
453:07 - only a singly linked list our loop would
453:08 - look as follows
453:11 - four open paren struct l node star
453:13 - current equals head semicolon current
453:15 - not equal to null semicolon current
453:18 - equals current right arrow next closed
453:20 - paren open curly brace
453:23 - printf open paren double quote percent s
453:26 - double quote comma current right arrow
453:28 - text
453:29 - close paren
453:30 - semicolon close curly brace
453:34 - in general we use the variable names
453:36 - head tail and current as well as next
453:38 - and pre or similar names when writing
453:41 - code that builds or uses a linked list
453:43 - or so other programs will quickly
453:44 - understand what we are talking about
453:47 - after a while reading a for loop to
453:49 - traverse a linked list becomes as
453:51 - natural as reading a for loop that
453:53 - progresses through a sequence of numbers
453:56 - sections 6.5.2 binary trees
453:59 - suppose we want to handle the more
454:01 - general problem of counting the
454:02 - occurrences of all the words in some
454:04 - input
454:05 - since the list of words isn't known in
454:07 - advance we can't conveniently sort it
454:09 - and use a binary search
454:11 - yet we can't do a linear search for each
454:13 - word that has arrived to see if it's
454:14 - already been seen
454:16 - the program would take forever
454:18 - more precisely what is the expected
454:20 - running time and it would grow
454:21 - quadratically with a number of input
454:23 - words
454:24 - how can we organize the data to cope
454:27 - efficiently with a list of arbitrary
454:29 - words
454:31 - our solution is to keep the set of words
454:33 - seen so far sorted at all times
454:37 - by placing each word into its proper
454:39 - position in the order as it arrives
454:42 - this should this shouldn't be done by
454:44 - shifting the words in a linear array
454:45 - though that takes too long instead we
454:49 - will use a data structure called a
454:51 - binary tree
454:53 - the tree contains one node per distinct
454:55 - word
454:56 - each node contains a pointer to the text
454:58 - of the word
455:00 - a count of the number of occurrences of
455:01 - the word
455:02 - a pointer to the left child
455:04 - node and a pointer to the right child of
455:06 - node
455:08 - no node may have more than one
455:10 - at more than two children it might have
455:13 - only zero or
455:14 - one the nodes are maintained so that any
455:17 - node in the left tree contains only
455:19 - words that are less than the words at
455:20 - the node and the right tree only
455:22 - contains words that are greater
455:24 - to find out whether a new word is
455:25 - already in the tree one starts at the
455:27 - root and compares the new word to the
455:28 - word starting at that node
455:30 - if they match we found it
455:33 - if the new word is less than the tree
455:35 - word the search continues down the left
455:37 - otherwise the right child is searched
455:39 - there is no child in the required
455:40 - direction then the word is not in the
455:42 - tree and
455:44 - in plaque in fact the proper place for
455:46 - it to be
455:47 - is the missing child
455:49 - this search process is inherently
455:51 - recursive
455:53 - since the search for many node uses a
455:55 - search from one of its children
455:56 - accordingly recursive routines for
455:58 - inserting and printing will be the most
456:00 - natural
456:03 - going back to the description of a node
456:05 - is clearly a structure with four
456:06 - components
456:08 - struct t node open curly brace char star
456:13 - word
456:13 - int count semicolon
456:16 - struct t note star left semicolon struct
456:19 - t node star right semicolon closed curly
456:22 - brace
456:24 - this recursive declaration of a node
456:26 - might look chancy but actually it's
456:28 - quite correct
456:29 - it's
456:30 - illegal for a structure to contain an
456:32 - instance of itself but struck t node
456:35 - star left semicolon declares left to be
456:38 - a pointer to a node not a node itself
456:42 - the code for the whole program is
456:43 - surprisingly small given the handful of
456:46 - supporting routines that we've already
456:47 - written these are get word to fetch
456:49 - input and alec to provide space for
456:51 - squirreling the words away
456:53 - the mahin routine simply reads words
456:57 - with getword installs them in the tree
456:58 - with tree
457:00 - this is the first example on page 131 of
457:03 - the textbook which you can see at
457:05 - www.cc4e.com
457:08 - code
457:10 - pound include stdio.h pound defined max
457:14 - word 20 pound defined letter single
457:16 - quote a single quote
457:18 - main open paren close paren open curly
457:21 - brace struct t node star root comma star
457:26 - tree open print close paren semicolon
457:28 - char word open square bracket max word
457:31 - close square bracket semicolon and t
457:34 - semicolon
457:35 - root equals null
457:38 - while open paren open parent t equals
457:41 - get word open paren word comma max word
457:44 - close print close paren not equal eof
457:46 - close paren
457:47 - if open paren t double equal letter
457:50 - close paren root equals tree open paren
457:53 - root comma word close paren semicolon
457:57 - tree print
457:58 - open paren
457:59 - root close paren semicolon close curly
458:02 - brace
458:04 - tree itself is straightforward
458:07 - a word is presented by main to the top
458:09 - level root of the tree
458:11 - at each stage that word is compared to
458:13 - the word already stored at the node and
458:15 - is percolated down either to the left or
458:17 - right subtree by a recursive called a
458:19 - tree
458:20 - eventually the word either matches
458:22 - something already in the tree
458:24 - in which case the count simply is
458:25 - incremented or a null or pointer is
458:27 - encountered indicating the node must be
458:30 - created and added to the tree if a new
458:32 - node is created tree rent turns a
458:34 - pointer to it which is installed in the
458:36 - parent node
458:40 - this is
458:41 - the example on page 132 of the textbook
458:44 - at wwe
458:47 - code
458:51 - pound includes string dot h
458:53 - struct t node open curly brace char star
458:57 - word semicolon int count semicolon
459:00 - struct t node star left semicolon struct
459:04 - t node star right semicolon
459:06 - close curly brace semicolon
459:10 - struct t node star tree open paren p
459:13 - comma w close paren we're going to
459:15 - install
459:16 - w at or below p
459:19 - struck t node star p semicolon char star
459:23 - w open curly brace struct t node star t
459:27 - alec
459:28 - open paren close paren semicolon char
459:31 - star stir state stir save open for n
459:34 - close paren semicolon
459:36 - int conned semicolon
459:39 - if open paren p double equal null
459:43 - close paren open curly brace
459:45 - we've got a new word p
459:47 - equals t alec open print close paren to
459:50 - make a new note
459:52 - p right arrow word equals stir save open
459:54 - paren w close paren semicolon p
459:57 - right arrow count equals 1
460:00 - p right arrow left equals p right arrow
460:02 - right equals null
460:06 - close curly brace else if
460:09 - open paren open print con equal stir
460:12 - comp w comma p right arrow word close
460:15 - paren close paren
460:16 - double equals zero close paren
460:19 - p right arrow count plus plus
460:22 - indicate that we've seen the word one
460:24 - more time
460:27 - else if open paren conned less than zero
460:30 - close paren
460:32 - lower will go into the left part of the
460:33 - tree
460:37 - p right arrow left equals tree
460:40 - p right arrow left comma w
460:43 - close paren semicolon else
460:46 - p right arrow right
460:48 - equals tree open friend p right arrow
460:51 - right comma
460:53 - w
460:54 - close paren semicolon
460:56 - return open paren p close paren
460:58 - semicolon
460:59 - close curly brace
461:02 - and that's a bit of code it's not much
461:04 - and it's beautiful
461:06 - recursion is happening the return p at
461:08 - the very end is really really important
461:10 - because we're kind of always overriding
461:12 - it but we're okay
461:14 - so um
461:16 - the overriding works its way back up to
461:18 - the recursion because it's recursive
461:19 - it's using pointers away we go
461:22 - back to the text
461:24 - storage for the new node is fixed by a
461:27 - routine called t alec which is an
461:29 - adaptation of the alec we wrote earlier
461:31 - it returns a pointer to a free space
461:34 - suitable for holding a tree node
461:36 - we'll discuss this more in a moment the
461:38 - new word is copied to a hidden place by
461:41 - stir save the count is initialized and
461:43 - the two children are made null
461:45 - this part of the code is executed only
461:47 - at the edge of the tree when a new node
461:49 - is being added
461:50 - we have unwisely for a production
461:52 - program omitted error checking on the
461:55 - values between returned by stir save and
461:58 - t alec
461:59 - tree print
462:01 - prints the tree in left sub tree order
462:04 - at each node it prints its left sub-tree
462:06 - all the words less than this word then
462:08 - the word itself then the right sub-tree
462:10 - all the words greater
462:13 - if you feel shaky about recursion draw
462:15 - yourself a tree and printed with tree
462:17 - print
462:18 - it's one of the cleanest recursive
462:20 - routines you can find
462:24 - this example code is on page 133 of the
462:27 - textbook which you can see at
462:29 - www.cc4e.com
462:32 - code
462:35 - i won't read
462:38 - the struct node code
462:40 - just tree print
462:43 - tree print open paren p close paren
462:46 - struct t node star p semicolon open
462:49 - curly brace if open paren p not equal to
462:52 - null close parend
462:55 - curly brace open curly brace tree print
462:58 - open paren p air right arrow left close
463:01 - paren semicolon printf percent 4d space
463:05 - percent s backslash n double quote comma
463:08 - p right arrow count comma p right arrow
463:11 - word sum print close parenthesis
463:13 - semicolon
463:15 - tree print open print p right arrow
463:18 - right close paren semicolon close curly
463:21 - brace for the if and then close curly
463:22 - brace for the tree print function
463:26 - again i agree with the authors and that
463:28 - is one of the cleanest and most
463:29 - beautiful and most applicable uses of
463:32 - recursion that you will probably ever
463:33 - see in all your career
463:36 - i'm not a fan of recursion in all uses
463:38 - cases but you really can't do this any
463:40 - other way well
463:43 - back to the text
463:44 - practic as a practical note if the pre
463:46 - tree becomes unbalanced because the
463:48 - words don't arrive in random order the
463:50 - running time of the program can grow too
463:52 - fast as a worst case if the forwards are
463:55 - already in order
463:57 - this program does an expensive
463:58 - simulation of linear search there are
464:00 - generalizations of the binary tree
464:02 - notably
464:03 - 2 3 trees avl trees and i would add
464:06 - balanced binary trees which do not
464:08 - suffer from this worst case behavior but
464:10 - we will not describe them here
464:13 - before we leave this example it's also
464:15 - worth a brief digression on a problem
464:17 - related to storage allocators clearly
464:20 - it's desirable that there only be one
464:22 - storage allocator in a program
464:24 - even though it allocates different kinds
464:26 - of objects but if one allocator is to
464:28 - process requests for say pointers to
464:30 - chars and pointers to struck t nodes two
464:33 - questions arise
464:34 - first
464:35 - does it meet the requirement of most
464:37 - real machines that objects of a certain
464:39 - types must satisfy alignment
464:41 - restrictions for example integers must
464:44 - often be located uneven addresses
464:47 - second
464:48 - what declarations can cope with the fact
464:50 - that alec necessarily returns different
464:52 - kinds of pointers
464:54 - alignment requirements can generally be
464:56 - satisfied easily at the cost of some
464:58 - wasted space merely by assuring ensuring
465:01 - the allocator always returns a pointer
465:03 - that meets all alignment restrictions
465:06 - for an example on the pdb11 it is
465:08 - sufficient
465:09 - that alec always returns an even pointer
465:12 - since any type of object may be stored
465:14 - at an even address the only cost is a
465:17 - wasted character on the odd length
465:19 - requests
465:20 - similar actions are taken on other
465:22 - machines
465:23 - thus the implementation of alec may not
465:25 - be portable but its usage is
465:28 - the alec of chapter 5 does not guarantee
465:31 - any particular alignment in chapter 8
465:33 - we'll show how to do the job right
465:37 - as an aside by now you know that when
465:39 - the authors mentioned the pdp-11 they
465:41 - are sharing some aspects of the
465:43 - challenge of making c work on previous
465:45 - generation computers with short memory
465:48 - words and small amounts of memory and at
465:50 - the same time making them work well on
465:52 - the incoming generation of computers
465:53 - with larger words and more memory
465:56 - the research thought
465:58 - and care that went into making sure the
466:01 - c code was portable across multiple
466:03 - generations of computer hardware is on
466:05 - display in the previous paragraph
466:09 - the question of the type declaration for
466:12 - alec is a vexing one for any language
466:14 - that takes its type checking seriously
466:17 - in c the best procedure is to declare
466:19 - that alec returns a pointer to char and
466:21 - then explicitly coerce the pointer into
466:24 - the desired type with a cast
466:26 - therefore if p is declared as char star
466:30 - p semicolon then
466:32 - open paren struct t node star close
466:35 - paren p converts it into a t node
466:37 - pointer expression
466:38 - thus t alec is written as
466:41 - t node star t alec open paren close
466:44 - paren open curly brace char star alec
466:48 - return open paren open print struct t
466:51 - node star close print alec open paren
466:54 - sizeof open prin struct t node close
466:58 - prin close paren close print
467:01 - this is more than is needed for current
467:03 - compilers but represents the safest
467:05 - course for the future
467:09 - i would add
467:10 - that these concerns that the authors
467:12 - mentioned in this section are also
467:14 - nicely resolved in modern c compilers in
467:16 - the nc version of c they introduce the
467:18 - notion of the void type
467:20 - the void type indicates the lack of a
467:22 - type
467:23 - much like null is used to indicate not a
467:26 - valid pointer
467:27 - or not a flying toy
467:30 - in 1978 because the chart type was
467:33 - generally the most native type on any
467:34 - system it was often used as the generic
467:37 - pointer needed to return memory from an
467:39 - allocation function
467:41 - in modern c we use pointers to void and
467:43 - then cast the returning pointer
467:45 - to be a pointer to whatever struct or
467:47 - other data we just allocated
467:49 - if we were writing alec the alec routine
467:51 - in this book using modern c it would
467:53 - return a pointer to white
467:56 - the 1978 version is char star alec open
467:59 - paren close paren and the modern version
468:01 - is void star alec open paren close paren
468:07 - we've left the book alone we haven't
468:08 - used void throughout the book
468:10 - but it is a testament to the foresight
468:12 - of the authors
468:13 - that all the pointer casting code in
468:16 - this book still works today the same
468:20 - regardless of whether the memory
468:22 - allocation functions return char or void
468:24 - pointers to the allocated data
468:26 - sections 6.6 table lookup
468:30 - as an aside in this section we finish
468:33 - our quick tour of the implementations of
468:35 - the three core data structures in
468:36 - computer science
468:38 - one the linked list two the tree and
468:41 - three the hash map as described in this
468:43 - section
468:44 - a singly linked list is also part of a
468:46 - hashmap implementation so you can
468:48 - compare it
468:49 - to the doubly linked list code
468:50 - introduced in the earlier bonus section
468:52 - 6.5.1
468:55 - this section is worth understanding well
468:58 - because not only is it an excellent
468:59 - review of pointers and structures but
469:02 - also because one of the most common
469:04 - questions
469:05 - on a face-to-face programming interview
469:07 - is draw a hashmap on the whiteboard and
469:09 - explain how it works
469:11 - this is an easy question if you study
469:13 - and understand this section of the book
469:15 - and almost impossible if you have not
469:20 - in some ways this section is the most
469:22 - intricate data structure that's
469:23 - described in the book
469:24 - it is why it is so popular in coding
469:26 - interviews
469:28 - chapters 7 and 8 talk about lots of
469:30 - practical things like input output of
469:32 - the unix operating system
469:34 - elegant data structures and their use
469:36 - are core concepts in computer science
469:39 - understanding them highlights the
469:40 - difference between a good programmer and
469:43 - a computer scientist
469:45 - in a sense understanding how a hashmap
469:48 - is the secret handshake of computer
469:50 - science
469:51 - and it is the secret handshake
469:54 - because of this book and this section of
469:57 - this book
469:58 - written back in 1978
470:01 - and used in a course
470:03 - that the person interviewing you may
470:05 - have took when they were in college
470:08 - hash maps were difficult for them to
470:10 - understand back then and so if you
470:12 - understand the concept then you must be
470:14 - solid
470:16 - so i hope you pay close attention to
470:19 - this section and remember the handshake
470:22 - back to the text
470:25 - in this section we will write the
470:26 - innards of a table lookup package as an
470:29 - illustration of more aspects of
470:30 - structures this code is typical of what
470:33 - might be found in the symbol table
470:34 - management routines of a macro processor
470:37 - or a compiler
470:38 - for example consider the c pound define
470:41 - statement when a line like pound define
470:43 - yes one is encountered the name
470:46 - replacement text
470:47 - the name yes and the replacement text
470:49 - one are stored in a table
470:52 - later when the name yes appears in a
470:53 - statement like inward equals yes
470:55 - semicolon it must be replaced by one
470:59 - there are two major routines that
471:01 - manipulate the names and replacement
471:03 - texts
471:04 - install open paren s comma t close paren
471:07 - records the name s and replacement t in
471:10 - the table
471:11 - s and t are just character strings
471:14 - lookup open paren s close print searches
471:16 - for s in the table and returns a pointer
471:19 - to the place where it was found or null
471:21 - if it wasn't there
471:23 - the algorithm used is a hash search the
471:26 - incoming name is converted to a small
471:29 - positive integer which is then used to
471:31 - index into an array of pointers
471:34 - an array element points to the beginning
471:36 - of a chain of blocks describing the
471:38 - names that have the hash value
471:40 - and if it is null then no names have
471:43 - hashed to that value
471:45 - a block in the a block in the chain is a
471:48 - structure containing pointers to the
471:50 - name the replacement text and the next
471:52 - block in the chain
471:54 - a null next pointer marks marks the end
471:57 - of the chain
471:59 - struct and list open paren
472:02 - char star name semicolon char star def
472:06 - semicolon
472:08 - struct
472:09 - endless star next semicolon close curly
472:12 - brace semicolon
472:15 - the pointer array is just pound define
472:18 - hash size 100
472:21 - static struct and list star hash tab
472:25 - open square bracket hash size close
472:27 - square bracket semicolon
472:30 - the hashing function which is used by
472:32 - both lookup and install simply adds up
472:35 - the character values in the string and
472:37 - forms the remainder modulo
472:40 - the array size this is not the best
472:42 - possible
472:43 - algorithm but it has the merit of
472:45 - extreme simplicity
472:48 - hash open paren s close paren char star
472:52 - s semicolon open curly brace int hash
472:56 - val
472:58 - four
472:58 - open curly brace hash val equals zero
473:02 - star s not equal quote single quote
473:05 - backslash zero single quote semicolon
473:08 - close paren
473:10 - hash val plus equals star s plus plus
473:14 - semicolon
473:16 - return open paren hash val modulo
473:20 - percent hash size close paren semicolon
473:23 - close curly brace
473:25 - as an aside
473:27 - hashing functions are one of the
473:28 - foundational notions in computer science
473:32 - hashing functions are used for
473:33 - everything from high performance
473:35 - in-memory structures
473:36 - organizing databases
473:39 - data digital signing network packet
473:41 - checksums security algorithms and much
473:44 - more
473:45 - the above text is a really great example
473:49 - of a really simple hashing function
473:52 - you should understand this simple
473:54 - presentation well so that when you
473:56 - encounter a more complex implementation
473:59 - or use of hashing you can fall back on
474:01 - this text to understand that at its core
474:05 - hashing is a very simple concept
474:09 - so much of this chapter is a succinct
474:11 - example of some of the most powerful
474:14 - concepts in computer science
474:16 - please don't look at the eight code
474:18 - lines of code above and think i got that
474:20 - and just jump to the next bit
474:22 - this chapter is showing you the way of
474:24 - the master programmer
474:27 - wax on
474:28 - wax off
474:30 - be patient
474:31 - slow down
474:33 - and enjoy your time here
474:36 - back to the text the hashing process
474:39 - produces a starting index in the array
474:41 - hashtag if the string is to be found
474:43 - anywhere it will be in the chain of
474:45 - blocks beginning there
474:47 - the search is performed by lookup
474:49 - if lookup finds the entry already
474:51 - present it just returns a pointer to it
474:53 - if not it returns null
474:56 - here's the code struct and list star
474:59 - lookup open paren s close paren
475:03 - char star s
475:04 - semicolon open curly brace
475:08 - struct and list star np semicolon
475:13 - for
475:14 - open paren np equals tab sub hash open
475:18 - paren s close paren
475:22 - close square bracket semicolon np not
475:24 - equal null semicolon np equals np right
475:28 - arrow next close parenthesis
475:31 - if stir comp open print s comma np right
475:34 - arrow name close paren double equals
475:36 - zero return open print np close paren
475:39 - semicolon
475:42 - return open print null close print
475:44 - semicolon close curly brace
475:46 - install uses lookup to determine whether
475:49 - the name installed is already present if
475:51 - so the new definition must supersede the
475:54 - old one
475:55 - otherwise a complete newly new entry is
475:58 - created
475:59 - install returns no
476:00 - if for any reason there's no room for a
476:02 - new entry
476:06 - struct and list star install open friend
476:10 - name common death close paren
476:12 - jar star name comma star def semicolon
476:16 - open curly brace
476:17 - struct
476:18 - endless star np comma star lookup open
476:22 - print close brand semicolon char
476:25 - stir save comma star alec open print
476:28 - close paren semicolon
476:29 - int
476:30 - val semicolon
476:33 - if open paren open paren np equals
476:36 - lookup open paren name close paren close
476:38 - print double equal null
476:41 - close paren open curly brace i.e it's
476:44 - not found np
476:46 - equals open paren struct end list star
476:49 - close paren alec open paren size of open
476:52 - paren star np close paren close paren
476:55 - semicolon
476:57 - np equals null return null that means
477:00 - the allocation failed
477:02 - if open paren open paren np right arrow
477:05 - name
477:06 - equals
477:08 - stir save open paren name close print
477:10 - close paren double equals null close
477:12 - paren return
477:14 - open paren
477:15 - null close paren semicolon
477:20 - hash val
477:21 - equals
477:24 - open paren np right arrow name close
477:28 - brand semicolon
477:30 - np next equals
477:32 - tab open square bracket hash val close
477:35 - for bracket second semicolon
477:38 - hash tab open square bracket hash valve
477:41 - close spur bracket equals np semicolon
477:44 - we're actually pushing these new ones to
477:47 - the head of this singly linked list
477:50 - and so those last two
477:52 - statements push the the most recent top
477:55 - of the list
477:56 - forward and then replace with the new
477:59 - one at the top of the list the list does
478:00 - not stay in any order
478:04 - so
478:07 - we have a closed curly brace to end all
478:09 - that if for the not found code
478:12 - close curly brace else this is the
478:14 - already code click already their code
478:17 - free
478:18 - open paren np right arrow def close
478:21 - paren semicolon
478:22 - free the previous definition
478:24 - that's the string part of the
478:27 - the
478:28 - the pound define
478:30 - if open paren np
478:32 - right arrow def
478:34 - equal stir save open paren def close
478:37 - print close print
478:39 - equals null close print return open
478:42 - paren null close paren semicolon
478:44 - return open print np close print
478:47 - semicolon close curly brace so that last
478:50 - bit there was to
478:53 - if you have a pound define with the same
478:57 - keyword and a different later you have
479:00 - it later a different uh definition you
479:02 - can replace the definition so that last
479:04 - bit was replacing the definition
479:06 - again this code is a pretty intricate
479:09 - it's really both the hash table and a
479:11 - singly linked list going on at the same
479:13 - time so take a close look at this on
479:16 - page 136 of the book
479:20 - stir save merely copies the string given
479:22 - its argument to a safe space obtained by
479:25 - a call to alec we've showed this code in
479:27 - chapter five since calls to alec and
479:29 - free may occur in any order and since
479:31 - alignment matters the simple version of
479:33 - alec
479:34 - is just not adequate here
479:37 - see more in chapters 7 and 8.
479:42 - as an aside one of the reasons that the
479:43 - authors make vague forward-looking
479:45 - statements we know that they talk about
479:46 - dynamic memory is that large-scale
479:48 - memory management in a programming
479:50 - language is still a subject of active
479:52 - research 40 years later
479:55 - back in 1978 it was absolutely not a
479:58 - settled topic you can see this when the
480:00 - authors build a simple non-production
480:02 - memory allocation scheme with their own
480:04 - alec and free routines backed by a fixed
480:07 - length static extern array of characters
480:10 - dynamic allocation is essential to
480:12 - writing competency programs but it is
480:14 - likely that the production grade dynamic
480:16 - memory support was still somewhat
480:17 - non-portable when the book was written
480:19 - so they used simple self-contained
480:21 - implementations in this book
480:23 - modern dynamic memory support is through
480:26 - the mala c alec and free functions in
480:28 - the standard library these functions
480:30 - request dynamic memory blocks from the
480:32 - operating system and manage those areas
480:34 - on behalf of your c code
480:36 - on unix and unix-like systems the memory
480:39 - allocation layer asks the underlying
480:41 - operating systems for blocks of memory
480:43 - through the sbrk interface
480:46 - even with virtual memory programmers
480:48 - must carefully manage their use of
480:50 - dynamically allocated memory because
480:52 - memory is never unlimited
480:55 - section 6.7 fields
480:58 - when storage space is at a premium it
481:00 - may be necessary to pack several objects
481:02 - into a single machine word
481:05 - one especially common use is a set of
481:07 - single bit at flags in applications like
481:09 - compiler symbol tables
481:11 - externally imposed data formats such as
481:13 - interfaces to hardware devices also
481:16 - often require the ability to get at
481:18 - pieces of a word
481:20 - as an aside we are going to go now from
481:23 - low level programming to even lower
481:26 - level programming
481:27 - the unix operating system is written in
481:29 - c and unix needs to have for example an
481:32 - implementation of the internet protocol
481:34 - so it can be connected to the internet
481:36 - one of the most important internet
481:37 - protocols is the transmission control
481:39 - protocol tcp
481:42 - in order to implement tcp you need to
481:44 - send very precisely formatted data
481:46 - across the network the data is very
481:48 - tightly packed in order to save precious
481:51 - network bandwidth the exact format of a
481:54 - tcp header is described in the tcp
481:57 - wikipedia page
481:58 - if you look at the header you will find
482:00 - that it bits 96 through 99
482:03 - tcp expects a four bit integer that
482:06 - defines the data offset
482:09 - exactly what this data means is less
482:11 - relevant unless you're actually writing
482:12 - the tcp implementation but it does
482:15 - demonstrate that we need to control our
482:17 - data layout at times on a bit by bit
482:19 - basis
482:20 - this section covers how we can use
482:22 - struct to build up a tcp header in c
482:26 - which can be parsed and set without
482:27 - using masking and shifting operations
482:29 - with hard-coded numbers
482:31 - the section below is simpler than
482:32 - constructing a valid tcp header using a
482:34 - carefully packed struct but it does lay
482:36 - the groundwork for these more complex
482:38 - situations
482:40 - now back to the text
482:42 - imagine a fragment of a compiler that
482:44 - manipulates a symbol table
482:46 - each identifier in a program has certain
482:49 - information associated with it for
482:50 - example whether or not it's a keyword
482:53 - whether or not it's external and or
482:54 - static and so on the most compact way to
482:57 - encode such an information is a set of
482:59 - one-bit flags in a single char or int
483:02 - the usual way this is done is define a
483:04 - set of masks
483:06 - corresponding to the relevant bit
483:08 - positions as in
483:10 - pound-defying keyword 0-1 pound-define
483:13 - external 0-2 and pound defined static 0
483:16 - 4. the numbers of course must be powers
483:18 - of 2 so that the shifting works
483:21 - then accessing the bits become a matter
483:23 - of bit fiddling with shifting masking
483:25 - and complementing operators which were
483:27 - described in chapter 2.
483:29 - certain idioms of fear appear frequently
483:32 - flags
483:33 - vertical par equals external vertical
483:35 - bar static
483:36 - turns on the external and static bits
483:39 - and flags while flags ampersand equal
483:42 - tilled open paren external or static
483:45 - closed paren semicolon turns them off
483:48 - and if open paren open print flags
483:52 - ampersand paren external vertical bar
483:55 - static close paren close print equal
483:57 - equal zero
483:58 - dot dot dot is true if both bits are off
484:02 - although these idioms are readily
484:04 - mastered as an alternative c offers the
484:07 - capability of defining and accessing
484:09 - fields within a word directly rather
484:11 - than by bitwise logical operators
484:14 - a field is a set of adjacent bits within
484:16 - a single int the syntax of field
484:19 - definition and access is based on
484:21 - structures for example the symbol table
484:24 - palm defines above could be replaced by
484:26 - the definition of three fields
484:29 - struct
484:30 - unsigned is keyword colon one semicolon
484:35 - unsigned is extern colon one semicolon
484:39 - unsigned is static colon 1 semicolon
484:42 - closed curly brace flags
484:45 - this defines a variable called flags
484:47 - that contains three 1-bit fields the
484:50 - number following the colon
484:52 - represents the field width in bits
484:54 - the fields are declared unsigned to
484:56 - emphasize that they are really unsigned
484:58 - quantities
485:00 - individual fields are referenced as
485:02 - flags.is keyword
485:04 - flags.is extern etc just like other
485:07 - structure members
485:09 - fields behave like small unsigned
485:10 - integers and may partic participate in
485:13 - arithmetic expressions just like the
485:15 - other integers thus the previous
485:17 - examples may be written much more
485:18 - naturally as
485:20 - flags is underscore extern equals flags
485:24 - is static equals one semicolon
485:28 - turn the bits on
485:31 - flags is extern equals flags is static
485:35 - equals one semicolon to turn the bits on
485:38 - flags dot is extern equals flags dot is
485:41 - static equals zero turns them off
485:44 - and if open paren flags dot is extern
485:47 - double equals zero and flags dot is
485:50 - static double equals zero close paren
485:52 - dot dot to test them
485:55 - a field may not overlap an int boundary
485:58 - if the width would cause this to happen
486:00 - the field is aligned to the next in
486:02 - boundary fields need not be named
486:04 - unnamed fields with a colon and width
486:07 - only are used for padding the special
486:09 - width 0 may be used to force alignment
486:11 - to the next int boundary there are a
486:14 - number of caveats that apply to fields
486:15 - perhaps the most significant
486:17 - fields are assigned left to right on
486:19 - some machines and right to left on
486:22 - others reflecting the nature of
486:23 - different hardware
486:24 - this means that although fields are
486:26 - quite useful for maintaining internally
486:28 - defined data structures the question of
486:31 - which end comes first have to has to be
486:33 - carefully considered when picking apart
486:36 - externally defined data
486:38 - other restrictions to bear in mind
486:40 - fields are unsigned they may only be
486:42 - stored in ins or equivalently unsigned
486:45 - they are not arrays and they do not have
486:47 - addresses so the ampersand operator
486:49 - cannot be applied to them
486:51 - section 6.8 unions
486:54 - a union is a variable which may hold at
486:56 - different times
486:58 - objects of different types and sizes
487:00 - with the compiler keeping track of the
487:02 - size and alignment requirements
487:04 - unions provide a way to manipulate
487:06 - different kinds of data in a single area
487:08 - of storage without embedding any machine
487:11 - dependent information in the program for
487:14 - example again from a compiler symbol
487:16 - table suppose constants may be ins
487:19 - floats or character pointers the value
487:22 - of a particular constant must be stored
487:23 - in a variable of the proper type yet it
487:26 - is most convenient for table management
487:28 - if the value occupies the same amount of
487:30 - storage and is stored in the same place
487:33 - regardless of its type
487:35 - this is the purpose of a union to
487:37 - provide a single variable which can
487:39 - legitimately hold one of several types
487:42 - as with fields the syntax is based on
487:45 - structures
487:47 - union
487:48 - u tag open curly brace int ival
487:51 - semicolon float f val semicolon char
487:55 - star p-val semicolon closed curly brace
487:58 - u-val
487:59 - the variable u-val will be large enough
488:02 - to hold the largest of these three types
488:03 - regardless of the machine it is compiled
488:05 - of
488:06 - compiled on
488:07 - the code is independent of hardware
488:09 - characteristics any one of these types
488:12 - may be assigned to uval and then used in
488:14 - expressions so long as the usage is
488:16 - consistent the type retrieved must be
488:19 - the type most recently stored it is the
488:21 - responsibility of the programmer to keep
488:23 - track of what type is currently stored
488:25 - in the union the results are machine
488:27 - defendant dependent if something is
488:30 - stored as one type and extracted as
488:32 - another type
488:34 - syntactically members of a union are
488:36 - accessed as union name dot member or
488:40 - union pointer right arrow member
488:43 - justice for structures
488:45 - if the variable you type is used to keep
488:47 - track of the current type start in uval
488:49 - then one might see code as if open paren
488:53 - you type double equals int close paren
488:56 - printf
488:57 - paren
488:59 - double quote percent d backslash n
489:01 - double quote comma
489:02 - uval dot ival close parent semicolon
489:06 - else if
489:07 - open paren you type double equal float
489:09 - close paren
489:10 - print f
489:12 - open paren double quote percent f
489:14 - backslash n double quote comma u val dot
489:17 - f val
489:19 - close paren semicolon else if open paren
489:22 - you type double equals string close
489:24 - paren print f
489:25 - double quote percent s backslash n
489:28 - double quote comma u val dot p val close
489:31 - paren semicolon
489:33 - else printf
489:34 - open paren double quote bad type percent
489:37 - d and you type backslash n double quote
489:40 - comma you type
489:41 - close paren semicolon
489:46 - unions may occur in structures and
489:49 - arrays and vice versa the notion for
489:51 - accessing a member of a union in a
489:53 - structure or vice versa is identical
489:55 - that to that for nested structures
489:58 - for example in the structure array
490:00 - defined by struct
490:02 - open curly brace char star name
490:05 - semicolon int flags semicolon
490:08 - and you type semicolon
490:10 - union open curly brace
490:13 - int ival semicolon float f val semicolon
490:16 - char star p val semicolon
490:19 - close curly brace u val semicolon close
490:23 - curly brace sim tab open square bracket
490:26 - end sim close square bracket
490:29 - the variable i val is referred to as
490:33 - sim tab sub i dot u val dot ival
490:37 - and the first character of the string p
490:39 - val by star
490:41 - sim tab sub i
490:43 - dot uofl.pival
490:46 - in effect a union is a structure in
490:48 - which all the members have offset zero
490:50 - the structure is big enough to hold the
490:52 - widest member and the alignment is
490:54 - appropriate for all types in the union
490:57 - as with structures the only operations
490:59 - currently permitted on unions are
491:01 - accessing a member and taking the
491:03 - address
491:04 - unions may not be assigned to pass to
491:06 - functions or returned by functions
491:08 - pointers to unions can be used in a
491:10 - manner identical to pointers to
491:11 - structures
491:14 - as it aside the above limitations on
491:16 - unions are just no longer accurate like
491:18 - structures modern c compilers can assign
491:20 - the contents of the union to another
491:22 - union variable you can also pass unions
491:25 - into functions by value and receive a
491:28 - union as the return type of a function
491:30 - the storage allocator in chapter 8 shows
491:32 - how a union can be used to force a
491:34 - variable to be aligned on a particular
491:37 - kind of storage
491:38 - boundary section 6.9 type def
491:43 - c provides a facility called typedef for
491:45 - creating new data type names for example
491:49 - the declaration type def space int space
491:52 - length semicolon
491:54 - makes the name length a synonym for end
491:58 - the type length can be used in
492:00 - declarations cast etc in exactly the
492:03 - same ways int can be
492:06 - length len comma maxlen semicolon length
492:09 - star lengths open square bracket close
492:11 - four bracket semicolon
492:15 - similar the declaration type def char
492:19 - star string semicolon makes string a
492:23 - synonym for char star or a character
492:26 - pointer which then may be used in
492:28 - declarations like string
492:30 - p
492:31 - comma line ptr open square bracket lines
492:34 - close square bracket comma alec open
492:36 - paren close paren semicolon
492:39 - note that the type being declared in a
492:41 - typedef appears in the position of a
492:43 - variable name
492:45 - not right after the word typedef
492:47 - syntactically typedef is like the
492:50 - storage class
492:51 - extern static etc
492:54 - we've used uppercase letters in these
492:56 - examples to emphasize the names
493:00 - a more complicated example we could make
493:02 - typedefs for the tree nodes shown
493:03 - earlier in the track chapter
493:06 - typedef struct t node open curly brace
493:10 - char star word semicolon hint count
493:13 - semicolon struct t node star left
493:17 - semicolon struct t node star right
493:20 - semicolon close curly brace
493:23 - tree node comma star tree ptr
493:28 - this creates three two new type keywords
493:31 - called tree node which is a structure
493:33 - and tree ptr which is a pointer to the
493:36 - structure
493:37 - then the routine t alec could become
493:40 - tree ptr t alec open paren close print
493:43 - open curly brace char star alec
493:46 - open print close paren semicolon return
493:49 - open paren open paren tree ptr close
493:52 - print alloc open print size f open paren
493:57 - tree node close print close paren closed
493:59 - brand semicolon closed curly brace
494:03 - it should be emphasized that a typedef
494:05 - declaration does not exactly create a
494:07 - new type in any sense
494:10 - it merely adds a new name for some
494:11 - existing types nor are there any new
494:14 - semantics
494:15 - variables declared this way have exactly
494:17 - the same property as variables who
494:19 - whose declarations are spelled out
494:21 - explicitly
494:22 - in effect typedef is like defined
494:26 - except that since it's interpreted by
494:27 - the compiler it can cope with textual
494:30 - substitutions that are beyond the
494:32 - capabilities of the c macro preprocessor
494:35 - for example
494:37 - typedef int
494:38 - open paren star
494:40 - pfi close print
494:43 - open for enclosed print semicolon
494:45 - creates
494:46 - the type pfi
494:48 - to mean
494:49 - pointer to a function returning integer
494:52 - which can be used in context like
494:54 - pfi stir comp comma num comp comma swap
494:59 - in the sort program in chapter 5.
495:01 - there are two main reasons for using
495:03 - typedef declaration
495:05 - the first is to parameterize a program
495:07 - against portability problems if type
495:09 - defs are used
495:11 - for the data types which may be machine
495:13 - dependent only typedefs need to change
495:15 - when the program is moved
495:17 - one common situation is to use typedef
495:19 - names for various integer quantities and
495:22 - then make an appropriate set of choices
495:24 - of short int and long for each host
495:28 - machine
495:29 - the second purpose of type defs is to
495:31 - provide better documentation for a
495:33 - program a type called tree ptr may be
495:37 - easier to understand
495:38 - than one declared only as a pointer to a
495:41 - complicated structure
495:43 - finally there's always the possibility
495:45 - that the futures a compiler or some
495:48 - other program such as lind may make use
495:50 - of the information contained in typedef
495:52 - declaration to perform some extra
495:55 - checking on the program
495:58 - this work
495:59 - is based on the 1978 c programming book
496:02 - written by brian w kernighan and dennis
496:04 - m ritchie their book is copyright all
496:07 - rights reserved by at t
496:09 - but is used in this work under fair use
496:12 - because of the book's historical and
496:14 - scholarly significance
496:16 - its lack of availability and the lack of
496:18 - an accessible version of the book
496:20 - the book is augmented in places to help
496:22 - understand its rightful place in a
496:24 - historical context amidst the major
496:26 - changes of the 1970s and 1980s as
496:29 - computer science evolved from a
496:31 - hardware-first vendor-centered approach
496:33 - to a software-centered approach where
496:35 - portable operating systems and
496:36 - applications written in c could run on
496:39 - any hardware
496:41 - this is not the ideal book to learn c
496:43 - programming because the 1978 edition
496:45 - does not reflect the modern c language
496:48 - using an obsolete book gives us an
496:50 - opportunity to take students back in
496:52 - time and understand how the c language
496:55 - was evolving as it laid the groundwork
496:57 - for a future with portable applications
497:03 - chapter 7 input and output
497:06 - input and output facilities are not part
497:09 - of the c language so we've de-emphasized
497:11 - them in our presentation thus far
497:14 - nonetheless real programs do interact
497:16 - with their environment in much more
497:18 - complicated ways than those we've shown
497:20 - before
497:22 - in this chapter we will describe this
497:24 - standard io library
497:26 - a set of functions designed to provide a
497:28 - standard i o system for c programs
497:30 - the functions are intended to present a
497:32 - convenient programming interface yet
497:35 - reflect only operations that can be
497:37 - provided on most modern operating
497:39 - systems
497:40 - the routines are efficient enough that
497:42 - users should seldom feel the need to
497:44 - circumvent them for efficiency
497:46 - regardless of how critical the
497:47 - application
497:49 - finally the routines are meant to be
497:51 - portable
497:52 - in the sense that they will exist
497:54 - in compatible form on any system or c
497:56 - exists and that programs which confine
497:59 - themselves
498:01 - to facilities provided by the stated
498:03 - library can be moved from one system to
498:05 - another essentially without change
498:08 - we will not try to describe the entire
498:10 - io library here we are more interested
498:12 - in showing the essentials of writing c
498:14 - programs that interact with our
498:15 - operating system environment
498:18 - section 7.1
498:19 - access to the standard library
498:22 - each source file that refers to the
498:24 - standard library function must contain
498:26 - the line pound include stdio.h near the
498:29 - beginning
498:30 - the file
498:32 - stdio.h defines certain macros and
498:34 - variables used by the i o library
498:37 - the use of angle brackets less than and
498:40 - greater than instead of the usual double
498:42 - quotes directs the compiler to search
498:44 - for the file in a directory containing
498:46 - the standard header information
498:48 - in unix this is often somewhere like
498:51 - slash user slash include
498:54 - furthermore it may be necessary when
498:56 - loading the program to specify the
498:57 - library explicitly for example on the
499:00 - pdp-11 unix system the command to
499:02 - compile a program would be
499:04 - cc
499:06 - source files etc
499:08 - dash ls capital s
499:11 - where dash l capital s indicates loading
499:13 - from the standard library
499:16 - section 7.2
499:20 - standard input and output
499:22 - catch our input char
499:24 - the simplest input mechanism is to read
499:26 - a character at a time from the standard
499:29 - input generally the user's terminal or
499:31 - keyboard with getchar getchar returns
499:34 - the next input character each time it's
499:36 - called
499:37 - in most environments that support c
499:39 - a file may be substituted for the
499:41 - terminal by using the less than config
499:43 - convention
499:44 - if a program prog uses get char then the
499:47 - command line prog less than infile
499:51 - causes probe to read infile instead of
499:53 - the terminal
499:54 - or keyboard
499:55 - the switching of input is done in such a
499:57 - way that prog is oblivious to the change
499:59 - in particular the string less than
500:01 - infile is not included in the command
500:04 - line arguments in argv
500:06 - the input switching is also invisible if
500:08 - the input comes from another program by
500:10 - a pipe mechanism
500:12 - the command line other probe vertical
500:15 - bar prog
500:16 - runs two programs other prog and prog
500:18 - and arranges for the standard input for
500:20 - prog to come from the standard output of
500:23 - other prog
500:25 - cat char returns the value eof when it
500:28 - encounters end-to-file on whatever input
500:30 - is being read the standard library
500:32 - defines the symbolic eof constant to be
500:35 - -1 with a pound defined in the file
500:38 - stdio.h
500:40 - but test should be written in terms of
500:42 - eof not negative 1. so is to be
500:45 - independent of the specific value for
500:47 - output put char open paren c close paren
500:51 - puts the character c on the standard
500:53 - output which is also by default the
500:56 - terminal
500:57 - or screen
500:58 - the output can be directed to a file by
501:00 - using greater than
501:02 - if probe uses put char prog greater than
501:05 - out file will write the standard output
501:06 - onto outfile instead of the terminal
501:09 - on the unix system a pipe can also be
501:11 - used
501:12 - prog vertical bar another prog puts the
501:15 - standard output of prog into the
501:17 - standard input of other prog
501:20 - again
501:20 - prog is not aware of the redirection
501:25 - output produced by printf also finds its
501:27 - way to the standard output and calls to
501:29 - put char and printf may be interleaved
501:32 - a surprising number of programs read
501:34 - only one input stream and write only one
501:37 - output stream
501:38 - for such programs i o with getchart
501:41 - putchar and printf may be entirely
501:43 - adequate and is certainly enough to get
501:45 - started
501:46 - this is particularly true given file
501:48 - redirection in a pipe file for
501:50 - connecting the output of one program to
501:51 - the input of the next
501:53 - for example consider the program lower
501:56 - which maps
501:57 - input to lower case
501:59 - this is an example on page 145 with a
502:02 - textbook that you can see at
502:04 - www.cc4e.com
502:08 - code pound include stdio.h
502:12 - pound includes c type dot h
502:15 - main open print close paren
502:17 - open curly brace int c
502:20 - while open paren open paren c equals get
502:23 - char open paren close paren close print
502:25 - not equal to eof close paren
502:29 - put char
502:30 - is upper open paren c close paren
502:32 - question mark two lower open paren c
502:35 - close paren colon c close paren
502:38 - semicolon close curly brace
502:42 - the functions is upper and two lower are
502:44 - actually macros defined in c type dot h
502:47 - the macro is upper tests whether its
502:49 - argument is an uppercase letter
502:50 - returning non-zero if it is and zero if
502:52 - it's not the macro two lower converts an
502:55 - uppercase to lowercase letter
502:57 - regardless of how these functions are
502:59 - implemented on a particular machine
503:00 - their external behavior is the same
503:02 - so programs that use them are shield
503:04 - shielded from the knowledge of their
503:06 - character set
503:07 - to convert multiple files you can use a
503:10 - program
503:11 - like the unix cat to collect files cat
503:15 - file1 file2.verticalbar
503:18 - lower greater than output and thus avoid
503:21 - learning how to access files from a
503:22 - program
503:24 - the cad example is presented later as
503:26 - example code in this chapter
503:28 - as an aside
503:30 - the standard io library functions
503:32 - getchar and put char can actually be
503:35 - macros and thus
503:37 - avoid the overhead of a function call
503:39 - per character we'll show this how this
503:41 - is done in chapter 8.
503:44 - section 7.3 formatted output printf
503:48 - the two routines printf for output and
503:51 - scanf f4 input which we describe in the
503:53 - next section permit translation to and
503:55 - from character representations of
503:57 - numerical quantities
503:59 - they also allow generation or
504:00 - interpretation of formatted lines
504:03 - we've used printf informally throughout
504:05 - the previous chapters here is a more
504:07 - complete and precise description
504:10 - printf open paren control com arg1 comma
504:13 - card 2 etc close paren
504:16 - printf converts formats and prints its
504:19 - arguments on the standard output under
504:21 - this under the control of the string
504:23 - control the control string contains two
504:26 - type of objects ordinary characters
504:28 - which are simply copied to the output
504:30 - stream
504:31 - and conversion specifications each of
504:33 - which causes conversion and printing of
504:36 - the next successive argument to printf
504:39 - each conversion specification is
504:41 - introduced by the character sense sign
504:43 - and ended by a conversion character
504:46 - between the percent and the conversion
504:48 - character there may be a minus sign
504:50 - which specifies left adjusted of the
504:53 - left adjustment of the converted
504:54 - argument in its field
504:56 - a digit string specified a minimum field
504:59 - width
505:00 - the converted number will be printed in
505:02 - a field at least this wide and wider if
505:04 - necessary
505:05 - if the converted argument has fewer
505:07 - characters than the field it will be
505:09 - padded on the left or right if the left
505:12 - adjustment indicator's been given to
505:14 - make up the field width
505:16 - the padding character is normally blank
505:18 - in zero if the field width is specified
505:21 - with a leading zero
505:22 - this zero does not imply an octal field
505:25 - with
505:26 - a period
505:27 - which separates the field width from the
505:28 - next digit string
505:30 - a digit string
505:32 - that specifies the precision which
505:34 - specifies the maximum number of
505:35 - characters to be printed from a string
505:37 - or the number of digits to be printed to
505:39 - the right of the decimal point of a
505:41 - float or a double
505:43 - a length modifier the letter l
505:46 - which indicates that the corresponding
505:49 - data item is along rather than an end
505:54 - conversion characters and their meanings
505:56 - are
505:57 - d
505:58 - the arguments converted to decimal
505:59 - notation o the argument is converted to
506:02 - unsigned octal notation without a
506:04 - leading zero
506:05 - x
506:06 - the argument is converted to unsigned
506:08 - hexadecimal notation without the leading
506:10 - 0x
506:12 - u the argument is converted to unsigned
506:14 - decimal notation
506:16 - c
506:17 - the argument is taken to be a single
506:19 - character
506:20 - s the argument is a string
506:23 - characters from the string are printed
506:24 - until a null character is reached or the
506:26 - number of characters indicated by the
506:28 - present precision specification is
506:30 - exhausted
506:32 - e the argument is taken to be a float or
506:34 - a double and converted to decimal
506:36 - notation of the form
506:38 - optional minus sign
506:40 - m dot nnn
506:42 - capital e plus or minus xx where the
506:45 - length of the string of the ends is
506:46 - specified by the precision the default
507:03 - by precision
507:04 - the default precision is 6.
507:06 - note that the precision does not
507:08 - determine the number of significant
507:09 - digits printed in the f format
507:13 - g
507:14 - says use percent e or percent f which
507:17 - ever is shorter
507:19 - and non-significant zeros are not
507:20 - printed
507:22 - if the character after the percent is
507:24 - not a conversion character the character
507:26 - is simply printed thus percent may be
507:29 - printed as percent percent
507:32 - most of the format conversions are
507:34 - obvious and have been illustrated in the
507:36 - earlier chapter
507:37 - one exception is the precision field as
507:40 - it relates to strings the following
507:42 - table shows the effect of a variety of
507:45 - specifications in printing hello comma
507:47 - world which is 12 characters we put
507:50 - colons around each field so you can see
507:52 - its actual width
507:54 - colon percent 10 s colon
507:58 - colon hello world colon
508:01 - it's 12 characters long
508:03 - and so we get 12 characters printed
508:05 - because we haven't really told it to
508:06 - strictly limit that
508:09 - colon percent minus 10 s colon
508:12 - colon hello comma world colon no extra
508:15 - spaces
508:16 - again 12 characters are used even though
508:19 - if we said 10 it expands it to 12 and
508:22 - the fact that it's left justified seems
508:23 - how we're printing more than the width
508:25 - of the field
508:26 - doesn't make any difference
508:28 - colon percent 20 s colon
508:32 - colon eight spaces then hello comma
508:35 - world colon
508:36 - eight spaces are put in on the left
508:38 - because it by default is right justified
508:42 - colon
508:43 - percent minus 20 s colon
508:47 - prints colon hello comma world and then
508:50 - eight spaces and then colon
508:52 - we've told it to left justify so the
508:54 - eight spaces are added to fill it out to
508:56 - 20 spaces after hello world
509:00 - colon percent 20.10 s colon
509:04 - gives us colon and then 10 blanks and
509:07 - then hello comma w o r colon
509:10 - now in this case we've told it we really
509:13 - only want 10 characters from the string
509:15 - and so the the ld is truncated
509:19 - percent minus 20.10 s colon
509:24 - hello comma w o r
509:27 - and then 10 spaces
509:29 - and it's less justified so the ten
509:30 - spaces are at the end
509:32 - right before the colon
509:34 - colon percent dot 10 s colon colon hello
509:39 - comma wor colon so now the overall field
509:42 - that's printed is exactly 10 characters
509:44 - and it is the leftmost 10 characters
509:49 - warning
509:50 - printf uses its first argument to decide
509:53 - how many arguments follow and what their
509:55 - types are it will get confused and you
509:57 - will get nonsense answers if there are
509:59 - not arguments enough arguments or they
510:02 - are of the wrong
510:04 - type as an aside formatted output is
510:08 - difficult the design of c printf was
510:10 - inspired by the earlier format statement
510:13 - in fortran and alcohol in order to
510:15 - compete with those languages c needed to
510:17 - ship with solid support for formatted
510:19 - output the approach chosen by c
510:21 - percolated into c like languages php and
510:24 - java simply have a function called
510:26 - printf that mimics most of the c formats
510:30 - python has evolved its approach to
510:32 - formatted output over the years an early
510:35 - initial solution had a syntax that used
510:37 - percent to provide c like formatting
510:39 - there was also a format method on the
510:41 - string object
510:44 - for example
510:45 - x
510:47 - equals 421.34
510:51 - print open paren double quote x is
510:53 - percent 7.2 f
510:56 - double quote percent open paren x comma
510:59 - close paren close paren
511:02 - that uses the percent operator and sends
511:04 - a tuple but the syntax of percent seven
511:07 - point two f is the same another option
511:10 - is
511:10 - print open paren double quote x is
511:14 - open curly brace y colon 7.2 f
511:19 - close curly brace double quote dot
511:21 - format open paren y equals x close paren
511:25 - close paren
511:26 - this sends a set of key value pairs
511:30 - and it's a little clunky
511:33 - the latest and least clunky way to do it
511:36 - in modern python is what we call f
511:38 - strings
511:39 - and the code is print
511:41 - f double quote
511:45 - print open paren f double quote x is
511:49 - open curly brace x colon 7.2 f close
511:53 - curly brace double quote close paren
511:57 - but even after all this evolution much
511:59 - of this output formatting still traces
512:01 - its design inspiration from the nc
512:03 - printf capabilities back in 1978.
512:10 - formatted input scanf
512:12 - the function scanf is the input analog
512:15 - of printf providing many of the same
512:17 - conversion facilities but in the
512:19 - opposite direction
512:21 - scanf open paren control com arg1 comma
512:24 - r2 etc close paren scanf reads
512:27 - characters from standard input
512:28 - interprets them according to the format
512:30 - specified in control and stores the
512:32 - results in the remaining arguments the
512:34 - control argument is described below
512:37 - the other arguments each of which must
512:39 - be a pointer
512:41 - indicate where the converting
512:42 - corresponding converted input should be
512:45 - stored
512:46 - the control string usually contains
512:48 - conversion specifications which are used
512:50 - to direct interpretation of input
512:52 - sequences
512:53 - the control string may contain blanks
512:56 - tabs or new lines we call these white
512:58 - space characters which are ignored
513:00 - ordinary characters
513:02 - not
513:02 - percent which are expected to match the
513:04 - next non-white character space character
513:07 - of the input stream
513:08 - conversion specifications consisting of
513:11 - the character percent an optional
513:13 - assignment suppression character
513:14 - asterisk
513:15 - and an optional number specifying the
513:17 - maximum field width and a conversion
513:19 - character
513:21 - a conversion specification directs the
513:23 - conversion of the next input field
513:26 - normally the result is placed in the
513:27 - variable pointed to by the corresponding
513:30 - argument
513:31 - if assignment suppression is indicated
513:33 - by the asterisk character however the
513:35 - input field is parsed but then simply
513:37 - skipped no assignment is being made
513:40 - an input field is defined as a string of
513:42 - non-white space characters extent it
513:44 - extends to either the next white space
513:46 - character or until the field width if
513:48 - specified is exhausted
513:50 - this implies that scanf will read across
513:53 - line boundaries to find its input since
513:55 - new lines are white space
513:58 - the conversion character indicates the
514:00 - interpretation of the input field the
514:01 - corresponding argument must be a pointer
514:04 - as required by the call by value
514:05 - semantics of c
514:07 - the following conversion characters are
514:08 - legal
514:10 - d
514:11 - a decimal integer is expected on input
514:13 - the corresponding argument should be an
514:15 - integer pointer
514:17 - o
514:18 - an octal integer at with or without a
514:20 - leading zero is expected on input the
514:22 - corresponding argument should be an
514:24 - integer pointer
514:26 - x
514:27 - a hexadecimal integer with or without
514:29 - the leading zero x is expected in the
514:31 - input this corresponding argument should
514:33 - be an integer pointer
514:35 - h
514:36 - a short integer is expected in the input
514:39 - the corresponding argument should be the
514:41 - point a pointer to a short integer
514:43 - c
514:44 - a single character is expected the
514:46 - corresponding argument should be a
514:48 - character pointer the next input
514:50 - character is placed at the indicated
514:52 - spot
514:53 - the normal skip over white space
514:54 - characters is suppressed in this case to
514:56 - read the next non-white space character
514:59 - use percent one s
515:02 - s
515:03 - a character string is expected the
515:05 - corresponding argument should be a
515:07 - character pointer pointing to an array
515:09 - of characters large enough to accept the
515:10 - string and turn the terminating
515:12 - backslash zero which will be added
515:15 - f
515:16 - a floating point number is expected the
515:19 - corresponding argument should be a
515:21 - pointer to a float
515:22 - the conversion character e is a synonym
515:24 - for f
515:25 - the input formats for floats is an
515:27 - optional sign a string of numbers
515:29 - possibly containing a decimal point and
515:31 - an optional exponent field containing an
515:34 - upper or lower case e followed by
515:36 - possibly a signed integer
515:38 - the conversion character d o and x may
515:42 - be preceded by l the letter l
515:45 - to indicate that a pointer to a long
515:46 - rather than end appears in the argument
515:48 - list
515:49 - similarly the conversion characters e or
515:52 - f may be preceded by the letter l to
515:55 - indicate that it's a pointer to a double
515:57 - rather than a float in the argument list
516:01 - for example the call
516:04 - int i
516:05 - float x
516:07 - char
516:08 - name open square bracket 50 close square
516:10 - bracket close
516:11 - a semicolon
516:13 - scanf open parenthesis double quote
516:16 - percent d space percent f space percent
516:19 - s
516:20 - double quote comma ampersand i comma
516:23 - ampersand x comma name
516:26 - close paren semicolon with the input
516:28 - line
516:29 - 25 space 54.32
516:32 - e minus 1 space thomson
516:35 - we'll assign the value 25 to i
516:38 - the value 5.432
516:41 - to x and the string thompson properly
516:43 - terminated with a backslash 0 to name
516:46 - the three input fields may be separated
516:48 - by as many blanks tabs and new lines as
516:51 - desired
516:54 - the call
516:55 - int i semicolon float x semicolon char
516:59 - name open square bracket 50 close square
517:01 - bracket semicolon
517:03 - scanf double quote percent to d space
517:07 - percent f
517:08 - space
517:09 - percent star d
517:11 - space percent to s
517:14 - double quote comma ampersand i comma
517:16 - ampersand x common name close
517:18 - parentheses
517:20 - with input 56789 space 0 1 2 3 space
517:26 - 4 5 a 7 2 will assign 56 to i
517:31 - 7 89.0 to x
517:35 - skip over 0 1 2 3 and place the string
517:39 - 45 in name
517:42 - the next call to any input routine will
517:44 - begin searching at the letter a
517:47 - in these two examples
517:49 - name
517:50 - is a pointer and thus must not be
517:52 - preceded by an ampersand
517:55 - as another example the rudimentary
517:58 - calculator of chapter 4 can now be
518:00 - written with scanf to do the input put
518:02 - conversion
518:04 - this is example code on page 150 the
518:06 - textbook which you can see at
518:07 - www.cc4e.com
518:10 - code
518:12 - pound include stdio.h
518:14 - main open paren close paren open curly
518:17 - brace double sum comma v semicolon sum
518:21 - equals zero
518:23 - while open paren scanf open paren double
518:26 - quote percent l f
518:28 - double quote comma ampersand v
518:32 - close parenthesis not equal eof close
518:34 - parentheses printf open parenthesis
518:37 - double quote backslash t
518:39 - percent.2f backslash n
518:43 - double quote comma sum plus equals v
518:46 - close parenthesis semicolon close curly
518:48 - brace
518:50 - scanf stops when it's in when it
518:52 - exhausts control string or when some
518:55 - input fails to match the control
518:56 - specification it returns as its function
518:59 - residual value the number of
519:01 - successfully matched and assigned input
519:03 - items this can be used to decide how
519:05 - many input items were found
519:07 - on end to file eof is returned note that
519:10 - this is different from zero which means
519:12 - that the next input character does not
519:14 - match the first specification in the
519:16 - control string the next call to scanf
519:19 - resume searching immediately after the
519:21 - last character already returned
519:24 - a final warning the arguments to scanf
519:26 - must be pointers
519:28 - by far the most common error is writing
519:31 - scanf open paren double quote percent d
519:35 - percent comma n
519:37 - close paren semicolon instead of scanf
519:40 - open paren double quote percent d double
519:44 - quote comma ampersand n close paren
519:47 - semicolon
519:49 - section 7.5 in memory format conversion
519:53 - the functions scanf and printf have
519:55 - siblings called scan f and s printf
519:58 - which perform the corresponding
520:00 - conversion but operate on a string
520:02 - instead of a file the general format is
520:06 - s printf open paren string comma control
520:10 - comma arg one comma r two dot dot close
520:13 - paren
520:14 - s scan f open paren string comma control
520:17 - comma arg one comma r two et cetera
520:20 - close paren
520:22 - sprint s print f formats the arguments
520:25 - in arg1 arg2 etc according to control as
520:28 - before but it places the result in a
520:30 - string instead of on the standard output
520:32 - of course string had better be big
520:34 - enough to receive the result as an
520:36 - example
520:37 - if the name is a character array and n
520:39 - is an integer then
520:41 - s printf open paren name comma
520:44 - double quote temp percent d double quote
520:47 - comma n
521:03 - arg2 etc these arguments must be pointer
521:07 - the
521:08 - call scanf open paren name comma double
521:12 - quote temp percent d double quote comma
521:15 - ampersand n
521:16 - close parenthesis semicolon
521:18 - sets n to the value of the digits
521:22 - following
521:23 - temp in name
521:27 - section 7.6 file access
521:30 - as inside the next two sections do a
521:33 - nice job of covering file input and the
521:35 - notion of the standard error with simple
521:37 - sample code
521:38 - but the authors are also making a subtle
521:41 - point about unix
521:42 - and how the design of c makes it easy to
521:44 - build unix utilities
521:47 - by the end of section 7.6 we see a 29
521:50 - line program that is pretty much a
521:52 - complete implementation of the core
521:55 - functionality of the unix cat command
521:58 - part of the philosophy of unix was to
522:00 - build commands that are each simple
522:01 - building blocks that can be composed
522:03 - using standard input standard output
522:06 - redirection as well as pipes
522:08 - these next two sections are a gentle
522:10 - celebration of the design principles
522:12 - that underlie the unix operating system
522:15 - also
522:16 - while we're talking about the linkage
522:17 - between c and unix there is a
522:20 - unix-related easter egg earlier in the
522:22 - chapter
522:22 - see if you can find it
522:24 - bonus points if you already noticed it
522:30 - the programs written so far have all
522:32 - read the standard input and written the
522:33 - standard output which we have assumed
522:36 - are magically predefined for a program
522:38 - by the local operating system
522:40 - the next step in i o is to write a
522:42 - program that accesses a file which is
522:43 - not already connected to the program
522:46 - one program that clearly illustrates the
522:48 - need for such operations is cat which
522:51 - concatenates a set of name files onto
522:53 - standard output cad is used for printing
522:55 - files on a terminal and is a general
522:57 - purpose input collector for programs
522:59 - which do not have the capability of
523:01 - accessing files by name for example the
523:04 - command cat
523:05 - x dot c y dot c prints the contents of
523:09 - the files x dot c and y.c on the
523:11 - standard output
523:13 - the question is how to arrange for the
523:15 - named files to be read that is how to
523:17 - connect the external names the user that
523:19 - the user thinks of to the statements
523:20 - which actually read the data
523:22 - the rules are simple before it can be
523:25 - read or written the file has to be
523:26 - opened by the standard library function
523:28 - f open
523:30 - f open takes an external name like x dot
523:32 - c or y dot c does some housekeeping and
523:35 - negotiating with the operating system
523:37 - some details of which do not need to
523:38 - concern us and returns an internal name
523:41 - which then must be used for subsequent
523:42 - reads or rights of the file
523:45 - the internal name is actually a pointer
523:47 - called the file pointer to a structure
523:49 - which contains information about the
523:51 - file such as the location of a buffer
523:53 - the current character position in the
523:55 - buffer whether the file is being read or
523:57 - written and similar
523:59 - users don't need to know the details
524:01 - because part of the standard i o
524:02 - definitions are obtained from stdio.a
524:06 - and it's a structured definition called
524:09 - file
524:10 - the only declaration needed for a file
524:12 - pointer is exemplified by
524:14 - file star f open open paren close paren
524:17 - comma star fp semicolon
524:21 - that says that fp is a pointer to a file
524:24 - and f open returns a pointer to a file
524:27 - note that file is a type name like int
524:30 - not a structure tag it's implemented as
524:32 - a typedef details on how all this works
524:35 - on the unix system are given in chapter
524:38 - eight
524:39 - the actual call to f open in a program
524:41 - is
524:42 - fp equals
524:44 - f open open paren name comma mode close
524:48 - paren semicolon
524:50 - the first argument of f open is the name
524:52 - of the file as a character string the
524:55 - second argument is the mode also a
524:57 - character string which indicates how one
524:59 - intends to use the files
525:01 - allowable modes are read
525:04 - are
525:04 - write w or append a
525:08 - if you open a file which does not exist
525:10 - for writing or appending it is created
525:12 - if possible
525:14 - opening an existing file for writing
525:16 - causes the old constants to be discarded
525:19 - trying to read a file that does not
525:20 - exist is an error and there may be other
525:23 - causes of error as well like trying to
525:25 - read a file when you don't have
525:26 - permission
525:27 - if there is any error f open will return
525:30 - the null pointer with a value of null
525:33 - which for convenience is also defined in
525:35 - stdio.h
525:37 - the next thing needed is a way to read
525:39 - or write the file once it is open
525:41 - there are several possibilities of which
525:44 - get c and putsy are the simplest
525:46 - getc returns the next character from a
525:49 - file
525:50 - it needs the file pointer to tell what
525:52 - file thus
525:53 - c
525:54 - equals getc open paren fp close paren
525:58 - places in c the next character from the
526:00 - file referenced by fp and eof when it
526:03 - reaches end of file
526:05 - put c is the inverse of get c
526:08 - put c open paren c comma f p close paren
526:11 - puts the character c on the file fp and
526:14 - returns c
526:16 - like getchar and putchar gets the input
526:18 - c may be macros instead of functions
526:21 - when a program is started three files
526:23 - are automatically opened and file
526:25 - pointers are provided for them
526:27 - these files are the standard input the
526:30 - standard output and the standard error
526:32 - output the corresponding file pointers
526:35 - are called stdin
526:36 - sddi out and stder
526:40 - normally these are all connected to the
526:42 - terminal but stdn and std out may be
526:45 - redirected to files or pipes as
526:47 - described in section 7.2
526:50 - getchar and putchar can be defined in
526:53 - terms of getc put c std in and std out
526:56 - as follows
526:57 - pound define get char open for n close
527:00 - paren get c open paren stdin close paren
527:05 - pound define put char open paren c close
527:08 - paren put c open for n c comma std out
527:12 - close paren
527:13 - for formatted input or output files the
527:16 - function f scan f and f printf may be
527:19 - used these are identical to scanf and
527:21 - printf
527:23 - save that the first argument is a file
527:25 - pointer that specifies the file to be
527:26 - read or written the second string is the
527:29 - control the
527:30 - second argument is the control string
527:34 - with these preliminaries out of the way
527:36 - we are now in a position to write the
527:38 - program cat to concatenate files
527:41 - the basic design is one that has been
527:43 - found convenient for many programs if
527:45 - there are command line arguments they
527:47 - are processed in order if there are no
527:49 - arguments the standard input is
527:51 - processed this way the program
527:53 - can be used standalone or part of a
527:55 - larger process
527:58 - this example is on page 153 of the
528:01 - textbook and you can see it at
528:03 - www.cc4e.com
528:07 - code
528:09 - pound include stdio.h
528:12 - main open paren argc comma argv closed
528:15 - paren
528:16 - int argc semicolon
528:18 - char star argv
528:20 - open square bracket close square bracket
528:22 - semicolon
528:24 - open curly brace
528:26 - file star fp comma star f open open
528:30 - chrome close print semicolon
528:33 - if open paren rxc double equals one
528:36 - close paren
528:38 - there is no standard there's no
528:40 - arguments so we're going to copy the
528:41 - standard input
528:43 - file copy open paren
528:45 - stdin close paren semicolon else
528:49 - while open paren minus minus rxc greater
528:51 - than zero
528:53 - close paren
528:54 - if
528:56 - open paren open paren fp equals f open
528:59 - open paren star plus plus arc v comma
529:03 - quote r quote close paren close paren
529:06 - double equals null close paren open
529:07 - curly brace
529:09 - print
529:11 - f open print double quote cat colon
529:14 - can't open
529:16 - space percent s backslash n double quote
529:19 - star comma star r v close paren
529:22 - semicolon
529:24 - break semicolon
529:26 - close curly brace else open curly brace
529:29 - file copy open paren fp close paren
529:31 - semicolon f close open paren fp close
529:35 - print semicolon
529:36 - close curly brace for the if then else
529:39 - and then close curly brace for the main
529:42 - and now we have the file copy function
529:45 - we're going to open read all the
529:47 - contents of a file pointer and send it
529:49 - to standard output
529:50 - file copy open paren fp close paren
529:54 - file star fp semicolon open curly brace
529:58 - int c semicolon while open paren open
530:02 - for n c equals get c open paren fp close
530:06 - print close paren not equal eof close
530:09 - paren put c open paren
530:12 - c comma std o ut close paren semicolon
530:16 - close curly brace
530:18 - the file pointers std in and std out are
530:22 - predefined in the i o library as the
530:24 - standard input and the standard output
530:26 - they may be used anywhere an object of
530:28 - type file star can be they are constants
530:31 - however not variables so don't try to
530:33 - assign to them
530:35 - the function f close is the inverse of f
530:37 - open it breaks the connection between
530:39 - the file pointer and the external name
530:40 - that was established by x f open freeing
530:43 - the file pointer for another file
530:45 - since most operating systems have some
530:47 - limit on the number of simultaneously
530:49 - open files a program may have it's a
530:51 - good idea to free things when they're no
530:53 - longer needed as we did above in cat
530:56 - there's also another reason for f close
530:58 - on an output file it flushes the buffer
531:00 - in which put c is collecting output
531:03 - fclose is called automatically for each
531:05 - open file when a program terminates
531:08 - normally
531:10 - section 7.7 error handling stder and
531:15 - exit
531:16 - the treatment of errors in the previous
531:19 - implementation of cat is not ideal the
531:21 - trouble is that if one of the files
531:23 - can't be accessed for some reason the
531:25 - diagnostic is printed at the end of the
531:27 - concatenated output
531:29 - that is acceptable if the output's going
531:31 - to a terminal but it's really bad if
531:33 - it's going to a file or some other
531:35 - program via pipeline
531:37 - to handle this situation better a second
531:39 - output file called stderr is assigned to
531:42 - the program in the same way that stdin
531:45 - and std out are
531:48 - if at all possible output written on
531:50 - stderr appears on the user's terminal
531:54 - even if the standard output
531:56 - is redirected
531:58 - let's revise cat to write its error
532:01 - messages onto the standard output file
532:06 - this is really only a couple of lines of
532:08 - code different between the example on
532:11 - page 153 this is the example on page 154
532:15 - of the textbook which of course you can
532:17 - see at
532:18 - www.cc4e.com
532:22 - code
532:23 - pound include stdio.h
532:26 - pound include stdlib.h
532:29 - open paren argh c comma arc v close
532:32 - paren int argc semicolon
532:35 - char star arc v open square bracket
532:37 - close square bracket
532:38 - semicolon open curly brace
532:41 - file star fp comma star f open
532:45 - open paren close paren semicolon
532:48 - if open for n r c double equal one close
532:51 - paren
532:52 - here we have no arguments
532:54 - file copy open paren s t d i close
532:57 - parent semicolon else
532:59 - while open paren minus minus argc
533:02 - greater than zero close paren
533:05 - if open paren open paren fp equals f
533:08 - open open print star plus plus arg v
533:11 - comma
533:13 - double quote r double quote close paren
533:15 - and close for n double equal null
533:17 - close paren open curly brace
533:19 - f print f open paren std e r r comma
533:25 - double quote cat colon
533:27 - can't open
533:28 - percent s backslash n double quote comma
533:32 - star r v close paren semicolon
533:35 - exit open paren one close brand
533:38 - semicolon close curly brace else open
533:42 - curly brace file copy open paren fp
533:46 - close paren semicolon
533:48 - file close open print fp close paren
533:50 - semicolon close curly brace to finish
533:53 - the if and then exit
533:55 - open paren zero close paren semicolon
533:58 - close curly brace
534:00 - to the uh change the finish the main
534:03 - and file copy we is the same from the
534:05 - previous so
534:07 - this program signals errors two ways the
534:10 - diagnostic output produced by fprintf
534:13 - goes to stderr so it finds its way to
534:15 - the user's terminal instead of
534:17 - disappearing down a pipeline pipeline or
534:19 - into an output file the program also
534:22 - uses the standard library function exit
534:24 - which terminates execution when it's
534:26 - called the argument of exit is available
534:28 - to whatever process called this one so
534:30 - the success or failure of the program
534:32 - can be tested by another program that
534:34 - uses this one as a sub process
534:37 - by convention a return value of 0
534:40 - signals all as well and various non-zero
534:42 - values signal abnormal situations
534:45 - exit calls f-close for each open output
534:48 - file to flush any buffered output then
534:51 - calls a routine named underscore exit
534:53 - the function underscore exit causes
534:55 - immediate termination without any buffer
534:57 - flushing of course it may be called
534:59 - directly if desired
535:01 - section 7.8 line input and output
535:05 - the standard library provides a routine
535:08 - f git s which is quite similar to the
535:09 - getline function we've used throughout
535:11 - the book
535:12 - the call fcds open paren line comma max
535:15 - line comma fp close paren reads the next
535:18 - input line including the new line from
535:20 - the file fp into the character array
535:23 - line
535:24 - at most max line minus 1 characters will
535:27 - be red the resulting line is terminated
535:30 - with backslash zero normally f cades
535:33 - returns line on end to file it returns
535:35 - null
535:36 - our getline returns line length and zero
535:38 - friend to file
535:40 - for output the function f put s writes a
535:42 - string which need not contain a new line
535:44 - to a file f put s open paren line comma
535:48 - fp close paren
535:50 - to show there's nothing magic about the
535:52 - functions like f get s and f put s here
535:55 - they are copied directly from the unix
535:58 - standard io library
536:01 - this
536:02 - code example is on page 155 of the
536:05 - textbook which you can view at
536:06 - www.cc4e.com
536:09 - code
536:11 - char
536:12 - star
536:12 - f get s open paren s comma n comma iop
536:16 - close paren
536:17 - char star s semicolon
536:20 - in n semicolon register file star iop
536:25 - semicolon
536:26 - open curly brace
536:28 - register int c semicolon register char
536:32 - star cs semicolon
536:34 - cs equals s semicolon
536:37 - while open paren minus minus n greater
536:39 - than zero double ampersand open paren c
536:43 - equals get c open paren iop close print
536:46 - close paren not equal eof close paren
536:50 - if
536:51 - open paren open paren star cs plus plus
536:54 - equals c close print equal equal
536:58 - quote backslash n quote close paren
537:01 - break semicolon
537:03 - star cs equals
537:06 - quote backslash zero quote
537:08 - semicolon return
537:11 - open paren open paren c
537:13 - double equals e o f
537:15 - and c s double equals s close paren
537:19 - question mark null
537:21 - colon s close paren semicolon close
537:25 - curly brace
537:27 - the function f put s is as follows
537:30 - f put s open paren s comma iop close
537:33 - paren
537:35 - register char star s register file star
537:38 - iop semicolon open curly brace
537:42 - register int c semicolon while open
537:45 - paren c equals star s plus plus close
537:49 - paren
537:50 - put c open for n c comma iop close paren
537:54 - semicolon close curly brace
537:58 - section 7.9 some miscellaneous functions
538:02 - the standard library provides a variety
538:04 - of functions a few which stand out is
538:06 - especially useful we've already
538:08 - mentioned the string functions sterlin
538:11 - stir cpy
538:12 - stir cat and stir comp here are some
538:15 - others
538:16 - character class testing and
538:18 - conversion several macro rows perform
538:21 - character tests and conversions
538:24 - the function is alpha open paren c close
538:26 - print returns non-zero if c is
538:29 - alphabetic zero if not the function is
538:32 - upper open paren c close paren is
538:35 - returns non-zero if c is upper case
538:38 - zero if not
538:39 - is lower open paren c close paren is
538:42 - non-zero if c is lower case is zero if
538:44 - not
538:45 - is digit open paren c close paren is
538:47 - non-zero fc is a digit zero if not
538:50 - is space open friends c close paren
538:54 - is non-zero if c is blank tab or new
538:56 - line zero if not
538:58 - two upper open paren c close paren
539:00 - convert c to upper case
539:02 - two lower open parenthesis close paren
539:05 - convert c
539:06 - to lower case those all worked on single
539:09 - characters
539:11 - on get c
539:12 - the standard library provides a rather
539:14 - restricted version of the function
539:16 - ungetch which we wrote in chapter four
539:19 - it's called ungetc
539:21 - ungetc open paren c comma fp close paren
539:25 - pushes the character c back onto the
539:27 - file fp
539:29 - only one character of pushback is
539:31 - allowed per file
539:33 - unget c may be used with any of the
539:35 - input functions in macros like scan f
539:37 - get c or get char
539:40 - system call the function system open
539:43 - paren s close paren executes the command
539:46 - in the character string s
539:48 - then resumes the execution of the
539:50 - current program the contents of s
539:53 - depends strongly on the local operating
539:55 - system
539:56 - as a trivial example on unix the line
539:59 - system open for end double quote date
540:02 - double quote close paren semicolon
540:04 - causes the date program to be run it
540:07 - prints the time and date of the day on
540:10 - unix
540:12 - storage management
540:15 - the function c alec is rather like the
540:17 - alec we have used in previous chapters
540:19 - see alec open paren n comma size of
540:23 - open paren object close paren close
540:25 - paren
540:26 - returns a pointer to enough space for n
540:29 - objects of the specified size or null if
540:32 - the request cannot be satisfied the
540:34 - storage is initialized to zero the
540:36 - pointer has the proper alignment for the
540:38 - object in question but it should be cast
540:40 - to the appropriate type as in
540:42 - char star c alec open friend close paren
540:45 - semicolon int star ip semicolon ip
540:50 - equals open paren int star close paren c
540:53 - alec open paren n comma size of open
540:57 - paren int close paren close paren
540:59 - semicolon
541:01 - c free open paren p close print
541:04 - free space pointed to by p
541:07 - where p is originally obtained by a call
541:09 - to see alec there are no restrictions on
541:12 - the order in which space is freed but it
541:14 - is a ghastly error to free something
541:17 - not obtained by calling seahawk
541:20 - chapter 8 shows the implementation of a
541:23 - storage allocator like c alec in which
541:25 - the allocated blocks may be freed in any
541:28 - order
541:30 - this work
541:31 - is based on the 1978 c programming book
541:34 - written by brian w kernighan and dennis
541:36 - m ritchie
541:38 - their book is copyright all rights
541:40 - reserved by at t
541:41 - but is used in this work under fair use
541:44 - because of the book's historical and
541:46 - scholarly significance
541:48 - its lack of availability and the lack of
541:50 - an accessible version of the book
541:52 - the book is augmented in places to help
541:54 - understand its rightful place in a
541:56 - historical context amidst the major
541:58 - changes of the 1970s and 1980s as
542:01 - computer science evolved from a hardware
542:03 - first vendor-centered approach to a
542:05 - software-centered approach where
542:07 - portable operating systems and
542:08 - applications written in c could run on
542:11 - any hardware
542:13 - this is not the ideal book to learn c
542:15 - programming because the 1978 edition
542:17 - does not reflect the modern c language
542:20 - using an obsolete book gives us an
542:22 - opportunity to take students back in
542:24 - time and understand how the c language
542:26 - was evolving as it laid the groundwork
542:29 - for a future with portable applications
542:35 - chapter 8 the unix system interface
542:38 - the material in this chapter is
542:39 - concerned with the interface between c
542:41 - programs and the unix operating system
542:44 - since most c programs are on unix
542:46 - systems this should be helpful to a
542:47 - majority of the readers
542:49 - even if you see on a different machine
542:51 - however you should be able to glean more
542:53 - insight into c programming from studying
542:55 - these examples
542:57 - this chapter is divided into three major
542:59 - areas input output file system and a
543:02 - storage allocator the first two parts
543:05 - assume a modest familiarity with the
543:07 - external characteristics of
543:10 - unix
543:11 - chapter 7 was concerned with a system
543:13 - interface that is uniform across a
543:14 - variety of operating systems on any
543:17 - particular system the routines of the
543:19 - standard library have to be written in
543:21 - terms of the i o facilities that are
543:22 - actually available on the host system
543:25 - in the next few sections will describe
543:27 - the basic system entry points for i o
543:29 - and uni on the unix operating system and
543:31 - illustrate how parts of the standard
543:33 - library can be implemented with them
543:38 - but
543:38 - as an aside the dual nature of c and
543:41 - unix has been on display throughout the
543:43 - book
543:44 - and while this chapter is called the
543:46 - unix system interface
543:48 - in a sense it's less about unix in
543:50 - itself and very much about why c is such
543:53 - a great programming language
543:55 - let me explain
543:57 - before unix and c became the norm
544:00 - operating systems and operating system
544:01 - utilities those commands were used
544:03 - interactively and batch jobs were quite
544:06 - often written in the assembly language
544:07 - of the computer which it was supporting
544:10 - often there were not well-documented api
544:12 - calls between utilities in assembly
544:14 - language and the assembly language which
544:16 - implemented the operating system
544:18 - smart
544:20 - vendor programmers would just look at
544:21 - the operating system code and write
544:23 - their utility code to work with it
544:25 - this section shows that a language that
544:28 - has features like structures arrays
544:31 - pointers
544:32 - a preprocessor and unions was
544:35 - sufficiently rich
544:37 - so that we could document all the
544:39 - intricate interfaces with an operating
544:41 - system using a relatively high level
544:44 - language and then we could write our
544:46 - utility code like cat
544:48 - in a high-level language as well
544:51 - in this chapter the authors are almost
544:53 - shouting
544:54 - quit using assembly language to build
544:56 - your operating system and utility code
544:59 - further they are showing us examples
545:01 - designed to answer the question that
545:03 - might come from programmers used to the
545:05 - old ways like can we do
545:08 - x y z and c
545:10 - the author's emphatic answer in the
545:12 - increasingly intricate code samples is
545:15 - c is not a toy language that's only
545:17 - something used by a few att computer
545:19 - scientists in a research lab
545:21 - if you're doing serious system stuff
545:24 - that needs maximum performance and
545:26 - readability and reliability use c
545:30 - this chapter shows c in all its glory
545:33 - and shows why it was such an important
545:36 - language
545:37 - to enable the world of technology we
545:39 - have 40 years later
545:41 - at the end of the chapter we'll talk a
545:42 - little bit about see how c enabled the
545:45 - creation of easier to use programming
545:47 - languages and why it was so important to
545:51 - invent c inspired languages like python
545:53 - ph g and and php and java
545:56 - once c became the established systems
545:59 - programming language
546:01 - section 8.1
546:03 - file descriptors
546:05 - in the unix operating system all input
546:07 - and output is done by reading or writing
546:10 - files because all peripheral devices
546:12 - even the user's terminal are files in
546:14 - the file system
546:16 - this means that a single homogeneous
546:18 - interface handles all communications
546:20 - between a program and peripheral devices
546:24 - in the most general case before reading
546:26 - or writing a file it is necessary to
546:28 - inform the system of your intent to do
546:30 - so
546:31 - a process called opening the file
546:34 - if you're going to write on a file it
546:36 - may also be necessary to create it
546:38 - the system checks for your right to do
546:40 - so
546:41 - does the file exist do you have
546:43 - permission to access it and if all is
546:45 - well returns to the program a small
546:47 - positive integer called the file
546:49 - descriptor
546:50 - whenever i o is to be done on the file
546:52 - the file descriptor is used instead of
546:54 - the name to identify the file
546:57 - this is roughly analogous to the use of
547:00 - read open paren five comma dot dot dot
547:02 - and write open paren six comma dot dot
547:04 - dot in fortran
547:07 - all information about an open file is
547:09 - maintained by the system
547:11 - the user refers to the file only by the
547:14 - file descriptor
547:16 - since input and output involving the
547:17 - user terminal is so common
547:20 - special arrangements exist to make this
547:22 - convenient
547:23 - in the command interpreter the shell
547:25 - runs a program it opens three files with
547:28 - files descriptors 0 1 and 2 called the
547:32 - standard input standard output and
547:34 - standard error output
547:37 - all of these are normally connected with
547:38 - a terminal so if a program reads file
547:40 - descriptor 0 and writes to file
547:42 - descriptors 1 and 2 it can do terminal i
547:44 - o without worrying about opening the
547:46 - files
547:48 - the user of the program can redirect
547:50 - input output to and from files with less
547:53 - than and greater than
547:55 - for example probe less than in file
547:58 - greater than out file
548:00 - in this case the shell changes the
548:02 - default assignments for file descriptors
548:04 - 0 and 1 from the terminal to the named
548:07 - files
548:08 - normally file descriptor 2 remains
548:10 - attached to the terminal so error
548:12 - messages can go there
548:14 - similar observations hold if the input
548:16 - or output is associated with a pipe
548:19 - in all cases it must be noted that the
548:22 - file assignments are changed by the
548:24 - shell not the program
548:26 - the program does not know where its
548:27 - input comes from nor where its output
548:30 - goes so long as it uses file 0 for input
548:33 - and 1 and 2 for output section 8.2
548:37 - low level i o read and write
548:41 - this lowest level of i o in unix
548:43 - provides no buffering or any other
548:45 - services
548:46 - it is in fact a direct entry into the
548:48 - operating system all input and output is
548:51 - done by two functions called read and
548:53 - write
548:54 - for both the first argument is a file
548:57 - descriptor
548:58 - the second argument is a buffer in your
549:00 - program where the data is to come from
549:02 - or go to
549:03 - the third argument is the number of
549:05 - bytes to be transferred the calls are
549:08 - and read equals read open paren fd comma
549:12 - buff comma n close brand semicolon
549:15 - and written equals write open paren ft
549:19 - fd comma buff comma n close paren
549:22 - semicolon
549:24 - each call returns a byte count
549:26 - which is the number of bytes actually
549:28 - transferred
549:29 - on reading the return the number of
549:31 - bytes returned may be less than the
549:32 - number of number asked for a return
549:35 - value of zero bytes implies end to file
549:38 - and negative one indicates an error of
549:40 - some sort for writing the return value
549:43 - is the actual number of bytes written it
549:45 - is generally an error if this isn't
549:47 - equal to the supposed number that was
549:50 - asked to be written
549:52 - the number of bytes to be written read
549:54 - or written is quite arbitrary the two
549:57 - most common values are 1 which means 1
550:00 - character at a time or unbuffered and
550:02 - 512 which corresponds to the physical
550:05 - block size on many early peripheral
550:07 - devices
550:09 - this ladder size will be most efficient
550:11 - even but even a character at a time i o
550:13 - is not inordinately expensive
550:17 - putting these facts together we can
550:18 - write a simple program to copy its input
550:21 - to its output
550:22 - the equivalent of the file copying
550:25 - program written for chapter one
550:27 - in unix
550:28 - this program will copy anything to
550:30 - anything
550:31 - since input and output can be redirected
550:34 - to any file or device
550:36 - this example is on page 161 of the
550:38 - textbook which you can
550:40 - view at w www.cc4e.com
550:43 - code
550:45 - pound include standard stdio.h
550:49 - pound defined buff size
550:51 - 512. this is the best size for pdp 11
550:54 - unix
550:56 - modern computers it probably should be
550:57 - larger
550:58 - main open print close print open curly
551:01 - brace
551:02 - char buff open square bracket buff size
551:05 - close square bracket semicolon
551:07 - int n
551:08 - semicolon while open paren open paren n
551:12 - equals read open paren zero comma buff
551:16 - comma buff size close paren close paren
551:19 - greater than zero close paren right open
551:22 - paren one comma buff comma n close paren
551:26 - semicolon close curly brace
551:29 - if the file size is not an exact
551:31 - multiple of buff size some read will
551:33 - return a smaller number of bytes to be
551:35 - written by write
551:37 - the next call after that read will
551:39 - return zero
551:41 - it is instructive to see how read and
551:42 - write can be used to construct higher
551:44 - level routines like get char and put
551:46 - char for example here is a version of
551:48 - get char which does unbuffered input
551:52 - this is the second example on page 162
551:56 - of the textbook
551:58 - pound include
551:59 - stdio.h pound define
552:02 - cmask0377
552:04 - and this is a mask an octal mask to make
552:07 - sure characters are greater than zero
552:10 - get char open paren close paren open
552:13 - curly brace
552:14 - char c
552:16 - semicolon return open paren open paren
552:19 - read open paren 0 comma ampersand c
552:24 - comma 1 close print greater than 0 close
552:27 - print question mark
552:29 - c ampersand c mask
552:32 - colon e o f
552:34 - semicolon close curly brace
552:37 - c must be declared char because read
552:40 - accepts a character pointer the
552:42 - character being returned must be masked
552:44 - with 0 3 7 7 to ensure that it's
552:46 - positive otherwise
552:48 - sign extension might make it negative
552:50 - the constant 037 is appropriate for
552:54 - ascii
552:55 - and the pdp-11 but not necessarily for
552:57 - every other machine
553:00 - the second version of get char does its
553:03 - input in big chunks
553:05 - and hands out the characters one at a
553:07 - time
553:09 - this is the
553:10 - first example on page 162 of the
553:12 - textbook which you can see at www.ccf
553:17 - code
553:19 - pound include stdio.h
553:21 - pound define cmask0377
553:25 - pound define buff size 512.
553:29 - now we do the buffered version of get
553:30 - char
553:31 - get char open friend close paren open
553:34 - curly brace
553:35 - static char buff open square bracket
553:38 - buff size close square bracket
553:41 - static char star buff p equals buff
553:44 - semicolon static int n equals zero
553:48 - semicolon
553:49 - those variables are static so that they
553:52 - they are long lived and exist from call
553:55 - to call
553:57 - the beginning of the code if open paren
554:00 - n double equals 0 close print open curly
554:02 - brace n equals read
554:05 - open paren 0 comma buff comma buff size
554:07 - close paren semicolon
554:10 - buff p equals buff semicolon close curly
554:13 - brace return
554:15 - open paren open paren minus minus n
554:18 - greater than equal to zero close paren
554:21 - question mark star buff p plus plus
554:24 - ampersand c mask colon eof close print
554:28 - semicolon close curly brace
554:30 - section 8.3 open create close unlink
554:36 - create is not created it's create
554:38 - without the e so i'll just call it creat
554:40 - for now
554:42 - other
554:43 - than the default standard input and
554:45 - output and error files you must
554:46 - explicitly open files in order to read
554:48 - or write them there are two system entry
554:50 - points for this
554:52 - open and create open is rather like the
554:55 - f open discussed in chapter seven except
554:58 - that instead instead of returning a file
554:59 - pointer it returns a file descriptor
555:01 - which is just an int
555:03 - int fd semicolon
555:06 - fd equals
555:08 - open
555:09 - open paren name comma rw mode close
555:12 - paren semicolon
555:13 - as with f open the name argument is a
555:15 - character string corresponding to the
555:17 - external file name the access mode
555:20 - argument is different however rw mode is
555:22 - a zero for read one for right and two
555:25 - for read write access
555:26 - open returns negative one if any error
555:28 - occurs otherwise it returns a file valid
555:31 - file descriptor
555:33 - it is an error to open a file that does
555:35 - not exist the entry point create is
555:38 - provided to create new files or to
555:40 - rewrite old ones
555:41 - fd equals create open paren name comma p
555:45 - mode close paren semicolon
555:47 - returns a file descriptor if it was able
555:50 - to create the file name
555:52 - and negative one if not if the file
555:53 - already exists create will truncate it
555:55 - to zero length it is not an error to
555:58 - create a file that already exists
556:01 - if the file is brand new create creates
556:03 - it with the protection mode specified in
556:05 - the p mode argument
556:07 - in the unix file system there are nine
556:09 - bits of protection information
556:11 - associated associated with each file
556:13 - controlling read write and execute
556:16 - permission for the owner of the file for
556:18 - the owner's group and for all others
556:20 - thus a three-digit octal number is the
556:23 - most convenient
556:24 - format for specifying permissions
556:28 - for example zero seven five five
556:30 - specifies read write and execute
556:33 - permission for the owner and read and
556:35 - execute permission for group and for
556:37 - everyone else
556:39 - to illustrate here
556:41 - a simplified version of the unix utility
556:44 - cp a program that copies one file to
556:47 - another the main simplification is that
556:49 - our
556:50 - version only copies one file and does
556:52 - not permit the second argument to be a
556:54 - directory
556:56 - and this example code is on page 163 of
557:00 - the textbook which you can see at
557:02 - www.cc4e.com
557:05 - code
557:07 - found include stdio.h
557:09 - pound include std live.h pound defined
557:12 - buff size
557:13 - 512
557:15 - pound defined p mode 0 6 4 4 rw read and
557:19 - write for owner read for group and
557:20 - others
557:21 - int
557:22 - open paren arg c comma arg v
557:25 - close paren
557:27 - the format will be we're going to have
557:28 - two files copy file one file two
557:32 - int
557:33 - argc semicolon char star arc v open
557:36 - square bracket close square bracket
557:37 - semicolon open curly brace int
557:40 - f1 comma f2 comma n semicolon char buff
557:45 - buff size
557:46 - semicolon
557:48 - if open paren
557:50 - arg c not equal to three close paren
557:53 - error open paren double quote usage
557:55 - colon cp from 2
557:58 - double quote common null
558:00 - close paren semicolon
558:02 - if
558:03 - open paren open paren f1 equals open
558:07 - open paren arg v sub one comma zero
558:11 - close print close paren equal equal
558:13 - minus one close paren error
558:16 - open for n double quote cp colon can't
558:19 - open percent s double quote comma arg v
558:22 - sub 1
558:24 - close paren semicolon
558:26 - if
558:27 - open paren open paren f2 equals create
558:30 - open print arc v sub 2 comma p mode
558:32 - close paren close paren
558:34 - equal equal minus 1
558:36 - close paren air open friend quote cp
558:40 - colon can't create percent s
558:43 - double quote comma arg v sub 2
558:46 - close paren semicolon
558:49 - while open paren open print n equals
558:52 - read open paren f1 comma buff comma buff
558:55 - size close paren close print greater
558:57 - than zero close paren
558:59 - if open paren write open print f2 comma
559:02 - buff comma n close paren not equal
559:05 - and close paren air
559:07 - open paren double quote cp
559:10 - colon right ear double quote comma null
559:13 - close paren semicolon
559:15 - exit open paren
559:17 - zero close paren semicolon close curly
559:20 - brace that's the end of the main program
559:22 - the error
559:24 - routine is going to print the error
559:25 - message
559:28 - air open paren s1 comma s2 close paren
559:32 - char star s1 comma star s2 semicolon
559:37 - open paren
559:38 - printf open paren s1 comma s2 close
559:42 - paren semicolon printf double quote
559:45 - backslash n double quote close paren
559:47 - semicolon
559:48 - exit open paren 1 close paren semicolon
559:52 - close curly brace
559:53 - there is a limit on the number of files
559:55 - which the program may have open
559:57 - simultaneously according any program
560:00 - which intends to process many files must
560:02 - be prepared to reuse file descriptors
560:05 - the retain close breaks the connection
560:07 - between a file descriptor and an open
560:09 - file and frees the file descriptor for
560:12 - use with some other file
560:14 - termination of a program by exit or
560:16 - return from the main program
560:18 - closes all open files
560:22 - the function unlink open print file name
560:24 - close print removes the file name from
560:26 - the file system
560:29 - section 8.4
560:31 - random access seek and l-seek
560:34 - file i o is normally sequential each
560:37 - read or write takes place at a position
560:39 - in the file right after the previous one
560:42 - when necessary however a file can be
560:44 - read or written in any arbitrary order
560:47 - the system call lseq provides a way to
560:50 - move around in a file without actually
560:51 - reading or writing
560:53 - lseq open paren fd comma offset comma
560:57 - origin close paren semicolon
561:00 - forces the current position in the file
561:02 - whose descriptor is fd to move to the
561:04 - position offset which is taken relative
561:07 - to the location specified by origin
561:10 - subsequent reading or writing will begin
561:12 - at that position
561:13 - offset is a long
561:15 - fd and origin are ints origin can be 0 1
561:19 - or 2 to specify that the offset is to be
561:22 - measured from the beginning
561:23 - from current position or from the end of
561:25 - file respectively
561:27 - for example to append to a file seek to
561:30 - the end before writing
561:31 - l seek open print ft
561:34 - comma 0l
561:36 - comma 2 close print semicolon to get
561:40 - back to the beginning i.e rewind to the
561:42 - beginning
561:43 - l seek open paren fd comma 0l comma 0
561:49 - parentheses semicolon
561:52 - note that the 0l argument could also be
561:55 - written as open parent long close paren
561:58 - 0.
561:59 - with lseq it's possible to treat files
562:02 - more or less like large arrays at the
562:04 - price of slower access
562:06 - for example the following simple
562:08 - function reads any number of bytes from
562:11 - any arbitrary place in a file
562:14 - get open paren fd comma pause comma buff
562:18 - comma n close paren
562:21 - int fd comma n
562:23 - long pause semicolon char star buff
562:27 - semicolon open curly brace
562:30 - l seek open parenthesis fd comma pause
562:33 - comma 0 close paren semicolon
562:37 - return open paren read open paren fd
562:41 - comma buff comma n close paren close
562:44 - paren semicolon close curly brace
562:47 - in pre-version 7 unix the basic entry
562:49 - point to the i o system is called seek
562:52 - seek is identical to lseq except that
562:54 - its offset argument is an int rather
562:56 - than a long
562:58 - accordingly since pdp 11 integers only
563:00 - have 16 bits the offset specified for
563:03 - seek is limited to 65535
563:07 - for this reason origin values of 3 4 and
563:10 - 5 cause seek to multiply the given
563:12 - offset by 512 which is the number of
563:15 - bytes in one physical block on a 11 and
563:17 - then interpret origin as if it were 0 1
563:20 - or 2 respectively thus to get to an
563:23 - arbitrary place in a large file requires
563:25 - two seeks the first one selects the
563:27 - block
563:28 - then one which has origin equal to one
563:31 - and then moves to the desired desired
563:34 - byte within the block
563:36 - once again we see c in unix straddling a
563:39 - major improvement in computer hardware
563:41 - in 1978.
563:42 - the natural name for a function to
563:44 - randomly move around a file would be
563:45 - seek but in early versions of unix seek
563:48 - took an integer as the offset but on
563:50 - small word computers like pdp-11 have an
563:52 - integer that can't represent a large
563:54 - number so seek used a complex set of
563:56 - rules to handle larger files
563:58 - the only logical thing was to have the
564:00 - offset be along and then for upwards
564:02 - compatibility make a new function called
564:05 - lseq that we use to this day
564:08 - section 8.5
564:10 - an example implementation of f open and
564:13 - get c
564:14 - let us illustrate how some of these
564:16 - pieces fit together by showing an
564:18 - implementation of the standard library
564:19 - routines f open and get c on the pdp 11.
564:24 - recall that files in the standard
564:25 - library are described by file pointers
564:27 - rather than file descriptors
564:29 - a file pointer is a pointer to a
564:31 - structure that contains several pieces
564:33 - of information about the file a pointer
564:35 - to a buffer so the file can read in
564:36 - large chunks
564:38 - count of the number of characters left
564:39 - in the buffer a pointer to the next
564:41 - character position in the buffer and
564:43 - some flags describing read write mode
564:45 - and the file descriptor the data
564:47 - structure that describes a file is
564:49 - contained in the file stdio.h which must
564:52 - be included by pound include in any
564:55 - source file that uses routines from the
564:57 - standard library
564:58 - it is also included by functions in that
565:00 - library
565:01 - in the following excerpt from the pdp-11
565:04 - stdio.h
565:05 - names which are intended for use only by
565:08 - functions of the library begin with
565:09 - underscore
565:11 - so they are less likely to collide with
565:13 - the names of a user program
565:16 - as a side note i won't read the
565:18 - underscores
565:19 - because they
565:20 - confuse your understanding so the
565:22 - underscores are there in the code you
565:23 - can look at it online
565:25 - but i'm not going to read the
565:26 - underscores
565:29 - so this is basically some definitions
565:32 - for stdio.h
565:34 - pound define buff size
565:37 - pawn define and file 20.
565:40 - type def struct io buff open curly brace
565:43 - char star ptr
565:45 - int
565:46 - cnt semicolon char star base semicolon
565:51 - int flag semicolon int fd semicolon
565:54 - close curly brace
565:56 - file semicolon
565:58 - extern file iob
566:01 - open square bracket end file
566:03 - close square bracket semicolon pound
566:06 - define stdin
566:08 - open paren ampersand iob sub zero close
566:11 - paren
566:12 - pawn define std out
566:14 - open paren ampersand iob sub one close
566:17 - paren pound define std air open paren
566:20 - ampersand iob sub 2 close print
566:24 - pawn define read 01 pound define right
566:28 - o2 pondifying unbuff 04 pound define big
566:32 - buff zero one zero
566:34 - upon define eof
566:36 - zero two zero pondifying air
566:39 - zero four zero pound defined null zero
566:43 - pawn define eof open prin
566:46 - minus one close paren
566:49 - upon define gets e open paren p
566:52 - close paren open paren minus minus open
566:55 - paren p close paren right arrow cnt
566:59 - greater than or equal to zero question
567:01 - mark
567:02 - star open paren p close paren right
567:04 - arrow ptr plus plus
567:07 - ampersand zero three seven seven colon
567:11 - fill buff open paren p close print close
567:14 - print palm define get char
567:18 - open paren close friend
567:20 - get c
567:21 - open paren std high n close paren
567:24 - pound define put c
567:26 - open parent x comma p close paren
567:28 - open paren minus minus open paren p
567:31 - close paren right arrow cnt greater than
567:35 - or equal to zero question mark
567:37 - star
567:38 - open paren p close paren
567:40 - right arrow ptr plus plus equals open
567:43 - paren x close print colon
567:46 - flush buff open paren open paren x close
567:48 - paren comma p close print close paren
567:52 - pound define put char open paren x close
567:55 - paren put c open paren x come std out
567:59 - close paren
568:01 - the f c in macro normally just
568:03 - decrements the counts advances the
568:04 - pointer and returns the character
568:06 - we do this in a very long defined
568:08 - continued by a backslash if the count
568:11 - goes negative however get c calls the
568:13 - function fill buff to replenish the
568:15 - buffer real initialize the structure
568:17 - contents and return a character a
568:20 - function may present a portable
568:21 - interface yet itself contain
568:23 - non-portable constructs
568:25 - cat c masks the character with zero
568:27 - three seven seven which defeats the sign
568:30 - extension done by the pdp 11 and ensures
568:32 - that all characters will be positive
568:35 - although we will not discuss any details
568:37 - we've included the definition of put c
568:39 - to show that it operates in much the
568:41 - same way as getsy calling a function
568:44 - flush buff when its output buffer is
568:46 - full
568:47 - the function f open and fill buff can
568:50 - now be written most of f open is
568:52 - concerned with getting a file opened and
568:54 - positioned at the right place
568:56 - and setting the flag bits to indicate
568:57 - the proper state
568:59 - f open does not allocate any buffer
569:02 - space this is done by fill buff when the
569:04 - file is first read
569:07 - you can look at this sample code from
569:08 - page 167 at www.cc4e.com
569:13 - code
569:14 - i won't read it here because it's pretty
569:16 - long and intricate so you'll have to go
569:19 - watch it online or view it online
569:23 - back to the text the function fill buff
569:25 - is rather more complicated the main
569:27 - complexity lies in the fact that phil
569:29 - buff attempts to permit access to the
569:31 - file even though there may not be enough
569:33 - memory to buffer the i o if the space
569:36 - for a new buffer cannot be obtained from
569:38 - cat c alec all is well
569:41 - if not
569:42 - filbuff does unbuffered i o using a
569:45 - single character stored in a private
569:46 - array
569:47 - the first call to get c for a particular
569:50 - file finds a count of zero which forces
569:52 - a call a fill buff if phil buff finds
569:54 - that the file is not open for reading it
569:56 - returns eof immediately
569:58 - otherwise it tries to allocate a large
570:00 - buffer and failing that a single
570:03 - character buffer setting the buffering
570:05 - information in flag appropriately
570:08 - once the buffer is established phil buff
570:11 - simply calls read to fill it
570:13 - and sets the count and pointers
570:15 - and returns the character at the
570:16 - beginning of the buffer
570:18 - subsequent calls to fill buff will find
570:20 - a buffer already allocated
570:23 - the only remaining loose end is how
570:24 - everything gets started the array iob
570:27 - must be defined initialized and
570:29 - initialized force
570:31 - stdin std out and std err
570:36 - file iob open square bracket and file
570:39 - close square bracket equals open curly
570:41 - brace open curly brace null comma 0
570:44 - common null comma underscore read comma
570:47 - 0 comma close curly brace comma and
570:50 - that's the standard in
570:52 - the next one is
570:53 - open curly brace null comma 0 common
570:56 - null
570:57 - comma underscore right comma 1 comma
571:00 - close curly brace comma and that's the
571:02 - standard out definition the
571:05 - the sub 1 position and then the next one
571:07 - is open curly brace null comma 0 common
571:10 - null comma underscore right
571:13 - vertical bar
571:15 - underscore on buff comma 2 close print
571:18 - and that is the standard error entry
571:20 - close curly brace semicolon
571:23 - the initialization of the flag part of
571:25 - the structure shows that std standard in
571:27 - is to be read standard out is to be
571:29 - written and standard out is to standard
571:31 - error is to be written unbuffered
571:34 - section 8.6
571:36 - example listing directories
571:39 - i would note that the sample code in
571:40 - section 8.6 shows how we can write
571:43 - applications like ls to interact with
571:45 - directories in a unix file system
571:47 - however the code in this section is not
571:49 - portable to modern unix systems so we'll
571:51 - leave the code as it is in this section
571:54 - it's a good idea to read the code and
571:56 - get an outline of how to work with
571:57 - directories on unix if you want to write
571:59 - code to handle directories you'll need
572:01 - to consult more modern documentation
572:04 - given the complexity of the code in this
572:07 - section we are not going to include it
572:09 - in the
572:10 - copy of this book in this particular
572:12 - media
572:13 - similarly
572:14 - section 8.7
572:16 - example a storage allocator
572:18 - consists of a lot of really complex code
572:21 - and so we will leave that for you to see
572:24 - online
572:26 - at
572:28 - www.cc4e.com book
572:30 - slash chap08.md
572:34 - dynamic memory is hard
572:36 - modern languages like python ruby and
572:38 - java give us high level objects like
572:41 - strings lists and dictionaries
572:43 - these structures automatically expand
572:45 - and correct contract and can be copied
572:47 - into a temporary variable used and then
572:49 - discarded modern languages depend on
572:52 - efficient memory allocation
572:55 - a problem when dynamic memory is heavily
572:57 - used is a fragmentation of the free
572:59 - space
573:00 - you can get to the point where you have
573:01 - plenty of memory but each of the free
573:03 - memory areas is so small that you can't
573:05 - allocate a new memory block
573:07 - when this happens the runtime
573:09 - implementations of these systems run a
573:11 - step called garbage collection where
573:13 - everything pauses and free areas are
573:15 - moved around to make sure that the free
573:17 - memory is in a few large contiguous
573:19 - areas
573:20 - rather than many small non-contiguous
573:22 - areas
573:24 - language developers have been improving
573:25 - garbage collection algorithms for the
573:27 - past 40 years and there is still
573:30 - much work to do
573:32 - now that the authors have established
573:34 - all the reasons that make see the ideal
573:36 - portable systems programming language
573:38 - which i hardly agree with
573:40 - it's time to talk about where c comes up
573:42 - short as a general purpose language for
573:44 - those of us not working on the source
573:46 - code to linux the most challenging
573:48 - aspect of c is the lack of dynamic
573:51 - structures that we can use without the
573:52 - need to carefully allocate use without
573:54 - the regard to the length of dynamically
573:56 - allocated memory and not worry about
573:59 - calling c free every single time we call
574:01 - c alec
574:02 - if a programmer without strong
574:04 - programming skills a good understanding
574:06 - of a testing regimen and a proper
574:08 - defensing defensive programming attitude
574:10 - is let loose in c they will invariably
574:13 - write poor code
574:15 - their c code will make poor use of
574:16 - resources run the system out of memory
574:19 - or produce code that is riddled with
574:20 - security holes and bugs that seem to
574:23 - randomly appear
574:25 - a decade after c emerged and became
574:27 - popular guido van rossum designed a
574:29 - language called python
574:31 - it was one of a number of languages that
574:33 - was built using c and added an
574:35 - object-oriented layer that greatly
574:37 - simplified writing programs that used
574:39 - dynamic memory and added guard rails so
574:42 - programmers did not unintentionally
574:43 - write dangerous or insecure code the key
574:46 - value-add features that make python more
574:48 - appropriate for general purpose
574:50 - programming are the string object list
574:52 - object and dis dict object that handle
574:55 - all aspects of creating and using
574:57 - variables and collections of variables
575:01 - the book has one foot note unix is a
575:04 - trademark of bell laboratories
575:06 - but of course there's more
575:09 - actually the trademark for unix is no
575:10 - longer owned by at t it is owned by the
575:13 - open group but that is a story for
575:15 - another day
575:16 - the unix story arc includes att unix
575:19 - berkeley software de distribution which
575:21 - we call bsd sun microsystems minix linux
575:25 - the open software foundation unix
575:27 - international and others
575:29 - the short version of that story is that
575:31 - at t unix was poised to take over the
575:33 - world as an open source product long
575:36 - before the words open source were ever
575:38 - spoken
575:40 - at t should have and could have defined
575:43 - open source and changed everything by
575:45 - the early 1980s
575:47 - except for a few at t intellectual
575:49 - property lawyers it took over a decade
575:52 - for computer science to pivot away from
575:54 - a nearly exclusive focus on c and a t
575:58 - unix
575:59 - the linux operating system was open
576:01 - source from its inception and became the
576:03 - standard barrier for unix-like operating
576:05 - systems
576:06 - and continues to be the way most of us
576:08 - encounter quote unix
576:10 - it is almost certain that the computer
576:12 - that served this media to you runs linux
576:15 - but that is a story for another time
576:19 - in 1978
576:21 - unix and c were in their glory days and
576:23 - showed the entire computer science field
576:26 - and technology industry the right way
576:28 - forward
576:29 - from that point forward hardware could
576:31 - evolve independently from software
576:34 - with the systems programming language
576:35 - and operating systems patterns sorted
576:37 - the previous 40 years have seen an
576:39 - amazing innovation in hardware
576:42 - capability and performance
576:44 - this 1978 c programming book by brian w
576:48 - kernighan and dennis m richie was the
576:50 - big bang moment for modern computing and
576:53 - computer science
576:55 - we owe them a debt of gratitude for
576:58 - making whatever we do today possible
577:01 - if you have made it to the end of this
577:02 - chapter in this book as your narrator i
577:04 - would like to congratulate and thank you
577:07 - it has been an honor to record and
577:09 - narrate a book of such historical
577:12 - significance for you
577:14 - cheers
577:16 - this work
577:17 - is based on the 1978 c programming book
577:20 - written by brian w kernighan and dennis
577:23 - m ritchie
577:24 - their book is copyright all rights
577:26 - reserved by at t
577:28 - but is used in this work under fair use
577:30 - because of the book's historical and
577:32 - scholarly significance
577:34 - its lack of availability and the lack of
577:36 - an accessible version of the book
577:38 - the book is augmented in places to help
577:40 - understand its rightful place in a
577:42 - historical context amidst the major
577:44 - changes of the 1970s and 1980s as
577:47 - computer science evolved from a hardware
577:49 - first vendor-centered approach to a
577:51 - software-centered approach where
577:53 - portable operating systems and
577:55 - applications written in c could run on
577:57 - any hardware
577:59 - this is not the ideal book to learn c
578:01 - programming because the 1978 edition
578:03 - does not reflect the modern c language
578:06 - using an obsolete book gives us an
578:08 - opportunity to take students back in
578:10 - time and understand how the c language
578:13 - was evolving as it laid the groundwork
578:15 - for a future with portable applications
578:20 - [Music]
578:34 - you

Cleaned transcript:

dr charles severance is one of the world's most popular software instructors and he's the instructor for this c programming course this course is a little different than some of our other courses dr chuck is going to take you through a classic and important book on c programming you will occasionally have to pause the video to do some assignments to check your comprehension it's going to be a challenge but it will definitely be worth it if you want to have a deep understanding of the c programming language and if you're completely new to programming you may want to watch dr chuck's python for everybody course first welcome to c programming for everybody my name is charles severance and i'm your instructor for this course this course and website is dedicated to learning the classic version of c programming language from the 1978 book written by brian w kernighan and dennis m ritchie this book places the reader in the middle of the 1970s transition from a hardwarecentered computer science to a focus on writing portable and efficient software c was used to develop operating systems like unix minix and linux programming languages like perl python java and javascript and ruby are all written in c software like early tcp networking stack implementations that made the internet possible were written in c and the first web browsers and web servers were written in c writing software in c enabled major advances in computer architecture and performance operating systems compilers and utilities could be recompiled to work on a new hardware platform once we had a c compiler for the new hardware so much software has been written in c over the past 40 years that there's a very good chance that much of the software that you use every day was either written in c or written in a programming language that was written in c so we study c less as a programming language to use on a daily basis and more as the foundation of modern software and computing in many ways c is the technology equivalent of the rosetta stone in that it provides a connection between the programming languages of the past and the programming languages of the present the name cc4e in www.cc4e.com refers to the original unix command cc which was the command that you used to compile your c program cc stood for c compiler and it is featured on the first page of the first chapter of the knrc book programmers like me from the 1970s and 1980s typed cc on unix systems like the att 3b2 to compile and run their first hello world program in c this material is being presented under fair use as we are making use of material from a copyrighted work that is out of print and not broadly available in any format the book is also not available in any accessible format we are making use of this material in a teaching and research context with a focus on studying its contribution to computing history the material is available for free and online to anyone who wants to learn about the history of a c language computing and computer architecture welcome to the course welcome to c programming for everybody my name is charles severance and this is my reading of the 1978 c programming book written by brian kernighan and dennis ritchie at times i add my own interpretation of the material from a historical perspective chapter 0 introduction c is a general purpose programming language it has been closely associated with the unix system since it was developed on that system and since unix and its software are written in c the language however is not tied to any one operating system or machine and although it has been called a system programming language because it is useful for writing operating systems it has been used equally well to write major numerical text processing and database programs c is a relatively low level language this characterization is not pejorative it simply means that c deals with the same sort of objects that most computers do namely characters numbers and addresses these may be combined and moved about with the usual arithmetic and logical operators implemented by actual machines c provides no operations to deal directly with composite objects such as character strings sets lists or arrays considered as a whole there is no analog for example of the pl1 operations which manipulate an entire array or string the language does not define any storage allocation facility other than static definition and the stack discipline provided by the local variables of functions there is no heap or garbage collection like that provided by algol 68. finally c itself provides no input output facilities there are no read or write statements and no wired in file access methods all of these higher level mechanisms must be provided by explicitly called functions i would note that the lack of a heap or garbage collection feature in c is both one of the great strengths of the language and at the same time is likely the reason that the average programmer will never develop or maintain a major c application during their career c provides a simple feature using malloc and free functions that allow a programmer to request a certain amount of memory be allocated dynamically use the memory and then return the memory to the c runtime library for reuse for example to convert a jpeg image to a png image our application will read the jpeg data into memory then convert the image into a png image in memory and then write the png data out to a file we don't know how large the images will be in advance so we request whatever size we need from c and then give it back when we're done the term heap refers to the memory that c manages on our behalf when we need to borrow a bit of memory and give it back later there are a couple of issues with a simple heap implementation first if we forget to call free when we are done with a memory we have created a memory leak and our program will eventually run out of memory and abort c places the onus of giving back any dynamically allocated memory on the programmer modern languages like java javascript and python keep track of when we stop using dynamic memory using a dynamic memory layer that can automatically reclaim the memory the more difficult problem is after a series of calls to malik and free the heap space becomes fragmented and some cleanup is needed this cleanup is called garbage collection efficient memory allocation and garbage collection has been the subject of decades of computer science research the java language has built a number of increasingly effective garbage collection approaches over the years kernighan and ritchie in one simple paragraph define most of the problem as out of scope for the c language which makes it a bit challenging for us to make good use of dynamic memory allocation in c but when we do it properly it performs very well if you are currently using a language like java python or php every time you create a new string through concatenation without thinking about memory allocation remember to appreciate the decades of work by computer scientists that made it easy for you kernighan and ritchie knew that garbage collection was difficult so they left it out of the c language and put it into a run time library back to chapter zero similarly c offers only straightforward single thread control flow constructions tests loops grouping and subprograms but not multiprogramming parallel operations synchronization or coroutines though the absence of some of these features may seem like a grave deficiency you mean i have to call a function to compare two character strings keeping the language down to modest dimensions has brought real benefits since c is relatively small it can be described in a small space and learned quickly a compiler for c can be simple and compact compilers are also easily written using current technology one can expect to prepare a compiler for a new machine in a couple of months and to find that eighty percent of the code of a new compiler is common with existing ones this provides a high degree of language mobility because the data types and control structures provided by c are supported directly by most existing computers the runtime library required to implement selfcontained programs is tiny on the pdp11 for example it contains only the routines to do 32bit multiplication and division and to perform subroutine entry and exit sequences of course each implementation provides a comprehensible compatible library of functions to carry out input output string handling and storage allocation operations but since they are only called explicitly they can be avoided if required and they can also be written portably in c itself again because the language reflects the capabilities of current computers c programs tend to be efficient enough that there is no compulsion to write assembly language instead the most obvious example of this is the unix operating system itself which is written almost entirely in c of 13 000 lines of system code only about 800 lines at the very lowest level are an assembler in addition essentially all of the unix application software is written in c the vast majority of unix users including one of the authors of this book do not even know the pdp11 assembly language i would note that in this preface the authors are carefully explaining the fact that many of the wellestablished programming languages of the 1960s and 1970s like fortran cobalt pascal algol and pl1 were solving many of the use cases that were needed by us programmers by adding syntax to the languages the creators of c and unix were advocating for a more minimal set of programming language constructs and more reliance on calling function in provided runtime libraries to meet programmer use cases it may have seemed a strange approach for experienced programmers in the 1980s but over time it has allowed c to expand to meet a very wide range of programmer needs without requiring major revisions to the core language or compiler back to chapter 0. although c matches the capabilities of many computers it is independent of any particular machine architecture and so with a little care it is easy to write portable programs that is programs which can be run without change on a variety of hardware it is now routine in our environment that software developed on unix is transported to local honeywell ibm and inner data systems in fact the c compilers and runtime support on these four machines are much more compatible than the supposedly ansi standard versions of fortran the unix operating system itself now runs on both the pdp11 and the interdata 832 outside of programs which are necessarily somewhat machine dependent like the compiler assembler and debugger software written in c is identical on both machines within the operating system itself the 7 000 lines of code outside of the assembly language support and the i o device handlers is about 95 percent identical as a note before unix and c if you are running the vendor operating system and writing in the best language for systems like the pdp 11 and inner data 732 the user experience was completely different today we take for granted that we expect to be able to download the same application for windows mac os or a linux system even in the 1970s those that were using unix and c could write code once and move it between two hardware platforms and expect that it would work with no or relatively few changes back to chapter zero for programmers familiar with other languages it may prove helpful to mention a few historical technical and philosophical aspects of c for contrast and comparison many of the most important ideas of c stem from the considerably older but still quite vital language bcpl developed by martin richards the influence of bcpl on c proceeded indirectly through the language b which was written by ken thompson in 1970 for the first unix system on the pdp7 although it shares several characteristic features with bcpl c is in no sense a dialect of it bcpl and b are typeless language the only data type is the machine word and access to other kinds of objects is by special operators or function calls in c the fundamental data objects are characters integers of several sizes and floating point numbers in addition there is a hierarchy of derived data types created with pointers arrays structures unions and functions c provides the fundamental control constructions required for wellstructured programs statement grouping decision making with if looping with termination test at the top using for and while or at the bottom using do and selecting one of a set of possible cases switch all of these were provided in bcpl as well though with somewhat different syntax that language anticipated the vogue for structured programming by several years c provides pointers in the ability to do address arithmetic the arguments to functions are passed by copying the value of an argument and is impossible for the called function to change the actual argument in the caller when it is desired to achieve call by reference a pointer may be passed explicitly and the function may change the object to which the pointer points array names are passed as the location of the array origin so array arguments are effectively call by reference any function can be called recursively and its local variables are typically automatic or created anew with each invocation function definitions may not be nested but variables may be be declared in a block structured fashion the functions of a c program may be compiled separately variables may be internal to a function external but known only within a single source file or completely global internal variables may be automatic or static automatic variables may be placed in registers for increased efficiency but the register declaration is only a hint to the compiler and does not refer to specific machine registers c is not a strongly typed language in the sense of pascal or algol 68 it is relatively permissive about data conversion although it will not automatically convert data types with the wild abandon of pl1 existing compilers provide no run time checking of array subscripts or argument types etc for those situations where strong type checking is desirable a separate version of the compiler is used this program is called lint apparently because it picks up bits of fluff from one's program lint does not generate code but instead applies a very strict check as to many aspects of the program as can be verified at compile and load time it detects type mismatches inconsistent argument use unused or apparently uninitialized variables potential portability difficulties and the like programs which pass unscathed through lint enjoy with few exceptions freedom from type errors about as complete as do for example alcohol 68 programs we will mention other lint capabilities as the occasion arises i would note that separately checking for things that might be wrong into the lint program keeps the c compiler simple and easy to port to a new computer the lint program was naturally a very portable text processing application while there's some overlap between a lint program and a compiler over time there's quite distinct research and expertise in how to lint versus how to compile modern lint programs look at programs in far more detail than most compilers separating concerns of lint and the c compiler also allowed lint programs to use more memory and take more time to execute than compilers since the typical developer might use the compiler many times per day and run lint less often it was nice for the compiler to run quickly and make light use of computer resources we call this idea of building two smaller complementary programs that each specialize in one task separation of concerns and it is an important principle in computer science by keeping each component simple in focus we can more easily build test and verify each component unix and c showed the benefits of taking many small components approach to solve an overall set of problems back to chapter zero finally c like any other language has its blemishes some of the operators have the wrong precedence some of the syntax could be better there are several versions of the language extent differing in minor ways nonetheless c has proven to be an extremely effective and expressive language for a wide variety of programming applications the rest of this book is organized as follows chapter 1 is a tutorial introduction to the central part of c the purpose is to get the reader started as quickly as possible since we believe strongly that the only way to learn a new language is to write programs in it this tutorial does assume a working knowledge of the basic elements of programming there is no explanation of computers of compilation nor the meaning of an expression like n equals n plus one although we have tried where possible to show useful programming techniques the book is not intended to be a reference work on data structures and algorithms when forced to make a choice we have concentrated on the language chapters two through six discuss the various aspects of c in more detail and rather more formally than does chapter 1 although the emphasis is still on working examples of complete useful programs rather than isolated fragments chapter 2 deals with basic data types operators and expressions and chapter 3 treats control flow if else while 4 etc chapter 4 covers functions and program structure external variables scope rules and so on chapter 5 discusses pointers and address arithmetic and chapter 6 contains the details of structures and unions chapter 7 describes the standard cio library which provides a common interface to the operating system this io library is supported on all machines that support c so programs which use it for input output and other system functions can be moved from one system to another essentially without change chapter eight describes the interface between c programs and the unix operating system concentrating on input output the file system and portability although some of this chapter is unix specific programmers who are not using unix systems should still find useful material here including some insight on how one version of the standard library is implemented and suggestions on achieving portable code appendix a contains the c reference manual this is the official statement of the syntax and semantics of c and except for one owns compiler the final arbiter of any ambiguities and omissions from earlier chapters since c is an evolving language that exists on a variety of systems some of the material in this book may not correspond to the current state of developments for a particular system we have tried to steer clear of such problems and warn of potential difficulties when in doubt however we have chosen generally to describe the pdp11 unix system since that is the environment of the majority of c programmers appendix a also describes implementation differences on the major c systems chapter 1 a tutorial introduction let us begin with a quick introduction to c our aim is to show the essential elements of the language in real programs but without getting bogged down in details formal rules and exceptions at this point we are not trying to be complete or even precise we want you to get as quickly as possible to the point where you can write useful programs and to do that we have to concentrate on the basics variables and constants arithmetic control flow functions and the rudiments of input and output we are quite intentionally leaving out of this chapter features of c which are of vital importance for writing bigger programs these include pointers structures and most of c's rich set of operators several control flow statements and a myriad of details this approach has its drawbacks of course most notable is that the complete story on any particular language feature is not found in a single place the tutorial by being brief may also mislead and because they cannot use the full power of c the examples are not as concise and elegant as they might be we have tried to minimize these effects but be warned another drawback is that later chapters will necessarily repeat some of this chapter in any case experienced programmers should be able to extrapolate from the material in this chapter to their own programming needs beginners should supplement it by writing small similar programs of their own both groups can use it as a framework on which to hang the more detailed descriptions that begin in chapter 2. 1.1 getting started the only way to learn a new programming language is by writing programs in it the first program to write is the same for all languages print the words hello world this is the basic hurdle to leap over it you have to be able to create the program text somewhere compile it successfully load it run it and find out where your output went with these mechanical details mastered everything else is comparatively easy in traditional c the program to print hello world is main open parenthesis closed parenthesis open curly brace printf parentheses double quote hello comma space world backslash n double quote close parentheses semicolon close curly brace the modern minimal version of this program needs a bit more syntax we add a single line at the beginning hashtag include space left angle brackets stdio.h right angle bracket pound include stdio.h we have to add that line for the modern program back to the book just how to run this program depends on the system that you're using as a specific example on the unix operating system you must create the source program in a file whose name ends in dot c such as hello dot c and then you compile it with the command cc space hello.c if you haven't botched anything such as omitting a character or misspelling something the compilation will proceed silently and make an executable file called a dot out running that by the command a dot out will produce hello comma world as its output on other systems the rules will be different check with a local expert on modern systems we use the gcc compiler with the dash ansi option to accept the legacy syntax of c so we use gcc space minus ansi space hello.c and to run the resulting a dot out file you usually you need to prepend the local directory because most shell configurations do not include the current path in the paths to search for applications so you need to write dot slash a dot out now for some explanations about the program itself a c program whatever its size consists of one or more functions which specify the actual computing operations that are to be done c functions are similar to functions and subroutines of a fortran program or the procedures of pl1 pascal etc in our example main is such a function normally you are at liberty give functions whatever names you like but main is a special name your program begins executing at the beginning of main this means every program must have a main somewhere main will usually invoke other functions to perform its job some coming from the same program and others from libraries of previously written functions one method of communicating data between functions is by arguments the parentheses following the function name surround the argument list here main is a function of no arguments indicated by open parentheses close parentheses the curly braces enclose the statements that make up the function they're analogous to the due end of pl1 or the begin end of algol or pascal and so on a function is invoked by naming it followed by a parenthesized list of arguments there is no call statement as there is in fortran or pl1 the parentheses must be present even if there are no arguments in the above text the authors were making connections to the popular general purpose programming languages of the time when the book was written it was not all assured that c and c like languages would ever evolve past writing high performance applications like operating system kernels and device drivers by comparing c to these more general purpose languages the authors are trying to plant the seed that c could have value as a general purpose language back to the text the line that says printf parentheses double quote hello comma space world backslash and double quote close parentheses semicolon is a function call which calls a function named printf with the argument hello world printf is a library function which prints the output to the terminal unless some other destination is specified in this case it prints the string of characters that make up its argument any sequence of any number of characters enclosed in double quotes is called a character string or string constant for the moment our only use of the character strings will be as arguments to printf and other functions the sequence backslash n in the string is c notation for the new line character which when printed advances the terminal to the left margin on the next line if you leave out the backslash n a worthwhile experiment by the way you will find that your output is not terminated by a line feed the only way to get a new line character into the printf argument is with backslash n if you try to break it into two lines like printf quote hello world and then just hit the return double quote close parentheses semicolon on a new line the c compiler will print out unfriendly diagnostics about missing quotes printf never supplies a new line automatically so multiple calls can be used to build up an output line in stages our first program could have just as well been written as main open parenthesis closed parenthesis open curly brace printf quote hello quote semicolon printf quote world quote semicolon print f backslash n semicolon and then on a sixth line closed curly brace and it would have produced the identical output note that backslash n represents only a single character an escape sequence like backslash n provides a general and extensible mechanism for representing hard to get or invisible characters among the others that c provides are backslash t for tab backslash b for backspace backslash double quote for double quote and backslash backslash for the backslash itself 1.2 page 8 variables and arithmetic the next program prints the following table of fahrenheit temperatures in their centigrade or celsius equivalents using the formula c equals parenthesis 5 divided by 9 closed parenthesis parenthesis f minus 32. the table contains fahrenheit of 0 celsius of negative 17.8 fahrenheit at 20 celsius of negative 6.7 fahrenheit of 40 celsius of 4.4 and so forth here is the program itself for reference this program is on page 29 of the textbook so it starts with pound include stdio.h to include the standard library then it has a comment that says print the fahrenheit celsius table for f equals zero comma twenty comma dot dot dot comma three hundred close comment main open parenthesis close parenthesis open curly brace int lower comma upper comma step semicolon float far comma celsius lower equals zero semicolon followed by a comment upper equals 300 semicolon followed by a comment step equals 20 semicolon followed by a comment far equals lower and then while open parenthesis far less than or equal to upper closed parenthesis open curly brace celsius equals parenthesis 5.0 slash 9.0 closed parenthesis asterisk open parenthesis far minus 32.0 close parentheses semicolon then a printf statement printf open parentheses double quote percent 4.0 f space percent 6.1 f backslash n close quote comma far comma celsius close parentheses semicolon far equals far plus step and then a closing curly brace to finish the while statement and then a closing curly brace to finish the main statement the first two lines slash star print fahrenheit to celsius table for f equals zero comma twenty dot dot dot three hundred star slash are a comment which in this case explains briefly what the program does any characters between star and star slash are ignored by the compiler they may be used to freely make the program easier to understand comments may appear anywhere a blank or new line can in c all variables must be declared before use usually at the beginning of a function before any executable statements if you forget a declaration you will get a diagnostic from the compiler a declaration considered consists of a type and a list of variables that have that type as in int lower comma upper comma step semicolon float far celsius semicolon the type int implies that the variables listed are integers float stands for floating point i.e numbers which may have a fractional part the precision of both int and float depends on the particular machine that you are using on the pdp11 for instance an int is a 16bit signed number that is one that lies between negative 32 eight and positive thirty two thousand seven sixty seven a float number is a thirty two bit quantity which amounts to about seven significant digits with a magnitude of about ten to the minus thirty eight and 10 plus 38. chapter 2 lists the sizes for other machines i would note that the 1970s was a time of transition in the amount of memory installed in computers the c language int type was 16 bits in the older but more generally available computers like the pdp11 c could be used to write programs like the unix operating system that made efficient use of available memory in particular the 1978 version of c did not require that computers support 32bit integers but 32768 is a pretty small number the size of an integer affected the maximum size of arrays and strings a lot of early c programs use the long type to get at least a 32bit integer capable of representing numbers up to about 2 billion in modern modern computers and databases we tend to choose between 32bit and 64bit integers back to the text c provides several other basic data types besides int and float char is a character a single byte short is a short integer long is a long integer and double is a double precision floating point size of these objects are also machine dependent and details are in chapter 2. there are also arrays structures and unions of these basic types and pointers to them and functions that return them all of which we will meet in due course the actual computation in our temperature conversion program begins with the assignments lower equals zero upper equals 300 step equals 20 far equals lower all ending with semicolon these set the variables to their starting vari values individual statements are terminated by semicolons each line of the table is computed in the same way so we use a loop which repeats once per line this is the purpose of the while statement while parentheses far less than or equal upper close parentheses open curly brace then the body of the loop and then close curly brace the condition in the parentheses is tested if it is true i.e far is less than or equal to upper the body of the loop all of the statements included between the open curly brace and the closed curly brace are executed and the condition is retested if true the body is executed again when the test becomes false i.e far exceeds upper the loop ends and execution continues at the statement that follows the loop there are no further statements in the program so it terminates the body of a while loop can be one or more statements enclosed in braces as the temperature converter or a single statement without braces as in while open parentheses i less than j closed parenthesis i equals two times i semicolon in either case the statements controlled by the while are indented by one tab stop so you can see at a glance what statements are inside the loop the indentation emphasizes the logical structure of the program although c is quite permissive about statement positioning proper indentation and the use of white space are critical in making programs easy for people to read we recommend writing only one statement per line and usually leaving blanks around operators the position of the braces is less important we have chosen one of the several popular styles pick a style that suits you and then use it consistently i would add that with these words the authors triggered a great debate about how to best indent code and use curly braces that continues to this day the intention style used in this book is often referred to as the k and r style it tends to put open braces at the end of statements like if and while to keep code more compact in terms of the number of lines of code the best advice is not to debate at all when you modify someone else's code just imitate the style that they used when they wrote their code back to the text most of the work gets done in the body of the loop the celsius temperature is computed and assigned to the celsius variable by the statement celsius equals open parenthesis 5.0 slash 9.0 close parenthesis asterisk open parenthesis far minus 32.0 close parentheses semicolon the reason for using 5.0 9.0 instead of the simpler looking five slash nine is that in c as in many other languages integer division truncates so that any fractional part is discarded thus five slash nine is zero and of course so would then all the temperatures be zero a decimal point in a constant indicates that it is floating point so that 5.0 over 9.0 is 0.555 repeating which is what we want we also wrote 32.0 instead of 32 even though since far is a float 32 would automatically be converted to flow before the subtraction but as a matter of style it's wise to write floating point constants with explicit decimal points even when they have integral values it emphasizes their floating point nature for human readers and ensures the compiler will see things the way you do as well i would note that for those of you familiar with python before python 3 integer division truncated and returned an integer just like c in python 3 one of the major improvements was that the division of two integers performed the division operation in floating point and returns a floating point result c and python 2 made the choice because of efficiency integer division with truncation especially for 16bit numbers was quite fast in the 1970s computers compared to floating point division that kept the fractional part intact early pdp11 computers did integer division in hardware while all floating point was done with loops and functions so it was far slower if you wanted to write fast code in the 1970s you avoided floating point numbers except for special situations modern computers usually do 64bit floatingpoint operations almost at the same speed as integer division so we don't need to allow programmers to avoid using floating point computations in their code the detailed rules for when integers are converted to floating point are in chapter 2. for now notice that the assignment far equals lower semicolon and the test while far less than or equals upper both work as expected the int is converted to a float before the operation is done this example also shows a bit more of how printf works printf is actually a general purpose format conversion function which we will describe completely in chapter 7. its first argument is a string of characters to be printed with each percent sign indicating where one of the other second third etc arguments is to be substituted and what form it is to be printed in for instance in the statement printf parentheses double quote percent 4.0 f space percent 6.1 f backslash n double quote comma far comma celsius the conversion specification percent 4.0 f says that a floating point number is to be printed in a space at least four characters wide with no digits after the decimal point percent 6.1 f describes another number to occupy at least six spaces with one digit after the decimal point analogous to the f 6.1 of fortran or the f parentheses six comma one of pl1 parts of a specification may be omitted percent six f says that the number is to be at least six characters wide percent.2f requests two places after the decimal point but the width is not constrained and merely percent f says to print the number itself as floating point printf also recognizes percent d for decimal integers percent o for octal percent x for hexadecimal and percent c for characters and percent s for a character string and percent percent for the percent itself each percent construction in the first argument of printf is paired with its corresponding second third etc argument they must line up properly by number and type or else you'll get meaningless answers by the way printf is not part of the c language there is no input or output defined in c itself there is nothing magic about printf it's just a useful function which is part of the standard library of routines that are normally accessible to c programs in order to concentrate on c itself we might we won't talk much about io until chapter seven in particular we'll defer formatted input until then if you have to input numbers read the discussion of the function scanf in chapter 7 section 7.4 scanf is much like printf except that it reads input instead of writing output the balance between building a feature into the language itself and providing it as a function in a library is something that computer language designers struggle with many years later for example in python 2 print was a language element in python 3 one of the nonupwards compatible and somewhat unpopular changes was changing print to be a function many programmers feel that a print statement is a more elegant way to express printing but from a compiler and language design perspective a function call with a variable number of parameters is seen as technically more elegant and flexible with kernighan and richie focused on keeping everything small and portable they opted to keep all input output functionality in libraries the syntax is a little more complex but given how computing has changed in the past 30 years it is the right choice section 1.3 the for statement as you might expect there are plenty of different ways to write a program let's try a variation on the temperature converter this is sample code is on page 11 of the textbook pound sign include less than stdio.h greater than main open parentheses closed parenthesis open curly brace int bar that is f a h r semicolon four open parenthesis far equals zero semicolon far less than or equal to three hundred semicolon far equals far plus 20 close parenthesis printf open parentheses double quote percent 4d space percent 6.1 f backslash n close print a close quote comma far comma open parenthesis 5.0 slash 9.0 close parentheses asterisk open parenthesis far minus 32 close parentheses close parenthesis semicolon this code produces the same answers as the one before but it certainly looks different one major change is the elimination of most of the variables only far fahr remains as an int to show the percent d conversion in printf the lower and upper limits of the step size appear only as constants in the for statement itself the 4 is a new construction and the expression that computes the celsius temperature now appears as the third argument of printf instead of in a separate assignment statement this last change is an instance of a quite general rule in c in any context where it is permission permissible to use the value of a variable of some type you can use an expression of that type since the third argument of printf has to be a floating point value to match the percent 6.1 f any floating point expression can occur there the 4 itself is a loop a generalization of while if you compare it to the earlier while its operation should be clear it contains three parts separated by semicolons the first part far equals zero is done once before the loop proper is entered the second part is the test or condition that controls the loop far less than or equal to 300. this condition is evaluated if it is true the body of a loop in this case a single printf is executed then the reinitialization step far equals far plus 20 is done and the condition is reevaluated the loop terminates when the condition becomes false as with the while the body of the loop can be a single statement or a group of statements enclosed in braces the initialization and reinitialization parts can be any single expression the choice between while and four is arbitrary and should be based on what seems clearer the four is usually appropriate for loops in which the initialization and reinitialization are single statements and logically related since it is more compact than while and keeps the loop control statements together in one place i would note that the syntax of the for and while loop is a feature of c and derived c like languages in modern languages we tend to have two kinds of loop structures determinant and indeterminate the four and the while loop structures in c are both indeterminate because you must read them closely to make sure they are properly constructed and for example are not unintentionally infinite loops an example of a determinant loop is the for each loop in php or the for loop in python the semantics of both of these loops is to iterate all the elements in a collection but since collections are never infinite you can be assured that these determinant loops will not run forever section 1.4 symbolic constants a final observation before we leave temperature conversion it's a bad practice to bury magic numbers or magic constants like 320 or 320 in a program they convey little information to someone who might read the program later and they're hard to change in a systematic way fortunately c provides a way to avoid such magic numbers with the pound sign defined construction at the beginning of a program we can define a symbolic name or symbolic constant to be a particular string of characters thereafter the compiler will replace all unquoted occurrences of the name by the corresponding string the replacement for the name can actually be any text at all it's not related to numbers so this is a sample code on page 13 of the text pound sign include less than stdio.h greater than next line pound define space lower space zero next line pound define space upper space 300 pound define space step space 20. for these pound sign statements i would note that they have to start in the first column the rest of this sample code is the code itself main open parenthesis closed parenthesis open curly brace int far fahr for open parentheses far equals uppercase lower semicolon far less than or equal to uppercase upper semicolon far equals far plus uppercase step then the same print statement printf open parentheses double quote percent 4d space percent 6.1 f backslash n quote comma far comma percent 5.0 9.0 close parentheses asterisk open parenthesis far minus 32 close parenthesis close parenthesis semicolon and then to end the program close curly brace the quantities uppercase lower uppercase upper and uppercase step are constants so they do not appear in declarations symbolic names are commonly written in uppercase so they can be readily distinguished from lowercase variable names notice that there is no semicolon at the end of a pound defined statement since the whole line after the defined name is substituted there would be too many semicolons in the four section 1.5 a collection of useful programs we are now going to consider a family of related programs for doing simple operations on character data you will find that many programs are just expanded versions of the prototypes we discuss here character input and output the standard library provides functions for reading and writing a character at a time getchar fetches the next input character each time it is called and returns the character as its value that is after c equals get char open parentheses close parenthesis the variable c contains the next character of input these characters normally come from the terminal or keyboard but that need not concern us until chapter 7. the function put char open parentheses c close parenthesis is the complement of getchar put chair open parenthesis c close parenthesis prints the content of the variable c on some output medium again usually the terminal or screen calls to put char in printf may be interleaved the output may be a p will appear in the order in which the calls are made as with printf there is nothing special about gachar and putchar they are not part of the c language but they are universally available once again i would note that the authors are making the case that the syntax of the language should not include syntax for input output operations but instead call library functions keeping the compiler small and easy to port new systems was important to the creators of c and even if something like put char was part of the language syntax it would be translated at runtime to call a function programming languages from the 1960s tended to have a small set of use cases read some input run some calculation and then write some output so it seemed like a few language elements would be sufficient to describe all programs but as programs started to make network connections draw buttons on a screen or respond to api calls over the network it would have been difficult to keep expanding the core language syntax for each new use case but it was extremely natural to add new libraries to languages like c with functions to call to accomplish these new use cases file copying given getchar input char you can write a surprising amount of useful code without knowing anything more about input output the simplest example is a program which copies its input to its output one character at a time in outline here's what we do get a character while the character is not the end of file signal i'll put the character we just read and then get a new character converting this into c gives us the sample code on page 14 of the textbook pound includes stdio.h main open parentheses closed parentheses open curly brace int c semicolon c equals get char open parenthesis close parenthesis semicolon while c not equal eof uppercase eof close parenthesis open curly brace put char c c equals get char semicolon close parentheses close curly brace the relational operator exclamation equals means not equal to the main problem is detecting the end of the input by convention getchar returns the value which is a not a valid character when it encounters the end of input in this way programs can detect when they did not get a character and they've actually simply run out of input the only complication which is a serious nuisance is that there are two conventions in common use about what that endophile value really is we have deferred this issue by using the symbolic name eof capital eof for the value whatever it might be in practice eof will be either negative one or zero so the program must be pro seated by the appropriate pound define eof 1 or pounddefying eof0 to work properly by using the symbolic constant eof to represent the value that getcha returns when the end of file occurs we are assured that only one thing in the program defines on the specific depends on the specific value numeric value of eof i would note most of that is incorrect modern c compilers actually define eof in the stdio.h include file so you never define eof in your code in modern c the value of eof is minus one you should just include stdio.h and use predefined eof constant to check for end to file the nuisance of different values for eof was resolved shortly after 1978. continuing with the text we also declare c to be an int not a chair char so that it can hold the value which get char returns as we'll see in chapter two the value is actually an int because it must be capable of representing and defile in addition to all possible characters so the program for copying could actually be written more concisely by experienced c programmers in c any assignment such as c equals get char open parentheses close parenthesis can be used in an expression its value is simply the residual value being assigned to the left hand side if the assignment of a character to the variable c is put inside the test part of a while statement the file copy program can be written as shown in the example code on page 15 of the textbook pound include stdio.h main open parenthesis close parenthesis open curly brace int space c semicolon while open parenthesis open parenthesis c equals get char open parenthesis close parenthesis close parenthesis not equal eof close parenthesis put char c parentheses c close parenthesis semicolon close curly brace the program gets a character assigns it to c and then tests whether the character was the end of file signal if it was not the body of the wireless executed printing the character the while then repeats when the input is end of input is finally reached the wild terminal terminates and so does main this virtual version centralizes the input there is now only one call to get char and shrinks the program nesting an assignment is a test of one of the places where c permits a valuable conciseness it is possible to get carried away and create impenetrable code though a tendency that we will try though that is a tendency we will try to curb it's important to recognize that the parentheses around the assignment within the conditional are really necessary the precedence of exclamation equal not equals is higher than that of equals the assignment operator which means that in absence of parentheses the relational test exclamation equals would be done before the assignment equals so the statement c equals get char parentheses open parentheses close parenthesis not equal eof is equivalent to c equals get char open no sorry is equivalent to c equals open parenthesis get char open press the close parenthesis not equal eof close parenthesis this has the undefined desired effect of setting it is important to recognize that the parentheses around the assignment within the conditional are really necessary the precedence of exclamation equals is higher than that of equals which means that in the absence of parentheses the relational test not equals would be done before the assignment so the statement c equals get char not equal eof is equivalent to c equals open parenthesis getchar not equal eof close parenthesis this has the undesired effect of setting c to zero or one depending on whether or not the call of getchar encountered the end of file more on this in chapter 2. the next program counts characters it is a small elaboration of the copy program this sample code is on page 16 of the textbook pound include stdio.h main open parenthesis close parenthesis open curly brace long nc semicolon and c equals 0 semicolon while open parenthesis get char open parentheses close parenthesis exclamation equal eof plus plus nc semicolon printf double quote percent ld backslash n double quote comma nc parentheses semicolon close curly brace the statement plus plus nc semicolon shows a new operator plus plus which means increment by one you could write nc equals nc plus one but plus plus nc is more concise and often more efficient there is a corresponding operator minus minus to decrement by one the operators plus plus and minus minus can either be prefix operators plus plus c and c or postfix and c plus plus these two forms have different values and expressions as will be shown in chapter two but plus plus nc and nc plus plus both increment and c for the moment we'll stick to the prefix form the character counting program accumulates its count in a long variable instead of an int on a pdp 11 the maximum value of an int is 32 767 and it would take relatively little input to overflow that counter if it were declared as an int in honeywell and ibm c long and int are synonymous and much larger the conversion specification percent ld signals to printf that the corresponding argument is a long integer we again as a note we again see another reference to the fact that the number of bits of the int type is in transition in 1978. the older pdp11 used a 16bit integer to save limited memory on a small almost obsolete computer while later computers from ibm and honeywell have already switched to their int type to be 32 bits this allowed code originally for written for the pdp11 like unix or even the c compiler to be recompiled on the ibm or honeywell with very few changes to cope with bigger numbers you can use a double which is a double length float we will also use a for statement instead of a while to illustrate an alternate way to write a while loop this code is the second sample code on page 16 of the textbook pound include stdio.h main open parentheses closed parentheses open curly brace double nc semicolon four open parenthesis nc equals zero semicolon get our open parenthesis close parenthesis not equal eof semicolon plus plus nc close parenthesis and then a semicolon the semicolon in this case is an empty statement because there's nothing in the body of the of the for loop and at the end we say printf double quote percent dot zero f backslash n double quote comma nc close parentheses semicolon close curly bracket printf uses percent f for both float and double percent.0f suppresses printing of the nonexistent fraction part the body of the for loop here is empty because all the work is done in the test and reinitialization parts of the for loop but the grammatical rules of c require that a for statement have a body the isolated simply semicolon technically a null statement is there to satisfy that syntax requirement we put it on a separate line to make it more visible before we leave the character counting program observe that if the input contains no characters the while or for test fails on the very first call to get char so that the loop program produces zero the right answer this is an important observation one of the nice things about while and four is they are tested at the top of the loop proceed before proceeding with the body if there is nothing to do nothing is done even if that means never going through the loop body programs should act intelligently when hand handed input like no characters the while and the four statements help ensure that they do reasonable things with boundary conditions line counting the next program counts lines in its input input lines are assumed to be terminated by the newline character backslash n that has been carefully appended to every line written out this is sample code on line 17 of the textbook pound includes stdio.h main open parenthesis close parenthesis open curly brace int c comma nl semicolon nl equals zero semicolon while open parenthesis open parenthesis c equals get char open parentheses close parenthesis close parenthesis not equal eof close parenthesis if open parenthesis c double equals single quote backslash n single quote close parentheses plus plus nl semicolon printf double quote percent d backslash n double quote comma nl close parentheses semicolon close curly brace the body of the while loop now consists of an if which in turn controls the increment plus plus nl the if statement tests its parenthesized condition and if true does the statement or group of statements inside braces that follow we have again indented to show what is controlled by what the double equal sign in is the c notation for is equal to like fortrans dot eq dot this symbol is used to distinguish the equality test the question being asked from the single equal sign used for assignment since assignment is about twice as frequently used as equality testing in typical c programs it's appropriate that the operator be half as long a single character can be written between single quotes to produce a value equal to the numerical value of the character in the machine's character set this is called a character constant so for example single quote a single quote is a character constant in the ascii character set its value is 65 the internal representation of the character a of course double single quote a single quote is to be preferred over 65 its meaning is obvious and it is independent of a particular character set these escape sequences that are used in character strings are also legal in character constants so in tests and arithmetic expression expressions single quote backslash n single quote stands for the value of a new line character you should note carefully that single quote backslash n is a single quer character and an expressions is equivalent to a single integer on the other hand double quote backslash n double quote is a character string which happens to contain only one character the topics of strings versus characters is discussed further in chapter two the numeric values that are shown for characters are using the ascii character set the character sets in the 1970s were quite intricate most were eight bits long to conserve computer memory and only support a hundred or so latinlike characters this is why early programming languages use special characters like asterisk and curly brace in their syntax very carefully they needed to choose characters that were commonly available on computer keyboards from different manufacturers modern programming languages like python 3 and ruby store internal string values using the unicode character set so they are all able to represent all the characters in all languages around the world modern languages tend to represent 8bit values in the range from 0 to 256 using a byte or similar type python 2 strings were stored as 8 bit bytes and python 3 strings are stored as 32bit unicode characters moving to unicode was a major effort in the python 2 to python 3 transition word counting the fourth in our series of useful programs counts lines words and characters with a loose definition that a word is any sequence of characters that does not contain a blank a tab or a new line this is a very very bare bones version of the unix utility wc this example is on page 18 in the textbook pound include stdio.h pound define yes 1 pound to find no 0. main open parenthesis close parenthesis open curly brace int c comma nl comma nw comma nc come in word inward equals no l equals nw equals nc equals zero while open parenthesis open parenthesis c equals get char not equal to eof open curly brace plus plus nc if parentheses c double equals quote backslash n quote parenthesis plus plus nl if open parenthesis c double equals single quote space single quote double vertical bar c double equals single quote backslash n single quote double vertical bar c equals equals single quote backslash t single quote close parenthesis inward equals no else if open parenthesis inward equal equal no close parenthesis open curly brace inward equals yes semicolon plus plus nw semicolon close curly brace close curly brace printf open parenthesis double quote percent d space percent d space percent d backslash n double quote comma nl comma nw comma nc close curly brace every time the program encounters the first character of a word it counts it the variable inward records whether the program is currently in a word or not initially it is not in a word which which is assigned the value no we prefer the symbolic constants yes and no to the literal values one and zero because they make the program more readable of course in a program as tiny as this it makes little difference but in larger programs the increase of clarity is well worth the modest effort to write it this way to make it more readable you will also find that it's easier to make changes to programs where numbers appear only as symbolic constants the line nl equals nw equals nc equals zero sets all three variables to zero this is not a special case but a consequence of the fact that an assignment has a value and assignments associate right to left it's really as if we had written nc equals open parenthesis nl equals open parenthesis nw equals zero close parentheses close parenthesis semicolon the operator double vertical bar vertical bar vertical bar means or so the line if open parenthesis c double equals single quote space single quote vertical bar vertical bar c double equals single quote backslash n single quote double vertical bar c double equals quote backslash t quote parenthesis says if c is a blank or c is a new line or c is a tab the escape sequence backslash t is a visible representation of the tab character there is a corresponding operator which is double ampersand for and expressions connected by double ampersand or double vertical bar are evaluated left to right and it is guaranteed that the evaluation will stop as true as true soon as the truth or falsehood for the overall expression is known thus if c contains a blank there is no need to test whether contends contains a new line or tab so these tests are not made this isn't particularly important here but is very significant in more complicated situations as we will soon see i would note that the double vertical bar and double ampersand are the norm for boolean operators in c like languages when a new language was being designed it was really easy to just adopt the c convention for logical operators because while they may seem cryptic millions of software developers were already familiar with the operators in this way the relationship between c and c like languages is like the relationship between latin and romance languages including english back to the text the example also shows the c else statement which specifies an alternative action to be done if the condition part of an if statement is false the general form is if open parenthesis expression close parenthesis statement one else statement two one and only one of the two statements associated with an if then else is done if the expression is true statement one is executed if not statement two is executed each statement can actually be in fact quite complicated in the word count problem the one after the else is an if that controls two statements in braces section 1.6 arrays understanding the capabilities and limitations of c arrays is one of the most important topics in our historical look at the c programming language most importantly the number of elements in an array declaration must be a constant at compile time and the size of an array cannot be adjusted using an array declaration while the program's running this inability to automatically resize c arrays as data is added leads to a class of security laws that are generally referred to as buffer overflow where a program reads more data in that can fit into an array and is tricked to overriding other data or code in compromising an application later in this book we will create dynamic arraylike structures in c using pointers and the standard library cialoc function python has support for a nondynamic arrays buffers python buffers are generally not used except for programmers writing library code that talks to lowlevel code written in a language other than python or talking to operating system things like linux the more commonly used python list and dictionary structures can change their sizes automatically as elements are added and deleted at runtime java has support for nondynamic arrays like c which are given a length at the moment they are created and the array length cannot be increased nor decreased without making a new array and copying all the elements from the first to the second array java does provide list and map structures that automatically adjust their length as data is added or removed java has a class called arraylist which can be dynamically extended but provides arraylike linear access it is a list internally but it can be used like an array externally the underlying technique that is used to implement language structures like python's list is dynamic memory allocation in a linked list structure linked lists are one of the most important data structures in all of computer science we will cover dynamic allocation and implementing data structures in c in chapter 6. for now we will merely examine the syntax of c arrays but keep in mind that allocating an array in c is very different than creating a list in python back to the text let us write a program to count the number of occurrences of each digit of white space characters blank tab and new line and all other characters this is an artificial problem to solve but it permits us to illustrate several aspects of c in one program there are 12 categories of input so it is convenient to use an array to hold the number of occurrences of each digit rather than 10 individual variables actually 12 individual variables here is one version of the program on page 21 in the textbook and i would note that as these programs get larger and larger it is harder and harder for you to just listen to me read them and you have to go look at them in the textbook so i recommend that you go check out the textbook in page 20 and find this actual code found include io dot h main open parenthesis closed parenthesis open curly brace int c comma i comma n white comma n other semicolon int n digit open square bracket 10 close square bracket semicolon and white equals n other equals 0 semicolon 4 open parenthesis i equals 0 semicolon i less than 10 semicolon plus plus i open let me close parenthesis end digit open square bracket i close square bracket equals zero semicolon now we're going to have a loop to read all of our input while double open parentheses c equals get char open parenthesis close parentheses and another closed parenthesis not equal eof close parenthesis if open parentheses c greater than or equal to single quote 0 single quote double ampersand c less than or equal single quote 9 single quote close parenthesis plus plus in digit open square bracket c minus single quote 0 single quote close square bracket semicolon else if open parenthesis c double equals space quote space quote or double vertical bar c double equals single quote backslash n single quote double vertical bar c double equals single quote backslash t single quote close parenthesis plus plus and white semicolon else plus plus in other that if statement was a sort of three branches if checking to see if we were doing a digit a white space character or some other character at the end of the while loop or not the end of the while loop and so we say printf parentheses double quote digits equals double quote close parenthesis semicolon now we'll note in this that there is no new line so we can have these print defs kind of concatenate outward without going to a separate line four parenthesis i equals zero semicolon i less than 10 semicolon plus plus i close parenthesis printf double quote space percent d double quote comma n digit open square bracket i close square bracket close parenthesis semicolon printf open parenthesis double quote backslash n white space equals percent d comma other equals percent d backslash n double quote comma and white comma n other closed parentheses semicolon close curly brace let's go through the code the declaration int in digit open square bracket 10 closed square bracket semicolon declares n digit to be an array of 10 integers array of subscripts always start and 0 in c rather than 1 as in fortran or pl1 so the elements are end digit sub zero and digit sub one dot dot dot end digit sub nine square brackets are the sub this is reflected in the for loops which initialize and print the array a subscript can be integer any integer expression which of course includes integer variables like i and integer constants this particular program relies heavily on the properties of character representation of the digits for example if c greater than or equal to single quote 0 single quote double ampersand c less than or equal to single quote 9 single quote close parenthesis determines whether it's a digit that is if the numeric value of the digit and the numeric value of the digit is c minus double quote 0 double quote this only works if double quote 0 double quote 1 etc are positive and increasing order and there's nothing but digits between 0 and 9. fortunately this is true for all conventional character sets by definition arithmetic involving chars and ends converts everything to int before proceeding so char variables and constants are identically essentially identical to instant arithmetic contexts this is quite natural and convenient for example c minus single quote 0 single quote is an integer expression that gives us a value between 0 and 9 an integer value between 0 and 9 corresponding to the character quote 0 quote to quote 9 quote stored in c and is thus a valid subscript for the ten element array and digit the decision as to whether the character is a digit a white space or something else is made by the sequence if open parenthesis c greater than or equal to quote zero quote double ampersand c less than or equal quote zero quote i quote nine quote close parentheses plus plus end digit open square bracket c minus quote zero quote close bracket semicolon else if c double equals single quote or c double equals single quote backslash n or c double equals single quote backslash t plus plus n white else plus plus and other the pattern if in parentheses condition statement else if parentheses conditions statement else statement occurs frequently in programs as a way to express a multiway decision the code is simply read from the top of the bot to until the bottom until some condition is satisfied at that point the corresponding statement part is executed and the entire construction is finished of course statement can be several statements in closed embraces if none of the conditions are satisfied the statement after the final else is executed if present if the final else and statement are omitted as in the word count program no action takes place there can be an arbitrary number of else if condition statements groups between the initial if and the final else as a matter of style it is advisable to format this construction as we have shown with proper indentation so that long decisions do not march off the right side of the page the switch statement to be discussed in chapter 3 provides another way to write multiway branching that is particularly suitable when the condition being tested is simply whether some integer or character expression matches one of a set of constants for contrast we will present a switch version of this program in chapter three functions in c a function is equivalent to a subroutine or function in fortran or a procedure in pl1 pascal etc a function provides a convenient way to encapsulate some computation in a black box which can then be used without worrying about its innards functions are really the only way to cope with the potential complexity of large programs with properly designed functions it is possible to ignore how a job gets done knowing what is done is sufficient c is designed to make the use of functions easy convenient and efficient you will often see a function only a few lines long called only once just because it clarifies some piece of code so far we have used functions like printf getchar and put char that have been provided for us now it's time to write a few of our own since c has no exponentiation operator like the double asterisk of fortran or pl1 let us illustrate the mechanics of function definition by writing a function power open parenthesis m comma n close parenthesis to raise an integer into a positive power n that is the value of power parentheses 2 comma 5 is 32. this function certainly doesn't do the whole job of exponentiation since it only handles positive powers of small integers but it is best to confuse only one issue at a time here is the function power and a main program to exercise it so you can see the whole structure at once this sample code is on page 23 of the textbook pound include stdio.h main open curly brace int i semicolon for for parenthesis i equals 0 semicolon i less than 10 semicolon plus plus i close parentheses printf double quote percent d space percent d space percent d backslash n double quote comma i comma power open parenthesis two comma i close parenthesis comma power open parenthesis negative three comma i close parenthesis close parenthesis semicolon close curly brace the end of the main now we begin the function power open parenthesis x comma n close parenthesis int x comma n semicolon open curly brace int i comma p p equals one four open parenthesis i equals 1 semicolon i less than or equal to n semicolon plus plus i p equals p times x semicolon return open parenthesis p close parenthesis semicolon close curly brace each function has the same form function name open parenthesis argument list if any followed by argument declarations if any followed by the body of the function which includes declarations and statements the functions can appear in either order and in one source file or two if of course the source file appears in two files you will have to say more to compile and load it when it fall appears in one but that's an operating system matter not a language attribute for the moment we'll just assume that both function functions are in the same file so whatever you learned about c programs running them will not change the function power is called twice in the line printf open parenthesis double quote percent d space percent d space percent d backslash n double quote comma i comma power open parenthesis two comma i close parenthesis comma power open parenthesis negative three comma i close parenthesis close parenthesis each call passes two arguments to the power function which each time returns an integer to be formatted and printed in the expression power open parenthesis two comma i is just an integer as two and i are not all functions produce an integer value and we'll take this up in more detail in chapter four in power the arguments have to be cleared appropriately so their types are known before the beginning of the body of the function this is done by the line int x comma n semicolon that follows the function name the argument declarations go between the argument list and the opening left brace each declaration is terminated by a semicolon the names used for power and for its arguments are purely local to power and not accessible to any other functions other routines can use the same names for their variables without conflict this is also true of the variables i and p within the function the i in power is unrelated to the i in main the value that power computes is returned to main by the return statement which is just as in pl1 any expression must occur within the parentheses a function need not return a value a return statement with no expression causes control but no useful value to be returned to the call caller as does falling off the end of a function by reaching the terminating right curly brace section 1.8 arguments call by value one aspect of c function which may be unfamiliar to programmers who are used to other languages particularly fortran and pl1 in c all function arguments are passed by value this means that the called function is given the values of its arguments in temporary variables actually on a stack rather than their addresses this leads to some different properties than are seen with call by reference languages like fortran and pl1 in which the called routine has handled the address of the argument not its value it may seem strange that the authors are calling so much attention to the fact that function arguments are passed call by value in the very first chapter most modern programming languages like python php or java pass single value arguments by value by default and to pass in an argument by reference you need to do something special like adding the ampersand in the function declaration in php passing by reference was the norm before c and passing by value was the norm after c since modern languages were deeply influenced by and often written in c passing by value is the norm for modern languages it's nice because it isolates the data in the calling code from the called code so the called code can't easily mess with its arguments either intentionally or by mistake and create an unexpected side effect and possibly a bug or security flaw in the calling code it was a bit of work to make pass by value work and see c implements a call stack where a bit of memory is automatically allocated at each function call and c makes a copy of the values in the calling code to pass them into the call code in a way that the calling code can see the values and change their local copies without affecting the values in the calling code the same call stack that made it possible for c function arguments to be passed by value also made it possible for a function to call itself recursively fortran functions could not be called recursively until the 1990 version of fortran if you know your python you know that simple variables like integers and strings are passed by value while structured data like dictionaries and lists are passed by reference i.e the called function can modify its arguments we will later see this in c as well talking about call stacks recursive functions and the fact that arrays and structures are called by reference is jumping ahead somewhat so for now let's just remember the author's point that normal valuable values like integers and floats are passed by value in c back to the text the main distinction is that in c the called function cannot alter a variable in the calling function it can only alter its private temporary copy call by value is an asset however not a liability it usually leads to more compact programs with fewer extraneous variables because arguments can be treated as conveniently initialized local variables in the called routine for example here is a version of power which makes use of this fact this code is on page 24 of the text power open parenthesis x comma n close parenthesis and x comma n semicolon open curly brace int i comma p semicolon for open parenthesis p equals one semicolon n greater than zero semicolon minus minus n close parentheses p equals p times x semicolon return open parenthesis p close parenthesis semicolon close curly brace the argument n is used as a temporary variable and is counted down until it becomes zero there is no longer a need for the variable i as in the previous example whatever is done to end inside the power function has no effect on the argument that power was originally called with when necessary it is possible to arrange for a function to modify the variable in the calling routine the caller must provide the address of their variable to be set technically a pointer to the variable and the called function must declare the argument to be a pointer and reference the actual variable indirectly through it we will cover this in detail in chapter 5. when the name of an array is used as an argument the value passed to the function is actually the location or address of the beginning of the array there is no copying of the elements in the array by subscripting this value the function can access and alter any element of the array in the calling code this is the topic of the next section now i would recommend that you're careful looking at the code samples in the rest of this chapter recall that in c array sizes do not grow and shrink dynamically at all after they're allocated the authors statically allocate character arrays capable of handling up to 1 000 characters long their code works but it is somewhat brittle so look at the next two sections as examples of c syntax with many important concepts about character strings stored as arrays and calling patterns when passing arrays to functions as parameters that but not exactly the best practice when handling dynamically sized data back to the text probably the most common type of array in c is an array of characters to illustrate the use of character arrays and functions to manipulate them let's write a program that reads a set of lines and prints the longest the basic outline is simple enough while there's another line if it's longer than the previous longest save it and its length and at the very end print the longest line the outline makes it clear that the program divides naturally into pieces one piece gets a new line another checks it another saves it and then the rest controls the process since things divide so nicely it'd be it would be well to write them that way too accordingly let's write first a separate function called getline to fetch the next line of input this is a generalization of getchar to make the function useful in other contexts we'll try to make it as flexible as possible at the minimum getline has to return a signal but possible end of file a more generally useful design would be to return the length of the lan line or zero if the end of file is encountered zero is never a valid line length since every line has at least one character even a line containing only a new line has length one i would note that here in chapter one we have changed the book's original use of the function name getline to get underscore line in the code examples because it conflicts with stead the stdio.h that defines getline as a library function in this chapter the authors are providing examples around function naming and linking in later chapters code samples will simply use the builtin git line without an underscore to read an input when we find a line that is longer than the previous longest it must be saved somewhere this suggests a second function copy to copy the new line to a safe place finally we need a main program to control getline and copy here is the result the sample code for this is on page 26. and it's a bit long so you might want to show take a look at the sample code in a browser pound include stdio.h pound define max line 1000 main open for an enclosed paren open curly brace int len semicolon which is the current line length int max semicolon which is the maximum length we've seen so far char line open square bracket max line close square bracket semicolon a character array that's the current input line and then char save open square bracket max line close square bracket semicolon which is a character array that has the longest line where we're going to save it onto the code max equals zero while open parenthesis open parenthesis len equals get line open parenthesis line comma max line close parenthesis close parenthesis greater than zero if len is greater than max open curly brace max equals len to save it and then copy line comma save close curly brace if open parenthesis max greater than zero i.e there was a line print f open parenthesis double quote percent s double quote comma save close curly brace to end the main program now we're in the first function get line open parenthesis s comma limb close parenthesis char s open bracket close bracket semicolon since it's being passed in as an argument we don't need to know the length of it and the next argument is int lim semicolon so getline takes a character array of unknown length and a limit that tells us the length of the character array open curly brace int c comma i semicolon four open parenthesis i equals zero semicolon i less than lim minus one double ampersand parenthesis c equals get char open parentheses close parenthesis close parenthesis not equal e o f and double ampersand c not equal single quote backslash n back single quote semicolon plus plus i and in the body of the loop it's s open square bracket i closed square bracket equals c from now on i'll read that s sub i equals c at the end of the loop we say if open parenthesis c double equals single quote backslash n single quote close parenthesis open curly brace s sub i equals c plus plus i close curly brace s sub i equals quote backslash zero quote semicolon return open parenthesis i close parenthesis semicolon close curly brace and that's the end of the get line function and now we're on to the copy function copy open parenthesis s1 s2 close parenthesis the purpose of this function is copy s1 to s2 assume that s2 is big enough the declaration is char s1 open square bracket close square bracket comma s2 open square bracket close square bracket a note these arrays have a size we just don't know what they are and we hope that they're large enough the body of the copy function starts with open curly brace int i semicolon i equals zero while open parenthesis open parenthesis s two sub i equals s one sub i close parenthesis not equal single quote backslash zero single quote plus plus i close curly brace to end the copy function main and getline communicate both through a pair of arguments and a returned value in getline the arguments are declared by the lines char s open square bracket close square bracket semicolon int lim semicolon which specify that the first argument is an array of unknown length and the second is an integer the length of the array s is not specified in getline since it's determined in main getline uses return to send a value back to the caller just as the function power did some functions return a useful value others like copy are only used for their effect and return no value getline puts the character backslash 0 the null character whose integer value is zero at the end of the array it's creating to mark the end of the string of characters this convention is also used by the c compiler with a when a string constant like double quote hello backslash n double quote is written in a c program the compiler creates an array of characters containing the characters of the string and adds a backslash zero at the end to terminate it so that functions such as printf can detect the end so that would lead to an array that has h e l l o backslash n backslash zero so it's a five character array with a new line which is a sixth character and then backslash zero which is an actual character again we don't know the arrays don't know their length and so you use the backslash 0 as the indicator of the end of a string the percent s format specification in printf expects a string represented in exactly this form if you examine copy you will discover that it too relies on the fact that its input argument s1 is terminated by backslash zero and it copies this character backslash zero into the argument output argument s2 all of this implies that backslash 0 is not part of normal text it's merely a marker it is worth mentioning in passing that even a program as small as this one presents some sticky design problems for example what should maine do if it encounters a line which is bigger than its limit getline works properly and then it stops collecting when the array is full even if no new line has been seen by testing the length in the last character returned main can determine whether the line was too long then cope with it as it wishes in interest of brevity we have ignored this issue there is also no way for a user of getline function to know in advance how long an input line might be so getline checks for overflow on the other hand a user of the copy function already knows or should be able to find out how big the strings are so we have have chosen not to add error checking to it section section 1.10 scope external variables the variables in main line save etc are private or local to main because they are declared within main no other function can have direct access to them the same is true of the variables in the other functions for example the variable i in getline is unrelated to the i in copy each local variable in a routine comes into existence only when a function is called and disappears when the function is exited it is for this reason that such variables are usually known as automatic variables following terminology in other languages we'll use the term automatic henceforth to refer to these dynamic local variables chapter 4 discusses the static storage class in which local variables do retain their values between function invocations because automatic variables come and go with function in invocation they do not retain their values from one call to the next and must be explicitly set upon each entry if they are not set they will contain garbage as an alternative to automatic variables it is possible to define variables which are external to all functions that is global variables which can be accessed by name by any function that cares to this function is rather like fortran common or pl1 external because external variables are globally accessible they can be used instead of arguments to communicate data between functions furthermore because external variables remain in existence permanently rather than appearing and disappearing as functions are called and exited they retain their values even after the functions that set them are done an external variable has to be defined outside of any function this allocates actual storage for it the function also must be declared and each function that wants to access it this may be done either by an explicit extern declaration or implicitly by context to make the discussion concrete let's rewrite the longest line program with line save and max as external variables this requires changing the calls declarations and bodies of all three functions this sample code is on page 29 of the textbook and it's pretty long but i'll read it for you pound include stdio.h pound define max line 1000. and we're still outside of main char line open bracket max line close bracket semicolon char save open bracket max line semicolon int max semicolon those are our three global variables starting the main main open friend close paren open curly brace intlen extern int max so we're saying that this is an integer but it's also not to be allocated inside of main extern char save open square bracket close square bracket the line length the length of the save array is defined above so we don't need to define it here max equals zero semicolon while double parenthesis land double left parenthesis len equals get line parenthesis greater than zero parenthesis if parenthesis len greater than max open curly brace max equals len copy open parenthesis no parenthesis semicolon no parameters to copy because it's going to simply talk to the global variables close curly brace after the loop finishes we say if open parenthesis max greater than zero then printf open parentheses double quote percent s double quote comma save close parenthesis semicolon close close curly brace and that is the end of the main so now we have the getline function which is specialized to deal with external variables okay so we start get line open parentheses close parenthesis no parameters open curly brace int comma c comma int c comma i semicolon these are local variables extern char line open curly brace closed curly brace semicolon this is the our reference inside of getline to the global variable line four open parenthesis i equals 0 semicolon i less than max line minus 1 max line minus 1 max line is a predefined constant at compile time for i less than max line 1 double ampersand parenthesis c equals get char open parenthesis close parenthesis close parenthesis not equal eof double ampersand i.e and c not equal single quote backslash n single quote semicolon plus plus i lines sub i equals c that's the for loop that in effect reads characters one at a time and puts them in line after the for loop we say if open parenthesis c double equals single quote backslash n single quote close parentheses open curly brace line sub i equals c plus plus i close curly brace this ensures that we append the new line to the function line sub i equals single quote backslash zero backslash that's semicolon the that's the string termination character return i return open parenthesis i close parentheses this is the length that getline is returning and then close curly brace to end the getline function and then we have the copy function and it's again it takes no parameters copy open parentheses close parenthesis curly brace and i extern char line open bracket close bracket comma save open bracket close bracket semicolon i equals 0 while parentheses open parenthesis open parenthesis save sub i equals line sub i close parenthesis is not equal quote backslash zero quote plus plus i close curly brace for copy so the external variables in main getline and copy are defined by the very first lines in the example above outside of main which state their type and cause storage to be allocated for them syntactically external definitions are just like the declarations we used previously but because they occur outside of any function including outside the main function the variables are external before a function can use or access an external variable the name of the variable must be made known to the function one way to do this is to write an extern declaration in the function the declaration is the same as before except for the added keyword extern in certain circumstances the extern declaration can be admitted omitted if the external definition of the variable occurs in the same source file before it's used in a particular function then there's no need for an extern declaration in the function the extern declarations in main and getline and copy are thus redundant in fact common practice is to place all definition of all external variables at the beginning of the source file and then omit all extern declarations if the program is in several source files and a variable is defined in say file 1 and used in file 2 then an extern declaration is needed in file 2 to connect the two occurrences of the variables this topic is discussed at length in chapter 4. you should note that we are using the words declaration and definition very carefully when we refer to external variables in this section definition refers to the place where the variable is actually created or assigned storage declaration refers to places where the nature of the variable is stated but no storage is allocated by the way there is a tendency to make everything inside an extern variable because it appears to simplify things argument lists are short and variables are always there when you want them but external variables are always there also when you don't want them the style of coding is fraught with peril since it leads to programs whose data connections are not at all obvious variables can be changed in unexpected and even inadvertent ways and the program is hard to modify when it becomes necessary the second version of the longest line program is inferior to the first partly because of these reasons and partly because it destroys the general at generality of two quite useful functions by hardwiring them into the names of the variables they will manipulate section 1.11 summary at this point we have covered what might be called the conventional core of c with this handful of building blocks it's possible to write useful programs of considerable size it probably a good idea if you paused long enough to do so the exercises that follow are intended to give you suggestions for programs of somewhat greater complexity than the ones presented in this chapter after you have this much sea under control it will be well worth your effort to read on for the features covered in the next few chapters are where the power and expressiveness of the language begin to become apparent this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by att but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardwarefirst vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 2 types operators and expressions variables and constants are the basic data objects manipulated in a program declarations list the variables to be used and state what type they have and perhaps what their initial values are operators specify what is to be done to them expressions combine variables and constants to produce new values these are the topics of this chapter section 2.1 variable names although we didn't come out and say so there are some restrictions on variable and symbolic constant names names are made up of letters and digits the first character must be a letter the underscore counts as a letter it is useful for improving the readability of long variable names upper and lower case are different traditional c practice is to use lowercase for variable names in all uppercase for symbolic constants only the first eight characters of an internal name are significant although more may be used for external names such as function names and external variables the number must be less than 8 because external names are used by various assemblers and loaders appendix a lists the details furthermore keywords like if else int float etc are reserved you can't use them as variable names and they must be in lower case i would note that in modern c languages the limitation of the first eight characters of a variable name being unique has been extended in most c variants at least 30 characters of a variable are treated as unique the it character limitation was to reflect the typical limitation of identifier length in assembly language programming and runtime linkers of the time naturally it's wise to choose variable names that mean something that are related to the purpose of the variable and are unlikely to get mixed up typographically section 2.2 data types and sizes there are only a few basic data types in c char which is a single byte capable of holding one character in the local character set and an integer typically reflecting the natural size of integers on the host machine float a single precision floating point and double is a double precision floating point in addition there are a number of qualifiers which can be applied to end short long and unsigned short and long refer to different sizes of integers unsigned numbers obey the arithmetic of modulo 2 to the n where n is the number of bits in an int unsigned numbers are always positive the declarations for qualifiers look like short int x semicolon long int y semicolon unsigned and z semicolon the word in can be omitted in such situations and typically is the precision of these objects depends on the machine at hand the table below shows some representative values on a dec pdp 11 a char is 8 bits on into 16 a short is 16 a char is 32 a float is 32 a double is 64. on a honeywell 6000 which uses ascii character set a char is 9 bits an int is 36 bits as short as 36 bits a char is 36 bits and a float is 36 bits and a double is 32 bits on the ibm 370 which is ebcdic in its character set a char is 8 bits and int is 32 bits as short is 16 bits a char is 32 bits a float is 32 bits and a double is 64 bits and so on the intent is that short and long should provide different lengths of integers where practical int will normally reflect the most natural size of a particular machine as you can see each compiler is free to interpret short and long as appropriate for their own hardware about all you should count on is that short is no longer than long in this table we see that in the mid1970s c was designed to support a range of computer generations the pdp11 was a common previous generation computer that had less memory so variable sizes were kept small the more modern computers in the chart had a bit more memory and could afford to have slightly larger larger sizes the idea of a natural size is the size that could be loaded computed and stored in usually of single machine language instruction you knew as a programmer that when used int the machine code you would generate would not need to include an extra instructions for a simple line of code like x equals x plus one semicolon modern int values in c are 32 bits long and long values are 64 bits long even though modern computers can do 64bit computations in a single instruction using the shorter int type when appropriate can save on memory storage and memory bandwidth using int values interestingly the length of a 32bit int leads to a unix and c problem with dates that is called the year 2038 problem a common way to represent time in unix c programs was as a 32bit integer of the number of seconds since january first 1970. it was quick and easy to compare or add or subtract these second counter dates in code and even in databases but the number of seconds since january 1st 1970 will overflow a 30bit number on the 19th of january in 2038. by now in order to avoid systems in order to avoid problems most systems have converted to storing these number of second values in long or 64bit values which gives us almost 300 billion years until we need to worry about overflowing second timer counters again back when c was developed we had two different character sets and two different character variable lengths the world generally standardized on the ascii character set for the core western characters and the unicode utf8 to represent all characters in all languages worldwide but that is a story for another time for now just think of the char type as also a byte type it is 8 bits in length and can store ascii modern languages like python or java have excellent support for wide character sets in our historical look at c we will not cover wide or multibyte characters also if you look at the float and double types you will see different bit sizes even worse each of these computers in the 1970s did floating point computation using slightly different hardware implementations and the same code run on different computers would give slightly different results and have unpredictable behavior on overflow underflow and other extraordinary floating point operations this was solved by the introduction of the ieee 754 standard in 1985 which standardized floating point format this standardized both the length of the float and the double but also ensured that the same set of floating point calculations would produce the exact same result on different processors 2.3 constants int and float constants have already been disposed of except to note that the usual 123.456 e minus 7 or 0.12 e3 scientific notation for floats is also legal every floating point constant is taken to be double so the e notation serves for both float and double long constants are written in the style 1 2 3 capital l an ordinary integer constant that is too long to fit into an int is also assumed to be a long there is a notation for octal and hexadecimal constants a leading zero on an int constant implies octal and a leading zero x or zero x upper case indicates hexadecimal for example the decimal 31 can be written as 037 in octal and 0x1 f or 0x1 f where f is capitalized in hex hexadecimal and octal constants may also be followed by the letter l to make them long a character constant is a single character written in single quotes as in quote x quote the value of the character constant is the numeric value of the character in the machine's character set for example the ascii character set 0 or quote 0 quote is 48 and an ebcdic quote 0 quote is 240. both quite different from the numeric value zero writing quote zero quote instead of a numeric value like 48 or 240 makes the program independent of the particular value character constants participate in numeric operations just like any other numbers although they are most often used in comparisons with other characters a later section treats conversion rules certain nongraphic characters can be represented in character constants by escape sequence like backslash n for newline backslash t for tab backslash zero for null backslash backslash for backslash itself and backslash quote for single quote etc these look like two characters but they're actually only one in addition an arbitrary byte space bit pattern can be generated by writing single quote backslash and then three digits single quote where the three digits is one to three octal digits as in pound define space form feed single quote backslash zero one four single quote which is ascii for a form feed we mentioned form feed here because in the 1970s we sent much of our output to printers physical printers a form feed was the character we would send to the printer to advance to the top of a new page the character constant quote backslash zero quote represents the character with the value zero quote backslash zero quote is often written instead of zero to emphasize the character nature of some expression a constant expression is an expression that only involves constants such expressions are evaluated at compile time rather than run time and accordingly may be used in any place a constant maybe as in pound define max line 1000 char line open bracket max line plus 1 close bracket semicolon or seconds equals 60 times 60 times hours a string constant is a sequence of zero or more characters surrounded by double quotes as in double quote i space am space a space string double quote or double quote double quote which is a way to show an empty string the quotes are not part of the string but only serve to delimit it the same escape sequences used for character constants apply in strings backslash double quote represents the double quote character technically a string is an array whose elements are single characters the compiler automatically places the null character backslash zero at the end of each such string so programs can conveniently find the end this representation means that there is no real limit on how long a string can be but programs have to scan one to completely determine its length the physical storage required is one more location than the number of characters written between the quotes the following function sterlin taking the parameter s returns the length of the character string s excluding the terminal backslash zero sterling open parentheses s close parenthesis char s open bracket close bracket semicolon open curly brace int space i semicolon i equals zero semicolon while parentheses s sub i exclamation equals quote backslash zero quote close parentheses plus plus i semicolon return parentheses i parentheses semicolon close curly brace be careful to distinguish between the character constant and a string that contains a single character single quote x single quote is not the same as double quote x double quote the former is a single character used to produce the numerical value of the letter x of the machine's character set the latter is a character string that contains one character the letter x and a backslash zero section 2.4 all variables must be declared before use although certain declarations can be made implicitly by context a declaration specifies a type and is followed by a list of one or more variables of that type as in int lower comma upper comma step semicolon char c comma line open bracket 1000 close bracket semicolon variables can be distributed among declaration in any fashion the list above could we could be equally well written as int lower semicolon in upper semicolon in step semicolon char c semicolon char line open bracket 1000 close bracket semicolon the latter form takes more room but it is convenient for adding a comment to each declaration or for subsequent modifications variables may also be initialized in their declaration although there are some restrictions if the name is followed by an equal sign in a constant that serves as an initializer as in char backslash equals single quote backslash backslash single quote semicolon int i equals 0 semicolon float eps equals 1.0 e minus 5 semicolon if the variable in question is external or static the initialization is done once only conceptually before the program starts executing explicitly initialized automatic variables are initialized each time the function they are in is called automatic variables for which there is no explicit initializer have undefined that is garbage values external and static variables are initialized to zero by default but it is a good style to state the initialization anyway we will discuss initialization further as new data types are introduced section 2.5 arithmetic operators the binary operators are plus minus asterisk and slash and the modulus operator percent there is a unary minus but no unary plus integer division truncates any fractional fractional part the expression x percent y produces the remainder when x is divided by y and is thus zero when y divides x exactly for example a year is a leap year if it is divisible by 4 but not by 100 except that years divisible by 4 are leap years therefore if parentheses year percent for equal equal zero and and year percent 100 not equal zero or year percent 400 equal equal zero it's a leap year else it's not the percent operator cannot be applied to float or double the plus and minus operators have the same precedence which is lower than the identical precedence of asterisk slash and percent which are in turn lower than unary minus arithmetic operators group from left to right a table at the end of this chapter summarizes precedence and associativity for all operators the order of evaluation is not specified for associative and commutative operators like asterisk and plus the compiler may rearrange a parenthesized computation involving these thus a plus open parenthesis b plus c closed parenthesis can be evaluated as open parenthesis a plus b close parentheses plus c this rarely makes any difference but if a particular order is required explicit temporary variables might be used the action on overflow or underflow depends on the machine at hand i would note that the above paragraph allows the compiler i would note that the above paragraph allowing the compiler to reorder computations even in the parentheses presence of parentheses is known as the knr c arrangement license as the authors state it almost never makes a difference unless an expression contains a value computed in a function call or is there a pointered lookup to find a value for the computation that might fail the rule was subtly adjusted in the iso version of c but iso c still does not strictly force the order of otherwise commutative operations even in the pr presence of parentheses the good news is that as long as you keep your expression simple you don't have to worry about this rule sometimes the real value of parentheses is to communicate your intentions to the human readers of your code if you are writing code that depends on the order of overflow function calls and pointer dereferences in a single mathematical expression perhaps you should break your expression into multiple statements section 2.6 relational and logical operators the relational operators are greater than greater than or equal less than less than or equal they all have the same precedence just below them in precedence are the equality operators double equals and exclamation equals which have the same precedence relationals have lower precedence than arithmetic operators so expressions like i less than limb minus 1 are taken as i less than open parenthesis limb minus 1 close parenthesis as would be expected more interesting are the logical connectives double ampersand and double vertical bar and an or expressions connected by double ampersand or double vertical bar are evaluated left to right and the evaluation stops as soon as the truth or falsehood of the result is known these properties are critical in writing programs that work for example here is a loop from the input function get line which we wrote in chapter one for parenthesis i equals zero semicolon i less than lim minus one double ampersand parenthesis c equals get char open parenthesis close parenthesis close parenthesis not equal single quote backslash n single quote double ampersand c exclamation equal e o f semicolon plus plus i close parenthesis s sub i equals c clearly before reading a new character it is necessary to check that there's room to store the array so the test i less than lim minus 1 must be made first not only but if this test fails we must not go on and read another character similarly it would be unfortunate if c were tested against eof before getchar was called the call must occur before the character c is checked against dof the precedence of double ampersand and is greater than that of double vertical bar or and both are lower than the relational inequality operators so expressions like i less than limb minus one double ampersand parenthesis c equals char open print close paren close paren not equal single quote backslash n single quote double ampersand c not equal eof needs no extra parenthesis but since the parentheses of not equals is higher than assignment parentheses do need to be added in open print c equals get char open print close paren close print not equal backslash n to achieve the desired result let's take a brief digression one of the great debates of the 1970s was how to use structured programming to avoid any use of goto statements that lead to completely unreadable spaghetti code structured code was easier to read debug and validate structured code advocated for if then else else if while do loops and do while loops where the loop exit test was at the top or the bottom of the loops respectively there was a move from flowcharts with lines boxes and arrows to to structure programming techniques like nashi schneiderman diagrams that you did used nested boxes to emphasize the structured nature of the code the proponents of each approach tended to approach the problem based on the language they used algol and pascal programmers were strong advocates of structured programming and those languages had syntax that encouraged the approach fortran programs had decades of flowchart use and style flowchart style thinking intended to avoid full adoption of structured programming kurdian and ritchie chose a middle path and made it so that c could support both approaches to avoid angering either side of the structure programming debate one area where the structured code movement kept hitting a snag was implementing a loop that reads a file and processes data until it reaches the end file the loop must be able to handle an empty file or no data at all there are three ways to construct a read and process until eof loop and none of the approaches are ideal the loop constructions that you can do are a top tested loop with prime a priming read before the loop a bottom tested loop with a read as the first statement in the loop and then if then else is the rest of the body of the loop a top tested infinite loop with a priming read and a middle test and exit and a top tested loop with a side effect read in the test of the loop which is the way that kernighan and ritchie chose to document in this chapter all of this serves to explain the syntax while open parenthesis open parenthesis c equals get char open paren close print close parenthesis not equal eof close parenthesis open curly brace body of the loop close curly brace this construct is a topped tested loop which most programmers prefer and it folds the priming read and puts its value inside the variable c but since the getchar might also return eof we need to check if we actually receive no data at all and need to avoid executing the body of the loop or exit the loop if eof were defined as zero instead of minus 1. the loop could have been written while open parenthesis c equals get char open paren close paren close parenthesis open curly brace body of the loop close curly brace now the get jar function returns a character or zero and the test itself is looking at the side effect or residual value of the assignment statement to decide to start and or continue the loop body the problem with using zero is end of file if you are reading a binary file like jpeg data a zero character might make perfect sense and we would not want to incorrectly end the loop because of a zero character in input data that does not end a file so we get the double parentheses syntax the side effect call to getchar and test the return value within the while test i'm quite confident that this is far more detail that you wanted here in chapter two but as it is as good a time as any to understand how much thought goes into a programming language how it is designed and documented by the time we finish chapter 3 and look at the break and continue statements which are in languages like python and java you will see that this 50 year old structured programming debate debate is still unresolved in the minds of many software developers back to the book the unary negation operator logical negation operator converts a nonzero or true operand into zero in a zero or false operand into one a common use of exclamation which we often call bang is in constructions like if open parenthesis exclamation point in word close parenthesis rather than if open parenthesis inward equal equals zero it is hard to generalize about which of these two forms is better construction like exclamation inward read quite nicely as if not in word but more complicated ones can be hard to understand section 2.7 type conversions when operands of different types appear in expressions they are converted to a common type according to a small number of rules in general the only conversions that happen automatically are those that make sense such as converting an integer to a floating point in an expression like f plus i expressions that don't make sense like using a float in a subscript are disallowed first chars and inst may be freely intermixed in arithmetic expressions every chart in an expression is automatically converted to an end this permits considerable flexibility in certain kinds of character transformations one is exemplified by the function a to i which converts a string of digits into its numeric equivalent a to y open parenthesis s close parenthesis char s open bracket close bracket semicolon open curly brace int i comma n semicolon n equals zero four parenthesis i equals zero semicolon s sub i greater than or equal to quote zero quote double ampersand s sub i less than or equal to double quote nine quote semicolon plus plus i close parentheses n equals 10 asterisk n plus s sub i minus single quote 0 single quote semicolon return open parenthesis and close parentheses semicolon close curly brace to end the function as we discussed in chapter 1 the expression s sub i minus quote 0 quote gives the numeric value of the character stored in sub i because the values 0 1 etc form a continuously increasing positive sequence positive sequence another example of the card chart in conversion is the function lower which match a single character to lower case for the ascii character set only if the character is not an upper case letter lower is returned unchanged here's a function lower open parentheses c closed parenthesis int c semicolon open curly brace if open parenthesis c greater than or equal to quote capital a quote double ampersand c less than or equal to quote z quote uppercase z parenthesis return open parenthesis c plus quote lowercase a quote minus quote uppercase a quote close parentheses semicolon else return c this works for ascii because the corresponding upper and lowercase letters are a fixed distance apart as numeric values and each alphabet is contiguous there is nothing but letters between a and z this latter observation is not true of the ebcdic character set on ibm 360 370 architectures so this code fails on such systems it converts more than letters there is one subtle point about the conversion of characters to integer the language does not specify whether character where the variables of type char are signed or unsigned quantities when char is converted to an int can it ever produce a negative number unfortunately this varies from machine to machine reflecting differences in architecture on some machines for instance a char whose left most bit is one will be converted to negative integer using sign extension on others a char is promoted to an in by adding zeros at the left end and is thus always positive the definition of c guarantees that any character in the machine standard character set will never appear to be negative so these characters may be used freely in expressions as positive quantities but arbitrary bit patterns stored in character variables may appear to be negative on some machines yet positive on others the most common occurrence of this situation is when the value negative 1 is used for eof consider the code char c semicolon c equals get char open print close paren semicolon if open print c double equals eof close paren dot dot dot on a machine which does not do sign extension c is always positive because it returns a char yet eof is negative as a result this test always fails to avoid this we have been careful to use int instead of char for any variable which holds a value returned by the function getchar the real reason for using int instead of char is not related to any questions of possible sign extensions it is simply that getchar must return all possible characters so that it can be root used to read arbitrary input and in addition a distinct eof value thus its value cannot be represented as a care char but must instead be stored as an int as an aside since the book was written before the getchar function was standardized the text is somewhat vague in this section shortly after the book was published getchar was put into the stdio.h library and declared to return an integer so as to accommodate all possible characters and the integer 1 value to indicate the end file the above code would be better written with c declared as an integer intc semicolon c equals get char open paren close paren semicolon if open print c double equal eof close paren dot dot while the conversion from char to int may or may not have sign extension and yes it still depends on the implementation 50 years later the conversion from into char is predictable with the top bits being simply discarded if you're using the library function get s to read a file line by line we don't need to worry about this conversion since git s returns a pointer to a character array i.e a string it indicates that reach has reached end of file by returning the null pointer i.e there is no more data to give back to the textbook another useful form of automatic type conversions is that relational expressions like i greater than j and logical expressions constructed by double ampersand and double vertical bar and and or respectively are defined to have the value 1 if true and 0 if false thus the assignment is digit equals c greater than or equal to quote 0 quote double ampersand c less than or equal to quote 9 quote sets the variable is digit to 1 if c is a digit and 0 if it's not in the if test of a in a test part of an if while or four true just means nonzero implicit arithmetic conversions would work much as expected in general if an operator likes c or asterisk for multiplication which takes two operators i.e a binary operator if it has operated operands of different types the lower type is promoted to the higher type before the operation proceeds and the result is the higher type more precisely for each arithmetic operator the following sequence of conversion rules is applied char and short are converted to int and float is converted to double then if either operand is double the other is converted to double and the result is double otherwise if either operand is long and the other is converted to long the result is long otherwise if either operand is operand is unsigned the other is converted to unsigned and the result is unsigned otherwise the operands must be int and the result isn't note that all float values in an expression are converted to double all floating point arithmetic in c is done in double precision conversions take place across assignments the value of the right side is converted to the type of the left which is the type of the result a character is converted to an integer either by sign extension or not as described above the reverse operation into char is well behaved excess high order bits are simply discarded thus in int i semicolon char c semicolon i equals c c equals i the value of c is unchanged and this is true whether or not sign extension is involved if x is float and i is int then x equals i and i equals x both cause conversions float to end causes truncation of any fractional part double is converted to float by rounding longer ins are converted to shorter ones by or to charge by dropping excess high order bits since a function argument is an expression type conversions also take place when arguments are passed to functions in particular char and short become int and float becomes double and that is why we have declared function arguments to be int and double even when the function is called with char and float finally explicit type conversions can be forced also we call it coerced in any expression with a construct called the cast in the construction open parenthesis type name close parentheses expression the expression is converted to the named type by the conversion rules above the precise meaning of cast is in fact as if the expression were assigned to a variable of the specified type which is then used in place of the whole construction for example the library square root sqrt expects a double argument and will produce nonsense if inadvertently handed something else so if n is an integer sqrt open parenthesis open parenthesis double close parenthesis n close parenthesis converts n to double before passing it to sqrt note that the cast produces the value of n in the proper type the actual content of n is not altered the cast operator has the same precedence as other unary operations as is summarized in the table at the end of this chapter section 2.8 increment and decrement operators c provides two unusual operators for incrementing and decrementing variables the increment operator plus plus adds one to its operand the decrement operator minus minus subtracts one we have frequently used plus plus increment variables as in if open parentheses c equals equals single quote backslash n single quote closed parenthesis plus plus nl semicolon the unusual aspect is that plus plus and minus minus may be used either as prefix operators ie before the variable as in plus plus n or postfix after the variable n plus plus in both cases the effect is to increment n but the expression the residual value of the expression plus plus n increments n before using its value while n plus plus increments and after its value has been used this means that in a context where the value is used not just the effect plus plus n and n plus plus are different if n is 5 then x equals n plus plus semicolon sets x to 5 the old value but x equals plus plus n semicolon sets x to 6 the new value in both cases n becomes 6. the increment and decrement operators can only be applied to variables an expression like x equals open parenthesis i plus j close parenthesis parenthesis plus plus is illegal in a context where no value is wanted just incrementing effect as in if open parentheses c double equals single quote backslash n single quote close parenthesis and l plus plus semicolon choose prefix or postfix according to taste but there are situations where one or the other is specifically called for for example consider the function squeeze s comma c which removes all occurrences of the character c from the string s squeeze open parenthesis s comma c close parenthesis char s open bracket close bracket semicolon int c semicolon open curly brace int i comma j semicolon for parenthesis i equals j equals zero semicolon s sub i not equal to single quote backslash zero single quote semicolon i plus plus close parentheses if open parenthesis s sub i not equal to c close parenthesis s sub j plus plus close parenthesis equals s sub i and outside the for loop totally s sub j equals backslash quote s sub j equals quote backslash zero quote semicolon close curly brace each time a nonc a character other than what's in the variable c occurs is copied into the current j position and only then is j incremented to be ready for the next character this is exactly equivalent to if open parenthesis s sub i not equal to c close parenthesis open curly brace s sub j equals s sub i semicolon j plus plus semicolon close curly brace another example of a similar construction comes from the getline function we wrote in chapter one where we can replace if open parenthesis c double equals quote backslash n quote close parenthesis open curly brace s sub i equals c semicolon plus plus i semicolon close parenthesis by the far more compact if parentheses c double equals quote backslash end quote close parentheses s sub i plus plus equals c semicolon in a third example the function stir cat concatenates the string t to the end of the string s stir cat does assume that there's enough space in s to hold the combination here's the code stir cat open parentheses s comma t close parenthesis char s open bracket close bracket comma t open bracket close bracket semicolon open curly brace int i comma j semicolon i equals j equals 0 semicolon while open paren s sub i not equal single quote backslash zero single quote close paren i plus plus in this we'd find the end of s while open parenthesis open parenthesis s sub i plus plus equals t sub j plus plus close parenthesis not equal backslash zero close parentheses semicolon that code copies the rest of t into s close curly brace as each character is copied from t to s the postfix plus plus is applied to both i and j to make sure they are in position for the next pass through the loop section 2.9 bitwise logical operators c provides a number of operators for bit manipulation these may not be applied to float or double ampersand is bitwise and vertical bar is bitwise inclusive or carrot is bitwise exclusive or less than less than is left shift and greater than greater than is right shift and tild is one complements and it's a unary operator the bitwise and operator ampersand is often used to mask off some set of bits for example c equals n ampersand 0 1 7 7 sets to 0 all but the lower 7 bits of n the bitwise or operator is used to turn bits on x equals x vertical bar mask sets to 1 the x bits that are set to one in mask you should carefully distinguish the bitwise operator ampersand and vertical bar from the logical connectives double ampersand and double vertical bar which imply left to right evaluation of a truth value for example if x is 1 and y is 2 then x single ampersand y is 0 while x double ampersand y is 1. think about that for a moment the shift operators less than less than and greater than greater than perform left and right shifts respectively of their left operand by the number of bit positions given by the right operand thus x less than less than 2 shifts x left by two positions filling the vacated bits with zero this is the equivalent to multiplication by four right shifting an unsigned quantity fills the vacated bits with zero right shifting a sine quantity will fill the sine bits arithmetic shift on some machines such as pdp 11 and with and with zero bits logical shift on other the unary operator tilled yields the ones complement of an integer that is it converts each one bit into a zero bit and vice versa this operator typically finds use in expressions like x ampersand tilled 077 which masks the last six bits of x to zero note that x ampersand tilde 0 7 7 is independent of word length and is thus preferable to for example x ampersand 0 1 7 7 7 0 0 which assumes that x is a 16 bit quantity the portable form involves no extra cause since killed zero seven seven is a constant expression and thus evaluated at compile time to illustrate the use of sum of the bit operators consider the function get bets open parenthesis x comma p comma n which returns the right adjusted n bit field of x that visit begins at position p we assume that position 0 is at the right end and that n and p are sensible positive values for example get bits open print x comma 4 comma 3 close print returns the three bits in bit positions 4 3 and 2 write adjusted here we go with the code get bits open print x comma p comma n unsigned x comma p comma n semicolon open curly brace return open parenthesis open parenthesis x greater than greater than open parenthesis p plus 1 minus n close parenthesis close parenthesis and ampersand tild open parenthesis till 0 less than less than in closed parenthesis close parenthesis semicolon close curly brace x greater than greater than parenthesis p plus one minus n close parenthesis moves the desired field to the right end of the word declaring the argument to be x declaring the argument x to be unsigned ensures that when it is right shifted vacated bits will be filled with zeros not sign bits regardless of the machine the program is run on tilde zero is all one bits shifting it left n bit positions with tilde 0 left shift tilde 0 less than less than n creates a mask with the zeros in the right most n bits and ones everywhere else complementing that with tilled makes a mask with ones in the right most bits bitwise operators may seem unnecessary for modern computers but if you look at the internal structure of tcpip packets the values are packed very tightly into the headers in order to save space c made it possible to write portable tcpi implementations on a wide range of hardware architectures bitwise operators also play an important role in encryption decryption and checksum calculations modern languages like java and python support bitwise operators following the same patterns that we established in c so that things like tcpip and encryption algorithms can also be implemented in these languages by defining these operators it kept software developers from needing to write nonportable assembly language to implement these lowlevel features in operating systems and libraries section 2.10 assignment operators and expressions expressions such as i equals i plus 2 in which the lefthand side is repeated on the right can be written in the compressed form i plus equals 2 using an assignment operator like plus equals most binary operators operators like plus that have a left and right operand have a corresponding assignment operator op equals where op is one of plus minus asterisk for multiplication slash for division percent for modulo less than less than left shift greater than greater than right shift ampersand bitwise and carrot exclusive or vertical bar bitwise or if e1 and e2 are expressions then e1 operand equals e2 is equivalent to e1 equals e1 operand e2 except that e1 is only computed once note the parentheses around e2 x star equals y plus 1 is actually x equals x times parenthesis y plus 1 close parenthesis rather than x times y plus 1. as an example function bit count counts the number of one bits in its integer argument here's the code bit count open parentheses in close parenthesis unsigned and semicolon open curly brace into b four open parenthesis b equals 0 semicolon and exclamation equals 0 semicolon n greater than greater than equal 1 close parenthesis if open parenthesis in ampersand 0 1 close parenthesis b plus plus semicolon return open print b close print semicolon curly brace quite apart from its conciseness assignment operators have the advantage and that they correspond better to way the way people think we said we say add 2 to i or increment i by 2 not take i add 2 and put the result back in i thus i plus equal to in addition for a complicated expression like yy val open bracket yypv open bracket p3 plus p4 close bracket plus yypv open bracket p1 plus 2 p2 close bracket close bracket plus equals 2 the assignment operator makes it code easier to understand since the reader doesn't have to check painstakingly that too long expressions are indeed the same or wonder why they're not an assignment operator may even help the compiler to produce more efficient code we have already used the fact that the assignments statement has a side effect value and can occur in expressions the most common example is while open parentheses open parenthesis c equals get char open parenthesis close parenthesis close parenthesis exclamation equal eof close parentheses and then the rest of the loop assignments using other assignment operators plus equal minus sql can also occur in expressions although it's a less frequent occurrence the type of an assignment expression is the type of its left operand section 2.11 conditional expressions the statements if parentheses a greater than b close parentheses c equals a semicolon else z equals b semicolon of course compute z in the maximum of a and b the conditional expression written with a ternary operator which is question mark and colon provides an alternate way to write this and similar constructions in the expression e1 question mark e2 colon e3 the expression e1 is evaluated first if it is nonzero true then the expression e2 is evaluated and that is the value of the conditional expression otherwise e3 is evaluated and that is the value only one of e 2 and e 3 are evaluated thus to set the z to set z to the maximum of a and b we say z equals parentheses a greater than b close parentheses question mark a colon b and this implements z equals max of a and b it should be noted that the conditional expression is indeed an expression and can be used just as any other expression if e1 and if e2 and e3 are different types their type of the result is determined by the conversion rules described earlier in this chapter for example if f is a float and n is an end then the expression parentheses n greater than zero closed parenthesis question mark f colon n is of type double regardless of whether n is positive or not parentheses are not necessary around the first expression of a conventional expression since the precedence of question mark colon is very low just above assignment they are advisable anyway however since they make the condition part of the expression easier to see the conditional expression often leads to succinct code for example this loop print prints n elements of an array 10 per line with each column separated by one blank and with each line including the last terminated by exactly one new line here's the code four parentheses i equals zero semicolon i less than n semicolon i plus plus close parentheses printf open parentheses double quote percent 6d percent c double quote comma a sub i comma open parenthesis i percent 10 double equal 9 or double vertical bar i double equal n minus 1 close parenthesis question mark single quote backslash n single quote colon single quote space single quote close parenthesis semicolon a new line is printed after every tenth element and after the nth and all elements are followed by one blank although this might look tricky it's instructive to try to write it without the conditional expression section 2.12 precedence in order of evaluation the table below summarizes the rules for precedence and associativity of all operators including those which we have not yet discussed operators on the same line have the same precedence rows are in order of decreasing precedence so for example asterisk slash and percent all have the same precedence which is higher than that of plus and minus parentheses square brackets the arrow operator and the dot operator are first with the right left to right associativity next precedence is exclamation tilled plus plus minus minus single minus the cast multiplication bitwise and size of with left with right to left associativity then multiplication division and modulo with left right associativity then plus and minus with left to right associativity then left shift which is less than less than and right shift which is right greater than greater than with left to right associativity then logical operators less than less than or equal to greater than or greater than or equal to with left to right associativity then comparison double equals not equal exclamation equal left to right then we have some bitwise operators the bitwise and with left to right associativity then the bitwise exclusive or with left right associativity which is a carrot then the single vertical bar which is bitwise or with left to right associativity then we have amber sand ampersand which is and the logical and left to right associativity then double vertical bar which is the logical or with left to right associativity then the ternary operator which is question mark and colon with right to left associativity then the assignments equals plus equals minus sets equals etc with right to left associativity and then the comma which we'll cover in the next chapter with left to right associativity the operators dash greater than and dot are used to access members of structures they'll be covered in chapter six along with size of in chat and then in chapter five we'll discuss asterisk indirection and ampersand address of note that the precedence of the bitwise logical operators ampersand carrot and vertical bar falls below double equals and exclamation equals that this implies that bis bit testing expressions like if parentheses parentheses x ampersand mass close parenthesis equal equals zero close parenthesis must be fully parenthesized to get proper results as mentioned before expressions involving one or more of the associative and commutative operators like multiply plus bit y z end bit lies orbit li and bitwise exclusive or can be rearranged even when parenthesized in most cases this makes no difference whatsoever in situations where it might explicit temporary variables can use to force a particular order of evaluation c like most languages does not specify in what order operands of an operator are evaluated for example in a statement like x equals f open parentheses close parentheses plus g open parentheses close parenthesis semicolon f may be evaluated before v g or vice versa thus if f or g alters an external variable that the other depends on x can depend on the order value of evaluation again intermediate results can be stored in temporary variables to ensure a particular sequence similarly the order which function arguments are evaluated is not specified so the statement printf open parentheses double quote percent d space percent d backslash n double quote comma plus plus n comma power open parenthesis two comma n close parentheses close parentheses is wrong it can and often does produce different results on different machines depending on whether or not n is incremented before power is called the solution of course is to write plus plus n semicolon printf open parentheses double quote percent d space percent d backslash n double quote comma n comma power open parenthesis two comma n close parentheses close parenthesis function calls nested assignment statements and increment and decrement operators cause side effects some variables change as a byproduct of the evaluation of an expression in any expression involving side effects there can be subtle dependencies on the order in which variables taking part in the expression are stored one unhappy situation is typified by the statement a sub i equals i plus plus the question is whether or not the subscript is the old value of i or the new value the compiler can do this in different ways and generate different answers depending on its interpretation when side effects i.e assignment to actual variables takes place is left to the discretion of the compiler since the best order strongly depends on machine architecture the moral of this discussion is writing code which depends on the order of evaluation is a bad programming practice in any language naturally it is necessary to know what things to avoid but if you don't know how they are done on various machines that innocence may help to protect you the c verifier lint will detect most dependencies on order of evaluation i would add that the real moral of the story is to use side effect operators very carefully they are generally only used in idiomatic situations and then use it written using simple code the authors are happy to tell you everything that you can do and see in great detail and they are also suggesting that just because you can do something does not mean that you should do something remember that a key aspect of writing programs is to communicate with future human readers of your code including you reading your own code in the future with modern day compilers and optimizers you gain little performance by writing dense or obtuse code write the code describe what you want done and let the compiler find the best way to do it one of the reasons that a common senior project in many computer science degrees was to write a compiler is to make sure that all computer scientists understand that they can trust the compiler to generate great code this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 3 control flow the control flow statements of a language specify the order in which the computations are done we have already met the most common control flow constructions of c in earlier examples here we will complete the set and be more precise about the ones discussed above 3.1 statements and blocks an expression such as x equals zero or i plus plus or printf open paren dot dot dot close paren becomes a statement when it is followed by a semicolon as in x equals zero semicolon i plus plus semicolon printf open parentheses something closed parentheses semicolon in c the semicolon is a statement terminator rather than a separator as it is in algol like languages the braces the curly braces open curly brace and closed curly brace are used to group declarations and statements together into a compound statement or block so that they are syntactically equivalent to a single statement the braces that actually surround the statements of a function are one obvious example braces around multiple statements after an if else while or four are another variables can actually be declared inside any block we will talk about this in chapter four there is never a semicolon after the right curly brace that ends the block ah see how do i love thee let me count the ways quote by dr chuck with homage to elizabeth barrett browning the humble semicolon is why spacing and line ends do not matter in c and c like languages it means that we as programmers can focus all of our white space and line ends on communicating our intent to humans this freedom is not an excuse to write obtuse code or dense code for example see the obfusicated pearl contest but instead freedom to describe what we mean or use spacing to help us understand or maintain our code we can take a quick look at how a few other c like languages that came after c treat the semicolon java is just like c in that the semicolon terminates statements python treats the semicolon as a separator like alcohol allowing more than one statement on a single line but since python treats the end of a line as a statement separator you generally never use semicolon in python but for people like me who automatically add a semicolon when typing code too fast at least python ignores the few semicolons i mistakenly add to my code out of habit javascript treats the semicolon as a separator but since javascript ignores the end of the line it's treated as white space semicolons are required when a block of code consists of more than one statement when i write javascript i meticulously include semicolons at the end of all statements because any good programmer can write c in any language back to the text 3.2 if else the ifl statement is used to make decisions formally the syntax is if parentheses expression parentheses statement 1 else statement 2 where the else part is optional the expression in parentheses is evaluated if it evaluates to true that is the expression has a nonzero value statement one is done if it is false the expression is zero and there's an else part statement two is executed instead since an if simply tests the numeric value of the expression certain coding shortcuts are possible the most obvious is writing if open parentheses expression instead of if open parenthesis expression not equal zero close parenthesis sometimes this is natural and clear other times it's cryptic because the else part of an if else is optional there is an ambiguity when an else is omitted from a nested if sequence this is resolved the usual way the else is a cl associated with the closest closest previous else list if for example if open parenthesis n greater than zero closed parenthesis if open parenthesis a greater than b close parentheses z equals a semicolon else z equals b the else with the z equals b goes with the inner if as we have shown by the indentation in the above example if that's not what you want braces must be used to force the proper association if n greater than zero open curly brace if a greater than b z equals a semicolon closed curly brace else z equals b this ambiguity is especially pernicious in situations like if open parenthesis n greater than zero for open parenthesis i equals 0 semicolon i less than n semicolon i plus plus closed parenthesis if open parenthesis s sub i greater than 0 close parentheses open curly brace printf string dot parenthesis semicolon return open parenthesis i close parenthesis semicolon close curly brace else and this is where it's wrong printf open parenthesis error and is zero closed parenthesis semicolon the indentation in the above example shows unequivocally what you want but the compiler does not get the message and associates the else with the inner if this bug can be very hard to find by the way notice that there is a semicolon after z equals a in if open parenthesis a greater than b close parenthesis z equals a semicolon else z equals b semicolon that is because grammatically a statement follows the if and an expression like z equals a is always terminated by a semicolon section 3.3 else if the construction if open parenthesis expression close parentheses statement else blank if open parentheses expression close parentheses statement else if open parenthesis expression close parentheses statement else statement occurs so often that it's worth a brief separate discussion the sequence of ifs is the most general way of writing a multiway decision the expressions are evaluated in order if any expression is true the statement associated with it is executed and this terminates the whole chain the code for each statement is either a single statement or a group of statements in phrases the last else handles the none of the above or default case where none of the other conditions was satisfied sometimes there is no explicit action for the default in that case the trailing else statement can be omitted or it may be used for error checking to catch an impossible condition to illustrate threeway decision here is a binary search function that decides if a particular value x occurs in the sorted array v the elements of v must be in increasing order the function returns the position a number between 0 and n minus 1 if x occurs in v n minus 1 if not this sample code is on page 54. it is the first example on page 54 in the book binary open parenthesis x comma v comma n close parenthesis int x comma v open square bracket close square bracket comma n semicolon open curly brace int low comma high comma mid semicolon low equals zero semicolon high equals n minus one semicolon while open parenthesis low less than or equal to high close parenthesis open curly brace mid equals open parenthesis low plus high close parenthesis slash 2 semicolon if open parenthesis x less than v submid close parenthesis high equals mid minus 1 semicolon else if open parenthesis x greater than v sub mid close parenthesis low equals mid plus one else return open parenthesis mid close parenthesis semicolon close curly brace closing the while and then return open parenthesis 1 close parentheses semicolon close curly brace to end the function the fundamental decision in this code is whether x is less than greater than or equal to the middle element v submit at each step this is a natural for elsa i would note that in the above examples the else and the if in c are two language constructs that are just being used idiomatically to construct a multiway branch or else if pattern with indentation that captures the idiom if we are pedantic about the indentation above the of the above sequence we would be separating the else and if and indenting each succeeding block further as follows with brackets or added for clarity if open parenthesis expression close parentheo parentheses open curly brace statement close curly brace else open curly brace if open parenthesis expression close parenthesis open curly brace statement close curly brace else open curly brace and now we're quite indented at this point if open parenthesis expression close parentheses open curly brace statement closed curly brace else open curly brace statement close curly brace close curly brace glows curly brace java and javascript keep the else and if as separate language elements and document their idiomatic usage and indentation just like c but in python life is a single keyword in a new language construct that achieves the same idiom as shown below if open parenthesis expression close parentheses colon block lf open parenthesis expression close parenthesis colon block alif if lf parentheses expression parentheses colon block else colon block the c java javascript and python idioms thankfully look the same when the idiomatic indentation is used even fortran 77 supports elf the else if construct to implement multiway logic section 3.4 switch the switch statement is a special multiway decision maker that tests whether an expression matches one of a number of constant values and branches accordingly in chapter one we wrote a program to count the occurrences of each digit white space and all other characters using a sequence of if else if else here's the same program with a switch this is the first example program on page 55. pound include less than stdio.h main open parentheses closed parenthesis open curly brace int c comma i come n white comma n other comma n digit open square bracket 10 close square bracket a 10 element array and white equals and other equals 0 for i equals 0 i less than 10 i plus plus and digit sub i equals 0. while parentheses parenthesis c equals get char open paren close paren close paren not equal e o f close paren switch open parentheses c close parenthesis open curly brace case quote zero quote colon case quote one quote colon case quote two qu quote colon case quote three quote colon case quote four quote colon case quote five quote colon case quote six quote colon case quote seven quote colon case quote eight quote colon case quote nine quote colon end digit sub c minus quote zero quote close bracket plus plus break now that that bit of code right there was to take all the of zero through nine and guide it to the line of code that incremented the particular element of the end digit array by one continuing after the break semicolon case quote space quote colon case quote backslash end quote colon case quote backslash t quote colon and white plus plus semicolon break default colon and other plus plus colon break semicolon close curly brace print f open parenthesis double quote digits equals double quote close parenthesis semicolon 4 open print i equals 0 i less than 10 i semicolon i plus plus close parenthesis printf open parenthesis percent space percent d close double quote comma end digit sub i close parenthesis semicolon printf quote backslash n white space equals percent d comma other equals percent d backslash n double quote comma and white comma n other closed parenthesis semicolon close curly brace the switch statement evaluates the integer expression in parentheses in this case the character c and compares its value simultaneously to all the cases each case must be labeled by an integer or character constant or constant expression if a case matches the expression value execution starts at that case the case labeled default is executed if none of the other cases is satisfied default is optional if there isn't if it isn't there and none of the cases matches no action at all takes place cases in default can occur in any order cases must all be different the break statement causes an immediate exit from the switch because the cases serve as labels after the code for one case is done execution falls through to the next unless you take explicit action to escape break and return are the most common ways to leave a switch a break statement can be used to force an immediate exit from a while four and do loops as well as will be discussed later in this chapter falling through the cases is a mixed blessing on the positive side it allows multiple cases for a single action as with blank tab or new line in this example but it also implies that normally each case what must end with a break to prevent falling through to the next falling through from one case to another is not robust being prone to disintegration when the program is modified with the exception of multiple labels for a single computation fall throughs should be used sparingly as a matter of good form put a break after the last case in this case default although it's logically unnecessary someday when another case gets added at the end this bit of defensive programming will save you uh the switch statement what is there to say i think that the switch statement was added to c c to compete with the earlier fortran computed go to statement or just to keep low level assembly language programmers from switching into assembly language to implement the concept of a branch table the authors spend most of the previous section apologizing for the switch statement so you should perhaps take this as a hint and never use it there are very few situations where a branch table outperforms a series of this if then else checks and those are likely deep in a library or operating system code programmers should only use switch if they understand what a branch table is and why a branch table is more efficient for the particular bit of a program they're writing otherwise just use elsif and do the readers of your code a favor 3.5 loops while and four we have already excounted the while and for loops in while open parenthesis expression close parentheses statement the expression is evaluated if it is nonzero the statement is executed and the expression is reevaluated this cycle continues until the expression becomes a zero at which point execution return resumes after the statement the for statement four open parenthesis expression one semicolon expression two semicolon expression three closed parentheses statement is equivalent to expression one semicolon while open parenthesis expression two closed parenthesis open curly brace statement expression three semicolon close curly brace grammatically the three components of the four are expressions most commonly expression one and expression three are assignments or function calls and expression two is a relational expression any of the three parts can be omitted although the semicolons must remain expression if expression one or expression three is left out it is simply dropped from the expansion if the test expression two is not present it is taken as permanently true so the code for open parenthesis semicolon semicolon closed parenthesis open curly brace dot dot close curly brace is an infinite loop presumably to be broken by some other means such as a break or a return whether to use while or for is largely a matter of taste for example in the code while open parentheses open parenthesis c equals get char open paren close paren close parenthesis equal equal quote space quote or c equal equal quote backslash end quote or c equal equal quote backslash t quote close parentheses semicolon skipping white characters there is no initialization or reinitialization so a while seems more natural the four is clearly superior when there is simple initialization and reinitialization since it keeps the loop control statements close together and visible at the top of the loop this is the most obvious in 4 open paren i equals 0 semicolon i less than n semicolon i plus plus close paren which is the c idiom for processing the first n elements of an array the analog of a fortran or pl1 do loop the analogy is not perfect however since the limits of a for loop can be altered within the loop and the controlling variable i retains its value when the loop terminates for any reason because the components of the four are arbitrary expressions for loops are not restricted to arithmetic progressions nonetheless is bad style to force unrelated computations into a four it is best reserved for loot control operations as a larger example here is another version of the a to i function for converting a string to its numeric equivalent this one is more general it copes with optional leading white space and an optional plus or minus sign chapter 4 shows a to f which does the same conversion for floating point numbers the basic structure of the program reflects the form of the input skip white space if any get the sign if any get the integer part and convert it each step does its part and leaves a clean slate for the next the whole process terminates on the first character that would not be part of a number this is the first example on page 58 of the textbook a to i open paren s close paren which is going to convert s to an integer char s open square bracket close square bracket semicolon open curly brace int i comma n comma sine semicolon 4 i equals 0 s sub i equal equal quote space quote or s sub i equals equals quote backslash end quote or s sub i equals equals backslash quote backslash t quote semicolon i plus plus semicolon skip white space this is a for loop with an empty loop body sine equals one semicolon if s sub i equal equal plus or s sub i equal equal quote minus quote close parenthesis sine equals and here we use a ternary operator open parentheses s sub i plus plus equal equal quote plus quote close parenthesis question mark 1 colon minus 1 semicolon for open parentheses n equals 0 semicolon s sub i greater than or equal to quote 0 quote and s sub i less than or equal to quote 9 quote i plus plus close parenthesis n equals 10 times n plus s sub i minus quote 0 quote semicolon return open parenthesis sine times n close parenthesis semicolon close curly brace to end the function the advantages of keeping loop control centralized are even more obvious when there are separate several nested loops the following function is a shell sort for sorting an array of integers the basic idea of the shell sort is that in early stages far apart elements are compared rather than adjacent ones as in simple interchange sorts this tends to eliminate large amounts of disorder quickly so later stages have less work to do the interval between the compared elements is gradually decreased to 1 at which point the sort becomes an effectively an adjacent interchange method this sample code is the second example in page 58 of the textbook shell open parentheses v comma and close parenthesis int v open square bracket close square bracket comma n semicolon open curly brace int gap comma i comma j comma temp four open paren gap equals n divided by two semicolon gap greater than zero semicolon gap slash equals to close parenthesis 4 open parenthesis i equals gap semicolon i less than n i plus close parenthesis 4 and now we're 3d nested in the for loops 4 open parenthesis j equals i minus gap semicolon j greater than or equal to 0 and v sub j greater than v sub j plus gap semicolon j minus equals gap close parenthesis open curly brace temp equals v sub j v sub j equals v sub j plus gap semicolon v sub j plus gap equals temp semicolon just a swap of v and v b sub j plus gap p sub j and v sub j plus cap close curly brace and that close the inner innermost for loop and and then the next closed curly brace closes the function there are three nested loops the outermost loop controls the gap between the compared elements shrinking it from n over two by a factor of two each pass until it becomes zero the middle loop compares each pair of elements that is separated by cap the innermost loop reverses any elements that are out of order since gap is eventually reduced to one all elements are eventually ordered correctly note that the generality of the 4 makes the outer loop fit the same form as the others even though it is not an arithmetic progression one final c operator is the comma which most often finds use in the for statement a pair of expressions separated by a comma is evaluated left to right and the type and value of the result are the type and value of the right operand thus in a for statement it is possible to place multiple expressions in the various parts for example to process two parallel indices this is illustrated in the function reverse which reverses the function string in place this code is from page 59 of the textbook and it is the first example on page 59. pound include less than string.h greater than reverse open paren s close paren char s open square bracket close square bracket semicolon open curly brace int c comma i comma j for open parenthesis i equals zero comma j equals stirling sub s minus one semicolon i less than j semicolon i plus plus comma j minus minus close parenthesis open curly brace c equals s sub i s sub i equals s sub j semicolon s sub j equals c semicolon close curly brace close curly brace to end the function the commas that separate the function arguments variables declarations etc are not comma operators and do not guarantee left to right evaluation section 3.6 loops do while the while and for loops share the desirable attribute of testing the termination condition at the top rather than at the bottom as we discussed in chapter one the third loop in c the do while tests at the bottom after making each pass through the loop body the body is always executed at least once the syntax is as follows do statement while open parenthesis expression close parenthesis semicolon the statement is executed then the expression is evaluated if it is true statement is evaluated again and so on if the expression becomes false the loop terminates as might be expected do while is much less used than while in four accounting perhaps five percent of all loops nonetheless it is from time to time valuable as the following as in the following function i to a which converts a number to a character string the inverse of a to i the job is slightly more complicated than it might be thought at first because the easy methods of generating the digits generate them in the wrong order we've chosen to generate the string backwards and then reverse it this is the first sample code on page 61 page 60 of the textbook i to a open parenthesis n comma s close parenthesis char s open square bracket close square bracket semicolon int n semicolon open curly brace int i comma sine semicolon if open parenthesis open parenthesis sine equals n close parenthesis less than zero close parenthesis n equals minus n semicolon that's a bit of a complex if i would say there it has an assignment statement that both copies n into sine and then evaluates as to whether or not it's less than zero the n or sign is less than zero because it's a side effect assignment statement for the residual value but the net result is sign contains n and then it's negated um then n is made positive so continuing i equals 0 semicolon do open curly brace s sub i plus plus equals n modulo 10 plus quote 0 quote semicolon close curly brace while parenthesis parenthesis n slash equals 10 close parenthesis greater than zero close parenthesis semicolon if open parenthesis sine less than zero close parenthesis s sub i plus plus equals quote dash quote or minus sign semicolon s sub i equals quote 0 quote semicolon in a sense to terminate the string and then we call the function reverse reverse open parenthesis s close parenthesis semicolon close curly brace the do while is necessary or at least convenient since at least one character must be installed in the array s regardless of the value of n we have also used braces around the single statement that makes up the body of the do while even though they are unnecessary so the hasty reader will not mistaken mistake the while part for the beginning of a while loop i would note that it's important for any language to provide top tested loops and bottom tested loops but don't feel bad if you write code for years and never feel like a bottom tested loop is the right way to solve a problem you're facing it is usually rare to write a loop that you insist will run once regardless of its input data section 3.7 break it is sometimes convenient to be able to control loop exits other than by testing at the top or the bottom the break statement provides an early exit from a for while or do just as it does from the switch statement a break statement causes the innermost enclosing loop or switch to be executed immediately the following program removes trailing blanks and tabs from the end of each line of input using a break to exit from a loop when the rightmost character is nonblank nontab is found this example code is on page 61 of the textbook and it is the first example on that page pound include less than stdio.h pound define max line 1000 main open parenthesis close parenthesis open curly brace int n semicolon char line open bracket max line close bracket semicolon while open paren open paren n equals get line open paren line comma max line close paren close brand greater than zero close brand open curly brace while open cur open parenthesis minus minus n greater than or equal to zero close parenthesis if open parenthesis line sub n not equals a quote space quote and line sub n not equal quote backslash t quote and line sub n not equal quote backslash end quote close parenthesis break line sub n plus one equals quote backslash zero quote semicolon printf double quote percent s backslash n double quote comma line close parenthesis semicolon close curly brace to end the while and then close curly brace to end the main getline returns the length of the line the inner while loop starts at the last character of line recall that minus minus n decrements end before using the value and scans backwards looking for the first character that is not a blank tab or new line the loop is broken when one is found or when n becomes negative that is when the entire line has been scanned you should verify that this is the correct behavior even when the line contains only white space characters an alternative to break is to put the testing in the loop itself while open parenthesis open parenthesis n equals get line open parenthesis line comma max line close parenthesis close parenthesis greater than zero close parenthesis open curly brace while open paren minus minus n greater than equal to zero and open for n line sub n equal equal quote space quote or line sub n equals quote backslash t quote or line sub n equals quote backslash n quote close paren close paren semicolon dot dot close curly brace this is inferior to the previous version because the test is harder to understand tests which require a mixture of and or not and parentheses should generally be avoided 3.8 continue the continue statement is related to break but less often used it causes the next iteration of the enclosing loop for a while or do to begin in the while and do this means that the test part is executed immediately in the four control passes to the reinitialization step control by the way continue applies only to loops not to switch a continue inside a switch statement inside of a loop causes the next loop iteration as an example this fragment processes only positive elements in the array a negative values are skipped 4 open paren i equals 0 semicolon i less than n semicolon i plus plus close paren open curly brace if open paren a sub i less than 0 close paren continue this line skips the negative elements and then the rest of the body of the loop taut is will run only for the positive elements of the loop and the loop finishes with a close curly brace the continue statement is often used when part of the loop that follows is complicated so that reversing a test and indenting another level would nest the program too deeply it's time for a bit of an aside now that we have seen the break and continue language structures in c that also have made it into c like languages and learned about middle tested loops it is time to revisit the structured programming debate and the need for priming operations when a program must process all data until it finishes and still handle the there is no data at all situation in the previous chapter the author somewhat skirted the issue by using a top tested while loop and a side effect statement with residual value that was compared to eof to decide when to exit the loop int c colon while open parenthesis open parenthesis c equals get char open paren close paren close parenthesis not equal eof close parenthesis open curly brace process your data close curly brace and just for fun now that we do know about the for loop let's rewrite this loop as a for loop to make sure we really understand how for loops work in c semicolon for friend c equals get char open print close print semicolon c not equal eof semicolon c equals get char open print close paren close paren curly brace process your data close curly brace for the for loop now you will almost never see a read all characters until eof written this way because because it is not the way knr told us knr told us to reuse a while loop for this but the for loop formulation is probably clearer to many than the while formulation especially to a reader who's not familiar with the assignment side effect idiom commonly used in c in particular the four formulation does not require that the assignment statement has a residual value of the value that was assigned the first part of the four is a priming read the second part of the four is a top text tested exit criteria that works both for no data and after all data has been read and processed and the third part of the four is done at the bottom of the loop to advance to the next character or encounter eof before going back to the top and doing the loop test the call to get char is done twice in the for formulation of the read all available data loop and while we don't like to repeat ourselves in code it is a if it is a small and obvious bit of code perhaps this code is more clear with a bit of repetition so with all this is background you can take this page of the document and sit down with a friend at a coffee shop and debate as long as you like about which is the better formulation for the read all available data but if at that coffee shop you asked dr chuck's opinion neither of these is ideal because in the real world we build data oriented loops that usually do a lot more than get one character from standard input my formulation of a data loop will upset the structured programming purists and probably upset kernighan enrichy as well but i write code in the real world so here is my version int c semicolon while open paren one close print open curly brace c equals get char if open friends c double equals eof close paren break process your data and then close curly brace to end the loop and if i wanted to skip blanks and new lines i could use both break and continue further angered angering the structured programming purists int c semicolon while open parenthesis one closed parenthesis open curly brace c equals get char open parenthesis close parenthesis semicolon if open parenthesis c equal equal eof close parenthesis break if open parenthesis c equal equal quote space quote or c equal equal quote backslash end quote close parenthesis continue then process your data close parenthesis i use this middle tested approach because usually the data i am processing is coming from a more complex source than the keyboard and i don't want a function with two to three parameters stuck inside of a sine side effect statement in a while test and also sometimes you want to exit loop not just based on the return value from the function but instead based on the complex structure that came back from the function itself as these data processing loops get more complex the middle tested loop is a tried and true pattern even kernighan and ritchie point out its benefits above and with that i have now triggered endless coffee shop conversations about the best way to write a data handling loop section 3.9 go to's and labels c provides the infinitely abusable goto statement and labels to branch to formally the goto is never necessary and in practice it is almost always easy to write code without it we have not used go to in this book nevertheless we will suggest a few situations where goto's might find a place the most common use is to abandon processing in some deeply nested structure such as breaking out of two loops at once the break statement cannot be used directly since it leaves the only the most inter innermost loop thus four open parentheses.close parenthesis four open parenthesis.close parenthesis open curly brace do some stuff if open parenthesis disaster close parenthesis go to error semicolon close curly brace dot dot dot dot dot and then error colon and then clean up the mess this organization is handy if the error handling code is nontrivial and if errors can occur in several places a label has the same form as a variable name and is followed by a colon it can be attached to any statement in the same function as the go to another example consider the possibility of finding the first negative element in a twodimensional array multidimensional arrays are discussed in chapter five one possibility is four open parenthesis i equals zero semicolon i less than n semicolon i plus plus close parentheses four open parenthesis j equals zero semicolon j less than m semicolon j plus plus close parenthesis if open parenthesis v sub i sub j less than zero close parenthesis go to found other one and then you handle and you keep going and then found colon include is where it comes to uh jumps to code involving a go to can always be written without want but though perhaps at the price of somewhat repeated tests or an extra variable for example the array search becomes found equals zero four open parenthesis i equals zero semicolon i less than n ampersand ampersand exclamation found semicolon i plus plus four open parenthesis j equals zero semicolon j less than m ampersand ampersand exclamation found semicolon j plus plus found equals v sub i sub j less than zero if found continue else not found although we are not dogmatic about the matter it does seem that go to go to statements should not should be used sparingly at if at all i would add before we leave control flow i need to say that i agree with structured programming experts as well as kernighan and ritchie in that the goto is universally a bad idea there are a lot of little details that make them a real problem things like how the stack works in function calls and how code blocks happen and patching the stack up correctly when a go to happens in the middle of a deeply nested mess you might be tempted to use a go to when you want to exit multiple nested loops in a single statement break and continue only exit the innermost loop the authors use this example above but are quite lukewarm when describing it as the use of go to usually if your problem is that complex putting things in a function and using return or adding a few if statements is a better choice the dr chuck middle tested loop data processing solves this because the loop is always the innermost loop also as new languages were built the concept of exceptions became part of language design and was by a by far more elegant solution to a path of some deeply nested code that just needs to get out so most of the time you think the goto might be a good idea you should lean towards a throw catch pattern to make your intention clear it is one of the reasons why we prefer languages like java or python over c when writing general purpose code this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 4 functions in program structure functions break large computing tasks into smaller ones and enable people to build on what others have done instead of starting over from scratch appropriate functions can often hide details of operation from parts of the program that don't need to know about them thus clarifying the whole and easing the pain of making changes c has been designed to make functions efficient and easy to use c programs generally consist of numerous small functions rather than a few big ones a program may reside on one or more source files in any convenient way the source files may be compiled separately and loaded together along with previously compiled functions from libraries we will not go into that process here since the details vary according to the local system most programmers are familiar with library functions for input and output like get char input chart and numerical computations like sine cosine and square root in this chapter we will show more about writing new functions 4.1 basics to begin let us design and write a program to print each line of input that contains a particular pattern or string of characters this is a special function of the unix utility program grap for example searching for the pattern the in the set of lines now is the time for all good men to come to the aid of their party we'll produce the output now is the time men to come to the aid of their party the basic structure of the task falls neatly into three pieces while there's another line if that line contains a pattern print it although it's certainly possible to put the code for all of this in one main routine a better way is to use the natural structure to advantage by making each part a separate function three small pieces are easier to deal with than the one big one because irrelevant details can be buried in the functions and the chance of unwanted interactions minimized and the pieces might even be useful later in their own right while there is another line is getline a function we wrote in chapter one and printed is printf which someone has already provided for us this means that we need to only write a routine which decides if the line contains an occurrence of the pattern we can solve that problem by stealing a design from pl1 the function index s comma t returns the position or index in the string s where the string t begins or 1 if s doesn't contain t we use 0 rather than 1 as the starting position in s because c arrays always begin at position 0. when we later need more sophisticated pattern matching we only have to replace index the rest of the code can remain the same recall that because the modern stdio.h defines a getline function whenever the book writes this function to teach a feature of functions we rename it to get underscore line given this much design filling in the details of the program is straightforward here's the whole thing so you can see how the pieces fit together for now the pattern to be searched for is a literal string in the argument of index which is not the most general of mechanisms we will return shortly to a discussion of how to initialize character arrays and in chapter 5 we will show how to make the pattern a parameter that is set when the program is run this is also a new version of getline you might find it instructive to compare it to the one in chapter one pound include stdio.h pound define max line 1000 main open parenthesis closed parenthesis open curly brace char line open square bracket max line close square bracket semicolon while parentheses get line open parenthesis line comma max line close parenthesis greater than zero close parenthesis if open parenthesis index open parenthesis line comma double quote the double quote close parenthesis greater than or equal to zero close parenthesis printf open parenthesis double quote percent s double quote comma line close parenthesis semicolon and a close curly brace to finish the main function next function is get line get line open parenthesis s comma limb close parenthesis char s open square bracket close square bracket semicolon available c equals get char open frame close paren close paren not equal e o f double ampersand c not equal double quote backslash n double quote semicolon plus plus i close parentheses s sub i equals c that loop basically read until it found a new line or end of file if open parenthesis c double equals quote backslash end quote close parenthesis open curly brace s sub i equals c plus plus i semicolon close curly brace closing the f s sub i equals quote backslash zero quote semicolon to terminate the string properly return open paren i close paren semicolon to return the length of the line and then close curly brace to finish the getline function and now the new code index open parenthesis s comma t close parenthesis char s open square bracket close square bracket comma t open square bracket close square bracket semicolon i would note that when we are declaring a character array and we don't give the length of the array that means that we're inside of a function the length of the array exists but it was from the callings calling code so char s open square bracket close square bracket t open square bracket close square bracket semicolon means parameters s and t are strings of some length and we will use backslash 0 to know when that length is done beginning the code in index with an open curly brace int i comma j comma k semicolon and then we have two nested for loops four open print i equals zero s sub i not equal to quote backslash zero quote semicolon i plus plus open curly brace four j equals i comma k equals zero semicolon t s t sub k not equal to backslash zero and double ampersand s sub j double equals t sub k semicolon j plus plus k plus plus semicolon if open print t sub k double equals quote backslash zero quote close paren return open paren i close paren semicolon close curly brace return open paren minus one close paren semicolon curly brace each function has the form name argument list if any in parentheses argument declarations if any open curly brace declarations and statements if any close curly price as suggested various parts may be absent a minimal function is dummy open paren close paren open curly brace closed curly brace which does nothing a do nothing function is sometimes useful as a placeholder during program development the function name may also be preceded by a type if the vert function returns something other than an integer value this is the topic of the next section a program is just a set of individual function definitions communication between the functions is in this case by arguments and values returned by the functions it can also be via external variables the functions can occur in any order in the source file and the source program can be split into multiple files so long as no function is split the return statement is the mechanism for returning a residual value from the called function to its caller any expression can follow return return open parentheses expression close parentheses the calling function is free to ignore the return value if it wishes furthermore there need there is no need to have an expression after the return in that case no value is returned to the caller control also returns to the caller with no value when execution falls off the end of the function by reaching the right closing brace it is not illegal but probably a sign of trouble if a function returns a value from one place and no value from another place in any case the residual value of a function which does not return one is certain to be garbage the c verifier lint checks for such errors the mechanics of how to compile and load a c program which resides on multiple source files vary from one system to the next on the unix system for example the cc command mentioned in chapter one does the job suppose that three functions are in three files called main.c getline.c and index.c then the command cc main.c getline.c index.c compiles the three files and places the resulting relocatable object code in files main.o getline.o and index.o and loads them all into an executable file named a dot out if there is an error say in main.c that file can be recompiled by itself and the result loaded with the previous object files with the command cc main.c getline.o index.o the cc command uses the dot c suffix versus the dot o suffix naming convention to distinguish source files from object files i would note that this cc example exactly as the authors wrote it does not quite work as described in modern c compilers if you want to compile your source code and leave the compiled object code around after the compile you add the minus c option to the compiler column modern c compilers generally do accept multiple files with either dot c or dot o suffixes and conv combine them into a runnable application section 4.2 functions returning nonintegers so far none of our programs has contained any declaration of the type of a function this is because by default a function is implicitly declared by its appearance in an expression or statement such as while open paren get line open paren line comma max line close paren greater than zero close print if a name which has not been previously declared occurs in an expression and is followed by a left parenthesis it is declared by context to be a function name furthermore by default the function is assumed to return an int since char promotes to int in expressions there is no need to declare functions that return char these assumptions cover the majority of classes including all of our examples so far i would add that's not true quite true anymore in modern c languages you are required to provide a type for each function if you leave off the type for a function declaration at a minimum you will give us get a stern warning message but sometimes functions do not intend to return anything at all and so the void type was invented to indicate that a function returns nothing the rule of requiring a type on a modern function definition in c even if it's void allows the compiler to check to make sure all of your return values in a function match the expected return type back to the text but what happens if a function must return some other type many numerical functions like square roots sine and cosine return double other specialized functions return other types to illustrate how to deal with this let us write and use the function a to f which converts its argument string s to its double precision floating point equivalent a2f is an extension of a to i which we wrote versions of in chapters two and three it handles an optional sign and decimal point and the presence or absence of either the integer or fractional part we note that this is not a high quality input conversion routine it takes doing everything takes a bit more space than we care to use here in this book first a to f must declare the type of the value it returns since it's not int because float is converted to double in expressions there is no point in saying that a to f returns float we might as well make use of the extra precision and thus declare it to return double the type name precedes the function name like this double a to f open parenthesis s close parenthesis char s open square bracket close square bracket open curly brace double val comma power int i comma sine semicolon for i equals zero semicolon s sub i double equals quote space quote or s sub i double equals quote backslash end quote or s sub i eq double equals quote backslash t quote semicolon i plus plus semicolon that skips the white space sine equals one if s sub i double equals quote plus quote or s sub i double equals quote minus quote sine equals and now we're going to use a ternary operator here paren s sub i plus plus close bracket double equals quote plus quote close paren question mark 1 colon minus one semicolon and that basically tells us it it makes sine be one or negative one based on the presence or absence of a plus or minus for val equals zero semicolon s sub i greater than or equal to quote zero quote double ampersand s sub i less than or equal to double quote nine quote i plus plus close paren val equals 10 times val plus s sub i minus quote zero quote semicolon what this is doing is multiplying the current value by 10 in effect shifting it left and then adding in that new lower empty spot the digit that we're encountering which is somewhere between the character 0 and the character 9. continuing if parentheses s sub i double equals quote dot quote close parentheses i plus plus four open parenthesis power equals one semicolon s sub i greater than or equal to quote zero quote double ampersand s sub i less than or equal to quote nine quote semicolon i plus plus open curly brace val equals 10 times val plus s sub i minus quote zero quote again shifting the number to the left as its as we encounter characters power star equals 10 semicolon close curly brace return open parenthesis sine times val over power close parenthesis semicolon close curly brace second and just as important the calling routine must state that a to f returns a nonend value the declaration is shown in the following primitive desk calculator barely adequate for checkbook balancing which reads one number per line optionally preceded by sign and adds them all up printing the sum after each input this example is from page 70 of the textbook pound include stdio.h pound define max line 100 main open parenthesis close parenthesis open curly brace double sum comma a to f open parenthesis close parenthesis semicolon char line open square bracket max line close square bracket semicolon sum equals zero while open parenthesis get line open parenthesis line comma max line close parenthesis greater than zero close parenthesis printf quote backslash t percent.2f backslash n comma sum plus equals a to f open parenthesis line close parenthesis close parenthesis semicolon close curly brace that code used the plus a plus equals side effect operator and merge the call to a to f right into the parameter of the second parameter of printf the declaration double sum a to f open parentheses close parentheses says that sum is a double variable and that a to f is a function that returns a double value as a mnemonic it suggests that sum and a to f parenthesis dot dot are both double precision floating point values unless a to f is explicitly declared in both places c assumes it returns an integer and you will get nonsense answers if a to f itself and the call to it in main aren't typed inconsistently with this with in the same source file it will be detected by the compiler but if as is more likely a to f were compiled separately the mismatch would not be detected and a to f would return a double which maine would treat as an end and meaningless answers would result lind catches this error given a to f we could in principle write a to i to convert a string to an integer in terms of it int a to i open parentheses s close parentheses char s open square bracket close square bracket semicolon open curly brace double a to f open parenthesis close parenthesis semicolon return open parenthesis a to f close parentheses s close parentheses close parentheses semicolon close curly brace note the structure of the declarations in the return statement the value in the expression in return expression is always converted to the type of the function before the return is taken therefore the value of a to f a double is converted automatically to int when it appears in a return since the function a to i returns an end the conversion of a floating point value to in truncates any fractional part as we discussed in chapter two more on function arguments in chapter one we discuss the fact that function arguments are passed by value that is the called function receives a private temporary copy of each argument not its address this means that the function cannot affect the original argument in the calling function within a function each argument is in effect a local variable initialized to the value with which the function was called when an array name appears as an argument to a function the location of the beginning of the array is passed elements are not copied the function can alter elements of the array by subscripting from this location the effect is that arrays are always passed by reference in chapter 5 we will discuss the use of pointers to permit functions to affect nonarrays in calling functions a bit of a digression since including array as an argument passes the location or memory address of the array into the function the function cannot can change the items in the array using array subscripts in particular the array contents are not copied when an array is passed into a c function when we get destructs in a future chapter we will find that the content of structs also are passed using the address of the entire struct so structs are passed by reference as well when thinking about past by reference or pass by value remember that a char variable is a single item similar to int and passed by value i.e is copied in c strings are arrays of characters so they are passed by reference python follows this design for the same efficiency reason as c normal single variables like int or float are copied before being passed into a function and therefore passed by value collections like list or dict are passed into functions by reference so the contents can be changed within a function python strings are not technically copied when being passed into a function but the way assignments happen in python make it seem like strings are passed by value since they can never be modified you can learn more with a bit of web research but the easy way is to imagine in python that strings are passed by value with a clever trick to avoid requiring a copy for every function call php follows the same pattern of passing numbers and strings by value and passing arrays as reference php passes strings by value without recover without requiring a copy again using clever runtime code because in java javascript and php strings are objects of course which we haven't discussed much yet those languages can make sure that strings act as if they were passed by value and not passed by reference the way they are always passed in c c made decisions on its run time based on getting the maximum performance out of the hardware of the 1970s at the expense of making it too easy to write code that overwrites memory and leads to corrupted programs that have dangerous and undefined behavior languages like php java and javascript add a small amount of runtime overhead to do things like store the length of an array and make sure we programmers don't over reference the array and overwrite random bits of our program's code or data the creators of c placed more priority on speed and efficient use of memory than safety it is like driving an autom automobile in the rain without abs automatic braking system it is fast but dangerous and should be reserved by highly skilled and very careful programmers and drivers and those drivers should probably be on a race course by the way back to the text by the way there is no entirely satisfactory way to write a portable function that accepts a variable number of arguments because there is no portable way for the called function to determine how many arguments were actually passed in a given call thus you can't write a truly portable function that will compute the maximum of an arbitrary number of arguments as will the max functions that are built in to fortran and pl1 it is generally safe to deal with a variable number of arguments if the called function doesn't use an argument that was not actually supplied and if the types are consistent printf the most common c function with a variable number of arguments uses information from the first argument which is the formatting string to determine how many other arguments are present and what their types are it fails badly if the caller does not supply enough arguments or if types are not what the first argument says it is also nonportable and therefore must be modified for different programming environments alternatively if arguments are of known types it is possible to mark the end of the argument list in some agreedupon way such as a special argument value often zero that stands for the end of the arguments interestingly modern languages like python php and java go to great lengths to make variable length argument lists work predictably and portably the syntax for variable length argument lists in these language can be a bit obtuse at times but at least it's allowed documented reliable and portable section 4 external variables a c program consists of a set of external objects which are either variables or functions the adjective external is used primarily in contrast to internal which describes arguments and automatic variables defined inside functions external variables are defined outside any function and are thus potentially available to many functions functions themselves are always external because c does not allow functions to be defined inside other functions by default external variables are also global so that all references to such a variable by the same name even from functions that are compiled separately are references to the same thing in as this sense external variables are analogous to fortran common or pl1 external we will later see how to define external variables and functions that are not globally available but instead only visible within a single source file because external variables are globally accessible they provide an alternative to function arguments and return values for communicating data between function any function may access an external variable by referring it to by name if the name has been declared somehow if a large number of variables must be shared among functions external variables are a more convenient and efficient than long argument lists as pointed out in chapter 1 however this reasoning should be applied with some caution for it can have a bad effect on program structure and lead to programs with many data connections between functions a second reason for using external variables concerns initialization in particular external arrays may be initialized but automatic ie internal arrays may not we will treat initialization near the end of this chapter the third reason for using external variables is their scope and lifetime automatic variables are internal to a function they come into existence when the routine is entered and disappear when it's left external variables on the other hand are permanent they do not come and go so they retain values from one function invocation to the next thus if two functions must share some data yet neither calls the other it is often most convenient if the shared data is kept in external variables rather than passed in and out via arguments let's examine this issue further with a larger example the problem is to write another calculator program better than the previous one this one permits plus minus asterisk and slash and equals equals will print our answer because it is somewhat easier to implement the calculator will you use reverse polish notation instead of in fixed notation reverse polish notation is the scheme used by for example hewlettpackard pocket calculators in reverse polish notation each operator follows its operators operands an infix expression like open parenthesis 1 minus 2 close parentheses c star open parenthesis 4 plus 5 close parenthesis equals is entered as 1 2 minus 4 5 plus star equals parentheses are not needed in reverse polish notation the implementation is quite simple each operand is pushed onto a stack when an operator arrives the proper number of operands two for binary operators are popped the operator applied to them and the result is pushed back onto the stack in the example above one and two are pushed then replaced by their difference negative one next four and five are pushed then replaced by their sum nine and then the product of negative one and nine which is negative nine replaces them on the stack and then the equal sign operator prints the top element without removing it so intermediate steps in a calculation can be checked the operations of pushing and popping a stack are trivial but by the time error detection and recovery are added they're long enough so it's better to put each in a separate function than to repeat the code throughout the whole program and there should be a separate function for effects fetching the next input operator or operand thus the overall structure of the program is while next operator or operand is not into file if it's a number push it else if it's an operator pop operands do the opera operation and push the result else error the main design decision that has not yet been discussed is where the stack is that is what routines access it directly one possibility is to keep it in main and pass the stack and current stack position to the retrains that push and pop it but maine doesn't need to know about the variables that control the stack it should only think about pushing and popping so we have decided to make the stack and its associated information external variables accessible to push and pop but not to main translating this outline to code is easy enough the main program is primarily a big switch on the type of operator or operand this is a more typical use of switch than the one shown in chapter 3. this sample code is from page 74 of the textbook pound include stdio.h pound define maxop 20 pound defined number quote zero quote this is going to be a single we found a number and pound to find two big quote nine quote a signal that the string is too big main open parenthesis close parenthesis open curly brace int type semicolon char s open square bracket max op close square bracket semicolon double opt 2 a to f open parenthesis close parenthesis comma pop open parenthesis close parenthesis comma push open parenthesis close parenthesis semicolon while open parenthesis open parenthesis type equals get up open parenthesis s comma max op close parenthesis close parenthesis not equal e o f close parenthesis switch open parenthesis type close parenthesis open curly brace case number colon note that number is a predefined constant above push open parenthesis a to f open parenthesis s close parenthesis close parenthesis semicolon break case quote plus quote colon push open parenthesis pop open paren close paren plus pop open for n close paren close paren semicolon break semicolon case quote asterisk quote colon push open paren pop open paren close paren asterisk pop open paren close paren close paren semicolon break semicolon that was the multiplication case quote minus quote colon op 2 equals pop open for n close paren push open paren pop minus op2 close print semicolon break semicolon that was subtraction case open print slash close paren colon op 2 equals pop open paren semicolon if up to not equal 0.0 push open print pop open paren close print slash opt2 close paren semicolon else printf double quote zero divisor popped backslash n double quote close paren semicolon break case quote equal quote colon printf open paren double quote backslash t percent f backslash n double quote comma push open paren pop open friend close paren close paren close friend semicolon so to print it we pop it and push it and then print the residual value of the push function the next line is break semicolon case quote c quote colon clear open paren close print semicolon break semicolon case too big colon print f double quote percent dot 20 s space dot dot dot is too long backslash n double quote comma s close paren semicolon break semicolon default colon print f open paren double quote unknown command percent c backslash n double quote comma type open print close print semicolon break semicolon close paren close curly brace to finish the switch statement and then close curly brace to finish the main so now we're going to have a separate file that has some of these functions defined this file is on page 75 of the textbook this file will be compiled separately but then later linked all together with the main program but we're going to define push pop and clear in this file pound include stdio.h pawn define maxval 100 maximum value that would be the maximum value of our stack the maximum size of our stack maximum depth of our stack now we are declaring variables outside of any function these are the external variables int sp equals zero double val open square bracket max val close square bracket semicolon and so those variables are external variables and they're outside of all of the functions but we can use them in any function and there's just one copy no matter what function we're using it so now we define our functions double push open paren f close paren double f semicolon open curly brace if open paren sp less than max val close paren return open paren val open square bracket sp plus plus close square bracket equals f close paren semicolon else open curly brace printf double quote air colon stack full backslash n double quote closed paren semicolon clear open paren close print semicolon return open print zero close paren semicolon close curly brace to finish the else and then close curly brace to finish the double function the push function and now we define the pop double pop open print close paren open curly brace if open paren sp greater than zero close paren return open paren val open square bracket minus minus sp close square bracket close curly brace semicolon else open curly brace printf open paren double quote error colon stack empty backslash n close quote close double quote close paren semicolon clear open paren close paren semicolon return open print zero close paren semicolon close curly brace to finish the else and then close curly brace to finish the double and the last function we're going to define is the clear function which is quite simple clear open paren close paren open curly brace sp equals zero semicolon close paren i would note that just read this one carefully they're very good at using side effect operators and side effect assignments and to keep this code very simple and succinct and you really have to understand a lot of the other stuff that you've covered in the book up to this point back to the text the command c clears the stack with the function clear which can also be used by push and pop in case of error we'll return to get op in a moment as discussed in chapter one a variable is external if it is desi defined outside the body of any function thus the stack and stack pointer which must be shared by push pop and clear are defined outside the three functions but if main itself does not refer to the stack or stack pointer their representation is carefully hidden thus the code for the equal operator must use push open print pop parentheses parentheses close parenthesis close parenthesis semicolon to examine the top of the stack without disturbing it notice also that because plus and multiplication are commutative operators the order in which the popped operands are combined is irrelevant but for the minus and slash operators the left and right operands must be distinguished this example code above shows why it's important to remember the k and r c arrange rearrangement license as it applies to operators that are associative and commutative if the code for the minus operator were written written push open paren pop open print close print minus pop open print close paren close print semicolon there is no guarantee that the left pop will run before the right pop and since these functions access global variables and have side effects it is important to force the compiler not to rearrange the order of the function calls to force the evaluation order the code is broken into two statements op2 equals pop open print close print semicolon push open open paren pop open paren close paren minus op2 close paren semicolon now you might think that the lesson here is that the k rc arrangement license which was done to allow optimization and performance is a bad idea but the more important lesson is that writing low level utility functions like push and pop that use global variables and have side effects is a dangerous pattern in any programming language section 4.5 scope rules the functions and external variables that make up a c program need not all be compiled at the same time the source text of the program may be kept in several files and previously compiled routines may be loaded from libraries the two questions of interest are how are declarations written so that variables are properly declared during compilation and how our declarations set up so that all the pieces will be properly linked or connected when the program is loaded the scope of a name is the part of the program over which the name is defined for an automatic variable declared at the beginning of a function the scope is the function in which the name is declared and variables of the same name in different functions are unrelated the same is true of the arguments of the function the scope of an external variable lasts from the point at which is it is declared in a source file to the end of that file for example if val sp push pop and clear are defined in one file in the order shown above that is intsp equals zero double val open square bracket maxval close square bracket semicolon double push open print f close paren open curly brace dot dot close curly brace double pop open print close paren open curly brace dot dot dot close curly brace clear open paren close paren open curly brace dot dot dot close curly brace then the variables val and s p may be used in push pop and clear simply by naming them and no further declarations are needed on the other hand if an external variable is to be referenced before it is defined or it is defined in a different source file from the one in which it's being used then an extern declaration is mandatory it is very important to distinguish between the declaration of an external variable and its definition a declaration announces the property of the variable its type its size etc a definition also causes storage to be allocated if the lines int sp semicolon double val open square bracket maxval close square bracket semicolon appear outside any function they define the external variables sp and val and cause the storage to be allocated and also serve as the declaration for the rest of that source file on the other hand the lines extern int sp extern double val open square bracket close score bracket semicolon declare for the rest of the source file that sp is an int and val is a double array whose size is determined and allocated elsewhere but they do not create variables or allocate storage for them there must be only one definition of an external variable among all the files that make up the source program other files may contain extern declarations to access it there may also be an extern declaration in the file containing the definition any initialization of an external variable goes only with the definition array sizes must be specified with the definition but are optional with the extern declaration although it is not a likely organization for this program val and sp could be defined and initialized in one file and the functions push pop and clear defined in another then these definitions and declarations would be necessary to tie them together in file 1 we would see int sp 0 semicolon double val open square bracket max val close square bracket semicolon and then in file 2 x turn in sp semicolon x turn double val open square bracket close square bracket semicolon double push open print f close paren open curly brace dot dot close curly brace double pop open frame close paren open curly brace dot dot dot close curly brace clear open friend close paren open curly brace dot dot dot close curly brace because the x turned declarations in file two lie ahead and outside the three functions they apply to all one set of declarations suffices for all of file 2. for larger programs the pound include file inclusion facility discussed later in this chapter allows one to keep only a single copy of the extern declarations for the program and have that inserted in each source file it's as it's being compiled let us now turn to the implementation of getup the function that fetches the next operator or operand the basic task is easy skip blanks tabs and new lines if the character is not a digit or a decimal point return it otherwise collect a string of digits that might include a decimal point and return number a single signal that a number has been collected the routine is substantially complicated by an attempt to handle the situation properly when the input number is too long get up reads digits perhaps with an intervening decimal point until it doesn't see anymore but only stores the ones that fit if there was no overflow it returns number in the string of digits if the number was too long however getup discards the rest of the input line so the user can simply retype the line from the point of error it returns too big as the overflow signal this example code is from page 78 of the textbook and you can view it at www.cc4e.com code page 78 get up open friend s comma lim close paren char s open square bracket close square back at semicolon int lim semicolon open curly brace int i comma c semicolon while open paren open paren c equals get ch open paren close paren close paren double equals quote space quote or c double equals quote backslash t quote or c double equals quote backslash end quote close paren semicolon skip all the blanks if c is not equal quote dot quote and open paren c less than quote zero quote vertical bar vertical bar c greater than quote nine quote close paren close paren return s return open paren c close paren s sub zero equals c four paren i equals one semicolon open paren c equals get chart open paren close paren close print greater than or equal to quote zero quote and c less than or equal to quote nine quote semicolon i plus plus inside the for loop if i less than limb s sub i equals c if open for n c double equals quote dot quote close paren open curly brace we begin to collect the fraction if open print i less than limb close paren s sub i equals c four open paren i plus plus c equals get char open paren close paren close paren greater than or equal to quote zero quote ampersand ampersand c less than or equal to quote nine quote semicolon i plus plus closed paren if open prime i less than limb close paren s sub i equals c close curly brace to close the if statement where we're collecting the fraction if open paren i less than limb close paren open curly brace this means the number is good ungetch is ch open friends c close paren semicolon s sub i equals quote backslash zero quote semicolon return open paren number close print and recall that number is a predefined constant close curly brace else open curly brace if it's too big we're going to skip to the end of the line while open paren c not equal quote backslash end quote and c not equal eof open paren c equals get char open for enclosed paren semicolon s sublim minus one equals quote backslash zero quote semicolon return too big semicolon close curly brace to finish the if and then close curly brace to finish the function recall that too big is a constant that indicates that we've read too much back to the text what are get ch and unget ch well it is often the case that a programming reading input cannot determine that is read enough until it is read too much one instance is collecting characters that make up a number until the first nondigit is seen the number is not complete but then the program has read one character too far and that is a character it is not prepared for the problem would be solved if it were possible to unread the unwanted character then every time the program reads one character too many it could push it back on the input so that the rest of the code would behave as if it never been read fortunately it is easy to simulate ungetting a character by writing a pair of cooperating functions getch delivers the next input character to be considered ungetch puts the character back on the input so the next call to get ch will return it again how they work together is simple unget ch puts puts the pushed back characters into a shared buffer a character array gets the ch reads from the buffer is there's anything there and then it calls get char if the buffer is empty there must be an index variable which records the position of the current character in the buffer since the buffer and index are shared by get ch and unget ch and must retain their values between calls they must be external to both routines thus we can write getch and ungetch and their shared variables as follows this is on page 79 of the textbook you can see the code at www.cc4e.com code and go to page 79 pound include stdio.h found to find buff size 100 char buff open square bracket buff size close square bracket semicolon int buff p equals zero semicolon those are the external variables outside any function here's the first function get ch open friend close paren open curly brace return open parenthesis open parenthesis buff p greater than zero close parenthesis question mark buff open square bracket minus minus buff p close square bracket colon get char open paren close paren close paren semicolon close curly brace to finish the get ch function the unget ch function pushes a character back on input ch open paren c close paren into c semicolon open curly brace if open paren buff p greater than buff size printf open prin double quote unget ch colon too many characters backslash n double quote close paren semicolon else buff open square bracket buff p plus plus close square bracket equals c semicolon and then close curly brace to finish the ungetch function we have used an array for pushback rather than a single character since the generality may come in handy later section 4.6 static variables static variables are a third class of storage in addition to the x turn and automatic that we've already met static variables may either be internal or external internal static variables are local to a particular function just like automatic variables are but unlike automatics they remain in existence rather than coming and going each time the function's activated this means that internal static variables provide private permanent storage in a function character strings that appear within a function such as the arguments of printf are internal static an external static variable is known within the remainder of the source file in which it's declared but not in any other file external static thus provides a way to hide names like buff and buff p in the get ch unget ch combination which must be external so they can be shared yet which should not be visible to users of get ch and unguess ch so there's no possibility of conflict if the two routines are compiled in one file as in static char buff open square bracket buff size close square bracket semicolon static int buff p equals zero semicolon get ch open frame close paren open curly brace dot dot close curly brace unget ch open paren c close paren open curly brace dot dot dot close curly brace then no other routine will be able to access buff and buff p in fact they will not conflict with the same names in other files of the same program static storage whether internal or external is specified by prefixing the normal declaration with the word static the variable is external if it's defined outside of any function and internal if defined inside a function normally functions are external objects their names are known globally it is possible for a function however to be declared static this makes its name unknown outside the file in which it's declared in c static connotates not only permanence but also a degree of what might be called privacy internal static objects are known only inside one function external static objects variables or function are are known only within the source file in which they appear their names do not interfere with variables or functions of the same name in other files external static variables and functions provide a way to conceal data objects and any internal routines that manipulate them so that other routines and data cannot conflict even inadvertently for example getch and ungetch form a module for character input and pushback buff and buff p should be static so they're inaccessible from the outside in the same way push pop and clear form a module for stack manipulations val and sp should also be external static 4.7 register variables the fourth and final storage class is called register a registered declaration advises the compiler that the variable in question will be heavily used when possible register variables are placed in machine registers which may result in smaller and faster programs the register declaration looks like register int x semicolon register char c semicolon and so on the in part may be omitted register can only be applied to automatic variables and the formal parameters of a function in this latter case the function declaration looks like f open paren c comma n close paren register int c comma n semicolon open curly brace register int i semicolon and then dot dot close curly brace in practice there are some restrictions on register variables reflecting the realities of the underlying hardware only a few variables in each function may be kept in registers and only certain types are allowed the word register is ignored for excess or disallowed declarations and it is not possible to take the address of a register variable a topic that will be covered in chapter 5. the specific restrictions vary from machine to machine as an example on the pdp11 only the first three registered declarations in a function are effective and the types must be int char or pointer as a quick aside the description of the details of the implementation of the register modder modifier on the pdp11 is a delightful peek into how the c compiler generated runtime code on that particular system in the 1970s as compilers have become more sophisticated the compiler could decide which variables to keep in registers far better than the programmer could and since how variables would be allocated to registers might be different on different hardware architectures the register indication is generally ignored by modern c compilers so you should probably never use it in your code as a matter of fact i wrote the following sample c program and compiled it with the minus capital s option so i could see the generated assembly language with and without the register declaration with optimization there was no difference between the code generated with or without the registered declaration the reason the generated assembly code was identical once you take a look at it was regardless of the use the register keyboard was that the c optimizer on my arm based computer in 2022 realized the best way to implement the code was to keep both of the variables in registers because the loop code was so simple and the cpu in my computer has plenty of registers and optimized any loading and storing of the data for these variables right out of the program in 1978 the authors likely included the register function as a feature to convince the experienced assembly language programmers that they should write all but the lowest lowest level code in c so write a little tiny bit in c and then i mean write a little tiny bit in assembly language and write everything else in c so here's an example that's not in the textbook it's on page 81 if it were in the textbook you can see this code at www.cc4ed code page 81 and this is code that i wrote to play with the register keyword to mostly convince myself it was pointless to use it but here we go pound include stdio dot h int main open prime close print open curly brace int compute semicolon register end enter semicolon scanf open for n double quote percent d close quote comma ampersand compute close parenthesis semicolon printf open parenthesis double quote compute space percent d backslash n double quote comma compute close parenthesis semicolon four open print iter equals zero semicolon enter less than one thousand semicolon iter plus plus close parenthesis open curly brace compute equals open parenthesis compute times 22 close parenthesis times seven if compute greater than one thousand compute equals compute modulo one thousand close curly brace printf open paren double quote compute space percent d backslash n close quote comma compute semicolon close curly brace now some of these i wrote this code in a way that tries to convince the uh the the optimizer that i'm actually going to use these values that's why i read the value from input as compared to a constant it would actually optim the optimizer so so so smart that it would just eliminate all the constant calculations so but that's my sample playing with register section 4.8 block structure c is not a block structured language in the sense of pl1 or algol in that functions may not be defined within other functions on the other hand variables can be defined in a block structured fashion declarations of variables including initializations may follow the left brace that introduces any compound statement not just the one that begins a function variables declared this this way supersede any identically named variables in outer blocks and remain in existence until the matching right race for example if open parentheses n greater than zero close parenthesis open curly brace int i semicolon declare a new i four open parenthesis i equals 0 semicolon i less than n semicolon i plus plus close parenthesis and dot dot the rest of the for loop and then a closed curly brace for the if the scope of the variable i is in the true branch of the if this i is unrelated to any other i in the program block structure also applies to external variables given the declarations int x semicolon f open parenthesis closed parenthesis open curly brace double x semicolon dot dot dot close parenthesis then within the function f occurrences of x refer to the internal double variable outside of f they refer to the external integer this is same is true of the names of formal parameters for example in z semicolon outside of any function f open parenthesis z close parenthesis double z semicolon open curly brace dot dot close curly brace within function f z refers to the formal parameter not the external variable section 4.9 initialization initialization has been mentioned in passing many times so far but always peripherally to some other topic this section summarized some of the rules now that we have discussed the various storage classes in absence of explicit initialization external and static variables are guaranteed to be initialized to zero automatic and register variables have undefined or garbage values simple variables not arrays or structures may be initialized when they are declared by following the name with an equal sign and a constant expression int x equals one semicolon jar s quote equals single quote backslash single quote single quote semicolon a constant of a single character that is a single quote itself long day equals 60 times 24 semicolon which is the minutes in a day for external and static variables the initialization is done once conceptually at compile time for automatic and register variables it is done each time the function or block is entered for automatic and register variables the initializer is not restricted to being a constant it may in fact be any valid expression involving previously defined values even function calls for example the initializations of the binary search program that we wrote in chapter 3 could be written as binary open parenthesis x comma v comma n close parenthesis int x comma v open square bracket close square bracket comma n semicolon open curly brace int low equals zero semicolon and high equals n minus one semicolon and in mid followed by the rest of the function and then close curly brace instead of initializing these as the first executable statements and we would do this with binary open paren x comma v comma n close paren int x comma v open square bracket close square bracket comma n semicolon open curly brace int low comma mid comma high semicolon low equals 0 semicolon high equals n minus 1 semicolon and so forth in effect initializations of automatic variables are just shorthand for assignment statements which form to prefer is largely a matter of taste we have generally used explicit assignments because initializers and declarations are harder to see automatic arrays may not be initialized external and static arrays may be initialized by following the declaration with a list of initializers enclosed in braces and separated by commas for example the character counting program of chapter 1 which originally was main open parentheses closed princely open curly brace int c comma i comma n white comma n other int n digit open square bracket 10 close square bracket semicolon n white equals n other equals zero four open parenthesis i equals zero semicolon i less than ten semicolon i plus plus closed parenthesis and digit sub i equals 0 and then the rest of the code followed by a closed curly brace finishing main this could be written instead using initializers as follows int and white equals 0 semicolon int and other equals zero semicolon int n digit open square bracket 10 close square bracket equals open curly brace zero com zero comma zero comma zero comma zero comma zero comma zero comma zero comma zero comma zero close curly brace ten zeros in a row and separated by commas and in braces and then the main code is simply main open paren close paren open curly brace in comma c comma i and then the rest of the main code close curly brace the idea is is that with the initializers and with the external variables outside of the main function you do not need to initialize them even with a for loop in the beginning of the main program these initializations are actually all unnecessary since they're all zero anyways but it's a good form to make them explicit anyway if there are fewer initializers than the specialized size the others will be zero it is an error to have too many initializers regrettably there is no way to specify the repetition of an initializer nor to initialize an element in the middle of the ray without supplying all the intermeaning intervening values as well character arrays are a special case of initialization a string may be used instead of the braces in commas notation as in char pattern open square bracket close square bracket equals double quote th e double quote semicolon this is a shorthand for the longer but equivalent char pattern open square bracket close square bracket equals open curly brace single quote t single quote comma single quote h single quote comma single quote e single quote comma single quote backslash zero single quote close curly brace semicolon when the size of an array of any type is omitted the compiler will compute the length of the array by counting the initial initializers in this specific case the size of pattern is four three actual characters plus the terminating backslash zero i would note that the primary difference between c and c influence like languages like java php and javascript this key is that c strings are character arrays while in the other languages strings are objects these string objects do have inside themselves an array of bytes or characters but they also keep track of things like the length of the string and provide functionality like extract a substring in the methods in these objects in c there is a set of library functions that perform string operations like compare two strings while cut string comparison is built into the string objects in each of the other languages strings as character arrays allow programmers to build very fast lowlevel code in libraries and operating systems but to write the code well you need to understand what is really going on at the low level section 4.10 recursion c functions may be used recursively that is a function may call itself either directly or indirectly one traditional example involves printing of a number as a character string as we mentioned before the digits are generated in the wrong order low order digits are available before four high order digits but they have to be printed in the other way around there are two solutions to this problem one is to store the digits in an array as they are generated and then print them in reverse order as we did in chapter 3 with eye to a the first version of print d follows this pattern this is sample code on page 85 of the textbook you can view the sample code at com www.cc4e.com code page 85 example one pound include stdo dot h print d open paren and close paren in open curly brace char s open square bracket 10 close square bracket semicolon and i semicolon if parenthesis n less than 0 parenthesis open curly brace put char open prin single quote dash single quote close paren semicolon n equals minus n semicolon close curly brace i equals zero semicolon do open curly brace s sub i plus plus equals n modulo 10 plus quote zero quote which gets the next character while parentheses parenthesis equal 10 close parenthesis greater than zero close parenthesis semicolon then we reverse the string while open print minus minus i greater than equal to zero close paren put char open paren s sub i close paren semicolon close curly brace to end the print d function the alternative is a recursive solution in which each call of print d first its calls itself to cope with any leading digits then prints the trailing digit after that call returns this is an example on page 85 of the textbook in its example pound include stdio.h print d open paren n close paren int n semicolon open curly brace int i semicolon if open friend n less than zero close paren open curly brace put chair open paren single quote dash single quote close paren semicolon n equals minus n semicolon close curly brace to finish the if if open paren open print i equals n over 10 close print not equal 0 close print print d open print i closed paren semicolon that's the recursive call and after the recursive call comes back we do put char open paren n modulo 10 plus single quote 0 single quote close paren semicolon close curly brace to end the print d function when a function calls itself recursively each invocation gets a fresh set of all the automatic variables quite independent of the previous set thus in print d 123 the first print d has n equals 123. it passes 12 to a second print e then prints three when that one returns in the same way the second print d passes one to a third which prints it and then prints 2. recursion generally provides no saving in storage since somewhere a stack of values is being processed or has to be maintained nor will it be faster but recursive code is more compact and often much easier to write and understand recursion is especially convenient for recursively defined data structures like trees we will see a nice example in chapter 6. as an aside ah recursion recursion recursion recursion is a beloved concept in computer science it is often taught early in most programming courses because it is just so cool most examples are sadly like computing factorial or the example above converting an integer to a string and they're not good uses a recursion actually but when you do finally find yourself in need of traversing a treebased structure like an xml document or parsing a mathematical expression with parentheses recursion is the ideal solution so the problem in a sense is not recursion but when it is taught and what examples are used interestingly kernighan and ritchie include the correct warning about using recursion when it is not the best solution in the above text and it bears another read back to the book recursion generally provides no saving in storage since somewhere a stack of values is being processed or has to be maintained nor will it be faster but recursive code is more compact and often much easier to write and understand recursion is especially convenient for recursively defined data structures like trees we will see a nice example in chapter 6. i couldn't have said it better section 4.11 the c preprocessor c provides certain language extensions by means of a simple macro preprocessor the pound defined capability which we have used is the most common of these extensions another is the ability to include the entire contents of other files during compilation file inclusion to facilitate handling of pound defines and declarations among other things c provides a file inclusion feature any line that looks like pound include space double quote file name double quote is replaced by the contents of the file name the quotes are indeed mandatory often a line or two of this form appears at the very beginning of each source file to include common pounddefined statements and extern declarations for global variables pound includes may be nested pound include is the preferred way to tie declarations together for a large problem and in a large program it guarantees that all the source files will be supplied with the same definitions and variable declarations thus eliminating a particularly nasty kind of bug of course when an include file is changed all the files that depend on it must be recompiled macro substitution a definition of the form pound define yes one calls for a macro substitution of the simplest kind repeat replacing a logical name by a string of characters names in the pound of fine have the same forms as the c identifiers the replacement text is arbitrarily normally the replacement text is the rest of the line a long definition may be continued by pasting a backslash at the end of the line to be continued the scope of the name defined with pound define is from from its point of definition to the end of the source file names may be redefined and a definition may use previous definitions substitutions do not place take place within quoted strings so for example if yes is a defined name there would be no substitution in printf open paren double quote yes double quote close paren since implementation of pound define is a macro prepass not part of the compiler proper there are very few grammatical restrictions on what can be defined for example alcohol fans can say pound define then and then nothing pound define begin open curly brace pound define end semicolon close curly brace and then write approximate algo if paren i greater than zero close paren then begin a equals one semicolon b equals two end it is also possible to define macular macros with arguments so the replacement text depends on the way the macro is called as an example define a macro called max like this pound define max open paren a comma b open paren open paren a close paren greater than open paren b close print question mark open parent a closed paren colon open paren b close paren close paren now the line x equals max open paren p plus q comma r plus s close paren semicolon will be replaced in the preprocessor by the line x equals open paren open paren p plus q close paren greater than open paren r plus s close paren question mark open paren p plus q close print colon open paren r plus s close paren close print semicolon this provides a maximum function that expands into inline code rather than a function call so long as the arguments are treated consistently this macro will serve for any data type there is no need for different kinds of macs for different data types as there would be with functions of course if you examine the expansion of max above you will notice some pitfalls the expressions are evaluated twice it is bad if they involve side effects like function calls increment operators or perhaps push and pop like we've used before some care has to be taken with parentheses to make sure the order order of evaluation is preserved consider the macro pound defined square open paren x close paren equals x times x when it is invoked as square open paren z plus one close paren there are even some purely lexical problems there can be no space between the macro name and left parenthesis that introduces the argument list nevertheless macros are quite valuable one practical example is the standard io library to be described in chapter 7 in which git char and put char are defined as macros obviously put chart needs an argument thus avoiding the overhead of a function call per character profit process other capabilities of the macro processor are described in appendix a as a bit of a long aside in this section we are talking about the preprocessor it's probably a good time to talk a bit about why we use this terminology for those of you with a computer science degree from back in the day many of you wrote a compiler as a senior project just like i did building a compiler was a great project because part of the goal of computer science is to understand the technologies that make programming process possible from the language syntax down to the hardware the compiler that translates our source code into machine code is an essential part of the technology stack that we use early compilers for languages like the early fortran variants tended to be translators they just translated code one line at a time from a highlevel language to assembly language you could think of early fortran programs in the 1950s and the 1960s as just more convenient ways to write assembly language for programmers that knew assembly language you always needed to be aware of assembly language and the translation that it was going to write fast fortran programs were small and optimization was done at the fortran level often leading to some hard to understand code by the mid1970s programming languages were based on parsing theory and we used what is called a grammar to define the language kernighan and ritchie kept io statements out of the c language to keep its formal definition i.e its grammar as simple as possible as these new languages emerge they allowed for more theoretical and powerful approach to converting source code to machine language the theoretical advances in compiler and language design meant that parts of the compiler might be reusable across multiple programming languages each language could have its own syntax and grammar rules and they could be plugged into the compiler and poof you would have a new programming language it got to the point where unix system unix systems had a tool called yak which stood for yet another compiler compiler you would give it a grammar for your new language and it would make a compiler for you as a matter of fact the javascript language that was created in 10 days back in 1995 was possible because brendan ike had a lot of experience with compiler generators he defined a grammar for javascript and generated his first compiler part of what made a compiler generate generator possible is the idea of a multistep compiler or the tasks of a compiler were broken down into a series of simpler and more welldefined steps here are the steps of a typical c compiler in the 1970s first a preprocessor step that takes c code with syntax like pound define and pout include as its input and produces raw c code output with o's instructions processed and or expanded the preprocessor processor was a c to c transformation next a parser step that took the raw c code applied the grammar to the language and created what is called a parse tree think of the tree as a hierarchy of statements grouped into blocks grouped into functions etc of things like a loop or just one node in a parse tree after that a code generation would turn the parse tree into some kind of simplistic portable internal code that expanded things like loops and ifthenelse statements into code after that a code optimization that looked at the internal code and moved things around eliminating any redundant computations say don't compute the same things twice this step is why the authors make such a big fuss about how there are times where c might do things in a slightly different order in an expression even in the presence of parentheses remember the knrc arrangement license back in chapter 2 that rule removes constraints on the compiler's optimization step so it can generate the most efficient code i would note that all the steps up to this point did not depend in any way on the actual machine language of the system that they were running on this meant a preprocessor parser code generator and code optimizer could literally be written in c and used on any architecture the final step is a code generator that takes the optimized intermediate code and generates the actual assembly and machine language for the processor for fun you can add the minus capital s parameter to your c compiler and see the resulting assembly language output for your system if you look at the machine language generated on intel or amd processor and compare it to the machine language on an arm processor it will look very different because all but the final compiler steps did not depend on the computer where the program is being run you could actually create a c compiler on a new computer architecture by writing a code generator on the new computer then running all but the last step of the compiler on one computer then copying the internal code generated by the compiler to the new compiler and running the code generation step on the new computer then you actually have a working c compiler on the new computer and the first step is usually to recompile the c compiler itself from source code to produce a fully native c compiler on the new computer that can compile all the rest of the c code you have including possibly the mostly portable elements of the unix operating system on the new compiler yes describing how to cross compile and bootstrap a c compiler onto a new computer hardware architecture can give you a headache if you think about it too much but this notion of bootstrapping a c compiler onto a new architecture was an important technique to move c and then unix to a wide range of very different computer architectures we see this in action as the unixlike mac os operating system over the past 20 years was delivered initially on a motorola 68 000 family processors then on powerpc processors and then on intel processors and most recently on armbased processors built by apple using the software portability patterns that come from c and unix and described by kernighan and ritchie in this book apple now makes their own hardware that can be tuned and evolved over time as their operating system and their applications requirements dictate the use of a grammar by the way is to define a programming language is one of the reasons that syntax errors are so obtuse the compiler is not looking at your code like a human it is following a very set of simple rules to parse your code and it's stuck with something logical and gives you a message like unexpect unexpected statement block or constant on line 17 and the error is nowhere near line 17. modern compilers are more sophisticated of course than the steps above but these steps give you a sense the compiler does many things to make it so your code can actually run very efficiently and given that kernighan and richie were building a programming language c a more mostly portable operating system written in c unix and a mostly portable c compiler written in c some of their innovative work and research into compiler design finds it its way into this book so we have a section in this chapter called the c preprocessor so here we are at the end of chapter four and it's a good time to talk about the word address up to this point in the book if you count them the word address has been used 10 times without a precise definition beyond the notion that data is stored in memory and the address of the data is where the data is stored in memory in the next chapter this notion of the address where the data is stored becomes very real and tangible as we explore pointers as well as the ampersand and asterisk operators up to now an experienced javascript php or java programmer can view c as just another set of similar syntax rules with a few quirky runtime bits but in the next chapter we will deeply explore the concept of data allocation and location it turns out that every programming language pays a lot of attention to data allocation and location but the runtime environments of modern languages work very hard not to expose you to those details just because modern languages hide the difficult bits from us it does not mean that those languages solve the problem using magic eventually the problem needs to be solved and that is why the compiler and lowlevel runtime elements of language like php javascript and java are usually written in c so the builders of those languages can solve the difficult data storage and allocation problems for you this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a software centered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 5 pointers and arrays before we start chapter 5 a quick note from your narrator from time to time i have been adding some of my interpretation to this book but i won't be adding anything to this chapter i think that sections 5.1 through 5.6 contain some of the most elegantly written text in the book the concepts are clearly stated and the example code is short direct and easy to understand pointers are the essential difference between c and any other modern programming language so pay close attention to this chapter and make sure that you understand it before continuing this chapter is as strong now as it was in 1978 and so without further ado we read and listen as kernighan and ritchie teach us about pointers and arrays a pointer is a variable that contains the address of another variable pointers are very much used in c partly because they are sometimes the only way to express a computation and partly because they usually lead to more compact and efficient code than can be obtained in other ways pointers have been lumped with a goto statement as a marvelous way to create impossible to understand programs this is certainly true when they are used carelessly and it is easy to create pointers that point somewhere unexpected with discipline however pointers can also be used to achieve clarity and simplicity this is the app aspect that we will try to illustrate section 5.1 pointers and addresses since a pointer contains the address of an object it is possible to access the object indirectly through the pointer suppose that x is a variable say int and that px is a pointer created in some as yet unspecified way the unary operator ampersand gives the address of an object so the statement px equals ampersand x semicolon assigns the address of x to the variable px px is now said to point to x the ampersand operator can be applied only to variables and array elements construct like ampersand open paren x 1 close paren and ampersand 3 are illegal it is also illegal to take the address of a register variable the unit the unary operator asterisk treats its operand as the address of the ultimate target and accesses that address to fetch the contents thus if y is also an int y equals star p x semicolon assigns to y the contents of whatever px points to so the sequence px equals ampersand x semicolon y equals star px semicolon assigns the same value to y as does y equals x it is also necessary to declare the variables that participate in all of this int x comma y semicolon int star px semicolon the declaration of x and y is what we have seen all along the declaration of the pointer px is new int star px semicolon is intended as a mnemonic it says that the combination star px is an end that is if px occurs in the context star px it is equivalent to a variable of type int in effect the syntax of the declaration for a variable mimics the syntax of expressions in which the variable might appear this reasoning is useful in all cases involving complicated declarations for example double a to f open parenthesis close parenthesis comma star dp semicolon says that in a particular expression a to f open friend close friend and star dp have values of type double you should also note the implication in the direction declaration that a pointer is constrained to point to a particular kind of objects pointers can occur in expressions for example if px points to the integer x then star px can occur in any context where x could y equal star px plus 1 sets y to 1 more than x printf open parenthesis double quote percent d backslash n double quote comma star px close paren prints the current value of x and d equals square root open paren open paren double close paren star p x close paren produces in d the square root of x which is coerced into a double before being passed to square root in expressions like y equals star px plus 1 the unary operators star and ampersand bind more tightly than arithmetic operators so this expression takes whatever px points at adds one and assigns it to y we will return shortly to what y equals star open paren px plus one close paren might mean pointer references can also occur on the left side of assignments if px points to x then star px equals zero sets x to zero and star px plus equals one increments it as does open paren star px close paren plus plus the parentheses are necessary in this last example without them the ink expression would increment px instead of what it points to because unary operators like star and plus plus are evaluated right to left finally since pointers are variables they can be manipulated as other variables can if py is another pointer to int then py equals px copies the contents of px into py thus making py point to whatever px points to section 5.2 pointers and function arguments since c passes arguments to functions by call by value there is no direct way for the called function to alter the variable in the calling function what do you do if you really have to change an ordinary argument for example a sorting routine might exchange two out of order elements with a function called swap it's not enough to write swap open parentheses a comma b close parentheses semicolon where the swap function is defined as and this is sample source code on page 91 of the textbook and you can see it at www.cc4e.com code this is a wrong swap by the way this this is showing you the code that you're not supposed to do swap open paren x comma y close paren int x comma y semicolon open curly brace int temp semicolon temp equals x x equals y semicolon y equals temp semicolon close curly brace because of call by value swap can't affect the arguments a and b in the routine that called it fortunately there is a way to obtain the desired effect the calling point program passes pointers to the values to be changed the call is swap open parentheses ampersand a comma ampersand b close parentheses semicolon since the operator ampersand gives the address of a variable ampersand a is a pointer to a in swap itself the arguments are declared to be pointers and the actual operands are accessed through them so the correct code is on page 92 swap open paren px comma py close paren int star px comma star py semicolon open curly brace int temp semicolon temp equals star px semicolon star px equals star py semicolon star py equals temp semicolon and closed curly brace one common use of pointer arguments is in functions that must return more than a single value you might say that swap actually returns two values the new values of its arguments as an example consider a function getint which performs a free format input conversion by breaking a stream of characters into integer values one integer per call getint has to return the value that it found or an end to file signal when there is no more input these values have to be returned as separate objects for no matter what value is used for eof that could also be a value of the integer one solution which is based on the input function scanf that we will describe in chapter seven is to have get in to return eof as its function value it finds end of file and other any other return value singles a normal integer the numeric value of the integer it found is returned through an argument which then must be a pointer to an integer this organization separates the end of file status from the returned numeric value the following loop fills an array with integers by calls to getint int n comma array open print size close paren semicolon for n equals zero n less than size double ampersand get int open paren ampersand v close print not equal eof semicolon and plus plus close parentheses array sub n equals v each call sets v to the next integer found in the input notice that is essential to write ampersand v instead of v as the argument to get int using plane v is likely to cause an addressing error since getint believes that it's been handed a valid pointer getint is an obvious modification to a to i which we wrote earlier the sample code is on page 93 of the textbook and you can see this sample code at dot www.cc4e.com slash code pound include stdio.h getint open paren pn close print int star pn semicolon open for open curly brace int c comma sign while open print open print c equals get ch open praying close paren close print double equals quote space quote or c double equals quote backslash n quote or c double equals backslash t quote close paren semicolon this loop we've done before and it skips the white space sine equals one semicolon if open paren c double equals quote plus quote or c double equals quote minus quote close paren open curly brace equals open parenthesis double equals quote plus quote close paren question mark 1 colon 1 semicolon c equals gut ch to advance the character semicolon and then close curly brace that those four lines record the sign now four star pn equals zero c greater than or equal to quote zero quote and c less than or equal to quote 9 quote colon semicolon c equals get ch open paren close paren close curly brace star pn equals 10 times star pn plus c minus quote zero quote star pn star equals sine if open paren c not equal to eof close print on get ch open paren c close paren semicolon return c throughout get int star pn is used as an ordinary int variable we have also used getch and ungetch as described in chapter four so the one extra character that must be read can be pushed backed on to the input section 5.3 pointers and arrays and see there is a strong relationship between pointers and arrays strong enough that pointers and arrays should really be treated simultaneously any operation which can be achieved by array subscripting can also be done with pointers the pointer version will in general be faster but at least to the uninitiated somewhat harder to grasp immediately the declaration int a sub 10 defines an array a of size 10 that is a block of 10 consecutive objects named a sub 0 a sub 1 dot dot a sub 9. the notation a sub i means the element of the array i positions from the beginning if p a is a pointer to an integer declared as int star pa then the assignment pa equals ampersand a sub zero sets pa to 0.2 the zeroth element of a that is pa contains the address of a sub zero now the assignment x equals star pa will copy the contents of a sub 0 into x if pay a points to a particular element of array a then by definition pa points to the next element nope if pa points to a particular element of an array a then by definition pa plus 1 points to the next element and in general a minus i points to i elements before p a and p a plus i points to i elements after thus if p a points to a sub zero star parentheses pa plus 1 closed parenthesis refers to the contents of a sub 1. pa plus i is the address of a sub i and star print and star open paren pa plus i is the contents of a sub i these remarks are true regardless of the type of the variables in the array a the definition of adding one to a pointer and by extension all pointer arithmetic is that the increment is scaled by the size of the storage of the object that is pointed to thus in pa plus i i is multiplied by the size of the objects that pa points to before being added to pa the correspondence between indexing and pointer arithmetic is evidently very close in fact a reference to an array is converted by the compiler to a pointer to the beginning of the array the effect is that the array name is a pointer expression this has quite a few useful implications since the name of an array is a synonym for the location of the zeroth element the assignment pa equals ampersand a sub zero can also be written as p a equals a rather more surprising at least at first sight is the fact that a reference to a sub i can also be written as star open paren a plus i close paren in evaluating a sub i c converts it to star open paren a plus i close paren immediately the two forms are completely equivalent applying the operator ampersand to both parts of this equivalence it follows that ampersand a sub i and a plus i are also identical a plus i is the address of the ith element beyond a as on the other side of this coin if p a is a pointer expressions may use it with a subscript p a sub i is identical to star open paren pa plus i close print in short any array and index expression can be rewritten as a pointer and an offset and vice versa even in the same statement there is one difference between an array name and a pointer that must be kept in mind a pointer is a variable so pa equals a and pa plus plus are sensible operations but an array name is a constant not a variable constructions like a equals pa or a plus plus or p equals ampersand a are illegal when an array name is passed to a function what is passed is the location of the beginning of the array within the call function this argument is a variable just like any other variable and so an arrayname argument is truly a pointer that is a variable containing an address we can use this fact to write a new version of stirlin which computes the length of the string the sample code is on page 95 of the book and you can see it in www.cc4e.com code page 95. int stirlin open paren s close prin char star s semicolon open curly brace int n semicolon four open parenthesis n equals zero semicolon star s not equal quote backslash zero quote semicolon s plus plus close paren n plus plus return open print and close paren semicolon close curly brace incrementing s is perfectly legal since it's a pointer variable s plus plus has no effect on the character string in the function that called sterlin but merely increments the stir lens private copy of the address as the formal parameters in a function definition char s open square bracket close square bracket semicolon and char star s semicolon are exactly equivalent which one should be written is determined largely by how expressions will be written in the function when an array name is passed to a function the function can at its convenience believe that has been handed either an array or a pointer and manipulated accordingly it can even use both kinds of operations if it seems appropriate and clear it is possible to pass part of an array to a function by passing a pointer to the beginning of the subarray for example if a is an array f open friend ampersand a sub 2 close print and f open paren a plus 2 close print both pass to the function f the address of the element a sub 2 because ampersand a sub 2 and a plus 2 are both pointer expressions that refer to the third element of a within f the argument declaration can read f open paren array close paren int array open bracket close bracket semicolon dot dot dot or f open paren array closed paren and star array semicolon so far as f is concerned the fact that the argument really refers to part of a larger array is really of no consequence section 5.4 address arithmetic if p is a pointer then p plus plus increments p to point to the next element of whatever kind of object p points to and p plus equals i increments p to the point i elements beyond where it currently does these and similar constructions are the simplest and most common form forms of pointer or address arithmetic c is consistent and regular in its approach to address arithmetic its integration of pointers arrays and address arithmetic is one of the major strengths of the language let us illustrate some of the properties by writing a rudimentary storage allocator but useful in spite of its simplicity there are two routines alec open paren and close paren returns a pointer p to n consecutive character positions which can be used by the caller of alec for storing characters free open paren p close print releases the storage thus acquired so it can later be reused these routines are rudimentary because the calls to free must be made in the opposite order to the calls on alec that is storage managed by alec and free is a stack or last in first out the standard c library provides analogous functions which have no such restrictions and in chapter 8 we'll show how improved versions as well in the meantime however many applications really only need a trivial alec to dispense little pieces of storage of unpredictable sizes at unpredictable times the simplest implementation is to have alec hand out pieces of a large character array which we will call alec buff this array is private to allocan free since they deal in pointers and not array indices no other routine need know the name of the array which can be declared as external static that is local to the source file containing allocan free and invisible outside it in practical implementations the array may well not even have a name it might be obtained by asking the operating system for a pointer to some unnamed block of storage the other information needed is how much alec buff has been used we use a pointer to the next free element called alex cp when alec is asked for n characters it checks to see if there is enough room left in alec buff if so alec returns the current value of alec p ie the beginning of the free block and then increments it by n to point to the next free area free p merely sets alec p to p if p is inside alec buff this next code example is on page 97 of the textbook you can see the code at www.cc4e.com code pound include stdio.h to find null zero it's a pointer value for in the error report pound define alec size 1000 the size of the available space static char alec buff open square bracket alex size close square bracket semicolon static chair char star alec p equals alec buff next free position initialized to the start of the array char star alec open paren and close paren return a pointer to n characters int n semicolon open curly brace if alec cp plus n less than or equal to alec buff plus alec size close paren open curly brace meaning we have space alex cp plus equals n return alex cp minus n close parenthesis semicolon close curly brace else if there's not enough room return open paren null close paren semicolon close curly brace free open paren p close print this function will free the storage pointed to by p char star p open curly brace if open paren p greater than equal to alec buff and p less than alec buff plus alex size alex cp equals p close curly brace some explanations in general a pointer can be initialized just as any other variable can though normally only meaningful values are null discussed below or an expression involving the address of a previously defined data of the appropriate type the declaration static char star alex cp equals alec buff defines alex cp to be a character pointer and initializes it to point to alec buff which is the next free position when the program starts this could also have been written static char stala star alex cp equals ampersand alec buff subzero semicolon since the array name is the address of the zeroth element whichever is more natural the test if open paren alec p plus n less than or equal to alec buff plus alex size checks if there's enough room to satisfy a request for n characters if there is the new value of alec p would be at most one beyond the end of alec buff if the request can be satisfied alec returns a normal pointer notice the declaration of the function itself if not alec must return some kind of signal that there's no space left c guarantees that no pointer that validly points to data will ever contain a zero so a return value of zero can be used to signal an abnormal event in this case no space we write null instead of zero however to indicate more clearly that this is a special value for a pointer in general integers cannot be meaningfully assigned to pointers but zero is a special case tests like if open for n alec p plus n less than or equal to alec buff plus alex size and if open paren p greater than or equal to alec buff and p less than alec buff plus alex size shows several important facets of pointer arithmetic first pointers may be compared on certain circumstances if p and q point to members of the same array then relations like less than greater than equal etc work properly p greater than q is true for example if p points to an earlier member of the array than q the relations double equals and not equals exclamation equals also work any pointer can be meaningly compared for equality or inequality with null but all bets are off if you do arithmetic or compu comparisons with pointers that point to different arrays if you're lucky you get obvious nonsense on all machines if you're unlucky your code will work on one machine but collapse mysteriously on another second we've already observed that a pointer and an integer can be added or subtracted the construction p plus n means the nth object beyond the one p currently points to this is true regardless of the kind of object p is declared to point at the compiler scales n according to the size of the objects p points to which is determined by the declaration of p for example on the pdp 11 the factors are one for char two for int and short and four for long float and dub and float and eight for double pointer subtraction is also valid if p and q point to members of the same array p minus q is the number of elements between p and q this fact can be used to write yet another version of sterlin sterling open for n s close paren char star s semicolon open curly brace char star p equals s semicolon while star p not equal backslash a single quote backslash zero single quote close paren p plus plus semicolon return open print p minus s close paren semicolon close curly brace in its declaration p is initialized s that is to point to the first character in the while loop each character in turn is examined until backslash zero at the end is seen since backslash zero is zero and since while tests only whether the expression is zero it is possible to omit the explicit test and such loops are often written as while open paren star p close paren p plus plus semicolon because p points to characters p plus plus advances p up to the next character each time and p minus f's gives the number of characters advanced over that is the string length pointer arithmetic is consistent if we'd been dealing with floats which occupying more storage than chars and if p were a pointer to a float p plus plus would advance to the next float thus we could write another version of alec which maintains say floats instead of chars merely by changing char to float throughout alec and free all the pointer manipulations automatically take into the account the size of the object pointed to so nothing else has to be altered other than the operations mentioned here adding or subtracting a pointer in an integer subtracting or comparing two pointers all other pointer arithmetic is illegal it is not permitted to add two pointers or to multiply or divide or shift or mask them or add float or double to them section 5.5 character pointers and functions a string constant written as double quote i am a string double quote is an array of characters in the internal representation the compiler terminates the array with the character backslash zero so programs can find the end the length in storage is thus one more than the number of characters between the double quotes perhaps the most common occurrence of a string constant is arguments to functions as in printf open paren double quote hello comma world backslash n double quote when a character string appears like this in a program access to it is through a character pointer what printf receives is a pointer to the character array character arrays of course need not be function arguments if message is declared as char star message then the statement message equals double quote now is the time double quote semicolon assigns message to a pointer to the actual characters this is not a string copy only pointers are involved c does not provide any operators for processing an entire string of characters as a unit in the language we will illustrate more aspects of pointers and arrays by studying two useful functions from the standard i o library to be discussed in chapter 7. the first function is stir copy open paren s comma t which copies the string t to the string s the arguments are written in this order by analogy to assignment where one would say s equals t to assign t to s the array version is first stir copy open paren s comma t close paren char s open square bracket close square bracket comma t open square bracket close square bracket semicolon open curly brace int i semicolon i equals zero semicolon while open paren open for n s sub i equals t sub i close paren not equal quote backslash 0 quote close parenthesis i plus plus semicolon close curly brace you'll note in that while statement that there is a copying of the actual characters as an assignment and then the side effect of the result of that assignment is compared to the new line at the end of string which terminates the while loop for contrast here is a version of stir copy with pointers and this is on page 100 of the textbook and you can see all the code in the textbook at www.cc4e code and again this is example number two on page 100. stir copy open paren s comma t close paren char star s comma star t semicolon open curly brace while open paren open paren star s equals star t close prin not equal single quote backslash zero single quote close print open curly brace s plus plus comma semicolon t plus plus semicolon close curly brace close curly brace to end the function because the arguments are passed by value stir copy can use s and t in any way it pleases here they are conveniently initialized pointers which are marched along the arrays a character at a time until the backslash terminates then t has been copied to s in practice their copy would not be written as we showed above a second possibility might be and this is the third example on page 100 of the textbook stir copy open vern s comma t close paren char star s comma star t semicolon open curly brace while paren paren star s plus plus equals star t plus plus close prin not equal quote backslash zero quote close paren semicolon curly brace this moves the increment and s and t into the test part the value of star t plus plus is the character that t pointed to before t was incremented the post fix plus plus doesn't change t until after this character has been fetched in the same way the character is stored in the old position of s before s is incremented the character is also the value that is compared against backslash zero to control the loop the net effect is that the characters are copied from t to s up to and including the terminating backslash zero as the final abbreviation of this solving this problem we can observe that the comparison against backslash zero is redundant so the function is often written as and now this is the first sample code on page 101 of the textbook stir copy open paren s comma t close paren char star s comma star t semicolon open curly brace while open paren star s plus plus equals star t plus plus closed paren semicolon curly brace although this may seem cryptic at first the notational convenience is considerable and the idiom should be mastered if for no other reason then you will see it frequently in c programs the second routine is stir comp open for n s comma t which compares the character strings s and t and returns negative zero or positive according to as s is lexigraphically less than equal to or greater than t the value returned is obtained by subtracting the characters at the first position where s and t disagree this is the second example on page 101 of the textbook which you can see at www.cc4e.com code stir comp open paren s comma t close parent char s open square bracket close square square bracket comma t open square bracket close square bracket semicolon open curly brace int i semicolon i equals zero semicolon while s sub i double equals t sub i close paren open print s sub i plus plus double equals single quote backslash zero single quote close paren return zero return open paren s sub i minus t sub i close paren semicolon close curly brace the pointer version of stir comb is the first example on page 102 of the textbook stir comp open paren s comma t close paren char star s comma star t open curly brace 4 open paren semicolon star s double equals star t semicolon s plus plus comma t plus plus close paren if open for n star s equal equal single quote backslash zero single quote close paren return open print 0 close paren return open print star s minus star t close paren semicolon close curly brace since plus plus and minus minus are either prefix or postfix operators the combination of star and plus plus and minus minus occur although less frequently for example star plus plus p increments p before fetching the character that p points to star minus minus p decrements p first section 5.6 pointers are not integers you may notice in older c programs a rather cavalier attitude towards copying pointers it has generally been true that on most machines a pointer may be assigned to an integer and back again without changing it no scaling or conversion takes place and no bits are lost regrettably this has led to the taking of liberties with routines that return pointers which are then merely passed to other routines the requisite pointer declarations are often left out for example consider the function stir save open paren s close paren which copies the string s into a safe place obtained by a call to alec and returns a pointer to it properly this should be written as this is the first example on page 103 of the textbook you can see the sample code at www.ccfree.com code pound include stdlib.h char star serv stir save open print s close paren save a string somewhere char star s semicolon open curly brace char star p star alec open paren close paren semicolon if open paren open paren p equals alec open paren sterling open paren s close paren plus one close paren close print not equal null close paren stir copy open paren p comma s close paren semicolon return open paren p close paren semicolon curly brace in practice there would be a strong tendency mistaken tendency that is to emit declarations this is the example 2 on page 103 pound include stdlib dot h stir save open paren s close paren open curly brace char star p semicolon if parentheses parentheses p equals alec open paren sterlin open paren s close print plus one close print close print not equal no close paren stir copy open paren p comma s close paren semicolon return open paren p close print semicolon this will work on many machines since the default type for functions and arguments is int an int and pointer can usually be safely assigned back and forth nonetheless this kind of code is inherently risky for it depends on the details of the implementation and machine architecture which may not hold for the particular compiler you use it is wiser to be complete in all declarations the program lind will warn of such constructions in case they creep in inadvertently section 5.7 multidimensional arrays in general rectangular multidimensional arrays are used in computational programs like a weather simulation and were a way back in the day to write c code that could accept fortran multidimensional arrays as parameters so that computational or statistical libraries can be written in c arrays of pointers are a better mapping to the typical operating system in string manipulation use cases that are more the core of c applications we also call these ragged arrays because each row can be a different length this also works well as data is dynamically allocated in c as compared to the more static allocation approach that's typical in fortran's multidimensional arrays now to the textbook c provides for rectangular multidimensional arrays although in practice they tend to be much less used than the arrays of pointers in this section we will show some of their properties consider the problem of date conversion from the day of the month to the day of the year and vice versa for example march 1st is the 60th day of a nonleap year and 60 first day of a leap year let us define two functions to do the conversions day of year converts month and day to the day of the year and month day converts the day of the year into the month and the day since this ladder function returns two values the month and day arguments will be pointers month day open parenthesis 1977 comma 60 ampersand m comma ampersand d close parentheses sets m to three and d to one which is march first these functions both need the same information a table of the number of days in each month 30 days half september et cetera since the number of days per month differs for leap years and nonleap years it's easier to separate them into two rows of a twodimensional array rather than try to keep track of what happens in february during computation the array and the functions performing the transformations are as follows this is example number one on page 104 of the textbook and you can see the code at www.cc4e.com code static int day tab open paren to close print open paren 13 close print equals open curly brace open curly brace 0 comma 31 and then a number of numbers close curly brace comma open curly brace 0 comma 31 29 and then a bunch of numbers close curly brace close curly brace semicolon day of the year open paren year come a month come a day int year come a month comedy semicolon open curly brace int i comma leap semicolon leap equals 0 year modulo 4 double equals 0 and year modulo 100 not equal 0 or year modulo 400 equals equals 0 semicolon for open paren i equals one i less than month i plus plus close paren day plus equals day tab open square bracket leap close square bracket open square bracket i close square bracket semicolon return open paren day close paren semicolon close curly brace then the month day function month day open paren year come a year day come a p month come a p day close paren int year come a year day star p month comma star p day semicolon open curly brace int i come a leap semicolon leap equals year percent four double equals zero and year percent 100 not equal zero or year percent 1400 double equals zero for i equals one year day greater than date tab open square bracket leap close square bracket open square bracket i close square bracket semicolon i plus plus close parenthesis your day minus equal day tab open square parenthesis open square bracket leap close square bracket open square bracket i close square bracket semicolon star p month equals i p day equals year day semicolon close paren the array day tab has to be external to both day of year and month day so they can both use it date tab is the first two dimensional array we've dealt with in c by definition a twodimensional array is really a onedimensional array each of which elements is also an array hence subscripts are written as day tab open square bracket i close square bracket open square bracket j close square bracket rather than day tab open square bracket i comma j close square bracket as in most languages other than this a twodimensional array can be treated much the same in the same way as other languages elements are stored by rows that is the rightmost subscript varies fastest as elements are accessed in storage order an array is initialized by list of initializers and braces each row of a twodimensional array is initialized by a corresponding sublist we started the array day tab with a column of 0 so that month numbers can run from the natural 1 to 12 instead of 0 to 11. since space is not a premium here this is easier than adjusting indices if a 2 dimensional array is to be passed to a function the argument definition declaration in the function must include the column dimension the row dimension is irrelevant since what is passed in as before it is a pointer this is in this particular case it's a pointer to objects which are arrays of 13 ins thus the array day tab if it's to be passed to a function f the declaration would be f open friend date tab close paren int day tab open square bracket 2 close square bracket open square bracket 13 close square bracket semicolon open curly brace dot dot dot close curly brace the argument declaration in f could also be int date tab open square bracket close square bracket open square bracket 13 closed square bracket semicolon since the number of rows is actually irrelevant it could also be seen as int open print star day tab close print open bracket 13 closed bracket semicolon which says that the argument is a pointer to an array of 13 integers the parentheses are necessary since the brackets have higher precedence than asterisk without parentheses the declaration int star day tab sub 13 close square bracket semicolon is an array of 13 pointers to integers as we shall see in the next section section 5.8 pointer arrays pointers to pointers since pointers are variables themselves you might expect that there would be uses for arrays of pointers this is indeed the case let us illustrate by writing a program that will sort a set of text lines into alphabetic order than a strippeddown version of the unix utility sort in chapter three we presented a shell sort function that would sort an array of integers this same algorithm will work except that now we have to deal with lines of text which are of different lengths and which unlike integers can't be compared or moved in a single operation we will need a data representation data structure that will cope efficiently and conveniently with variable length text lines this is where an array of pointers enters if the lines to be sorted are stored and in one long character array maintained by alec perhaps then each line can be accessed by a pointer to its first character the pointers themselves can be stored in an array two lines can be compared by passing their pointers to stir comp when two out of order lines have to be swapped or exchanged the pointers in the pointer array are exchanged not the text lines themselves this eliminates the twin problems of complex storage management and high overhead that would go with moving the text of the actual lines the sorting process involves three steps read all the lines of input sort them and then print them in order as usual it's best to divide the program into functions that match this natural division with the main routine controlling things let us defer the sorting step for a moment and concentrate on the data structures and the input in output the input routine has to collect and save the characters in each line and build an array of pointers to the lines it will also have to count the number of input lines since that information is also needed for sorting and printing since the input function can only cope with a finite number of input lines it can return some illegal line count like negative 1 if too much input is presented the output routine only has to print the lines in order in the order in which they appear in the array of pointers this next code segment is actually a combination of three successive sample code segments uh starting on page 106 of the textbook and it's pretty complex so you might be best it might be best for you to see them on www.cc4e.com slash code line 106 example one okay pound include stdio.h pound includes string.h pound define lines 100. the maximum lines of support to be sorted main open paren close paren char line ptr open brick ombud square bracket lines close square bracket semicolon int n lines which is the number of lines read if open paren open paren n lines equals read lines open paren line ptr comma lines close praying close paren greater than or equal to zero close paren open curly brace sort open paren line ptr comma n lines close paren write lines open print line ptr comma n lines close paren semicolon close curly brace else print f open paren double quote input too big to sort backslash n close double quote close paren semicolon and close curly brace to end the main program this next routine is actually from page 107 of the textbook but we combined them into one pound defined maxland1000 readlines openpren line ptr comma max lines close paren char star line ptr open square bracket close for a square bracket semicolon this is an array of pointers to characters an array of pointers pointers being you know long like four bytes characters being generally one byte int max line semicolon open curly brace int len comma n lines semicolon char star p star alec open print close paren comma line open square bracket max lane close square bracket semicolon so just to recall alec is a function we do we did later i mean did earlier that allows us to allocate uh some text of a varying length and then lines so maxlen is a place that we're going to read each line into beginning the code of read lines n lines equals zero while open paren open paren len equals get line open paren line comma max len close paren close friend greater than or equal to zero close paren if open print n lines greater than equal to max lines close paren return open paren minus one close paren semicolon else if open print open paren p equals alec open paren len close paren close paren double equals null close paren return minus one so those two tests basically make sure that we don't get too many lines and that we have enough space in our al dynamic data area that alec is managing for us so continuing with the if we're at the else opens curly brace line sub len minus one equals quote backslash zero quote semicolon stir copy p comma line close paren semicolon line ptr sub n lines plus plus equals p semicolon close curly brace that finishes the else segment return n lines semicolon and close curly brace to finish the read lines function now at a high level we're reading a line into a allocated automatic variable line and then we are calling alec to get another cop place to copy that line then we're making a copy of that line and then we are remembering the pointer to the beginning of that line in line ptr and that's the essence of it okay write lines open paren line ptr comma n lines close paren char star line ptr open square bracket close square bracket semicolon again an array of pointer characters int n lines semicolon which is the number of character pointers in line ptr open curly brace int i semicolon four paren i equals zero semicolon i less than n lines semicolon i plus plus close paren printf open paren double quote percent s backslash n double quote comma line ptr sub i close paren semicolon close curly brace a simple loop that goes through the array of character pointers and then prints each one out using printf the main new thing is the declaration for line ptr char starline ptr sub open square bracket lines close square bracket semicolon says that line ptr is an array of lines elements each element of which is a pointer to a char that is line ptr sub i is a character pointer and star line pr ptr sub i accesses a character since line ptr itself is an array that was passed to right lines it can be treated as a pointer exactly in the same manner as our earlier examples and the function can be written instead as right lines open paren line ptr comma n lines close paren char starline ptr open square bracket close square bracket semicolon int and line semicolon open curly brace while open paren minus minus n lines greater than or equal to zero close paren printf open paren double quote percent s backslash n double quote comma star line ptr plus plus close paren semicolon that code by the way was on page 108 example one of the textbook starline ptr points initially to the first line but each increment of line ptr advances it to the next line while n lines is counted down with input and output under control we can proceed to sorting the shell sort from chapter 3 needs minor changes the declarations have to be modified and the comparison operation must be moved into a function but the basic algorithm remains the same which gives us some confidence that it will still work and this is the second example on page 108 of the textbook and you can see this example at www.cc4e.com code start sort open paren v comma n close paren char star v open square bracket close square bracket semicolon and and semicolon open curly brace so we're getting an array of pointers to the beginnings of lines and how many of those pointers matter and the rest of it is shell sort with the stir comp being used to do the string comparison so it's a three nested for loop with a simple if test in it so here we go open curly brace for the sort function int gap comma i comma j semicolon char star semicolon and that's a pointer to a character four open paren gap equals n over two slash i mean semicolon gap greater than zero semicolon gap slash equals two close parenthesis 4 i equals gap semicolon i less than n semicolon i plus plus close parenthesis for open paren j equals i minus gap semicolon j greater than or equal to zero semicolon j minus equals gap close paren open curly brace so that's sort of the shell part of the shell sort and now we have to do our comparison if open paren stir comp open print v sub j comma v sub j plus gap close paren less than or equal to zero close paren break and note that that's only breaking the third deep for loop which it just goes and then runs the next iteration of the second for loop now we do the swapping temp equals b sub j semicolon v sub j equals a v sub j plus gap semicolon v sub j plus gap equals temp now that's just swapping pointer values so the the strings that are pointed to by these two pointers v sub j and v sub j plus gap if they're out of order we're going to swap the pointers in the array and move them so that if you then go through like we did in write lines earlier then um they come out in order but we literally read the data once we copy it once into the its final destination using alec alec and stir copy but once we sort it which is the most complex part of the calculation we're only moving the pointers back and forth so the sort is very efficient and requires no extra memory than what we had before the sort so that's really nice and it sorts in place so back to the text since any individual element of v which is an alias to line pointer ptr is a character pointer temp could also should also be one so one can be copied to the other we wrote the program about as straightforwardly as possible so as to get it working quickly it might be faster for instance to copy the incoming lines directly into an array made by read lines rather than copying them into line and then to a hidden place maintained by alec but it's wiser to make the first draft of something easy to understand and worry about efficiency later the way to make this program significantly faster is probably not by avoiding an unnecessary copy of the input lines just instead replacing the shell store sort by something quicker and better like quick sort is much more likely to make a real difference that matters in chapter one we pointed out that because while in for loops test the termination condition before executing the loop body even once they help to ensure that the programs will work at their boundaries in particular with no input it's illuminating to walk through the functions of the sorting program checking what happens if there is no input text at all section 5.9 initialization of pointer arrays consider the problem of writing a function month name open paren and close paren which returns a pointer to a character string containing the name of the mf month this is an ideal application for an internal static array month name contains a private array of character strings and returns a pointer to the proper one when called the topic of this section is how that array of names is initialized the syntax is quite similar to the previous initializations this is sample code from page 109 of the textbook which you can see at www.cc4e.com code char star month name open paren close print so the return value for this function is a character pointer int n semicolon open curly brace static char star name open square bracket close square bracket equals open curly brace quote illegal month quote comma double quote january double quote comma double quote february double quote comma and so forth down to double quote december double quote close curly brace semicolon the body of the function is one line return open paren open paren n less than 1 or n greater than 12 close paren question mark name sub 0 colon name sub n close paren semicolon close curly brace the declaration of name which is an array of character pointers is the same as line ptr in the sorting example the initializer is simply a list of character strings each assigned to the corresponding position in the array more precisely the characters of the i string are placed somewhere else and a pointer to them is stored in name sub i since the name size of the array name is not specified the compiler itself counts the initializers and fills in the correct number section 5.10 pointers versus multidimensional arrays newcomers to see are sometimes confused about the difference between a twodimensional array and an array of pointers such as name in the example above given the declarations int a open square bracket 10 close square bracket open square bracket 10 close square bracket semicolon and int star b open square bracket 10 close square bracket semicolon the usage of a and b may be similar in that a sub 5 5 and b sub 5 5 are both legal references to a single integer but a is a true array all 100 storage cells have been allocated and the conventional rectangular substrip calculation is done to find any given element for b however the declaration only allocates 10 pointers each must be set to point to an array of integers assuming that each does point to a 10 element array then there will be 100 storage cells set aside plus the 10 cells for the pointers thus the array of pointers uses slightly more space and may require an explicit initialization step but it has two advantages accessing an element is done by indirection through a pointer rather than by a multiplication and an addition and the rows of the array may be of different lengths that is each element of b need not point to a 10 element vector some may point to two elements others may point to 20 and some to none at all although we have phrased this discussion in terms of integers by far the most frequent use of arrays of pointers is like that shown in month name to store character strings of a diverse lengths section 5.11 command line arguments in environments that support c there is a way to pass command line arguments or parameters to a program when it begins executing when main is called to begin execution it is called with two arguments the first conventionally called arg c is the number of command line arguments the program was invoked with the second arg v is a pointer to an array of character strings that contain the arguments one per string manipulating these character strings is a common use of multiple levels of pointers i would note that back in 1978 the two largest bodies of c code were likely the at t unix kernel itself and unix utilities like grep ls or the login shell so writing an operating system was fresh on the mind of the authors while writing this book these topics find their way into the text of this book in a sense a likely second order goal of the book was to train programmers that might learn c and then might help build and maintain unix the 1978 edition of this textbook fits nicely into a series of att bell labs technic reports like the portability of c programs in the unix system written by stephen c johnson and dennis m ritchie published in the bell system technical journal volume 57 number six part two july through august 1978 pages 2021 through 2048. you can see this one online if you search for it back to the textbook the simplest illustration of the necessary declarations and use is in the program echo which simply echoes its command line arguments in a single line separated by blanks that is if the command echo hello comma world is given the output is hello comma world by convention arg v sub 0 is the name by which the program was invoked so argc is at least 1. in the above example argc is three and args arc v sub zero arc v sub one and args v sub two are echo hello comma and world respectively the first real argument is arc v sub 1 and the last is arg v sub rxc minus 1 and if argc is 1 there are no command line arguments after the program name this is shown in the source code to echo and this source code is on page 111 of the textbook and you can see this source code at www.cc4e.com code pound include stdio.h pound includes string.h main open paren argc comma arc fee close paren int argc semicolon char star argv open square bracket close square bracket semicolon open curly brace int i semicolon for open paren i equals one semicolon i less than rxc semicolon i plus plus close paren print f open paren double quote percent s percent c double quote comma arg v sub i comma open paren i less than r c minus one close paren question mark single quote space single quote colon single quotes backslash n single quote close parenthesis semicolon close curly brace to end it since argv is a pointer to an array of pointers there are several ways to write this program that involve manipulating the pointer rather than indexing an array let us show two variations and this is the example number two on page 111 of the textbook pawn include stdio.h pawn includes string.h main open paren rxc comma argv close paren int argc semicolon char star argv open square bracket close square bracket semicolon open curly brace while open paren minus minus arg c greater than zero close paren printf open paren double quote percent s percent c double quote comma star plus plus arg v comma open paren rxc greater than one close paren question mark single quote space single quote colon single quote backslash n single quote close paren semicolon close curly brace since arc v is a pointer to the beginning of an array of argument strings incrementing it by one plus plus rv makes it point to the at the original array arc v sub one instead of arc b sub zero each successive increment moves it along to the next argument star arc v is then the pointer to that argument at the same time argc is decremented and when it becomes zero there are no arguments left to print another version the third version on page 111 of the textbook pound include stdio.h pound includes string.h main open paren arg c com argv close paren int argc semicolon char star arc v open square bracket close square bracket semicolon open curly brace while open paren minus minus arg c greater than zero close paren print f open paren open paren argc greater than one close paren question mark double quote percent s blank double quote colon double quote percent s backslash n double quote comma star plus plus arg v close paren semicolon close curly brace this version so shows that the format argument of printf can be an expression just like any of the others this usage is not very frequent but worth remembering as a second example let's make some example enhancements to the pattern finding program from chapter 4. if you recall we wired the search pattern deep into the program and this is an obviously unsatisfactory arrangement for flexible code following the lead of the unix utility grep which stands for the generalized regular expression parser let us change the program so that the pattern to be matched is specified by the first argument on the command line this is example one on page 112 of the book which you can see at www.cc4e.com code pound include sddio.h pound includes string.h upon define max line 1000 main open paren arg c comma arg v close paren int r c semicolon char star arc v open square bracket close square bracket semicolon open curly brace char line open open square bracket max line close square bracket semicolon if open paren argc not equal to close paren printf double quote usage colon find pattern backslash n double quote close paren semicolon else while open pren getline open print line comma max line close paren greater than zero close paren if index open paren line comma arg v sub 1 close paren greater than or equal to 0 close paren printf open paren double quote percent s double quote comma line close paren semicolon close curly brace the basic model can now be elaborated to illustrate further pointer constructions suppose we want to allow two optional arguments one says print all the lines except those that match the pattern the second says precede its print each printed line with its line number a common convention for c programs is that an argument beginning with a minus sign introduces an optional flag or parameter if we choose minus x for accept to signal the inversion and minus n number to request line numbering then the command find space minus x space minus n the with the input now is the time for all good men to come to the aid of their party should produce two comma for all good men optional arguments should be permitted in any order and the rest of the program should be insensitive to the number of arguments which were actually present in particular the call to index should not refer to arg v sub 2 where a single flag argument and to arc v sub 1 when there was no single flag furthermore it's convenient for users if option arguments can be concatenated and as in find space dash nx space the here is the program and this program is on page 113 of the textbook and it is complex enough that i suggest that you take a look at it at www.cc4e.com code it's it's about 35 lines long the commentary on the program hopefully now you're watching looking at it arc v is incremented before each optional argument and argc is decremented if there are no errors at the end of the loop arg c should be 1 and star argv should point to the point to the pattern note that star plus plus arc v is a pointer to an argument string open paren star plus plus arc v close paren open square bracket zero square square bracket is its first character the parentheses are necessary for without them the expression would be star plus plus open paren arg v sub subzero close paren which is quite different and wrong an alternate valid form would be star star plus plus arg v section 5.12 pointers to functions in c a function itself is not a variable but it is possible to define a pointer to a function which can be manipulated passed to functions placed in arrays and so on we will illustrate this by modifying the sorting procedure written earlier in this chapter so that if the optional argument minus n is given it will sort the input lines numerically instead of lexographically a sort often consists of three parts a comparison which determines the ordering of any pair of objects an exchange which reverses their order and a sorting algorithm which makes comparisons and exchanges until the objects are in order the sorting algorithm is independent of the comparison and exchange operations so by passing different comparison and exchange functions to it we can arrange to sort by different criteria this approach is taken in our new sort the lexigraphic comparison of the two lines is done by stir comp and swapping by swap as before we'll also need a routine num comp which compares two lines on the basis of numeric value and returns the same kind of condition indication as stir comp does these three functions are declared in main and pointers to them are passed to sort sort in turn calls the functions via pointers we have skimped on error processing processing for arguments so as to concentrate on the main issues this sample code is from page 115 of the textbook which you can view at www.cc4e.com code pound include stdio.h pawn include string.h pawn defined lines 100 main open paren rxc comma arg v close current int argc semicolon char star arg fee open square bracket close square bracket semicolon open curly brace char star line ptr open for open bracket lines close square bracket semicolon this is the pointers to the text lines so we're going to be reading in the lines saving them and keeping an array of the pointer and then we're going to sort that way int n lines semicolon int stir comp open paren close print comma num comp open paren close paren which are comparison functions and swap open paren close print semicolon int numeric equals zero and this is going to be one if it's a numeric sort first we parse the arguments if open paren arg c greater than one ampersand ampersand arg v sub one sub zero equal equal quote minus quote and arg v opens bracket one close bracket open bracket one close bracket double equals quote end quote close paren numeric equals one if open paren open paren n lines equals read lines open paren line ptr comma lines close paren close paren greater than or equal to zero close paren open curly brace if open paren numeric close paren sort open print line ptr n lines num comp comma swap close paren semicolon else sort open print line ptr comma n lines comma stir comp comma swap close paren write lines line pr ptr comma n lines close paren close curly brace else print f open paren double quote input too big to sort backslash n double quote close paren semicolon stir comp num comp and swap are addresses of functions since they're known to be functions the ampersand operator is not necessary in the same way that it is not needed before an array name the compiler arranges for the address of the function to be passed the second step is to modify our sort function and this is the first example on page 116 of the textbook sort open paren v comma n comma comp comma e x c h exchange close paren char star v open square bracket close work square bracket semicolon that's our pointer array of pointers int and semicolon int open friends start comp close paren open print close paren comma open paren star exchange close paren open prayer and close paren semicolon that declared the type and the fact that these are pointers to functions it's a little more complex here in the called code open curly brace int gap comma i comma j semicolon and now we're going to do the three nested for loops for the quick sort no shell sort um and then the only really change is in the code checking to see if the uh two items pair of items are out of order and then what we do so four open paren gap equals n over two semicolon cap greater than zero semicolon graph gap slash equals two close paren for open print i equals gap semicolon i less than n semicolon i plus plus closed paren four open paren j equals i minus gap semicolon j greater than or equal to zero semicolon j minus equals gap close paren open curly brace and now here starts the different code if open print open print star comp close print open paren v sub j comma v sub j plus gap close paren less than or equal to zero close paren break open print star ex exchange close prin open print ampersand v sub j comma ampersand v sub j plus gap close paren semicolon close curly brace for the for loop and then close curly brace for the sort function and so really all we're doing is we're checking the order of the two items b sub j and b sub j plus gap and if they're out of order i.e less than or equal to zero i mean greater than or equal to uh greater than zero then we just exchange them with the provided exchange function and so the key thing here is it looks exactly like the previous time we wrote this code except we're calling the pointer to the comparison function and the pointer to the exchange function which is makes this flexible so it can handle different kinds of data back to the textbook the declaration should be studied with some care int open paren star comp close paren open paren close paren says that comp is a pointer to a function that returns an int the first set of parentheses are necessary without them int star comp open prank close paren would say that comp is a function returning a pointer to an end which is a quite different thing the use of comp in the line if open paren open paren star com close paren open print v sub j comma v sub j plus gap close print less than or equal to zero close paren is consistent with the declaration comp is a pointer to the function and star comp is the function and open paren star comp close paren open paren v sub j comma v sub j plus gap close paren is the call to it the parentheses are needed so the components are correctly associated we've only we've already shown stir comp which compares two strings here is num comp which compares two strings on a leading numeric value this is sample code from page 117 of the textbook which you can see at www.cc4e.com code numcomp open paren s1 comma s2 close paren char star s1 comma star s2 semicolon open curly brace double a to f open frame close paren comma v1 comma v2 v1 equals a to f open paren s1 close paren semicolon v2 equals a to f open print s2 close paren semicolon if open paren v1 less than v2 close print return open print 1 else if open print v1 greater than v2 close paren return open print 1 close paren semicolon else return open paren 0 close paren semicolon close curly price the final step is to add the function swap which exchanges the two pointers this is adapted directly from what we presented earlier in the chapter swap open paren px comma py close paren char star px open square bracket close square bracket comma star py open square bracket close square bracket semicolon open curly brace char star temp semicolon temp equals star px semicolon star px equals star py semicolon star py equals temp semicolon close curly brace there are a variety of other options that can be added to the sorting program some make challenging exercises this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardwarefirst vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 6 structures a structure is a collection of one or more variables possibly of different types grouped together under a single name for convenient handling while we talk about data structures and how to use them in every language this section is about understanding how software developers carefully control the low level shape of their data items to solve their problems when you first learn about the c struct keyword you might think it's equivalent to a python dict a dynamic key value store like a php array java myapp or javascript object but nothing is further from the truth these other languages provide us with easy to use data structures where all the challenging problems are solved this chapter tells or told the creators of python php java and javascript how to solve the complex problems and build convenient and flexible data structures which we now all use in those objectoriented languages one way to look at this code in this chapter is to think of it as a lesson on how one might build python's list and dict data structures if the code in the chapter takes you a little while to figure out mentally make a note of thanks for all the hard work that modern languages invest to make their high level data structures flexible and easy to use back to the textbook the traditional example of a structure is a payroll record an employee is described as a set of attributes such as name address social security number salary etc some of these in turn could be structures a name has several components as does an address and even a salary structures help organize complicated data particularly in large programs because in many situations they permit a group of related variables to be treated as a unit instead of separate entities in this chapter we'll try to illustrate how structures are used the programs that we will use are bigger than many others in the book but are still of modest size section 6.1 basics let us revisit the date conversion routines of chapter 5. a date consists of several parts such as the day month and year and perhaps the day of the year and the month name these five variables can all be placed in a single structure like this struct date open curly brace in day semicolon in month semicolon in int year semicolon and year day semicolon char mun name open square bracket for closed square bracket semicolon curly brace semicolon the keyword struct introduces a structure declaration which is a list of declarations enclosed embraces an optional name called the structure tag may follow the word struct as with date here the tag names this kind of a structure and can subsequently be used as shorthand for the detailed declaration the elements or variables mentioned in a structure are called its members a structure member or tag and ordinary ie nonmember variable can have the same name without conflict since they are always distinguished by context of course as a matter of style one would normally use the same names only for closely related objects the right brace that terminates the list of members may be followed by a list of variables just as for any basic type that is struct open curly brace dot dot dot close curly brace x comma y comma z semicolon is syntactically analogous to int x comma y comma z semicolon in the sense that each statement declares x y and z to be variables of the named type and causes space to be allocated for them a structured declaration that is not followed by a list of variables allocates no storage it merely describes a template or the shape of the structure if the declaration is tagged however the tag can be used in later definitions of the actual instances of the structure for example given the declaration of date above struct date d defines a variable d which is a structure of type date an external or static structure can be initialized by the following by following its definition with a list of initializers for the components struct date d equals open curly brace 14 comma 7 comma 1776 comma 186 comma double quote j u l double quote close curly brace semicolon a member of a particular structure is referred to in an expression by construction of the form structure name dot member the structure member operator dot connects the structure name in the member name to set leap from the date in structure d for example leap equals d dot year modulo four double equals zero and d dot year modulo 100 not equal to zero or d dot year modulo 400 double equal zero semicolon or to check the month name if open paren stir comp open paren d dot mun name comma double quote aug double quote close paren double equals zero close paren dot dot or to convert the first character of the month named lower case d dot mon name sub zero equals lower open paren d dot name sub zero close paren semicolon structures may be nested a payroll record might actually look like struct person open curly brace char name open square bracket name size close square bracket semicolon char address open square bracket adder size close square bracket semicolon long zip code semicolon long ss number semicolon double salary struct date birth date semicolon struct date hire date semicolon close curly brace semicolon the person structure contains two dates if we declare emp as struct person amp semicolon then emp.birthdate.month refers to the month of birth the structure member operator dot associates left to right section 6.2 structures and functions there are a number of restrictions on c structures the essential rules are that only operations you can perform on a structure are to take its address with ampersand and access one of its members this implies that structures may not be assigned or copied to as a unit and that they cannot be passed or returned from functions these restrictions will be removed in forthcoming versions furnace destructures do not suffer these limitations however so structures and functions do work together comfortably finally automatic structures like automatic arrays cannot be initialized only external or static structures can this prediction was indeed accurate modern c compilers do support the copying of a structure with a single assignment statement given that a c structure is just a fixed length block of memory it's easy easy to generate machine code to copy it a key bit to remember that when the c structure is copied it is done as a shallow copy a shallow copy copies the values of the variables and the pointers in the structure but does not make copies of any data which the pointers point to a structure that contains other structures i.e not pointers to structures and those structures are shallow copied as well back to the text let us investigate some of these points by rewriting the date conversion functions in the last chapter to use structures since the rules prohibit passing of a structure to a function directly we must either pass the component separately or pass a pointer to the whole thing the first alternative uses of de avere which as we wrote in chapter 5 d year day equals day of year open for n d year comma d dot month comma d dot day close paren semicolon the other way is to pass a pointer if we've declared higher date as struct date higher date semicolon and rewritten day of year we could then say higherdate.year day equals day of year open paren ampersand higher date close paren semicolon to pass a pointer to higher date to day of year the function has to be modified because its argument is now a pointer rather than a list of variables this example code is on page 122 of the textbook and you can see it at www.cc4e.com code struct date open curly brace int day semicolon int month semicolon in ear semicolon int year day semicolon and mun name open square bracket four close spread square bracket semicolon closed curly brace semicolon static int day tab open square bracket two close square bracket open square bracket 13 close square bracket equals open curly brace open curly brace zero come at 31 come at 28 come a 31 come a 30 come at 31 come with 30 come a 31 31 come a 30 come a 31 come a 30 31 close curly brace comma and then another list just as long as that co with a closed curly brace and a semicolon that just initialized the lookup table for the days in each month now on to the function day of year open paren pd close paren struct date star pd semicolon open curly brace and i come a day come a leap semicolon day equals pd minus greater than day semicolon leap equals pd minus greater than year percent for double equals zero and pd minus greater than year percent 100 not equal to zero or pd minus greater than year percent 400 double equal zero semicolon four open paren i equals one semicolon i less than pd minus greater than month semicolon i plus plus close paren day plus equals day tab open square bracket leap close square bracket open square bracket i close square bracket semicolon return open paren day close paren semicolon close curly brace the declaration struct date star pd says that pd is a pointer to a structure of type date the notion exemplified by pd minus greater than year i think i'll call that at this point pd right arrow because that's really what it is it's the minus greater than looks like an arrow to the right so i'm going to call it right arrow but it's really two characters pd right arrow year is new if p is a pointer to a structure then pd right arrow member of structure refers to the particular member the operator right arrow is a minus sign followed by a greater than since pd points to the structure the year member could also be referenced as open paren star pd closed paren dot ear but pointers to structures are so frequently used that the right arrow notation is provided both as a convenient shorthand the parentheses are necessary in open paren star pd close paren dot ear because the precedence of the structure member operator dot is higher than the pointer lookup operator asterisk both right arrow and dot associate to left from left to right so p right arrow q right arrow mem and emp dot birthdate dot month r open paren p right arrow q close paren right arrow mem and open parent emp dot birth date close paren dot month for completeness here is the other function month day rewritten to use the structure this is the first example on page 123 of the text which you can look at the source code at www.cc4e.com code i won't read the struct and the date the destruct date definition in the struct in static in day tab definition we'll just go month day month day open paren pd close paren struct date star pd semicolon open curly brace end i comma leap semicolon leap equals pd right arrow year percent four double equals zero and pd right arrow year percent 100 not equal to zero or pd right arrow year percent 400 double equals 0 semicolon pd right arrow day equals pd right arrow year day four open print i equals one semicolon pd right arrow day greater than day tab subleap sub i semicolon i plus plus close paren pd right arrow day minus equals day tab subleap sub i semicolon pd right arrow month equals i semicolon close curly brace the structure operators right arrow and dot together with parentheses for argument lists and square brackets for subscripts are the top of the precedence hierarchy and then thus bind very tightly for example given the declaration struct open curly brace int x int star y semicolon close curly brace star p semicolon then plus plus p right arrow x increments x not p because the implied parenthesization is plus plus open paren p right arrow x close paren parentheses can be used after the binding open paren plus plus p right arrow x increments p before accessing x and open paren p plus plus close paren right arrow x increments p afterward the last set of parentheses is unnecessary in the same way star p right arrow y fetches whatever y points to star p right arrow y plus plus increments y after what after accessing whatever it points to just like star s plus plus open paren star p right arrow y close paren plus plus increments whatever y points to and star p plus plus right arrow y increments p after accessing whatever y points to section 6.3 arrays of structures structures are especially suitable for managing arrays of related variables for instance consider a program to count the occurrences of each c keyword we need an array of character strings to hold the names and an array of integers to hold the counts one possibility is to use two parallel arrays keyword and key count as in char star keyword open square bracket n keys close square bracket semicolon int key count open square bracket n keys close square bracket semicolon but the very fact that the arrays are parallel indicates a different organization is possible each keyword entry is really a pair char star keyword semicolon int key count semicolon and there's an array of the pairs the structure declaration struct key open curly brace char star keyword semicolon int key count semicolon close curly brace key tab open square bracket n keys close square bracket semicolon defines an array key tab of structures of this type and allocate storage to them each element of the array is a structure this could also be written struct key open curly brace char star keyword semicolon int key count semicolon close curly brace semicolon struct key key tab open square bracket and keys close square bracket semicolon since the structure key tab actually contains a constant set of names it's easiest to initialize it once and for all when it's defined the structural initialization is quite analogous to the earlier ones the definition is followed by a list of initializers and closed embraces struct key open curly brace char star keyword semicolon int key count semicolon close curly brace key tab open square bracket close square bracket equals open curly brace double quote break comma 0 comma double quote case comma 0 comma double quote char comma 0 comma and so forth down to double quote unsigned double quote comma 0 comma double quote while double quote comma 0 closed curly brace semicolon these initializers are listed in pairs corresponding to the structure members it would be more precise to enclose initializers for each row or structure in the braces as in open curly brace double quote break double quote comma zero close curly brace comma open curly brace double quote case double quote comma zero close curly brace comma and so forth but the inner braces are not necessarily when the initializers are simple variables or character strings and when all are present as usual the compiler will compute the number of entries in the array key tab if the initializer is present and the open square bracket close square bracket is left empty the keyword counting program which begins with a definition of key tab the main routine reads the input repeatedly by calling a function get word that fetches input one word at a time each word is looked up in key tab with a version of binary the binary search function we wrote in chapter three of course the list of keywords has to be given in increasing order for this to work here is the first example on page 125 of the textbook you can see this at www.cc4e.com code pound include stdio.h pound define max word 20 pound defined letter quote a quote main open prem close paren open curly brace int n comma t semicolon char word open square bracket max word close square bracket semicolon while open paren open print t equals get word open paren word comma max word close paren close paren not equal eof close paren if open friend t double equal letter close paren if double open paren open paren n equals binary open paren word come a key tab comma n keys close paren close paren greater than or equal to zero close paren key tab sub n dot key count plus plus four open paren n equals zero semicolon and less than n keys semicolon and plus plus if open open paren key tab sub n dot key count greater than zero close paren print f double quote percent for d space percent s backslash n double quote comma key tab sub n dot key count comma key tab sub n dot keyword close paren semicolon and then a closed curly brace to finish main binary to find the word in the in the table binary open paren word comma tab comma n close paren char star word semicolon struct key tab open square bracket close work square bracket semicolon int n open curly brace int low comma high comma mid comma cond low equals zero semicolon high equals n minus one semicolon while open paren low less than or equal to high close paren open curly brace mid equals paren low plus high close paren over to semicolon if open paren open paren conned equals stir comp open paren word comma tab comma open square bracket mid close square bracket dot keyword close print close friend less than zero close paren hi equals mid minus one semicolon else if open paren con greater than zero close paren low equals mid plus one semicolon else return open paren mid close paren semicolon close curly brace to finish the while and then return open paren minus one close paren semicolon close curly brace and that's really a rewrite of the binary function from the earlier part where we're just taking the keyword and count and and look in and looking up in the array but then using the dot keyword to find the actual keyword back to the text we'll show function get word in a moment for now it suffices to say it returns letter each time it finds a word and copies the word into its first argument the quantity n keys is the number of keywords in key tab although we could count this by hand it's a lot easier and safer to do it by machine especially if the list is subject to change one possibility would be to terminate the list of initializers with a null pointer and then the loop along key tab just runs until the end is found but this is more than as needed since the size of the array is completely determined at compile time the number of entries is just the size of key tab divided by the size of the struct key c provides a compile time op unary operator called sizeof which can be used to compute the size of any object the expression size of open paren object close paren yields an integer equal to the size of the specified object the size is given in unspecified units called bytes which are the same size as a char closed paren the object can be an actual variable or an array or structure or the name of a basic type like int or double or the name of a derived type like a structure in our case the number of keywords is the array size divided by the size of one array element and this computation is used in a pound define statement to set the value of n keys pound define n keys open paren size of open or print key tab close print divided by size of open paren struct key close paren close paren now for the function get word we have actually written a more general get word than is necessary for this program but it is not really much more complicated get word returns the next word from the input where a word is either a string or of letters or digits beginning with a letter or a single character the type of the object that is is the returned function as a function value it is the letter if the token is a word eof render file or the character itself if it's nonalphabetic this sample code is on page 127 of the textbook which you can see at www.cc4e.com code pound define letter quote a quote pound defined digit quote zero quote get word open paren w comma limb close paren char star w colon semicolon int lim semicolon open curly brace int c comma t semicolon if open paren type open paren c equals star w plus plus equals get ch open paren close paren close paren not equal letter close print open curly brace start w equals quote backslash zero quote semicolon return open for nc close paren semicolon close curly brace that if statement has got some stuff going on in it you might want to look at it very closely while open paren minus minus limb greater than zero close paren open curly brace t equals type open friend c equals star w plus plus equals get ch open paren close paren close point semicolon if if open friend t not equal letter and t not equal digit close paren open curly brace unget ch open paren c close paren semicolon break semicolon close curly brace star open paren w minus one close paren equals quote backslash zero quote semicolon return open paren letter close paren semicolon close curly brace close curly brace that that example code has a lot of stuff about pointers and incrementing pointers and dereferencing pointers etc so take a good look at that code back to the text get word uses the routines get ch and unget ch which we wrote in chapter 4. when the collection of alphabetic of an alphabetic token stops get word has gone one character too far that call to unget ch pushes that character back on the input for the next call getword calls another function called type to determine the type of each individual character for input here is a version that's only for ascii this code is the second example on page 127 of the textbook at www.cc4e.com code type open paren c close paren in c semicolon yeah open curly brace if open paren c greater than or equal to quote a quote and c less than or equal to quote z quote or c greater than or equal to quote uppercase a quote and c less than or equal to quote uppercase z quote close paren return letter semicolon else if open paren c greater than or equal to quote zero quote and c less than or equal to quote nine quote close paren return open friend digit close paren semicolon else return open paren c close paren semicolon close curly brace the symbolic constants letter and digits can have any values that do not conflict with nonalphanumeric values and eof the obvious choices are quote a quote and quote zero quote get word can be faster if calls to the function type are replaced by references to the appropriate array type the standard c library provides macros like is alpha and is digit which operate in this manner section 6.4 pointers to structures to illustrate some of the considerations involved with pointers and arrays of structures let us write a keyword counting program again this time using pointers instead of array indices as an aside i would note that it's a classic early assignment in any programming language to do a word frequency program here is a python program from my python for everybody course to count words from an input stream handle equals open open parenthesis single quote romeo dot txt close single quote comma quote r quote close parenthesis words equals handle dot read open print close print dot split open friend close paren counts equals dict open paren close paren four word in words colon counts subword equals get open paren word comma zero close paren plus one print open parent counts close paren this section in this book implements a less general word counting program in c the code depends on several functions from earlier in the book and the code below is pretty complex where the programmer only has access to lowlevel language without powerful and easytouse data types like python's list or dict it is likely that keto van rossen read this book took a long look at this code and designed the dick data structure in python so the rest of us can write a data parsing and word frequency programming program in the above six lines of code without worrying about dynamic memory allocation pointer management string length and a myriad of other details that must be solved when you're solving this program in c since python is open source you can actually look at the c code that implements the dict object in a file called dict object dot c it is almost 6 000 lines of code and includes other files or utility code there thankfully we only have to write one line of python to use it counts equals dict open friend close paren we will leave the complex bits to the c programmers that build and maintain this section is not showing us how to use the python dict object rather it is showing how one would build a dick like structure using c so continuing with section 6.4 pointers to structures the external definition of key tab do not need to change but main and binary do need modification this is example on page 129 of the textbook and that is available at www.cc4e.com code pointer version of counting c keywords main open paren close paren open curly brace int t semicolon char word open square bracket max word close square bracket semicolon struct key star binary open paren close paren comma star p semicolon while open paren open paren t equals get word open paren word comma max word close paren close paren not equal e o f close paren if open print t equal equal letter close paren if open paren open paren b equals binary open paren word comma key tab comma n keys close paren close paren not equal null close paren p right arrow key count plus plus for p equals key tab p less than key tab plus n keys semicolon p plus plus close parenthesis if open paren p right arrow key count greater than zero close paren printf open paren double quote percent for d space percent s backslash n double quote comma p right arrow key count comma p right arrow keyword and now we look at the binary search struct key star binary open paren word come tab comma n close paren char star word struct key tab open square bracket close square bracket semicolon int n open curly brace int cond semicolon struct key star low equals ampersand tab sub zero semicolon struct key star high equals ampersand tab sub n minus one semicolon struct key equals mid while open paren low less than or equal to high close paren open curly brace mid equals low plus high minus low divided by 2. if open paren open for n cond equals stir comp word comma mid right arrow keyword close print close paren less than zero close paren hi equals mid minus one semicolon else if close print con greater than zero close paren low equals mid plus one semicolon else return open paren mid close print semicolon close curly brace to finish the while and then return open paren null close paren close curly brace there are several things worthy of note here first the declaration of binary must indicate that it returns a pointer to the structure type key instead of an integer this is declared both in main and in binary if binary finds the word it returns a pointer to it if it fails it returns null second all the accessing elements of key dab is done by pointers this causes one very significant change in binary the computation of the middle element can no longer be simply mid equals paren low plus high close paren divided by two because the addition of two pointers will not produce any kind of useful answer even when divided by two and is fact illegal this must be changed to mid equals low plus open paren high minus low close paren divided by two which sets mid to the point to point to the element halfway between low and high you should also study the initializers for low and high it is possible to initialize a pointer to the address of a previously defined object and that is precisely what we have done here in main we wrote four open paren p equals key tab semicolon p less than key tab plus n keys semicolon p plus plus close paren if p is a pointer to a structure any arithmetic on p takes into the account the actual size of the structure so p plus plus increments p by the correct amount to get to the next element in the array of structures but don't assume that the size of a structure is the sum of the sizes of its members because alignment requirements for different objects potentially may cause holes in the structure finally an aside on program format when a function returns a complicated type as instruct key star binary open paren word comma tab comma n close paren the function name can kind of be hard to see and or find with a text editor alternately another style is sometimes used on two lines now struct key star on the first line in binary open paren word comma tab comma n close paren the spacing is mostly a matter of personal taste pick the form you like and hold to it section 6.5 selfreferential structures before we start this section a slightly longer aside from your narrator up to now i've resisted the temptation to augment the book with my own bits of code but we have reached the single point in the book where i feel that there is too big of a conceptual leap between two sections so i'm going to add some of my own narrative between sections 6.4 and 6.5 the rest of this chapter talks very nicely about binary trees and hash tables both essential lowlevel data structures in computer science and both excellent ways to understand pointers and how c can be used to build data structures like the python dictionary however the authors skip separately describing the structure of a dynamic dynamically constructed linked list which is the first and foundational collection data structure in computer science it should be understand be understood before moving to tree and hash map structures linked lists form the foundation of the python list object java array object php numeric key arrays and javascript arrays the linked list can be dynamically extended and items can be added in the middle efficiently as well as being pushed or popped on or off the front or back of the list linked lists are used also to implement cues as well as other aspects of operating system i will attempt to mimic the author's writing style in this new section of the book i'll write some sample code using a more modern dialect of c so it's easier to run on a modern compiler section 6.5.1 linked lists bonus content suppose we want to read a file and print the file in reverse order we don't know how many lines will be in the file before we read the file so we can't simply use an array of pointers to strings and character arrays like lines in a sense we need a dynamic array that grows as we encounter new lines when we reach the end of the file we then just loop through our stored lines from the end to the beginning so we can print them out in reverse order one solution is to make a data structure called a doubly linked list of character strings in addition to each line of data we will store a pointer to the previous line and the next line as well as well as a pointer to the first item we add to the list and then we'll call this the head of the list and then the most recent item we've added to the list which we'll call the tail of the list we will see a singly linked list as part of the hashmap data structure in a following section a single link list can only be traversed in a forward direction a doubly linked list can be traversed either forwards or backwards given that our linked list of strings will keep expanding as we get new lines we avoid hard coding array sizes like pound define maxlen1000 in the previous chapter we were building a program to sort a file going back to the description of a line in our doubly linked list it is clearly a structure with three components struct l node open curly brace char star text semicolon struct l node star prev semicolon struct l node star next semicolon close curly brace this recursive definition of l node might look chancy but it's actually quite correct it is illegal for a structure contained to contain an instance of itself but struct l node star prev declares preeve to be a pointer to an l node not an l node itself we'll write this code in a more modern c dialect using modern memory allocation i o routines provided by the standard c library this code is on page 130 of the textbook available at slash www.cc4e.com pound include stdio.h pound include std live.h pawn includes string.h pound define max line 1000 this is the length of the line not the number of lines struct l node open curly brace char star text semicolon struct l node star preview semicolon struct l node star next semicolon close curly brace semicolon now we have our main program to print the lines in reverse and we will use int main open paren close paren because we're coding in a modern dialect of c open curly brace struct l node star head equals null semicolon struct l node star tail equals null semicolon char line sub max line semicolon while open paren f get s open paren line comma max line comma s t d i n close paren not equal null close print open curly brace char star save equals open print char star close prin malloc open prin sterlin open print line close paren plus one close paren semicolon stir copy save come align struct l node star new equals open paren struct l node star close paren malloc open paren size of struct l node close paren close paren semicolon new right arrow text equals save new right arrow next equals null new right arrow preview equals tail and tail equals new if head equals equals null close paren head equals new semicolon close curly brace to finish the while now we'll print it all out four open paren struct l node star current equals tail semicolon current not equal to null semicolon current equals current right arrow prev close parenthesis open curly brace printf open paren double quote s close double quote comma current right arrow text close paren semicolon close curly brace to finish the four and then close curly brace to finish the main interestingly if we wanted to print the list in forward order or if we did have only a singly linked list our loop would look as follows four open paren struct l node star current equals head semicolon current not equal to null semicolon current equals current right arrow next closed paren open curly brace printf open paren double quote percent s double quote comma current right arrow text close paren semicolon close curly brace in general we use the variable names head tail and current as well as next and pre or similar names when writing code that builds or uses a linked list or so other programs will quickly understand what we are talking about after a while reading a for loop to traverse a linked list becomes as natural as reading a for loop that progresses through a sequence of numbers sections 6.5.2 binary trees suppose we want to handle the more general problem of counting the occurrences of all the words in some input since the list of words isn't known in advance we can't conveniently sort it and use a binary search yet we can't do a linear search for each word that has arrived to see if it's already been seen the program would take forever more precisely what is the expected running time and it would grow quadratically with a number of input words how can we organize the data to cope efficiently with a list of arbitrary words our solution is to keep the set of words seen so far sorted at all times by placing each word into its proper position in the order as it arrives this should this shouldn't be done by shifting the words in a linear array though that takes too long instead we will use a data structure called a binary tree the tree contains one node per distinct word each node contains a pointer to the text of the word a count of the number of occurrences of the word a pointer to the left child node and a pointer to the right child of node no node may have more than one at more than two children it might have only zero or one the nodes are maintained so that any node in the left tree contains only words that are less than the words at the node and the right tree only contains words that are greater to find out whether a new word is already in the tree one starts at the root and compares the new word to the word starting at that node if they match we found it if the new word is less than the tree word the search continues down the left otherwise the right child is searched there is no child in the required direction then the word is not in the tree and in plaque in fact the proper place for it to be is the missing child this search process is inherently recursive since the search for many node uses a search from one of its children accordingly recursive routines for inserting and printing will be the most natural going back to the description of a node is clearly a structure with four components struct t node open curly brace char star word int count semicolon struct t note star left semicolon struct t node star right semicolon closed curly brace this recursive declaration of a node might look chancy but actually it's quite correct it's illegal for a structure to contain an instance of itself but struck t node star left semicolon declares left to be a pointer to a node not a node itself the code for the whole program is surprisingly small given the handful of supporting routines that we've already written these are get word to fetch input and alec to provide space for squirreling the words away the mahin routine simply reads words with getword installs them in the tree with tree this is the first example on page 131 of the textbook which you can see at www.cc4e.com code pound include stdio.h pound defined max word 20 pound defined letter single quote a single quote main open paren close paren open curly brace struct t node star root comma star tree open print close paren semicolon char word open square bracket max word close square bracket semicolon and t semicolon root equals null while open paren open parent t equals get word open paren word comma max word close print close paren not equal eof close paren if open paren t double equal letter close paren root equals tree open paren root comma word close paren semicolon tree print open paren root close paren semicolon close curly brace tree itself is straightforward a word is presented by main to the top level root of the tree at each stage that word is compared to the word already stored at the node and is percolated down either to the left or right subtree by a recursive called a tree eventually the word either matches something already in the tree in which case the count simply is incremented or a null or pointer is encountered indicating the node must be created and added to the tree if a new node is created tree rent turns a pointer to it which is installed in the parent node this is the example on page 132 of the textbook at wwe code pound includes string dot h struct t node open curly brace char star word semicolon int count semicolon struct t node star left semicolon struct t node star right semicolon close curly brace semicolon struct t node star tree open paren p comma w close paren we're going to install w at or below p struck t node star p semicolon char star w open curly brace struct t node star t alec open paren close paren semicolon char star stir state stir save open for n close paren semicolon int conned semicolon if open paren p double equal null close paren open curly brace we've got a new word p equals t alec open print close paren to make a new note p right arrow word equals stir save open paren w close paren semicolon p right arrow count equals 1 p right arrow left equals p right arrow right equals null close curly brace else if open paren open print con equal stir comp w comma p right arrow word close paren close paren double equals zero close paren p right arrow count plus plus indicate that we've seen the word one more time else if open paren conned less than zero close paren lower will go into the left part of the tree p right arrow left equals tree p right arrow left comma w close paren semicolon else p right arrow right equals tree open friend p right arrow right comma w close paren semicolon return open paren p close paren semicolon close curly brace and that's a bit of code it's not much and it's beautiful recursion is happening the return p at the very end is really really important because we're kind of always overriding it but we're okay so um the overriding works its way back up to the recursion because it's recursive it's using pointers away we go back to the text storage for the new node is fixed by a routine called t alec which is an adaptation of the alec we wrote earlier it returns a pointer to a free space suitable for holding a tree node we'll discuss this more in a moment the new word is copied to a hidden place by stir save the count is initialized and the two children are made null this part of the code is executed only at the edge of the tree when a new node is being added we have unwisely for a production program omitted error checking on the values between returned by stir save and t alec tree print prints the tree in left sub tree order at each node it prints its left subtree all the words less than this word then the word itself then the right subtree all the words greater if you feel shaky about recursion draw yourself a tree and printed with tree print it's one of the cleanest recursive routines you can find this example code is on page 133 of the textbook which you can see at www.cc4e.com code i won't read the struct node code just tree print tree print open paren p close paren struct t node star p semicolon open curly brace if open paren p not equal to null close parend curly brace open curly brace tree print open paren p air right arrow left close paren semicolon printf percent 4d space percent s backslash n double quote comma p right arrow count comma p right arrow word sum print close parenthesis semicolon tree print open print p right arrow right close paren semicolon close curly brace for the if and then close curly brace for the tree print function again i agree with the authors and that is one of the cleanest and most beautiful and most applicable uses of recursion that you will probably ever see in all your career i'm not a fan of recursion in all uses cases but you really can't do this any other way well back to the text practic as a practical note if the pre tree becomes unbalanced because the words don't arrive in random order the running time of the program can grow too fast as a worst case if the forwards are already in order this program does an expensive simulation of linear search there are generalizations of the binary tree notably 2 3 trees avl trees and i would add balanced binary trees which do not suffer from this worst case behavior but we will not describe them here before we leave this example it's also worth a brief digression on a problem related to storage allocators clearly it's desirable that there only be one storage allocator in a program even though it allocates different kinds of objects but if one allocator is to process requests for say pointers to chars and pointers to struck t nodes two questions arise first does it meet the requirement of most real machines that objects of a certain types must satisfy alignment restrictions for example integers must often be located uneven addresses second what declarations can cope with the fact that alec necessarily returns different kinds of pointers alignment requirements can generally be satisfied easily at the cost of some wasted space merely by assuring ensuring the allocator always returns a pointer that meets all alignment restrictions for an example on the pdb11 it is sufficient that alec always returns an even pointer since any type of object may be stored at an even address the only cost is a wasted character on the odd length requests similar actions are taken on other machines thus the implementation of alec may not be portable but its usage is the alec of chapter 5 does not guarantee any particular alignment in chapter 8 we'll show how to do the job right as an aside by now you know that when the authors mentioned the pdp11 they are sharing some aspects of the challenge of making c work on previous generation computers with short memory words and small amounts of memory and at the same time making them work well on the incoming generation of computers with larger words and more memory the research thought and care that went into making sure the c code was portable across multiple generations of computer hardware is on display in the previous paragraph the question of the type declaration for alec is a vexing one for any language that takes its type checking seriously in c the best procedure is to declare that alec returns a pointer to char and then explicitly coerce the pointer into the desired type with a cast therefore if p is declared as char star p semicolon then open paren struct t node star close paren p converts it into a t node pointer expression thus t alec is written as t node star t alec open paren close paren open curly brace char star alec return open paren open print struct t node star close print alec open paren sizeof open prin struct t node close prin close paren close print this is more than is needed for current compilers but represents the safest course for the future i would add that these concerns that the authors mentioned in this section are also nicely resolved in modern c compilers in the nc version of c they introduce the notion of the void type the void type indicates the lack of a type much like null is used to indicate not a valid pointer or not a flying toy in 1978 because the chart type was generally the most native type on any system it was often used as the generic pointer needed to return memory from an allocation function in modern c we use pointers to void and then cast the returning pointer to be a pointer to whatever struct or other data we just allocated if we were writing alec the alec routine in this book using modern c it would return a pointer to white the 1978 version is char star alec open paren close paren and the modern version is void star alec open paren close paren we've left the book alone we haven't used void throughout the book but it is a testament to the foresight of the authors that all the pointer casting code in this book still works today the same regardless of whether the memory allocation functions return char or void pointers to the allocated data sections 6.6 table lookup as an aside in this section we finish our quick tour of the implementations of the three core data structures in computer science one the linked list two the tree and three the hash map as described in this section a singly linked list is also part of a hashmap implementation so you can compare it to the doubly linked list code introduced in the earlier bonus section 6.5.1 this section is worth understanding well because not only is it an excellent review of pointers and structures but also because one of the most common questions on a facetoface programming interview is draw a hashmap on the whiteboard and explain how it works this is an easy question if you study and understand this section of the book and almost impossible if you have not in some ways this section is the most intricate data structure that's described in the book it is why it is so popular in coding interviews chapters 7 and 8 talk about lots of practical things like input output of the unix operating system elegant data structures and their use are core concepts in computer science understanding them highlights the difference between a good programmer and a computer scientist in a sense understanding how a hashmap is the secret handshake of computer science and it is the secret handshake because of this book and this section of this book written back in 1978 and used in a course that the person interviewing you may have took when they were in college hash maps were difficult for them to understand back then and so if you understand the concept then you must be solid so i hope you pay close attention to this section and remember the handshake back to the text in this section we will write the innards of a table lookup package as an illustration of more aspects of structures this code is typical of what might be found in the symbol table management routines of a macro processor or a compiler for example consider the c pound define statement when a line like pound define yes one is encountered the name replacement text the name yes and the replacement text one are stored in a table later when the name yes appears in a statement like inward equals yes semicolon it must be replaced by one there are two major routines that manipulate the names and replacement texts install open paren s comma t close paren records the name s and replacement t in the table s and t are just character strings lookup open paren s close print searches for s in the table and returns a pointer to the place where it was found or null if it wasn't there the algorithm used is a hash search the incoming name is converted to a small positive integer which is then used to index into an array of pointers an array element points to the beginning of a chain of blocks describing the names that have the hash value and if it is null then no names have hashed to that value a block in the a block in the chain is a structure containing pointers to the name the replacement text and the next block in the chain a null next pointer marks marks the end of the chain struct and list open paren char star name semicolon char star def semicolon struct endless star next semicolon close curly brace semicolon the pointer array is just pound define hash size 100 static struct and list star hash tab open square bracket hash size close square bracket semicolon the hashing function which is used by both lookup and install simply adds up the character values in the string and forms the remainder modulo the array size this is not the best possible algorithm but it has the merit of extreme simplicity hash open paren s close paren char star s semicolon open curly brace int hash val four open curly brace hash val equals zero star s not equal quote single quote backslash zero single quote semicolon close paren hash val plus equals star s plus plus semicolon return open paren hash val modulo percent hash size close paren semicolon close curly brace as an aside hashing functions are one of the foundational notions in computer science hashing functions are used for everything from high performance inmemory structures organizing databases data digital signing network packet checksums security algorithms and much more the above text is a really great example of a really simple hashing function you should understand this simple presentation well so that when you encounter a more complex implementation or use of hashing you can fall back on this text to understand that at its core hashing is a very simple concept so much of this chapter is a succinct example of some of the most powerful concepts in computer science please don't look at the eight code lines of code above and think i got that and just jump to the next bit this chapter is showing you the way of the master programmer wax on wax off be patient slow down and enjoy your time here back to the text the hashing process produces a starting index in the array hashtag if the string is to be found anywhere it will be in the chain of blocks beginning there the search is performed by lookup if lookup finds the entry already present it just returns a pointer to it if not it returns null here's the code struct and list star lookup open paren s close paren char star s semicolon open curly brace struct and list star np semicolon for open paren np equals tab sub hash open paren s close paren close square bracket semicolon np not equal null semicolon np equals np right arrow next close parenthesis if stir comp open print s comma np right arrow name close paren double equals zero return open print np close paren semicolon return open print null close print semicolon close curly brace install uses lookup to determine whether the name installed is already present if so the new definition must supersede the old one otherwise a complete newly new entry is created install returns no if for any reason there's no room for a new entry struct and list star install open friend name common death close paren jar star name comma star def semicolon open curly brace struct endless star np comma star lookup open print close brand semicolon char stir save comma star alec open print close paren semicolon int val semicolon if open paren open paren np equals lookup open paren name close paren close print double equal null close paren open curly brace i.e it's not found np equals open paren struct end list star close paren alec open paren size of open paren star np close paren close paren semicolon np equals null return null that means the allocation failed if open paren open paren np right arrow name equals stir save open paren name close print close paren double equals null close paren return open paren null close paren semicolon hash val equals open paren np right arrow name close brand semicolon np next equals tab open square bracket hash val close for bracket second semicolon hash tab open square bracket hash valve close spur bracket equals np semicolon we're actually pushing these new ones to the head of this singly linked list and so those last two statements push the the most recent top of the list forward and then replace with the new one at the top of the list the list does not stay in any order so we have a closed curly brace to end all that if for the not found code close curly brace else this is the already code click already their code free open paren np right arrow def close paren semicolon free the previous definition that's the string part of the the the pound define if open paren np right arrow def equal stir save open paren def close print close print equals null close print return open paren null close paren semicolon return open print np close print semicolon close curly brace so that last bit there was to if you have a pound define with the same keyword and a different later you have it later a different uh definition you can replace the definition so that last bit was replacing the definition again this code is a pretty intricate it's really both the hash table and a singly linked list going on at the same time so take a close look at this on page 136 of the book stir save merely copies the string given its argument to a safe space obtained by a call to alec we've showed this code in chapter five since calls to alec and free may occur in any order and since alignment matters the simple version of alec is just not adequate here see more in chapters 7 and 8. as an aside one of the reasons that the authors make vague forwardlooking statements we know that they talk about dynamic memory is that largescale memory management in a programming language is still a subject of active research 40 years later back in 1978 it was absolutely not a settled topic you can see this when the authors build a simple nonproduction memory allocation scheme with their own alec and free routines backed by a fixed length static extern array of characters dynamic allocation is essential to writing competency programs but it is likely that the production grade dynamic memory support was still somewhat nonportable when the book was written so they used simple selfcontained implementations in this book modern dynamic memory support is through the mala c alec and free functions in the standard library these functions request dynamic memory blocks from the operating system and manage those areas on behalf of your c code on unix and unixlike systems the memory allocation layer asks the underlying operating systems for blocks of memory through the sbrk interface even with virtual memory programmers must carefully manage their use of dynamically allocated memory because memory is never unlimited section 6.7 fields when storage space is at a premium it may be necessary to pack several objects into a single machine word one especially common use is a set of single bit at flags in applications like compiler symbol tables externally imposed data formats such as interfaces to hardware devices also often require the ability to get at pieces of a word as an aside we are going to go now from low level programming to even lower level programming the unix operating system is written in c and unix needs to have for example an implementation of the internet protocol so it can be connected to the internet one of the most important internet protocols is the transmission control protocol tcp in order to implement tcp you need to send very precisely formatted data across the network the data is very tightly packed in order to save precious network bandwidth the exact format of a tcp header is described in the tcp wikipedia page if you look at the header you will find that it bits 96 through 99 tcp expects a four bit integer that defines the data offset exactly what this data means is less relevant unless you're actually writing the tcp implementation but it does demonstrate that we need to control our data layout at times on a bit by bit basis this section covers how we can use struct to build up a tcp header in c which can be parsed and set without using masking and shifting operations with hardcoded numbers the section below is simpler than constructing a valid tcp header using a carefully packed struct but it does lay the groundwork for these more complex situations now back to the text imagine a fragment of a compiler that manipulates a symbol table each identifier in a program has certain information associated with it for example whether or not it's a keyword whether or not it's external and or static and so on the most compact way to encode such an information is a set of onebit flags in a single char or int the usual way this is done is define a set of masks corresponding to the relevant bit positions as in pounddefying keyword 01 pounddefine external 02 and pound defined static 0 4. the numbers of course must be powers of 2 so that the shifting works then accessing the bits become a matter of bit fiddling with shifting masking and complementing operators which were described in chapter 2. certain idioms of fear appear frequently flags vertical par equals external vertical bar static turns on the external and static bits and flags while flags ampersand equal tilled open paren external or static closed paren semicolon turns them off and if open paren open print flags ampersand paren external vertical bar static close paren close print equal equal zero dot dot dot is true if both bits are off although these idioms are readily mastered as an alternative c offers the capability of defining and accessing fields within a word directly rather than by bitwise logical operators a field is a set of adjacent bits within a single int the syntax of field definition and access is based on structures for example the symbol table palm defines above could be replaced by the definition of three fields struct unsigned is keyword colon one semicolon unsigned is extern colon one semicolon unsigned is static colon 1 semicolon closed curly brace flags this defines a variable called flags that contains three 1bit fields the number following the colon represents the field width in bits the fields are declared unsigned to emphasize that they are really unsigned quantities individual fields are referenced as flags.is keyword flags.is extern etc just like other structure members fields behave like small unsigned integers and may partic participate in arithmetic expressions just like the other integers thus the previous examples may be written much more naturally as flags is underscore extern equals flags is static equals one semicolon turn the bits on flags is extern equals flags is static equals one semicolon to turn the bits on flags dot is extern equals flags dot is static equals zero turns them off and if open paren flags dot is extern double equals zero and flags dot is static double equals zero close paren dot dot to test them a field may not overlap an int boundary if the width would cause this to happen the field is aligned to the next in boundary fields need not be named unnamed fields with a colon and width only are used for padding the special width 0 may be used to force alignment to the next int boundary there are a number of caveats that apply to fields perhaps the most significant fields are assigned left to right on some machines and right to left on others reflecting the nature of different hardware this means that although fields are quite useful for maintaining internally defined data structures the question of which end comes first have to has to be carefully considered when picking apart externally defined data other restrictions to bear in mind fields are unsigned they may only be stored in ins or equivalently unsigned they are not arrays and they do not have addresses so the ampersand operator cannot be applied to them section 6.8 unions a union is a variable which may hold at different times objects of different types and sizes with the compiler keeping track of the size and alignment requirements unions provide a way to manipulate different kinds of data in a single area of storage without embedding any machine dependent information in the program for example again from a compiler symbol table suppose constants may be ins floats or character pointers the value of a particular constant must be stored in a variable of the proper type yet it is most convenient for table management if the value occupies the same amount of storage and is stored in the same place regardless of its type this is the purpose of a union to provide a single variable which can legitimately hold one of several types as with fields the syntax is based on structures union u tag open curly brace int ival semicolon float f val semicolon char star pval semicolon closed curly brace uval the variable uval will be large enough to hold the largest of these three types regardless of the machine it is compiled of compiled on the code is independent of hardware characteristics any one of these types may be assigned to uval and then used in expressions so long as the usage is consistent the type retrieved must be the type most recently stored it is the responsibility of the programmer to keep track of what type is currently stored in the union the results are machine defendant dependent if something is stored as one type and extracted as another type syntactically members of a union are accessed as union name dot member or union pointer right arrow member justice for structures if the variable you type is used to keep track of the current type start in uval then one might see code as if open paren you type double equals int close paren printf paren double quote percent d backslash n double quote comma uval dot ival close parent semicolon else if open paren you type double equal float close paren print f open paren double quote percent f backslash n double quote comma u val dot f val close paren semicolon else if open paren you type double equals string close paren print f double quote percent s backslash n double quote comma u val dot p val close paren semicolon else printf open paren double quote bad type percent d and you type backslash n double quote comma you type close paren semicolon unions may occur in structures and arrays and vice versa the notion for accessing a member of a union in a structure or vice versa is identical that to that for nested structures for example in the structure array defined by struct open curly brace char star name semicolon int flags semicolon and you type semicolon union open curly brace int ival semicolon float f val semicolon char star p val semicolon close curly brace u val semicolon close curly brace sim tab open square bracket end sim close square bracket the variable i val is referred to as sim tab sub i dot u val dot ival and the first character of the string p val by star sim tab sub i dot uofl.pival in effect a union is a structure in which all the members have offset zero the structure is big enough to hold the widest member and the alignment is appropriate for all types in the union as with structures the only operations currently permitted on unions are accessing a member and taking the address unions may not be assigned to pass to functions or returned by functions pointers to unions can be used in a manner identical to pointers to structures as it aside the above limitations on unions are just no longer accurate like structures modern c compilers can assign the contents of the union to another union variable you can also pass unions into functions by value and receive a union as the return type of a function the storage allocator in chapter 8 shows how a union can be used to force a variable to be aligned on a particular kind of storage boundary section 6.9 type def c provides a facility called typedef for creating new data type names for example the declaration type def space int space length semicolon makes the name length a synonym for end the type length can be used in declarations cast etc in exactly the same ways int can be length len comma maxlen semicolon length star lengths open square bracket close four bracket semicolon similar the declaration type def char star string semicolon makes string a synonym for char star or a character pointer which then may be used in declarations like string p comma line ptr open square bracket lines close square bracket comma alec open paren close paren semicolon note that the type being declared in a typedef appears in the position of a variable name not right after the word typedef syntactically typedef is like the storage class extern static etc we've used uppercase letters in these examples to emphasize the names a more complicated example we could make typedefs for the tree nodes shown earlier in the track chapter typedef struct t node open curly brace char star word semicolon hint count semicolon struct t node star left semicolon struct t node star right semicolon close curly brace tree node comma star tree ptr this creates three two new type keywords called tree node which is a structure and tree ptr which is a pointer to the structure then the routine t alec could become tree ptr t alec open paren close print open curly brace char star alec open print close paren semicolon return open paren open paren tree ptr close print alloc open print size f open paren tree node close print close paren closed brand semicolon closed curly brace it should be emphasized that a typedef declaration does not exactly create a new type in any sense it merely adds a new name for some existing types nor are there any new semantics variables declared this way have exactly the same property as variables who whose declarations are spelled out explicitly in effect typedef is like defined except that since it's interpreted by the compiler it can cope with textual substitutions that are beyond the capabilities of the c macro preprocessor for example typedef int open paren star pfi close print open for enclosed print semicolon creates the type pfi to mean pointer to a function returning integer which can be used in context like pfi stir comp comma num comp comma swap in the sort program in chapter 5. there are two main reasons for using typedef declaration the first is to parameterize a program against portability problems if type defs are used for the data types which may be machine dependent only typedefs need to change when the program is moved one common situation is to use typedef names for various integer quantities and then make an appropriate set of choices of short int and long for each host machine the second purpose of type defs is to provide better documentation for a program a type called tree ptr may be easier to understand than one declared only as a pointer to a complicated structure finally there's always the possibility that the futures a compiler or some other program such as lind may make use of the information contained in typedef declaration to perform some extra checking on the program this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardwarefirst vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 7 input and output input and output facilities are not part of the c language so we've deemphasized them in our presentation thus far nonetheless real programs do interact with their environment in much more complicated ways than those we've shown before in this chapter we will describe this standard io library a set of functions designed to provide a standard i o system for c programs the functions are intended to present a convenient programming interface yet reflect only operations that can be provided on most modern operating systems the routines are efficient enough that users should seldom feel the need to circumvent them for efficiency regardless of how critical the application finally the routines are meant to be portable in the sense that they will exist in compatible form on any system or c exists and that programs which confine themselves to facilities provided by the stated library can be moved from one system to another essentially without change we will not try to describe the entire io library here we are more interested in showing the essentials of writing c programs that interact with our operating system environment section 7.1 access to the standard library each source file that refers to the standard library function must contain the line pound include stdio.h near the beginning the file stdio.h defines certain macros and variables used by the i o library the use of angle brackets less than and greater than instead of the usual double quotes directs the compiler to search for the file in a directory containing the standard header information in unix this is often somewhere like slash user slash include furthermore it may be necessary when loading the program to specify the library explicitly for example on the pdp11 unix system the command to compile a program would be cc source files etc dash ls capital s where dash l capital s indicates loading from the standard library section 7.2 standard input and output catch our input char the simplest input mechanism is to read a character at a time from the standard input generally the user's terminal or keyboard with getchar getchar returns the next input character each time it's called in most environments that support c a file may be substituted for the terminal by using the less than config convention if a program prog uses get char then the command line prog less than infile causes probe to read infile instead of the terminal or keyboard the switching of input is done in such a way that prog is oblivious to the change in particular the string less than infile is not included in the command line arguments in argv the input switching is also invisible if the input comes from another program by a pipe mechanism the command line other probe vertical bar prog runs two programs other prog and prog and arranges for the standard input for prog to come from the standard output of other prog cat char returns the value eof when it encounters endtofile on whatever input is being read the standard library defines the symbolic eof constant to be 1 with a pound defined in the file stdio.h but test should be written in terms of eof not negative 1. so is to be independent of the specific value for output put char open paren c close paren puts the character c on the standard output which is also by default the terminal or screen the output can be directed to a file by using greater than if probe uses put char prog greater than out file will write the standard output onto outfile instead of the terminal on the unix system a pipe can also be used prog vertical bar another prog puts the standard output of prog into the standard input of other prog again prog is not aware of the redirection output produced by printf also finds its way to the standard output and calls to put char and printf may be interleaved a surprising number of programs read only one input stream and write only one output stream for such programs i o with getchart putchar and printf may be entirely adequate and is certainly enough to get started this is particularly true given file redirection in a pipe file for connecting the output of one program to the input of the next for example consider the program lower which maps input to lower case this is an example on page 145 with a textbook that you can see at www.cc4e.com code pound include stdio.h pound includes c type dot h main open print close paren open curly brace int c while open paren open paren c equals get char open paren close paren close print not equal to eof close paren put char is upper open paren c close paren question mark two lower open paren c close paren colon c close paren semicolon close curly brace the functions is upper and two lower are actually macros defined in c type dot h the macro is upper tests whether its argument is an uppercase letter returning nonzero if it is and zero if it's not the macro two lower converts an uppercase to lowercase letter regardless of how these functions are implemented on a particular machine their external behavior is the same so programs that use them are shield shielded from the knowledge of their character set to convert multiple files you can use a program like the unix cat to collect files cat file1 file2.verticalbar lower greater than output and thus avoid learning how to access files from a program the cad example is presented later as example code in this chapter as an aside the standard io library functions getchar and put char can actually be macros and thus avoid the overhead of a function call per character we'll show this how this is done in chapter 8. section 7.3 formatted output printf the two routines printf for output and scanf f4 input which we describe in the next section permit translation to and from character representations of numerical quantities they also allow generation or interpretation of formatted lines we've used printf informally throughout the previous chapters here is a more complete and precise description printf open paren control com arg1 comma card 2 etc close paren printf converts formats and prints its arguments on the standard output under this under the control of the string control the control string contains two type of objects ordinary characters which are simply copied to the output stream and conversion specifications each of which causes conversion and printing of the next successive argument to printf each conversion specification is introduced by the character sense sign and ended by a conversion character between the percent and the conversion character there may be a minus sign which specifies left adjusted of the left adjustment of the converted argument in its field a digit string specified a minimum field width the converted number will be printed in a field at least this wide and wider if necessary if the converted argument has fewer characters than the field it will be padded on the left or right if the left adjustment indicator's been given to make up the field width the padding character is normally blank in zero if the field width is specified with a leading zero this zero does not imply an octal field with a period which separates the field width from the next digit string a digit string that specifies the precision which specifies the maximum number of characters to be printed from a string or the number of digits to be printed to the right of the decimal point of a float or a double a length modifier the letter l which indicates that the corresponding data item is along rather than an end conversion characters and their meanings are d the arguments converted to decimal notation o the argument is converted to unsigned octal notation without a leading zero x the argument is converted to unsigned hexadecimal notation without the leading 0x u the argument is converted to unsigned decimal notation c the argument is taken to be a single character s the argument is a string characters from the string are printed until a null character is reached or the number of characters indicated by the present precision specification is exhausted e the argument is taken to be a float or a double and converted to decimal notation of the form optional minus sign m dot nnn capital e plus or minus xx where the length of the string of the ends is specified by the precision the default by precision the default precision is 6. note that the precision does not determine the number of significant digits printed in the f format g says use percent e or percent f which ever is shorter and nonsignificant zeros are not printed if the character after the percent is not a conversion character the character is simply printed thus percent may be printed as percent percent most of the format conversions are obvious and have been illustrated in the earlier chapter one exception is the precision field as it relates to strings the following table shows the effect of a variety of specifications in printing hello comma world which is 12 characters we put colons around each field so you can see its actual width colon percent 10 s colon colon hello world colon it's 12 characters long and so we get 12 characters printed because we haven't really told it to strictly limit that colon percent minus 10 s colon colon hello comma world colon no extra spaces again 12 characters are used even though if we said 10 it expands it to 12 and the fact that it's left justified seems how we're printing more than the width of the field doesn't make any difference colon percent 20 s colon colon eight spaces then hello comma world colon eight spaces are put in on the left because it by default is right justified colon percent minus 20 s colon prints colon hello comma world and then eight spaces and then colon we've told it to left justify so the eight spaces are added to fill it out to 20 spaces after hello world colon percent 20.10 s colon gives us colon and then 10 blanks and then hello comma w o r colon now in this case we've told it we really only want 10 characters from the string and so the the ld is truncated percent minus 20.10 s colon hello comma w o r and then 10 spaces and it's less justified so the ten spaces are at the end right before the colon colon percent dot 10 s colon colon hello comma wor colon so now the overall field that's printed is exactly 10 characters and it is the leftmost 10 characters warning printf uses its first argument to decide how many arguments follow and what their types are it will get confused and you will get nonsense answers if there are not arguments enough arguments or they are of the wrong type as an aside formatted output is difficult the design of c printf was inspired by the earlier format statement in fortran and alcohol in order to compete with those languages c needed to ship with solid support for formatted output the approach chosen by c percolated into c like languages php and java simply have a function called printf that mimics most of the c formats python has evolved its approach to formatted output over the years an early initial solution had a syntax that used percent to provide c like formatting there was also a format method on the string object for example x equals 421.34 print open paren double quote x is percent 7.2 f double quote percent open paren x comma close paren close paren that uses the percent operator and sends a tuple but the syntax of percent seven point two f is the same another option is print open paren double quote x is open curly brace y colon 7.2 f close curly brace double quote dot format open paren y equals x close paren close paren this sends a set of key value pairs and it's a little clunky the latest and least clunky way to do it in modern python is what we call f strings and the code is print f double quote print open paren f double quote x is open curly brace x colon 7.2 f close curly brace double quote close paren but even after all this evolution much of this output formatting still traces its design inspiration from the nc printf capabilities back in 1978. formatted input scanf the function scanf is the input analog of printf providing many of the same conversion facilities but in the opposite direction scanf open paren control com arg1 comma r2 etc close paren scanf reads characters from standard input interprets them according to the format specified in control and stores the results in the remaining arguments the control argument is described below the other arguments each of which must be a pointer indicate where the converting corresponding converted input should be stored the control string usually contains conversion specifications which are used to direct interpretation of input sequences the control string may contain blanks tabs or new lines we call these white space characters which are ignored ordinary characters not percent which are expected to match the next nonwhite character space character of the input stream conversion specifications consisting of the character percent an optional assignment suppression character asterisk and an optional number specifying the maximum field width and a conversion character a conversion specification directs the conversion of the next input field normally the result is placed in the variable pointed to by the corresponding argument if assignment suppression is indicated by the asterisk character however the input field is parsed but then simply skipped no assignment is being made an input field is defined as a string of nonwhite space characters extent it extends to either the next white space character or until the field width if specified is exhausted this implies that scanf will read across line boundaries to find its input since new lines are white space the conversion character indicates the interpretation of the input field the corresponding argument must be a pointer as required by the call by value semantics of c the following conversion characters are legal d a decimal integer is expected on input the corresponding argument should be an integer pointer o an octal integer at with or without a leading zero is expected on input the corresponding argument should be an integer pointer x a hexadecimal integer with or without the leading zero x is expected in the input this corresponding argument should be an integer pointer h a short integer is expected in the input the corresponding argument should be the point a pointer to a short integer c a single character is expected the corresponding argument should be a character pointer the next input character is placed at the indicated spot the normal skip over white space characters is suppressed in this case to read the next nonwhite space character use percent one s s a character string is expected the corresponding argument should be a character pointer pointing to an array of characters large enough to accept the string and turn the terminating backslash zero which will be added f a floating point number is expected the corresponding argument should be a pointer to a float the conversion character e is a synonym for f the input formats for floats is an optional sign a string of numbers possibly containing a decimal point and an optional exponent field containing an upper or lower case e followed by possibly a signed integer the conversion character d o and x may be preceded by l the letter l to indicate that a pointer to a long rather than end appears in the argument list similarly the conversion characters e or f may be preceded by the letter l to indicate that it's a pointer to a double rather than a float in the argument list for example the call int i float x char name open square bracket 50 close square bracket close a semicolon scanf open parenthesis double quote percent d space percent f space percent s double quote comma ampersand i comma ampersand x comma name close paren semicolon with the input line 25 space 54.32 e minus 1 space thomson we'll assign the value 25 to i the value 5.432 to x and the string thompson properly terminated with a backslash 0 to name the three input fields may be separated by as many blanks tabs and new lines as desired the call int i semicolon float x semicolon char name open square bracket 50 close square bracket semicolon scanf double quote percent to d space percent f space percent star d space percent to s double quote comma ampersand i comma ampersand x common name close parentheses with input 56789 space 0 1 2 3 space 4 5 a 7 2 will assign 56 to i 7 89.0 to x skip over 0 1 2 3 and place the string 45 in name the next call to any input routine will begin searching at the letter a in these two examples name is a pointer and thus must not be preceded by an ampersand as another example the rudimentary calculator of chapter 4 can now be written with scanf to do the input put conversion this is example code on page 150 the textbook which you can see at www.cc4e.com code pound include stdio.h main open paren close paren open curly brace double sum comma v semicolon sum equals zero while open paren scanf open paren double quote percent l f double quote comma ampersand v close parenthesis not equal eof close parentheses printf open parenthesis double quote backslash t percent.2f backslash n double quote comma sum plus equals v close parenthesis semicolon close curly brace scanf stops when it's in when it exhausts control string or when some input fails to match the control specification it returns as its function residual value the number of successfully matched and assigned input items this can be used to decide how many input items were found on end to file eof is returned note that this is different from zero which means that the next input character does not match the first specification in the control string the next call to scanf resume searching immediately after the last character already returned a final warning the arguments to scanf must be pointers by far the most common error is writing scanf open paren double quote percent d percent comma n close paren semicolon instead of scanf open paren double quote percent d double quote comma ampersand n close paren semicolon section 7.5 in memory format conversion the functions scanf and printf have siblings called scan f and s printf which perform the corresponding conversion but operate on a string instead of a file the general format is s printf open paren string comma control comma arg one comma r two dot dot close paren s scan f open paren string comma control comma arg one comma r two et cetera close paren sprint s print f formats the arguments in arg1 arg2 etc according to control as before but it places the result in a string instead of on the standard output of course string had better be big enough to receive the result as an example if the name is a character array and n is an integer then s printf open paren name comma double quote temp percent d double quote comma n arg2 etc these arguments must be pointer the call scanf open paren name comma double quote temp percent d double quote comma ampersand n close parenthesis semicolon sets n to the value of the digits following temp in name section 7.6 file access as inside the next two sections do a nice job of covering file input and the notion of the standard error with simple sample code but the authors are also making a subtle point about unix and how the design of c makes it easy to build unix utilities by the end of section 7.6 we see a 29 line program that is pretty much a complete implementation of the core functionality of the unix cat command part of the philosophy of unix was to build commands that are each simple building blocks that can be composed using standard input standard output redirection as well as pipes these next two sections are a gentle celebration of the design principles that underlie the unix operating system also while we're talking about the linkage between c and unix there is a unixrelated easter egg earlier in the chapter see if you can find it bonus points if you already noticed it the programs written so far have all read the standard input and written the standard output which we have assumed are magically predefined for a program by the local operating system the next step in i o is to write a program that accesses a file which is not already connected to the program one program that clearly illustrates the need for such operations is cat which concatenates a set of name files onto standard output cad is used for printing files on a terminal and is a general purpose input collector for programs which do not have the capability of accessing files by name for example the command cat x dot c y dot c prints the contents of the files x dot c and y.c on the standard output the question is how to arrange for the named files to be read that is how to connect the external names the user that the user thinks of to the statements which actually read the data the rules are simple before it can be read or written the file has to be opened by the standard library function f open f open takes an external name like x dot c or y dot c does some housekeeping and negotiating with the operating system some details of which do not need to concern us and returns an internal name which then must be used for subsequent reads or rights of the file the internal name is actually a pointer called the file pointer to a structure which contains information about the file such as the location of a buffer the current character position in the buffer whether the file is being read or written and similar users don't need to know the details because part of the standard i o definitions are obtained from stdio.a and it's a structured definition called file the only declaration needed for a file pointer is exemplified by file star f open open paren close paren comma star fp semicolon that says that fp is a pointer to a file and f open returns a pointer to a file note that file is a type name like int not a structure tag it's implemented as a typedef details on how all this works on the unix system are given in chapter eight the actual call to f open in a program is fp equals f open open paren name comma mode close paren semicolon the first argument of f open is the name of the file as a character string the second argument is the mode also a character string which indicates how one intends to use the files allowable modes are read are write w or append a if you open a file which does not exist for writing or appending it is created if possible opening an existing file for writing causes the old constants to be discarded trying to read a file that does not exist is an error and there may be other causes of error as well like trying to read a file when you don't have permission if there is any error f open will return the null pointer with a value of null which for convenience is also defined in stdio.h the next thing needed is a way to read or write the file once it is open there are several possibilities of which get c and putsy are the simplest getc returns the next character from a file it needs the file pointer to tell what file thus c equals getc open paren fp close paren places in c the next character from the file referenced by fp and eof when it reaches end of file put c is the inverse of get c put c open paren c comma f p close paren puts the character c on the file fp and returns c like getchar and putchar gets the input c may be macros instead of functions when a program is started three files are automatically opened and file pointers are provided for them these files are the standard input the standard output and the standard error output the corresponding file pointers are called stdin sddi out and stder normally these are all connected to the terminal but stdn and std out may be redirected to files or pipes as described in section 7.2 getchar and putchar can be defined in terms of getc put c std in and std out as follows pound define get char open for n close paren get c open paren stdin close paren pound define put char open paren c close paren put c open for n c comma std out close paren for formatted input or output files the function f scan f and f printf may be used these are identical to scanf and printf save that the first argument is a file pointer that specifies the file to be read or written the second string is the control the second argument is the control string with these preliminaries out of the way we are now in a position to write the program cat to concatenate files the basic design is one that has been found convenient for many programs if there are command line arguments they are processed in order if there are no arguments the standard input is processed this way the program can be used standalone or part of a larger process this example is on page 153 of the textbook and you can see it at www.cc4e.com code pound include stdio.h main open paren argc comma argv closed paren int argc semicolon char star argv open square bracket close square bracket semicolon open curly brace file star fp comma star f open open chrome close print semicolon if open paren rxc double equals one close paren there is no standard there's no arguments so we're going to copy the standard input file copy open paren stdin close paren semicolon else while open paren minus minus rxc greater than zero close paren if open paren open paren fp equals f open open paren star plus plus arc v comma quote r quote close paren close paren double equals null close paren open curly brace print f open print double quote cat colon can't open space percent s backslash n double quote star comma star r v close paren semicolon break semicolon close curly brace else open curly brace file copy open paren fp close paren semicolon f close open paren fp close print semicolon close curly brace for the if then else and then close curly brace for the main and now we have the file copy function we're going to open read all the contents of a file pointer and send it to standard output file copy open paren fp close paren file star fp semicolon open curly brace int c semicolon while open paren open for n c equals get c open paren fp close print close paren not equal eof close paren put c open paren c comma std o ut close paren semicolon close curly brace the file pointers std in and std out are predefined in the i o library as the standard input and the standard output they may be used anywhere an object of type file star can be they are constants however not variables so don't try to assign to them the function f close is the inverse of f open it breaks the connection between the file pointer and the external name that was established by x f open freeing the file pointer for another file since most operating systems have some limit on the number of simultaneously open files a program may have it's a good idea to free things when they're no longer needed as we did above in cat there's also another reason for f close on an output file it flushes the buffer in which put c is collecting output fclose is called automatically for each open file when a program terminates normally section 7.7 error handling stder and exit the treatment of errors in the previous implementation of cat is not ideal the trouble is that if one of the files can't be accessed for some reason the diagnostic is printed at the end of the concatenated output that is acceptable if the output's going to a terminal but it's really bad if it's going to a file or some other program via pipeline to handle this situation better a second output file called stderr is assigned to the program in the same way that stdin and std out are if at all possible output written on stderr appears on the user's terminal even if the standard output is redirected let's revise cat to write its error messages onto the standard output file this is really only a couple of lines of code different between the example on page 153 this is the example on page 154 of the textbook which of course you can see at www.cc4e.com code pound include stdio.h pound include stdlib.h open paren argh c comma arc v close paren int argc semicolon char star arc v open square bracket close square bracket semicolon open curly brace file star fp comma star f open open paren close paren semicolon if open for n r c double equal one close paren here we have no arguments file copy open paren s t d i close parent semicolon else while open paren minus minus argc greater than zero close paren if open paren open paren fp equals f open open print star plus plus arg v comma double quote r double quote close paren and close for n double equal null close paren open curly brace f print f open paren std e r r comma double quote cat colon can't open percent s backslash n double quote comma star r v close paren semicolon exit open paren one close brand semicolon close curly brace else open curly brace file copy open paren fp close paren semicolon file close open print fp close paren semicolon close curly brace to finish the if and then exit open paren zero close paren semicolon close curly brace to the uh change the finish the main and file copy we is the same from the previous so this program signals errors two ways the diagnostic output produced by fprintf goes to stderr so it finds its way to the user's terminal instead of disappearing down a pipeline pipeline or into an output file the program also uses the standard library function exit which terminates execution when it's called the argument of exit is available to whatever process called this one so the success or failure of the program can be tested by another program that uses this one as a sub process by convention a return value of 0 signals all as well and various nonzero values signal abnormal situations exit calls fclose for each open output file to flush any buffered output then calls a routine named underscore exit the function underscore exit causes immediate termination without any buffer flushing of course it may be called directly if desired section 7.8 line input and output the standard library provides a routine f git s which is quite similar to the getline function we've used throughout the book the call fcds open paren line comma max line comma fp close paren reads the next input line including the new line from the file fp into the character array line at most max line minus 1 characters will be red the resulting line is terminated with backslash zero normally f cades returns line on end to file it returns null our getline returns line length and zero friend to file for output the function f put s writes a string which need not contain a new line to a file f put s open paren line comma fp close paren to show there's nothing magic about the functions like f get s and f put s here they are copied directly from the unix standard io library this code example is on page 155 of the textbook which you can view at www.cc4e.com code char star f get s open paren s comma n comma iop close paren char star s semicolon in n semicolon register file star iop semicolon open curly brace register int c semicolon register char star cs semicolon cs equals s semicolon while open paren minus minus n greater than zero double ampersand open paren c equals get c open paren iop close print close paren not equal eof close paren if open paren open paren star cs plus plus equals c close print equal equal quote backslash n quote close paren break semicolon star cs equals quote backslash zero quote semicolon return open paren open paren c double equals e o f and c s double equals s close paren question mark null colon s close paren semicolon close curly brace the function f put s is as follows f put s open paren s comma iop close paren register char star s register file star iop semicolon open curly brace register int c semicolon while open paren c equals star s plus plus close paren put c open for n c comma iop close paren semicolon close curly brace section 7.9 some miscellaneous functions the standard library provides a variety of functions a few which stand out is especially useful we've already mentioned the string functions sterlin stir cpy stir cat and stir comp here are some others character class testing and conversion several macro rows perform character tests and conversions the function is alpha open paren c close print returns nonzero if c is alphabetic zero if not the function is upper open paren c close paren is returns nonzero if c is upper case zero if not is lower open paren c close paren is nonzero if c is lower case is zero if not is digit open paren c close paren is nonzero fc is a digit zero if not is space open friends c close paren is nonzero if c is blank tab or new line zero if not two upper open paren c close paren convert c to upper case two lower open parenthesis close paren convert c to lower case those all worked on single characters on get c the standard library provides a rather restricted version of the function ungetch which we wrote in chapter four it's called ungetc ungetc open paren c comma fp close paren pushes the character c back onto the file fp only one character of pushback is allowed per file unget c may be used with any of the input functions in macros like scan f get c or get char system call the function system open paren s close paren executes the command in the character string s then resumes the execution of the current program the contents of s depends strongly on the local operating system as a trivial example on unix the line system open for end double quote date double quote close paren semicolon causes the date program to be run it prints the time and date of the day on unix storage management the function c alec is rather like the alec we have used in previous chapters see alec open paren n comma size of open paren object close paren close paren returns a pointer to enough space for n objects of the specified size or null if the request cannot be satisfied the storage is initialized to zero the pointer has the proper alignment for the object in question but it should be cast to the appropriate type as in char star c alec open friend close paren semicolon int star ip semicolon ip equals open paren int star close paren c alec open paren n comma size of open paren int close paren close paren semicolon c free open paren p close print free space pointed to by p where p is originally obtained by a call to see alec there are no restrictions on the order in which space is freed but it is a ghastly error to free something not obtained by calling seahawk chapter 8 shows the implementation of a storage allocator like c alec in which the allocated blocks may be freed in any order this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 8 the unix system interface the material in this chapter is concerned with the interface between c programs and the unix operating system since most c programs are on unix systems this should be helpful to a majority of the readers even if you see on a different machine however you should be able to glean more insight into c programming from studying these examples this chapter is divided into three major areas input output file system and a storage allocator the first two parts assume a modest familiarity with the external characteristics of unix chapter 7 was concerned with a system interface that is uniform across a variety of operating systems on any particular system the routines of the standard library have to be written in terms of the i o facilities that are actually available on the host system in the next few sections will describe the basic system entry points for i o and uni on the unix operating system and illustrate how parts of the standard library can be implemented with them but as an aside the dual nature of c and unix has been on display throughout the book and while this chapter is called the unix system interface in a sense it's less about unix in itself and very much about why c is such a great programming language let me explain before unix and c became the norm operating systems and operating system utilities those commands were used interactively and batch jobs were quite often written in the assembly language of the computer which it was supporting often there were not welldocumented api calls between utilities in assembly language and the assembly language which implemented the operating system smart vendor programmers would just look at the operating system code and write their utility code to work with it this section shows that a language that has features like structures arrays pointers a preprocessor and unions was sufficiently rich so that we could document all the intricate interfaces with an operating system using a relatively high level language and then we could write our utility code like cat in a highlevel language as well in this chapter the authors are almost shouting quit using assembly language to build your operating system and utility code further they are showing us examples designed to answer the question that might come from programmers used to the old ways like can we do x y z and c the author's emphatic answer in the increasingly intricate code samples is c is not a toy language that's only something used by a few att computer scientists in a research lab if you're doing serious system stuff that needs maximum performance and readability and reliability use c this chapter shows c in all its glory and shows why it was such an important language to enable the world of technology we have 40 years later at the end of the chapter we'll talk a little bit about see how c enabled the creation of easier to use programming languages and why it was so important to invent c inspired languages like python ph g and and php and java once c became the established systems programming language section 8.1 file descriptors in the unix operating system all input and output is done by reading or writing files because all peripheral devices even the user's terminal are files in the file system this means that a single homogeneous interface handles all communications between a program and peripheral devices in the most general case before reading or writing a file it is necessary to inform the system of your intent to do so a process called opening the file if you're going to write on a file it may also be necessary to create it the system checks for your right to do so does the file exist do you have permission to access it and if all is well returns to the program a small positive integer called the file descriptor whenever i o is to be done on the file the file descriptor is used instead of the name to identify the file this is roughly analogous to the use of read open paren five comma dot dot dot and write open paren six comma dot dot dot in fortran all information about an open file is maintained by the system the user refers to the file only by the file descriptor since input and output involving the user terminal is so common special arrangements exist to make this convenient in the command interpreter the shell runs a program it opens three files with files descriptors 0 1 and 2 called the standard input standard output and standard error output all of these are normally connected with a terminal so if a program reads file descriptor 0 and writes to file descriptors 1 and 2 it can do terminal i o without worrying about opening the files the user of the program can redirect input output to and from files with less than and greater than for example probe less than in file greater than out file in this case the shell changes the default assignments for file descriptors 0 and 1 from the terminal to the named files normally file descriptor 2 remains attached to the terminal so error messages can go there similar observations hold if the input or output is associated with a pipe in all cases it must be noted that the file assignments are changed by the shell not the program the program does not know where its input comes from nor where its output goes so long as it uses file 0 for input and 1 and 2 for output section 8.2 low level i o read and write this lowest level of i o in unix provides no buffering or any other services it is in fact a direct entry into the operating system all input and output is done by two functions called read and write for both the first argument is a file descriptor the second argument is a buffer in your program where the data is to come from or go to the third argument is the number of bytes to be transferred the calls are and read equals read open paren fd comma buff comma n close brand semicolon and written equals write open paren ft fd comma buff comma n close paren semicolon each call returns a byte count which is the number of bytes actually transferred on reading the return the number of bytes returned may be less than the number of number asked for a return value of zero bytes implies end to file and negative one indicates an error of some sort for writing the return value is the actual number of bytes written it is generally an error if this isn't equal to the supposed number that was asked to be written the number of bytes to be written read or written is quite arbitrary the two most common values are 1 which means 1 character at a time or unbuffered and 512 which corresponds to the physical block size on many early peripheral devices this ladder size will be most efficient even but even a character at a time i o is not inordinately expensive putting these facts together we can write a simple program to copy its input to its output the equivalent of the file copying program written for chapter one in unix this program will copy anything to anything since input and output can be redirected to any file or device this example is on page 161 of the textbook which you can view at w www.cc4e.com code pound include standard stdio.h pound defined buff size 512. this is the best size for pdp 11 unix modern computers it probably should be larger main open print close print open curly brace char buff open square bracket buff size close square bracket semicolon int n semicolon while open paren open paren n equals read open paren zero comma buff comma buff size close paren close paren greater than zero close paren right open paren one comma buff comma n close paren semicolon close curly brace if the file size is not an exact multiple of buff size some read will return a smaller number of bytes to be written by write the next call after that read will return zero it is instructive to see how read and write can be used to construct higher level routines like get char and put char for example here is a version of get char which does unbuffered input this is the second example on page 162 of the textbook pound include stdio.h pound define cmask0377 and this is a mask an octal mask to make sure characters are greater than zero get char open paren close paren open curly brace char c semicolon return open paren open paren read open paren 0 comma ampersand c comma 1 close print greater than 0 close print question mark c ampersand c mask colon e o f semicolon close curly brace c must be declared char because read accepts a character pointer the character being returned must be masked with 0 3 7 7 to ensure that it's positive otherwise sign extension might make it negative the constant 037 is appropriate for ascii and the pdp11 but not necessarily for every other machine the second version of get char does its input in big chunks and hands out the characters one at a time this is the first example on page 162 of the textbook which you can see at www.ccf code pound include stdio.h pound define cmask0377 pound define buff size 512. now we do the buffered version of get char get char open friend close paren open curly brace static char buff open square bracket buff size close square bracket static char star buff p equals buff semicolon static int n equals zero semicolon those variables are static so that they they are long lived and exist from call to call the beginning of the code if open paren n double equals 0 close print open curly brace n equals read open paren 0 comma buff comma buff size close paren semicolon buff p equals buff semicolon close curly brace return open paren open paren minus minus n greater than equal to zero close paren question mark star buff p plus plus ampersand c mask colon eof close print semicolon close curly brace section 8.3 open create close unlink create is not created it's create without the e so i'll just call it creat for now other than the default standard input and output and error files you must explicitly open files in order to read or write them there are two system entry points for this open and create open is rather like the f open discussed in chapter seven except that instead instead of returning a file pointer it returns a file descriptor which is just an int int fd semicolon fd equals open open paren name comma rw mode close paren semicolon as with f open the name argument is a character string corresponding to the external file name the access mode argument is different however rw mode is a zero for read one for right and two for read write access open returns negative one if any error occurs otherwise it returns a file valid file descriptor it is an error to open a file that does not exist the entry point create is provided to create new files or to rewrite old ones fd equals create open paren name comma p mode close paren semicolon returns a file descriptor if it was able to create the file name and negative one if not if the file already exists create will truncate it to zero length it is not an error to create a file that already exists if the file is brand new create creates it with the protection mode specified in the p mode argument in the unix file system there are nine bits of protection information associated associated with each file controlling read write and execute permission for the owner of the file for the owner's group and for all others thus a threedigit octal number is the most convenient format for specifying permissions for example zero seven five five specifies read write and execute permission for the owner and read and execute permission for group and for everyone else to illustrate here a simplified version of the unix utility cp a program that copies one file to another the main simplification is that our version only copies one file and does not permit the second argument to be a directory and this example code is on page 163 of the textbook which you can see at www.cc4e.com code found include stdio.h pound include std live.h pound defined buff size 512 pound defined p mode 0 6 4 4 rw read and write for owner read for group and others int open paren arg c comma arg v close paren the format will be we're going to have two files copy file one file two int argc semicolon char star arc v open square bracket close square bracket semicolon open curly brace int f1 comma f2 comma n semicolon char buff buff size semicolon if open paren arg c not equal to three close paren error open paren double quote usage colon cp from 2 double quote common null close paren semicolon if open paren open paren f1 equals open open paren arg v sub one comma zero close print close paren equal equal minus one close paren error open for n double quote cp colon can't open percent s double quote comma arg v sub 1 close paren semicolon if open paren open paren f2 equals create open print arc v sub 2 comma p mode close paren close paren equal equal minus 1 close paren air open friend quote cp colon can't create percent s double quote comma arg v sub 2 close paren semicolon while open paren open print n equals read open paren f1 comma buff comma buff size close paren close print greater than zero close paren if open paren write open print f2 comma buff comma n close paren not equal and close paren air open paren double quote cp colon right ear double quote comma null close paren semicolon exit open paren zero close paren semicolon close curly brace that's the end of the main program the error routine is going to print the error message air open paren s1 comma s2 close paren char star s1 comma star s2 semicolon open paren printf open paren s1 comma s2 close paren semicolon printf double quote backslash n double quote close paren semicolon exit open paren 1 close paren semicolon close curly brace there is a limit on the number of files which the program may have open simultaneously according any program which intends to process many files must be prepared to reuse file descriptors the retain close breaks the connection between a file descriptor and an open file and frees the file descriptor for use with some other file termination of a program by exit or return from the main program closes all open files the function unlink open print file name close print removes the file name from the file system section 8.4 random access seek and lseek file i o is normally sequential each read or write takes place at a position in the file right after the previous one when necessary however a file can be read or written in any arbitrary order the system call lseq provides a way to move around in a file without actually reading or writing lseq open paren fd comma offset comma origin close paren semicolon forces the current position in the file whose descriptor is fd to move to the position offset which is taken relative to the location specified by origin subsequent reading or writing will begin at that position offset is a long fd and origin are ints origin can be 0 1 or 2 to specify that the offset is to be measured from the beginning from current position or from the end of file respectively for example to append to a file seek to the end before writing l seek open print ft comma 0l comma 2 close print semicolon to get back to the beginning i.e rewind to the beginning l seek open paren fd comma 0l comma 0 parentheses semicolon note that the 0l argument could also be written as open parent long close paren 0. with lseq it's possible to treat files more or less like large arrays at the price of slower access for example the following simple function reads any number of bytes from any arbitrary place in a file get open paren fd comma pause comma buff comma n close paren int fd comma n long pause semicolon char star buff semicolon open curly brace l seek open parenthesis fd comma pause comma 0 close paren semicolon return open paren read open paren fd comma buff comma n close paren close paren semicolon close curly brace in preversion 7 unix the basic entry point to the i o system is called seek seek is identical to lseq except that its offset argument is an int rather than a long accordingly since pdp 11 integers only have 16 bits the offset specified for seek is limited to 65535 for this reason origin values of 3 4 and 5 cause seek to multiply the given offset by 512 which is the number of bytes in one physical block on a 11 and then interpret origin as if it were 0 1 or 2 respectively thus to get to an arbitrary place in a large file requires two seeks the first one selects the block then one which has origin equal to one and then moves to the desired desired byte within the block once again we see c in unix straddling a major improvement in computer hardware in 1978. the natural name for a function to randomly move around a file would be seek but in early versions of unix seek took an integer as the offset but on small word computers like pdp11 have an integer that can't represent a large number so seek used a complex set of rules to handle larger files the only logical thing was to have the offset be along and then for upwards compatibility make a new function called lseq that we use to this day section 8.5 an example implementation of f open and get c let us illustrate how some of these pieces fit together by showing an implementation of the standard library routines f open and get c on the pdp 11. recall that files in the standard library are described by file pointers rather than file descriptors a file pointer is a pointer to a structure that contains several pieces of information about the file a pointer to a buffer so the file can read in large chunks count of the number of characters left in the buffer a pointer to the next character position in the buffer and some flags describing read write mode and the file descriptor the data structure that describes a file is contained in the file stdio.h which must be included by pound include in any source file that uses routines from the standard library it is also included by functions in that library in the following excerpt from the pdp11 stdio.h names which are intended for use only by functions of the library begin with underscore so they are less likely to collide with the names of a user program as a side note i won't read the underscores because they confuse your understanding so the underscores are there in the code you can look at it online but i'm not going to read the underscores so this is basically some definitions for stdio.h pound define buff size pawn define and file 20. type def struct io buff open curly brace char star ptr int cnt semicolon char star base semicolon int flag semicolon int fd semicolon close curly brace file semicolon extern file iob open square bracket end file close square bracket semicolon pound define stdin open paren ampersand iob sub zero close paren pawn define std out open paren ampersand iob sub one close paren pound define std air open paren ampersand iob sub 2 close print pawn define read 01 pound define right o2 pondifying unbuff 04 pound define big buff zero one zero upon define eof zero two zero pondifying air zero four zero pound defined null zero pawn define eof open prin minus one close paren upon define gets e open paren p close paren open paren minus minus open paren p close paren right arrow cnt greater than or equal to zero question mark star open paren p close paren right arrow ptr plus plus ampersand zero three seven seven colon fill buff open paren p close print close print palm define get char open paren close friend get c open paren std high n close paren pound define put c open parent x comma p close paren open paren minus minus open paren p close paren right arrow cnt greater than or equal to zero question mark star open paren p close paren right arrow ptr plus plus equals open paren x close print colon flush buff open paren open paren x close paren comma p close print close paren pound define put char open paren x close paren put c open paren x come std out close paren the f c in macro normally just decrements the counts advances the pointer and returns the character we do this in a very long defined continued by a backslash if the count goes negative however get c calls the function fill buff to replenish the buffer real initialize the structure contents and return a character a function may present a portable interface yet itself contain nonportable constructs cat c masks the character with zero three seven seven which defeats the sign extension done by the pdp 11 and ensures that all characters will be positive although we will not discuss any details we've included the definition of put c to show that it operates in much the same way as getsy calling a function flush buff when its output buffer is full the function f open and fill buff can now be written most of f open is concerned with getting a file opened and positioned at the right place and setting the flag bits to indicate the proper state f open does not allocate any buffer space this is done by fill buff when the file is first read you can look at this sample code from page 167 at www.cc4e.com code i won't read it here because it's pretty long and intricate so you'll have to go watch it online or view it online back to the text the function fill buff is rather more complicated the main complexity lies in the fact that phil buff attempts to permit access to the file even though there may not be enough memory to buffer the i o if the space for a new buffer cannot be obtained from cat c alec all is well if not filbuff does unbuffered i o using a single character stored in a private array the first call to get c for a particular file finds a count of zero which forces a call a fill buff if phil buff finds that the file is not open for reading it returns eof immediately otherwise it tries to allocate a large buffer and failing that a single character buffer setting the buffering information in flag appropriately once the buffer is established phil buff simply calls read to fill it and sets the count and pointers and returns the character at the beginning of the buffer subsequent calls to fill buff will find a buffer already allocated the only remaining loose end is how everything gets started the array iob must be defined initialized and initialized force stdin std out and std err file iob open square bracket and file close square bracket equals open curly brace open curly brace null comma 0 common null comma underscore read comma 0 comma close curly brace comma and that's the standard in the next one is open curly brace null comma 0 common null comma underscore right comma 1 comma close curly brace comma and that's the standard out definition the the sub 1 position and then the next one is open curly brace null comma 0 common null comma underscore right vertical bar underscore on buff comma 2 close print and that is the standard error entry close curly brace semicolon the initialization of the flag part of the structure shows that std standard in is to be read standard out is to be written and standard out is to standard error is to be written unbuffered section 8.6 example listing directories i would note that the sample code in section 8.6 shows how we can write applications like ls to interact with directories in a unix file system however the code in this section is not portable to modern unix systems so we'll leave the code as it is in this section it's a good idea to read the code and get an outline of how to work with directories on unix if you want to write code to handle directories you'll need to consult more modern documentation given the complexity of the code in this section we are not going to include it in the copy of this book in this particular media similarly section 8.7 example a storage allocator consists of a lot of really complex code and so we will leave that for you to see online at www.cc4e.com book slash chap08.md dynamic memory is hard modern languages like python ruby and java give us high level objects like strings lists and dictionaries these structures automatically expand and correct contract and can be copied into a temporary variable used and then discarded modern languages depend on efficient memory allocation a problem when dynamic memory is heavily used is a fragmentation of the free space you can get to the point where you have plenty of memory but each of the free memory areas is so small that you can't allocate a new memory block when this happens the runtime implementations of these systems run a step called garbage collection where everything pauses and free areas are moved around to make sure that the free memory is in a few large contiguous areas rather than many small noncontiguous areas language developers have been improving garbage collection algorithms for the past 40 years and there is still much work to do now that the authors have established all the reasons that make see the ideal portable systems programming language which i hardly agree with it's time to talk about where c comes up short as a general purpose language for those of us not working on the source code to linux the most challenging aspect of c is the lack of dynamic structures that we can use without the need to carefully allocate use without the regard to the length of dynamically allocated memory and not worry about calling c free every single time we call c alec if a programmer without strong programming skills a good understanding of a testing regimen and a proper defensing defensive programming attitude is let loose in c they will invariably write poor code their c code will make poor use of resources run the system out of memory or produce code that is riddled with security holes and bugs that seem to randomly appear a decade after c emerged and became popular guido van rossum designed a language called python it was one of a number of languages that was built using c and added an objectoriented layer that greatly simplified writing programs that used dynamic memory and added guard rails so programmers did not unintentionally write dangerous or insecure code the key valueadd features that make python more appropriate for general purpose programming are the string object list object and dis dict object that handle all aspects of creating and using variables and collections of variables the book has one foot note unix is a trademark of bell laboratories but of course there's more actually the trademark for unix is no longer owned by at t it is owned by the open group but that is a story for another day the unix story arc includes att unix berkeley software de distribution which we call bsd sun microsystems minix linux the open software foundation unix international and others the short version of that story is that at t unix was poised to take over the world as an open source product long before the words open source were ever spoken at t should have and could have defined open source and changed everything by the early 1980s except for a few at t intellectual property lawyers it took over a decade for computer science to pivot away from a nearly exclusive focus on c and a t unix the linux operating system was open source from its inception and became the standard barrier for unixlike operating systems and continues to be the way most of us encounter quote unix it is almost certain that the computer that served this media to you runs linux but that is a story for another time in 1978 unix and c were in their glory days and showed the entire computer science field and technology industry the right way forward from that point forward hardware could evolve independently from software with the systems programming language and operating systems patterns sorted the previous 40 years have seen an amazing innovation in hardware capability and performance this 1978 c programming book by brian w kernighan and dennis m richie was the big bang moment for modern computing and computer science we owe them a debt of gratitude for making whatever we do today possible if you have made it to the end of this chapter in this book as your narrator i would like to congratulate and thank you it has been an honor to record and narrate a book of such historical significance for you cheers this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications you
