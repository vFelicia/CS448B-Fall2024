With timestamps:

00:00 - [MUSIC PLAYING]
00:16 - COLTON OGDEN: Hello, everybody.
00:18 - Welcome to GD50 Lecture 2.
00:20 - This is Breakout.
00:22 - And interestingly, CS50 has
a history with Breakout,
00:25 - so I pulled this up today.
00:26 - This is Pset3 in 2015, 2014.
00:30 - It was an implementation of
Breakout using the Stanford Portable
00:34 - Library, which was a
sort of Java library
00:37 - that we were able to get C bindings for.
00:40 - And so students were able
to actually implement
00:42 - a game what was at the time the CS50
appliance, which is a Linux distro.
00:48 - But suffice to say that was--
00:49 - oh, a funny story also.
00:51 - I happened to also write the lasers for
this implementation back in the day.
00:56 - And I think that was one
of the first bits of code
00:59 - I got my hands dirty with
when working with CS50.
01:02 - So today in the context
of Breakout, we'll
01:04 - be talking about a few different things
that we haven't talked about yet.
01:07 - Sprite sheets being chief
among them most likely.
01:10 - At least the most visibly so.
01:12 - So sprite sheets are simply a way
of taking an image, a large image,
01:15 - and rather than splitting it, rather
than loading individual images
01:19 - for all of your different
things in the game,
01:21 - whether it's your aliens or your paddles
or whatnot, you can put everything
01:25 - into one sheet and then just sort of
index into that sheet using rectangles,
01:30 - quads.
01:30 - We'll talk about soon.
01:31 - Which will allow you to just
draw a subset of that image,
01:33 - and therefore condense all of your
artwork just into one piece, one file.
01:37 - We'll be talking a little bit
more about procedural generation
01:41 - in the context of Breakout.
01:42 - And in this case, we'll be laying
out all the bricks in the game world
01:45 - procedurally.
01:46 - So having instead of the same
set of colors, in this case,
01:50 - the standard layout is to have a bunch
of the same colored bricks row by row.
01:55 - We'll actually implement a
dynamic generation approach
01:58 - and have a bunch of different
cool layouts we'll see.
02:00 - And it's actually quite simple to
achieve pretty believable results.
02:04 - We'll manage state a little
bit better in this game.
02:07 - So before we sort of had a
couple of global variables
02:10 - and we didn't really have the concept
of a per state or a global state
02:14 - that we were cleanly sort of
sharing between all of our states
02:18 - for our state machine.
02:19 - But to avoid having sort of like
a polluted global name space
02:22 - and to just sort of keep
things a little bit cleaner,
02:24 - we'll end up taking all of the important
variables for our code like, you know,
02:28 - the player and any other entities.
02:29 - The bricks, the ball.
02:30 - And rather than keep them
in our main [INAUDIBLE],,
02:33 - we'll end up shifting them.
02:34 - We'll sort of transfer them to
and from the different states
02:37 - via the state machine's enter method.
02:41 - We'll actually have levels.
02:42 - So a progression system.
02:43 - So start at level one, go up.
02:45 - And then with each level,
we'll implement a scale
02:48 - in terms of the
generation of the bricks.
02:51 - So we'll get higher tiered bricks
and more points as a result.
02:54 - We'll have a health system.
02:55 - So hearts, in a similar
fashion to Legend of Zelda.
02:58 - Particle systems, which are a
very important aesthetic component
03:02 - to 2D games and 3D games.
03:04 - Particle systems basically
being a bunch of spawned images
03:07 - that you sort of cluster, you
put into a little spawner,
03:10 - emit them in a certain way, and
color them, perform math on them,
03:15 - and get sort of believable
effects like fire and smoke
03:17 - and all these other things
that would otherwise
03:19 - be not easy to do
using simple animation,
03:24 - but trivial with a particle system.
03:26 - We'll do a little bit more complicated
collision detection with our paddle
03:31 - and with our bricks
than we did with Pong.
03:33 - And then we'll also
talk lastly about how
03:34 - we can save data locally to our computer
so that when we close the application
03:38 - and run it again, we end up having
a persistent high score rather
03:42 - than just something that's volatile.
03:44 - So first though, I would like
to demo today's finished game.
03:49 - So if anybody would like to demo from
the audience, that would be nice.
03:55 - Go ahead and come up.
03:57 - I'll go ahead and cue it up for you.
04:02 - What's your name?
04:03 - JEREMY: Jeremy.
04:03 - COLTON OGDEN: Jeremy.
04:04 - Colton.
04:04 - JEREMY: Nice to meet you, Colton.
04:05 - COLTON OGDEN: Nice to meet you.
04:06 - So we're going to go ahead
and run Breakout here.
04:13 - And so it uses the arrow keys.
04:15 - So if you go ahead
and press up and down,
04:17 - you'll see you can move between the
start and the high score screen.
04:19 - So they're two separate screens.
04:21 - So go ahead and--
04:22 - here we have when you start,
you can choose a paddle.
04:24 - So rather than just the same old
paddle every time, you get to select.
04:27 - And as you can see here, he chose green.
04:29 - So he gets the green paddle.
04:31 - These bricks all procedure generated.
04:32 - So if he runs the application,
they'll be completely different.
04:36 - And as is the classic
formula, the ball moves
04:39 - between the bricks and the paddle.
04:41 - When it hits a brick, if
it's of a certain color,
04:44 - it'll either get destroyed--
in this case, if it's blue,
04:46 - it's the base color brick.
04:48 - So it's the lowest value.
04:50 - And if it's higher
than blue, it'll end up
04:52 - going down a color depending
on which color it is.
04:55 - I believe it goes blue,
green, red, purple, yellow.
04:58 - So anything higher
will get shifted down.
05:01 - And then the player amasses
points, as you can see top right.
05:04 - Score.
05:04 - And notice also the three hearts.
05:06 - That will be the player's health.
05:07 - So if he were to lose
on purpose possibly,
05:13 - we can see he gets another message
that's saying press Enter to serve.
05:18 - His hearts have gone down by one.
05:20 - So now he's got two out of three health.
05:23 - And so eventually if he were
to by chance lose completely--
05:32 - oh.
05:35 - That's honestly the most
fun part about Breakout
05:37 - is just getting it caught
in a bunch of stuff.
05:39 - But you can see we go
to a Game Over screen.
05:41 - It shows your final score.
05:42 - And then you can press
Enter and it will--
05:46 - oh.
05:46 - I must have had a bug.
05:48 - But that should take you back to the--
05:51 - if in the event that
you have a high score,
05:53 - it'll take you to enter a high score.
05:55 - And if you don't have a high score,
it'll take you back to the Start menu.
06:00 - So I made a couple of
last minute changes.
06:02 - Unfortunately I must have
left something in there.
06:04 - But that's Breakout in a nutshell.
06:07 - Our goal today will be to implement
basically all the functionality we saw.
06:10 - Oh, we didn't take a look
at the high score screen.
06:12 - So let's take a look at
that really quick as well.
06:14 - So here at the title, you can see
we have Start and High Scores.
06:17 - Oh, man.
06:18 - OK.
06:19 - I must have screwed something up.
06:20 - So I'm going want to go
[INAUDIBLE] Breakout 12.
06:24 - OK.
06:24 - Sorry.
06:25 - I apologize.
06:25 - I'm going to fix that.
06:26 - But it should show this menu here where
you will have a list of all your names
06:31 - that get loaded from a file and
will output your score accordingly.
06:35 - And in the event that
you get a new high score,
06:41 - you'll get to enter
your name after that,
06:44 - and then it will end up
saving it to another file.
06:46 - And when we get to that
point I'll try and fix it
06:48 - so that we can actually
see what it looks like.
06:51 - So let's go back to these slides here.
06:53 - So this is the overall
state, flow of our game.
06:55 - So as you can see by me marking
it out in a highlighted color,
06:59 - we start off in the StartState.
07:00 - And this is all stuff
we've covered before.
07:01 - Just the state machine.
07:03 - It's a little bit more
complicated than Flappy Bird.
07:05 - We have eight states as
opposed to I think it
07:07 - was four or five in the last lecture.
07:10 - And the arrows illustrate which states
can move in between other states.
07:13 - So as we saw, the StartState can
move via the up and down arrows
07:17 - in the HighScoreState.
07:18 - It can move between the
HighScoreState and back.
07:20 - So when you go into the
HighScoreState, press Escape,
07:23 - go back to the StartState.
07:25 - The StartState also has
an arrow branching off
07:27 - to the left going down
to the PaddleSelectState
07:29 - where we saw the user is able
to select a paddle to use.
07:32 - Once they've selected a paddle,
we'll go to the ServeState.
07:35 - They'll be able to serve
the ball at their leisure.
07:37 - And then it will go back and
forth between the PlayState.
07:40 - So if they end up
taking damage, the ball
07:43 - goes below the surface of the screen,
they'll go back to the ServeState
07:47 - again so they can reorient themselves.
07:49 - If they're in the PlayState
and they end up scoring,
07:53 - clearing the whole entire
set of bricks, they'll
07:55 - actually get taken to the VictoryState.
07:57 - And the VictoryState is
where we increment the level
07:59 - and we also regenerate the level.
08:00 - And the VictoryState goes
back to the ServeState,
08:02 - and then we repeat
that whole loop again.
08:04 - In the PlayState if they
are to get a Game Over,
08:08 - they'll go to the GameOverState,
it'll tell them their score,
08:10 - and then they'll go to
the EnterHighScoreState
08:13 - depending on whether
they have a high score.
08:14 - And if not, as seen by the arrow
that goes up and to the left,
08:18 - they'll actually go
back to the StartState.
08:19 - And then the EnterHighScoreState will
also go back to the HighScoreState
08:22 - so that they can see
once they've entered
08:24 - their high score, their score relative
to the other scores in the list.
08:27 - So in Breakout0, which
we're going to look at now,
08:29 - we're going to do some very basic stuff.
08:31 - So this is the Day 0 update as always.
08:34 - I'm in Breakout0 right now.
08:37 - Yes, I am.
08:39 - So what we're going to do is we're going
to look at first thing here, line 27.
08:42 - So before what we were
doing in our application
08:47 - is having basically a lot of files at
the top level and sort of losing track
08:51 - of what we were doing potentially.
08:53 - Especially as you start
adding more and more files
08:55 - and you've got like 50,
100 more files, that's
08:58 - something that's obviously
not maintainable.
09:00 - So the solution there,
just put them in folders
09:02 - and then keep track of everything.
09:04 - Keep them organized.
09:05 - And that's a major thing that
we're going to start doing.
09:07 - And on top of that, we're
also going to, in our code,
09:10 - keep things a little bit more modular.
09:11 - And that's why we have this
file source slash dependencies,
09:15 - which we'll take a look at in a second.
09:18 - We've allocated a bunch
of global tables here.
09:20 - So we're taking the
design decision of even
09:23 - though I mentioned that we will be sort
of taking a lot of the global variables
09:26 - out of our application
assets, we're going to keep
09:29 - all of those in some global variables.
09:31 - And we'll see in the future how we
can maybe implement a resource manager
09:34 - class that takes care of this for us.
09:36 - But for now, for simplicity's
sake, in love.load,
09:38 - we're just going to have a few
global tables that contain,
09:41 - in this case, global fonts.
09:43 - So by key, we can index small,
medium, and large fonts,
09:46 - which are just new fonts
at different sizes.
09:48 - 8, 16, 32.
09:49 - And we're using it.
09:50 - We have a fonts folder now instead of
just keeping it at the parent level.
09:53 - We're going to set it to small.
09:54 - We have global textures.
09:55 - So background, main,
arrows, hearts, particle.
09:59 - So we have the background, which
was the background of our screen.
10:02 - Main has all of our bricks,
paddles, the balls, et cetera.
10:05 - Arrows are going to be for
the paddle select screen.
10:07 - The two left and right arrows.
10:09 - Hearts are going to be for our health.
10:10 - And then particle is a single,
small, tiny little texture
10:13 - that we'll use to spawn all the
particles in our particle systems
10:16 - later on as we get towards
the end of the demonstration.
10:20 - So this is push.
10:21 - We're setting it up just like normal.
10:22 - Nothing new there.
10:23 - Except the virtual width, virtual
height, and all that stuff,
10:26 - those have been moved out, if we
look into source in a constants file.
10:29 - So this file here, instead of
having all the constants in main,
10:32 - it kind of makes sense just
to take them out, put them
10:35 - in a file called constants.lua,
and we can sort manage all that.
10:39 - We can know immediately when
we're looking at capital window
10:42 - width, window height, et cetera.
10:43 - And these are all constants.
10:44 - If you have a constants
file, we just can more easily
10:46 - track it rather than having to
grab through all of our files
10:48 - to try and figure out
what we were looking at.
10:53 - And the constants are used here
in our set up screen as before.
10:59 - And then another sounds
global table, just as before.
11:03 - We have a bunch of
different sound effects.
11:05 - I've separated the music
from the sound effects
11:07 - just so that we can see at a
glance, oh, this is the music,
11:10 - these are the sound effects.
11:11 - Pretty straight forward.
11:12 - We have a state machine, as always.
11:14 - And we're just going to use a
StartState for this demonstration.
11:18 - Setting it to Start.
11:20 - Love.resize, love.update.
11:22 - These are all functions
we've seen before.
11:23 - Nothing too new.
11:25 - Love.keypress.
11:25 - We have a global input table.
11:26 - So as in the case of Flappy Bird, we
can index into that input table anywhere
11:30 - in our application and call
love.keyboard.wasPressed[key],
11:34 - which allows us to take input
exclusively from main and use it
11:38 - in other modules.
11:40 - Here we're drawing the--
11:42 - so this is the actual rendering code.
11:45 - And we're doing this in our love.draw
as opposed to a specific state
11:49 - because this is actually
going to apply to all states.
11:51 - We're always going to
have this background.
11:53 - So rather than duplicate
it over and over again,
11:55 - in this instance, this
minor bit of code,
11:58 - we're going to display the
background behind all the states.
12:02 - So all the states are going
to render over this background
12:04 - and make it seem a little more cohesive.
12:07 - We're going to draw at
0, 0 without rotation.
12:09 - And then this bit of math
here, the virtual width
12:11 - divided by, and then background width
minus one, end up being a scale factor
12:15 - so that we can always scale
it to be our virtual width.
12:18 - Because the texture by default is some
amount smaller than our actual window
12:22 - or our actual virtual width and
height, but by dividing virtual width
12:26 - by whatever the background
width of that image is by one,
12:29 - we'll get a scale factor because
virtual width is larger than the image.
12:32 - We'll get a scale factor on X and Y
that equates to it completely stretching
12:37 - to fill our virtual width and height.
12:41 - And recall that these two parameters
are the scale on the X and the Y.
12:44 - So it's going to be some, like, one
point something or two point something.
12:47 - Whatever it takes to end
up filling the screen.
12:50 - And then lastly here,
the new bit I implemented
12:52 - is just a display of frames per
second function, which I think
12:55 - is kind of important generally,
and it's very easy to do.
12:58 - I don't recall, I don't think
we talked about it yet, but just
13:00 - love.timer.getFPS.
13:02 - And then I just draw in
the top left in green
13:04 - so that we can see it throughout all
of our iterations of the game, what
13:07 - are frames per second are.
13:08 - If you want to monitor without having to
look through your terminal or anything
13:12 - like that, just displaying
at the top, it's
13:13 - standard practice in a lot of games.
13:16 - If you've gone to the
debug console or whatnot
13:18 - or sort of looked into
some of the hacks,
13:20 - you'll see that in a lot of places.
13:23 - So I talked earlier
about dependencies.lua.
13:25 - So this ties in as well to our effort
to sort of modularize everything,
13:30 - keep everything organized.
13:31 - Instead of requiring
everything at the top of main,
13:34 - let's just put it all
in a file and then we'll
13:36 - know at a glance what we're requiring
and we don't have to look through main
13:40 - and make main 100 lines, potentially
a lot more than it needs to be.
13:44 - So requiring push, requiring class.
13:47 - Same as we've done before.
13:49 - Require source.constants.
13:50 - We have access to those.
13:51 - Require StateMachine, and
then BaseState and StartState.
13:55 - So let's go ahead and take
a look at our StartState.
13:58 - So I put states in a
subfolder of source.
14:01 - This is another effort to
sort of keep things modular.
14:03 - In this particular project, we won't
have a lot of nested folders of code,
14:08 - but I decided to put the
states in their own folder
14:10 - just so easily you can get
access to all your states.
14:14 - So we'll look at
StartState here on line 21.
14:18 - So recall in the StartState, we just
had Breakout in the center of the screen
14:21 - and then we had Start
Game and High Scores.
14:24 - So the user was able to highlight
which state he wanted to look at.
14:27 - So we need to keep track of
which one is highlighted.
14:29 - So all this variable's
purpose is just to keep track.
14:32 - So one or two.
14:33 - One being Play Game, and
two being High Scores.
14:39 - And then here if we press
up and down, then we--
14:43 - because there's only
two options effectively,
14:45 - you can just flip whatever
highlight is with one or two.
14:48 - If you have a list of
options that's more than two,
14:50 - you'll need to increment one
until it gets to whatever
14:52 - X is, your number of list options.
14:55 - And then if you press
down at that point,
14:57 - you should flip back up to the top.
14:58 - And the same holds true for
whether you're at option one.
15:02 - You should go flip, rotate
to the bottom of your list
15:05 - so that it looks as if you've
gone all the way around.
15:08 - And-- then we're just playing
a sound here when we do that.
15:11 - We have a
love.keyboard.wasPressed[escape] call
15:14 - here.
15:14 - It's not global anymore because there
are some states in our application
15:18 - where we might want to press
Escape to actually go backwards,
15:20 - and we'll see that.
15:22 - And so rendering here.
15:23 - We render Breakout with a large font.
15:25 - Now that we can access G fonts at
large key in the center of the screen,
15:29 - set medium font.
15:30 - And then we're going to render our
two text fields one after the other.
15:36 - But if highlighted is
equal to one, then we're
15:38 - going to set it to some blue
color, which is one of three--
15:40 - 255, 255, 255.
15:43 - And then render it.
15:44 - And then make sure to reset the
color after that because recall
15:47 - love 2D is sort of like a
state machine in its own right,
15:50 - where if you set the color to
something, whatever you draw and render
15:53 - after that, be it images or
text, will adopt that color.
15:56 - So having everything
be 255, 255, 255, 255,
16:00 - which is pure white,
completely opaque, has
16:02 - the effect of drawing
everything completely opaque.
16:04 - But if you don't do that, your images
or whatnot that you draw afterwards
16:07 - will be tinted or transparent, which
you most of the time don't want.
16:10 - But you might sometimes want
that, and we'll actually
16:13 - see that in the PaddleSelectState.
16:14 - And same thing holds true here.
16:15 - If highlighted is two,
do the exact same thing.
16:19 - And so if we run this
application, which is mainly
16:22 - just a subset of what we saw
before, we can move up and down
16:26 - between Start and High Scores.
16:28 - But if we press Enter
on any of them, nothing
16:30 - happens because we have no event
handlers actually taking care of that.
16:33 - But we have the image scaled to the
screen, we have Breakout in the middle,
16:37 - and we have our two menu options there.
16:40 - So Breakout1.
16:41 - So this is where we start to dive a
little bit into sprite sheets, which
16:46 - is a major component of
game development, 2D game
16:49 - development that we'll be looking at
in the future and in this application.
16:53 - But a sprite sheet is just,
ultimately, rather than have--
16:57 - I don't know how many images there
are on this sprite sheet here.
17:00 - But however many of
these files, just have
17:03 - one file put them all together,
and then using rectangles, define
17:07 - where all the different sprites are.
17:08 - And then when we want to
draw, use those rectangles
17:11 - and just tell
love.graphics.draw, I want you
17:14 - to draw this texture, this
sprite sheet, but I want
17:16 - you to draw just this section of it.
17:19 - You'd pass it in a quad, which is just
simply rectangle with height, X and Y.
17:23 - And love 2D will know, OK, I'm going
to draw the image, but only this bit.
17:27 - And it has the effect of looking as if
you're only drawing tiny little images
17:31 - as opposed to one monstrous image.
17:34 - And the functions that are
relevant for us to look at
17:36 - are love.graphics.newquad, which
takes an X, Y, width, and a height.
17:41 - And also a dimensions object,
which you get from an image.
17:45 - We'll see that.
17:46 - And all that basically is, I believe, is
just an X, Y, width and height as well.
17:50 - Or just a width and a height,
rather, from whatever image
17:54 - you want to create quads for.
17:57 - And then love.graphics.draw,
we've already seen it,
18:00 - but this is a different signature.
18:01 - This has texture, quad, X, Y.
Quad being the second argument.
18:06 - And when it takes in this
quad, it knows to only draw
18:09 - that defined rectangle
of image to the screen.
18:13 - And so we'll go ahead and
take a look now at Breakout1.
18:17 - AUDIENCE: [INAUDIBLE]
18:22 - COLTON OGDEN: The question
was, are there any tools
18:24 - so that we don't have to guess where
the quad is when we're doing the sheet?
18:28 - Yes, there are a lot of the time.
18:31 - I looked and saw a couple, but I
haven't tested them thoroughly myself.
18:35 - For simpler examples
like this, it's usually
18:37 - easy enough to programmatically do it.
18:39 - But yeah, when you get into
having giant sprite atlases where
18:42 - you have especially things that
are not necessarily symmetrical
18:46 - or rectangular looking even though they
still need to be defined rectangularly,
18:50 - it's often best to use a tool like that.
18:54 - There are, I do believe,
I just haven't used them.
18:57 - I can bring it up in a future
lecture so we can discuss.
19:03 - Any other questions before
we carry into Breakout1?
19:08 - All right.
19:09 - So I'm going to go ahead and
open up the very first thing
19:12 - we should look at on Breakout1.
19:14 - In the source directory,
we have a new file.
19:18 - And from here on out,
I'm going to assume,
19:20 - we're going to always assume that
when we introduce a new file,
19:24 - we're going to include
it in dependencies.lua.
19:28 - And so in this case, all we need to
do is just say require source/util.
19:32 - And as you can see, we're also adding
a PlayState to this demonstration.
19:38 - But from here on out, I won't
make mention of us actually
19:41 - adding it to our project.
19:42 - So util.lua is the module
that contains the code
19:47 - we're going to use to actually generate
quads for a given sprite sheet.
19:51 - And this function, all it does, is
it takes an atlas or sprite sheet--
19:54 - the names are synonymous.
19:56 - You'll hear them both.
19:57 - Or we pass it an Atlas, we pass it
the width of the tile that we want
20:02 - and the height of the tile that we want.
20:04 - It's going to get the width and
the height of the sheet here.
20:07 - So every image has a function
called get width and get height,
20:11 - so we're just going to do that.
20:13 - And specifically the sheet
width and sheet height
20:16 - are the width of the image divided
by tile width and tile height.
20:19 - So we know how many times we need
to iterate over the sprite sheet
20:23 - to generate a rectangle.
20:24 - We're dividing it up based
on the size of our tiles.
20:29 - And then we just basically do
a simple nested four loop here.
20:32 - We start a counter and a sprite sheet.
20:34 - This sprite sheet is going to be a
table that holds all of our quads.
20:37 - We just say for Y, get zero.
20:39 - Sheet height minus one.
20:40 - So starting at the top left, going down.
20:44 - And starting at the top going
down, and then x equals zero,
20:46 - starting at the left going right.
20:50 - At sprite sheet, sheet counter,
which is one here because in lua,
20:55 - tables are one indexed.
20:57 - We're going to create a new quad at X
times tile width, Y times tile width.
21:02 - Give it the width and
the height of our tile.
21:05 - So just whatever we passed
into our function signature.
21:07 - Here it will often be
in this case be 16 by 32
21:10 - because that's the size of the bricks.
21:14 - And then we pass in the last
parameter that we saw in the slide,
21:17 - which is atlas:getdimensions.
21:19 - And then we just increment
our sheet counter here.
21:21 - And then at the end of this, when
we're all done, we'll return this.
21:23 - We'll have a table of
quads that we can then
21:25 - use that are in a sort of one, two,
three, four, five, six, seven, eight.
21:31 - Well, I should say, one, two, three,
four, five, six, seven, eight top
21:34 - left to bottom right of all the
sprites in our sheet to make it
21:38 - super easy to look at.
21:40 - We have another function here.
21:42 - Lua doesn't by default, have a slice
function, but we are just adding to it.
21:45 - Table.slice.
21:47 - It takes the table a first, the first
entry in the table that we want,
21:52 - the last entry, and then
the step between them.
21:54 - Just like Pythons slice function,
it just iterates over the
22:00 - for loop, which is first till one.
22:02 - So one by default. Until the last or
until whatever this sort of number sign
22:10 - is the size of a table, which I
don't think we've introduced yet.
22:13 - But basically, if we pass in last,
it'll stop there, otherwise just
22:18 - assume we want the whole entire table.
22:20 - And then this comma here at
the end, which has step or one,
22:25 - you can pass in a step at the end
of a for loop as a third argument,
22:28 - and that will be however much increments
or decrements the loop that you're in.
22:33 - So by default, just one.
22:35 - We go one, then we go to
two, then we go to three.
22:37 - But you can set it to negative one.
22:39 - And so if you say four i
gets three to one minus one,
22:42 - you'll go three, two, one.
22:44 - And you can't do normally a
step, which is what we do here.
22:50 - No, you can do a step,
but you can't slice,
22:52 - which is why we have here sliced at
number of slice plus one gets table i,
22:58 - and then eventually we return slice.
22:59 - So it just returns just a segment
of whatever table we're in.
23:04 - And then the important function
here that we're actually
23:07 - going to use in our application,
we're going to generate quads paddles.
23:11 - And so this takes X and Y, 0 and 64.
23:15 - And if we look back at
our paddles here, we
23:19 - can see that we have
various different sizes.
23:22 - So we have a small one, a medium one, a
large one, and then a really large one.
23:25 - So if we want to get every single
paddle in our sprite sheet,
23:30 - small, medium, large, giant,
notice that we have four blocks
23:33 - and within each of those blocks
we have four different sizes.
23:36 - So we can just iterate
over this four times
23:38 - and then just define whatever
the size of this rect
23:41 - is, that rect, that rect, and that rect.
23:43 - And we'll see the math for it here.
23:45 - If I go zero to three, for
i, get zero till three.
23:50 - We're going to go ahead
because that will give us four.
23:53 - So that's how many times we want
to iterate over the sprite sheet
23:57 - to get the separate quads.
24:00 - We'll get the smallest one.
24:01 - So quads counter.
24:03 - We initialize counter to one.
24:05 - Gets love.graphics, that new
quad at X, Y, with the 32 and 16.
24:11 - Oh, and X and Y default at 0
and 64 here because the note--
24:16 - recall that these are all 16 tall here.
24:21 - So we're starting Y at 64
so that we start right here.
24:24 - And we're starting X at zero
because it's on the left side.
24:28 - So we'll do that.
24:29 - We'll increment counter.
24:31 - Get it at 32 wide by 16 tall.
24:34 - Those are the actual
dimensions of the smallest one.
24:36 - The same exact logic applies
for medium and for large.
24:40 - Only that we're adding 32 and
then we're making it size 64,
24:44 - and then we're adding 96 to X at size
96 because they're getting wider,
24:49 - but they're also offsetting
more to the right.
24:52 - And then the last bit is pretty much the
same thing as before, except now we're
24:56 - going Y plus 16 back to X because we've
gone down a row in our sprite sheet
25:01 - The paddle width at that point
is 128, but still 16 pixels.
25:06 - And then here at the bottom because
we want to do this four times,
25:13 - we want to go through the
chunks are effectively 32 pixels
25:16 - because we're going 16, 16, 16, 16.
25:19 - We're going to add 32 to Y and then
go to the next set of four paddles.
25:23 - So this is how we're effectively
getting all of the paddle sprites,
25:26 - and they;re going to be stored one
through X where I believe X is 16.
25:30 - So we'll have 16 quads
defined in our sprite sheet
25:34 - thereafter that we can then return.
25:36 - So I'm going to go back to
main.lua now on line 64.
25:43 - Here we have a new global
table called gframes.
25:47 - We'll be able to access this
anywhere we want to draw stuff.
25:49 - And it's just the same
thing that we just saw.
25:52 - Generate quads paddles, and we
just pass it in our main texture.
25:55 - And our main texture is this.
25:57 - This is what our main
texture looks like.
25:59 - And then we're going to index it.
26:01 - We're going to say it
gets the key paddles,
26:04 - because in that particular table
was just the quads for our paddles.
26:10 - So in the future, we just need to call
love.graphics.drawtexture and then
26:14 - index into gframes paddles
at whatever paddle we want.
26:19 - And that's how we can keep track of
what we want to draw paddle wise.
26:24 - And in this particular demo
we have a new paddle class
26:28 - because paddle is a thing in our game.
26:30 - We can represent it as sort
of a class or an object.
26:33 - So we'll define a class for it.
26:36 - Everything is pretty simple thus far.
26:38 - Gets an X and a Y. Dx
is zero with height.
26:41 - Skin.
26:42 - The skin is going to
be what color it is.
26:45 - We need to keep track of that.
26:47 - And then the size, because size
will be how we sort of offset
26:51 - into our paddles, our quads, because the
sizes are small, medium, large, giant.
26:56 - One, two, three, four times four.
26:58 - So one, two, three, four for
the first set and then five,
27:00 - six, seven, eight for the second set.
27:03 - Those are all sort of by color.
27:04 - So we can just multiply skin times--
27:07 - or we can multiply whatever
our size is by skin
27:12 - and that will give us the current frame,
the current quad that we want in order
27:15 - to draw to the screen.
27:18 - And then on line seven--
27:21 - so this is keyboard input here.
27:23 - Stuff that we've seen before.
27:24 - If we're pressing left or right,
then the paddles should move.
27:28 - Dx should be set left or right.
27:31 - We want to clamp it.
27:32 - We saw this, we've seen this as well.
27:33 - Clamp the input to the left and
the right side of the screen.
27:37 - If the dx is less than zero, do
math.max and math.min otherwise
27:42 - if we're moving to the right.
27:43 - And then here, this is actually
where we tie it all together
27:46 - and we actually use the quads to
draw something onto the screen.
27:49 - So we're calling love.graphics.draw
just our texture, our main texture.
27:54 - And then gframes at paddles at
our current size, which is two.
28:01 - We want to by default have the
medium size plus four times whatever
28:07 - our skin is, minus one.
28:10 - So if our skin is one, which is the
blue skin, we won't add anything to it.
28:18 - It'll just be four times zero.
28:20 - But if we have the next
one, it'll be two minus one,
28:22 - so we'll end up adding four to that.
28:24 - And because we're adding four to
it times whatever that skin is,
28:28 - it will just basically
put us four quads in,
28:32 - which is the next, the exact
same paddle, but the next color.
28:36 - And then lastly what we'll
look at here is the PlayState.
28:41 - So we had just the
StartState before, but now we
28:44 - want to actually test to make
sure we can draw a paddle,
28:47 - move it around the screen.
28:48 - So we're going to implement
a simple PlayState here.
28:50 - So on line 20, we're just
calling self.paddle gets paddle.
28:53 - We're initializing a new paddle object.
28:56 - And then we're keeping
track of also this
28:58 - is a simple, like, pause demonstration.
29:01 - If self.paused, then-- actually yeah.
29:06 - Did I say self.paused?
29:06 - I did.
29:07 - OK.
29:07 - I just don't initialize it to anything.
29:09 - I should have set
self.paused to false here.
29:15 - If self.paused, we're going to test
to see whether we're pressing space,
29:19 - and if we are, unpause it.
29:22 - Otherwise, basically just do
the same exact thing in reverse.
29:26 - If we press space, pause the
game, play a sound, et cetera.
29:31 - Here on line 39, we're just going
to call update on the paddle.
29:34 - Which, just remember, test
for left or right input.
29:37 - Here we want to be able
to escape the game,
29:38 - so we're going to have
a handler for escape.
29:41 - Render the paddle on lines 47,
which will do the love.graphics.draw
29:45 - with a quad as we saw
before, but it'll use
29:47 - the skin and the size of that paddle
to index into the quads tile sheet
29:52 - appropriately.
29:54 - And then here if we're
paused, let's just draw
29:57 - some text in the middle of the
screen that just says Pause.
30:00 - And we use the large font.
30:01 - So we can go ahead and demo this now
and see everything come together.
30:08 - We have as before our StartState.
30:11 - But if we press Enter,
now we go to our PlayState
30:13 - and we just have a paddle
at the bottom of the screen.
30:15 - It's size two, skin one.
30:18 - Just the blue skin.
30:19 - And we can move it left
or right like that.
30:21 - And if it hits the left side
of the screen, it will stop.
30:24 - And if it hits the right side of
the screen, it will stop as well.
30:27 - So we've made progress, but this
is one of the fundamental things
30:30 - I'd like to showcase today is just,
like, using quads and categorizing
30:35 - them, organizing them,
and being able to draw
30:38 - your assets from a large compiled
image rather than keep track
30:43 - of however many images it would take.
30:45 - And you have to name all
of them and sort them.
30:47 - It would just be a big pain.
30:49 - So yeah.
30:49 - Definitely going forward when
you have more than one sprite,
30:52 - you want to sort of put
it together in one sheet,
30:55 - and that's how we can accomplish that.
30:57 - But we don't have bricks,
and this is probably
31:00 - the other big main component of Breakout
besides the paddle and the ball.
31:05 - We want to have bricks that we can
actually hit and aim for on the screen.
31:08 - So this update will address that.
31:10 - So let's go ahead and take a
look at Breakout2 in main.lua.
31:16 - I'm going to open it up here.
31:21 - On line 66, you can see we have
a new table in our gframes.
31:29 - Because we had one just
for paddles, we took out
31:32 - just the paddles from our sprite sheet.
31:33 - We're going to do the same
thing for just the balls.
31:36 - So we're going to look
at-- if we look here,
31:38 - we can see that the balls sort of
come after all of the bricks here
31:43 - and they're just laid out in
eight pixels wide by eight
31:46 - pixels tall increments here.
31:48 - So four pixels to one brick,
four balls to one brick,
31:52 - two balls to one horizontally,
and then two balls vertically.
31:56 - And so what we'll end up doing is
just a simple function in our util
32:02 - that takes a look at that.
32:04 - So let's go ahead and take a look at our
util.lua, which we've made changes to.
32:14 - And so what this is going to
do is sort of do the same thing
32:17 - that we did before.
32:20 - It has to iterate.
32:21 - So notice we have two rows of balls.
32:23 - We have these four and
we have these three.
32:26 - So we want to iterate four times.
32:27 - You want to find whatever
the offset is here,
32:29 - the X and Y. So it looks like three
times 32 and then three times 16.
32:35 - So 96 by--
32:36 - I can't do math.
32:37 - Whatever 16 times three is.
32:39 - And then we'll end up 48.
32:40 - And then we'll have--
32:42 - which is what we do here.
32:43 - So we have two iterations.
32:46 - So a four loop that
goes from zero to three.
32:48 - So the top row, the four.
32:51 - We'll set a counter to one here.
32:52 - And notice also 96 and 48.
32:54 - That's the X and the
Y that we're setting.
32:56 - That's where the offset is for
the individual ball sprites.
33:01 - Quads at counter gets--
33:03 - and notice also quads is a table.
33:05 - We're going to return this.
33:06 - Quads at counter gets
love.graphics.newquad at X, Y.
33:10 - Eight pixels wide, eight pixels tall.
33:12 - That's how large the balls are.
33:13 - And then we're going to add eight to
it because we're going to the right.
33:17 - So this iteration just
goes left to right.
33:20 - And then here we're going to
do basically X being set to 96
33:25 - and then Y to 56.
33:27 - And then because we were
editing X directly in here,
33:30 - we want to reset X back
to 96, but then also add
33:33 - the eight pixels so that we
have the start for the next row
33:36 - vertically, so at Y 56.
33:38 - Do the exact same thing
here, but only do it
33:40 - three times because recall
there is four balls on top
33:43 - and then three balls on bottom.
33:44 - And then return it at the very end.
33:46 - And so now we have just
an individual table.
33:49 - We don't need to keep like
one monstrous table of quads,
33:51 - which I find sort of disorganized.
33:53 - We can just have a table
of frames for the paddles,
33:57 - and the balls, and the
bricks as we'll see.
34:02 - Actually, I have it up here I think.
34:05 - Maybe not.
34:08 - So in ball-- oh, actually, hold on.
34:12 - Sorry.
34:12 - So we were looking at--
34:17 - I skipped over this one on accident.
34:19 - So the bounce update.
34:19 - So everything I just said is
relevant, but I accidentally
34:22 - hit that right two times.
34:23 - We want to go to the bounce update
because this is slightly simpler.
34:27 - So we were just talking about
the ball, which is perfect.
34:30 - So we're going to take the ball and then
we're going to add that to the scene,
34:33 - and we're just going to
implement bouncing off the walls.
34:36 - So actually, pretty
identical to the code
34:39 - we saw for Pong where you just
detect whether the ball has
34:43 - gone past the left, right,
or top edge of the screen.
34:45 - In this case, it will also allow us
to go to the bottom of the screen
34:48 - and we'll also implement
colliding with the paddle
34:51 - so then get a sense of the actual
game play and what that feels like.
34:54 - So everything is currently current.
34:57 - So we're going to go--
34:59 - after talking about the function
to actually get the individual ball
35:03 - quads out of the
spreadsheet, we're going
35:05 - to look at the ball class which is going
to allow us to spawn them in our scene.
35:10 - So a ball takes a width
and height of eight.
35:12 - No velocity.
35:13 - But we're going to allow ourselves
to initialize the ball with the skin,
35:17 - and we'll see this later just
as a cutesy little thing to you
35:21 - use the actual individual sprites
rather than just one constant sprite.
35:24 - We're just going to give it a
random number between one and seven
35:27 - because there are seven quads.
35:30 - And then we'll just use gframes
balls and math dot random number
35:35 - to get the actual ball
spread that we want.
35:38 - And so we have a simple
collides function within ball
35:40 - that would allow us to check to see
whether we've collided with something
35:45 - that has a X, Y width and a height.
35:47 - So it's a simple A, B
collision detection.
35:54 - And then here we have reset.
35:56 - Just resets it to the
middle of the screen.
35:58 - Update applies velocity.
35:59 - Stuff we've already seen.
36:02 - This is where we actually
implement bouncing off the walls.
36:05 - So if X is less than or
equal to zero, greater than
36:07 - or equal to virtual width minus
eight, or less than or equal to zero,
36:11 - this should be where we
reverse the velocity.
36:14 - In the case of it bouncing off the left
side, we want to reverse the X velocity
36:18 - but keep it going up.
36:19 - If it hits the top,
then we want to reverse
36:21 - the Y velocity to keep it moving in
whatever direction it was moving.
36:24 - And same thing with the right hand wall.
36:27 - And then play a wall hit sound.
36:29 - And we're incorporating the
sounds sort of as we go today
36:31 - just because they're so simple.
36:33 - And it's also kind of nice just
to have a little bit of feedback
36:35 - when you're actually
endpoint of the game.
36:37 - And the exact same code
is here for drawing.
36:39 - So we have main texture, but
now we're using gframes balls,
36:43 - and then we're indexing
that at self.skin.
36:46 - And recall that we just
set self.skin in here.
36:48 - So all we need to do
to just make it random
36:49 - is just wherever we create a new
ball, just give it a math.random7,
36:53 - and then that will index
into that quads table
36:57 - so we can draw a different
ball texture each time.
37:01 - And so let's go ahead and see--
37:03 - oh, actually, no.
37:03 - And one last thing we need
to look at is the PlayState
37:06 - has a little bit of new code as well.
37:09 - We're going to spawn a ball,
so this is where we do it here.
37:11 - I'm not doing it random, but I could
do it random here if I wanted to.
37:14 - I could math.random7,
and every time we boot up
37:17 - the game it's going to be a
different color because it's
37:19 - going to be a different skin.
37:22 - We need to update the ball.
37:23 - So on line 50 we just update
it like we do the paddle.
37:26 - And then on line 52,
we're just testing to see
37:29 - whether it collides with the paddle
because we're using just simple A,
37:32 - A, B, B. If it collides with the paddle,
we can assume it was coming down.
37:36 - We can just reverse as delta Y.
37:38 - Now, does anybody know what
might be a current issue
37:43 - with the current implementation
of this function?
37:46 - Particularly with this line.
37:51 - AUDIENCE: [INAUDIBLE]
38:01 - COLTON OGDEN: It will.
38:02 - You're on the right track.
38:03 - The answer was, if the ball
is coming from the side,
38:06 - it won't necessarily be bounced
back up in the right Y direction.
38:11 - If it's coming from the side,
it will always, in this case,
38:13 - be coming from up above.
38:15 - So it always still be
reversing in the right delta Y.
38:17 - But what's going to happen
if it comes in at an angle
38:22 - and then isn't basically reset?
38:28 - Like right now if it
comes at an angle and it
38:31 - gets caught-- let's say it's like
below the top edge of the paddle.
38:36 - AUDIENCE: [INAUDIBLE]
38:37 - COLTON OGDEN: You're going
to get an infinite collision
38:40 - loop because we're not
resetting it's position,
38:42 - we're only updating its velocity.
38:44 - If it comes in at the
right angle from the side,
38:46 - it's going to get
stuck inside the paddle
38:50 - and then it's going to cause a
little bit of funky behavior.
38:52 - I'll try and see if I can make that
happen in my demonstration here.
38:55 - But that's the gist of
all of these updates.
38:58 - So if we go to Start, we can
see immediately we have a ball.
39:02 - And when it hits the sides or
the top, it bounces accordingly.
39:05 - It hits the paddle.
39:06 - So when it comes in from the top flush
on the top, it flips the Y velocity.
39:11 - Let's see if I can get
it at an angle here.
39:14 - There it is.
39:15 - It'll get stuck.
39:17 - And so whenever you sort of do
A, A, B, B collision detection,
39:22 - just remember to always reset
the position of whatever it
39:25 - is that collided that's
moving so that it doesn't clip
39:29 - and get stuck inside of something
else over and over again.
39:31 - Yes.
39:32 - AUDIENCE: [INAUDIBLE]
39:42 - COLTON OGDEN: The question is
I'm always doing love space dot,
39:45 - and as opposed to just
running things from using
39:50 - the complete path of whatever the file
is, in order to do that-- so are you
39:55 - on a Mac or a Windows machine?
39:56 - AUDIENCE: [INAUDIBLE]
39:57 - COLTON OGDEN: So on a Windows
machine it is a little trickier,
40:01 - but I've found a really nice
sort of plug-in for VS Code.
40:07 - So if you're VS Code, which is the
editor that I use, it has plug-ins
40:11 - and one of the plug-ins that
you can download is for Love2D
40:14 - and it has a config where
if you just press Alt L,
40:19 - it will run whatever
directory you're currently in,
40:22 - whatever project you're currently in.
40:24 - It will call Love.
40:25 - It adds it to your path for you.
40:27 - So download the Love2D plug-in on
VS code if you want that to work.
40:31 - I'm on a Mac, so I can edit
what's called my batch profile,
40:34 - and alias Love to its complete
path in my file system.
40:40 - And you can do the same thing with--
40:43 - I don't know how it would work
with Windows in terms of aliasing,
40:48 - but it's essentially the same thing
as typing out the entire path to Love,
40:52 - but only I'm changing
it to another word.
40:55 - I'm changing it to Love.
40:56 - So I'm setting Love equals
to application slash
40:59 - love.app/content/resources et cetera.
41:02 - So good question.
41:04 - I would download on Windows.
41:05 - I'm a big fan of VS Code
and the Love2D plug-in.
41:07 - I would recommend looking into that.
41:09 - And I'm sure there are other
plug-ins, and there's a page also
41:12 - on the website--
41:13 - I don't have a browser
open at the moment.
41:15 - But on the wiki, you can look
at the Getting Started page.
41:19 - I believe it's like
love2d.com/wiki/gettingstarted.
41:21 - They have a bunch of instructions
for different operating
41:23 - systems and different text
editors that allow you to get sort
41:26 - of a more efficient workflow going.
41:29 - So any other questions?
41:34 - All right.
41:35 - So we did the bounce update.
41:38 - Now we can finally edit the bricks.
41:40 - Add in the bricks, I should say.
41:42 - So these are pretty simple.
41:44 - So we're going to take a look at it.
41:47 - And right now we're not going to do any
sort of fancy procedural generation,
41:50 - we're just going to get
some bricks on the screen.
41:52 - Just some easy bricks.
41:55 - Or rather, we will get some very
basic procedural generation,
41:58 - but not to the level
that we'll see soon.
41:59 - We'll see that very soon.
42:01 - OK.
42:02 - So I'm going to go
into my main.lua here.
42:05 - I'm going to go into the Breakout3.
42:12 - And same thing that we
did before on line 67,
42:15 - we just have a new bricks
table in our gframes.
42:19 - And it just generate quads bricks.
42:21 - We call from util.lua, so we can
look at that really quick as well.
42:25 - This one's actually really easy.
42:28 - Sourceutil.lua.
42:30 - Because they start at the
very top of the screen,
42:33 - we can assume that--
we could effectively
42:37 - treat this whole thing
as if it were just these
42:40 - and just generate quads at
a constant width and height
42:43 - because, effectively, we only need a
subset of the frames that's generating.
42:47 - Because it's generating them this
way, top to bottom, left to right,
42:52 - we can just grab all
the way up to here using
42:55 - table.slice, which we
saw before, and not
42:59 - worry about indexing
into any weird, like,
43:01 - having any constants X and Y that
we need to index with in order
43:04 - to get an offset.
43:05 - We can just do a very simple--
43:07 - if we go down to line 57, generate quads
bricks, it just does a table.slice.
43:15 - And so within that, we're going
to generate quads atlas 32,16.
43:19 - So this is going to have the effect
of dividing up our sprite sheet by 32
43:23 - by 16 pieces.
43:24 - It's going to generate
all of these just fine,
43:27 - but then it's going to have quads
here, here, here, here, here
43:30 - that don't line up with
the quads that you see here
43:32 - because it's just blindly assuming
that all of the sprites in that sheet
43:36 - are the same size because
that's all we're doing.
43:38 - We're just calling generate
quads, which if you recall,
43:41 - just generates a fixed size width and
height throughout our entire atlas,
43:46 - which is great for a lot of
sheets that are symmetrical,
43:49 - but there are cases where we have,
like, for example here, where
43:52 - our spreadsheet is asymmetrical.
43:53 - We have paddles of
differing sizes, we have
43:55 - the balls which are eight by
eight, we have the bricks,
43:58 - we have the other power
ups at the bottom.
44:01 - But the generate quads
bricks takes in that table
44:05 - that we're generating, which is
going to be a bunch of frames
44:08 - that we don't want.
44:09 - Many of them clipped, half clipped.
44:11 - And then we're just going
to take it from one to 21.
44:14 - And when we do that, one to 21 is
effectively-- that's how many of these
44:18 - there are.
44:19 - So 18 and then one, two, three.
44:22 - So from one to 21, all of those.
44:24 - That will be all the bricks.
44:25 - We can throw away all
the rest of the quads
44:28 - and just blindly assume that
they're all the same size.
44:36 - So any questions on how quads or
how any of these tables are working?
44:41 - OK.
44:44 - So we're going to go ahead.
44:45 - We have a new class now, brick.lua.
44:49 - So simple building blocks.
44:52 - In brick.lua on line 30, we
have a flag called in play.
44:57 - self.inplay gets true.
44:58 - And so we're just going
to use this to render.
45:00 - We're just going to say,
if it's in play, render it.
45:02 - If it's not, don't render it.
45:04 - It's that simple.
45:04 - That way we don't have to worry about
object deallocation or anything fancy.
45:08 - We have all of our bricks
and whether it's in play
45:10 - or not, render it or
perform update logic.
45:12 - And if it's not in play, just
pretend it doesn't exist.
45:14 - Just ignore it.
45:17 - We're only going to have like
30 or I don't know how many,
45:21 - 13 max by four bricks in our scene at
once, so worrying about freeing memory
45:26 - isn't really an issue.
45:28 - But if you have a million different
things getting generated all the time,
45:34 - having simple in play is
false might not always
45:37 - be viable because you need to store
all that memory for all those objects.
45:40 - So just a shortcut here,
but not necessarily best
45:44 - practice for very large games.
45:47 - But certainly great and
simple for small games.
45:53 - On line 37, we define a
function called brick hit.
45:56 - And all this does is just play a
sound effect and set in play to false.
46:00 - And so all we're going
to do is just check
46:03 - to see whether there's a collision
and then just call this hit function,
46:06 - play a sound, and then just
pretend it doesn't exist anymore.
46:10 - And then render, all render does is if
it's in play, check the in play flag,
46:15 - draw main at bricks or using our
bricks table here that we created.
46:23 - And then we're going to
start at one and then
46:25 - we're going to index it based on
our color minus one times four,
46:30 - and then we're going to add it's tier.
46:31 - So there are, if you recall,
one, two, three, four,
46:36 - five colors and four tiers.
46:41 - And so what we're going to do is we're
going to jump between the colors.
46:44 - So we'll go value one, value two,
value three, value four, value five.
46:49 - That will be our first
five or I guess six.
46:52 - That will be our first six bricks.
46:55 - And then we're going to go one,
two, three-- or we're going to add,
46:59 - we're going to have a tier basically.
47:00 - It'll be one, two, three, or four.
47:04 - And if it's at tier one,
then we can just add--
47:07 - basically to index into
whatever tier we're on,
47:10 - we just need to add tier minus
one to whatever our index is.
47:13 - So here if our tier is one, then
we just want to render this block.
47:17 - We don't want to go to the next one.
47:18 - So we're just going
to say tier minus one.
47:20 - We're going to add--
47:22 - so one minus one is zero.
47:23 - So we're going at zero
to this, get this.
47:25 - But if tiers two, we'll add
one, and two, and three.
47:29 - And then we just multiply whatever
brick we want by our color.
47:34 - Multiply it by four to get an offset
for whatever our actual color is.
47:40 - So we take our color, figure
out where on the sheet it is,
47:43 - and then just add our tier
to it in order to index
47:46 - into our spreadsheet accordingly.
47:49 - And so that's what the
math here is doing.
47:52 - And if we go back to our PlayState--
48:02 - and I'm going to start
moving a little bit faster
48:04 - just so we can keep caught up.
48:06 - But in our PlayState, one
thing that we notice here,
48:10 - we have a new class called
level maker that we're seeing,
48:13 - which was a function called createmap.
48:15 - We're going to take out all the
logic for generating our levels
48:17 - and we're just going
to put it in one place.
48:19 - We're going to call that level maker.
48:20 - Rather than in our
different states that maybe
48:24 - generate the bricks
like the PlayState or I
48:26 - guess it would be the
ServeState, VictoryState,
48:30 - I guess, rather than
generating all the bricks
48:33 - in that state within it's innate
code, let's just make a level maker
48:37 - and we can just say, OK, set
bricks to levelmaker.createmap,
48:41 - which will return a table of bricks.
48:46 - Same-- excuse me--
logic as we saw before.
48:51 - In this case, we're just
going to iterate for k brick
48:53 - in pairs of self.bricks.
48:57 - If the brick's in play and it
collides, if the ball collides with it,
49:00 - then hit it, which will
set it not into play.
49:02 - So simple A, A, B, B.
49:08 - And then lastly, we have
our render logic here,
49:10 - which is going to take that bricks
table and just iterate over it.
49:13 - And the last thing we
should probably look at
49:15 - is the actual level maker itself,
which in this case is very simple,
49:18 - but we'll see it gets a little bit
more complicated later when we do it.
49:21 - When we have a more elaborate procedural
generation approach to our levels.
49:26 - But right now, we're just going to
say set two random variables here.
49:29 - Number of rows and columns.
49:31 - And then for every row or for
basically every row and every column,
49:37 - create a new brick.
49:40 - And then there's some math here.
49:41 - I'm going to kind of skim
over it, but basically it
49:43 - calculates where the
brick is and then gives us
49:46 - eight pixels of padding on either side.
49:50 - And then based on how many
it is, it needs to center all
49:53 - the bricks and shift them by
a certain amount to the left
49:55 - and then start drawing all of them.
49:57 - And that's essentially
what this code does here.
49:59 - So calculate the center.
50:01 - I wrote it out in comments
here, but I'm going
50:03 - just kind of glaze over it for now.
50:05 - But effectively, center all the bricks.
50:08 - Basically calculate what offset on
the X-axis you need to put all of them
50:12 - so that they appear centered, and then
you're going to draw them all out.
50:16 - And then that's it for
the level maker class.
50:20 - So simply number of rows and columns,
and then fill a table with bricks
50:24 - but set their X equal to however
much we need to center all
50:28 - of them when they're all drawn out.
50:29 - So we need to figure, we need to
basically take in our number of columns
50:32 - into account when we do that.
50:34 - And then if we go into Breakout3
and run that, we have bricks.
50:43 - They're getting collided with,
and as soon as they get hit,
50:47 - collided are in play on each of
those bricks gets set to false
50:51 - and they no longer get rendered.
50:52 - And they no longer get
updated in terms of collision.
50:55 - Now, we still have the issue
with the ball not getting reset.
50:58 - We'll fix that.
50:59 - That's an easy fix.
51:01 - But we're coming a long way.
51:02 - We have things moving at quite a pace.
51:04 - I'm going to go ahead and move
to the next bit of code here.
51:08 - So this is another bit of code.
51:09 - I'm going to sort of glaze over
a little bit of the details here.
51:12 - But at a high level what we
need to do is it's one thing
51:16 - to detect that we've
collided with a brick,
51:18 - but in Breakout, the ball
bounces off of the brick
51:21 - depending on which side it hits.
51:23 - And we don't know this necessarily
just based off of the collision.
51:27 - We just know whether the
collision is true or not.
51:29 - We don't know where it came from
and how much it collided with.
51:34 - And then we're also going to fix our
paddles so that rather than-- because
51:37 - currently all it does is just
negate whatever the Y velocity is,
51:40 - but we want to add a
little bit more variety
51:43 - to how we end up sort of ricocheting
the ball off the paddle when we play
51:47 - so that we can sort of
strategize a little bit,
51:50 - give ourselves a little
bit of game play.
51:51 - So if we are moving to the right and
we hit the right edge of the puddle
51:54 - with the ball, it should probably
go in a sharper direction.
51:56 - Same thing with the left side.
51:58 - And we can effectively do
that by taking the middle,
52:01 - figuring out how far away
from the center it is,
52:03 - and then just amplifying our delta X
in the negative or positive direction
52:08 - based off of that.
52:09 - And that has the effect
of causing that to happen.
52:13 - So here we can see we have the
ball sort of coming at the paddle,
52:18 - and let's pretend that the
paddle is moving to the left.
52:21 - In this case, however far away
the ball is from the center,
52:24 - we want to scale that
by some amount and then
52:27 - end up making that our negative
delta X, because that's effectively
52:32 - how the game normally works.
52:34 - If you move the paddle
to the left or the right,
52:36 - hit it on a corner or something,
gives it that sharp angle.
52:39 - And that's effectively
what the sharp angle is.
52:41 - It's just a strong delta X, and it
gets amplified the larger this is.
52:44 - So just basically take this,
multiply it by some amount,
52:47 - and then make it negative
or positive on your dx.
52:50 - That's your sort of paddle collision V2.
52:56 - Brick collision is a little bit--
53:00 - it's pretty simple, but it's
a little bit more complicated.
53:03 - Basically what we need to do is just
check and see which edge of the ball
53:06 - isn't inside the brick.
53:09 - And so if the left edge of
the-- and we can also sort of
53:12 - simplify this a little bit.
53:13 - If the left-- as you see
here by the pseudocode--
53:15 - if the left edge of the ball is outside
the brick and the dx is positive,
53:20 - then we can say, oh,
we can basically assume
53:22 - we've come in from the left
side, so we should probably
53:25 - go in the opposite Y
direction on the left side.
53:30 - Or sorry, we should go in the same
Y direction, but negate our delta
53:35 - X. Because we're coming
in from the left,
53:38 - the left side is outside the
brick, so bounce it back.
53:42 - And the same thing for the right edge.
53:44 - And we only do this test, the left
edge of the ball, if dx is positive.
53:48 - Because if dx is
negative, there's no way
53:50 - the ball's colliding with
the left side of our brick.
53:52 - So we can shortcut that effectively.
53:54 - We do the same exact logic
here, just on the right edge
53:56 - of the brick instead of the left edge.
53:59 - And then if none of
those hold true, we're
54:01 - going to see if the top edge of the
ball is above the top edge of the brick.
54:06 - And if that's the case, we know
that we've hit from the top.
54:09 - We can trigger a top collision.
54:10 - And if none of those
have held true, we know
54:12 - that we have had a
collision of some kind,
54:14 - we can just register a bottom collision.
54:18 - And so this is a simple
version of this sort
54:23 - of way of doing Breakout collision.
54:25 - It has a few faults when
it comes to corners,
54:27 - sometimes corners can
be a little bit finicky,
54:29 - but I would say it
works 99% of the time.
54:31 - For a much more robust and a better
example, I would look at this URL
54:37 - here because he also goes
into a full sort of breakdown
54:40 - of how he would implement arkanoid,
which is the same thing effectively
54:43 - as Breakout if you just want
an alternative look at it.
54:46 - But basically, his solution involved
taking how much the X and the Y
54:50 - differed on different points of
the bricks relative to the ball.
54:54 - And I believe he also kept the ball
as an actual ball with a center point,
54:58 - even though he rendered
it as a rectangle.
55:04 - So it's a little bit more robust.
55:05 - I decided to implement it a
simpler way, which I'll showcase,
55:09 - which is the way that I
demonstrated because it worked well
55:12 - and it wasn't too much
code to sort of look over.
55:15 - But I do encourage you
to take a look at that.
55:17 - We're going to look at our
PlayState now in Breakout4.
55:26 - And in our PlayState,
we're going to see--
55:32 - sorry.
55:33 - Line 65.
55:35 - So this is the actual paddle code
for influencing the ball's delta X.
55:43 - So basically, if the ball.x is less than
the paddle.x plus it's width divided
55:53 - by two, so basically on the
left side of the paddle,
55:58 - and the paddle's delta X is less than
zero, which means it's moving left--
56:02 - because we don't really want to
necessarily influence it if we're just
56:04 - standing still--
56:05 - we're going to do what
I described earlier.
56:07 - We're going to give it some
scaler, like some start off value.
56:11 - In this case, negative 50 is just
sort of seeding this, giving it
56:15 - some sort of initial value.
56:18 - And then we're just going to subtract
the ball's X from the middle point.
56:24 - This being the middle
point of the paddle
56:26 - And then just multiply it by eight.
56:28 - So whatever the difference is
between the ball's X and the middle
56:31 - of the paddle, multiply it by eight.
56:34 - Add it to negative 50
and then negate that.
56:36 - Also negate that whole value so that
the whole entire value becomes negative.
56:40 - And we, therefore, get a sharper
delta X depending on which angle
56:44 - it's coming at, and also how fast--
56:46 - or not how fast, but whether
or not we are moving left.
56:50 - And it's the exact same
thing on the right side.
56:53 - Only because we're taking
this math, this self.paddle.x
56:58 - plus self.paddle.width divided
by two minus the ball.x,
57:02 - the ball.x isn't going to
be greater than that point.
57:05 - So this value is actually
going to be negative.
57:07 - So we're going to just make
it positive with math.abs.
57:09 - So absolute value.
57:10 - Just a lua function.
57:12 - So the absolute value of the
difference between the ball's
57:14 - X and the middle point
times eight, add it to 50,
57:19 - and that'll give us a positive value
that scales depending on whether or not
57:23 - we've hit the middle of the, we've
hit the right edge of the paddle
57:27 - and are moving to the right.
57:28 - And so that's, in a nutshell, how we get
that collision to work with the paddle
57:33 - and how we can tweak delta X
to be scaled a little bit more
57:36 - than just a constant, you
know, negative or whatever
57:40 - it's current X was, but negative dy.
57:43 - A little bit more complicated.
57:45 - And then the actual
collision code for the bricks
57:50 - themselves is going to take
place in a for loop here.
57:53 - So if it's in play, if the
ball collides with it, hit it.
57:58 - So I added plus two.
57:59 - So the gist of the math is if
ball.x is less than brick.x
58:05 - and the ball is moving to the right,
self.ball.dx is greater than zero,
58:09 - then flip it's X velocity.
58:10 - So bounce it to the left.
58:11 - That's what this check is.
58:13 - But it plays a little
bit rough with corners
58:15 - because you could theoretically
get into a position
58:17 - where you come in at an
angle and it's intersecting
58:21 - with the paddle in two positions,
both on top and the left
58:29 - or on bottom and the left.
58:30 - So in that case, adding two sort
of prioritizes the Y being hit.
58:36 - So it basically takes the check from the
exposition of the ball to the X plus 2.
58:42 - And so it ends up fixing the corners
a little bit, but the gist of it
58:48 - is just check to see if the
ball.x is less than the brick.x.
58:50 - And if it is and we've detected
a collision, we can bounce it.
58:55 - There are some subtle corner case
bugs without adding this plus two,
58:59 - so we add that.
59:01 - And then flip the velocity here.
59:04 - Oh, this shift here.
59:05 - This is what we were talking
about earlier with make sure
59:07 - when you do a collision,
shift whatever is
59:09 - moving outside the boundaries of
whatever you're colliding with.
59:12 - So self.ball.x gets brick.x minus eight
because the ball is eight pixels wide.
59:19 - It should actually be
self.ball.width for a better style,
59:23 - but that's essentially
what it translates out to.
59:26 - Same thing for the right edge.
59:27 - The plus six because
it's on the right side.
59:29 - So it's effectively the same thing as
minus two if we're on the left side.
59:34 - Just a sort of fixes corners,
weird issues with corners.
59:39 - But check in to see if basically
the ball plus its height minus two
59:44 - is greater than the brick plus X
plus brick.width, which it means,
59:51 - oh, we've collided with the right
edge of the screen, of the brick.
59:55 - And then if the Y is
less than the brick.y,
59:58 - then we've collided with
the top of the brick,
60:00 - and otherwise, we've
collided with the bottom.
60:03 - And with the top and the bottom, just
do the same thing we did with delta X,
60:06 - but do it with delta Y, but
you're still resetting it.
60:09 - So ball.y gets brick.y minus eight.
60:11 - Ball.y gets brick.y plus 16 because
the paddle or the individual bricks
60:17 - are 16 pixels tall.
60:21 - That's the gist of the
collision detection.
60:24 - And then if we actually-- oh, and
one other thing that I ended up
60:27 - putting here just to make it
a little bit more interesting,
60:30 - and this also ties into more
complicated collision detection.
60:33 - If your velocity is too fast, a lot of
the time it'll skip through objects,
60:38 - and then that causes a lot of problems
with these collision detection
60:40 - functions that normally are very
sort of mathematically correct
60:44 - and they work well.
60:45 - They don't work well
when it skips over what
60:47 - you're trying to actually collide with.
60:49 - So a solution to that, which was beyond
the scope of this example but something
60:53 - we're thinking about, is perhaps
stepping backwards a certain amount
60:57 - of time, a certain amount of pixels.
60:59 - Perhaps maybe start at where you
where your ball was on one particular,
61:04 - on the last frame, and then just
add its width and height to itself
61:08 - until it collides with something, until
it reaches whatever its current delta X
61:12 - or delta Y plus its position is.
61:15 - That's one way to do it.
61:16 - Sort of just adding a
bunch of invisible--
61:18 - whatever you're colliding with or
whatever you're using to collide--
61:21 - add a bunch of invisible those to bridge
the gap and check into if any of those
61:26 - hold true for a collision.
61:27 - A little bit more computationally
expensive, but a lot more accurate
61:32 - in terms of the physics.
61:35 - And aside from that,
everything is the same.
61:36 - So if you look at the
code in Breakout4--
61:40 - and I'm going to go a little
bit faster henceforth.
61:42 - That's probably the meatiest
part of the program.
61:47 - We get collisions.
61:49 - And then I'll try and get a
strong angle so I can demo the--
61:54 - that didn't work.
61:54 - That actually gave a weaker angle.
61:55 - So if you do this and you do it close to
the center, it has the opposite effect.
61:59 - But there you go.
61:59 - That's a sharper angle.
62:01 - So now you can actually influence
the ball in a little bit more
62:05 - of a personable way.
62:07 - You know, not just have it be
a flat delta Y gets negative--
62:11 - or get negative delta Y effectively.
62:14 - So any questions on sort of how
the gist of all of that works?
62:23 - OK.
62:24 - Perfect.
62:25 - So now we're going to get into a
little bit more of some fun stuff.
62:28 - We'll do a couple more examples,
then we'll take a break.
62:30 - So this is the hearts update.
62:32 - So notice that the very top of the
screen, as I've demonstrated in these
62:35 - slides, we have just a few hearts.
62:38 - One of them is empty.
62:39 - We showed this earlier.
62:40 - And then we have a game over
screen, which is our final score.
62:43 - So I'm going to go ahead and we're just
going to look at the code a little bit
62:46 - faster now since a lot of the
stuff is fairly straightforward.
62:50 - I'm going to go ahead and open up the--
62:52 - I'm going to make sure I'm in
the right folder first of all.
62:54 - Breakout5.
62:55 - And then in the--
63:00 - so one other thing we're
going to start doing is--
63:07 - I mentioned this earlier.
63:08 - And it's going to be
it's going to hold true
63:10 - for any of the sort of
state transformations
63:13 - that take place going forward.
63:15 - Rather than keep global
variables, we're going
63:17 - to sort of do away with that
idea outside of the asset tables
63:20 - that we have just because
those are kind of an exception
63:23 - and they could reasonably be put into
a separate class called the resource
63:26 - manager.
63:27 - We're going to start passing in what
is basically our current app state,
63:35 - or at least the variables
that make sense.
63:37 - And this is a common paradigm in
web development with React as well.
63:40 - But basically, everything that we
need to be preserve state to state,
63:44 - rather than just keeping
global variables,
63:46 - let's pass them between the states
because the state machine allows
63:49 - us to do that in the change function.
63:52 - And then whatever that state
is in it's enter function,
63:55 - it'll have access to
that and it can just
63:56 - set those values to self
dot whatever and use them.
64:01 - But we no longer have global variables.
64:02 - We're just saying, here.
64:03 - Here's the values that are
important for you to continue on.
64:06 - And then that state will take its
values and go to the next state
64:09 - and say, oh, OK, here are the
values that you need to function.
64:14 - Like the serve, play,
and all those states
64:16 - that have the core game
play involved will probably
64:17 - need to maintain a reference
to like the paddle,
64:19 - and to the score, the
amount of health we have.
64:21 - But when we get to the end, for
example, and then we no longer really
64:24 - need a paddle, we no longer really
need bricks or anything like that,
64:27 - we just need to know what our high
score is so that we can enter it
64:30 - into our high score
list, all we really need
64:33 - to do is just pass in the high score
state entry or just our high score,
64:37 - and that's it.
64:39 - So it encapsulates all of our data.
64:41 - And at a glance, we can sort of see
what we need to pass between the states
64:45 - and what's going to be
relevant at a glance as well.
64:48 - It just clean things up quite a bit.
64:52 - So that's what we're
doing now on line 35.
64:55 - And henceforth, we will do
this in every state as we see,
64:58 - but I'm going to sort of
glaze over it in the future.
65:02 - We have a ServeState now.
65:03 - So a ServeState, this is very
identical to what we did in Pong.
65:08 - So we just wait for the
user to press Space.
65:10 - They can move around and then
when they do press Enter,
65:16 - basically the ball starts moving.
65:20 - And then we change the
PlayState here using
65:23 - the current values that are necessary.
65:25 - Paddle, bricks, health, score, and ball.
65:27 - Those are basically the
fundamental variables
65:30 - that we need in order to
keep track of our GameState.
65:35 - So we have a ServeState, it
will wait for us to press Enter.
65:38 - And then our main.lua, we
have a new hearts table.
65:50 - And then on line 208,
because we're going
65:55 - to need the ability to render health and
render our score across several states,
65:59 - Play, Serve, Victory, Game Over--
66:02 - actually not Game Over,
but the three before that.
66:04 - We don't want to
duplicate those behaviors,
66:06 - so I'm just calling a function
called Render Health, which
66:08 - just takes in whatever
health is and then
66:10 - we just set an X to
virtual width minus 100.
66:13 - And then for however many
health we have, draw a heart
66:17 - from the hearts sprite sheet,
which I separated the hearts out
66:20 - into a smaller image so you can just
split them on like eight by eight
66:23 - or whatever it is.
66:25 - But just draw those
and then add 11 to X,
66:27 - and just keep going until we've drawn
out however many hearts we have.
66:30 - That will draw full hearts.
66:32 - And then three minus health will give
us however many health we're missing.
66:35 - So if we took a point of damage,
this is going to be equal to one.
66:38 - So then it'll draw one empty heart after
that or it'll draw two empty hearts.
66:41 - So draw however many full hearts we
have, then draw the empty hearts.
66:44 - And those are two separate sprites
that we get from the image.
66:48 - And that will have the
effect of drawing our health.
66:51 - And then our score is simply, it takes
a score variable that we pass into here.
66:56 - And also note that the
render health [INAUDIBLE]
66:58 - and health variable
and pass into it here.
67:00 - And so in our PlayState, we are calling
both of these functions on line 135.
67:17 - Well, on line 135, we are
calculating whether we
67:20 - go below the edge of the screen, which
is another important part of the game.
67:23 - Obviously, we need to detect
when we've lost health.
67:26 - So it's as simple as this.
67:28 - If it's greater than the virtual
height, decrement health by one.
67:31 - If it's equal to zero,
change to Game Over.
67:34 - Else change to the ServeState.
67:35 - And note that we're passing in all
these variables to and from our states.
67:38 - The ones that are important.
67:39 - Game Over just needs score,
but Serve needs whatever
67:41 - variables we were already using.
67:46 - And then down here we're calling
render score and render health,
67:50 - and then the GameOverState is simply--
67:54 - because it takes in score
from the parameters list,
67:58 - just wait for keyboard input to go back
to the start and then render game over,
68:03 - here's your score.
68:04 - It's self.score, and then that's it.
68:06 - Very simple.
68:07 - Very simple state.
68:08 - AUDIENCE: [INAUDIBLE]
68:09 - COLTON OGDEN: Sure.
68:10 - AUDIENCE: [INAUDIBLE]
68:15 - COLTON OGDEN: The question
was, do any of these states
68:18 - have access to their parent file?
68:19 - AUDIENCE: [INAUDIBLE]
68:27 - COLTON OGDEN: Is everything
in main.lua global functions?
68:30 - Yes.
68:30 - Functions that you declare.
68:31 - Anything that's basically not specified
as local that you define in main.lua
68:35 - will be accessible anywhere in your
application, including functions.
68:39 - AUDIENCE: [INAUDIBLE]
68:40 - COLTON OGDEN: You don't
have to-- the question was,
68:42 - do you have to declare as public?
68:44 - No, there is no notion of public.
68:45 - In lua, anything that does
not have a local specifier
68:48 - is assumed global, even
if it's in a nested scope.
68:51 - So you could have a for loop, you
could have several nested for loops
68:54 - and declare some variable without local,
that variable can be accessed anywhere
68:59 - above it or outside of it.
69:01 - So it's pretty important
to use local variables
69:03 - when you're not explicitly
allocating something as global
69:05 - just to avoid the bug
of for nested loops
69:09 - and you have some variable name like
hello and you use it somewhere else.
69:14 - Good questions though.
69:16 - So yeah.
69:17 - We have a bunch of states now.
69:18 - We have a GameOverState,
a PlayState, we're
69:20 - rendering our score,
rendering our health.
69:22 - If we go and take a look at Breakout5--
69:29 - is it a different window?
69:33 - There we go.
69:35 - We can see hearts at the top.
69:37 - Score zero.
69:41 - Oh, and I forgot to mention the part
where we actually add score now.
69:44 - So the bricks themselves in their on
hit, or I should say in the PlayState,
69:54 - on line 81 when we detect a hit, we're
just adding 10 to the score for now.
70:00 - But later on, we'll
do a calculation where
70:01 - we take tier and color
into consideration
70:04 - and then perform arithmetic on that to
get our total score for each ball hit.
70:09 - But yeah, we have our
health, we have our score.
70:14 - And then once we take
enough damage, we'll
70:16 - end up going to the Game Over screen.
70:18 - The Game Over screen will
go back to our Start screen.
70:20 - So making progress.
70:21 - And then probably my
favorite of the updates
70:24 - before we take a short break
is the pretty colors update.
70:27 - So what this does is
clearly we can have--
70:31 - we've updated our level maker.
70:32 - So rather than just having a
bunch of very static bricks,
70:37 - we end up doing a little bit more
complicated procedural generation.
70:41 - It's not complicated though.
70:42 - Just in levelmaker.lua in Breakout6,
we have a few different constants here.
70:48 - So solid, alternate, skip, or none.
70:51 - Actually, I don't think
I use skip or none.
70:53 - Just solid or alternate basically.
70:54 - We have flags now.
70:56 - So number of columns.
70:58 - And we ensure that it's odd because
even columns with generating patterns
71:02 - leads to asymmetry.
71:04 - So make sure the number
of columns is odd.
71:07 - Generate the highest tier and the
highest color based on our level.
71:10 - So in this case, we'll
go no higher of a tier
71:12 - than three because we have
no higher tiers than three.
71:16 - It goes zero, one, two, three.
71:18 - And then whatever our
level divided by five is,
71:20 - and it would just take math.floor.
71:21 - Math.floor takes in basically
performing division and then truncating
71:26 - the decimal point.
71:28 - Well, not division.
71:29 - It just literally truncates the
decimal point off of a number.
71:31 - So a level divided by five.
71:33 - Whatever that is before
the decimal point.
71:36 - Level modular five plus
three for the highest color.
71:39 - So we'll cycle.
71:40 - We'll go over and over again.
71:42 - Go highest color one, two, three, four,
five, and then we'll go to a new tier
71:46 - with level divided by 5.
71:47 - So basically, every five
levels will increment in tier,
71:50 - and then we'll start back at blue.
71:52 - And then we go on, and on, and on
like that for every number of rows.
71:56 - So basically I have a few--
71:57 - I'm going to sort of glaze
over this a little bit
71:59 - just because we're probably
going to run short on time.
72:02 - But we have basically two flags.
72:05 - Whether we're skipping bricks in this
row or alternating bricks color wise.
72:10 - And if we do, we need to set
a color for it and a tier.
72:14 - And then we basically
just say, you know,
72:16 - the same sort of logic that we had
before we generated random rows
72:19 - and columns, but if we
have the alternate flag on,
72:24 - then as we can see in some of these
photos here, here we have skip is true.
72:31 - So the color for that row is set
to the blue, but skip is true,
72:36 - so every other brick is just going
to skip that iteration of the loop.
72:40 - Same thing here, only
it's offset by one.
72:42 - Same thing here.
72:43 - Same thing here.
72:44 - So this is kind of a
nice little pattern.
72:46 - And in each of these cases--
72:47 - actually not each of these cases.
72:49 - Notice this third one, it
also set alternate to true.
72:52 - So it goes green, purple,
green, purple, green, purple.
72:55 - And so the logic there is
if alternate is true, then
72:57 - just flip the color every iteration.
73:00 - If skip is true, don't generate a
brick every other iteration, and so on
73:04 - and so forth.
73:05 - And then if you have solid or if you
don't have alternate equals true,
73:09 - then you have a solid
brick like these blue ones.
73:11 - And if you have alternate but no
skip, you get this sort of pattern
73:16 - where you have green,
purple, green, purple.
73:18 - You know, any random color.
73:20 - And then also the number
of columns is random.
73:23 - So it can go--
73:24 - here we have 1, 2, 3, 4, 5, 6, 7, 8,
9, 10, 11 but on this very bottom one,
73:30 - we have that minus two it looks like
because it can only go that wide.
73:35 - And in those here too.
73:37 - Smaller size.
73:38 - That one there's no spacing.
73:40 - So these are very simple concepts.
73:42 - Like should we skip a
block this iteration?
73:44 - Should we alternate the colors?
73:47 - And when you put them
all together, it produces
73:49 - things that look as if they
were almost handcrafted.
73:52 - Like this could be made by somebody.
73:53 - Like, that looks like
it was made by somebody.
73:55 - Pretty much every iteration of this.
73:57 - I mean, even that, that
looks like a shape almost.
73:59 - Its just very simple but the results
are pretty awesome in my opinion.
74:03 - And so that's just the gist
behind what we're doing.
74:05 - We're just setting flags
and just saying, you know,
74:08 - if we're skipping this turn
and just every iteration,
74:10 - every time we lay out a brick and
we spawn a new brick on this row,
74:13 - just do or don't.
74:14 - Just make it's color--
74:16 - pick two colors if we're
alternating and then set
74:19 - its color to whatever the off
color is that we're alternating.
74:23 - And if we're skipping
and alternating, then
74:26 - we're just doing whenever we're on
a brick that we're actually laying
74:29 - is when we change the
color, the alternate color.
74:32 - And so like I said, I won't
go into too much detail.
74:35 - Happy to talk about the
generator after class.
74:36 - But just because we're
running short on time,
74:39 - sort of going to wave my hands over it.
74:40 - But that's it in a nutshell.
74:42 - So any questions before we
take a break for five minutes?
74:47 - Yes?
74:47 - AUDIENCE: [INAUDIBLE]
75:02 - COLTON OGDEN: The question is, in
an instance with this programming
75:06 - if the ball were so fast that it
we're actually inside the brick,
75:10 - would it what?
75:12 - AUDIENCE: Would it still bounce back?
75:14 - COLTON OGDEN: Would
it still bounce back?
75:15 - The answer is no, it wouldn't.
75:18 - This implementation doesn't
take into consideration velocity
75:21 - that goes too fast.
75:24 - Mainly to-- for two reasons.
75:26 - One, it's non-trivial
to implement, and two,
75:28 - it's an interesting thing
to look at, and observe,
75:30 - and be conscious of as you go forward
in implementing your own games.
75:34 - The current code, if it gets
clipped inside of the brick,
75:38 - it will have no edges that are
peaking outside of the brick
75:41 - and therefore, it will default
to the final condition, which
75:43 - is the last else clause,
which puts it below the brick.
75:47 - So it'll just go below the brick.
75:48 - It'll almost be as if it came in
from the underside and bounced out.
75:54 - But like I alluded to earlier, if
you want to implement something
75:56 - like this yourself, you would have to
slice up frame X and frame X plus one
76:01 - into the size of the ball
if the delta is so wide
76:08 - that it either goes inside of a
brick or it goes outside of a brick,
76:11 - or if it skips a brick.
76:13 - And this sort of solves that problem.
76:15 - It solves both of those
problems, but it's a little more
76:18 - than we can cover in this example.
76:20 - Any other questions?
76:24 - All right.
76:24 - Let's take five and get back to it.
76:28 - All right.
76:29 - And we're back.
76:29 - So the next step is we have
basically a layout dynamically
76:35 - generated of interesting bricks
now, but we haven't really
76:39 - implemented scoring any of these.
76:41 - We just have score gets
score plus 10, which
76:43 - isn't really particularly interesting.
76:46 - So Breakout7 is what I
call the tier update, which
76:50 - should allow us to hit blocks that
are a higher tier than just base blue.
76:55 - And if they are of a higher color than
base blue, they should go down a color.
76:59 - So the hierarchy was,
if we look back, blue
77:04 - goes to green goes to red
goes to purple goes to gold.
77:08 - And if something is a
higher tier, it goes
77:11 - to the next color below
it but at that same tier,
77:15 - unless it happens to be like
blue and gray, in which case
77:19 - it'll go back to blue.
77:22 - So how might we implement
scoring based on this system?
77:30 - What do we need?
77:30 - What pieces do we need?
77:33 - What pieces do we already have that
we can use to make this happen?
77:38 - AUDIENCE: [INAUDIBLE]
77:40 - COLTON OGDEN: I'm sorry?
77:41 - AUDIENCE: [INAUDIBLE]
77:52 - COLTON OGDEN: So the
answer was the brick index.
77:54 - So yes, the brick skin
and color are the pieces.
78:00 - Yes.
78:01 - So those are fields of brick.
78:03 - So if we open up--
78:04 - I'm going to go up to Breakout7.
78:06 - And I'm going to start probably
deferring a lot of this code
78:10 - to future reading.
78:12 - But in brick here, the
tier and the color--
78:16 - sorry, not skin, but
skin is for the paddle.
78:19 - But the brick has a
tier and it has a color.
78:22 - And so we need to perform
some arithmetic on that here.
78:25 - And that's essentially what
lines 44 through 58 is.
78:28 - So basically-- oh, I apologize.
78:32 - That's not actually
where the arithmetic is.
78:36 - 44, that does compute, but
this is the bit of code
78:40 - that computes how we can actually
go backwards if we make a collision.
78:45 - So if we collide with a brick and
it's of a higher tier than one
78:52 - and it's a higher color than blue,
it should be brought back one step.
78:57 - But if it happens to be blue, in
which case self.color gets one
79:02 - because blue is one, then it
should just be removed from play
79:05 - just like we've done before.
79:06 - Only now, we're also
taking in tier and color.
79:10 - So we're decrementing tier
based on what index we're at
79:13 - and we're decrementing color.
79:15 - And then this actually
gets used in our PlayState.
79:24 - If we go to line 81,
which previously just
79:29 - had self.score gets self.score plus
one, there's a little bit of math here.
79:32 - It's very simple though.
79:34 - Just brick.tier times 200.
79:36 - So make the tiers worth 100.
79:38 - Plus brick.color times 25.
79:41 - And so if tier is zero,
if it's a base then we're
79:43 - just not going to get that 200 bonus.
79:44 - But the first tier, everything
is going to be worth
79:47 - 25 times whatever its color is.
79:49 - So one, two, three, four, five.
79:52 - And then add 200 plus
the brick.color for when
79:55 - we get to the next set of bricks.
79:58 - And so the result of this is--
80:05 - I believe this is GUI Breakout7.
80:14 - And then if we hit a brick--
80:15 - since this one is blue,
it should disappear.
80:17 - And we're playing a new sound as well.
80:19 - New, like, death sound
just to make it clear.
80:24 - But notice they change colors.
80:26 - So that's all we're doing.
80:27 - We're just taking their
tier or their color
80:29 - and just performing a
simple decrement on it.
80:32 - Looping back.
80:33 - In the event that we go down
a tier, we should loop back up
80:36 - to the highest color of the lower tier.
80:39 - So I'll let you look
at the code for that
80:41 - if you want to sort of get a more
low level understanding of it,
80:44 - but that's the sort of
high level understanding.
80:46 - The next big concept that I'd
like to introduce you guys to
80:48 - is a particle system.
80:51 - And so particle systems are
fairly omnipresent in video games,
80:57 - I would say, because
they make effects that
80:59 - or otherwise difficult
to do with simple sprite
81:02 - editing achievable very
easily and realistically.
81:05 - Just like fire, for example.
81:07 - Things that are very organic, and
flowy, and have a lot going on
81:10 - are often better represented
with particle systems
81:12 - than they are with
simple sprite animation.
81:15 - So does anybody know how
we might be able to--
81:18 - how a particle system might
work underneath the hood?
81:22 - I think I alluded to it previously.
81:26 - Yes.
81:26 - AUDIENCE: [INAUDIBLE]
81:33 - COLTON OGDEN: Yeah.
81:34 - So what he said was
in order to make fire,
81:38 - for example, just spawn
a bunch of particles
81:41 - close to the center of wherever your
fire is spawning and then outside of it
81:45 - spawn fewer.
81:46 - That is absolutely a
way to get fire to work,
81:49 - and also taking into consideration
the travel of your particles.
81:54 - For example, you might spawn a ton
of fire particles really densely,
81:57 - but then maybe they have some
logic that makes them go upwards.
82:00 - Maybe they have a negative delta Y
and then some sort of acceleration
82:04 - so they've sort of trail off.
82:06 - And then maybe sort of how
to get a more realistic fire
82:10 - look, they travel sort of
upwards and then fade away.
82:13 - So the way fire works,
sort of thinking of things
82:16 - in terms of particles like that,
you can achieve a lot of effects.
82:20 - How might we implement,
like, smoke, for example?
82:23 - Same system.
82:29 - So we could have maybe a
timer in our particle effect,
82:33 - or even a transition
because in particle systems,
82:36 - often you have the ability to
transition colors between particles.
82:39 - Let's say you start
off red, go to yellow,
82:41 - and then maybe your particle system
transitions to gray or brown.
82:44 - And then over time, your particles
are going up, they're dissipating.
82:47 - And they're also turning
dark, they're turning brown,
82:50 - it sort of gives you
the illusion of fire.
82:52 - And we won't be doing
anything necessarily as
82:54 - complex as this in our code
here, but in Breakout8, we
82:59 - will be using Love's sort of integrated
particle system which is just
83:04 - love.graphics.newparticlesystem.
83:06 - And it takes in a texture because
all particle systems need some sort
83:09 - of texture as their foundation.
83:11 - And then it needs the number of
particles that it could maximally emit.
83:15 - And so each individual
particle system can emit up
83:18 - to a certain instance of particles.
83:20 - And in the number, and
speed, and whatnot of all
83:23 - those particles is ultimately
the determining factor
83:25 - for how you can get an illusion.
83:28 - Back to last week's lecture, illusions,
like, it's not fire, it's not smoke,
83:32 - it's just a bunch of
particles responding
83:34 - with colors and acceleration and stuff.
83:36 - But there's a lot of functions that
particle system gives you in Love2D,
83:40 - so I encourage you to look at that
link just to explore some of them.
83:44 - Love2d.org/wiki/particlesystem.
83:48 - We'll be using a few of them.
83:49 - Here I'm going to just briefly show you.
83:53 - So each individual
brick when it gets hit
83:57 - is going to need a
particle system of its own.
83:59 - Because our goal is--
84:00 - I'll run the code for
you so you can see it.
84:03 - So if you go to Breakout8
and then you run it,
84:09 - we have a little bit of particles
you saw there at the very end.
84:18 - The blue you were probably able
to see a little bit better.
84:22 - And then one last time.
84:25 - So it spawns a bunch
of little particles.
84:27 - So can anyone tell me how
they think the particles are
84:30 - behaving sort of in a nutshell?
84:33 - What the logic is for the particles?
84:38 - AUDIENCE: [INAUDIBLE] slightly random.
84:40 - COLTON OGDEN: Yeah.
84:41 - Slightly random.
84:42 - And if you look at it, you'll also
notice that they tend to go downwards.
84:49 - So knowing that, we can
probably just assume
84:52 - that they have an acceleration
that tends towards positive Y.
84:57 - And that's essentially
all we really need to do.
84:59 - We spawn a bunch of particles
outwards and then just set them--
85:02 - they have all a lifetime.
85:04 - They last for a certain amount of time.
85:06 - And then they fade between two colors.
85:09 - In this case, we fade from red to
transparent or whatever color it is.
85:16 - And then after the lifetimes
elapsed, it has the overall effect
85:23 - of sort of this glimmering,
gravity based effect,
85:25 - but it's really just a
bunch of particles that are
85:27 - set to spawn in different directions.
85:28 - Apologize for that.
85:30 - So we'll take a look.
85:32 - It's going to be in our brick
class here in Breakout8.
85:38 - So we're going to go to brick.
85:42 - We have a bunch of colors
that we're storing here.
85:45 - So if you notice, the particle systems
adopt the color of whatever brick
85:49 - they're hitting just so that
it stays sort of congruent
85:52 - with what we're looking at.
85:54 - So we're just storing
a bunch of colors here.
85:56 - And I wouldn't worry
too much about this.
85:57 - These are just colors
from the sprite palette
85:59 - that we used with our sprite art.
86:01 - There's specific colors that
are only used in that sprite.
86:04 - And having a palette,
generally speaking,
86:06 - allows your art to look a
little bit more cohesive
86:08 - when you're doing sprite art as opposed
to just picking colors willy nilly.
86:11 - If you say, oh, I'm going to only
use 16 or 32 colors for this palette,
86:15 - you'll sort of have a more
cohesive look and also
86:17 - a very retro look because
often hardware was
86:20 - limited to a certain amount of colors
back in the day for older systems.
86:25 - So it's nice to--
86:26 - as an aside-- and we'll look
at it next week as well.
86:30 - Looking at when you're doing your own
sprite art, try to use fewer colors
86:34 - and then that will give you--
it also makes it easier for you.
86:36 - You don't have to spend time choosing
I want to have this shade of green.
86:40 - I wonder if it looks good.
86:42 - If you only have two shades of green
or semi shades of green to choose from,
86:45 - that's all you've got.
86:46 - You have to make do
with it what you can.
86:48 - So what we're doing here is we're
storing five colors from our palette.
86:51 - We're going to use this.
86:52 - And then when we trigger our--
86:54 - so right here we're
initializing a particle system.
86:57 - So psystem gets
love.graphics.newparticlesystem.
87:02 - And then these are a few functions.
87:04 - So feel free to look in the wiki for
how these functions actually behave.
87:07 - But lifetime acceleration
and area spread
87:10 - just are sort of the
properties that influence
87:13 - the way our particle systems behave.
87:15 - And so using whatever
our current color is,
87:17 - we're going to set our psystem's
colors using setcolors function.
87:21 - We're going to set it
between two colors.
87:23 - Color with 55 times tier alpha
and color with zero alpha.
87:28 - So the higher the tier,
the brighter the particles,
87:30 - but they'll always fade to zero
alpha, if that makes sense.
87:34 - And then we'll just emit 64.
87:35 - And this is all in the hit function.
87:37 - So all we've basically done is just add
this particle system trigger in our hit
87:42 - function, and it has the result of
the behavior that we saw earlier.
87:46 - So any questions on particle
systems or how we use them?
87:53 - So level 9 is the progression update.
87:55 - So the purpose of this update is
to allow us to go from level one
87:59 - to two to three to four and
start get more interesting level
88:04 - generation that way.
88:06 - The gist of this is in our--
88:09 - so if you look at our StartState--
88:16 - so all we need to really do to store
a level is just to store a number.
88:22 - And then where do we
increment the number?
88:24 - Or when do we increment
the number I should say?
88:28 - AUDIENCE: [INAUDIBLE]
88:33 - COLTON OGDEN: Exactly.
88:34 - So we increment the level.
88:40 - We go to the next level
when all of the bricks
88:43 - are in play have gotten there
in play flag set to false.
88:47 - So we have no pricks that
are in play effectively.
88:52 - So in our StartState--
88:54 - so let's go ahead and look at Breakout9.
89:00 - So StartState.
89:05 - We're passing in level gets one here.
89:07 - We're just going to start off.
89:08 - When we're going to StartState, we're
just going to pass level equals one.
89:12 - And then henceforth, anytime we do
any state changes from play to serve
89:17 - and to victory, as we'll
see, victory being our new,
89:19 - oh, you cleared this level.
89:21 - Here's the next level.
89:22 - We're just going to pass
the level between them.
89:27 - And then in PlayState, the important
bit of code here is on line 204.
89:37 - So this is just a function
called checkVictory,
89:39 - which is exactly as James said.
89:44 - We're going to iterate over the entire
table and just say if it's in play,
89:48 - return false because
we're not in victory
89:50 - if we have any bricks that are in play.
89:52 - But return true if we
didn't meet that condition.
89:55 - And so this is just a simple way
for us to check whether or not
89:59 - we are in a victory.
90:02 - And so on line 88 of the
same file in our PlayState,
90:05 - we're just checking to say, hey, if
self.checkVictory after we do any brick
90:09 - hit--
90:10 - because that's when we've just
set a brick to in play is false--
90:13 - just check victory.
90:14 - And if so, play a new
sound like a happy sound
90:17 - that we've done a victory,
and then just pass everything
90:20 - into the new VictoryState
that we have here.
90:22 - And the VictoryState is simply
a sort of just a message state.
90:27 - So all it does is just
renders everything as before,
90:30 - but it just says your
current level complete.
90:34 - Self.level complete.
90:36 - And then press Enter to serve and
it'll go back to the ServeState
90:39 - as soon as that happens.
90:41 - And then here is where the
actual progression happens.
90:47 - When we go to the ServeState, we have
our level but we want to add one to it.
90:51 - So all we need to do when we trigger
a transition into our next state, just
90:57 - increment level by one
here, and also create
91:01 - a new map because bricks needs to get
restarted because we have a new level.
91:05 - Self.level plus one.
91:07 - And that'll have the effect of, oh,
we've gone from level one to two
91:12 - to three to four et cetera when we go
between PlayState to the VictoryState
91:17 - back to the ServeState.
91:19 - So any questions on
how any of this works?
91:21 - Yes.
91:21 - AUDIENCE: Do you have to worry
about garbage collection for any
91:24 - of the bricks at all?
91:26 - Or is that handled by
the Love engine somehow?
91:28 - COLTON OGDEN: Garbage
collection is handled by Love.
91:30 - Yes.
91:31 - Yeah.
91:31 - AUDIENCE: [INAUDIBLE]
91:32 - COLTON OGDEN: Yes.
91:33 - Because the question was, do you have
to worry about garbage collection
91:37 - when we are sort of clearing away
the bricks and adding new bricks?
91:40 - The self.bricks table,
this table here, it's
91:45 - getting assigned to a brand new
table from levelmap.createmap.
91:48 - When there are no references
to an existing table,
91:51 - lua's garbage collector
will trigger at whatever
91:54 - interval it's set to trigger and
clear up all that for you dynamically.
91:57 - Just like the same way that Java works.
92:00 - Almost identical.
92:02 - Any other questions?
92:06 - All right.
92:07 - So we have progression.
92:10 - In the sake of speed, I won't demo.
92:11 - It also takes a while just because
we have to clear an entire level then
92:14 - get to the next level.
92:16 - But that's how the behavior works.
92:17 - The next sort of iteration
of this is high scores.
92:22 - And I will test to make sure whether
or not this is actually working.
92:30 - I know I changed some stuff.
92:31 - Yeah.
92:32 - So high score.
92:33 - Let's debug for a second.
92:34 - So HighScoreState line 38 in Breakout10.
92:44 - So HighScoreState.
92:49 - And then the issue was [INAUDIBLE]
to index field high scores.
92:54 - A nil value.
92:56 - OK.
92:57 - So that means that--
92:59 - OK.
93:00 - I think I might know the
issue, but it's because I
93:03 - transitioned to a new user that doesn't
have a saved file active on this.
93:06 - The way that will transition,
therefore, into love.file system, which
93:12 - is Breakout10's main new thing that
it introduces-- so writing files
93:17 - to your file system is done
[INAUDIBLE] with love.filesystem.
93:22 - And there's a few things.
93:23 - So Love automatically gives you
a directory, a save directory
93:28 - that's pretty much hard coded.
93:30 - There are a few exceptions as to
how to not use that directory,
93:33 - but it assumes that you're
always using that directory.
93:36 - And with very few exceptions
will you always use that folder.
93:42 - It's like app data local on
Windows, and application support,
93:47 - and the name of your application on Mac.
93:50 - But it's a subfolder that Love
has read and write access to
93:53 - for files on your file system.
93:55 - You can check whether it exists with
love.filesystem.exists at some path.
93:59 - You can write to that path with some
data, that data being a string value.
94:03 - And then love.filesystem.lines
is an iterator,
94:08 - which will allow you to look
over any of the data that's
94:11 - in a file at a given location.
94:12 - Yes.
94:13 - AUDIENCE: [INAUDIBLE]
94:16 - COLTON OGDEN: Yeah.
94:17 - AUDIENCE: Does this
work if you [INAUDIBLE]
94:20 - COLTON OGDEN: It should.
94:21 - We can pull that up
now actually and see.
94:24 - Because I know on their Love2D--
94:28 - so file system.
94:30 - So the question was he ported his--
94:35 - when you port your
Love app to the iPhone,
94:39 - will it have the same sort
of behavior if you're--
94:47 - on an iPhone, will it have the same
sort of save directory behavior?
94:50 - And it looks like it's
not officially on here.
94:53 - I know that there is
an iOS port for Love2D,
94:57 - or the ability to send it to Love2D.
95:02 - AUDIENCE: [INAUDIBLE]
95:05 - COLTON OGDEN: I have to imagine yes.
95:07 - It probably has some sort of--
95:08 - I'm not entirely familiar with how
iOS handles sort of local storage,
95:14 - but I'm assuming that just in the way
that it's been abstracted for desktops
95:18 - and for Android, it's
also abstracted for iOS.
95:20 - Haven't tested it myself.
95:22 - I would experiment and see
actually maybe with this code.
95:25 - See if you can maybe get it working
with persistent high scores.
95:29 - I know that iOS does typically let you
store a small amount of data per app
95:33 - in some location, a fixed
location, but I'm not
95:35 - entirely sure what that is offhand.
95:37 - I can look into it more
and come up with a--
95:40 - AUDIENCE: [INAUDIBLE]
95:41 - COLTON OGDEN: Yeah.
95:42 - I mean, not from firsthand
because I don't have an Android,
95:45 - but it has official Android support.
95:47 - So I'm guessing it does,
but I haven't tested it.
95:50 - I have not tested it manually
on Android to verify that.
95:59 - But yes.
96:00 - I believe-- because in the prior
directory we were looking at when it
96:03 - showed--
96:05 - oh, it's actually up here.
96:08 - This path here.
96:09 - This data/user/0/love2d.android.
96:14 - file save.
96:15 - That looks to me like it's
the official sort of path
96:18 - that data is stored on an
Android device for application.
96:22 - So I haven't tested it myself.
96:24 - But if you have an Android and
you're curious or maybe an emulator,
96:27 - give it a shot and see if it works.
96:30 - Oh, and it even says here, there
are various save locations.
96:32 - And if they don't work, you can
see what the actual location
96:35 - is with this function here.
96:37 - The love.filesystem.get save directory.
96:39 - That may work on iOS as well,
so I'd be curious to hear about
96:43 - whether that actually works on that.
96:50 - Yeah.
96:51 - So that's the gist.
96:52 - Using the love.filesystem abstraction
lets us read and write files.
96:55 - We can then just paste or we
can just save whatever data
96:58 - we want anywhere within that directory.
97:02 - We can just create files in there
and then use those to store our,
97:06 - you know, sort of game worlds, or
character profiles, or whatnot.
97:10 - How would we maybe go about implementing
sort of like a high score list?
97:21 - So I'll look.
97:21 - There's a picture here.
97:24 - So we have 10 scores.
97:27 - We'll assume that's fixed.
97:29 - Each of the scores has a name, and then
each of the scores has an actual score.
97:34 - So all we really need to do is
just store ultimately the names
97:39 - and then the scores.
97:42 - AUDIENCE: [INAUDIBLE]
97:47 - COLTON OGDEN: So we'll use an array.
97:49 - Their response was we'll use an
array as sorted by that score.
97:53 - Yeah.
97:53 - Essentially that's exactly it.
97:55 - We're just going to keep a
score table and each table
97:57 - is going to have a sub table.
97:59 - And each of those
entries, one through ten,
98:00 - is going to have a name and a score.
98:02 - And then once we're done
with our application,
98:05 - we'll just use love.filesystem.write.
98:07 - We'll have to convert all
of those into a string
98:10 - because we can't just take a table
and then spit that out into a file.
98:15 - We have to actually make it
into some form that we can save
98:18 - and then reload back in somehow.
98:20 - What would be the most efficient way,
do you think, or a way we can do this?
98:28 - Probably just a new line separated list.
98:31 - The way that I've done
it in this application
98:33 - is just names, and then new line,
score, new line, name, new line, score.
98:39 - 10, so 20 rows.
98:41 - And that gets the job done.
98:43 - Assuming that you don't tamper with
the file, then everything should work.
98:46 - And you can write
additional code as well
98:48 - to say, oh, if there
is a score that's all
98:51 - garbled, we don't have
enough scores, then probably
98:53 - should render it accordingly.
98:55 - My code does something similar
to this, but not entirely.
99:02 - The relevant code-- and I'm going
to sort of just glaze over it.
99:06 - If we're looking at--
this is Breakout11, right?
99:08 - Yeah.
99:09 - Oh, no, this is Breakout10.
99:11 - So in Breakout10, we have
to load all the high scores
99:14 - in main.lua, which is here.
99:16 - So set identity to Breakout or
create a folder called Breakout
99:19 - that we can save and
read files to and from.
99:22 - If it doesn't exist,
then just create them.
99:24 - In this case, I'm just
seeding CTO my initials.
99:26 - And then I times 1,000.
99:28 - So 10,000 down to 1,000.
99:30 - Just very simple data.
99:33 - Writing into a file called breakout.lst.
99:34 - It can be whatever you want.
99:36 - All we're doing is reading lines
from the data, or from the file.
99:40 - And then this is if it doesn't exist.
99:42 - And then if it does exist, then
we're going to iterate over it
99:50 - with love.filesystem.line,
which will take a file
99:53 - and then just split it on new
lines basically and give you
99:56 - an iterator over all those lines.
99:58 - So it can just say, OK,
if it's a name, which
100:00 - means that if it's one or three
or five or seven in the list,
100:06 - then set the name to--
100:08 - and we're using string.sub
just in case they
100:11 - write some long name or some
long name gets-- they can't do it
100:14 - through our game, but if it gets
written to the file as some long name,
100:17 - it should get truncated
to three characters
100:19 - so we can display it appropriately.
100:22 - And then otherwise if
we're not on a name line,
100:24 - if we're on, like, an
odd line or even line,
100:28 - we should consider that a
score and just use to number.
100:32 - Because we're using string
data and if we try to assign,
100:37 - do any sort of comparisons
numerically on the string data,
100:39 - which we will have to do
to compare high scores,
100:41 - it's not going to work because it's
going to see that there's strings.
100:44 - So we use to number here.
100:45 - Just a simple Lua function.
100:46 - And then that's it.
100:47 - And then we just return scores.
100:50 - And then I'll sort out
what's causing the issue,
100:53 - and then push that to the repo ASAP.
100:56 - But that has the effect of us being able
to actually load all of our high scores
101:00 - and display them at
the start of the game.
101:03 - It doesn't take care of being
able to actually input our score.
101:08 - And so we can do this with Breakout11,
which you can see if you run the repo.
101:12 - And you can test just to assign your
initial score to some value like 10,000
101:17 - or 20,000, and then just
lose on purpose and you
101:19 - get a sense of how it actually works.
101:21 - But essentially, it's just arcade style.
101:24 - You know, you had only three
characters you could input your name.
101:26 - So does anybody have any idea as
to how we are sort of storing this,
101:31 - or can pitch an idea?
101:36 - So we have three
characters and we want to--
101:41 - ideally if we're, let's say I
want to go to C on the first one.
101:45 - Let's say I pressed up twice so I get
to C. How is it going from A to C?
101:52 - You could just say,
you could just render
101:54 - I want to render the character A,
the character A, the character A,
101:58 - but how is it going to know when
you want to go to B, or C, or D.
102:01 - AUDIENCE: [INAUDIBLE]
102:15 - COLTON OGDEN: The pitch
was, you could create
102:16 - a table with all of the
characters and iterate through it.
102:19 - You absolutely could do that.
102:22 - It's a little bit bulky.
102:23 - That might be what--
102:24 - actually, that's probably not how
arcade systems did it back in the day.
102:28 - Because the way that we're going
to do it here in Breakout11 is I
102:38 - added a new state called
EnterHighScoreState.
102:43 - And if you recall, CS50 teaches this.
102:46 - But all sort of characters at the
end of the day are just numbers.
102:51 - ASCI.
102:53 - In this case, 65, if you
recall, is capital A.
102:58 - So all we need to do is just
draw out whatever that character
103:03 - cast to a string is, or character.
103:06 - And we do that simply down
here in the draw function.
103:11 - If we do string.char, at char is three.
103:19 - All that has the effect of
doing is just taking that number
103:22 - and then converting it to a character.
103:25 - So all we need to do then is what?
103:27 - When we want to go from
A to B, B to C, C to D.
103:33 - AUDIENCE: [INAUDIBLE]
103:35 - COLTON OGDEN: Exactly.
103:36 - But then what happens if we're
at A and we want to go down?
103:39 - AUDIENCE: [INAUDIBLE]
103:41 - COLTON OGDEN: We would.
103:42 - So if we're at A, then if we press
downward and we want to go to Z,
103:49 - the logic is in here.
103:53 - But one we've incremented our code,
if it's greater than 90, which is Z,
103:59 - then we should set it back to 65.
104:00 - We'll loop back to A.
104:01 - And same thing here.
104:02 - If we press down and we're at
A, we've got to go back up to Z,
104:06 - so we just set it to 90.
104:08 - So simple loop back logic.
104:09 - And we just draw it, we highlight.
104:11 - And then once we've done
that, the user presses Enter.
104:14 - We transition to the
HighScoreState, actually,
104:19 - because this state should only trigger
if they entered a new high score.
104:22 - Which means that we need to check in the
VictoryState, or not the VictoryState,
104:26 - but rather in the
GameOverState whether or not
104:29 - their score is higher than any
of the stores in some sort of,
104:33 - quote unquote, global scores table.
104:36 - And then how do we think we're
passing the scores back and forth now?
104:42 - Does anybody recall how we're
keeping track of app state?
104:48 - AUDIENCE: [INAUDIBLE]
104:55 - COLTON OGDEN: Yep.
104:55 - In the change function.
104:57 - So all we need to do
is keep track of-- load
104:59 - our high scores at the
beginning of the game,
105:01 - pass them all the way down the line.
105:03 - And then finally-- and we can also
load them in our EnterHighScoreState,
105:07 - but we need to keep track of what our
high scores are in the GameOverState
105:11 - so that we know, oh,
I've got a high score.
105:13 - Let's instead of transitioning back
to the StartState, let's transition
105:16 - to the EnterHighScoreState so the user
can add their high score to the list.
105:22 - And then once they've entered
their high score, which is here,
105:30 - we'll just write it to this file again.
105:35 - Compile a score string, which
takes name and score of our scores.
105:39 - We take whatever score
that we were at that's--
105:43 - we look through our
scores table backwards
105:45 - and when we find a score
that's lower than ours,
105:47 - we just keep track of that index until
we get to one that's higher than ours.
105:51 - In which case the one plus
one, that index plus one
105:54 - is what we should then overwrite.
105:55 - And so we shift all the
other ones below accordingly.
105:59 - And we do that in this class if curious.
106:01 - And so I'm just going to
breeze through the last couple.
106:04 - The paddle select update is
just kind of a fluffy state
106:07 - that lets us add a element of sort
of, like, user selection to our game.
106:13 - In our PaddleSelectState here,
we transition immediately.
106:18 - Instead of going to the
[INAUDIBLE] PlayState now,
106:21 - we're going to go from Start to
Paddle Select when we hit Start Game.
106:26 - So we're going to go to--
106:27 - and then the Paddle Select class itself.
106:32 - CurrentPaddle gets one,
and then all it essentially
106:35 - is is us drawing two arrows here.
106:42 - And so if we're at number one-- in this
case, I think we're at number three--
106:47 - then both of these arrows
will be completely opaque.
106:49 - But if we're on the left or the right
edge, they should darken to say to us,
106:53 - oh, we can't move left or
right anymore because we're
106:55 - at either index one or four or five,
and there's only that many colors.
107:00 - And then render whatever
that color variable
107:02 - is using the quads table that we
had before of the different tables.
107:07 - And then just instructions.
107:09 - And then from there is where we'll
end up transitioning to the ServeState
107:13 - rather than going to the
ServeState from the StartState.
107:18 - And all the code in that is here.
107:20 - We have sound effects playing.
107:22 - And then making sure that we
also play a different sound
107:26 - effect based upon whether they're
at the left or the right edge.
107:29 - If they're on the left edge
and they try to go left,
107:30 - it should play like a sound that
sort of sounds a little rougher
107:33 - to let them know that
they can't go left,
107:35 - and the opposite for the right edge.
107:38 - And then once that's all done, once
they press Enter on whatever paddle
107:42 - they want, they're
going to get the paddle,
107:46 - we're going to instantiate a paddle,
pass that into the ServeState,
107:50 - and we're going to take
currentPaddle from the state, which
107:53 - is whatever value they got by scrolling
between all the different paddles.
107:59 - And then the last update, which is my
favorite part of most every lecture
108:06 - I think is the music update.
108:09 - And all that really is is just
music set play in main.lua,
108:15 - and then set looping to true,
and then we have a game.
108:19 - And this is our Paddle Select.
108:20 - So notice the arrows are semi-opaque
on the left and the right.
108:25 - It's kind of hard to hear,
but when I press right now
108:30 - it's kind of like there's
a bit of a rougher sound.
108:33 - We choose red.
108:35 - We go to level one and we
transition to the ServeState
108:37 - from the PaddleSelectState, and then
we just play the game as normal.
108:43 - And that's basically all there is to it.
108:45 - And there is a couple of features we
didn't have time to really go over
108:48 - like making sure we recover HP
if a certain amount of points
108:51 - have been elapsed, but
I encourage you to look
108:53 - into that when you trigger a hit.
108:56 - There's some logic in
the PlayState to say, oh,
108:58 - if they've gone over a
current recovery threshold,
109:01 - let's add one heart to the player,
you know, just keep them playing.
109:04 - Just to reward them
for their high score.
109:08 - Next time we'll cover a few concepts.
109:10 - So basic shaders.
109:11 - Shaders are like little programs
you can run in your graphics card
109:13 - and do fancy effects, but we
won't go into too much detail.
109:16 - Anonymous functions.
109:17 - We've seen a lot of anonymous functions
in Lua in the context of Love.
109:21 - They're just functions without
a name, and you can just
109:23 - use them as function arguments and
do all sorts of cool stuff with them.
109:26 - We'll use them for callbacks
next week when we do things
109:29 - like tweening, which
is taking some value
109:31 - and making it interpolate
over time to some other thing.
109:35 - Because right now we've basically just
been updating things based on velocity,
109:38 - but we haven't really done
anything based on time.
109:40 - So we'll take a look
at that in more detail
109:42 - next week with a library called
timer, which is really fantastic.
109:46 - Lets you time things and
then chain things together.
109:50 - We'll be covering the game
Match Three if familiar.
109:52 - It's basically Candy Crush.
109:54 - We'll be using a different tile
set, but it's the same idea.
109:57 - And we'll have to calculate
how to actually find out
109:59 - whether we've gotten a match
in the grid, our tile grid,
110:02 - and then shift the blocks accordingly
and do all the other logic, add score.
110:06 - And then basically since it's so
fundamental to Candy Crush and games
110:10 - of its nature, we will have to
cover how to sort of generate
110:13 - these maps procedurally to have tiles
that are laid out in a dynamic way,
110:17 - and also in a way that doesn't
start off with any matches
110:19 - because then that wouldn't make
any sense because the matches have
110:22 - to resolve.
110:23 - And then we'll take a little time
if we have the time next week
110:26 - to talk about sprite
art again and palettes.
110:28 - And maybe I'll show you guys how
to sort of convert images from one
110:32 - palette to another in, like, a
program that I use, Aseprite,
110:35 - but you can do this in any sort
of large photo editing software.
110:40 - And then assignment two is a
couple of extensions to Breakout.
110:44 - So if you noticed in the sheet
there were a few little sprites here
110:50 - at the bottom--
110:51 - so get rid of the quad outlines.
110:53 - So these little things down
here are, I'm assuming,
110:56 - they're meant to be power ups.
110:57 - They look like power ups.
110:58 - But the goal of the pset
is to implement a power up.
111:01 - And a power up is going to be
such that when you grab it,
111:05 - you'll get two additional balls,
or however many you want actually,
111:08 - that will spawn in addition to your
one and detect collisions on their own.
111:12 - So you'll have several and
they'll score points for you.
111:14 - And, of course, only when the last ball
comes below the surface of the screen
111:18 - should you trigger a Game Over.
111:20 - And then I want you to
add-- and this will also
111:22 - be more detailed than
the spec-- but I would
111:24 - like you to add growing and
shrinking to the paddle.
111:26 - So currently, we have like
four different sizes of paddle,
111:29 - but we're not using them.
111:31 - So it would be nice if when we gain
enough points or we lose points, or not
111:34 - points, but lives rather, we increase
or decrease the size of the paddle
111:37 - accordingly just to introduce
another level of challenge
111:40 - and or lack of challenge.
111:42 - And then finally, one last part
which is in the sprite sheet as well,
111:46 - there's a key block here
and a key power up here.
111:54 - So sort of let the power up come,
pick the power up with your paddle.
112:00 - And then only when you have
that power up should you
112:02 - be able to break the block with a key.
112:06 - And you should take
this into consideration
112:07 - when generating your levels as well.
112:09 - So you'll have to also get your
hands dirty with the level maker.
112:12 - But all in all, that was Breakout.
112:14 - So I'll see you guys next time.
112:16 - Thank you.

Cleaned transcript:

[MUSIC PLAYING] COLTON OGDEN Hello, everybody. Welcome to GD50 Lecture 2. This is Breakout. And interestingly, CS50 has a history with Breakout, so I pulled this up today. This is Pset3 in 2015, 2014. It was an implementation of Breakout using the Stanford Portable Library, which was a sort of Java library that we were able to get C bindings for. And so students were able to actually implement a game what was at the time the CS50 appliance, which is a Linux distro. But suffice to say that was oh, a funny story also. I happened to also write the lasers for this implementation back in the day. And I think that was one of the first bits of code I got my hands dirty with when working with CS50. So today in the context of Breakout, we'll be talking about a few different things that we haven't talked about yet. Sprite sheets being chief among them most likely. At least the most visibly so. So sprite sheets are simply a way of taking an image, a large image, and rather than splitting it, rather than loading individual images for all of your different things in the game, whether it's your aliens or your paddles or whatnot, you can put everything into one sheet and then just sort of index into that sheet using rectangles, quads. We'll talk about soon. Which will allow you to just draw a subset of that image, and therefore condense all of your artwork just into one piece, one file. We'll be talking a little bit more about procedural generation in the context of Breakout. And in this case, we'll be laying out all the bricks in the game world procedurally. So having instead of the same set of colors, in this case, the standard layout is to have a bunch of the same colored bricks row by row. We'll actually implement a dynamic generation approach and have a bunch of different cool layouts we'll see. And it's actually quite simple to achieve pretty believable results. We'll manage state a little bit better in this game. So before we sort of had a couple of global variables and we didn't really have the concept of a per state or a global state that we were cleanly sort of sharing between all of our states for our state machine. But to avoid having sort of like a polluted global name space and to just sort of keep things a little bit cleaner, we'll end up taking all of the important variables for our code like, you know, the player and any other entities. The bricks, the ball. And rather than keep them in our main [INAUDIBLE],, we'll end up shifting them. We'll sort of transfer them to and from the different states via the state machine's enter method. We'll actually have levels. So a progression system. So start at level one, go up. And then with each level, we'll implement a scale in terms of the generation of the bricks. So we'll get higher tiered bricks and more points as a result. We'll have a health system. So hearts, in a similar fashion to Legend of Zelda. Particle systems, which are a very important aesthetic component to 2D games and 3D games. Particle systems basically being a bunch of spawned images that you sort of cluster, you put into a little spawner, emit them in a certain way, and color them, perform math on them, and get sort of believable effects like fire and smoke and all these other things that would otherwise be not easy to do using simple animation, but trivial with a particle system. We'll do a little bit more complicated collision detection with our paddle and with our bricks than we did with Pong. And then we'll also talk lastly about how we can save data locally to our computer so that when we close the application and run it again, we end up having a persistent high score rather than just something that's volatile. So first though, I would like to demo today's finished game. So if anybody would like to demo from the audience, that would be nice. Go ahead and come up. I'll go ahead and cue it up for you. What's your name? JEREMY Jeremy. COLTON OGDEN Jeremy. Colton. JEREMY Nice to meet you, Colton. COLTON OGDEN Nice to meet you. So we're going to go ahead and run Breakout here. And so it uses the arrow keys. So if you go ahead and press up and down, you'll see you can move between the start and the high score screen. So they're two separate screens. So go ahead and here we have when you start, you can choose a paddle. So rather than just the same old paddle every time, you get to select. And as you can see here, he chose green. So he gets the green paddle. These bricks all procedure generated. So if he runs the application, they'll be completely different. And as is the classic formula, the ball moves between the bricks and the paddle. When it hits a brick, if it's of a certain color, it'll either get destroyed in this case, if it's blue, it's the base color brick. So it's the lowest value. And if it's higher than blue, it'll end up going down a color depending on which color it is. I believe it goes blue, green, red, purple, yellow. So anything higher will get shifted down. And then the player amasses points, as you can see top right. Score. And notice also the three hearts. That will be the player's health. So if he were to lose on purpose possibly, we can see he gets another message that's saying press Enter to serve. His hearts have gone down by one. So now he's got two out of three health. And so eventually if he were to by chance lose completely oh. That's honestly the most fun part about Breakout is just getting it caught in a bunch of stuff. But you can see we go to a Game Over screen. It shows your final score. And then you can press Enter and it will oh. I must have had a bug. But that should take you back to the if in the event that you have a high score, it'll take you to enter a high score. And if you don't have a high score, it'll take you back to the Start menu. So I made a couple of last minute changes. Unfortunately I must have left something in there. But that's Breakout in a nutshell. Our goal today will be to implement basically all the functionality we saw. Oh, we didn't take a look at the high score screen. So let's take a look at that really quick as well. So here at the title, you can see we have Start and High Scores. Oh, man. OK. I must have screwed something up. So I'm going want to go [INAUDIBLE] Breakout 12. OK. Sorry. I apologize. I'm going to fix that. But it should show this menu here where you will have a list of all your names that get loaded from a file and will output your score accordingly. And in the event that you get a new high score, you'll get to enter your name after that, and then it will end up saving it to another file. And when we get to that point I'll try and fix it so that we can actually see what it looks like. So let's go back to these slides here. So this is the overall state, flow of our game. So as you can see by me marking it out in a highlighted color, we start off in the StartState. And this is all stuff we've covered before. Just the state machine. It's a little bit more complicated than Flappy Bird. We have eight states as opposed to I think it was four or five in the last lecture. And the arrows illustrate which states can move in between other states. So as we saw, the StartState can move via the up and down arrows in the HighScoreState. It can move between the HighScoreState and back. So when you go into the HighScoreState, press Escape, go back to the StartState. The StartState also has an arrow branching off to the left going down to the PaddleSelectState where we saw the user is able to select a paddle to use. Once they've selected a paddle, we'll go to the ServeState. They'll be able to serve the ball at their leisure. And then it will go back and forth between the PlayState. So if they end up taking damage, the ball goes below the surface of the screen, they'll go back to the ServeState again so they can reorient themselves. If they're in the PlayState and they end up scoring, clearing the whole entire set of bricks, they'll actually get taken to the VictoryState. And the VictoryState is where we increment the level and we also regenerate the level. And the VictoryState goes back to the ServeState, and then we repeat that whole loop again. In the PlayState if they are to get a Game Over, they'll go to the GameOverState, it'll tell them their score, and then they'll go to the EnterHighScoreState depending on whether they have a high score. And if not, as seen by the arrow that goes up and to the left, they'll actually go back to the StartState. And then the EnterHighScoreState will also go back to the HighScoreState so that they can see once they've entered their high score, their score relative to the other scores in the list. So in Breakout0, which we're going to look at now, we're going to do some very basic stuff. So this is the Day 0 update as always. I'm in Breakout0 right now. Yes, I am. So what we're going to do is we're going to look at first thing here, line 27. So before what we were doing in our application is having basically a lot of files at the top level and sort of losing track of what we were doing potentially. Especially as you start adding more and more files and you've got like 50, 100 more files, that's something that's obviously not maintainable. So the solution there, just put them in folders and then keep track of everything. Keep them organized. And that's a major thing that we're going to start doing. And on top of that, we're also going to, in our code, keep things a little bit more modular. And that's why we have this file source slash dependencies, which we'll take a look at in a second. We've allocated a bunch of global tables here. So we're taking the design decision of even though I mentioned that we will be sort of taking a lot of the global variables out of our application assets, we're going to keep all of those in some global variables. And we'll see in the future how we can maybe implement a resource manager class that takes care of this for us. But for now, for simplicity's sake, in love.load, we're just going to have a few global tables that contain, in this case, global fonts. So by key, we can index small, medium, and large fonts, which are just new fonts at different sizes. 8, 16, 32. And we're using it. We have a fonts folder now instead of just keeping it at the parent level. We're going to set it to small. We have global textures. So background, main, arrows, hearts, particle. So we have the background, which was the background of our screen. Main has all of our bricks, paddles, the balls, et cetera. Arrows are going to be for the paddle select screen. The two left and right arrows. Hearts are going to be for our health. And then particle is a single, small, tiny little texture that we'll use to spawn all the particles in our particle systems later on as we get towards the end of the demonstration. So this is push. We're setting it up just like normal. Nothing new there. Except the virtual width, virtual height, and all that stuff, those have been moved out, if we look into source in a constants file. So this file here, instead of having all the constants in main, it kind of makes sense just to take them out, put them in a file called constants.lua, and we can sort manage all that. We can know immediately when we're looking at capital window width, window height, et cetera. And these are all constants. If you have a constants file, we just can more easily track it rather than having to grab through all of our files to try and figure out what we were looking at. And the constants are used here in our set up screen as before. And then another sounds global table, just as before. We have a bunch of different sound effects. I've separated the music from the sound effects just so that we can see at a glance, oh, this is the music, these are the sound effects. Pretty straight forward. We have a state machine, as always. And we're just going to use a StartState for this demonstration. Setting it to Start. Love.resize, love.update. These are all functions we've seen before. Nothing too new. Love.keypress. We have a global input table. So as in the case of Flappy Bird, we can index into that input table anywhere in our application and call love.keyboard.wasPressed[key], which allows us to take input exclusively from main and use it in other modules. Here we're drawing the so this is the actual rendering code. And we're doing this in our love.draw as opposed to a specific state because this is actually going to apply to all states. We're always going to have this background. So rather than duplicate it over and over again, in this instance, this minor bit of code, we're going to display the background behind all the states. So all the states are going to render over this background and make it seem a little more cohesive. We're going to draw at 0, 0 without rotation. And then this bit of math here, the virtual width divided by, and then background width minus one, end up being a scale factor so that we can always scale it to be our virtual width. Because the texture by default is some amount smaller than our actual window or our actual virtual width and height, but by dividing virtual width by whatever the background width of that image is by one, we'll get a scale factor because virtual width is larger than the image. We'll get a scale factor on X and Y that equates to it completely stretching to fill our virtual width and height. And recall that these two parameters are the scale on the X and the Y. So it's going to be some, like, one point something or two point something. Whatever it takes to end up filling the screen. And then lastly here, the new bit I implemented is just a display of frames per second function, which I think is kind of important generally, and it's very easy to do. I don't recall, I don't think we talked about it yet, but just love.timer.getFPS. And then I just draw in the top left in green so that we can see it throughout all of our iterations of the game, what are frames per second are. If you want to monitor without having to look through your terminal or anything like that, just displaying at the top, it's standard practice in a lot of games. If you've gone to the debug console or whatnot or sort of looked into some of the hacks, you'll see that in a lot of places. So I talked earlier about dependencies.lua. So this ties in as well to our effort to sort of modularize everything, keep everything organized. Instead of requiring everything at the top of main, let's just put it all in a file and then we'll know at a glance what we're requiring and we don't have to look through main and make main 100 lines, potentially a lot more than it needs to be. So requiring push, requiring class. Same as we've done before. Require source.constants. We have access to those. Require StateMachine, and then BaseState and StartState. So let's go ahead and take a look at our StartState. So I put states in a subfolder of source. This is another effort to sort of keep things modular. In this particular project, we won't have a lot of nested folders of code, but I decided to put the states in their own folder just so easily you can get access to all your states. So we'll look at StartState here on line 21. So recall in the StartState, we just had Breakout in the center of the screen and then we had Start Game and High Scores. So the user was able to highlight which state he wanted to look at. So we need to keep track of which one is highlighted. So all this variable's purpose is just to keep track. So one or two. One being Play Game, and two being High Scores. And then here if we press up and down, then we because there's only two options effectively, you can just flip whatever highlight is with one or two. If you have a list of options that's more than two, you'll need to increment one until it gets to whatever X is, your number of list options. And then if you press down at that point, you should flip back up to the top. And the same holds true for whether you're at option one. You should go flip, rotate to the bottom of your list so that it looks as if you've gone all the way around. And then we're just playing a sound here when we do that. We have a love.keyboard.wasPressed[escape] call here. It's not global anymore because there are some states in our application where we might want to press Escape to actually go backwards, and we'll see that. And so rendering here. We render Breakout with a large font. Now that we can access G fonts at large key in the center of the screen, set medium font. And then we're going to render our two text fields one after the other. But if highlighted is equal to one, then we're going to set it to some blue color, which is one of three 255, 255, 255. And then render it. And then make sure to reset the color after that because recall love 2D is sort of like a state machine in its own right, where if you set the color to something, whatever you draw and render after that, be it images or text, will adopt that color. So having everything be 255, 255, 255, 255, which is pure white, completely opaque, has the effect of drawing everything completely opaque. But if you don't do that, your images or whatnot that you draw afterwards will be tinted or transparent, which you most of the time don't want. But you might sometimes want that, and we'll actually see that in the PaddleSelectState. And same thing holds true here. If highlighted is two, do the exact same thing. And so if we run this application, which is mainly just a subset of what we saw before, we can move up and down between Start and High Scores. But if we press Enter on any of them, nothing happens because we have no event handlers actually taking care of that. But we have the image scaled to the screen, we have Breakout in the middle, and we have our two menu options there. So Breakout1. So this is where we start to dive a little bit into sprite sheets, which is a major component of game development, 2D game development that we'll be looking at in the future and in this application. But a sprite sheet is just, ultimately, rather than have I don't know how many images there are on this sprite sheet here. But however many of these files, just have one file put them all together, and then using rectangles, define where all the different sprites are. And then when we want to draw, use those rectangles and just tell love.graphics.draw, I want you to draw this texture, this sprite sheet, but I want you to draw just this section of it. You'd pass it in a quad, which is just simply rectangle with height, X and Y. And love 2D will know, OK, I'm going to draw the image, but only this bit. And it has the effect of looking as if you're only drawing tiny little images as opposed to one monstrous image. And the functions that are relevant for us to look at are love.graphics.newquad, which takes an X, Y, width, and a height. And also a dimensions object, which you get from an image. We'll see that. And all that basically is, I believe, is just an X, Y, width and height as well. Or just a width and a height, rather, from whatever image you want to create quads for. And then love.graphics.draw, we've already seen it, but this is a different signature. This has texture, quad, X, Y. Quad being the second argument. And when it takes in this quad, it knows to only draw that defined rectangle of image to the screen. And so we'll go ahead and take a look now at Breakout1. AUDIENCE [INAUDIBLE] COLTON OGDEN The question was, are there any tools so that we don't have to guess where the quad is when we're doing the sheet? Yes, there are a lot of the time. I looked and saw a couple, but I haven't tested them thoroughly myself. For simpler examples like this, it's usually easy enough to programmatically do it. But yeah, when you get into having giant sprite atlases where you have especially things that are not necessarily symmetrical or rectangular looking even though they still need to be defined rectangularly, it's often best to use a tool like that. There are, I do believe, I just haven't used them. I can bring it up in a future lecture so we can discuss. Any other questions before we carry into Breakout1? All right. So I'm going to go ahead and open up the very first thing we should look at on Breakout1. In the source directory, we have a new file. And from here on out, I'm going to assume, we're going to always assume that when we introduce a new file, we're going to include it in dependencies.lua. And so in this case, all we need to do is just say require source/util. And as you can see, we're also adding a PlayState to this demonstration. But from here on out, I won't make mention of us actually adding it to our project. So util.lua is the module that contains the code we're going to use to actually generate quads for a given sprite sheet. And this function, all it does, is it takes an atlas or sprite sheet the names are synonymous. You'll hear them both. Or we pass it an Atlas, we pass it the width of the tile that we want and the height of the tile that we want. It's going to get the width and the height of the sheet here. So every image has a function called get width and get height, so we're just going to do that. And specifically the sheet width and sheet height are the width of the image divided by tile width and tile height. So we know how many times we need to iterate over the sprite sheet to generate a rectangle. We're dividing it up based on the size of our tiles. And then we just basically do a simple nested four loop here. We start a counter and a sprite sheet. This sprite sheet is going to be a table that holds all of our quads. We just say for Y, get zero. Sheet height minus one. So starting at the top left, going down. And starting at the top going down, and then x equals zero, starting at the left going right. At sprite sheet, sheet counter, which is one here because in lua, tables are one indexed. We're going to create a new quad at X times tile width, Y times tile width. Give it the width and the height of our tile. So just whatever we passed into our function signature. Here it will often be in this case be 16 by 32 because that's the size of the bricks. And then we pass in the last parameter that we saw in the slide, which is atlasgetdimensions. And then we just increment our sheet counter here. And then at the end of this, when we're all done, we'll return this. We'll have a table of quads that we can then use that are in a sort of one, two, three, four, five, six, seven, eight. Well, I should say, one, two, three, four, five, six, seven, eight top left to bottom right of all the sprites in our sheet to make it super easy to look at. We have another function here. Lua doesn't by default, have a slice function, but we are just adding to it. Table.slice. It takes the table a first, the first entry in the table that we want, the last entry, and then the step between them. Just like Pythons slice function, it just iterates over the for loop, which is first till one. So one by default. Until the last or until whatever this sort of number sign is the size of a table, which I don't think we've introduced yet. But basically, if we pass in last, it'll stop there, otherwise just assume we want the whole entire table. And then this comma here at the end, which has step or one, you can pass in a step at the end of a for loop as a third argument, and that will be however much increments or decrements the loop that you're in. So by default, just one. We go one, then we go to two, then we go to three. But you can set it to negative one. And so if you say four i gets three to one minus one, you'll go three, two, one. And you can't do normally a step, which is what we do here. No, you can do a step, but you can't slice, which is why we have here sliced at number of slice plus one gets table i, and then eventually we return slice. So it just returns just a segment of whatever table we're in. And then the important function here that we're actually going to use in our application, we're going to generate quads paddles. And so this takes X and Y, 0 and 64. And if we look back at our paddles here, we can see that we have various different sizes. So we have a small one, a medium one, a large one, and then a really large one. So if we want to get every single paddle in our sprite sheet, small, medium, large, giant, notice that we have four blocks and within each of those blocks we have four different sizes. So we can just iterate over this four times and then just define whatever the size of this rect is, that rect, that rect, and that rect. And we'll see the math for it here. If I go zero to three, for i, get zero till three. We're going to go ahead because that will give us four. So that's how many times we want to iterate over the sprite sheet to get the separate quads. We'll get the smallest one. So quads counter. We initialize counter to one. Gets love.graphics, that new quad at X, Y, with the 32 and 16. Oh, and X and Y default at 0 and 64 here because the note recall that these are all 16 tall here. So we're starting Y at 64 so that we start right here. And we're starting X at zero because it's on the left side. So we'll do that. We'll increment counter. Get it at 32 wide by 16 tall. Those are the actual dimensions of the smallest one. The same exact logic applies for medium and for large. Only that we're adding 32 and then we're making it size 64, and then we're adding 96 to X at size 96 because they're getting wider, but they're also offsetting more to the right. And then the last bit is pretty much the same thing as before, except now we're going Y plus 16 back to X because we've gone down a row in our sprite sheet The paddle width at that point is 128, but still 16 pixels. And then here at the bottom because we want to do this four times, we want to go through the chunks are effectively 32 pixels because we're going 16, 16, 16, 16. We're going to add 32 to Y and then go to the next set of four paddles. So this is how we're effectively getting all of the paddle sprites, and they;re going to be stored one through X where I believe X is 16. So we'll have 16 quads defined in our sprite sheet thereafter that we can then return. So I'm going to go back to main.lua now on line 64. Here we have a new global table called gframes. We'll be able to access this anywhere we want to draw stuff. And it's just the same thing that we just saw. Generate quads paddles, and we just pass it in our main texture. And our main texture is this. This is what our main texture looks like. And then we're going to index it. We're going to say it gets the key paddles, because in that particular table was just the quads for our paddles. So in the future, we just need to call love.graphics.drawtexture and then index into gframes paddles at whatever paddle we want. And that's how we can keep track of what we want to draw paddle wise. And in this particular demo we have a new paddle class because paddle is a thing in our game. We can represent it as sort of a class or an object. So we'll define a class for it. Everything is pretty simple thus far. Gets an X and a Y. Dx is zero with height. Skin. The skin is going to be what color it is. We need to keep track of that. And then the size, because size will be how we sort of offset into our paddles, our quads, because the sizes are small, medium, large, giant. One, two, three, four times four. So one, two, three, four for the first set and then five, six, seven, eight for the second set. Those are all sort of by color. So we can just multiply skin times or we can multiply whatever our size is by skin and that will give us the current frame, the current quad that we want in order to draw to the screen. And then on line seven so this is keyboard input here. Stuff that we've seen before. If we're pressing left or right, then the paddles should move. Dx should be set left or right. We want to clamp it. We saw this, we've seen this as well. Clamp the input to the left and the right side of the screen. If the dx is less than zero, do math.max and math.min otherwise if we're moving to the right. And then here, this is actually where we tie it all together and we actually use the quads to draw something onto the screen. So we're calling love.graphics.draw just our texture, our main texture. And then gframes at paddles at our current size, which is two. We want to by default have the medium size plus four times whatever our skin is, minus one. So if our skin is one, which is the blue skin, we won't add anything to it. It'll just be four times zero. But if we have the next one, it'll be two minus one, so we'll end up adding four to that. And because we're adding four to it times whatever that skin is, it will just basically put us four quads in, which is the next, the exact same paddle, but the next color. And then lastly what we'll look at here is the PlayState. So we had just the StartState before, but now we want to actually test to make sure we can draw a paddle, move it around the screen. So we're going to implement a simple PlayState here. So on line 20, we're just calling self.paddle gets paddle. We're initializing a new paddle object. And then we're keeping track of also this is a simple, like, pause demonstration. If self.paused, then actually yeah. Did I say self.paused? I did. OK. I just don't initialize it to anything. I should have set self.paused to false here. If self.paused, we're going to test to see whether we're pressing space, and if we are, unpause it. Otherwise, basically just do the same exact thing in reverse. If we press space, pause the game, play a sound, et cetera. Here on line 39, we're just going to call update on the paddle. Which, just remember, test for left or right input. Here we want to be able to escape the game, so we're going to have a handler for escape. Render the paddle on lines 47, which will do the love.graphics.draw with a quad as we saw before, but it'll use the skin and the size of that paddle to index into the quads tile sheet appropriately. And then here if we're paused, let's just draw some text in the middle of the screen that just says Pause. And we use the large font. So we can go ahead and demo this now and see everything come together. We have as before our StartState. But if we press Enter, now we go to our PlayState and we just have a paddle at the bottom of the screen. It's size two, skin one. Just the blue skin. And we can move it left or right like that. And if it hits the left side of the screen, it will stop. And if it hits the right side of the screen, it will stop as well. So we've made progress, but this is one of the fundamental things I'd like to showcase today is just, like, using quads and categorizing them, organizing them, and being able to draw your assets from a large compiled image rather than keep track of however many images it would take. And you have to name all of them and sort them. It would just be a big pain. So yeah. Definitely going forward when you have more than one sprite, you want to sort of put it together in one sheet, and that's how we can accomplish that. But we don't have bricks, and this is probably the other big main component of Breakout besides the paddle and the ball. We want to have bricks that we can actually hit and aim for on the screen. So this update will address that. So let's go ahead and take a look at Breakout2 in main.lua. I'm going to open it up here. On line 66, you can see we have a new table in our gframes. Because we had one just for paddles, we took out just the paddles from our sprite sheet. We're going to do the same thing for just the balls. So we're going to look at if we look here, we can see that the balls sort of come after all of the bricks here and they're just laid out in eight pixels wide by eight pixels tall increments here. So four pixels to one brick, four balls to one brick, two balls to one horizontally, and then two balls vertically. And so what we'll end up doing is just a simple function in our util that takes a look at that. So let's go ahead and take a look at our util.lua, which we've made changes to. And so what this is going to do is sort of do the same thing that we did before. It has to iterate. So notice we have two rows of balls. We have these four and we have these three. So we want to iterate four times. You want to find whatever the offset is here, the X and Y. So it looks like three times 32 and then three times 16. So 96 by I can't do math. Whatever 16 times three is. And then we'll end up 48. And then we'll have which is what we do here. So we have two iterations. So a four loop that goes from zero to three. So the top row, the four. We'll set a counter to one here. And notice also 96 and 48. That's the X and the Y that we're setting. That's where the offset is for the individual ball sprites. Quads at counter gets and notice also quads is a table. We're going to return this. Quads at counter gets love.graphics.newquad at X, Y. Eight pixels wide, eight pixels tall. That's how large the balls are. And then we're going to add eight to it because we're going to the right. So this iteration just goes left to right. And then here we're going to do basically X being set to 96 and then Y to 56. And then because we were editing X directly in here, we want to reset X back to 96, but then also add the eight pixels so that we have the start for the next row vertically, so at Y 56. Do the exact same thing here, but only do it three times because recall there is four balls on top and then three balls on bottom. And then return it at the very end. And so now we have just an individual table. We don't need to keep like one monstrous table of quads, which I find sort of disorganized. We can just have a table of frames for the paddles, and the balls, and the bricks as we'll see. Actually, I have it up here I think. Maybe not. So in ball oh, actually, hold on. Sorry. So we were looking at I skipped over this one on accident. So the bounce update. So everything I just said is relevant, but I accidentally hit that right two times. We want to go to the bounce update because this is slightly simpler. So we were just talking about the ball, which is perfect. So we're going to take the ball and then we're going to add that to the scene, and we're just going to implement bouncing off the walls. So actually, pretty identical to the code we saw for Pong where you just detect whether the ball has gone past the left, right, or top edge of the screen. In this case, it will also allow us to go to the bottom of the screen and we'll also implement colliding with the paddle so then get a sense of the actual game play and what that feels like. So everything is currently current. So we're going to go after talking about the function to actually get the individual ball quads out of the spreadsheet, we're going to look at the ball class which is going to allow us to spawn them in our scene. So a ball takes a width and height of eight. No velocity. But we're going to allow ourselves to initialize the ball with the skin, and we'll see this later just as a cutesy little thing to you use the actual individual sprites rather than just one constant sprite. We're just going to give it a random number between one and seven because there are seven quads. And then we'll just use gframes balls and math dot random number to get the actual ball spread that we want. And so we have a simple collides function within ball that would allow us to check to see whether we've collided with something that has a X, Y width and a height. So it's a simple A, B collision detection. And then here we have reset. Just resets it to the middle of the screen. Update applies velocity. Stuff we've already seen. This is where we actually implement bouncing off the walls. So if X is less than or equal to zero, greater than or equal to virtual width minus eight, or less than or equal to zero, this should be where we reverse the velocity. In the case of it bouncing off the left side, we want to reverse the X velocity but keep it going up. If it hits the top, then we want to reverse the Y velocity to keep it moving in whatever direction it was moving. And same thing with the right hand wall. And then play a wall hit sound. And we're incorporating the sounds sort of as we go today just because they're so simple. And it's also kind of nice just to have a little bit of feedback when you're actually endpoint of the game. And the exact same code is here for drawing. So we have main texture, but now we're using gframes balls, and then we're indexing that at self.skin. And recall that we just set self.skin in here. So all we need to do to just make it random is just wherever we create a new ball, just give it a math.random7, and then that will index into that quads table so we can draw a different ball texture each time. And so let's go ahead and see oh, actually, no. And one last thing we need to look at is the PlayState has a little bit of new code as well. We're going to spawn a ball, so this is where we do it here. I'm not doing it random, but I could do it random here if I wanted to. I could math.random7, and every time we boot up the game it's going to be a different color because it's going to be a different skin. We need to update the ball. So on line 50 we just update it like we do the paddle. And then on line 52, we're just testing to see whether it collides with the paddle because we're using just simple A, A, B, B. If it collides with the paddle, we can assume it was coming down. We can just reverse as delta Y. Now, does anybody know what might be a current issue with the current implementation of this function? Particularly with this line. AUDIENCE [INAUDIBLE] COLTON OGDEN It will. You're on the right track. The answer was, if the ball is coming from the side, it won't necessarily be bounced back up in the right Y direction. If it's coming from the side, it will always, in this case, be coming from up above. So it always still be reversing in the right delta Y. But what's going to happen if it comes in at an angle and then isn't basically reset? Like right now if it comes at an angle and it gets caught let's say it's like below the top edge of the paddle. AUDIENCE [INAUDIBLE] COLTON OGDEN You're going to get an infinite collision loop because we're not resetting it's position, we're only updating its velocity. If it comes in at the right angle from the side, it's going to get stuck inside the paddle and then it's going to cause a little bit of funky behavior. I'll try and see if I can make that happen in my demonstration here. But that's the gist of all of these updates. So if we go to Start, we can see immediately we have a ball. And when it hits the sides or the top, it bounces accordingly. It hits the paddle. So when it comes in from the top flush on the top, it flips the Y velocity. Let's see if I can get it at an angle here. There it is. It'll get stuck. And so whenever you sort of do A, A, B, B collision detection, just remember to always reset the position of whatever it is that collided that's moving so that it doesn't clip and get stuck inside of something else over and over again. Yes. AUDIENCE [INAUDIBLE] COLTON OGDEN The question is I'm always doing love space dot, and as opposed to just running things from using the complete path of whatever the file is, in order to do that so are you on a Mac or a Windows machine? AUDIENCE [INAUDIBLE] COLTON OGDEN So on a Windows machine it is a little trickier, but I've found a really nice sort of plugin for VS Code. So if you're VS Code, which is the editor that I use, it has plugins and one of the plugins that you can download is for Love2D and it has a config where if you just press Alt L, it will run whatever directory you're currently in, whatever project you're currently in. It will call Love. It adds it to your path for you. So download the Love2D plugin on VS code if you want that to work. I'm on a Mac, so I can edit what's called my batch profile, and alias Love to its complete path in my file system. And you can do the same thing with I don't know how it would work with Windows in terms of aliasing, but it's essentially the same thing as typing out the entire path to Love, but only I'm changing it to another word. I'm changing it to Love. So I'm setting Love equals to application slash love.app/content/resources et cetera. So good question. I would download on Windows. I'm a big fan of VS Code and the Love2D plugin. I would recommend looking into that. And I'm sure there are other plugins, and there's a page also on the website I don't have a browser open at the moment. But on the wiki, you can look at the Getting Started page. I believe it's like love2d.com/wiki/gettingstarted. They have a bunch of instructions for different operating systems and different text editors that allow you to get sort of a more efficient workflow going. So any other questions? All right. So we did the bounce update. Now we can finally edit the bricks. Add in the bricks, I should say. So these are pretty simple. So we're going to take a look at it. And right now we're not going to do any sort of fancy procedural generation, we're just going to get some bricks on the screen. Just some easy bricks. Or rather, we will get some very basic procedural generation, but not to the level that we'll see soon. We'll see that very soon. OK. So I'm going to go into my main.lua here. I'm going to go into the Breakout3. And same thing that we did before on line 67, we just have a new bricks table in our gframes. And it just generate quads bricks. We call from util.lua, so we can look at that really quick as well. This one's actually really easy. Sourceutil.lua. Because they start at the very top of the screen, we can assume that we could effectively treat this whole thing as if it were just these and just generate quads at a constant width and height because, effectively, we only need a subset of the frames that's generating. Because it's generating them this way, top to bottom, left to right, we can just grab all the way up to here using table.slice, which we saw before, and not worry about indexing into any weird, like, having any constants X and Y that we need to index with in order to get an offset. We can just do a very simple if we go down to line 57, generate quads bricks, it just does a table.slice. And so within that, we're going to generate quads atlas 32,16. So this is going to have the effect of dividing up our sprite sheet by 32 by 16 pieces. It's going to generate all of these just fine, but then it's going to have quads here, here, here, here, here that don't line up with the quads that you see here because it's just blindly assuming that all of the sprites in that sheet are the same size because that's all we're doing. We're just calling generate quads, which if you recall, just generates a fixed size width and height throughout our entire atlas, which is great for a lot of sheets that are symmetrical, but there are cases where we have, like, for example here, where our spreadsheet is asymmetrical. We have paddles of differing sizes, we have the balls which are eight by eight, we have the bricks, we have the other power ups at the bottom. But the generate quads bricks takes in that table that we're generating, which is going to be a bunch of frames that we don't want. Many of them clipped, half clipped. And then we're just going to take it from one to 21. And when we do that, one to 21 is effectively that's how many of these there are. So 18 and then one, two, three. So from one to 21, all of those. That will be all the bricks. We can throw away all the rest of the quads and just blindly assume that they're all the same size. So any questions on how quads or how any of these tables are working? OK. So we're going to go ahead. We have a new class now, brick.lua. So simple building blocks. In brick.lua on line 30, we have a flag called in play. self.inplay gets true. And so we're just going to use this to render. We're just going to say, if it's in play, render it. If it's not, don't render it. It's that simple. That way we don't have to worry about object deallocation or anything fancy. We have all of our bricks and whether it's in play or not, render it or perform update logic. And if it's not in play, just pretend it doesn't exist. Just ignore it. We're only going to have like 30 or I don't know how many, 13 max by four bricks in our scene at once, so worrying about freeing memory isn't really an issue. But if you have a million different things getting generated all the time, having simple in play is false might not always be viable because you need to store all that memory for all those objects. So just a shortcut here, but not necessarily best practice for very large games. But certainly great and simple for small games. On line 37, we define a function called brick hit. And all this does is just play a sound effect and set in play to false. And so all we're going to do is just check to see whether there's a collision and then just call this hit function, play a sound, and then just pretend it doesn't exist anymore. And then render, all render does is if it's in play, check the in play flag, draw main at bricks or using our bricks table here that we created. And then we're going to start at one and then we're going to index it based on our color minus one times four, and then we're going to add it's tier. So there are, if you recall, one, two, three, four, five colors and four tiers. And so what we're going to do is we're going to jump between the colors. So we'll go value one, value two, value three, value four, value five. That will be our first five or I guess six. That will be our first six bricks. And then we're going to go one, two, three or we're going to add, we're going to have a tier basically. It'll be one, two, three, or four. And if it's at tier one, then we can just add basically to index into whatever tier we're on, we just need to add tier minus one to whatever our index is. So here if our tier is one, then we just want to render this block. We don't want to go to the next one. So we're just going to say tier minus one. We're going to add so one minus one is zero. So we're going at zero to this, get this. But if tiers two, we'll add one, and two, and three. And then we just multiply whatever brick we want by our color. Multiply it by four to get an offset for whatever our actual color is. So we take our color, figure out where on the sheet it is, and then just add our tier to it in order to index into our spreadsheet accordingly. And so that's what the math here is doing. And if we go back to our PlayState and I'm going to start moving a little bit faster just so we can keep caught up. But in our PlayState, one thing that we notice here, we have a new class called level maker that we're seeing, which was a function called createmap. We're going to take out all the logic for generating our levels and we're just going to put it in one place. We're going to call that level maker. Rather than in our different states that maybe generate the bricks like the PlayState or I guess it would be the ServeState, VictoryState, I guess, rather than generating all the bricks in that state within it's innate code, let's just make a level maker and we can just say, OK, set bricks to levelmaker.createmap, which will return a table of bricks. Same excuse me logic as we saw before. In this case, we're just going to iterate for k brick in pairs of self.bricks. If the brick's in play and it collides, if the ball collides with it, then hit it, which will set it not into play. So simple A, A, B, B. And then lastly, we have our render logic here, which is going to take that bricks table and just iterate over it. And the last thing we should probably look at is the actual level maker itself, which in this case is very simple, but we'll see it gets a little bit more complicated later when we do it. When we have a more elaborate procedural generation approach to our levels. But right now, we're just going to say set two random variables here. Number of rows and columns. And then for every row or for basically every row and every column, create a new brick. And then there's some math here. I'm going to kind of skim over it, but basically it calculates where the brick is and then gives us eight pixels of padding on either side. And then based on how many it is, it needs to center all the bricks and shift them by a certain amount to the left and then start drawing all of them. And that's essentially what this code does here. So calculate the center. I wrote it out in comments here, but I'm going just kind of glaze over it for now. But effectively, center all the bricks. Basically calculate what offset on the Xaxis you need to put all of them so that they appear centered, and then you're going to draw them all out. And then that's it for the level maker class. So simply number of rows and columns, and then fill a table with bricks but set their X equal to however much we need to center all of them when they're all drawn out. So we need to figure, we need to basically take in our number of columns into account when we do that. And then if we go into Breakout3 and run that, we have bricks. They're getting collided with, and as soon as they get hit, collided are in play on each of those bricks gets set to false and they no longer get rendered. And they no longer get updated in terms of collision. Now, we still have the issue with the ball not getting reset. We'll fix that. That's an easy fix. But we're coming a long way. We have things moving at quite a pace. I'm going to go ahead and move to the next bit of code here. So this is another bit of code. I'm going to sort of glaze over a little bit of the details here. But at a high level what we need to do is it's one thing to detect that we've collided with a brick, but in Breakout, the ball bounces off of the brick depending on which side it hits. And we don't know this necessarily just based off of the collision. We just know whether the collision is true or not. We don't know where it came from and how much it collided with. And then we're also going to fix our paddles so that rather than because currently all it does is just negate whatever the Y velocity is, but we want to add a little bit more variety to how we end up sort of ricocheting the ball off the paddle when we play so that we can sort of strategize a little bit, give ourselves a little bit of game play. So if we are moving to the right and we hit the right edge of the puddle with the ball, it should probably go in a sharper direction. Same thing with the left side. And we can effectively do that by taking the middle, figuring out how far away from the center it is, and then just amplifying our delta X in the negative or positive direction based off of that. And that has the effect of causing that to happen. So here we can see we have the ball sort of coming at the paddle, and let's pretend that the paddle is moving to the left. In this case, however far away the ball is from the center, we want to scale that by some amount and then end up making that our negative delta X, because that's effectively how the game normally works. If you move the paddle to the left or the right, hit it on a corner or something, gives it that sharp angle. And that's effectively what the sharp angle is. It's just a strong delta X, and it gets amplified the larger this is. So just basically take this, multiply it by some amount, and then make it negative or positive on your dx. That's your sort of paddle collision V2. Brick collision is a little bit it's pretty simple, but it's a little bit more complicated. Basically what we need to do is just check and see which edge of the ball isn't inside the brick. And so if the left edge of the and we can also sort of simplify this a little bit. If the left as you see here by the pseudocode if the left edge of the ball is outside the brick and the dx is positive, then we can say, oh, we can basically assume we've come in from the left side, so we should probably go in the opposite Y direction on the left side. Or sorry, we should go in the same Y direction, but negate our delta X. Because we're coming in from the left, the left side is outside the brick, so bounce it back. And the same thing for the right edge. And we only do this test, the left edge of the ball, if dx is positive. Because if dx is negative, there's no way the ball's colliding with the left side of our brick. So we can shortcut that effectively. We do the same exact logic here, just on the right edge of the brick instead of the left edge. And then if none of those hold true, we're going to see if the top edge of the ball is above the top edge of the brick. And if that's the case, we know that we've hit from the top. We can trigger a top collision. And if none of those have held true, we know that we have had a collision of some kind, we can just register a bottom collision. And so this is a simple version of this sort of way of doing Breakout collision. It has a few faults when it comes to corners, sometimes corners can be a little bit finicky, but I would say it works 99% of the time. For a much more robust and a better example, I would look at this URL here because he also goes into a full sort of breakdown of how he would implement arkanoid, which is the same thing effectively as Breakout if you just want an alternative look at it. But basically, his solution involved taking how much the X and the Y differed on different points of the bricks relative to the ball. And I believe he also kept the ball as an actual ball with a center point, even though he rendered it as a rectangle. So it's a little bit more robust. I decided to implement it a simpler way, which I'll showcase, which is the way that I demonstrated because it worked well and it wasn't too much code to sort of look over. But I do encourage you to take a look at that. We're going to look at our PlayState now in Breakout4. And in our PlayState, we're going to see sorry. Line 65. So this is the actual paddle code for influencing the ball's delta X. So basically, if the ball.x is less than the paddle.x plus it's width divided by two, so basically on the left side of the paddle, and the paddle's delta X is less than zero, which means it's moving left because we don't really want to necessarily influence it if we're just standing still we're going to do what I described earlier. We're going to give it some scaler, like some start off value. In this case, negative 50 is just sort of seeding this, giving it some sort of initial value. And then we're just going to subtract the ball's X from the middle point. This being the middle point of the paddle And then just multiply it by eight. So whatever the difference is between the ball's X and the middle of the paddle, multiply it by eight. Add it to negative 50 and then negate that. Also negate that whole value so that the whole entire value becomes negative. And we, therefore, get a sharper delta X depending on which angle it's coming at, and also how fast or not how fast, but whether or not we are moving left. And it's the exact same thing on the right side. Only because we're taking this math, this self.paddle.x plus self.paddle.width divided by two minus the ball.x, the ball.x isn't going to be greater than that point. So this value is actually going to be negative. So we're going to just make it positive with math.abs. So absolute value. Just a lua function. So the absolute value of the difference between the ball's X and the middle point times eight, add it to 50, and that'll give us a positive value that scales depending on whether or not we've hit the middle of the, we've hit the right edge of the paddle and are moving to the right. And so that's, in a nutshell, how we get that collision to work with the paddle and how we can tweak delta X to be scaled a little bit more than just a constant, you know, negative or whatever it's current X was, but negative dy. A little bit more complicated. And then the actual collision code for the bricks themselves is going to take place in a for loop here. So if it's in play, if the ball collides with it, hit it. So I added plus two. So the gist of the math is if ball.x is less than brick.x and the ball is moving to the right, self.ball.dx is greater than zero, then flip it's X velocity. So bounce it to the left. That's what this check is. But it plays a little bit rough with corners because you could theoretically get into a position where you come in at an angle and it's intersecting with the paddle in two positions, both on top and the left or on bottom and the left. So in that case, adding two sort of prioritizes the Y being hit. So it basically takes the check from the exposition of the ball to the X plus 2. And so it ends up fixing the corners a little bit, but the gist of it is just check to see if the ball.x is less than the brick.x. And if it is and we've detected a collision, we can bounce it. There are some subtle corner case bugs without adding this plus two, so we add that. And then flip the velocity here. Oh, this shift here. This is what we were talking about earlier with make sure when you do a collision, shift whatever is moving outside the boundaries of whatever you're colliding with. So self.ball.x gets brick.x minus eight because the ball is eight pixels wide. It should actually be self.ball.width for a better style, but that's essentially what it translates out to. Same thing for the right edge. The plus six because it's on the right side. So it's effectively the same thing as minus two if we're on the left side. Just a sort of fixes corners, weird issues with corners. But check in to see if basically the ball plus its height minus two is greater than the brick plus X plus brick.width, which it means, oh, we've collided with the right edge of the screen, of the brick. And then if the Y is less than the brick.y, then we've collided with the top of the brick, and otherwise, we've collided with the bottom. And with the top and the bottom, just do the same thing we did with delta X, but do it with delta Y, but you're still resetting it. So ball.y gets brick.y minus eight. Ball.y gets brick.y plus 16 because the paddle or the individual bricks are 16 pixels tall. That's the gist of the collision detection. And then if we actually oh, and one other thing that I ended up putting here just to make it a little bit more interesting, and this also ties into more complicated collision detection. If your velocity is too fast, a lot of the time it'll skip through objects, and then that causes a lot of problems with these collision detection functions that normally are very sort of mathematically correct and they work well. They don't work well when it skips over what you're trying to actually collide with. So a solution to that, which was beyond the scope of this example but something we're thinking about, is perhaps stepping backwards a certain amount of time, a certain amount of pixels. Perhaps maybe start at where you where your ball was on one particular, on the last frame, and then just add its width and height to itself until it collides with something, until it reaches whatever its current delta X or delta Y plus its position is. That's one way to do it. Sort of just adding a bunch of invisible whatever you're colliding with or whatever you're using to collide add a bunch of invisible those to bridge the gap and check into if any of those hold true for a collision. A little bit more computationally expensive, but a lot more accurate in terms of the physics. And aside from that, everything is the same. So if you look at the code in Breakout4 and I'm going to go a little bit faster henceforth. That's probably the meatiest part of the program. We get collisions. And then I'll try and get a strong angle so I can demo the that didn't work. That actually gave a weaker angle. So if you do this and you do it close to the center, it has the opposite effect. But there you go. That's a sharper angle. So now you can actually influence the ball in a little bit more of a personable way. You know, not just have it be a flat delta Y gets negative or get negative delta Y effectively. So any questions on sort of how the gist of all of that works? OK. Perfect. So now we're going to get into a little bit more of some fun stuff. We'll do a couple more examples, then we'll take a break. So this is the hearts update. So notice that the very top of the screen, as I've demonstrated in these slides, we have just a few hearts. One of them is empty. We showed this earlier. And then we have a game over screen, which is our final score. So I'm going to go ahead and we're just going to look at the code a little bit faster now since a lot of the stuff is fairly straightforward. I'm going to go ahead and open up the I'm going to make sure I'm in the right folder first of all. Breakout5. And then in the so one other thing we're going to start doing is I mentioned this earlier. And it's going to be it's going to hold true for any of the sort of state transformations that take place going forward. Rather than keep global variables, we're going to sort of do away with that idea outside of the asset tables that we have just because those are kind of an exception and they could reasonably be put into a separate class called the resource manager. We're going to start passing in what is basically our current app state, or at least the variables that make sense. And this is a common paradigm in web development with React as well. But basically, everything that we need to be preserve state to state, rather than just keeping global variables, let's pass them between the states because the state machine allows us to do that in the change function. And then whatever that state is in it's enter function, it'll have access to that and it can just set those values to self dot whatever and use them. But we no longer have global variables. We're just saying, here. Here's the values that are important for you to continue on. And then that state will take its values and go to the next state and say, oh, OK, here are the values that you need to function. Like the serve, play, and all those states that have the core game play involved will probably need to maintain a reference to like the paddle, and to the score, the amount of health we have. But when we get to the end, for example, and then we no longer really need a paddle, we no longer really need bricks or anything like that, we just need to know what our high score is so that we can enter it into our high score list, all we really need to do is just pass in the high score state entry or just our high score, and that's it. So it encapsulates all of our data. And at a glance, we can sort of see what we need to pass between the states and what's going to be relevant at a glance as well. It just clean things up quite a bit. So that's what we're doing now on line 35. And henceforth, we will do this in every state as we see, but I'm going to sort of glaze over it in the future. We have a ServeState now. So a ServeState, this is very identical to what we did in Pong. So we just wait for the user to press Space. They can move around and then when they do press Enter, basically the ball starts moving. And then we change the PlayState here using the current values that are necessary. Paddle, bricks, health, score, and ball. Those are basically the fundamental variables that we need in order to keep track of our GameState. So we have a ServeState, it will wait for us to press Enter. And then our main.lua, we have a new hearts table. And then on line 208, because we're going to need the ability to render health and render our score across several states, Play, Serve, Victory, Game Over actually not Game Over, but the three before that. We don't want to duplicate those behaviors, so I'm just calling a function called Render Health, which just takes in whatever health is and then we just set an X to virtual width minus 100. And then for however many health we have, draw a heart from the hearts sprite sheet, which I separated the hearts out into a smaller image so you can just split them on like eight by eight or whatever it is. But just draw those and then add 11 to X, and just keep going until we've drawn out however many hearts we have. That will draw full hearts. And then three minus health will give us however many health we're missing. So if we took a point of damage, this is going to be equal to one. So then it'll draw one empty heart after that or it'll draw two empty hearts. So draw however many full hearts we have, then draw the empty hearts. And those are two separate sprites that we get from the image. And that will have the effect of drawing our health. And then our score is simply, it takes a score variable that we pass into here. And also note that the render health [INAUDIBLE] and health variable and pass into it here. And so in our PlayState, we are calling both of these functions on line 135. Well, on line 135, we are calculating whether we go below the edge of the screen, which is another important part of the game. Obviously, we need to detect when we've lost health. So it's as simple as this. If it's greater than the virtual height, decrement health by one. If it's equal to zero, change to Game Over. Else change to the ServeState. And note that we're passing in all these variables to and from our states. The ones that are important. Game Over just needs score, but Serve needs whatever variables we were already using. And then down here we're calling render score and render health, and then the GameOverState is simply because it takes in score from the parameters list, just wait for keyboard input to go back to the start and then render game over, here's your score. It's self.score, and then that's it. Very simple. Very simple state. AUDIENCE [INAUDIBLE] COLTON OGDEN Sure. AUDIENCE [INAUDIBLE] COLTON OGDEN The question was, do any of these states have access to their parent file? AUDIENCE [INAUDIBLE] COLTON OGDEN Is everything in main.lua global functions? Yes. Functions that you declare. Anything that's basically not specified as local that you define in main.lua will be accessible anywhere in your application, including functions. AUDIENCE [INAUDIBLE] COLTON OGDEN You don't have to the question was, do you have to declare as public? No, there is no notion of public. In lua, anything that does not have a local specifier is assumed global, even if it's in a nested scope. So you could have a for loop, you could have several nested for loops and declare some variable without local, that variable can be accessed anywhere above it or outside of it. So it's pretty important to use local variables when you're not explicitly allocating something as global just to avoid the bug of for nested loops and you have some variable name like hello and you use it somewhere else. Good questions though. So yeah. We have a bunch of states now. We have a GameOverState, a PlayState, we're rendering our score, rendering our health. If we go and take a look at Breakout5 is it a different window? There we go. We can see hearts at the top. Score zero. Oh, and I forgot to mention the part where we actually add score now. So the bricks themselves in their on hit, or I should say in the PlayState, on line 81 when we detect a hit, we're just adding 10 to the score for now. But later on, we'll do a calculation where we take tier and color into consideration and then perform arithmetic on that to get our total score for each ball hit. But yeah, we have our health, we have our score. And then once we take enough damage, we'll end up going to the Game Over screen. The Game Over screen will go back to our Start screen. So making progress. And then probably my favorite of the updates before we take a short break is the pretty colors update. So what this does is clearly we can have we've updated our level maker. So rather than just having a bunch of very static bricks, we end up doing a little bit more complicated procedural generation. It's not complicated though. Just in levelmaker.lua in Breakout6, we have a few different constants here. So solid, alternate, skip, or none. Actually, I don't think I use skip or none. Just solid or alternate basically. We have flags now. So number of columns. And we ensure that it's odd because even columns with generating patterns leads to asymmetry. So make sure the number of columns is odd. Generate the highest tier and the highest color based on our level. So in this case, we'll go no higher of a tier than three because we have no higher tiers than three. It goes zero, one, two, three. And then whatever our level divided by five is, and it would just take math.floor. Math.floor takes in basically performing division and then truncating the decimal point. Well, not division. It just literally truncates the decimal point off of a number. So a level divided by five. Whatever that is before the decimal point. Level modular five plus three for the highest color. So we'll cycle. We'll go over and over again. Go highest color one, two, three, four, five, and then we'll go to a new tier with level divided by 5. So basically, every five levels will increment in tier, and then we'll start back at blue. And then we go on, and on, and on like that for every number of rows. So basically I have a few I'm going to sort of glaze over this a little bit just because we're probably going to run short on time. But we have basically two flags. Whether we're skipping bricks in this row or alternating bricks color wise. And if we do, we need to set a color for it and a tier. And then we basically just say, you know, the same sort of logic that we had before we generated random rows and columns, but if we have the alternate flag on, then as we can see in some of these photos here, here we have skip is true. So the color for that row is set to the blue, but skip is true, so every other brick is just going to skip that iteration of the loop. Same thing here, only it's offset by one. Same thing here. Same thing here. So this is kind of a nice little pattern. And in each of these cases actually not each of these cases. Notice this third one, it also set alternate to true. So it goes green, purple, green, purple, green, purple. And so the logic there is if alternate is true, then just flip the color every iteration. If skip is true, don't generate a brick every other iteration, and so on and so forth. And then if you have solid or if you don't have alternate equals true, then you have a solid brick like these blue ones. And if you have alternate but no skip, you get this sort of pattern where you have green, purple, green, purple. You know, any random color. And then also the number of columns is random. So it can go here we have 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 but on this very bottom one, we have that minus two it looks like because it can only go that wide. And in those here too. Smaller size. That one there's no spacing. So these are very simple concepts. Like should we skip a block this iteration? Should we alternate the colors? And when you put them all together, it produces things that look as if they were almost handcrafted. Like this could be made by somebody. Like, that looks like it was made by somebody. Pretty much every iteration of this. I mean, even that, that looks like a shape almost. Its just very simple but the results are pretty awesome in my opinion. And so that's just the gist behind what we're doing. We're just setting flags and just saying, you know, if we're skipping this turn and just every iteration, every time we lay out a brick and we spawn a new brick on this row, just do or don't. Just make it's color pick two colors if we're alternating and then set its color to whatever the off color is that we're alternating. And if we're skipping and alternating, then we're just doing whenever we're on a brick that we're actually laying is when we change the color, the alternate color. And so like I said, I won't go into too much detail. Happy to talk about the generator after class. But just because we're running short on time, sort of going to wave my hands over it. But that's it in a nutshell. So any questions before we take a break for five minutes? Yes? AUDIENCE [INAUDIBLE] COLTON OGDEN The question is, in an instance with this programming if the ball were so fast that it we're actually inside the brick, would it what? AUDIENCE Would it still bounce back? COLTON OGDEN Would it still bounce back? The answer is no, it wouldn't. This implementation doesn't take into consideration velocity that goes too fast. Mainly to for two reasons. One, it's nontrivial to implement, and two, it's an interesting thing to look at, and observe, and be conscious of as you go forward in implementing your own games. The current code, if it gets clipped inside of the brick, it will have no edges that are peaking outside of the brick and therefore, it will default to the final condition, which is the last else clause, which puts it below the brick. So it'll just go below the brick. It'll almost be as if it came in from the underside and bounced out. But like I alluded to earlier, if you want to implement something like this yourself, you would have to slice up frame X and frame X plus one into the size of the ball if the delta is so wide that it either goes inside of a brick or it goes outside of a brick, or if it skips a brick. And this sort of solves that problem. It solves both of those problems, but it's a little more than we can cover in this example. Any other questions? All right. Let's take five and get back to it. All right. And we're back. So the next step is we have basically a layout dynamically generated of interesting bricks now, but we haven't really implemented scoring any of these. We just have score gets score plus 10, which isn't really particularly interesting. So Breakout7 is what I call the tier update, which should allow us to hit blocks that are a higher tier than just base blue. And if they are of a higher color than base blue, they should go down a color. So the hierarchy was, if we look back, blue goes to green goes to red goes to purple goes to gold. And if something is a higher tier, it goes to the next color below it but at that same tier, unless it happens to be like blue and gray, in which case it'll go back to blue. So how might we implement scoring based on this system? What do we need? What pieces do we need? What pieces do we already have that we can use to make this happen? AUDIENCE [INAUDIBLE] COLTON OGDEN I'm sorry? AUDIENCE [INAUDIBLE] COLTON OGDEN So the answer was the brick index. So yes, the brick skin and color are the pieces. Yes. So those are fields of brick. So if we open up I'm going to go up to Breakout7. And I'm going to start probably deferring a lot of this code to future reading. But in brick here, the tier and the color sorry, not skin, but skin is for the paddle. But the brick has a tier and it has a color. And so we need to perform some arithmetic on that here. And that's essentially what lines 44 through 58 is. So basically oh, I apologize. That's not actually where the arithmetic is. 44, that does compute, but this is the bit of code that computes how we can actually go backwards if we make a collision. So if we collide with a brick and it's of a higher tier than one and it's a higher color than blue, it should be brought back one step. But if it happens to be blue, in which case self.color gets one because blue is one, then it should just be removed from play just like we've done before. Only now, we're also taking in tier and color. So we're decrementing tier based on what index we're at and we're decrementing color. And then this actually gets used in our PlayState. If we go to line 81, which previously just had self.score gets self.score plus one, there's a little bit of math here. It's very simple though. Just brick.tier times 200. So make the tiers worth 100. Plus brick.color times 25. And so if tier is zero, if it's a base then we're just not going to get that 200 bonus. But the first tier, everything is going to be worth 25 times whatever its color is. So one, two, three, four, five. And then add 200 plus the brick.color for when we get to the next set of bricks. And so the result of this is I believe this is GUI Breakout7. And then if we hit a brick since this one is blue, it should disappear. And we're playing a new sound as well. New, like, death sound just to make it clear. But notice they change colors. So that's all we're doing. We're just taking their tier or their color and just performing a simple decrement on it. Looping back. In the event that we go down a tier, we should loop back up to the highest color of the lower tier. So I'll let you look at the code for that if you want to sort of get a more low level understanding of it, but that's the sort of high level understanding. The next big concept that I'd like to introduce you guys to is a particle system. And so particle systems are fairly omnipresent in video games, I would say, because they make effects that or otherwise difficult to do with simple sprite editing achievable very easily and realistically. Just like fire, for example. Things that are very organic, and flowy, and have a lot going on are often better represented with particle systems than they are with simple sprite animation. So does anybody know how we might be able to how a particle system might work underneath the hood? I think I alluded to it previously. Yes. AUDIENCE [INAUDIBLE] COLTON OGDEN Yeah. So what he said was in order to make fire, for example, just spawn a bunch of particles close to the center of wherever your fire is spawning and then outside of it spawn fewer. That is absolutely a way to get fire to work, and also taking into consideration the travel of your particles. For example, you might spawn a ton of fire particles really densely, but then maybe they have some logic that makes them go upwards. Maybe they have a negative delta Y and then some sort of acceleration so they've sort of trail off. And then maybe sort of how to get a more realistic fire look, they travel sort of upwards and then fade away. So the way fire works, sort of thinking of things in terms of particles like that, you can achieve a lot of effects. How might we implement, like, smoke, for example? Same system. So we could have maybe a timer in our particle effect, or even a transition because in particle systems, often you have the ability to transition colors between particles. Let's say you start off red, go to yellow, and then maybe your particle system transitions to gray or brown. And then over time, your particles are going up, they're dissipating. And they're also turning dark, they're turning brown, it sort of gives you the illusion of fire. And we won't be doing anything necessarily as complex as this in our code here, but in Breakout8, we will be using Love's sort of integrated particle system which is just love.graphics.newparticlesystem. And it takes in a texture because all particle systems need some sort of texture as their foundation. And then it needs the number of particles that it could maximally emit. And so each individual particle system can emit up to a certain instance of particles. And in the number, and speed, and whatnot of all those particles is ultimately the determining factor for how you can get an illusion. Back to last week's lecture, illusions, like, it's not fire, it's not smoke, it's just a bunch of particles responding with colors and acceleration and stuff. But there's a lot of functions that particle system gives you in Love2D, so I encourage you to look at that link just to explore some of them. Love2d.org/wiki/particlesystem. We'll be using a few of them. Here I'm going to just briefly show you. So each individual brick when it gets hit is going to need a particle system of its own. Because our goal is I'll run the code for you so you can see it. So if you go to Breakout8 and then you run it, we have a little bit of particles you saw there at the very end. The blue you were probably able to see a little bit better. And then one last time. So it spawns a bunch of little particles. So can anyone tell me how they think the particles are behaving sort of in a nutshell? What the logic is for the particles? AUDIENCE [INAUDIBLE] slightly random. COLTON OGDEN Yeah. Slightly random. And if you look at it, you'll also notice that they tend to go downwards. So knowing that, we can probably just assume that they have an acceleration that tends towards positive Y. And that's essentially all we really need to do. We spawn a bunch of particles outwards and then just set them they have all a lifetime. They last for a certain amount of time. And then they fade between two colors. In this case, we fade from red to transparent or whatever color it is. And then after the lifetimes elapsed, it has the overall effect of sort of this glimmering, gravity based effect, but it's really just a bunch of particles that are set to spawn in different directions. Apologize for that. So we'll take a look. It's going to be in our brick class here in Breakout8. So we're going to go to brick. We have a bunch of colors that we're storing here. So if you notice, the particle systems adopt the color of whatever brick they're hitting just so that it stays sort of congruent with what we're looking at. So we're just storing a bunch of colors here. And I wouldn't worry too much about this. These are just colors from the sprite palette that we used with our sprite art. There's specific colors that are only used in that sprite. And having a palette, generally speaking, allows your art to look a little bit more cohesive when you're doing sprite art as opposed to just picking colors willy nilly. If you say, oh, I'm going to only use 16 or 32 colors for this palette, you'll sort of have a more cohesive look and also a very retro look because often hardware was limited to a certain amount of colors back in the day for older systems. So it's nice to as an aside and we'll look at it next week as well. Looking at when you're doing your own sprite art, try to use fewer colors and then that will give you it also makes it easier for you. You don't have to spend time choosing I want to have this shade of green. I wonder if it looks good. If you only have two shades of green or semi shades of green to choose from, that's all you've got. You have to make do with it what you can. So what we're doing here is we're storing five colors from our palette. We're going to use this. And then when we trigger our so right here we're initializing a particle system. So psystem gets love.graphics.newparticlesystem. And then these are a few functions. So feel free to look in the wiki for how these functions actually behave. But lifetime acceleration and area spread just are sort of the properties that influence the way our particle systems behave. And so using whatever our current color is, we're going to set our psystem's colors using setcolors function. We're going to set it between two colors. Color with 55 times tier alpha and color with zero alpha. So the higher the tier, the brighter the particles, but they'll always fade to zero alpha, if that makes sense. And then we'll just emit 64. And this is all in the hit function. So all we've basically done is just add this particle system trigger in our hit function, and it has the result of the behavior that we saw earlier. So any questions on particle systems or how we use them? So level 9 is the progression update. So the purpose of this update is to allow us to go from level one to two to three to four and start get more interesting level generation that way. The gist of this is in our so if you look at our StartState so all we need to really do to store a level is just to store a number. And then where do we increment the number? Or when do we increment the number I should say? AUDIENCE [INAUDIBLE] COLTON OGDEN Exactly. So we increment the level. We go to the next level when all of the bricks are in play have gotten there in play flag set to false. So we have no pricks that are in play effectively. So in our StartState so let's go ahead and look at Breakout9. So StartState. We're passing in level gets one here. We're just going to start off. When we're going to StartState, we're just going to pass level equals one. And then henceforth, anytime we do any state changes from play to serve and to victory, as we'll see, victory being our new, oh, you cleared this level. Here's the next level. We're just going to pass the level between them. And then in PlayState, the important bit of code here is on line 204. So this is just a function called checkVictory, which is exactly as James said. We're going to iterate over the entire table and just say if it's in play, return false because we're not in victory if we have any bricks that are in play. But return true if we didn't meet that condition. And so this is just a simple way for us to check whether or not we are in a victory. And so on line 88 of the same file in our PlayState, we're just checking to say, hey, if self.checkVictory after we do any brick hit because that's when we've just set a brick to in play is false just check victory. And if so, play a new sound like a happy sound that we've done a victory, and then just pass everything into the new VictoryState that we have here. And the VictoryState is simply a sort of just a message state. So all it does is just renders everything as before, but it just says your current level complete. Self.level complete. And then press Enter to serve and it'll go back to the ServeState as soon as that happens. And then here is where the actual progression happens. When we go to the ServeState, we have our level but we want to add one to it. So all we need to do when we trigger a transition into our next state, just increment level by one here, and also create a new map because bricks needs to get restarted because we have a new level. Self.level plus one. And that'll have the effect of, oh, we've gone from level one to two to three to four et cetera when we go between PlayState to the VictoryState back to the ServeState. So any questions on how any of this works? Yes. AUDIENCE Do you have to worry about garbage collection for any of the bricks at all? Or is that handled by the Love engine somehow? COLTON OGDEN Garbage collection is handled by Love. Yes. Yeah. AUDIENCE [INAUDIBLE] COLTON OGDEN Yes. Because the question was, do you have to worry about garbage collection when we are sort of clearing away the bricks and adding new bricks? The self.bricks table, this table here, it's getting assigned to a brand new table from levelmap.createmap. When there are no references to an existing table, lua's garbage collector will trigger at whatever interval it's set to trigger and clear up all that for you dynamically. Just like the same way that Java works. Almost identical. Any other questions? All right. So we have progression. In the sake of speed, I won't demo. It also takes a while just because we have to clear an entire level then get to the next level. But that's how the behavior works. The next sort of iteration of this is high scores. And I will test to make sure whether or not this is actually working. I know I changed some stuff. Yeah. So high score. Let's debug for a second. So HighScoreState line 38 in Breakout10. So HighScoreState. And then the issue was [INAUDIBLE] to index field high scores. A nil value. OK. So that means that OK. I think I might know the issue, but it's because I transitioned to a new user that doesn't have a saved file active on this. The way that will transition, therefore, into love.file system, which is Breakout10's main new thing that it introduces so writing files to your file system is done [INAUDIBLE] with love.filesystem. And there's a few things. So Love automatically gives you a directory, a save directory that's pretty much hard coded. There are a few exceptions as to how to not use that directory, but it assumes that you're always using that directory. And with very few exceptions will you always use that folder. It's like app data local on Windows, and application support, and the name of your application on Mac. But it's a subfolder that Love has read and write access to for files on your file system. You can check whether it exists with love.filesystem.exists at some path. You can write to that path with some data, that data being a string value. And then love.filesystem.lines is an iterator, which will allow you to look over any of the data that's in a file at a given location. Yes. AUDIENCE [INAUDIBLE] COLTON OGDEN Yeah. AUDIENCE Does this work if you [INAUDIBLE] COLTON OGDEN It should. We can pull that up now actually and see. Because I know on their Love2D so file system. So the question was he ported his when you port your Love app to the iPhone, will it have the same sort of behavior if you're on an iPhone, will it have the same sort of save directory behavior? And it looks like it's not officially on here. I know that there is an iOS port for Love2D, or the ability to send it to Love2D. AUDIENCE [INAUDIBLE] COLTON OGDEN I have to imagine yes. It probably has some sort of I'm not entirely familiar with how iOS handles sort of local storage, but I'm assuming that just in the way that it's been abstracted for desktops and for Android, it's also abstracted for iOS. Haven't tested it myself. I would experiment and see actually maybe with this code. See if you can maybe get it working with persistent high scores. I know that iOS does typically let you store a small amount of data per app in some location, a fixed location, but I'm not entirely sure what that is offhand. I can look into it more and come up with a AUDIENCE [INAUDIBLE] COLTON OGDEN Yeah. I mean, not from firsthand because I don't have an Android, but it has official Android support. So I'm guessing it does, but I haven't tested it. I have not tested it manually on Android to verify that. But yes. I believe because in the prior directory we were looking at when it showed oh, it's actually up here. This path here. This data/user/0/love2d.android. file save. That looks to me like it's the official sort of path that data is stored on an Android device for application. So I haven't tested it myself. But if you have an Android and you're curious or maybe an emulator, give it a shot and see if it works. Oh, and it even says here, there are various save locations. And if they don't work, you can see what the actual location is with this function here. The love.filesystem.get save directory. That may work on iOS as well, so I'd be curious to hear about whether that actually works on that. Yeah. So that's the gist. Using the love.filesystem abstraction lets us read and write files. We can then just paste or we can just save whatever data we want anywhere within that directory. We can just create files in there and then use those to store our, you know, sort of game worlds, or character profiles, or whatnot. How would we maybe go about implementing sort of like a high score list? So I'll look. There's a picture here. So we have 10 scores. We'll assume that's fixed. Each of the scores has a name, and then each of the scores has an actual score. So all we really need to do is just store ultimately the names and then the scores. AUDIENCE [INAUDIBLE] COLTON OGDEN So we'll use an array. Their response was we'll use an array as sorted by that score. Yeah. Essentially that's exactly it. We're just going to keep a score table and each table is going to have a sub table. And each of those entries, one through ten, is going to have a name and a score. And then once we're done with our application, we'll just use love.filesystem.write. We'll have to convert all of those into a string because we can't just take a table and then spit that out into a file. We have to actually make it into some form that we can save and then reload back in somehow. What would be the most efficient way, do you think, or a way we can do this? Probably just a new line separated list. The way that I've done it in this application is just names, and then new line, score, new line, name, new line, score. 10, so 20 rows. And that gets the job done. Assuming that you don't tamper with the file, then everything should work. And you can write additional code as well to say, oh, if there is a score that's all garbled, we don't have enough scores, then probably should render it accordingly. My code does something similar to this, but not entirely. The relevant code and I'm going to sort of just glaze over it. If we're looking at this is Breakout11, right? Yeah. Oh, no, this is Breakout10. So in Breakout10, we have to load all the high scores in main.lua, which is here. So set identity to Breakout or create a folder called Breakout that we can save and read files to and from. If it doesn't exist, then just create them. In this case, I'm just seeding CTO my initials. And then I times 1,000. So 10,000 down to 1,000. Just very simple data. Writing into a file called breakout.lst. It can be whatever you want. All we're doing is reading lines from the data, or from the file. And then this is if it doesn't exist. And then if it does exist, then we're going to iterate over it with love.filesystem.line, which will take a file and then just split it on new lines basically and give you an iterator over all those lines. So it can just say, OK, if it's a name, which means that if it's one or three or five or seven in the list, then set the name to and we're using string.sub just in case they write some long name or some long name gets they can't do it through our game, but if it gets written to the file as some long name, it should get truncated to three characters so we can display it appropriately. And then otherwise if we're not on a name line, if we're on, like, an odd line or even line, we should consider that a score and just use to number. Because we're using string data and if we try to assign, do any sort of comparisons numerically on the string data, which we will have to do to compare high scores, it's not going to work because it's going to see that there's strings. So we use to number here. Just a simple Lua function. And then that's it. And then we just return scores. And then I'll sort out what's causing the issue, and then push that to the repo ASAP. But that has the effect of us being able to actually load all of our high scores and display them at the start of the game. It doesn't take care of being able to actually input our score. And so we can do this with Breakout11, which you can see if you run the repo. And you can test just to assign your initial score to some value like 10,000 or 20,000, and then just lose on purpose and you get a sense of how it actually works. But essentially, it's just arcade style. You know, you had only three characters you could input your name. So does anybody have any idea as to how we are sort of storing this, or can pitch an idea? So we have three characters and we want to ideally if we're, let's say I want to go to C on the first one. Let's say I pressed up twice so I get to C. How is it going from A to C? You could just say, you could just render I want to render the character A, the character A, the character A, but how is it going to know when you want to go to B, or C, or D. AUDIENCE [INAUDIBLE] COLTON OGDEN The pitch was, you could create a table with all of the characters and iterate through it. You absolutely could do that. It's a little bit bulky. That might be what actually, that's probably not how arcade systems did it back in the day. Because the way that we're going to do it here in Breakout11 is I added a new state called EnterHighScoreState. And if you recall, CS50 teaches this. But all sort of characters at the end of the day are just numbers. ASCI. In this case, 65, if you recall, is capital A. So all we need to do is just draw out whatever that character cast to a string is, or character. And we do that simply down here in the draw function. If we do string.char, at char is three. All that has the effect of doing is just taking that number and then converting it to a character. So all we need to do then is what? When we want to go from A to B, B to C, C to D. AUDIENCE [INAUDIBLE] COLTON OGDEN Exactly. But then what happens if we're at A and we want to go down? AUDIENCE [INAUDIBLE] COLTON OGDEN We would. So if we're at A, then if we press downward and we want to go to Z, the logic is in here. But one we've incremented our code, if it's greater than 90, which is Z, then we should set it back to 65. We'll loop back to A. And same thing here. If we press down and we're at A, we've got to go back up to Z, so we just set it to 90. So simple loop back logic. And we just draw it, we highlight. And then once we've done that, the user presses Enter. We transition to the HighScoreState, actually, because this state should only trigger if they entered a new high score. Which means that we need to check in the VictoryState, or not the VictoryState, but rather in the GameOverState whether or not their score is higher than any of the stores in some sort of, quote unquote, global scores table. And then how do we think we're passing the scores back and forth now? Does anybody recall how we're keeping track of app state? AUDIENCE [INAUDIBLE] COLTON OGDEN Yep. In the change function. So all we need to do is keep track of load our high scores at the beginning of the game, pass them all the way down the line. And then finally and we can also load them in our EnterHighScoreState, but we need to keep track of what our high scores are in the GameOverState so that we know, oh, I've got a high score. Let's instead of transitioning back to the StartState, let's transition to the EnterHighScoreState so the user can add their high score to the list. And then once they've entered their high score, which is here, we'll just write it to this file again. Compile a score string, which takes name and score of our scores. We take whatever score that we were at that's we look through our scores table backwards and when we find a score that's lower than ours, we just keep track of that index until we get to one that's higher than ours. In which case the one plus one, that index plus one is what we should then overwrite. And so we shift all the other ones below accordingly. And we do that in this class if curious. And so I'm just going to breeze through the last couple. The paddle select update is just kind of a fluffy state that lets us add a element of sort of, like, user selection to our game. In our PaddleSelectState here, we transition immediately. Instead of going to the [INAUDIBLE] PlayState now, we're going to go from Start to Paddle Select when we hit Start Game. So we're going to go to and then the Paddle Select class itself. CurrentPaddle gets one, and then all it essentially is is us drawing two arrows here. And so if we're at number one in this case, I think we're at number three then both of these arrows will be completely opaque. But if we're on the left or the right edge, they should darken to say to us, oh, we can't move left or right anymore because we're at either index one or four or five, and there's only that many colors. And then render whatever that color variable is using the quads table that we had before of the different tables. And then just instructions. And then from there is where we'll end up transitioning to the ServeState rather than going to the ServeState from the StartState. And all the code in that is here. We have sound effects playing. And then making sure that we also play a different sound effect based upon whether they're at the left or the right edge. If they're on the left edge and they try to go left, it should play like a sound that sort of sounds a little rougher to let them know that they can't go left, and the opposite for the right edge. And then once that's all done, once they press Enter on whatever paddle they want, they're going to get the paddle, we're going to instantiate a paddle, pass that into the ServeState, and we're going to take currentPaddle from the state, which is whatever value they got by scrolling between all the different paddles. And then the last update, which is my favorite part of most every lecture I think is the music update. And all that really is is just music set play in main.lua, and then set looping to true, and then we have a game. And this is our Paddle Select. So notice the arrows are semiopaque on the left and the right. It's kind of hard to hear, but when I press right now it's kind of like there's a bit of a rougher sound. We choose red. We go to level one and we transition to the ServeState from the PaddleSelectState, and then we just play the game as normal. And that's basically all there is to it. And there is a couple of features we didn't have time to really go over like making sure we recover HP if a certain amount of points have been elapsed, but I encourage you to look into that when you trigger a hit. There's some logic in the PlayState to say, oh, if they've gone over a current recovery threshold, let's add one heart to the player, you know, just keep them playing. Just to reward them for their high score. Next time we'll cover a few concepts. So basic shaders. Shaders are like little programs you can run in your graphics card and do fancy effects, but we won't go into too much detail. Anonymous functions. We've seen a lot of anonymous functions in Lua in the context of Love. They're just functions without a name, and you can just use them as function arguments and do all sorts of cool stuff with them. We'll use them for callbacks next week when we do things like tweening, which is taking some value and making it interpolate over time to some other thing. Because right now we've basically just been updating things based on velocity, but we haven't really done anything based on time. So we'll take a look at that in more detail next week with a library called timer, which is really fantastic. Lets you time things and then chain things together. We'll be covering the game Match Three if familiar. It's basically Candy Crush. We'll be using a different tile set, but it's the same idea. And we'll have to calculate how to actually find out whether we've gotten a match in the grid, our tile grid, and then shift the blocks accordingly and do all the other logic, add score. And then basically since it's so fundamental to Candy Crush and games of its nature, we will have to cover how to sort of generate these maps procedurally to have tiles that are laid out in a dynamic way, and also in a way that doesn't start off with any matches because then that wouldn't make any sense because the matches have to resolve. And then we'll take a little time if we have the time next week to talk about sprite art again and palettes. And maybe I'll show you guys how to sort of convert images from one palette to another in, like, a program that I use, Aseprite, but you can do this in any sort of large photo editing software. And then assignment two is a couple of extensions to Breakout. So if you noticed in the sheet there were a few little sprites here at the bottom so get rid of the quad outlines. So these little things down here are, I'm assuming, they're meant to be power ups. They look like power ups. But the goal of the pset is to implement a power up. And a power up is going to be such that when you grab it, you'll get two additional balls, or however many you want actually, that will spawn in addition to your one and detect collisions on their own. So you'll have several and they'll score points for you. And, of course, only when the last ball comes below the surface of the screen should you trigger a Game Over. And then I want you to add and this will also be more detailed than the spec but I would like you to add growing and shrinking to the paddle. So currently, we have like four different sizes of paddle, but we're not using them. So it would be nice if when we gain enough points or we lose points, or not points, but lives rather, we increase or decrease the size of the paddle accordingly just to introduce another level of challenge and or lack of challenge. And then finally, one last part which is in the sprite sheet as well, there's a key block here and a key power up here. So sort of let the power up come, pick the power up with your paddle. And then only when you have that power up should you be able to break the block with a key. And you should take this into consideration when generating your levels as well. So you'll have to also get your hands dirty with the level maker. But all in all, that was Breakout. So I'll see you guys next time. Thank you.
