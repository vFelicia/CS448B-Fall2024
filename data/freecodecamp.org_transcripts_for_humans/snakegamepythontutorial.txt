With timestamps:

00:00 - [Music]
00:07 - so let's just go ahead and get a look at
00:08 - what this final product is going to look
00:10 - like um so on like an x by x grid so
00:13 - whatever you want it to be you have a
00:16 - little snake moving around there's a
00:18 - snack is what i want to call it that
00:19 - shows up and as you collect it it
00:22 - increases the length of the tail and
00:23 - then obviously if you run into yourself
00:25 - and i just did that by clicking the back
00:27 - key while i was going forward it gives
00:28 - you a little error message here says you
00:30 - ran into your tail um your length was
00:32 - nine dot dot dot whatever um and then
00:35 - you can continue and
00:37 - play as long as you want um anyways what
00:39 - i'm going to be doing in here is i'm
00:40 - going to be coding everything object
00:42 - orientated i know that there's a much
00:44 - faster and easier way to do this but it
00:46 - doesn't really teach you that much
00:48 - this way you're going to learn a bit
00:49 - about objects about classes
00:52 - how we can kind of work with them
00:54 - and you'll see like how the flow of my
00:55 - program goes and you should learn quite
00:57 - a bit especially if you're somewhat a
00:58 - beginner programmer
01:00 - what we're going to be using to make
01:02 - this is module called pygame if you
01:04 - don't know about pi game and you want to
01:05 - learn about it before you do this i
01:07 - would recommend that all right so let's
01:09 - start coding so pretty much what i've
01:11 - done is i've just set up the flow of the
01:13 - program all the classes and the function
01:15 - just to remind myself what i need to
01:17 - write
01:18 - and while i'm talking here it's probably
01:19 - a good idea if you guys copy this down
01:21 - so what we're gonna have is we're gonna
01:23 - have two main objects we're gonna have a
01:24 - cube object and a snake object and our
01:26 - snake object is going to contain cube
01:28 - objects if that makes sense so each one
01:31 - of those little red
01:32 - i don't know squares that was moving
01:33 - around is a cube object and the whole
01:35 - thing is our snake object we're going to
01:37 - have a few functions here draw grid
01:39 - redraw window random snack message box
01:42 - and main
01:43 - so let's get started with
01:45 - our main function here and this is
01:47 - what's going to be our main loop so
01:49 - essentially what i need for the main
01:50 - loop to start is we need to make a
01:52 - surface so in high game to do this we do
01:54 - win equals pi game
01:56 - dot
01:57 - display dot set underscore mode and then
02:00 - i'm going to set it um
02:02 - let's see here what do i want the height
02:04 - to be let's say width
02:07 - and height like this
02:09 - oops bad spelling and i'm just going to
02:11 - make a variable here called width equals
02:14 - height equals and we'll just set this to
02:17 - 500 by what i have 500 like so
02:21 - now we need another variable i'm going
02:22 - to set this as rows uh i can delete this
02:25 - down here it's going to do something but
02:26 - i'll do that later um and this is how
02:28 - many rows you're going to have or rows
02:30 - or columns whatever you can set this to
02:32 - whatever you want just make sure it
02:33 - divides 500 evenly otherwise you're
02:35 - going to have like weird looking rows if
02:38 - you know what i mean so i'm just going
02:38 - to set mine to 20 that's what i'm using
02:40 - in the other one but if you want to make
02:41 - it harder set it to something like 10
02:43 - and there won't be as much room for the
02:44 - snake to move around and the games will
02:46 - go faster pretty well
02:48 - okay next what we need to do is we need
02:50 - to set up a snake object so i know that
02:52 - uh we haven't even created like anything
02:54 - in the snake class yet but i'm just
02:56 - gonna do s equals snake
02:58 - and i'm just gonna give it a position so
03:01 - in this case
03:02 - we want to or a color sorry
03:05 - which is going to be red because red
03:07 - green blue 255 for red and then i'm
03:08 - going to give it a position we're going
03:09 - to start in the middle so i'm going to
03:10 - start at 10 10. um now let's move into
03:14 - our main loop so i'm just going to say
03:16 - wow flag create my variable up here flag
03:20 - equals true
03:22 - and then we're just going to start by
03:24 - doing a pi game tick so pi game dot time
03:27 - dot delay
03:29 - 50 like so and that's just going to
03:31 - delay us uh i want to say like 0.5 or 50
03:35 - milliseconds
03:37 - every time so that our program doesn't
03:38 - run too fast i'm also just going to
03:42 - create this clock.tick i'm going to put
03:44 - that at 10 and what i'm going to do is
03:46 - i'm going to create a clock object up
03:48 - here um and this is a built-in thing in
03:50 - pie game and what this is going to do is
03:52 - explain in just one second once i finish
03:54 - typing it pie game dot
03:55 - clock i believe it is oops dot time dot
03:59 - clock
04:00 - like so
04:01 - so what this clock dot tick is actually
04:04 - going to do is it's going to make sure
04:05 - that our game doesn't run at more than
04:07 - 10 frames per second um so that would
04:09 - mean essentially that our snake would be
04:12 - able to move like 10 blocks in one
04:14 - second and again we don't want it to be
04:16 - that fast so that's why we're also
04:18 - delaying um by like a few milliseconds
04:20 - here if you put this too low um then
04:23 - again it's going to move too low you can
04:24 - play around with the speed this is kind
04:26 - of what i found was the best speed um
04:28 - and it may vary depending on what
04:30 - machine you're on it shouldn't it might
04:31 - so you might want to just change these
04:33 - numbers um again the lower this goes is
04:36 - the faster it's going to be and the
04:37 - lower this one goes is the slower it's
04:40 - going to be so they're kind of inversely
04:41 - proportional like that
04:43 - all right
04:44 - um next
04:46 - what are we going to do here i'm just
04:47 - going to call
04:49 - redraw
04:51 - window
04:53 - and i butcher that so bad oops
04:56 - redraw window like so i'm just going to
04:58 - give it a surface which is in this case
04:59 - going to be win
05:00 - that we've created up here
05:02 - and for now that's all i'm going to put
05:04 - in my main loop here and we'll move more
05:07 - into that once i start coding some other
05:09 - stuff okay so now that we have our
05:10 - redraw window being called here
05:12 - i'm going to go and i'm going to start
05:14 - coding our redraw window
05:16 - so what this is essentially going to do
05:17 - is we first need to update the display
05:19 - so pygame.display
05:22 - dot
05:23 - update like so
05:25 - and we also need to um draw the grid
05:28 - so we're simply going to draw a grid
05:30 - we're going to pass it that same surface
05:32 - that we were given um and move on from
05:35 - that we're also going to fill the screen
05:36 - so
05:37 - when dot
05:39 - fill
05:39 - in this case i'm just going to use black
05:41 - so it's zero zero zero um and there we
05:44 - are that's all we need to do right now
05:45 - but essentially we're also gonna need to
05:47 - draw the snake uh we're gonna need to
05:49 - draw a few other things on the screen uh
05:51 - that we'll get to later okay so draw
05:53 - grid let's move into this one now uh
05:55 - what we need to do here is a set like
05:56 - draw a grid which is pretty easy to do
06:00 - um so what we do is we we're given rows
06:03 - and surface so it's probably a good idea
06:05 - if i actually passed in the rows and
06:07 - surface so i'm just going to global them
06:09 - here so that
06:10 - i can reference them i think this is
06:11 - going to work we'll do global
06:13 - rows
06:14 - and width like that
06:17 - and here we also need to make these
06:19 - global just because i don't want to pass
06:21 - them in every time i draw a grid we're
06:22 - just going to say width uh oops
06:25 - androids and this height variable is
06:28 - actually not necessary because
06:30 - we are just going to draw a square um
06:33 - like a square surface every time so we
06:36 - can just make this the same we don't
06:37 - need two variables for width and height
06:38 - to it are going to contain the same
06:39 - number anyway so global width and rows
06:42 - i go here draw a grid
06:44 - given with rows and surface so now we're
06:46 - going to put in
06:48 - well first we're going to put our rows
06:50 - or oops
06:51 - width
06:53 - row
06:54 - and surface like that
06:56 - okay so that should be working now
06:58 - in here what we first need to do
07:00 - when we're drawing a grid
07:02 - is we want to figure out um
07:05 - how big each square in the grid is going
07:07 - to be because what we're going to do is
07:09 - we're going to just draw lines going
07:11 - down and across but we need to figure
07:13 - out where to draw those lines so we have
07:14 - to figure out kind of like the gap
07:16 - between each of the lines so the way we
07:18 - do that i'm just going to create a
07:20 - variable here size between is equal to
07:22 - our width integer divided by our rows
07:25 - this is just so that we don't get like
07:27 - large decimal numbers because that we
07:29 - cannot pass into our uh drawline method
07:33 - in uh in python okay so now i'm just
07:35 - going to create x variable
07:37 - and a y variable
07:38 - and i'm going to set these to zero and
07:40 - say 4l
07:42 - in
07:43 - range and this is just standing for line
07:45 - pretty well and rows like that now what
07:48 - i'm going to do is i'm going to
07:49 - increment my x by the size
07:52 - between and i'm going to increment my y
07:54 - by the same so
07:56 - y equals y
07:58 - plus oops
08:00 - size between i can get rid of one of the
08:02 - spaces here
08:04 - oh what okay there we are
08:06 - and now we're simply just going to draw
08:08 - two lines so to draw a line in pie game
08:10 - all we have to do is
08:11 - pygame
08:12 - dot draw dot line
08:15 - and the arguments that takes is a
08:16 - surface
08:17 - we need a color in this case it's gonna
08:19 - be white
08:20 - so we do 255 255 255 for white
08:24 - we're going to draw at x 0 comma
08:27 - x w and i'll go through this in just one
08:29 - second
08:30 - what this does and i'm just going to
08:32 - copy this and draw one more and then
08:33 - explain
08:34 - how this is going to work pretty well
08:37 - okay so now we need
08:39 - 0
08:40 - y
08:41 - and
08:43 - w
08:44 - y like so okay
08:45 - so what this is going to do is this is
08:47 - going to draw two lines for us every
08:48 - loop of this for loop
08:51 - and these arguments here is the start
08:52 - position of the line and the end
08:53 - position of the line so the first line
08:55 - that we want to draw is going horizontal
08:57 - which means we don't want to change the
08:58 - y value at all um so what we need to do
09:02 - is we need to find the x
09:04 - and then we're going to put y at 0
09:06 - because we're going to be at the top
09:08 - i think that's right at least oh sorry
09:10 - this this line is dropped being drawn
09:11 - down not being drawn to the right i was
09:13 - getting confused there okay so we're
09:14 - going to change the x but we're going to
09:16 - keep the y at zero and then we're going
09:19 - to stay at that same x and we're going
09:20 - to keep the y at the width of the screen
09:23 - so that we're going uh far enough down
09:25 - and then same thing here this one is
09:26 - going horizontal excuse me i messed that
09:28 - up before so our x is always going to
09:30 - stay at zero and our y is going to be
09:32 - what's changing as we draw horizontal
09:34 - lines across the screen i hope that
09:36 - makes sense to everyone how that works
09:38 - anyways i'm going to move on from that
09:39 - and that's all we need for the draw grid
09:42 - uh function so let's just go ahead i
09:43 - probably made a mistake here but we'll
09:45 - run the program to see if everything's
09:46 - working
09:47 - again our name win is not defined
09:49 - win.fill ah so i've called this win one
09:52 - really needs to be
09:54 - surface like that
09:56 - so let's try now and there we go we get
09:58 - a nice little grid um on our screen like
10:00 - so 20 by 20 grid
10:02 - there we are so now let's move into
10:05 - another uh function actually let's start
10:07 - coding on the classes here so like i was
10:09 - talking about before we're going to have
10:11 - a snake object which is going to contain
10:13 - a bunch of cube objects so essentially
10:15 - what we're going to do is we're going to
10:16 - have a list of cubes and that's going to
10:18 - be known as the snake body so let's go
10:20 - ahead and write that in now
10:21 - what i want to do for that is just
10:23 - create a list so we're just going to say
10:25 - body
10:26 - is equal to and then a blank list i'm
10:28 - also just while we're already up here
10:30 - and creating a class variable i'm going
10:31 - to create turns
10:33 - is equal to and it's just going to be
10:35 - this set of squiggly brackets here that
10:37 - we'll uh we'll get into in a bit
10:40 - okay so now that we're already in the
10:41 - snake function
10:43 - what we need to do is we just need to
10:44 - define our
10:46 - parameters here that we're passed in so
10:48 - we're just going to say self.color
10:50 - equals color
10:52 - say self.head
10:55 - equals
10:56 - cube which i'll get into in a second
10:58 - given the position say self thought body
11:01 - dot append
11:03 - our head
11:05 - self.head like this so what we're doing
11:07 - here now is we're saying okay so the
11:08 - head of our snake which is going to be
11:10 - important because we need to know where
11:11 - that is at all times so we can move
11:12 - accordingly is equal to a cube at the
11:15 - given position and the given position is
11:17 - what we pass in here as like the
11:19 - starting position of our snake
11:21 - or we could create a new snake like we'd
11:23 - have multiple snakes moving around and
11:24 - anyways that's the position
11:26 - now we're saying we're going to append
11:28 - to the body
11:29 - this head so now this is
11:32 - in our list here and then we can go
11:34 - through that list and we can draw things
11:35 - we can move it we can check things we
11:37 - want all of our cubes to be ordered
11:39 - within this list so that's why i'm
11:40 - putting that in first now i'm just going
11:42 - to give
11:43 - this one which is called during x
11:46 - is equal to zero and
11:48 - turn y which is equal to one
11:51 - so what this is going to do is we have a
11:53 - direction for x in a direction for y for
11:56 - moving our snake so obviously these are
11:58 - going to be
11:59 - a value like negative 1
12:01 - 1
12:02 - or 0 and that's going to be the same for
12:04 - y and x if y or x is equal to 1 negative
12:07 - 1 then the other one's going to be equal
12:08 - to 0 because you can only be moving in
12:10 - one direction at the same time and this
12:12 - is just going to keep track of
12:13 - what direction we're moving in and we'll
12:15 - use this in the next function that we're
12:16 - going to code which is our move function
12:19 - so moving is pretty straightforward
12:22 - at least in terms of just if you have
12:24 - one object moving around the screen
12:25 - getting it to go left straight right but
12:27 - when you have the snake object it has to
12:30 - turn at certain points so when i click
12:32 - left um
12:33 - the rest of the snake is still moving
12:35 - forward once it reaches the point where
12:37 - the head turned left then it has to turn
12:39 - left so that's where things can get a
12:40 - bit complicated
12:42 - anyways to start what i'm going to do is
12:43 - i'm going to say for event
12:46 - in pi game oops am i doing with my
12:48 - typing here
12:50 - pygame dot events dot gets like so
12:54 - and then we're just gonna say if
12:56 - event dot
12:58 - type equals equals
13:00 - pi game
13:01 - dot quit like this and this is the first
13:04 - one we always want to code in because we
13:05 - want to make sure that if they click
13:06 - that little red arrow it actually works
13:09 - and we can quit we're going to do pi
13:10 - game dot quit like that and i'm just
13:12 - going to say if
13:14 - actually we don't even need another if
13:15 - because the way i'm going to do this
13:16 - is
13:17 - this other way you might have seen in pi
13:19 - game before to move things around you
13:20 - said if uh event dot type equals key
13:23 - down and then you just check which key
13:25 - was pressed and move to the left this is
13:26 - a similar thing but it works smoother
13:29 - i've used both of them a lot and this is
13:30 - one i prefer so i'm just going to use
13:31 - this so pygame dot pygame.key.get
13:34 - underscore press so what this is going
13:35 - to do is it's going to get a list
13:37 - actually i think it's like a dictionary
13:39 - or something like that that has all the
13:41 - key values
13:42 - and then if they were pressed or not
13:44 - so that way if you press more than one
13:46 - key at once when you're looping through
13:48 - it'll adjust to that whereas the other
13:49 - one you can only click one at a time and
13:51 - you couldn't move like per se diagonally
13:53 - if you're moving like a character on the
13:55 - screen it doesn't matter too much for
13:56 - this but this is the way i like to do it
13:57 - so now i'm going to say four key
13:59 - in keys
14:00 - because remember this is going to give
14:02 - us all of the keys and then like one or
14:04 - zero value if they were clicked or not
14:06 - um so we need to loop through all of
14:08 - them in check we're going to say if keys
14:10 - and then
14:11 - pygame dot key
14:14 - or oops dot k underscore left
14:17 - i thought it was key there and then
14:19 - we're going to say if keys
14:22 - high game dot okay underscore right like
14:25 - that
14:26 - and we can continue down here with up
14:28 - and down
14:30 - and then we'll get into exactly what is
14:32 - going to happen when we click uh these
14:34 - keys so last one here
14:41 - all right and there we go okay so now
14:44 - what we're going to do
14:45 - is we're going to change the direction
14:47 - according to what key we click so if
14:49 - we're going left that means that our x
14:51 - has to be negative because the way again
14:53 - coordinates work in pi game is in the
14:55 - top left-hand corner of your screen is 0
14:57 - 0
14:58 - so if we want to be moving left we
15:00 - should be making our x negative to move
15:03 - more towards zero right if we want to
15:05 - move right now you make our x positive
15:07 - which would be one in this case because
15:09 - we're just going to move one cube at a
15:10 - time to go further to the right same
15:12 - thing with the y it's kind of weird in
15:14 - pi game how the y works because the more
15:16 - y you add
15:18 - the further down you go um
15:20 - so we'll do that inside so for x we're
15:21 - going to say itself.dern x
15:23 - equals negative one again because moving
15:25 - left and we're going to set our turn y
15:27 - equal to zero
15:29 - and this is because again we don't wanna
15:30 - be moving in two directions at once and
15:32 - be going uh diagonally
15:34 - now this is what i was talking about
15:37 - is we need to remember where we actually
15:39 - turned because if you just have one cube
15:41 - moving around that's fine but when we
15:43 - have multiple cubes we need to be able
15:44 - to turn left
15:45 - right we need to remember where we
15:46 - turned so the tail of our cube can turn
15:48 - at that point so that's why we have that
15:50 - self.turns list up here or just this
15:53 - turns um i want to say dictionary or set
15:56 - whatever
15:56 - so we're going to add to that self.turns
15:59 - and
16:01 - we're going to give it a new key
16:04 - and i'll go through how this works in a
16:05 - second
16:06 - self.pause here
16:08 - is equal to and then we're going to give
16:12 - just a list of self. during x
16:15 - and self dot during y
16:18 - okay so you might be kind of confused on
16:19 - what's going on here so i've created a
16:21 - new dictionary up here that's what i'm
16:22 - going to call it officially you could
16:23 - think of it as a set as well
16:25 - and pretty much we're going to add a key
16:28 - which is the current position of the
16:31 - head of our snake
16:33 - and then it's going to be set equal to
16:35 - what direction we turned so we're saying
16:37 - we have a new turn at this position and
16:40 - our character or our snake moved left so
16:42 - it's going to say we have self dot
16:44 - during y which is right here as negative
16:45 - one self dot er surf dot during x array
16:47 - and then during y is equal to zero so we
16:49 - know what
16:50 - way we actually turned and i hope that
16:52 - makes sense that's uh yeah that's how
16:54 - we're going to do that now i'm just
16:56 - going to copy and paste these and then
16:57 - change these values so when we're going
16:58 - right this is going to be one
17:01 - oops
17:03 - same thing here so we'll put that in
17:05 - this is going to be zero
17:06 - and during y we're going up is going to
17:08 - be negative one
17:10 - now when we're going down
17:12 - we need to change this to one
17:14 - and this to zero and i'm just going to
17:16 - get rid of that
17:17 - and there we go okay so
17:19 - that is uh pretty much how we go about
17:22 - doing this um and i can also just put
17:25 - lifts here as well because we don't want
17:27 - to be able to move in more than one
17:28 - direction so we're going to prioritize
17:30 - the left arrow key if they're not
17:32 - clicking the left arrow key then we'll
17:34 - check they're doing the right otherwise
17:35 - up otherwise down because we don't want
17:37 - them to be able to click more than one
17:38 - key at once okay so next we need to
17:41 - actually move our cube and this is where
17:43 - it gets a little bit more tricky in
17:45 - terms of looking where our cube is and
17:48 - if it's at that turn then we're going to
17:50 - turn it
17:51 - so i'm just going to start coding and
17:52 - i'm kind of going to go through exactly
17:53 - what i do sort for i see and
17:56 - enumerate
17:57 - oops
18:00 - and i spoke that wrong didn't they
18:04 - like that uh and then we're going to say
18:06 - self.body because we're going to look
18:07 - through the list of uh positions that we
18:10 - have in
18:11 - on the snake we're going to say p equals
18:13 - c dot position
18:15 - and i'm just going to copy this um by
18:17 - the way that's what this little arrow
18:18 - does here it just makes a copy so that
18:20 - we're not changing the position of our
18:22 - snake um
18:24 - when we do things each
18:26 - just uh just follow along with it it's
18:27 - not super important okay so we're gonna
18:29 - say if p is in self dot turns
18:33 - like this because remember what we did
18:35 - is we added the position
18:37 - of our head two turns so now we're gonna
18:40 - say well if this position
18:42 - is in the turns
18:44 - then we're going to move
18:46 - or we're going to turn right so let's
18:48 - say here so we're going to say
18:49 - turn
18:51 - oops
18:53 - equals
18:54 - self.turns p
18:56 - like that
18:58 - so now we've seen that it's in there uh
19:00 - so now it's in there we can find the
19:01 - index of it uh and we can grab the
19:03 - direction value so we know what way
19:04 - we're gonna be moving and now we're just
19:06 - gonna say c dot move
19:08 - like this and turn
19:11 - zero
19:12 - turn
19:13 - one like so
19:15 - okay now next i'm gonna say
19:18 - if
19:19 - i equals equals the length of
19:22 - self.body
19:24 - minus one
19:26 - oops then i'm gonna do self i don't know
19:29 - why that's capital self.turns
19:32 - dot pop p okay so i know i just did a
19:34 - lot of coding here and this probably
19:37 - doesn't make a lot of sense to you guys
19:38 - so i'm going to kind of run through
19:39 - exactly what i just did um it's it's
19:42 - pretty it's a little bit difficult to
19:43 - explain so anyways what we start off by
19:45 - doing is we're going to say we're going
19:46 - to get the index and we're going to get
19:48 - the cube
19:49 - object in our self.buddy because
19:51 - remember our self.body is made up of
19:53 - cube objects right here um that have
19:57 - these properties right they're going to
19:58 - have a directory in y direction x um a
20:01 - start color so on and we're going to get
20:03 - we're going to get to coding cube in
20:04 - just a second so they're cube objects
20:07 - now all of these cube objects have a
20:09 - position so i'm saying for each
20:12 - object here i'm going to grab their
20:13 - position
20:14 - and i'm going to see if that position is
20:16 - in our turn list and we create the turn
20:18 - list and add to the turn list um
20:21 - when we turn right when we click left
20:24 - center right so on um
20:26 - and then we're going to say okay so the
20:28 - actual turn so where we're actually
20:29 - going to be moving is equal to
20:32 - um that are the turns list at that index
20:35 - right so we grab
20:37 - um the turn direction x and direction y
20:39 - which we stored there and now we're just
20:41 - going to say our cube dot move which is
20:43 - another method that we're going to code
20:45 - and we're giving it that direction x in
20:46 - that direction y so it knows what way it
20:48 - needs to move
20:49 - pretty well
20:51 - and then i say if i is equal to the
20:53 - length of self.body minus one so that
20:55 - means if we are on the last cube
20:58 - we're going to remove that turn so once
21:00 - that last cube hits that turn we're
21:03 - going to remove it because if we were
21:04 - just to leave that turn in the list that
21:06 - would mean any time you hit that
21:07 - position on the screen regardless of if
21:09 - the snake was turning there or not
21:11 - you'd automatically
21:12 - change directions
21:14 - if you don't remove it from the list um
21:17 - i hope that makes sense
21:18 - okay now also after this if here
21:21 - we're going to say if the um
21:24 - what do you call it if it's not in the
21:26 - list so if our position is not in the
21:27 - list we still need to move the snake
21:30 - because it's constantly moving so what
21:31 - do we do to this well we write an else
21:34 - and i'm just going to copy this in
21:35 - because it's going to take a second to
21:36 - type because i have another file open
21:38 - and i'll go through what happened how
21:39 - this works okay
21:41 - now this looks like a lot but pretty
21:42 - much what this is doing for us is we're
21:46 - checking whether or not we've reached
21:48 - the edge of the screen
21:49 - so we're saying if we're moving left
21:52 - and the position so the x position of
21:54 - our cube is less than or equal to zero
21:58 - um then we're going to change that
22:00 - position so that it goes to the right
22:01 - side of the screen
22:03 - so the way that we can do that is by
22:04 - saying c dot rows minus one because
22:06 - again in you start counting at zero in
22:08 - computers um so if our rows is like 20
22:11 - then the last cube would be 19 in a list
22:14 - right
22:15 - so c dot rows minus one and we're gonna
22:16 - be at the same y value so we'll leave
22:18 - that there
22:19 - okay and then we say otherwise uh we're
22:22 - gonna check if we're going right from
22:24 - moving right
22:25 - and same thing if we're at the edge of
22:27 - the screen move back to the left side by
22:29 - putting zero here and then next one if
22:31 - we're going down uh what we're going to
22:33 - be doing is again checking
22:35 - are we less than rows minus one or
22:37 - greater than rows minus one no we're not
22:39 - or if we are then let's move us back up
22:41 - to the top of the screen
22:43 - by changing our y value and then same
22:45 - thing here if you're moving upwards
22:48 - now if none of that's true so we're not
22:50 - at the edge of the screen we're not
22:51 - moving up left down to whatever i just
22:53 - said uh then we're just simply going to
22:55 - move our cube at the direction x and the
22:59 - direction y of that cube already so if
23:02 - that cube is moving upwards and it's not
23:04 - turning and it's not going to the edge
23:05 - of the screen it doesn't need to be
23:06 - changed just keep moving it in whatever
23:08 - direction it's going and that's why i'm
23:10 - simply referencing the cube's already
23:12 - existing direction x and direction y
23:14 - we're not changing anything we're simply
23:15 - just saying okay let's move you forward
23:17 - one like that
23:18 - i hope that makes sense that was a lot
23:20 - and that's probably one of the hardest
23:21 - things in this program is figuring out
23:23 - the movement of the stake so if you guys
23:24 - understand that um then that is the hard
23:27 - part kind of over with and we're going
23:28 - to get into this cube object so you're
23:30 - going to understand what all this means
23:32 - and how our rows and columns kind of
23:33 - work and stuff like that
23:35 - okay so i'm just going to forget about
23:37 - reset and add cue for now because we'll
23:39 - worry about those later um but let's get
23:42 - into the uh draw method because we want
23:43 - to see if it's actually working and put
23:44 - this on the screen so simply for i
23:47 - see
23:47 - [Music]
23:49 - numerate
23:50 - why can i not spell enumerate today like
23:52 - that uh same thing self.body like that
23:56 - we're going to say if i equals equal 0
24:00 - c dot draw and you'll see why it is in a
24:03 - second
24:04 - true
24:07 - else
24:07 - c dot draw
24:09 - surface
24:11 - like that okay so the reason i'm
24:13 - doing this little check here rather than
24:15 - just drawing every object
24:17 - is because when we uh draw the first
24:19 - snake object i'm sure if you remember my
24:21 - other program it had eyes so what i
24:23 - would simply want to do is make sure
24:25 - that when we draw that first object we
24:27 - add eyes onto it just so we know where
24:28 - the head of the snake is uh we don't get
24:30 - confused like what direction it's moving
24:31 - in although you shouldn't we i want to
24:33 - add the little eyes maybe just for
24:34 - aesthetic as well so what this true does
24:36 - optional parameter simply says draw eyes
24:39 - if it's the uh first one in our list
24:42 - like that if it's the head uh and then
24:44 - in this draw method you can see i have
24:46 - eyes equals to false but when you make
24:47 - it equal to true we're going to do a
24:48 - special thing in here that's going to
24:49 - draw eyes for us
24:51 - okay so now that we've coded this this
24:53 - whole mess of stuff in the snake
24:56 - class let's just run the program quickly
24:58 - and see if anything's happening so
24:59 - currently we just have the grid we don't
25:01 - have any errors or anything
25:02 - but that's because we haven't drawn the
25:04 - snake object onto the screen yet so what
25:06 - we need to do
25:08 - is we just need to simply do s dot draw
25:10 - it within our redraw window here so i'm
25:12 - just going to type i'm going to global s
25:14 - here and i'll global it down there as
25:15 - well i'm going to say s dot draw
25:17 - like that
25:19 - and we need to give it surface so
25:21 - let's give it a surface and i'm just
25:22 - going to global s
25:23 - so that we can reference it there
25:26 - uh and is there a reason we aren't being
25:28 - drawn to the screen let's just have a
25:30 - look quickly
25:32 - s dot draw
25:35 - let's.draw oh it's because yes we are
25:37 - indeed drawing s but we haven't drawn
25:39 - any of the cube objects yet and it is
25:42 - calling the draw method on all of our
25:44 - cube objects which we haven't yet
25:45 - created
25:46 - hopefully that makes sense but we'll go
25:48 - ahead and do that now so we have to code
25:50 - a little bit more before we can see
25:51 - everything so let's just go ahead and
25:52 - get into the cube object here and let's
25:54 - just say self.start
25:56 - equals start
25:57 - except i'm actually just going to change
25:59 - this to position because i believe this
26:00 - is what it's supposed to be
26:04 - and then we're going to say
26:05 - self.turn x
26:09 - equals one
26:10 - self.
26:12 - during y
26:13 - is equal to zero and self.color
26:18 - is equal to color and the reason we have
26:19 - this is because we're going to be
26:21 - drawing later what i want to call like a
26:23 - snack for the uh for the cube to collect
26:25 - for the snake to collect um so we want
26:27 - to be able to change the color with that
26:29 - and i spelled it wrong like three times
26:32 - during x and during y the reason i have
26:34 - duran x here set to one initially is
26:37 - because
26:38 - i i want to make sure that we start
26:40 - moving in a direction
26:42 - if i had this at zero you would have to
26:44 - click a key before the snake starts
26:45 - moving but i want right when we run the
26:46 - program for the snake to just start
26:48 - moving so i'm setting it already with a
26:50 - direction x and the reason these are
26:52 - optional again is so that when we create
26:53 - a new cube object
26:55 - we don't have to implicitly
26:57 - say direction x is one direction y is
26:59 - zero because it's assumed that it's
27:00 - always going to be like that unless
27:01 - otherwise stated
27:03 - okay
27:04 - let's have a look what else do we need
27:05 - to do here uh we need to now code this
27:07 - move function which is actually really
27:09 - easy um
27:10 - all i'm just gonna do is we're gonna say
27:12 - since we're changing the direction x in
27:14 - the direction y in our snake class we
27:16 - need to do that in here so that it stays
27:18 - with the object let's say during x
27:20 - equals
27:22 - during x
27:24 - and then the same thing self thought
27:26 - during y
27:27 - equals during y
27:30 - like that
27:32 - and then we'll go down here and all
27:33 - we're going to do is we're going to
27:34 - change our position so self.position
27:37 - is equal to self.pause 0 which is our
27:40 - already existing position plus
27:42 - self thought during x
27:45 - and they're saying self.
27:47 - pause one
27:48 - which is our already existing y value
27:51 - plus equals self dot
27:53 - during y like that
27:55 - and just in case i haven't mentioned it
27:56 - here right we're working with a grid
27:58 - system of 20 rows in this instant so
28:01 - when i say something like uh if our
28:03 - self-deposition is like 1 3 or 10 10 i'm
28:07 - saying we're in the 10th row in the 10th
28:09 - column i'm not saying the x value is
28:10 - equal to 10 and the y value is equal to
28:12 - 10
28:13 - because it's not in the case of drawing
28:15 - on the screen because our screen is
28:17 - actually a width of 500 pixels um but
28:19 - just where we are in the grid which is
28:20 - most important to us right now um is
28:23 - equal to like that values like one four
28:25 - or three five um so on like that just
28:27 - just to make that clear for anyone who
28:28 - might have been confused okay so now for
28:30 - drawing
28:32 - um it's a little bit harder just because
28:34 - of what i mentioned as well
28:35 - is the fact that we need to figure out
28:37 - the distance between each x value and
28:39 - each y value so when we're drawing
28:41 - something in pi game it draws in the top
28:43 - left hand corner of the object so if we
28:45 - draw a cube
28:46 - we're drawing that in the top left um so
28:48 - we need to figure out what that x and y
28:50 - value is going to be for each cube when
28:52 - we're drawing it to the screen
28:53 - so
28:54 - i'm just going to call this gap here
28:56 - that is going to be our distance and the
28:58 - same thing self.w
29:00 - by self.rows
29:02 - and we're going to change w and rows
29:05 - down in our program later but we can
29:06 - actually just type it in now
29:08 - like this so 500 and 200 just so we have
29:10 - that set okay so self.w answer divided
29:13 - by self.rows again that's the same thing
29:15 - we did when we were drawing the grid to
29:17 - figure out the distance between our x
29:19 - and y values okay we're going to say i
29:22 - is equal to
29:23 - self.pause zero that's going to save us
29:25 - a bit of typing in our function here or
29:27 - in our method i'm just going to say
29:28 - j.self.pause1
29:31 - so we're just saying i which stands for
29:33 - row j stands for column
29:35 - um like a classic like convention for it
29:38 - so that we don't have to keep typing
29:39 - pause zero pause one when we move okay
29:42 - so the next one next thing we need to do
29:43 - is now draw a rectangle we're gonna say
29:45 - pygame.draw.correct
29:48 - like this
29:49 - and then we need a surface
29:51 - we need a color so self.color and then
29:53 - we need a rect and here is a little bit
29:55 - of math i'm just going to type it and
29:56 - i'll go through exactly what what it
29:58 - does
30:00 - j multiplied by
30:01 - this one
30:04 - this minus two
30:05 - this s2
30:07 - okay so the reason i have these little
30:09 - plus ones and these minus twos here is
30:11 - just so you can still see the grid when
30:13 - we draw the rectangle um
30:15 - because if we were to draw with exactly
30:18 - the dimensions of this distance um
30:21 - then what would end up happening is we'd
30:22 - cover the white lines of the grid and it
30:24 - just looks kind of weird if you can't
30:25 - see the white lines um so that's why i
30:27 - have plus one
30:29 - added here and minus two just so we're
30:31 - drawn inside of the uh the circle or
30:33 - inside of the square a little bit and
30:34 - you'll see that in a second so what i'm
30:35 - simply doing is i'm multiplying my i
30:37 - value
30:38 - which is going to be my current like row
30:40 - column by the distance that we need to
30:42 - get to the next one and then same thing
30:44 - for j
30:45 - and then these little add ones minus
30:46 - twos is just to make sure that we stay
30:48 - inside so a quick quick example if you
30:50 - don't understand is say we're in a
30:51 - position zero zero so our i is zero and
30:53 - our j is zero
30:55 - we're going to say i multiplied by
30:57 - distance let's say distance is like 40.
30:59 - okay so zero multiplied by forty zero
31:01 - zero multiplied by forty 0. so our
31:04 - position is 0 0 and that's correct
31:06 - because if we're drawing in the top left
31:07 - hand corner here and we're in position 0
31:09 - 0 then that's where we should draw again
31:11 - if you go something like 0 10
31:14 - and you or and you move down i guess so
31:16 - 10 you're moving wide down you're going
31:18 - to say 0 minus distance 0 and you're
31:20 - going to say 10 multiplied by distance
31:22 - let's say it's 40 then we move to that
31:24 - correct position down the screen
31:27 - so this is rectangle x y with height
31:29 - okay makes sense now the next thing we
31:30 - need to do is we need to draw the eyes
31:33 - now you can skip this part if you want
31:34 - i'm just going to copy it in because
31:35 - it's a little bit of math to make it
31:36 - them like perfectly aligned on the
31:38 - square um
31:40 - but yeah so we say if eyes and we're
31:42 - saying our center is equal to distance
31:44 - modulus 2 because that's going to be the
31:46 - center obviously or much so i'm saying
31:48 - divided by 2 is going to be the middle
31:50 - of our cube
31:52 - and we're saying the radius that's how
31:53 - big the i radius is going to be
31:55 - and then we go through a little bit of
31:56 - math here so circle middle is going to
31:58 - be high multiplied by distance plus
32:01 - center minus radius
32:03 - and then we're finding out the x and
32:04 - this is just like a random x that i'm
32:06 - setting by just putting it 8 pixels up
32:09 - like every time because i don't want to
32:10 - calculate the x
32:12 - i don't feel like doing that and then
32:13 - i'm drawing two circles based on circle
32:15 - middle one circle middle two and then
32:17 - the radius and a color of black
32:19 - or a color of white actually sir or no
32:22 - that's black i'm confused all right
32:24 - anyways
32:26 - with all that being said and done and
32:28 - you guys probably pretty confused right
32:30 - now let's just run and see if anything's
32:32 - actually happening and you can see we
32:34 - have a cube in the middle of the screen
32:36 - yay so that's all we've done with all
32:38 - this coding um so far it's drawn a
32:41 - cube so actually not quite because we
32:44 - still
32:45 - all we have to do now simply to start
32:47 - having that cube move and seeing our key
32:48 - presses work is just do a little bit in
32:50 - the main loop so let's move down to the
32:52 - main loop now
32:53 - and have a look here what we need to do
32:56 - okay so what i'm going to do is i'm
32:58 - simply just going to call
32:59 - s dot move which is our snake object
33:01 - every time this main loop runs
33:03 - and what this will allow us to do um is
33:06 - i want to call this before i read draw
33:08 - window is it's going to go up to that
33:09 - method in snake it's going to check
33:11 - every time that we run the loop if a key
33:13 - has been pressed if it has we're going
33:14 - to move accordingly and remember that in
33:16 - this move loop here it moves all of the
33:19 - objects for us so it moves all those
33:20 - cube objects
33:22 - and then we're just drawing the grid
33:24 - we're drawing everything in this redraw
33:25 - function so it'll just display that and
33:27 - update that to the screen so let's see
33:28 - here
33:29 - and we get an error tuple object is not
33:31 - callable self dot pause zero plus
33:33 - although they're next
33:35 - um all right one second guys oh it's
33:37 - because i've used
33:42 - okay so apparently i am an idiot and i
33:44 - forgot to add an equal sign here so the
33:46 - issue was simply that this looked
33:49 - something like this then i changed it to
33:51 - square brackets when all i needed to do
33:53 - was put an equal sign like this and now
33:55 - we should be up and we're working so to
33:57 - reiterate the line here
33:59 - that the issue is out you guys probably
34:00 - saw this when i coded it to be honest um
34:03 - is
34:04 - in move in cube it's near the top of the
34:06 - program all you have to do is change
34:08 - this add an equal sign between this like
34:11 - the bracket and the pause so now that we
34:14 - run it we can see that we have a moving
34:16 - object and that we can move up down left
34:18 - right etc so on and so forth like that
34:23 - okay so play around with that for a
34:25 - second and now we'll get into adding
34:27 - cubes
34:28 - and we're actually almost done we just
34:30 - need to add the add cube function
34:32 - message box a little bit in the main
34:34 - loop and then we'll be finished
34:35 - okay so what we're going to do now is
34:38 - that's all great we're moving around but
34:39 - we need to add stuff to our cube right
34:41 - like we need to progress the game so to
34:43 - do this we are going to generate what i
34:46 - want to call a random snack that we're
34:47 - going to place on the screen
34:49 - that our snake can't eat so
34:51 - the way that we do this i'm just going
34:53 - to say
34:54 - positions
34:56 - equals item dot body and this item oops
35:00 - shouldn't be items should be item
35:02 - it's just going to be a snake object i
35:04 - don't know why i'm calling it item but
35:05 - that's what i'm calling it
35:06 - um and we're simply just going to set
35:08 - like a new list equal to
35:10 - that list
35:12 - so on okay so now we're going to say
35:13 - while true
35:16 - capital t
35:18 - we're gonna do x equals random dot rand
35:22 - range if you haven't imported random yet
35:24 - make sure you do that and y equals
35:26 - random dot range
35:28 - range rows
35:31 - and rows again should be
35:33 - global so let's make sure that
35:36 - this works with global rows
35:39 - like that and then after this we're
35:41 - going to say
35:42 - if don't know how i just typed that but
35:45 - the length of
35:47 - and i'm doing something fancy here and
35:48 - i'll explain what this does in a second
36:06 - okay
36:06 - so i know i just typed uh this stuff
36:09 - that probably makes absolutely no sense
36:10 - you guys if you haven't been using
36:11 - python for a little bit but pretty much
36:13 - what this is going to do
36:15 - is we're going to get a list
36:17 - of a filtered uh list
36:20 - and we're going to see if any of the
36:22 - positions are the same as
36:26 - like the current position of the snake
36:28 - pretty well so what we're doing is we're
36:30 - saying that we want to make sure that
36:32 - we're not going to put a snack on top of
36:34 - the snake because if we have a really
36:36 - long snake the chance that happens
36:37 - actually somewhat high and i didn't do
36:39 - this when i first coded the game so what
36:41 - happened is when you have your snake
36:42 - moving around the screen all of a sudden
36:43 - the snack would pop up but it's like on
36:45 - the tail of the snake
36:47 - um which you don't want so what this is
36:49 - doing and just type it out you don't
36:50 - really have to understand it
36:52 - is we're saying this this means a
36:53 - function
36:54 - uh z
36:55 - and we're just checking if the z dot
36:57 - position uh is equal to uh x y
37:01 - so if it's equal to x y which is the
37:03 - position we just generated here by
37:04 - getting two random numbers so x and y um
37:07 - then we're going to have to do this
37:09 - again so we say
37:11 - continue
37:14 - and else
37:16 - we break
37:18 - like that and then i'm just simply going
37:19 - to return
37:22 - a tuple or a tubal whatever you want to
37:23 - call it x y
37:25 - okay so this is confusing but um you can
37:27 - do this in like a much longer way with a
37:29 - for loop where you pretty much loop
37:30 - through every position in this list you
37:33 - check it against x and y
37:35 - you see if it's the same if it's the
37:37 - same then do this loop again otherwise
37:39 - you break and you return x y that's all
37:41 - we're doing in there uh to generate a
37:42 - random snap
37:44 - any message box you're gonna leave that
37:46 - and in here now what we're gonna okay so
37:48 - now that i've created this uh this
37:50 - random snack function what i need to do
37:52 - is i need to use it so i'm just going to
37:54 - create a new object i'm going to call
37:55 - this snack and it's going to be equal to
37:57 - another cube right because we want to
37:59 - have the same functionality we want to
38:01 - be able to draw it
38:02 - possibly move it around right so we're
38:04 - just going to create a new cube object
38:05 - we're going to give it a position of a
38:06 - random snack which is going to be
38:07 - something like this
38:10 - random snack and then random snack i
38:12 - believe oh it takes a row in an item so
38:14 - what we're going to do is we're going to
38:15 - give it
38:17 - or rows and we'll just give it our item
38:20 - which is gonna be s
38:21 - um and then after that what else do we
38:23 - need for cube
38:24 - i don't think we actually need anything
38:26 - else i think that's all we need oh i'm
38:27 - gonna change the color that's what i
38:28 - wanna do i'm gonna change the color
38:30 - equal to green so red green blue 255 for
38:33 - green
38:34 - so that it shows up and is visible on
38:35 - screen and now what i'm going to do down
38:37 - here in this while loop is i'm going to
38:39 - say
38:39 - snack i'm going to check if our the head
38:42 - of our snake has hit the the snack and
38:45 - if it has we're gonna add
38:47 - another part to the body of the snake
38:50 - otherwise we're not gonna do that right
38:51 - and then we're gonna generate a new
38:52 - snack and so on so we're just gonna say
38:54 - if
38:55 - s dot body
38:58 - zero
38:59 - dot pause and this is going to be the
39:00 - head right because we have it ordered i
39:02 - don't need those brackets
39:03 - is equal to
39:05 - snap dot pause and remember these are
39:07 - both cube objects so this works fine
39:08 - because they're going to be tuples um
39:10 - then what we're going to do
39:12 - is we're simply going to say s dot add
39:14 - cube which is a method that we have
39:16 - there that we haven't actually written
39:17 - yet and we're going to say snack is now
39:19 - equal to well a new cube so i'm just
39:21 - going to copy this
39:23 - and paste it here um so all we're doing
39:25 - is now generating a new cube for snack
39:28 - i'm sure i could put something in that
39:30 - like changed it but this is just the way
39:32 - that works okay so now that we've done
39:34 - that we should be able to move around
39:35 - the screen and get the snack but we need
39:37 - to code in the add snack method here
39:40 - which i believe i have here or add cue
39:42 - so the ad cube is pretty straightforward
39:45 - we just have to figure out where we're
39:47 - adding that snack or wherever we're
39:49 - adding that cube i don't know why i keep
39:50 - calling it snack to the uh list so what
39:53 - we're going to do is we're going to
39:54 - figure out where the tail is and we want
39:56 - to add it after that tail
39:58 - so tail is equal to
40:00 - self dot body
40:02 - negative one the last element in that
40:04 - list i'm going to say dx dy which again
40:06 - is going to be our direction x direction
40:07 - why i'm just shorting it shorting it
40:09 - here it's going to be tail dot dern x
40:12 - and
40:13 - tail dot
40:14 - turn y like this
40:16 - now again you can do this in two lines
40:18 - i'm just doing it like this because it's
40:19 - faster and now i'm going to copy some
40:21 - again and we'll just go through exactly
40:23 - what this does
40:26 - okay so pretty much
40:28 - this looks complicated but all it's
40:30 - going to be doing is checking what
40:32 - direction that we're currently moving in
40:34 - like the head of the cube or the tail
40:36 - actually of the cube is moving in so
40:38 - that we can then make sure that when we
40:39 - add that um
40:41 - cube we know where to add it so for
40:43 - adding it like to the right of the cube
40:44 - to the left of the cube above it below
40:46 - it and we can give it the correct
40:48 - direction to be moving in
40:50 - so pretty much
40:53 - um what we do here
40:54 - is we just say we're going to append a
40:56 - new cube to our body
40:59 - and its position if we're moving to the
41:01 - right which in here we are because dx
41:03 - equals 1
41:04 - is one less than the x position of that
41:08 - tail
41:09 - so whatever the last cube is one less
41:10 - than that and that's so that we don't
41:12 - add a cube per se to the right when
41:14 - we're moving to the right and then
41:16 - we're just gonna have overlapping cubes
41:17 - and you're not gonna see them right
41:19 - same thing down here if we're moving
41:21 - down
41:22 - that means or not down sorry for moving
41:24 - left that means we need to add the cube
41:26 - to the right side um so one plus that
41:29 - tail of the exposition of the tail of
41:31 - the cube
41:32 - or of the snake sorry so that we can um
41:35 - have it in the proper position right and
41:36 - the same thing here with x and y uh or
41:39 - with y so that when we're moving up or
41:41 - we're moving down then we add it above
41:43 - otherwise we move we put it below
41:46 - so i just stumbled through that um
41:48 - because there was a lot of different
41:49 - words they're very similar anyways
41:51 - what we need to do now is simply set the
41:53 - direction uh for that cube so now that
41:56 - we added it in if we just left it like
41:58 - that it wouldn't be moving anywhere so
41:59 - we just need to change that to the
42:01 - current direction of that tail so
42:03 - whatever the tail is moving that's where
42:05 - this new cube is going to be moving in
42:06 - that direction so we're just going to
42:07 - say self.body
42:10 - negative1.dern
42:12 - x equals dx and then same thing down
42:15 - here except we're going to change these
42:16 - to y
42:18 - during y
42:20 - equals d y and that again is just the uh
42:23 - where our tail is moving at that current
42:25 - moment
42:26 - okay so now that we've got all that done
42:28 - it's time to see what syntax air we get
42:30 - next name rows is parameter and global
42:35 - one second
42:36 - so i've actually never even ran into
42:38 - that error oh global rows as
42:40 - okay so let's just make this r
42:42 - and let's change this to be
42:47 - one second ah we can just get rid of
42:48 - this
42:50 - and this should work there we go so now
42:52 - we move around like this the only issue
42:54 - is our snack is not being generated on
42:56 - the screen and i don't know why that is
42:58 - exactly happening oh it's because we're
43:00 - not drawing the snack that's why so
43:02 - now i'm just going to global snack up
43:04 - here i believe that's what i called it
43:06 - and i'm simply just going to say snack
43:09 - dot
43:09 - draw
43:10 - like that and i gotta give it a surface
43:13 - so let's give it a surface let's run
43:16 - and error name snack is not defined
43:19 - it's because i didn't global it down
43:20 - here so let's
43:22 - go over that
43:23 - okay so now we have the snack it's on
43:26 - the screen
43:27 - and you can see that when we collect it
43:29 - we have that cube added to the end of
43:31 - our snake
43:32 - and that pretty much is almost the game
43:35 - done so all we need to do now
43:37 - is write that reset method and then we
43:40 - need to just simply check like when we
43:42 - lose like right now the snake can go
43:43 - through each other right through itself
43:44 - and you can see we have a huge error
43:46 - when the snake can go through itself so
43:48 - we need to make sure that when we hit
43:50 - ourselves um we like end the game and we
43:52 - need to write that message method as
43:54 - well so to do this um
43:57 - again i'm just going to copy in this for
43:59 - loop uh and then we'll kind of go go
44:02 - from there so
44:03 - let's move in here
44:06 - okay so for x and range the length of s
44:08 - dot body uh we're going to say s dot
44:10 - body x which is going to be we're just
44:12 - looping through every cube in our snake
44:14 - body we're checking if the position
44:17 - is in a list of um
44:20 - all the positions after that works um
44:23 - that's how we're checking the collision
44:24 - if you want to do it your own way um go
44:26 - ahead but this is the way that i like to
44:27 - do it okay so now what i'm going to do
44:29 - um is i just want to print to the
44:31 - console like their score uh just so that
44:33 - i know what it is let's say a score
44:35 - oops
44:38 - and then we'll just say plus is the
44:40 - length of
44:42 - s dot body but this is going to have to
44:44 - be converted to a string unless i put a
44:46 - comma like that so let's just do it like
44:47 - that
44:48 - and then i am going to simply display a
44:50 - message box will say message box
44:53 - like this message underscore box uh we
44:56 - have a subject and we have content and
44:58 - we'll we'll do that in just a second
44:59 - because i haven't yet um actually coded
45:01 - that
45:02 - and then we're going to reset our snake
45:03 - by just doing s dot reset and this is
45:04 - going to take a position which is going
45:05 - to be our starting position again 10 10.
45:08 - um and then we're going to break out of
45:09 - this for loop because if we collided
45:11 - once we don't really care if we collided
45:12 - again
45:14 - and go back and we continue the game
45:16 - with a snake that has length one now
45:19 - okay
45:20 - so our reset um this is pretty
45:22 - straightforward all i'm doing in this
45:23 - reset
45:24 - is i'm just gonna get rid of
45:27 - our turns i'm gonna get rid of our body
45:30 - um and i'm just going to change like the
45:31 - direction x and the direction y so maybe
45:33 - it's faster if i just copy it and you
45:34 - guys can
45:36 - just copy this out
45:38 - so pretty much all i'm doing is i'm
45:39 - setting a new head um which is going to
45:41 - be equal to
45:43 - again like whatever position we give in
45:44 - because we can move it at a different
45:45 - position if we wanted to i'm clearing
45:48 - self.body which is in the class variable
45:50 - here
45:51 - and then i'm adding head i'm setting
45:54 - turns equal to blank direction x is zero
45:56 - direction y is set to one again so we
45:58 - start moving and you can see it's pretty
46:01 - much exactly what i have typed out here
46:02 - except i'm just resetting the turns list
46:05 - okay so now that we've done that
46:07 - all we need to code is message box so
46:09 - this one's pretty easy um you can see up
46:11 - here just in case you haven't looked yet
46:13 - um i import tkinter stk and then from
46:16 - decanter i import message box
46:18 - now this is how you create a message box
46:20 - in a pie game and this is how you create
46:22 - one that actually shows up on top of the
46:24 - screen um and that doesn't like float
46:26 - kind of below it or it doesn't show up
46:28 - right away if you want to say that um so
46:31 - just watch this is extremely useful to
46:32 - use in other programs too if you if you
46:34 - copy out this uh
46:35 - function and then you just drag it into
46:36 - other ones so
46:39 - attributes
46:43 - topmost
46:44 - comma true what this simply does is
46:46 - we're creating a root oops which is not
46:49 - root.tk it's root equal to tk.tk which
46:52 - is going to be a new tkinter window
46:54 - we're making sure that this window is
46:56 - going to be on top of anything so if we
46:58 - have like a bunch of different windows
46:59 - open it just comes up on top which is
47:01 - what we want i'm just going to simply
47:03 - make this window now
47:04 - invisible and i'll explain how this
47:06 - works in a second and then from this
47:08 - message box um
47:10 - what do you call it method class
47:11 - whatever it's going to say message box
47:13 - dot show info
47:14 - and then we're going to do subject
47:16 - and content
47:18 - and this just takes it takes a few more
47:19 - parameters as well if you want but
47:21 - pretty much just just shows info
47:22 - given whatever subject we type in and
47:24 - whatever content we have and now i'm
47:26 - going to say try
47:29 - root dot
47:30 - destroy
47:31 - like that
47:34 - accept oops
47:37 - uh pass and don't ask me what this does
47:39 - because honestly i don't know but it
47:40 - just works so pretty much it shows this
47:42 - message box
47:43 - and i'm actually pretty sure the way
47:45 - that this works is it constantly keeps
47:47 - trying to destroy the message box until
47:50 - eventually you click the x button and
47:52 - then it actually can i think it's like
47:53 - something like that so anyways that's
47:54 - how you create a message box and with
47:57 - that we all need to do is add a subject
47:59 - and content so i'm going to say you lost
48:03 - and
48:04 - our message will be play again
48:08 - let's run the program for the last time
48:10 - and make sure everything is working
48:13 - so there we go i just need to get my
48:14 - snake to a length that is uh large
48:16 - enough to the point where i can actually
48:18 - hit myself
48:21 - oh okay and there we go so pretty much
48:24 - we ran into an error
48:25 - what is the air i spelt attributes wrong
48:28 - that is lovely air to run into let's
48:31 - run back up here
48:33 - attributes attributes attributes where
48:35 - did i even make this function i must
48:36 - have scrolled path it all right there we
48:37 - go
48:41 - and i believe that's correct
48:43 - let's try this now
48:46 - so i'm actually just going to go and see
48:48 - if i can there we go okay so we get a
48:50 - message says you lost play again and the
48:52 - reason i died there by the way is
48:53 - because while i was moving right i moved
48:55 - left so technically um the head of my
48:58 - snake actually ran into another part of
49:00 - it so it says you lost play again um and
49:02 - you can make that say exactly what you
49:04 - want and then we can see that our guy
49:05 - just continues to move
49:07 - so on
49:08 - so anyways
49:09 - if you guys want to see more content
49:11 - like this go check out my channel it is
49:13 - named tech with tim and i do have a
49:15 - bunch of videos teaching stuff like pie
49:17 - game and doing a bunch of python
49:18 - tutorials you guys will definitely learn
49:20 - a lot following through some of my
49:21 - videos and i would be very grateful if
49:23 - you guys went over there and liked some
49:25 - of my videos and subscribed

Cleaned transcript:

so let's just go ahead and get a look at what this final product is going to look like um so on like an x by x grid so whatever you want it to be you have a little snake moving around there's a snack is what i want to call it that shows up and as you collect it it increases the length of the tail and then obviously if you run into yourself and i just did that by clicking the back key while i was going forward it gives you a little error message here says you ran into your tail um your length was nine dot dot dot whatever um and then you can continue and play as long as you want um anyways what i'm going to be doing in here is i'm going to be coding everything object orientated i know that there's a much faster and easier way to do this but it doesn't really teach you that much this way you're going to learn a bit about objects about classes how we can kind of work with them and you'll see like how the flow of my program goes and you should learn quite a bit especially if you're somewhat a beginner programmer what we're going to be using to make this is module called pygame if you don't know about pi game and you want to learn about it before you do this i would recommend that all right so let's start coding so pretty much what i've done is i've just set up the flow of the program all the classes and the function just to remind myself what i need to write and while i'm talking here it's probably a good idea if you guys copy this down so what we're gonna have is we're gonna have two main objects we're gonna have a cube object and a snake object and our snake object is going to contain cube objects if that makes sense so each one of those little red i don't know squares that was moving around is a cube object and the whole thing is our snake object we're going to have a few functions here draw grid redraw window random snack message box and main so let's get started with our main function here and this is what's going to be our main loop so essentially what i need for the main loop to start is we need to make a surface so in high game to do this we do win equals pi game dot display dot set underscore mode and then i'm going to set it um let's see here what do i want the height to be let's say width and height like this oops bad spelling and i'm just going to make a variable here called width equals height equals and we'll just set this to 500 by what i have 500 like so now we need another variable i'm going to set this as rows uh i can delete this down here it's going to do something but i'll do that later um and this is how many rows you're going to have or rows or columns whatever you can set this to whatever you want just make sure it divides 500 evenly otherwise you're going to have like weird looking rows if you know what i mean so i'm just going to set mine to 20 that's what i'm using in the other one but if you want to make it harder set it to something like 10 and there won't be as much room for the snake to move around and the games will go faster pretty well okay next what we need to do is we need to set up a snake object so i know that uh we haven't even created like anything in the snake class yet but i'm just gonna do s equals snake and i'm just gonna give it a position so in this case we want to or a color sorry which is going to be red because red green blue 255 for red and then i'm going to give it a position we're going to start in the middle so i'm going to start at 10 10. um now let's move into our main loop so i'm just going to say wow flag create my variable up here flag equals true and then we're just going to start by doing a pi game tick so pi game dot time dot delay 50 like so and that's just going to delay us uh i want to say like 0.5 or 50 milliseconds every time so that our program doesn't run too fast i'm also just going to create this clock.tick i'm going to put that at 10 and what i'm going to do is i'm going to create a clock object up here um and this is a builtin thing in pie game and what this is going to do is explain in just one second once i finish typing it pie game dot clock i believe it is oops dot time dot clock like so so what this clock dot tick is actually going to do is it's going to make sure that our game doesn't run at more than 10 frames per second um so that would mean essentially that our snake would be able to move like 10 blocks in one second and again we don't want it to be that fast so that's why we're also delaying um by like a few milliseconds here if you put this too low um then again it's going to move too low you can play around with the speed this is kind of what i found was the best speed um and it may vary depending on what machine you're on it shouldn't it might so you might want to just change these numbers um again the lower this goes is the faster it's going to be and the lower this one goes is the slower it's going to be so they're kind of inversely proportional like that all right um next what are we going to do here i'm just going to call redraw window and i butcher that so bad oops redraw window like so i'm just going to give it a surface which is in this case going to be win that we've created up here and for now that's all i'm going to put in my main loop here and we'll move more into that once i start coding some other stuff okay so now that we have our redraw window being called here i'm going to go and i'm going to start coding our redraw window so what this is essentially going to do is we first need to update the display so pygame.display dot update like so and we also need to um draw the grid so we're simply going to draw a grid we're going to pass it that same surface that we were given um and move on from that we're also going to fill the screen so when dot fill in this case i'm just going to use black so it's zero zero zero um and there we are that's all we need to do right now but essentially we're also gonna need to draw the snake uh we're gonna need to draw a few other things on the screen uh that we'll get to later okay so draw grid let's move into this one now uh what we need to do here is a set like draw a grid which is pretty easy to do um so what we do is we we're given rows and surface so it's probably a good idea if i actually passed in the rows and surface so i'm just going to global them here so that i can reference them i think this is going to work we'll do global rows and width like that and here we also need to make these global just because i don't want to pass them in every time i draw a grid we're just going to say width uh oops androids and this height variable is actually not necessary because we are just going to draw a square um like a square surface every time so we can just make this the same we don't need two variables for width and height to it are going to contain the same number anyway so global width and rows i go here draw a grid given with rows and surface so now we're going to put in well first we're going to put our rows or oops width row and surface like that okay so that should be working now in here what we first need to do when we're drawing a grid is we want to figure out um how big each square in the grid is going to be because what we're going to do is we're going to just draw lines going down and across but we need to figure out where to draw those lines so we have to figure out kind of like the gap between each of the lines so the way we do that i'm just going to create a variable here size between is equal to our width integer divided by our rows this is just so that we don't get like large decimal numbers because that we cannot pass into our uh drawline method in uh in python okay so now i'm just going to create x variable and a y variable and i'm going to set these to zero and say 4l in range and this is just standing for line pretty well and rows like that now what i'm going to do is i'm going to increment my x by the size between and i'm going to increment my y by the same so y equals y plus oops size between i can get rid of one of the spaces here oh what okay there we are and now we're simply just going to draw two lines so to draw a line in pie game all we have to do is pygame dot draw dot line and the arguments that takes is a surface we need a color in this case it's gonna be white so we do 255 255 255 for white we're going to draw at x 0 comma x w and i'll go through this in just one second what this does and i'm just going to copy this and draw one more and then explain how this is going to work pretty well okay so now we need 0 y and w y like so okay so what this is going to do is this is going to draw two lines for us every loop of this for loop and these arguments here is the start position of the line and the end position of the line so the first line that we want to draw is going horizontal which means we don't want to change the y value at all um so what we need to do is we need to find the x and then we're going to put y at 0 because we're going to be at the top i think that's right at least oh sorry this this line is dropped being drawn down not being drawn to the right i was getting confused there okay so we're going to change the x but we're going to keep the y at zero and then we're going to stay at that same x and we're going to keep the y at the width of the screen so that we're going uh far enough down and then same thing here this one is going horizontal excuse me i messed that up before so our x is always going to stay at zero and our y is going to be what's changing as we draw horizontal lines across the screen i hope that makes sense to everyone how that works anyways i'm going to move on from that and that's all we need for the draw grid uh function so let's just go ahead i probably made a mistake here but we'll run the program to see if everything's working again our name win is not defined win.fill ah so i've called this win one really needs to be surface like that so let's try now and there we go we get a nice little grid um on our screen like so 20 by 20 grid there we are so now let's move into another uh function actually let's start coding on the classes here so like i was talking about before we're going to have a snake object which is going to contain a bunch of cube objects so essentially what we're going to do is we're going to have a list of cubes and that's going to be known as the snake body so let's go ahead and write that in now what i want to do for that is just create a list so we're just going to say body is equal to and then a blank list i'm also just while we're already up here and creating a class variable i'm going to create turns is equal to and it's just going to be this set of squiggly brackets here that we'll uh we'll get into in a bit okay so now that we're already in the snake function what we need to do is we just need to define our parameters here that we're passed in so we're just going to say self.color equals color say self.head equals cube which i'll get into in a second given the position say self thought body dot append our head self.head like this so what we're doing here now is we're saying okay so the head of our snake which is going to be important because we need to know where that is at all times so we can move accordingly is equal to a cube at the given position and the given position is what we pass in here as like the starting position of our snake or we could create a new snake like we'd have multiple snakes moving around and anyways that's the position now we're saying we're going to append to the body this head so now this is in our list here and then we can go through that list and we can draw things we can move it we can check things we want all of our cubes to be ordered within this list so that's why i'm putting that in first now i'm just going to give this one which is called during x is equal to zero and turn y which is equal to one so what this is going to do is we have a direction for x in a direction for y for moving our snake so obviously these are going to be a value like negative 1 1 or 0 and that's going to be the same for y and x if y or x is equal to 1 negative 1 then the other one's going to be equal to 0 because you can only be moving in one direction at the same time and this is just going to keep track of what direction we're moving in and we'll use this in the next function that we're going to code which is our move function so moving is pretty straightforward at least in terms of just if you have one object moving around the screen getting it to go left straight right but when you have the snake object it has to turn at certain points so when i click left um the rest of the snake is still moving forward once it reaches the point where the head turned left then it has to turn left so that's where things can get a bit complicated anyways to start what i'm going to do is i'm going to say for event in pi game oops am i doing with my typing here pygame dot events dot gets like so and then we're just gonna say if event dot type equals equals pi game dot quit like this and this is the first one we always want to code in because we want to make sure that if they click that little red arrow it actually works and we can quit we're going to do pi game dot quit like that and i'm just going to say if actually we don't even need another if because the way i'm going to do this is this other way you might have seen in pi game before to move things around you said if uh event dot type equals key down and then you just check which key was pressed and move to the left this is a similar thing but it works smoother i've used both of them a lot and this is one i prefer so i'm just going to use this so pygame dot pygame.key.get underscore press so what this is going to do is it's going to get a list actually i think it's like a dictionary or something like that that has all the key values and then if they were pressed or not so that way if you press more than one key at once when you're looping through it'll adjust to that whereas the other one you can only click one at a time and you couldn't move like per se diagonally if you're moving like a character on the screen it doesn't matter too much for this but this is the way i like to do it so now i'm going to say four key in keys because remember this is going to give us all of the keys and then like one or zero value if they were clicked or not um so we need to loop through all of them in check we're going to say if keys and then pygame dot key or oops dot k underscore left i thought it was key there and then we're going to say if keys high game dot okay underscore right like that and we can continue down here with up and down and then we'll get into exactly what is going to happen when we click uh these keys so last one here all right and there we go okay so now what we're going to do is we're going to change the direction according to what key we click so if we're going left that means that our x has to be negative because the way again coordinates work in pi game is in the top lefthand corner of your screen is 0 0 so if we want to be moving left we should be making our x negative to move more towards zero right if we want to move right now you make our x positive which would be one in this case because we're just going to move one cube at a time to go further to the right same thing with the y it's kind of weird in pi game how the y works because the more y you add the further down you go um so we'll do that inside so for x we're going to say itself.dern x equals negative one again because moving left and we're going to set our turn y equal to zero and this is because again we don't wanna be moving in two directions at once and be going uh diagonally now this is what i was talking about is we need to remember where we actually turned because if you just have one cube moving around that's fine but when we have multiple cubes we need to be able to turn left right we need to remember where we turned so the tail of our cube can turn at that point so that's why we have that self.turns list up here or just this turns um i want to say dictionary or set whatever so we're going to add to that self.turns and we're going to give it a new key and i'll go through how this works in a second self.pause here is equal to and then we're going to give just a list of self. during x and self dot during y okay so you might be kind of confused on what's going on here so i've created a new dictionary up here that's what i'm going to call it officially you could think of it as a set as well and pretty much we're going to add a key which is the current position of the head of our snake and then it's going to be set equal to what direction we turned so we're saying we have a new turn at this position and our character or our snake moved left so it's going to say we have self dot during y which is right here as negative one self dot er surf dot during x array and then during y is equal to zero so we know what way we actually turned and i hope that makes sense that's uh yeah that's how we're going to do that now i'm just going to copy and paste these and then change these values so when we're going right this is going to be one oops same thing here so we'll put that in this is going to be zero and during y we're going up is going to be negative one now when we're going down we need to change this to one and this to zero and i'm just going to get rid of that and there we go okay so that is uh pretty much how we go about doing this um and i can also just put lifts here as well because we don't want to be able to move in more than one direction so we're going to prioritize the left arrow key if they're not clicking the left arrow key then we'll check they're doing the right otherwise up otherwise down because we don't want them to be able to click more than one key at once okay so next we need to actually move our cube and this is where it gets a little bit more tricky in terms of looking where our cube is and if it's at that turn then we're going to turn it so i'm just going to start coding and i'm kind of going to go through exactly what i do sort for i see and enumerate oops and i spoke that wrong didn't they like that uh and then we're going to say self.body because we're going to look through the list of uh positions that we have in on the snake we're going to say p equals c dot position and i'm just going to copy this um by the way that's what this little arrow does here it just makes a copy so that we're not changing the position of our snake um when we do things each just uh just follow along with it it's not super important okay so we're gonna say if p is in self dot turns like this because remember what we did is we added the position of our head two turns so now we're gonna say well if this position is in the turns then we're going to move or we're going to turn right so let's say here so we're going to say turn oops equals self.turns p like that so now we've seen that it's in there uh so now it's in there we can find the index of it uh and we can grab the direction value so we know what way we're gonna be moving and now we're just gonna say c dot move like this and turn zero turn one like so okay now next i'm gonna say if i equals equals the length of self.body minus one oops then i'm gonna do self i don't know why that's capital self.turns dot pop p okay so i know i just did a lot of coding here and this probably doesn't make a lot of sense to you guys so i'm going to kind of run through exactly what i just did um it's it's pretty it's a little bit difficult to explain so anyways what we start off by doing is we're going to say we're going to get the index and we're going to get the cube object in our self.buddy because remember our self.body is made up of cube objects right here um that have these properties right they're going to have a directory in y direction x um a start color so on and we're going to get we're going to get to coding cube in just a second so they're cube objects now all of these cube objects have a position so i'm saying for each object here i'm going to grab their position and i'm going to see if that position is in our turn list and we create the turn list and add to the turn list um when we turn right when we click left center right so on um and then we're going to say okay so the actual turn so where we're actually going to be moving is equal to um that are the turns list at that index right so we grab um the turn direction x and direction y which we stored there and now we're just going to say our cube dot move which is another method that we're going to code and we're giving it that direction x in that direction y so it knows what way it needs to move pretty well and then i say if i is equal to the length of self.body minus one so that means if we are on the last cube we're going to remove that turn so once that last cube hits that turn we're going to remove it because if we were just to leave that turn in the list that would mean any time you hit that position on the screen regardless of if the snake was turning there or not you'd automatically change directions if you don't remove it from the list um i hope that makes sense okay now also after this if here we're going to say if the um what do you call it if it's not in the list so if our position is not in the list we still need to move the snake because it's constantly moving so what do we do to this well we write an else and i'm just going to copy this in because it's going to take a second to type because i have another file open and i'll go through what happened how this works okay now this looks like a lot but pretty much what this is doing for us is we're checking whether or not we've reached the edge of the screen so we're saying if we're moving left and the position so the x position of our cube is less than or equal to zero um then we're going to change that position so that it goes to the right side of the screen so the way that we can do that is by saying c dot rows minus one because again in you start counting at zero in computers um so if our rows is like 20 then the last cube would be 19 in a list right so c dot rows minus one and we're gonna be at the same y value so we'll leave that there okay and then we say otherwise uh we're gonna check if we're going right from moving right and same thing if we're at the edge of the screen move back to the left side by putting zero here and then next one if we're going down uh what we're going to be doing is again checking are we less than rows minus one or greater than rows minus one no we're not or if we are then let's move us back up to the top of the screen by changing our y value and then same thing here if you're moving upwards now if none of that's true so we're not at the edge of the screen we're not moving up left down to whatever i just said uh then we're just simply going to move our cube at the direction x and the direction y of that cube already so if that cube is moving upwards and it's not turning and it's not going to the edge of the screen it doesn't need to be changed just keep moving it in whatever direction it's going and that's why i'm simply referencing the cube's already existing direction x and direction y we're not changing anything we're simply just saying okay let's move you forward one like that i hope that makes sense that was a lot and that's probably one of the hardest things in this program is figuring out the movement of the stake so if you guys understand that um then that is the hard part kind of over with and we're going to get into this cube object so you're going to understand what all this means and how our rows and columns kind of work and stuff like that okay so i'm just going to forget about reset and add cue for now because we'll worry about those later um but let's get into the uh draw method because we want to see if it's actually working and put this on the screen so simply for i see numerate why can i not spell enumerate today like that uh same thing self.body like that we're going to say if i equals equal 0 c dot draw and you'll see why it is in a second true else c dot draw surface like that okay so the reason i'm doing this little check here rather than just drawing every object is because when we uh draw the first snake object i'm sure if you remember my other program it had eyes so what i would simply want to do is make sure that when we draw that first object we add eyes onto it just so we know where the head of the snake is uh we don't get confused like what direction it's moving in although you shouldn't we i want to add the little eyes maybe just for aesthetic as well so what this true does optional parameter simply says draw eyes if it's the uh first one in our list like that if it's the head uh and then in this draw method you can see i have eyes equals to false but when you make it equal to true we're going to do a special thing in here that's going to draw eyes for us okay so now that we've coded this this whole mess of stuff in the snake class let's just run the program quickly and see if anything's happening so currently we just have the grid we don't have any errors or anything but that's because we haven't drawn the snake object onto the screen yet so what we need to do is we just need to simply do s dot draw it within our redraw window here so i'm just going to type i'm going to global s here and i'll global it down there as well i'm going to say s dot draw like that and we need to give it surface so let's give it a surface and i'm just going to global s so that we can reference it there uh and is there a reason we aren't being drawn to the screen let's just have a look quickly s dot draw let's.draw oh it's because yes we are indeed drawing s but we haven't drawn any of the cube objects yet and it is calling the draw method on all of our cube objects which we haven't yet created hopefully that makes sense but we'll go ahead and do that now so we have to code a little bit more before we can see everything so let's just go ahead and get into the cube object here and let's just say self.start equals start except i'm actually just going to change this to position because i believe this is what it's supposed to be and then we're going to say self.turn x equals one self. during y is equal to zero and self.color is equal to color and the reason we have this is because we're going to be drawing later what i want to call like a snack for the uh for the cube to collect for the snake to collect um so we want to be able to change the color with that and i spelled it wrong like three times during x and during y the reason i have duran x here set to one initially is because i i want to make sure that we start moving in a direction if i had this at zero you would have to click a key before the snake starts moving but i want right when we run the program for the snake to just start moving so i'm setting it already with a direction x and the reason these are optional again is so that when we create a new cube object we don't have to implicitly say direction x is one direction y is zero because it's assumed that it's always going to be like that unless otherwise stated okay let's have a look what else do we need to do here uh we need to now code this move function which is actually really easy um all i'm just gonna do is we're gonna say since we're changing the direction x in the direction y in our snake class we need to do that in here so that it stays with the object let's say during x equals during x and then the same thing self thought during y equals during y like that and then we'll go down here and all we're going to do is we're going to change our position so self.position is equal to self.pause 0 which is our already existing position plus self thought during x and they're saying self. pause one which is our already existing y value plus equals self dot during y like that and just in case i haven't mentioned it here right we're working with a grid system of 20 rows in this instant so when i say something like uh if our selfdeposition is like 1 3 or 10 10 i'm saying we're in the 10th row in the 10th column i'm not saying the x value is equal to 10 and the y value is equal to 10 because it's not in the case of drawing on the screen because our screen is actually a width of 500 pixels um but just where we are in the grid which is most important to us right now um is equal to like that values like one four or three five um so on like that just just to make that clear for anyone who might have been confused okay so now for drawing um it's a little bit harder just because of what i mentioned as well is the fact that we need to figure out the distance between each x value and each y value so when we're drawing something in pi game it draws in the top left hand corner of the object so if we draw a cube we're drawing that in the top left um so we need to figure out what that x and y value is going to be for each cube when we're drawing it to the screen so i'm just going to call this gap here that is going to be our distance and the same thing self.w by self.rows and we're going to change w and rows down in our program later but we can actually just type it in now like this so 500 and 200 just so we have that set okay so self.w answer divided by self.rows again that's the same thing we did when we were drawing the grid to figure out the distance between our x and y values okay we're going to say i is equal to self.pause zero that's going to save us a bit of typing in our function here or in our method i'm just going to say j.self.pause1 so we're just saying i which stands for row j stands for column um like a classic like convention for it so that we don't have to keep typing pause zero pause one when we move okay so the next one next thing we need to do is now draw a rectangle we're gonna say pygame.draw.correct like this and then we need a surface we need a color so self.color and then we need a rect and here is a little bit of math i'm just going to type it and i'll go through exactly what what it does j multiplied by this one this minus two this s2 okay so the reason i have these little plus ones and these minus twos here is just so you can still see the grid when we draw the rectangle um because if we were to draw with exactly the dimensions of this distance um then what would end up happening is we'd cover the white lines of the grid and it just looks kind of weird if you can't see the white lines um so that's why i have plus one added here and minus two just so we're drawn inside of the uh the circle or inside of the square a little bit and you'll see that in a second so what i'm simply doing is i'm multiplying my i value which is going to be my current like row column by the distance that we need to get to the next one and then same thing for j and then these little add ones minus twos is just to make sure that we stay inside so a quick quick example if you don't understand is say we're in a position zero zero so our i is zero and our j is zero we're going to say i multiplied by distance let's say distance is like 40. okay so zero multiplied by forty zero zero multiplied by forty 0. so our position is 0 0 and that's correct because if we're drawing in the top left hand corner here and we're in position 0 0 then that's where we should draw again if you go something like 0 10 and you or and you move down i guess so 10 you're moving wide down you're going to say 0 minus distance 0 and you're going to say 10 multiplied by distance let's say it's 40 then we move to that correct position down the screen so this is rectangle x y with height okay makes sense now the next thing we need to do is we need to draw the eyes now you can skip this part if you want i'm just going to copy it in because it's a little bit of math to make it them like perfectly aligned on the square um but yeah so we say if eyes and we're saying our center is equal to distance modulus 2 because that's going to be the center obviously or much so i'm saying divided by 2 is going to be the middle of our cube and we're saying the radius that's how big the i radius is going to be and then we go through a little bit of math here so circle middle is going to be high multiplied by distance plus center minus radius and then we're finding out the x and this is just like a random x that i'm setting by just putting it 8 pixels up like every time because i don't want to calculate the x i don't feel like doing that and then i'm drawing two circles based on circle middle one circle middle two and then the radius and a color of black or a color of white actually sir or no that's black i'm confused all right anyways with all that being said and done and you guys probably pretty confused right now let's just run and see if anything's actually happening and you can see we have a cube in the middle of the screen yay so that's all we've done with all this coding um so far it's drawn a cube so actually not quite because we still all we have to do now simply to start having that cube move and seeing our key presses work is just do a little bit in the main loop so let's move down to the main loop now and have a look here what we need to do okay so what i'm going to do is i'm simply just going to call s dot move which is our snake object every time this main loop runs and what this will allow us to do um is i want to call this before i read draw window is it's going to go up to that method in snake it's going to check every time that we run the loop if a key has been pressed if it has we're going to move accordingly and remember that in this move loop here it moves all of the objects for us so it moves all those cube objects and then we're just drawing the grid we're drawing everything in this redraw function so it'll just display that and update that to the screen so let's see here and we get an error tuple object is not callable self dot pause zero plus although they're next um all right one second guys oh it's because i've used okay so apparently i am an idiot and i forgot to add an equal sign here so the issue was simply that this looked something like this then i changed it to square brackets when all i needed to do was put an equal sign like this and now we should be up and we're working so to reiterate the line here that the issue is out you guys probably saw this when i coded it to be honest um is in move in cube it's near the top of the program all you have to do is change this add an equal sign between this like the bracket and the pause so now that we run it we can see that we have a moving object and that we can move up down left right etc so on and so forth like that okay so play around with that for a second and now we'll get into adding cubes and we're actually almost done we just need to add the add cube function message box a little bit in the main loop and then we'll be finished okay so what we're going to do now is that's all great we're moving around but we need to add stuff to our cube right like we need to progress the game so to do this we are going to generate what i want to call a random snack that we're going to place on the screen that our snake can't eat so the way that we do this i'm just going to say positions equals item dot body and this item oops shouldn't be items should be item it's just going to be a snake object i don't know why i'm calling it item but that's what i'm calling it um and we're simply just going to set like a new list equal to that list so on okay so now we're going to say while true capital t we're gonna do x equals random dot rand range if you haven't imported random yet make sure you do that and y equals random dot range range rows and rows again should be global so let's make sure that this works with global rows like that and then after this we're going to say if don't know how i just typed that but the length of and i'm doing something fancy here and i'll explain what this does in a second okay so i know i just typed uh this stuff that probably makes absolutely no sense you guys if you haven't been using python for a little bit but pretty much what this is going to do is we're going to get a list of a filtered uh list and we're going to see if any of the positions are the same as like the current position of the snake pretty well so what we're doing is we're saying that we want to make sure that we're not going to put a snack on top of the snake because if we have a really long snake the chance that happens actually somewhat high and i didn't do this when i first coded the game so what happened is when you have your snake moving around the screen all of a sudden the snack would pop up but it's like on the tail of the snake um which you don't want so what this is doing and just type it out you don't really have to understand it is we're saying this this means a function uh z and we're just checking if the z dot position uh is equal to uh x y so if it's equal to x y which is the position we just generated here by getting two random numbers so x and y um then we're going to have to do this again so we say continue and else we break like that and then i'm just simply going to return a tuple or a tubal whatever you want to call it x y okay so this is confusing but um you can do this in like a much longer way with a for loop where you pretty much loop through every position in this list you check it against x and y you see if it's the same if it's the same then do this loop again otherwise you break and you return x y that's all we're doing in there uh to generate a random snap any message box you're gonna leave that and in here now what we're gonna okay so now that i've created this uh this random snack function what i need to do is i need to use it so i'm just going to create a new object i'm going to call this snack and it's going to be equal to another cube right because we want to have the same functionality we want to be able to draw it possibly move it around right so we're just going to create a new cube object we're going to give it a position of a random snack which is going to be something like this random snack and then random snack i believe oh it takes a row in an item so what we're going to do is we're going to give it or rows and we'll just give it our item which is gonna be s um and then after that what else do we need for cube i don't think we actually need anything else i think that's all we need oh i'm gonna change the color that's what i wanna do i'm gonna change the color equal to green so red green blue 255 for green so that it shows up and is visible on screen and now what i'm going to do down here in this while loop is i'm going to say snack i'm going to check if our the head of our snake has hit the the snack and if it has we're gonna add another part to the body of the snake otherwise we're not gonna do that right and then we're gonna generate a new snack and so on so we're just gonna say if s dot body zero dot pause and this is going to be the head right because we have it ordered i don't need those brackets is equal to snap dot pause and remember these are both cube objects so this works fine because they're going to be tuples um then what we're going to do is we're simply going to say s dot add cube which is a method that we have there that we haven't actually written yet and we're going to say snack is now equal to well a new cube so i'm just going to copy this and paste it here um so all we're doing is now generating a new cube for snack i'm sure i could put something in that like changed it but this is just the way that works okay so now that we've done that we should be able to move around the screen and get the snack but we need to code in the add snack method here which i believe i have here or add cue so the ad cube is pretty straightforward we just have to figure out where we're adding that snack or wherever we're adding that cube i don't know why i keep calling it snack to the uh list so what we're going to do is we're going to figure out where the tail is and we want to add it after that tail so tail is equal to self dot body negative one the last element in that list i'm going to say dx dy which again is going to be our direction x direction why i'm just shorting it shorting it here it's going to be tail dot dern x and tail dot turn y like this now again you can do this in two lines i'm just doing it like this because it's faster and now i'm going to copy some again and we'll just go through exactly what this does okay so pretty much this looks complicated but all it's going to be doing is checking what direction that we're currently moving in like the head of the cube or the tail actually of the cube is moving in so that we can then make sure that when we add that um cube we know where to add it so for adding it like to the right of the cube to the left of the cube above it below it and we can give it the correct direction to be moving in so pretty much um what we do here is we just say we're going to append a new cube to our body and its position if we're moving to the right which in here we are because dx equals 1 is one less than the x position of that tail so whatever the last cube is one less than that and that's so that we don't add a cube per se to the right when we're moving to the right and then we're just gonna have overlapping cubes and you're not gonna see them right same thing down here if we're moving down that means or not down sorry for moving left that means we need to add the cube to the right side um so one plus that tail of the exposition of the tail of the cube or of the snake sorry so that we can um have it in the proper position right and the same thing here with x and y uh or with y so that when we're moving up or we're moving down then we add it above otherwise we move we put it below so i just stumbled through that um because there was a lot of different words they're very similar anyways what we need to do now is simply set the direction uh for that cube so now that we added it in if we just left it like that it wouldn't be moving anywhere so we just need to change that to the current direction of that tail so whatever the tail is moving that's where this new cube is going to be moving in that direction so we're just going to say self.body negative1.dern x equals dx and then same thing down here except we're going to change these to y during y equals d y and that again is just the uh where our tail is moving at that current moment okay so now that we've got all that done it's time to see what syntax air we get next name rows is parameter and global one second so i've actually never even ran into that error oh global rows as okay so let's just make this r and let's change this to be one second ah we can just get rid of this and this should work there we go so now we move around like this the only issue is our snack is not being generated on the screen and i don't know why that is exactly happening oh it's because we're not drawing the snack that's why so now i'm just going to global snack up here i believe that's what i called it and i'm simply just going to say snack dot draw like that and i gotta give it a surface so let's give it a surface let's run and error name snack is not defined it's because i didn't global it down here so let's go over that okay so now we have the snack it's on the screen and you can see that when we collect it we have that cube added to the end of our snake and that pretty much is almost the game done so all we need to do now is write that reset method and then we need to just simply check like when we lose like right now the snake can go through each other right through itself and you can see we have a huge error when the snake can go through itself so we need to make sure that when we hit ourselves um we like end the game and we need to write that message method as well so to do this um again i'm just going to copy in this for loop uh and then we'll kind of go go from there so let's move in here okay so for x and range the length of s dot body uh we're going to say s dot body x which is going to be we're just looping through every cube in our snake body we're checking if the position is in a list of um all the positions after that works um that's how we're checking the collision if you want to do it your own way um go ahead but this is the way that i like to do it okay so now what i'm going to do um is i just want to print to the console like their score uh just so that i know what it is let's say a score oops and then we'll just say plus is the length of s dot body but this is going to have to be converted to a string unless i put a comma like that so let's just do it like that and then i am going to simply display a message box will say message box like this message underscore box uh we have a subject and we have content and we'll we'll do that in just a second because i haven't yet um actually coded that and then we're going to reset our snake by just doing s dot reset and this is going to take a position which is going to be our starting position again 10 10. um and then we're going to break out of this for loop because if we collided once we don't really care if we collided again and go back and we continue the game with a snake that has length one now okay so our reset um this is pretty straightforward all i'm doing in this reset is i'm just gonna get rid of our turns i'm gonna get rid of our body um and i'm just going to change like the direction x and the direction y so maybe it's faster if i just copy it and you guys can just copy this out so pretty much all i'm doing is i'm setting a new head um which is going to be equal to again like whatever position we give in because we can move it at a different position if we wanted to i'm clearing self.body which is in the class variable here and then i'm adding head i'm setting turns equal to blank direction x is zero direction y is set to one again so we start moving and you can see it's pretty much exactly what i have typed out here except i'm just resetting the turns list okay so now that we've done that all we need to code is message box so this one's pretty easy um you can see up here just in case you haven't looked yet um i import tkinter stk and then from decanter i import message box now this is how you create a message box in a pie game and this is how you create one that actually shows up on top of the screen um and that doesn't like float kind of below it or it doesn't show up right away if you want to say that um so just watch this is extremely useful to use in other programs too if you if you copy out this uh function and then you just drag it into other ones so attributes topmost comma true what this simply does is we're creating a root oops which is not root.tk it's root equal to tk.tk which is going to be a new tkinter window we're making sure that this window is going to be on top of anything so if we have like a bunch of different windows open it just comes up on top which is what we want i'm just going to simply make this window now invisible and i'll explain how this works in a second and then from this message box um what do you call it method class whatever it's going to say message box dot show info and then we're going to do subject and content and this just takes it takes a few more parameters as well if you want but pretty much just just shows info given whatever subject we type in and whatever content we have and now i'm going to say try root dot destroy like that accept oops uh pass and don't ask me what this does because honestly i don't know but it just works so pretty much it shows this message box and i'm actually pretty sure the way that this works is it constantly keeps trying to destroy the message box until eventually you click the x button and then it actually can i think it's like something like that so anyways that's how you create a message box and with that we all need to do is add a subject and content so i'm going to say you lost and our message will be play again let's run the program for the last time and make sure everything is working so there we go i just need to get my snake to a length that is uh large enough to the point where i can actually hit myself oh okay and there we go so pretty much we ran into an error what is the air i spelt attributes wrong that is lovely air to run into let's run back up here attributes attributes attributes where did i even make this function i must have scrolled path it all right there we go and i believe that's correct let's try this now so i'm actually just going to go and see if i can there we go okay so we get a message says you lost play again and the reason i died there by the way is because while i was moving right i moved left so technically um the head of my snake actually ran into another part of it so it says you lost play again um and you can make that say exactly what you want and then we can see that our guy just continues to move so on so anyways if you guys want to see more content like this go check out my channel it is named tech with tim and i do have a bunch of videos teaching stuff like pie game and doing a bunch of python tutorials you guys will definitely learn a lot following through some of my videos and i would be very grateful if you guys went over there and liked some of my videos and subscribed
