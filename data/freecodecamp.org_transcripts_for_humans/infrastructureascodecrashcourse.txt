With timestamps:

00:00 - in this course you will learn all about
00:01 - infrastructurist code i'll start by
00:03 - giving you a general overview of the
00:05 - different concepts and then i'll show
00:07 - you how to implement infrastructure as
00:09 - code with three different labs
00:12 - this course will use python and aws but
00:14 - the concepts will apply to other
00:16 - languages and cloud providers
00:18 - so let's start by talking about what
00:20 - infrastructure as code is to put it
00:22 - simply it's setting up your
00:24 - infrastructure as code by infrastructure
00:27 - i mean all the different things needed
00:29 - to deploy your software into a cloud
00:32 - environment
00:33 - that can mean things like virtual
00:34 - machines containers or serverless
00:37 - functions
00:38 - infrastructure also means all the other
00:41 - pieces of infrastructure you need to set
00:43 - up to make that successful
00:44 - that can be security like aim and kms
00:48 - or networking or some of the monitoring
00:51 - and logging capabilities
00:54 - you can also use code to configure and
00:56 - set up data stores
00:58 - these are the things that your
00:59 - application needs to store and manage
01:02 - data the last piece of infrastructure
01:04 - landscape is the applications themselves
01:07 - and getting the applications that we're
01:09 - building into the infrastructure
01:11 - all of these different pieces of
01:13 - infrastructure can be set up using code
01:16 - software as a service or sas
01:19 - is related to infrastructure's code
01:22 - software as a service allows users to
01:24 - connect to and use cloud-based apps over
01:27 - the internet
01:28 - sas provides a complete software
01:30 - solution that you purchase on a
01:32 - pay-as-you-go basis from a cloud service
01:34 - provider
01:35 - you rent the use of an app or software
01:37 - for yourself or for your organization
01:40 - from a cloud service provider and
01:42 - connect to it over the internet common
01:44 - examples are email office tools crms and
01:47 - development tools
01:49 - infrastructure as a service is part of
01:51 - software as a service infrastructure as
01:54 - a service is a cloud computing service
01:56 - where companies rent servers for compute
01:59 - and storage in the cloud this allows
02:01 - users to run operating systems or
02:03 - applications on the servers without the
02:06 - maintenance and operating costs of those
02:08 - servers
02:09 - so infrastructure as code involves using
02:12 - code to manage your infrastructure as a
02:15 - service
02:16 - it's becoming more and more important to
02:18 - automate infrastructure because
02:20 - applications can be deployed to
02:21 - production
02:22 - up to 100 times per day and you don't
02:24 - want to be doing that all manually
02:27 - it's also helpful for infrastructure to
02:29 - be provisioned or d provisioned in
02:31 - response to load we need to answer
02:33 - questions such as how do we get the
02:35 - images for our vms
02:37 - how do we get the container images in
02:39 - how do we package up and ship code into
02:41 - serverless functions
02:43 - over the years there has been a
02:45 - transition with how people are using
02:46 - cloud infrastructure within their
02:48 - organization
02:49 - in the first wave it was fairly simple
02:52 - the infrastructure were fairly static it
02:54 - was often single virtual machines that
02:56 - you just accessed through ssh
02:58 - it got a little more complex in the
03:00 - second wave
03:01 - there were more containers and people
03:03 - started using provisioning tools to
03:05 - specify the application behaviors people
03:08 - use things like docker and datadog
03:10 - modern cloud infrastructure has added
03:13 - way more complexity it uses containers
03:16 - serverless and more managed services as
03:19 - part of the applications
03:21 - there are now way more different pieces
03:24 - involved in how people build the
03:25 - infrastructure
03:27 - infrastructure as code is becoming a
03:29 - more important part of how people build
03:32 - and deliver applications because
03:34 - infrastructure as code is what describes
03:36 - the glue between all the different edges
03:39 - on these diagrams this diagram for the
03:42 - modern infrastructure may look more
03:44 - complicated than the previous ones but
03:46 - it can actually be easier to maintain
03:49 - a key benefit is that the dark gray
03:52 - squares in the diagram are the only part
03:54 - which is the code you own
03:57 - and that part is smaller than the
03:58 - previous ways of doing things
04:01 - so a lot of the operational burden has
04:04 - been decreased compared to how it used
04:06 - to be done
04:07 - with infrastructure as code it is now
04:10 - easier to build deploy and manage
04:13 - infrastructure in a repeatable and
04:15 - scalable way on a variety of cloud
04:17 - service providers
04:18 - infrastructure as code makes it easier
04:20 - to manage that process alongside your
04:23 - actual application code now there is a
04:25 - greater focus on the glue between the
04:28 - different services that are being
04:30 - managed by a cloud provider and these
04:32 - services can be deployed in a repeatable
04:35 - and scalable way infrastructure code
04:37 - takes on an increasingly more important
04:40 - role in how you manage everything in the
04:42 - modern cloud
04:44 - so here are the three main ways that can
04:46 - be used to manage all the resources
04:49 - manual
04:50 - that's how it used to always be done you
04:52 - just point and click to create or modify
04:54 - resources in the console you can do it
04:56 - like through the aws console you can
04:58 - just point and click to what things you
04:59 - want to create
05:01 - then there's ad hoc automation
05:03 - this is when you use cli commands or
05:05 - scripts to create and modify resources
05:09 - so you're kind of using some code but
05:11 - it's not going to be able to be reused
05:14 - over and over and modified very easily
05:18 - the third way is what we're talking
05:19 - about infrastructure as code there's
05:22 - provisioning which is declaratively
05:24 - creating and modifying resources
05:27 - and configuration which means to change
05:30 - the state of an existing resource post
05:32 - provisioning infrastructure as code
05:35 - gives us the ability to write down what
05:37 - we want the desired state of our
05:38 - infrastructure to be i'll be showing you
05:40 - how to do some of these things later
05:42 - there are a few different ways to write
05:44 - infrastructures code so one approach is
05:46 - to use json
05:48 - here's an example
05:50 - you can see this is a way to tell aws
05:54 - what resources you want to have
05:56 - you can see the resources the ec2
05:58 - instance
06:00 - the instant security group and just
06:01 - everything you're going to need just in
06:03 - a json format
06:05 - another method is to use domain specific
06:08 - language or dsl
06:10 - this is a custom method specific to the
06:12 - tool or cloud provider you are using so
06:16 - here's an example
06:17 - you can see it does kind of look like
06:19 - code but it's no no it's not like a
06:22 - popular programming language or even the
06:25 - exact way that json usually is written
06:28 - yet another way of defining
06:29 - infrastructure using code is to use a
06:31 - well-known programming language for
06:34 - instance polumi can be used to write
06:36 - infrastructure as code using typescript
06:38 - javascript python go and net
06:42 - here's an example using typescript
06:45 - and later we'll be using python
06:48 - using code gives the ability to do
06:50 - things that are not possible in some of
06:52 - the other methods
06:54 - in this example there's a for loop that
06:56 - creates an instance for each
06:58 - availability zone
06:59 - code gives the ability to use loops
07:02 - conditionals classes packages and more
07:06 - using popular programming languages also
07:08 - allows the use of common ides linters
07:11 - and test frameworks
07:13 - so let's get into some real world
07:16 - examples
07:17 - we're about to set up some actual
07:18 - infrastructure as code there are a few
07:21 - different services that allow you to use
07:22 - popular languages to create
07:24 - infrastructure as code in this course
07:27 - we'll be using pollumi
07:28 - this course was made possible through a
07:30 - grant from blooming
07:32 - pollumi is an open source infrastructure
07:34 - as code tool for creating deploying and
07:37 - managing cloud infrastructure
07:40 - pollumi works with traditional
07:41 - infrastructure like vms networks and
07:44 - databases in addition to modern
07:47 - architectures including containers
07:49 - kubernetes clusters and serverless
07:51 - functions
07:52 - plumi supports dozens of cloud service
07:55 - providers
07:56 - we'll be using python and deploying on
07:59 - aws
08:00 - though it can be done with other
08:01 - programming languages and cloud
08:03 - providers we'll start with a simple
08:05 - example
08:06 - this will show an end-to-end experience
08:08 - of working with plumi using very simple
08:10 - resources
08:11 - in this first example we'll do the
08:13 - following
08:14 - create a new project configure aws
08:17 - provision infrastructure update
08:18 - infrastructure make your stack
08:20 - configurable create a second stack and
08:23 - destroy the infrastructure we'll use an
08:26 - s3 bucket and then work through the life
08:28 - cycle with a simple set of resources
08:31 - then in future examples you will learn
08:33 - how to implement more complex things
08:36 - with pollumi infrastructure is organized
08:38 - into projects each project is a single
08:40 - program that when run declares the
08:43 - desired infrastructure for pollumi to
08:45 - manage
08:46 - before we start the first lab make sure
08:48 - you have polomi installed
08:50 - the way to install is different
08:51 - depending on your operating system you
08:53 - can check the link in the description
08:55 - for all the instructions for how to
08:57 - install different operating systems
08:59 - one way if you have home brew is just
09:01 - brew install
09:04 - pollumi
09:06 - like i mentioned we'll also be using aws
09:09 - you have to make sure you have an aws
09:10 - account and have the cli set up and
09:13 - authenticated i have a link in the
09:15 - description that shows you how to sign
09:16 - up for a free aws account
09:19 - also there's another link that shows how
09:20 - to install the aws cli for your
09:23 - operating system
09:24 - from aws you're going to need an access
09:26 - key id and a secret access key let me
09:29 - show you how to get that
09:31 - i'm at this url right here
09:35 - um you can do without the v2 at the end
09:37 - just the console.aws.amazon.com
09:40 - iam
09:42 - and then i'm going to go to users here
09:45 - and then i'm going to add a user i'm
09:47 - going to make a new user just for this
09:48 - project
09:50 - and the user is just going to be
09:52 - infrastructure as code or iac
09:56 - and i'm going to click that i want to
09:58 - get the access key here
10:00 - and next permissions
10:02 - i'll just add administrator access so to
10:04 - make sure it can do whatever needs to do
10:08 - and then i'll just go through just keep
10:09 - clicking clicking next and then create
10:11 - user
10:13 - okay now we have the amazon access key
10:16 - and the secret access key
10:18 - so you're going to actually have to copy
10:20 - the access key and the secret access key
10:22 - from this page and you can get that
10:24 - obviously by clicking show to show the
10:26 - secret access key let me show you where
10:28 - you're going to need those things
10:30 - go over to your command line and type in
10:32 - aws configure
10:37 - okay now this is where you're going to
10:39 - enter your access key
10:44 - i'm just going to copy it from here
10:49 - and then the aws the aws secret access
10:52 - key
10:55 - now yours probably won't have this here
10:57 - because i've already done that so it's
10:59 - seeing if i want to use what i already
11:00 - have but i want to put in a brand new
11:02 - one here
11:04 - and then we can just click none for the
11:06 - next few things here
11:09 - okay aws is set up
11:14 - so the first step to starting a pollumi
11:16 - project is to create a new directory
11:20 - each pollumi project lives in its own
11:22 - directory so i'm going to create one
11:24 - first i'm going to go into projects
11:26 - okay i'm gonna make a directory
11:28 - and i'm just gonna call it iac
11:30 - lab
11:32 - one
11:33 - now just jump into my directory i just
11:34 - created
11:36 - okay i'll do paloomi
11:38 - new python because we're making a python
11:40 - project and we'll just select yes to
11:42 - everything
11:44 - now i've already used pollumi on this
11:45 - computer but if this is the first time
11:47 - you've used pollumi you will be directed
11:49 - to enter an access code or log in and it
11:53 - will tell you the website to go to get
11:55 - to get the access code but it's
11:57 - app.paloomy.com
11:59 - account slash tokens you will have to
12:02 - create a plumi account and then you will
12:04 - be able to get your access code
12:06 - so this command has created all the
12:08 - files we need it's initialized a new
12:10 - stack named dev which is an instance of
12:12 - our project we now need to install our
12:15 - dependencies as part of our virtual
12:18 - environment
12:19 - so let's set up our virtual environment
12:21 - we're going to create a virtual
12:22 - environment and install the required
12:23 - python packages the python module used
12:26 - to create and manage virtual
12:28 - environments is called v e and v so
12:31 - let's use these commands first we'll do
12:33 - python
12:34 - 3
12:35 - m v e and v v e n v
12:41 - and then source v e and v slash been
12:44 - slash activate
12:47 - okay i've activated my virtual
12:49 - environment and now i'm going to install
12:51 - the requirements pip 3 install
12:55 - requirements
12:57 - dot txt
12:59 - that requirements.txt file was created
13:02 - when we initialized our polumi project
13:06 - now let's open this up i'm going to open
13:08 - up in visual studio code but you can use
13:10 - any code editor you want
13:12 - okay these are all the files that got
13:15 - installed when we did their pluminew
13:18 - this main.pie is the program's main
13:20 - entry point file this is the file that
13:22 - we'll be putting all of our code in now
13:25 - we have the requirements.txt
13:27 - that's just your project's pip
13:29 - dependency information
13:31 - and then we have pollumi.yaml
13:33 - which is the project's metadata
13:35 - containing its name and language you can
13:37 - see we have python and then we have the
13:40 - name here and the virtual environment
13:43 - so if we go back into the main.pi we'll
13:45 - notice that we just have one line of
13:47 - code that's just automatically put in
13:49 - there which is import gloomy now there
13:53 - could be more or less code in here
13:54 - depending on
13:56 - which way we run the plumi new command
13:59 - but we just wrote ran it with plummy new
14:01 - python so it just started with import
14:04 - polymer which is the line of python so
14:06 - now that we have the basic project let's
14:09 - configure aws support for it
14:12 - i'm actually going to open the terminal
14:14 - right from within vs code okay i'm going
14:17 - to install something so pip 3 install
14:20 - pollumi
14:21 - aws
14:25 - now i'm going to
14:26 - make our code
14:28 - take up more of the room here and i'm
14:30 - going to add another line so import i'll
14:32 - import we just installed so import
14:36 - pollumi
14:38 - and actually recommend it right here
14:41 - as aws
14:45 - okay now we're going to configure an aws
14:48 - region which is whatever region you want
14:50 - to deploy to
14:51 - by we're going to run something in the
14:52 - command line so i'll go back down to the
14:54 - command line and i'm going to do pollumi
14:57 - config
14:58 - set
14:59 - aws
15:01 - region
15:02 - and you can use any aws region that you
15:06 - like but in my case i'm going to use us
15:08 - east
15:10 - one okay now we're actually going to
15:13 - start doing some infrastructure as code
15:15 - we're going to provision infrastructure
15:18 - so now that we have a project configured
15:20 - to use adws we'll create some basic
15:22 - infrastructure we'll start with a simple
15:24 - s3 bucket so let's declare a new bucket
15:28 - right up in our python file here i'm
15:31 - going to say bucket
15:33 - equals a
15:35 - aws.s3 dot well s3 dot bucket
15:42 - bucket
15:44 - and then you can call anything you want
15:47 - but i'm going to call it
15:49 - my
15:50 - bucket
15:53 - okay i'm going to save this and we're
15:55 - going to preview the changes so i'm just
15:57 - going to go back to my terminal down
15:59 - here and type in pollu me
16:02 - up
16:03 - so pluto me up is the command you'll be
16:05 - running a lot with palumi which is going
16:07 - to basically run our main.pi file and
16:11 - set up our infrastructure how we
16:13 - configured it so it looks like there's
16:14 - an error here so let's see what that is
16:18 - hmm looks like there was a mistake with
16:21 - my aws login let me just try doing the
16:24 - login again and see if that fixes the
16:25 - problem
16:29 - aws configure
16:32 - now i'm going to get my access key
16:34 - now try running pollumi up again
16:39 - okay work this time
16:40 - so let me
16:42 - bring up this we can see more of what
16:44 - the output was here
16:46 - so this is a preview the command
16:48 - evaluates your program determines the
16:51 - resource updates to make and shows us an
16:54 - outline of these changes so this is
16:56 - what's going to happen we're going to
16:58 - create this stack and we're going to
17:00 - create this bucket here and it hasn't
17:02 - done anything yet we can decide what we
17:05 - want to do for now i'm going to go to
17:06 - details to see more details
17:09 - so you can see now we can see that the
17:10 - acl
17:12 - is private you can see the actual bucket
17:14 - name we call that my bucket but plume is
17:17 - going to add this at the end so we can
17:20 - actually create a bunch of buckets with
17:22 - the same name but it's just going to
17:23 - have a different thing at the end here
17:25 - and you can just see some extra details
17:27 - about this and i do want to perform this
17:29 - update so i'll just go to yes and okay
17:31 - return
17:35 - so now our s3 bucket has been created in
17:38 - our aws account so if we view our
17:41 - buckets on the aws website you'll see
17:43 - the new bucket so i'm going to go to aws
17:45 - and then go to the s3 section
17:49 - and it's going to show this bucket we
17:50 - just created
17:53 - so it's currently empty but we can see
17:56 - the bucket that we just created with
17:57 - pallumi
17:59 - and there's also this url here
18:02 - if we go to this url i'll let's do uh
18:06 - i'll just do command click
18:11 - and i'm going to have to log into plumi
18:14 - to get this to work out
18:17 - so now we're on the plumi console which
18:20 - records your deployment history so right
18:23 - now we've just done one one thing so you
18:26 - can see one thing on here
18:28 - okay next i'm going to show you how to
18:30 - export your new bucket name so
18:33 - we're going to go back into the code
18:35 - area
18:36 - and to inspect your new bucket you'll
18:38 - need its physical aws name well we did
18:42 - see we were able to see the name
18:45 - up here when we went to more details
18:48 - but there's another way to get the name
18:50 - that i will show you using the code
18:54 - so
18:55 - this
18:56 - is called
18:57 - the logical name my bucket but like i
19:00 - said before the aws name will be a
19:02 - little different
19:04 - programs can export variables which will
19:06 - be shown in the cli and recorded for
19:08 - each deployment so let me show you how
19:10 - to export the bucket's name by adding a
19:12 - line of code in here so right after we
19:15 - get the bucket here i'm going to do
19:17 - pollumi.export
19:21 - x
19:22 - export
19:24 - and then i'm going to export the bucket
19:28 - name
19:30 - so that's just what we're calling this
19:31 - value which we're going to get as
19:33 - bucket.bucket
19:35 - so this bucket.bucket will be the bucket
19:38 - name so let me just save this
19:41 - and then we'll go back into the terminal
19:44 - and i'll do pollumi
19:46 - up
19:49 - and now we can see
19:51 - there's a new line here outputs
19:54 - so
19:55 - you can in your python code you can
19:58 - export certain information that will
20:00 - show up in the output section when you
20:02 - do blue me up
20:05 - so i'll just select yes to perform the
20:08 - update
20:10 - and you can see it's unchanged because
20:12 - the only update was just to output the
20:14 - bucket name here
20:15 - you can see all the output
20:18 - by running this command in the terminal
20:20 - pollumi
20:22 - stack output
20:26 - you can see it's there's only one output
20:28 - the bucket name and then it has the
20:29 - value of it right here
20:31 - now we can run the aws cli to list the
20:35 - objects in this new bucket
20:37 - and we can get the bucket name using the
20:39 - command from above let me show you how
20:41 - you do that so we're going to do aws
20:45 - s3
20:46 - ls and then
20:49 - i'm going to run that command right in
20:51 - here pollumi stack output
20:55 - bucket
20:57 - name so that's going to get the bucket
20:58 - name
20:59 - and if we run that command
21:02 - nothing's going to really happen because
21:04 - there's nothing in the bucket so it's
21:07 - returning what's in the bucket but
21:08 - there's nothing in the bucket so there's
21:09 - nothing to be returned
21:11 - but we'll change that shortly
21:13 - we're going to now update the
21:15 - infrastructure we just saw how to create
21:17 - new infrastructure from scratch so now
21:19 - we're going to make a few updates we're
21:22 - going to add an object to the bucket
21:24 - we're going to serve content from the
21:25 - bucket as a website and we're going to
21:28 - pragmatically create infrastructure
21:31 - this will demonstrate how declarative
21:32 - infrastructure as code tools can be used
21:34 - not just for initial provisioning but
21:36 - also subsequent changes to existing
21:38 - resources so we're going to add an
21:40 - object to the bucket i am going to
21:43 - create a new directory i'm going to just
21:45 - go to new folder i could click this
21:48 - button up here this folder is going to
21:49 - be called
21:51 - site and then i'm going to make a new
21:53 - file and this will be called index.html
21:57 - okay i'm just going to make an extremely
21:59 - simple website here html
22:03 - and
22:04 - body
22:10 - and then just an h1 tag and it's going
22:13 - to say
22:14 - hello
22:15 - everybody
22:20 - okay now let me
22:23 - rearrange things here we'll go back to
22:25 - our main.pi
22:27 - and let's add some lines of code so we
22:30 - can add that file
22:32 - to our bucket
22:34 - so i'm going to add import
22:38 - and put a new library the os library so
22:40 - we can access
22:41 - uh stuff from our operating system the
22:43 - file path in particular
22:45 - so
22:48 - let's see actually we'll put it right
22:49 - here
22:52 - file path equals os dot path dot join
22:58 - and then we'll put the directory name
23:00 - site
23:02 - and then the file name index.html
23:08 - now we're going to create an object
23:11 - variable
23:12 - and we'll do aws.s3
23:15 - dot bucket object
23:21 - index.html
23:24 - so the object is index.html
23:29 - and then
23:31 - the bucket
23:32 - is going to be
23:35 - dot bucket
23:36 - and that's how you get the name of the
23:38 - bucket that we created
23:40 - and for source
23:45 - i'll put polumi
23:49 - file
23:51 - asset
23:54 - file
23:55 - path
23:58 - so this is how you use
24:00 - polumi to get this asset this file path
24:03 - right here we're going to create as the
24:06 - object that goes into our bucket
24:10 - so i'm going to save that and enter
24:12 - terminal we'll do plumi up
24:16 - and then i'll just
24:18 - look at this
24:19 - more
24:22 - oh
24:23 - not fire asset file
24:26 - asset because this is a file asset
24:29 - so i'll go to plume up
24:36 - see that makes a lot more sense to you
24:37 - doesn't it than fire asset okay so you
24:40 - can see it's showing what the change is
24:42 - going to be we're going to create this
24:44 - object which is the index.html we're
24:47 - going to create that
24:51 - so i will go to yes to
24:54 - do these changes perform this update
24:58 - so a single resource is added and the
25:01 - two existing resources are left
25:03 - unchanged this is a key attribute of
25:06 - infrastructure as code such tools
25:08 - determine the minimal set of changes
25:10 - necessary to update your infrastructure
25:13 - from one change to the next
25:15 - so
25:16 - let's list again the contents the
25:18 - contents of the bucket i'll just press
25:20 - up a few times we'll use the same line
25:22 - from before
25:23 - and now let's see what's in the bucket
25:27 - it's showing index.html and if i go back
25:29 - over to my web browser
25:32 - and if i refresh
25:34 - my page that shows the bucket on aws
25:38 - we should see yep we see this index.html
25:41 - right here next step we're going to
25:42 - serve content from the bucket as a
25:45 - website
25:46 - to do that we'll need to update a few
25:49 - properties
25:50 - first the bucket needs a website
25:52 - property that sets the default index
25:54 - document the index.html
25:57 - that can
25:58 - that can be achieved by making a few
26:00 - changes to our python file
26:04 - we have our bucket right here
26:07 - and
26:08 - i'm going to after the buck and nam and
26:10 - add a comma
26:14 - and then i'm going to put
26:15 - website
26:17 - equals
26:21 - and then we just have to set the index
26:22 - document
26:25 - and we'll just set that to
26:27 - index.html
26:30 - and make sure that's in a string here
26:38 - okay next
26:39 - the index.html object will need two
26:41 - changes
26:45 - so let's go
26:47 - down here to see this index.html object
26:49 - that's right here
26:51 - we're going to need an acl which is an
26:53 - access control list of public read
26:57 - so right after the source
27:00 - i'll put
27:03 - acl
27:04 - equals
27:07 - public
27:09 - read
27:14 - there now you can see that better
27:16 - this makes it so it can be accessed
27:17 - anonymously over the internet
27:20 - we also need a content type so it's
27:23 - served as html
27:26 - so
27:27 - for the content type to work
27:29 - let's go back up to the top
27:31 - we're going to import something import
27:34 - mime types because we're going to set
27:36 - the mime type
27:38 - and then down here after the file path
27:41 - we're going to get the mime type of the
27:43 - file so mime
27:46 - type
27:48 - and what
27:50 - we'll put it underscore because this is
27:51 - going to return two things but we only
27:53 - need one of the things which is the mime
27:55 - type so we'll do mime types
27:58 - dot guess
28:01 - type
28:02 - and we'll guess the type of the file
28:05 - path
28:07 - and now down here we can set the content
28:12 - type
28:14 - to
28:14 - the mime type
28:16 - so now we have the content type so it's
28:18 - served as html
28:20 - we'll also need to export the resulting
28:22 - buckets endpoint url so we can easily
28:24 - access it so let me show you how you
28:26 - would do that
28:28 - so here we're exporting the bucket name
28:31 - and now let's export the bucket endpoint
28:34 - the full url so we'll do pollumi
28:38 - dot export
28:40 - and this will be called the bucket
28:42 - endpoint
28:45 - we're going to use this concat function
28:49 - from polumi to concat a string and
28:52 - something else so this bucket.bucket
28:55 - it's actually an object it's not a
28:58 - string but it does return a string so if
29:00 - we want to combine something like this
29:02 - with a string we have to use uh concat
29:04 - let me show you how that's done we're
29:06 - going to do pollumi dot output dot
29:09 - concat
29:11 - and then i'm going to put the two things
29:13 - we're going to concat the first thing is
29:14 - going to be a string https came and see
29:17 - what i'm writing here let's see if i can
29:19 - http
29:21 - let's do http
29:23 - colon slash slash
29:25 - and then we'll get a comma here
29:28 - and
29:29 - then just bucket dot web site
29:33 - endpoint
29:36 - so we're just concatenate we're
29:38 - concatenating the http and this website
29:41 - endpoint
29:43 - okay let's deploy the changes so well
29:45 - let me save it and then we'll do pollumi
29:50 - up
29:56 - if i go up here
29:59 - we can see it's making some updates and
30:01 - i'll go to yes
30:06 - okay now we have this
30:08 - url here so we can use this to access
30:11 - that index.html file so i can actually
30:14 - just copy this url stored on amazon aws
30:18 - and now i can open up the url right in
30:21 - my web browser it says hello everybody
30:25 - i can also use curl to get it so back in
30:28 - my terminal do curl
30:30 - and
30:31 - now i am going to run a command right
30:34 - here to get the website url
30:41 - lumi stack output and then you can get
30:44 - any of the things that get output and
30:46 - we'll get bucket
30:48 - endpoint
30:53 - okay see we got this
30:55 - here's the text of our html file
30:58 - next we are going to make the stack
31:00 - configurable
31:02 - right now the bucket's contents are hard
31:04 - coded
31:05 - we're going to make the location of the
31:07 - contents configurable and add support
31:09 - for populating the bucket with an entire
31:11 - directory's worth of contents
31:13 - so the next step is to add a config
31:16 - variable
31:17 - right now
31:18 - we hard code the directory of the site
31:21 - let me show you here so we have we're
31:24 - hard coding
31:25 - this directory here
31:27 - of the site so we're going to configure
31:30 - it to make it easy to change the
31:31 - location without editing the program
31:34 - so right below the imports here i'm
31:37 - gonna do config
31:40 - equals pollumi dot config
31:44 - that's going to make it possible to
31:46 - access some
31:48 - config settings that we set up
31:50 - and we're going to specifically access
31:53 - the site
31:56 - directory
31:57 - and we're going to get it from
31:58 - config dot
32:01 - require
32:03 - and then we're going to get the site
32:06 - dir and i remembered i see that i
32:08 - spelled paloomi wrong
32:11 - there we go
32:12 - and we are going to set this in a minute
32:14 - the site directory but first let's
32:16 - update our program to use this citer
32:18 - variable so instead of getting the site
32:22 - here i'm just going to paste in the
32:24 - variable name okay so now what we're
32:26 - going to do i'm going to save this and
32:29 - then i'm going to go back into my files
32:30 - i'm going to rename this site directory
32:34 - i'm going to rename it
32:36 - www now you may not actually do this in
32:39 - like a real life situation but we're
32:41 - just doing this as an example to see how
32:43 - this can be helpful
32:45 - so let me go into my terminal
32:47 - and i'm gonna do pollumi
32:49 - up
32:52 - okay it's saying air missing required
32:54 - configuration variable this site dur
32:57 - variable and it says please set a value
33:00 - using the command plume config set ic
33:03 - lab 1 site directory with the value so
33:05 - that's what we're going to do now i'm
33:06 - just going to copy this command here
33:09 - and then i'm just going to paste it in
33:11 - and then i'm going to set it to www so
33:13 - now the directory you'll be looking for
33:15 - is the www directory instead of the site
33:17 - directory
33:20 - okay i'll just do plume up again
33:27 - and i will perform the update
33:32 - okay that works so now we don't have to
33:35 - have the the directory hard hard-coded
33:37 - in here we can use these config
33:39 - variables and you can see how you'll be
33:41 - able to use that with other types of
33:42 - data as well okay now we're going to add
33:45 - more files instead of hard coding the
33:47 - set of files
33:49 - which we do now let me show you what i
33:50 - mean right now we hard code that we're
33:54 - adding the index.html file
33:57 - to our bucket but instead of doing that
34:00 - we're going to change the program to
34:02 - read the entire contents of the www
34:05 - directory and add every file from that
34:08 - directory to our bucket so let's start
34:10 - by adding a new file to that directory
34:13 - so i'm going to go into the directory
34:14 - and click the new file button and this
34:17 - is going to be called about.html and
34:19 - this is just going to be a simple thing
34:21 - you can make it anything you want i'm
34:23 - just going to make an extremely simple
34:25 - file with a paragraph it will say it's
34:29 - about so i want to say something about
34:30 - me and i am not a cat so that's
34:33 - something about me
34:35 - okay let's go back to the main.pi file
34:38 - and we're going to replace the object
34:41 - allocation code
34:43 - and now we are going to update the
34:45 - object
34:46 - allocation code so this right here we're
34:50 - going to put all of this into a for loop
34:54 - so i'm going to say for file in os dot
34:57 - list
34:58 - directory
34:59 - site
35:02 - directory
35:04 - and then i'm gonna just indent all this
35:07 - so it's all in that directory
35:10 - and see we have the the file here so now
35:13 - instead of index.html
35:15 - i'm going to put this variable file
35:19 - so now we are using this for loop to go
35:23 - through
35:24 - every file and adding all those files to
35:27 - our bucket now this is one of the really
35:30 - cool things about infrastructure as code
35:32 - and using an actual programming language
35:34 - like python is that you can use for
35:36 - loops and that can make things go a lot
35:39 - that can make things a lot simpler and
35:42 - save a lot of time like we didn't have
35:44 - to use a for loop we could have just
35:46 - copied and pasted this code a bunch of
35:48 - times and and then added each file
35:51 - individually in insta instead of using
35:54 - this for loop but this is going to save
35:56 - us a lot of time especially if we have
35:58 - tons of files that we want to put into
36:00 - our bucket
36:02 - so let's go back to the terminal i'll do
36:04 - actually have to save first here and
36:06 - then i'll do pollumi up
36:11 - so you can see what's going to do it's
36:12 - going to create
36:14 - this file this is about.html
36:16 - and let's do that i'll go to yes
36:20 - now i'm back in my web browser i'm going
36:22 - to put a slash about
36:26 - dot html at the end
36:29 - and now we can see
36:30 - i'm not a cat i can zoom in on that so
36:32 - you can see a little better it's just a
36:34 - paragraph tag so it's pretty small
36:36 - we can also access it through curl the
36:39 - same ways before
36:40 - let me just press up in here but i'll
36:42 - just put slash
36:44 - about.html at the end
36:47 - and then yep here it is here's the
36:49 - about.html file we created
36:52 - now we're going to create a second stack
36:55 - it's easy to create multiple instances
36:56 - of the same project in pollumi each
36:59 - instance is called a stack
37:01 - this is useful if you have multiple
37:03 - development or test environments like
37:05 - staging versus production or if you want
37:08 - to scale a given infrastructure across
37:10 - many regions
37:12 - so let me show you how to create and
37:14 - configure a new stack we'll create a
37:16 - stack named prod so i'm
37:19 - still in the terminal down here i'll do
37:21 - pollumi stack and knit
37:24 - prod
37:27 - and i just created it now next i'll
37:29 - configure the two required variables
37:32 - the same ones we did before so we'll do
37:34 - paloomy
37:38 - config set
37:41 - this is going to be the region aws
37:43 - region
37:44 - and we're going to do it different from
37:45 - before this time it's going to be eu
37:47 - west
37:48 - one you can basically set this to any
37:50 - aws region
37:52 - we'll also set
37:54 - the the site directory
37:56 - paloomi config
37:59 - set
38:01 - iec
38:03 - lab
38:04 - one
38:06 - site
38:08 - directory
38:10 - and instead of the www this is gonna be
38:12 - www.prod
38:14 - i'm just showing where you can have
38:15 - different site directories for different
38:18 - projects for different stacks
38:21 - so let's see the list of stacks we have
38:24 - paloomi
38:26 - stack
38:28 - ls
38:31 - we have the dev stack
38:32 - and we have
38:34 - the prod or production stack
38:36 - now let's populate the new site
38:37 - directory we could have used the
38:39 - existing www directory for the site
38:42 - directory but for this example we'll use
38:44 - the the www prod directory to
38:47 - demonstrate how it can be configured
38:49 - we will make a directory
38:52 - wwe prod
38:55 - and then i'm just going to create a file
38:56 - right from here we could have created
38:57 - the directory from here so where's our
38:59 - new directory
39:02 - right here i'll just create a new file
39:05 - and it's just going to be another
39:06 - index.html file
39:08 - and
39:10 - we'll just make it pretty similar let's
39:12 - copy this other index.html file but this
39:15 - time we're going to
39:17 - add a paragraph tag here
39:20 - and put
39:21 - in production
39:23 - so then we will be able to know the
39:25 - difference between the production one
39:27 - and the development one so just save
39:29 - that
39:30 - and then we'll just deploy the changes
39:32 - plume
39:34 - up
39:35 - we don't need that up anymore
39:38 - it says we need to set the command the
39:40 - configuration variable apparently this
39:42 - got set wrong oh it's because i call the
39:46 - site
39:47 - i made a mistake a long time ago where's
39:49 - the side drill which should have been
39:50 - site der so let's just go back over here
39:53 - and
39:55 - let's see
39:57 - this is supposed to be site der
40:01 - and i must of uh yeah so now let's try
40:05 - this
40:06 - pollumi
40:08 - up
40:13 - and then i'm actually going to also have
40:14 - to
40:16 - create the site the site der
40:19 - configuration variable for the
40:21 - development
40:22 - stack but we're on the this we're on the
40:25 - production stack now so let's keep going
40:27 - with this
40:30 - okay so we can see
40:33 - the new buckets new objects it's
40:34 - creating
40:35 - and we can go to details just like
40:37 - before
40:39 - and you can see additional information
40:41 - but i will just go to yes and perform
40:44 - the update
40:47 - okay let's try going to this url here i
40:50 - click command click but i'm just going
40:51 - to copy it
40:54 - and then i'm going to go to my you
40:56 - website here
40:57 - hello everybody in production so we're
41:00 - now seeing the production website
41:03 - we can also curl it just like before
41:05 - it's actually pretty much the same
41:06 - command so if i just press up a few
41:09 - times
41:12 - and we see hello everybody in production
41:15 - and especially when you're practicing
41:18 - whenever you get to the end of what
41:19 - you're doing you want to destroy
41:22 - everything destroy the resources
41:24 - this is especially important in aws you
41:26 - don't want to accidentally be charged
41:28 - something if you have stuff on aws for a
41:31 - long period of time so
41:33 - to destroy all the resources we can just
41:36 - use pollumi
41:38 - destroy
41:40 - and that will make sure everything
41:42 - gets destroyed
41:44 - just like before it's going to show us a
41:46 - preview and it's showing that it's going
41:48 - to be deleting
41:50 - all these things
41:51 - three to delete
41:54 - and yes i want to do that
41:57 - and you'll see this message on the
41:59 - bottom
42:00 - the resource and the stack may have been
42:01 - deleted
42:02 - but the history and configuration
42:04 - associated with the stack are still
42:05 - maintained if you want to remove the
42:07 - stack completely run pollumi stack
42:10 - remove fraud which we do want to do so
42:13 - paloomi
42:14 - stack
42:15 - remove
42:16 - prod
42:18 - and i'll just type in prod to remove
42:20 - that but remember we have another stack
42:22 - we have the dev stack so we're gonna
42:24 - have to switch back to the dev stack
42:26 - using pollumi stack select
42:30 - dev
42:31 - and then once we've
42:32 - went back to that stack we can do
42:35 - halloumi
42:36 - destroy
42:40 - and then i will say yes we want to
42:42 - destroy that
42:44 - and then we want to run this other
42:46 - command again
42:48 - gloomy stack remove dev
42:56 - and type in dev
42:59 - okay let's just verify that the stacks
43:01 - are gone so i'll do pollumi
43:03 - stack
43:05 - list
43:06 - and there are no stacks
43:08 - okay we just completed the first lab the
43:11 - next few labs are a little shorter and
43:13 - demonstrate some more advanced tasks
43:20 - the second lab is all about provisioning
43:22 - ec2 virtual machines
43:25 - amazon elastic cloud compute also known
43:28 - as amazon ec2 is a web service that
43:30 - provides secure resizable compute
43:33 - capacity in the cloud it's designed to
43:35 - make web scale cloud computing easier
43:38 - for developers amazon ec2 simple web
43:40 - service interface allows you to obtain
43:42 - and configure capacity with minimal
43:44 - friction so in this lab you'll first
43:47 - create a single ec2 virtual machine
43:50 - afterwards we'll scale that out to a vm
43:53 - per availability zone in your region and
43:56 - then add a load balancer to spread load
43:58 - across the entire fleet
44:01 - now we could do it all within the
44:03 - directory we already created
44:05 - and just update our python file just
44:08 - remove everything from our python file
44:09 - and start from scratch
44:11 - but we'll create a new one to get more
44:13 - practice we'll create a new directory to
44:14 - get more practice so let me create a new
44:17 - directory
44:18 - called iac lab
44:21 - 2 and i'll go right into it cd iac lab 2
44:26 - and then i'll just open that with my
44:27 - code editor in this case visual studio
44:30 - code
44:31 - and before i initialize the project in
44:33 - the terminal and then switch over to
44:34 - code editor now i'll just initialize the
44:37 - project right from the terminal within
44:39 - my code editor so let me open up the
44:41 - terminal
44:43 - and we'll do pollumi
44:45 - new aws python so this is a little
44:48 - different from before
44:49 - why
44:52 - now we just have to make sure our
44:54 - virtual environment is set up so do
44:56 - python 3
44:59 - then
45:00 - then
45:04 - and then source then
45:06 - then activate
45:09 - let's try putting an e at the end that
45:11 - works better okay now let's install the
45:14 - requirements
45:19 - and let me configure the aws region so
45:22 - plumi config set
45:25 - aws
45:26 - region
45:28 - us
45:29 - west
45:32 - two and again you can use any region for
45:34 - this
45:35 - okay you can see the files here are
45:37 - pretty much the same before we have the
45:38 - requirements we have the yaml file
45:42 - move this down
45:44 - in the main.pi you can see this is a
45:47 - little different we've already
45:49 - initialized this with creating a bucket
45:52 - and exporting the bucket
45:54 - you can see the way we created this
45:57 - with the plumey new
45:59 - already added some some extra code
46:02 - creating an s3 bucket
46:04 - i'm going to do this a little
46:05 - differently so i'm actually going to
46:06 - delete all this and i'm going to import
46:10 - pollumi
46:15 - as aws
46:19 - now we're going to dynamically query the
46:21 - amazon linux machine we'll do this in
46:24 - code and so that will avoid needing to
46:26 - hard code the machine image
46:29 - in other words it's ami ami is the
46:32 - amazon machine image and that provides
46:34 - information required to launch an
46:36 - instance so let's get the ami with code
46:39 - so ami
46:40 - equals aws
46:42 - dot ec
46:44 - 2
46:45 - dot get
46:46 - ami
46:48 - and we want to get the most recent one
46:52 - okay you can barely see that
46:54 - okay mo so most recent we can set that
46:56 - to true
46:58 - and then i'm actually just going to
46:59 - paste in some stuff here
47:03 - everything's in the description all the
47:04 - code and everything there's a link to an
47:06 - article that will have all this code
47:09 - but this allows us to set the owner of
47:11 - the ami and some filters we want to use
47:15 - so we also need to grab the default
47:17 - virtual private cloud which is a service
47:20 - that lets you launch aws resources in a
47:23 - logically isolated virtual network that
47:25 - you defined
47:26 - that's available in our aws account so
47:29 - to get that virtual private cloud we'll
47:31 - just do vpc
47:32 - equals aws.ec2.getv
47:39 - and then we'll just set the default
47:42 - to equal true
47:46 - now we'll create an aws security group
47:49 - this will enable ping over icmp and http
47:53 - traffic on port 80.
47:55 - so for this i will just paste it in
47:59 - and we can see this is how you would
48:00 - create a security group on here
48:07 - and again you can get that code right
48:08 - from the article in the description
48:10 - now we're going to create a server
48:13 - and this server is actually going to
48:15 - have a startup script that spins up a
48:17 - simple python web server i'm just going
48:19 - to paste in some code and then i'll
48:21 - explain it
48:22 - so we're creating an instance of the
48:24 - server we're creating a web server and
48:26 - then this is the type a t2.micro
48:29 - and this comes right from aws the types
48:32 - of different servers that you can create
48:34 - so you could do a t3 or t1 and there's
48:37 - just different types you can do
48:39 - and then we're getting the security
48:40 - group ids right from what we already
48:43 - created up here the group ids
48:46 - and then the ami is from what we already
48:48 - created and then this is an interesting
48:50 - thing the user data
48:52 - here we are creating a simple python web
48:56 - server
48:57 - now for most real world applications you
48:59 - would want to create a dedicated image
49:01 - for your application
49:02 - rather than embedding the script in the
49:04 - code like this
49:06 - but for this example we're just trying
49:08 - to spin up something really quick
49:10 - okay now we are going to export the ec2
49:13 - instances resulting i p address and host
49:16 - name so we'll do pollumi
49:18 - dot export
49:20 - and then we're going to export the ip
49:24 - and then server
49:26 - dot public
49:28 - ip we're getting the ip is coming
49:30 - directly from aws here
49:33 - and then the host name
49:37 - which in this case is the public dns
49:40 - okay we're going to provision the ec2
49:42 - instance and access it so to provision
49:44 - it we'll do pollute me up
49:47 - wait first save save and then pollute me
49:49 - up
49:50 - and then let's see what it shows
49:53 - looks like there's an air i think we
49:55 - made a minor mistake here oh api that
49:59 - should be ami
50:01 - so let's save that
50:03 - and then do blue me up again
50:06 - okay and you can see it's showing what
50:09 - it's about to create
50:10 - and i'll just go into yes
50:16 - okay if we go up we can see we have the
50:18 - host name and the ip address
50:20 - so i'm actually just going to take this
50:22 - hostname and copy it we're going to go
50:24 - right into our web browser so if i paste
50:26 - it in here
50:31 - okay it took a few seconds to start
50:33 - working but it must have finished
50:35 - provisioning so it says hello world
50:38 - and another way to do is write from the
50:39 - command line
50:41 - interestingly it looks like a new
50:43 - version of polumi must have came out in
50:44 - the middle of me making this tutorial
50:47 - because it wasn't saying that before
50:49 - okay but right now i'm going to do this
50:52 - curl
50:57 - and do pull
51:00 - pull me
51:02 - stack output hostname
51:07 - and then we can see the hello world
51:09 - right here and i might as well just
51:13 - install the new version of pollumi while
51:14 - i'm at it
51:19 - okay that was simple so the next thing
51:21 - we're going to do is add more ec2
51:23 - instances we're going to create multiple
51:25 - instances that are each running the same
51:27 - python web server and we're going to
51:29 - make them across all aws availability
51:31 - zones in the region
51:33 - so let's go back up to our code
51:37 - and the part of the code that creates
51:39 - this web server
51:41 - and this instance and it exports
51:43 - resulting ip address and host name we're
51:46 - going to
51:47 - modify this a bit
51:49 - well first of all we're going to make a
51:51 - new there's going to be a new ip and
51:53 - host name for each aws availability zone
51:56 - so let's store those in in an array or a
51:59 - list so ips
52:01 - equals and then we're just making an
52:02 - empty list that we're going to be
52:04 - filling
52:05 - host names
52:07 - equals
52:08 - and then we're going to put this into
52:12 - a for loop because we're going to
52:14 - make an instance for each element for
52:17 - each availability zone so for a z and
52:20 - aws dot get
52:23 - of the availability zone we can get
52:25 - right here
52:27 - z
52:30 - dot names
52:32 - so for each availability zone
52:35 - now what i'm going to do
52:39 - i'm going to put this into the for loop
52:42 - and then we'll just do some minor
52:43 - updates
52:44 - so this will be different for each
52:46 - availability zone
52:48 - so for where it says web server i'm
52:50 - going to use the python f string
52:52 - to put a variable in here
52:57 - dash
52:59 - a z
53:01 - which is the availability zone
53:03 - and then for the
53:05 - well we'll add what the availability
53:07 - zone is so i'll put
53:10 - availability zone
53:13 - and it's just going to be a z
53:15 - and now we are going to make it so
53:19 - each
53:20 - and now we're going to make it so it
53:21 - says hello world we're going to make it
53:22 - so this is different the index.html
53:25 - files can be different for each
53:26 - availability zone so for that to work
53:30 - let me just add a few characters here
53:36 - and then we'll just do dot format
53:40 - okay so now it's going to fill in the
53:41 - availability zone uh for in this spot
53:44 - here in the index.html file and we'll go
53:47 - down here and the ip is going to be ips
53:50 - and then we'll use that
53:53 - variable and actually we didn't fill
53:54 - that variable yet so we still have to do
53:56 - that so host names
54:00 - host names
54:03 - and then right here still in the for
54:05 - loop
54:06 - ips.append
54:10 - server dot public
54:12 - ip
54:14 - and then host names
54:18 - append
54:21 - server dot public
54:25 - dns
54:26 - okay so now we'll be exporting the list
54:28 - of ips in the list of host names so
54:30 - let's do another plug me up i'll save
54:32 - that
54:34 - and we'll do pollumi up
54:38 - okay so we're going to be deleting our
54:39 - original one and creating
54:41 - four new ones if we go up here so
54:44 - there's there's four of them for each
54:46 - availability zone and you can see them
54:48 - right here
54:50 - west 2a 2b b2c and 2d
54:53 - so i'll perform that update
55:01 - okay it looks like we have an error the
55:03 - requested instance type which is
55:05 - t2.micro is not supported in the
55:08 - availability zone but just this one so
55:10 - i'm going to copy this and we're going
55:12 - to use an if statement to make sure we
55:14 - create an instance everywhere except
55:16 - that availability zone so
55:19 - if
55:20 - not
55:22 - a z
55:25 - equals
55:27 - us west d2
55:29 - then
55:30 - we'll create the server okay just let me
55:33 - just indent all this here
55:37 - and then i'll save it
55:38 - pull me up
55:41 - i'll go yes
55:45 - okay now we have these three outputs
55:49 - so i can just try going to one in the
55:52 - web browser
55:55 - and you can see this one is in
55:57 - 2a
56:00 - let's try another one
56:08 - and this one's 2b
56:10 - so each web server is going to include
56:12 - in the response what availability zone
56:15 - it's in
56:16 - but this isn't very realistic in the
56:18 - real world you're not going to want all
56:19 - these different urls for each
56:21 - availability zone
56:23 - we're going to now add a load balancer
56:27 - the load balancer is going to be able to
56:28 - distribute the load evenly we'll just
56:30 - have a single url that we can go to and
56:33 - the load balancer will automatically
56:34 - determine which server or which
56:37 - availability zone to get the data from
56:40 - this is the way you can handle a lot of
56:42 - people going to a website at once and
56:44 - the website can be loaded from different
56:46 - places depending on where the load is
56:49 - the lowest so it can kind of balance the
56:51 - load across all the servers
56:53 - okay back over to our code we need to
56:56 - add an egress rule to our security group
56:59 - whenever you add a listener to your load
57:00 - balancer or update the health check port
57:03 - for a target group used by the load
57:04 - balancer to route requests you must
57:06 - verify that the security groups
57:08 - associated with the load balancer allow
57:10 - traffic to the new port in both
57:12 - directions
57:14 - so to do that
57:16 - i'm just going to paste in the egress
57:18 - here
57:19 - this is required to ensure the security
57:21 - group ingress rules don't conflict with
57:23 - the load balancers
57:25 - so now we'll define the alb let me go
57:28 - right after this
57:29 - security group definition
57:32 - i'm going to add the load balancer
57:33 - creation steps someone just paste in
57:36 - some code here and i'll go over it
57:38 - so we already have we already got the
57:40 - vpc up here
57:43 - but we also need the vpc subnets
57:48 - and then we're going to create
57:50 - the load balancer like this
57:53 - we're gonna it's internal equals false
57:55 - so it can be accessed by the public
57:57 - we're going to use the same the group id
57:59 - for the same security groups
58:01 - and then the subnets we get right up
58:03 - here
58:05 - and then
58:06 - we're creating a target group here
58:14 - and then a listener
58:20 - so we've defined the alb it's target
58:23 - group and some listeners but we haven't
58:25 - actually added the ec2 instance to the
58:28 - alb
58:29 - so this is how we're going to add the
58:31 - instance let's go down to our creation
58:34 - of the
58:34 - ec2 the ec2 creation
58:38 - was update this
58:40 - to the security groups
58:46 - and then we'll attach the instances
58:49 - so we'll do attachment
58:55 - equals aws.lb dot
58:59 - target group attachment
59:02 - and then this f string here
59:08 - target group are in is going to be the
59:10 - target group
59:13 - dot arn
59:15 - and the target
59:20 - id
59:21 - is going to be the server dot
59:23 - private
59:27 - ip
59:28 - and then it's going to be on port 80.
59:34 - okay we just want to export one more
59:36 - thing
59:38 - the
59:40 - url
59:41 - and this is going to be the main url
59:43 - we're going to be using
59:44 - which it has the load balancer
59:50 - okay this is all the infrastructure we
59:52 - need for our load balanced web server
59:55 - so i'll just save that and we'll apply
59:57 - it with polumi
59:58 - up
60:02 - and i'll perform the update
60:06 - okay here is the load balancer url if i
60:09 - just copy this
60:12 - and i'm going to do a curl to it
60:15 - now watch i'm just going to keep doing
60:16 - it a few times and every time i do this
60:19 - curl you can see that a different url is
60:23 - loaded because c says
60:24 - us west 2a 2c 2b 2b 2a so the load
60:29 - balancer is working i have one url
60:32 - but each time i go to the url it's being
60:34 - loaded from a different server because
60:36 - the load is being distributed
60:39 - so
60:40 - that works that's how you create a load
60:43 - balancer
60:45 - with infrastructure as code since we're
60:47 - done with that i'm now going to destroy
60:50 - everything since this is just a test i
60:52 - don't want
60:53 - these web servers still going on aws so
60:56 - to destroy everything i'll just do
60:58 - paloomy
60:59 - destroy
61:04 - and then i have to see do i want to
61:05 - delete all this stuff
61:07 - yes i do
61:15 - okay just like it says here we can
61:18 - also run this command plume stack remove
61:20 - dev
61:22 - to remove the stack completely
61:33 - in this final lab we'll use pollumi to
61:35 - deploy a docker image to ecs with
61:39 - fargate
61:40 - so let's start from the beginning again
61:42 - to make more practice
61:44 - so let me go out of this directory
61:48 - and i'm going to create a new directory
61:54 - and then i'll just change into it
62:00 - and i will initialize
62:02 - the project
62:04 - okay we'll do pollumi new aws
62:07 - python
62:11 - and then i'll just fill this in or just
62:13 - hit enter to use the default
62:18 - so just like before it's creating all
62:19 - the files we need it's initializing a
62:21 - new stack named dev which is an instance
62:23 - of our project
62:25 - and it's installing the needed package
62:26 - dependencies from pi pi
62:29 - let's open up this in vs code
62:35 - okay here's the project in nvs code the
62:37 - same files from before we have the
62:38 - main.pi
62:40 - which is going to be our main file where
62:43 - we put all the python code like before
62:46 - and you can see down in the terminal
62:48 - we're in our virtual environment
62:51 - and let's configure the aws region now
62:53 - it did do that when we were setting
62:55 - things up but just to make sure we have
62:57 - the right region pollumi config
63:00 - set
63:01 - aws
63:03 - region
63:04 - us west
63:07 - 2
63:09 - and then we'll go back up to our code
63:11 - and i'm actually just going to delete a
63:12 - lot of this because we're going to start
63:14 - from scratch we're going to start by
63:17 - creating creating an ecs cluster so we
63:21 - imported pollumi now let's import
63:23 - plumy
63:25 - aws
63:27 - as aws
63:29 - and now we'll create a new cluster
63:32 - we can use the default values so it's
63:34 - going to be pretty concise so cluster
63:37 - equals
63:38 - aws.ecs that cluster
63:43 - cluster
63:46 - now we're going to create a load balance
63:47 - container service so we're going to
63:49 - allocate the application load balancer
63:52 - or the alb
63:53 - and listen for http traffic port 80. in
63:56 - order to do this we'll need to find the
63:58 - default vpc and the subset groups for it
64:04 - okay i'll just paste in some code here
64:07 - and i'll just look through it i'm going
64:08 - to go through it pretty quick a lot of
64:11 - it's similar to the last lab we did
64:14 - so we create the vpc and the vpc subnets
64:17 - we got the security group here
64:22 - there's the egress
64:23 - and then we got the load balancer
64:28 - and the target group
64:32 - and the listener
64:34 - so i'll save that and run plummy up
64:42 - and then i'll make the update
64:47 - so we've fleshed out our infrastructure
64:50 - and added a load balancer that we can
64:52 - add infrastructure to
64:55 - in the next step we'll run a container
64:58 - aws fargate is a service that enables a
65:01 - user to run containers on amazon's cloud
65:04 - computing platform without the need to
65:06 - manage the underlying infrastructure
65:10 - in order to create a fargate service
65:13 - we'll need to add an iam role and a task
65:16 - definition and service
65:17 - the ecs cluster will run the nginx image
65:21 - from the docker hub
65:22 - so we're not actually going to create
65:24 - our own docker image for this example
65:27 - we're just getting the image right from
65:29 - docker hub
65:30 - so first we'll need to add an import at
65:32 - the top of our file go to the top and
65:34 - put import
65:35 - json
65:38 - now at the bottom i'm going to paste in
65:40 - some more code here again it's all in
65:42 - the description if you want to get the
65:44 - code
65:45 - so here we define our iam role and
65:48 - attach a policy
65:51 - so this section right here we're
65:52 - defining the role here
65:55 - and then we're going to attach this
65:57 - policy
66:03 - then we define a task definition for our
66:07 - ecs service
66:12 - you can see the image is the nginx image
66:18 - and then here is the service
66:29 - and then at the very end we export the
66:32 - url
66:34 - we get from here the alb
66:36 - the dns name
66:39 - so let's provision the cluster and
66:41 - service
66:43 - we'll i'll save
66:44 - and then do pollumi
66:46 - up
66:50 - this is going to output the status and
66:52 - resulting load balancer url
66:58 - perform the update
67:01 - so if i pull this up
67:03 - we can see the status and the resulting
67:06 - load balancer url
67:09 - i'm going to copy this url and we're
67:11 - actually going to try going to it in the
67:12 - web browser
67:14 - so if i load this it says service
67:16 - temporary on the temporarily unavailable
67:18 - but let's see if i refresh it a few
67:20 - times
67:22 - okay keep refreshing it eventually says
67:24 - welcome to nginx
67:27 - we got the web server
67:30 - says if you see this place the nginx web
67:32 - server is successfully installed and
67:33 - working
67:36 - we can also go to the terminal and do
67:38 - this curl plume stack output url so it's
67:41 - just going to actually just curl that
67:43 - url
67:45 - and you can see we have the same html
67:48 - that we saw in our web browser
67:51 - that the nginx web server successfully
67:54 - installed
67:57 - so now let's update the service
68:02 - we're going to change the desired count
68:04 - from 1
68:06 - to 3.
68:10 - so now we are making three containers
68:15 - save that
68:16 - and then i'll do pull me up
68:22 - and then i'll say i want to update
68:27 - i'm over on the aws console and if i go
68:31 - to the ecs clusters page and i make sure
68:34 - i have the right region in here the one
68:36 - that i set up
68:37 - for my on polumi we can see the cluster
68:41 - that i created we have one service it's
68:43 - running two tasks
68:46 - so desired test three and it's running
68:48 - two
68:53 - so we can see the desired count up here
68:56 - is three
68:57 - just like we set up in pollumi
69:01 - okay we're actually done with this so
69:03 - we're going to destroy everything
69:06 - pollumi destroy
69:11 - and yes
69:16 - okay then we'll remove the stack
69:17 - completely with pollumi
69:20 - remove dev
69:28 - okay we're done with the third lab
69:30 - thanks for watching i hope this spurred
69:32 - your interest to start trying to use
69:34 - some infrastructurized code on some of
69:36 - your own projects

Cleaned transcript:

in this course you will learn all about infrastructurist code i'll start by giving you a general overview of the different concepts and then i'll show you how to implement infrastructure as code with three different labs this course will use python and aws but the concepts will apply to other languages and cloud providers so let's start by talking about what infrastructure as code is to put it simply it's setting up your infrastructure as code by infrastructure i mean all the different things needed to deploy your software into a cloud environment that can mean things like virtual machines containers or serverless functions infrastructure also means all the other pieces of infrastructure you need to set up to make that successful that can be security like aim and kms or networking or some of the monitoring and logging capabilities you can also use code to configure and set up data stores these are the things that your application needs to store and manage data the last piece of infrastructure landscape is the applications themselves and getting the applications that we're building into the infrastructure all of these different pieces of infrastructure can be set up using code software as a service or sas is related to infrastructure's code software as a service allows users to connect to and use cloudbased apps over the internet sas provides a complete software solution that you purchase on a payasyougo basis from a cloud service provider you rent the use of an app or software for yourself or for your organization from a cloud service provider and connect to it over the internet common examples are email office tools crms and development tools infrastructure as a service is part of software as a service infrastructure as a service is a cloud computing service where companies rent servers for compute and storage in the cloud this allows users to run operating systems or applications on the servers without the maintenance and operating costs of those servers so infrastructure as code involves using code to manage your infrastructure as a service it's becoming more and more important to automate infrastructure because applications can be deployed to production up to 100 times per day and you don't want to be doing that all manually it's also helpful for infrastructure to be provisioned or d provisioned in response to load we need to answer questions such as how do we get the images for our vms how do we get the container images in how do we package up and ship code into serverless functions over the years there has been a transition with how people are using cloud infrastructure within their organization in the first wave it was fairly simple the infrastructure were fairly static it was often single virtual machines that you just accessed through ssh it got a little more complex in the second wave there were more containers and people started using provisioning tools to specify the application behaviors people use things like docker and datadog modern cloud infrastructure has added way more complexity it uses containers serverless and more managed services as part of the applications there are now way more different pieces involved in how people build the infrastructure infrastructure as code is becoming a more important part of how people build and deliver applications because infrastructure as code is what describes the glue between all the different edges on these diagrams this diagram for the modern infrastructure may look more complicated than the previous ones but it can actually be easier to maintain a key benefit is that the dark gray squares in the diagram are the only part which is the code you own and that part is smaller than the previous ways of doing things so a lot of the operational burden has been decreased compared to how it used to be done with infrastructure as code it is now easier to build deploy and manage infrastructure in a repeatable and scalable way on a variety of cloud service providers infrastructure as code makes it easier to manage that process alongside your actual application code now there is a greater focus on the glue between the different services that are being managed by a cloud provider and these services can be deployed in a repeatable and scalable way infrastructure code takes on an increasingly more important role in how you manage everything in the modern cloud so here are the three main ways that can be used to manage all the resources manual that's how it used to always be done you just point and click to create or modify resources in the console you can do it like through the aws console you can just point and click to what things you want to create then there's ad hoc automation this is when you use cli commands or scripts to create and modify resources so you're kind of using some code but it's not going to be able to be reused over and over and modified very easily the third way is what we're talking about infrastructure as code there's provisioning which is declaratively creating and modifying resources and configuration which means to change the state of an existing resource post provisioning infrastructure as code gives us the ability to write down what we want the desired state of our infrastructure to be i'll be showing you how to do some of these things later there are a few different ways to write infrastructures code so one approach is to use json here's an example you can see this is a way to tell aws what resources you want to have you can see the resources the ec2 instance the instant security group and just everything you're going to need just in a json format another method is to use domain specific language or dsl this is a custom method specific to the tool or cloud provider you are using so here's an example you can see it does kind of look like code but it's no no it's not like a popular programming language or even the exact way that json usually is written yet another way of defining infrastructure using code is to use a wellknown programming language for instance polumi can be used to write infrastructure as code using typescript javascript python go and net here's an example using typescript and later we'll be using python using code gives the ability to do things that are not possible in some of the other methods in this example there's a for loop that creates an instance for each availability zone code gives the ability to use loops conditionals classes packages and more using popular programming languages also allows the use of common ides linters and test frameworks so let's get into some real world examples we're about to set up some actual infrastructure as code there are a few different services that allow you to use popular languages to create infrastructure as code in this course we'll be using pollumi this course was made possible through a grant from blooming pollumi is an open source infrastructure as code tool for creating deploying and managing cloud infrastructure pollumi works with traditional infrastructure like vms networks and databases in addition to modern architectures including containers kubernetes clusters and serverless functions plumi supports dozens of cloud service providers we'll be using python and deploying on aws though it can be done with other programming languages and cloud providers we'll start with a simple example this will show an endtoend experience of working with plumi using very simple resources in this first example we'll do the following create a new project configure aws provision infrastructure update infrastructure make your stack configurable create a second stack and destroy the infrastructure we'll use an s3 bucket and then work through the life cycle with a simple set of resources then in future examples you will learn how to implement more complex things with pollumi infrastructure is organized into projects each project is a single program that when run declares the desired infrastructure for pollumi to manage before we start the first lab make sure you have polomi installed the way to install is different depending on your operating system you can check the link in the description for all the instructions for how to install different operating systems one way if you have home brew is just brew install pollumi like i mentioned we'll also be using aws you have to make sure you have an aws account and have the cli set up and authenticated i have a link in the description that shows you how to sign up for a free aws account also there's another link that shows how to install the aws cli for your operating system from aws you're going to need an access key id and a secret access key let me show you how to get that i'm at this url right here um you can do without the v2 at the end just the console.aws.amazon.com iam and then i'm going to go to users here and then i'm going to add a user i'm going to make a new user just for this project and the user is just going to be infrastructure as code or iac and i'm going to click that i want to get the access key here and next permissions i'll just add administrator access so to make sure it can do whatever needs to do and then i'll just go through just keep clicking clicking next and then create user okay now we have the amazon access key and the secret access key so you're going to actually have to copy the access key and the secret access key from this page and you can get that obviously by clicking show to show the secret access key let me show you where you're going to need those things go over to your command line and type in aws configure okay now this is where you're going to enter your access key i'm just going to copy it from here and then the aws the aws secret access key now yours probably won't have this here because i've already done that so it's seeing if i want to use what i already have but i want to put in a brand new one here and then we can just click none for the next few things here okay aws is set up so the first step to starting a pollumi project is to create a new directory each pollumi project lives in its own directory so i'm going to create one first i'm going to go into projects okay i'm gonna make a directory and i'm just gonna call it iac lab one now just jump into my directory i just created okay i'll do paloomi new python because we're making a python project and we'll just select yes to everything now i've already used pollumi on this computer but if this is the first time you've used pollumi you will be directed to enter an access code or log in and it will tell you the website to go to get to get the access code but it's app.paloomy.com account slash tokens you will have to create a plumi account and then you will be able to get your access code so this command has created all the files we need it's initialized a new stack named dev which is an instance of our project we now need to install our dependencies as part of our virtual environment so let's set up our virtual environment we're going to create a virtual environment and install the required python packages the python module used to create and manage virtual environments is called v e and v so let's use these commands first we'll do python 3 m v e and v v e n v and then source v e and v slash been slash activate okay i've activated my virtual environment and now i'm going to install the requirements pip 3 install requirements dot txt that requirements.txt file was created when we initialized our polumi project now let's open this up i'm going to open up in visual studio code but you can use any code editor you want okay these are all the files that got installed when we did their pluminew this main.pie is the program's main entry point file this is the file that we'll be putting all of our code in now we have the requirements.txt that's just your project's pip dependency information and then we have pollumi.yaml which is the project's metadata containing its name and language you can see we have python and then we have the name here and the virtual environment so if we go back into the main.pi we'll notice that we just have one line of code that's just automatically put in there which is import gloomy now there could be more or less code in here depending on which way we run the plumi new command but we just wrote ran it with plummy new python so it just started with import polymer which is the line of python so now that we have the basic project let's configure aws support for it i'm actually going to open the terminal right from within vs code okay i'm going to install something so pip 3 install pollumi aws now i'm going to make our code take up more of the room here and i'm going to add another line so import i'll import we just installed so import pollumi and actually recommend it right here as aws okay now we're going to configure an aws region which is whatever region you want to deploy to by we're going to run something in the command line so i'll go back down to the command line and i'm going to do pollumi config set aws region and you can use any aws region that you like but in my case i'm going to use us east one okay now we're actually going to start doing some infrastructure as code we're going to provision infrastructure so now that we have a project configured to use adws we'll create some basic infrastructure we'll start with a simple s3 bucket so let's declare a new bucket right up in our python file here i'm going to say bucket equals a aws.s3 dot well s3 dot bucket bucket and then you can call anything you want but i'm going to call it my bucket okay i'm going to save this and we're going to preview the changes so i'm just going to go back to my terminal down here and type in pollu me up so pluto me up is the command you'll be running a lot with palumi which is going to basically run our main.pi file and set up our infrastructure how we configured it so it looks like there's an error here so let's see what that is hmm looks like there was a mistake with my aws login let me just try doing the login again and see if that fixes the problem aws configure now i'm going to get my access key now try running pollumi up again okay work this time so let me bring up this we can see more of what the output was here so this is a preview the command evaluates your program determines the resource updates to make and shows us an outline of these changes so this is what's going to happen we're going to create this stack and we're going to create this bucket here and it hasn't done anything yet we can decide what we want to do for now i'm going to go to details to see more details so you can see now we can see that the acl is private you can see the actual bucket name we call that my bucket but plume is going to add this at the end so we can actually create a bunch of buckets with the same name but it's just going to have a different thing at the end here and you can just see some extra details about this and i do want to perform this update so i'll just go to yes and okay return so now our s3 bucket has been created in our aws account so if we view our buckets on the aws website you'll see the new bucket so i'm going to go to aws and then go to the s3 section and it's going to show this bucket we just created so it's currently empty but we can see the bucket that we just created with pallumi and there's also this url here if we go to this url i'll let's do uh i'll just do command click and i'm going to have to log into plumi to get this to work out so now we're on the plumi console which records your deployment history so right now we've just done one one thing so you can see one thing on here okay next i'm going to show you how to export your new bucket name so we're going to go back into the code area and to inspect your new bucket you'll need its physical aws name well we did see we were able to see the name up here when we went to more details but there's another way to get the name that i will show you using the code so this is called the logical name my bucket but like i said before the aws name will be a little different programs can export variables which will be shown in the cli and recorded for each deployment so let me show you how to export the bucket's name by adding a line of code in here so right after we get the bucket here i'm going to do pollumi.export x export and then i'm going to export the bucket name so that's just what we're calling this value which we're going to get as bucket.bucket so this bucket.bucket will be the bucket name so let me just save this and then we'll go back into the terminal and i'll do pollumi up and now we can see there's a new line here outputs so you can in your python code you can export certain information that will show up in the output section when you do blue me up so i'll just select yes to perform the update and you can see it's unchanged because the only update was just to output the bucket name here you can see all the output by running this command in the terminal pollumi stack output you can see it's there's only one output the bucket name and then it has the value of it right here now we can run the aws cli to list the objects in this new bucket and we can get the bucket name using the command from above let me show you how you do that so we're going to do aws s3 ls and then i'm going to run that command right in here pollumi stack output bucket name so that's going to get the bucket name and if we run that command nothing's going to really happen because there's nothing in the bucket so it's returning what's in the bucket but there's nothing in the bucket so there's nothing to be returned but we'll change that shortly we're going to now update the infrastructure we just saw how to create new infrastructure from scratch so now we're going to make a few updates we're going to add an object to the bucket we're going to serve content from the bucket as a website and we're going to pragmatically create infrastructure this will demonstrate how declarative infrastructure as code tools can be used not just for initial provisioning but also subsequent changes to existing resources so we're going to add an object to the bucket i am going to create a new directory i'm going to just go to new folder i could click this button up here this folder is going to be called site and then i'm going to make a new file and this will be called index.html okay i'm just going to make an extremely simple website here html and body and then just an h1 tag and it's going to say hello everybody okay now let me rearrange things here we'll go back to our main.pi and let's add some lines of code so we can add that file to our bucket so i'm going to add import and put a new library the os library so we can access uh stuff from our operating system the file path in particular so let's see actually we'll put it right here file path equals os dot path dot join and then we'll put the directory name site and then the file name index.html now we're going to create an object variable and we'll do aws.s3 dot bucket object index.html so the object is index.html and then the bucket is going to be dot bucket and that's how you get the name of the bucket that we created and for source i'll put polumi file asset file path so this is how you use polumi to get this asset this file path right here we're going to create as the object that goes into our bucket so i'm going to save that and enter terminal we'll do plumi up and then i'll just look at this more oh not fire asset file asset because this is a file asset so i'll go to plume up see that makes a lot more sense to you doesn't it than fire asset okay so you can see it's showing what the change is going to be we're going to create this object which is the index.html we're going to create that so i will go to yes to do these changes perform this update so a single resource is added and the two existing resources are left unchanged this is a key attribute of infrastructure as code such tools determine the minimal set of changes necessary to update your infrastructure from one change to the next so let's list again the contents the contents of the bucket i'll just press up a few times we'll use the same line from before and now let's see what's in the bucket it's showing index.html and if i go back over to my web browser and if i refresh my page that shows the bucket on aws we should see yep we see this index.html right here next step we're going to serve content from the bucket as a website to do that we'll need to update a few properties first the bucket needs a website property that sets the default index document the index.html that can that can be achieved by making a few changes to our python file we have our bucket right here and i'm going to after the buck and nam and add a comma and then i'm going to put website equals and then we just have to set the index document and we'll just set that to index.html and make sure that's in a string here okay next the index.html object will need two changes so let's go down here to see this index.html object that's right here we're going to need an acl which is an access control list of public read so right after the source i'll put acl equals public read there now you can see that better this makes it so it can be accessed anonymously over the internet we also need a content type so it's served as html so for the content type to work let's go back up to the top we're going to import something import mime types because we're going to set the mime type and then down here after the file path we're going to get the mime type of the file so mime type and what we'll put it underscore because this is going to return two things but we only need one of the things which is the mime type so we'll do mime types dot guess type and we'll guess the type of the file path and now down here we can set the content type to the mime type so now we have the content type so it's served as html we'll also need to export the resulting buckets endpoint url so we can easily access it so let me show you how you would do that so here we're exporting the bucket name and now let's export the bucket endpoint the full url so we'll do pollumi dot export and this will be called the bucket endpoint we're going to use this concat function from polumi to concat a string and something else so this bucket.bucket it's actually an object it's not a string but it does return a string so if we want to combine something like this with a string we have to use uh concat let me show you how that's done we're going to do pollumi dot output dot concat and then i'm going to put the two things we're going to concat the first thing is going to be a string https came and see what i'm writing here let's see if i can http let's do http colon slash slash and then we'll get a comma here and then just bucket dot web site endpoint so we're just concatenate we're concatenating the http and this website endpoint okay let's deploy the changes so well let me save it and then we'll do pollumi up if i go up here we can see it's making some updates and i'll go to yes okay now we have this url here so we can use this to access that index.html file so i can actually just copy this url stored on amazon aws and now i can open up the url right in my web browser it says hello everybody i can also use curl to get it so back in my terminal do curl and now i am going to run a command right here to get the website url lumi stack output and then you can get any of the things that get output and we'll get bucket endpoint okay see we got this here's the text of our html file next we are going to make the stack configurable right now the bucket's contents are hard coded we're going to make the location of the contents configurable and add support for populating the bucket with an entire directory's worth of contents so the next step is to add a config variable right now we hard code the directory of the site let me show you here so we have we're hard coding this directory here of the site so we're going to configure it to make it easy to change the location without editing the program so right below the imports here i'm gonna do config equals pollumi dot config that's going to make it possible to access some config settings that we set up and we're going to specifically access the site directory and we're going to get it from config dot require and then we're going to get the site dir and i remembered i see that i spelled paloomi wrong there we go and we are going to set this in a minute the site directory but first let's update our program to use this citer variable so instead of getting the site here i'm just going to paste in the variable name okay so now what we're going to do i'm going to save this and then i'm going to go back into my files i'm going to rename this site directory i'm going to rename it www now you may not actually do this in like a real life situation but we're just doing this as an example to see how this can be helpful so let me go into my terminal and i'm gonna do pollumi up okay it's saying air missing required configuration variable this site dur variable and it says please set a value using the command plume config set ic lab 1 site directory with the value so that's what we're going to do now i'm just going to copy this command here and then i'm just going to paste it in and then i'm going to set it to www so now the directory you'll be looking for is the www directory instead of the site directory okay i'll just do plume up again and i will perform the update okay that works so now we don't have to have the the directory hard hardcoded in here we can use these config variables and you can see how you'll be able to use that with other types of data as well okay now we're going to add more files instead of hard coding the set of files which we do now let me show you what i mean right now we hard code that we're adding the index.html file to our bucket but instead of doing that we're going to change the program to read the entire contents of the www directory and add every file from that directory to our bucket so let's start by adding a new file to that directory so i'm going to go into the directory and click the new file button and this is going to be called about.html and this is just going to be a simple thing you can make it anything you want i'm just going to make an extremely simple file with a paragraph it will say it's about so i want to say something about me and i am not a cat so that's something about me okay let's go back to the main.pi file and we're going to replace the object allocation code and now we are going to update the object allocation code so this right here we're going to put all of this into a for loop so i'm going to say for file in os dot list directory site directory and then i'm gonna just indent all this so it's all in that directory and see we have the the file here so now instead of index.html i'm going to put this variable file so now we are using this for loop to go through every file and adding all those files to our bucket now this is one of the really cool things about infrastructure as code and using an actual programming language like python is that you can use for loops and that can make things go a lot that can make things a lot simpler and save a lot of time like we didn't have to use a for loop we could have just copied and pasted this code a bunch of times and and then added each file individually in insta instead of using this for loop but this is going to save us a lot of time especially if we have tons of files that we want to put into our bucket so let's go back to the terminal i'll do actually have to save first here and then i'll do pollumi up so you can see what's going to do it's going to create this file this is about.html and let's do that i'll go to yes now i'm back in my web browser i'm going to put a slash about dot html at the end and now we can see i'm not a cat i can zoom in on that so you can see a little better it's just a paragraph tag so it's pretty small we can also access it through curl the same ways before let me just press up in here but i'll just put slash about.html at the end and then yep here it is here's the about.html file we created now we're going to create a second stack it's easy to create multiple instances of the same project in pollumi each instance is called a stack this is useful if you have multiple development or test environments like staging versus production or if you want to scale a given infrastructure across many regions so let me show you how to create and configure a new stack we'll create a stack named prod so i'm still in the terminal down here i'll do pollumi stack and knit prod and i just created it now next i'll configure the two required variables the same ones we did before so we'll do paloomy config set this is going to be the region aws region and we're going to do it different from before this time it's going to be eu west one you can basically set this to any aws region we'll also set the the site directory paloomi config set iec lab one site directory and instead of the www this is gonna be www.prod i'm just showing where you can have different site directories for different projects for different stacks so let's see the list of stacks we have paloomi stack ls we have the dev stack and we have the prod or production stack now let's populate the new site directory we could have used the existing www directory for the site directory but for this example we'll use the the www prod directory to demonstrate how it can be configured we will make a directory wwe prod and then i'm just going to create a file right from here we could have created the directory from here so where's our new directory right here i'll just create a new file and it's just going to be another index.html file and we'll just make it pretty similar let's copy this other index.html file but this time we're going to add a paragraph tag here and put in production so then we will be able to know the difference between the production one and the development one so just save that and then we'll just deploy the changes plume up we don't need that up anymore it says we need to set the command the configuration variable apparently this got set wrong oh it's because i call the site i made a mistake a long time ago where's the side drill which should have been site der so let's just go back over here and let's see this is supposed to be site der and i must of uh yeah so now let's try this pollumi up and then i'm actually going to also have to create the site the site der configuration variable for the development stack but we're on the this we're on the production stack now so let's keep going with this okay so we can see the new buckets new objects it's creating and we can go to details just like before and you can see additional information but i will just go to yes and perform the update okay let's try going to this url here i click command click but i'm just going to copy it and then i'm going to go to my you website here hello everybody in production so we're now seeing the production website we can also curl it just like before it's actually pretty much the same command so if i just press up a few times and we see hello everybody in production and especially when you're practicing whenever you get to the end of what you're doing you want to destroy everything destroy the resources this is especially important in aws you don't want to accidentally be charged something if you have stuff on aws for a long period of time so to destroy all the resources we can just use pollumi destroy and that will make sure everything gets destroyed just like before it's going to show us a preview and it's showing that it's going to be deleting all these things three to delete and yes i want to do that and you'll see this message on the bottom the resource and the stack may have been deleted but the history and configuration associated with the stack are still maintained if you want to remove the stack completely run pollumi stack remove fraud which we do want to do so paloomi stack remove prod and i'll just type in prod to remove that but remember we have another stack we have the dev stack so we're gonna have to switch back to the dev stack using pollumi stack select dev and then once we've went back to that stack we can do halloumi destroy and then i will say yes we want to destroy that and then we want to run this other command again gloomy stack remove dev and type in dev okay let's just verify that the stacks are gone so i'll do pollumi stack list and there are no stacks okay we just completed the first lab the next few labs are a little shorter and demonstrate some more advanced tasks the second lab is all about provisioning ec2 virtual machines amazon elastic cloud compute also known as amazon ec2 is a web service that provides secure resizable compute capacity in the cloud it's designed to make web scale cloud computing easier for developers amazon ec2 simple web service interface allows you to obtain and configure capacity with minimal friction so in this lab you'll first create a single ec2 virtual machine afterwards we'll scale that out to a vm per availability zone in your region and then add a load balancer to spread load across the entire fleet now we could do it all within the directory we already created and just update our python file just remove everything from our python file and start from scratch but we'll create a new one to get more practice we'll create a new directory to get more practice so let me create a new directory called iac lab 2 and i'll go right into it cd iac lab 2 and then i'll just open that with my code editor in this case visual studio code and before i initialize the project in the terminal and then switch over to code editor now i'll just initialize the project right from the terminal within my code editor so let me open up the terminal and we'll do pollumi new aws python so this is a little different from before why now we just have to make sure our virtual environment is set up so do python 3 then then and then source then then activate let's try putting an e at the end that works better okay now let's install the requirements and let me configure the aws region so plumi config set aws region us west two and again you can use any region for this okay you can see the files here are pretty much the same before we have the requirements we have the yaml file move this down in the main.pi you can see this is a little different we've already initialized this with creating a bucket and exporting the bucket you can see the way we created this with the plumey new already added some some extra code creating an s3 bucket i'm going to do this a little differently so i'm actually going to delete all this and i'm going to import pollumi as aws now we're going to dynamically query the amazon linux machine we'll do this in code and so that will avoid needing to hard code the machine image in other words it's ami ami is the amazon machine image and that provides information required to launch an instance so let's get the ami with code so ami equals aws dot ec 2 dot get ami and we want to get the most recent one okay you can barely see that okay mo so most recent we can set that to true and then i'm actually just going to paste in some stuff here everything's in the description all the code and everything there's a link to an article that will have all this code but this allows us to set the owner of the ami and some filters we want to use so we also need to grab the default virtual private cloud which is a service that lets you launch aws resources in a logically isolated virtual network that you defined that's available in our aws account so to get that virtual private cloud we'll just do vpc equals aws.ec2.getv and then we'll just set the default to equal true now we'll create an aws security group this will enable ping over icmp and http traffic on port 80. so for this i will just paste it in and we can see this is how you would create a security group on here and again you can get that code right from the article in the description now we're going to create a server and this server is actually going to have a startup script that spins up a simple python web server i'm just going to paste in some code and then i'll explain it so we're creating an instance of the server we're creating a web server and then this is the type a t2.micro and this comes right from aws the types of different servers that you can create so you could do a t3 or t1 and there's just different types you can do and then we're getting the security group ids right from what we already created up here the group ids and then the ami is from what we already created and then this is an interesting thing the user data here we are creating a simple python web server now for most real world applications you would want to create a dedicated image for your application rather than embedding the script in the code like this but for this example we're just trying to spin up something really quick okay now we are going to export the ec2 instances resulting i p address and host name so we'll do pollumi dot export and then we're going to export the ip and then server dot public ip we're getting the ip is coming directly from aws here and then the host name which in this case is the public dns okay we're going to provision the ec2 instance and access it so to provision it we'll do pollute me up wait first save save and then pollute me up and then let's see what it shows looks like there's an air i think we made a minor mistake here oh api that should be ami so let's save that and then do blue me up again okay and you can see it's showing what it's about to create and i'll just go into yes okay if we go up we can see we have the host name and the ip address so i'm actually just going to take this hostname and copy it we're going to go right into our web browser so if i paste it in here okay it took a few seconds to start working but it must have finished provisioning so it says hello world and another way to do is write from the command line interestingly it looks like a new version of polumi must have came out in the middle of me making this tutorial because it wasn't saying that before okay but right now i'm going to do this curl and do pull pull me stack output hostname and then we can see the hello world right here and i might as well just install the new version of pollumi while i'm at it okay that was simple so the next thing we're going to do is add more ec2 instances we're going to create multiple instances that are each running the same python web server and we're going to make them across all aws availability zones in the region so let's go back up to our code and the part of the code that creates this web server and this instance and it exports resulting ip address and host name we're going to modify this a bit well first of all we're going to make a new there's going to be a new ip and host name for each aws availability zone so let's store those in in an array or a list so ips equals and then we're just making an empty list that we're going to be filling host names equals and then we're going to put this into a for loop because we're going to make an instance for each element for each availability zone so for a z and aws dot get of the availability zone we can get right here z dot names so for each availability zone now what i'm going to do i'm going to put this into the for loop and then we'll just do some minor updates so this will be different for each availability zone so for where it says web server i'm going to use the python f string to put a variable in here dash a z which is the availability zone and then for the well we'll add what the availability zone is so i'll put availability zone and it's just going to be a z and now we are going to make it so each and now we're going to make it so it says hello world we're going to make it so this is different the index.html files can be different for each availability zone so for that to work let me just add a few characters here and then we'll just do dot format okay so now it's going to fill in the availability zone uh for in this spot here in the index.html file and we'll go down here and the ip is going to be ips and then we'll use that variable and actually we didn't fill that variable yet so we still have to do that so host names host names and then right here still in the for loop ips.append server dot public ip and then host names append server dot public dns okay so now we'll be exporting the list of ips in the list of host names so let's do another plug me up i'll save that and we'll do pollumi up okay so we're going to be deleting our original one and creating four new ones if we go up here so there's there's four of them for each availability zone and you can see them right here west 2a 2b b2c and 2d so i'll perform that update okay it looks like we have an error the requested instance type which is t2.micro is not supported in the availability zone but just this one so i'm going to copy this and we're going to use an if statement to make sure we create an instance everywhere except that availability zone so if not a z equals us west d2 then we'll create the server okay just let me just indent all this here and then i'll save it pull me up i'll go yes okay now we have these three outputs so i can just try going to one in the web browser and you can see this one is in 2a let's try another one and this one's 2b so each web server is going to include in the response what availability zone it's in but this isn't very realistic in the real world you're not going to want all these different urls for each availability zone we're going to now add a load balancer the load balancer is going to be able to distribute the load evenly we'll just have a single url that we can go to and the load balancer will automatically determine which server or which availability zone to get the data from this is the way you can handle a lot of people going to a website at once and the website can be loaded from different places depending on where the load is the lowest so it can kind of balance the load across all the servers okay back over to our code we need to add an egress rule to our security group whenever you add a listener to your load balancer or update the health check port for a target group used by the load balancer to route requests you must verify that the security groups associated with the load balancer allow traffic to the new port in both directions so to do that i'm just going to paste in the egress here this is required to ensure the security group ingress rules don't conflict with the load balancers so now we'll define the alb let me go right after this security group definition i'm going to add the load balancer creation steps someone just paste in some code here and i'll go over it so we already have we already got the vpc up here but we also need the vpc subnets and then we're going to create the load balancer like this we're gonna it's internal equals false so it can be accessed by the public we're going to use the same the group id for the same security groups and then the subnets we get right up here and then we're creating a target group here and then a listener so we've defined the alb it's target group and some listeners but we haven't actually added the ec2 instance to the alb so this is how we're going to add the instance let's go down to our creation of the ec2 the ec2 creation was update this to the security groups and then we'll attach the instances so we'll do attachment equals aws.lb dot target group attachment and then this f string here target group are in is going to be the target group dot arn and the target id is going to be the server dot private ip and then it's going to be on port 80. okay we just want to export one more thing the url and this is going to be the main url we're going to be using which it has the load balancer okay this is all the infrastructure we need for our load balanced web server so i'll just save that and we'll apply it with polumi up and i'll perform the update okay here is the load balancer url if i just copy this and i'm going to do a curl to it now watch i'm just going to keep doing it a few times and every time i do this curl you can see that a different url is loaded because c says us west 2a 2c 2b 2b 2a so the load balancer is working i have one url but each time i go to the url it's being loaded from a different server because the load is being distributed so that works that's how you create a load balancer with infrastructure as code since we're done with that i'm now going to destroy everything since this is just a test i don't want these web servers still going on aws so to destroy everything i'll just do paloomy destroy and then i have to see do i want to delete all this stuff yes i do okay just like it says here we can also run this command plume stack remove dev to remove the stack completely in this final lab we'll use pollumi to deploy a docker image to ecs with fargate so let's start from the beginning again to make more practice so let me go out of this directory and i'm going to create a new directory and then i'll just change into it and i will initialize the project okay we'll do pollumi new aws python and then i'll just fill this in or just hit enter to use the default so just like before it's creating all the files we need it's initializing a new stack named dev which is an instance of our project and it's installing the needed package dependencies from pi pi let's open up this in vs code okay here's the project in nvs code the same files from before we have the main.pi which is going to be our main file where we put all the python code like before and you can see down in the terminal we're in our virtual environment and let's configure the aws region now it did do that when we were setting things up but just to make sure we have the right region pollumi config set aws region us west 2 and then we'll go back up to our code and i'm actually just going to delete a lot of this because we're going to start from scratch we're going to start by creating creating an ecs cluster so we imported pollumi now let's import plumy aws as aws and now we'll create a new cluster we can use the default values so it's going to be pretty concise so cluster equals aws.ecs that cluster cluster now we're going to create a load balance container service so we're going to allocate the application load balancer or the alb and listen for http traffic port 80. in order to do this we'll need to find the default vpc and the subset groups for it okay i'll just paste in some code here and i'll just look through it i'm going to go through it pretty quick a lot of it's similar to the last lab we did so we create the vpc and the vpc subnets we got the security group here there's the egress and then we got the load balancer and the target group and the listener so i'll save that and run plummy up and then i'll make the update so we've fleshed out our infrastructure and added a load balancer that we can add infrastructure to in the next step we'll run a container aws fargate is a service that enables a user to run containers on amazon's cloud computing platform without the need to manage the underlying infrastructure in order to create a fargate service we'll need to add an iam role and a task definition and service the ecs cluster will run the nginx image from the docker hub so we're not actually going to create our own docker image for this example we're just getting the image right from docker hub so first we'll need to add an import at the top of our file go to the top and put import json now at the bottom i'm going to paste in some more code here again it's all in the description if you want to get the code so here we define our iam role and attach a policy so this section right here we're defining the role here and then we're going to attach this policy then we define a task definition for our ecs service you can see the image is the nginx image and then here is the service and then at the very end we export the url we get from here the alb the dns name so let's provision the cluster and service we'll i'll save and then do pollumi up this is going to output the status and resulting load balancer url perform the update so if i pull this up we can see the status and the resulting load balancer url i'm going to copy this url and we're actually going to try going to it in the web browser so if i load this it says service temporary on the temporarily unavailable but let's see if i refresh it a few times okay keep refreshing it eventually says welcome to nginx we got the web server says if you see this place the nginx web server is successfully installed and working we can also go to the terminal and do this curl plume stack output url so it's just going to actually just curl that url and you can see we have the same html that we saw in our web browser that the nginx web server successfully installed so now let's update the service we're going to change the desired count from 1 to 3. so now we are making three containers save that and then i'll do pull me up and then i'll say i want to update i'm over on the aws console and if i go to the ecs clusters page and i make sure i have the right region in here the one that i set up for my on polumi we can see the cluster that i created we have one service it's running two tasks so desired test three and it's running two so we can see the desired count up here is three just like we set up in pollumi okay we're actually done with this so we're going to destroy everything pollumi destroy and yes okay then we'll remove the stack completely with pollumi remove dev okay we're done with the third lab thanks for watching i hope this spurred your interest to start trying to use some infrastructurized code on some of your own projects
