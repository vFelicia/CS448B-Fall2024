With timestamps:

00:05 - Welcome to an introduction to react. My name
is Bob Ziroll, and I'm here to guide you through
00:11 - learning how to build front end web applications.
using one of the world's most popular front
00:15 - end web frameworks react. But first, a little
background about me. I'm the Director of Education
00:21 - at V School, which is a technology education
school that teaches full stack JavaScript
00:27 - and UX courses to those looking for a career
change. I've been teaching in the boot camp
00:32 - space since the very early days of boot camps
starting in 2014. Over the years of teaching
00:38 - and designing curriculum to help students
learn difficult topics in a very short amount
00:42 - of time, I've developed my own learning philosophy,
which I think would be helpful to share. First
00:47 - of all, the easiest way to learn something
is by doing it the hard way, there's truly
00:51 - no substitute for getting your hands on code
as soon and as often as possible. During our
00:57 - class orientation at V school, I typically
give an analogy about myself. So I've recently
01:03 - developed an interest in woodworking. I've
read books, I've watched hours of YouTube
01:08 - videos, I've received new tools as gifts.
However, none of those things has actually
01:13 - brought me any closer to becoming a skilled
carpenter. It's not until I actually put in
01:19 - the hours of cutting, sanding, gluing, screwing
things up. And finally, eventually building
01:25 - things that I'm actually proud of that I can
say that I'm actually starting to become a
01:31 - skilled woodworker. As such, if you actually
want to learn react well enough to be able
01:36 - to use it, you'll need to be actually writing
react code. Most of the lessons in this course
01:43 - are followed up by an exercise that I fully
expect you to put in real time and effort
01:48 - into accomplishing on your own. Now, if you
decide to breeze through them the easy way
01:53 - without actually doing the exercises, you're
actually kind of taking the hardest road possible
01:58 - to learning react. And along those lines,
you should really use the scrum platform to
02:03 - its full potential. Throughout the course,
I'll be having you pause the lesson and actually
02:08 - dive into the code making changes. But even
when I don't ask you to pause and play with
02:13 - the code, you should take the initiative to
do it on your own. And just be curious in
02:16 - general, doing this is going to help you avoid
what some call tutorial hell. And if you want
02:22 - some more information, there's a medium blog
posts that I've linked here in the slides.
02:27 - The idea essentially being that you should
get your hands on the code as much as possible.
02:31 - And by doing so actually do the things. Okay,
not just necessarily the exercises I asked
02:36 - you to do, but anything that you're interested
in curious about. And as I mentioned, scrubba
02:41 - is ideal for this sort of learning if you
use it the right way. Another main point of
02:46 - my learning philosophy is that spaced learning
and repetition are absolutely key, this information
02:51 - to actually stick in your mind. And one of
the main tenants of spaced learning is that
02:56 - you don't just binge on the course, this kind
of goes in line with the concept of Tutorial
03:01 - How, where it can be the easy way out to just
binge on the course and feel like you're actually
03:06 - learning something when in reality, your brain
has been incapable of actually retaining the
03:11 - information. So as you're going through the
course, make sure that you take frequent breaks.
03:16 - And I don't just mean for five or 10 minutes
here, there. But finish a couple of key principles,
03:20 - practice them quickly, and then rest your
brain for the day. And when you come back
03:25 - to the course, don't be afraid to go back
to previous courses and review them. Yes,
03:30 - it will obviously take a lot longer to complete
the course that way, but it will be super
03:33 - beneficial to your learning. Okay, I'll get
down from my soapbox for now. But I'll be
03:38 - reminding you of some of these things frequently
throughout the course. So for now, let's quickly
03:43 - cover what you'll actually be learning. When
we talk about react, we can't avoid the concept
03:47 - of components. components in react are the
core building block for making reusable pieces
03:53 - of HTML. And pretty much everything else that
we talk about deals with how to use these
03:58 - components to build the web applications that
we want to build. We'll also be talking about
04:03 - JSX, which is reacts proprietary wrapper around
JavaScript. And it simply lets you build components
04:09 - in a very familiar way, using the HTML syntax
that you're already familiar with. We'll also
04:15 - spend a little bit of time talking about styling
your components will get a chance to learn
04:20 - about props and how to pass data around your
application. And when we talk about props,
04:25 - we oftentimes talk about state which is how
to maintain and change data in your application.
04:30 - We'll talk about event handling, and how you
can have strong interactivity with your users.
04:35 - We'll talk about lifecycle methods, which
help you hook into different timing events
04:39 - of your react components. We'll talk about
fetching data from an API using HTTP. We'll
04:45 - talk about forms and their role in creating
a good user experience. And there's plenty
04:50 - more that we'll be covering in this course
as well. Now, there's a few things that you
04:54 - should already know before taking this course.
04:56 - And honestly, it's just the basic building
blocks. htm Well, CSS, vanilla JavaScript,
05:02 - and ideally a little bit of the updated syntax
for JavaScript in iOS six. If you're feeling
05:08 - rusty on any of these topics, I've included
links on the logo that you can click, and
05:12 - it will take you to another free course here
on scramble to brush up on that topic. Okay,
05:17 - that's plenty of talking. For now, let's actually
dive into react.
05:26 - Let's take a quick look at some of the applications
that we're going to be building throughout
05:29 - this course, this should give you an idea
of what you'll be able to accomplish by the
05:33 - time you're done with this course. The first
one is kind of the default required to do
05:38 - list application, it may seem a little bit
boring, but it actually covers a lot of the
05:43 - topics that we're going to be talking about
in this course. And of course, you can click
05:47 - an item to mark it as completed, and we see
some style changes and everything. And is
05:53 - kind of a capstone project to this course,
you're going to be building a meme generator.
05:57 - And the idea is you input some top text, some
bottom text, hit the button, and it will randomly
06:04 - choose meme image from an API that contains
meme images. Some of them are funnier than
06:14 - others. So get excited. React is really exciting
technology. And it's going to be an excellent
06:20 - tool in your tool belt as a developer. Alright,
let's get started. We're gonna jump right
06:30 - into learning about react. But first things
first, let's learn why we're going to be using
06:34 - the React framework, instead of just developing
something in vanilla JavaScript. One of the
06:39 - things that you'll hear people talk about
with react is its speed, and how fast it is
06:44 - compared to web applications that are developed
in vanilla JavaScript. The way that react
06:49 - is able to do that is by using something called
the virtual DOM, we're not going to go into
06:54 - a lot of detail about the virtual Dom right
now. But if you're interested in learning
06:57 - more about it, I've included here a link to
a YouTube video with a pretty simple explanation
07:02 - of how the virtual DOM is different than the
way that web applications work when you're
07:07 - developing in vanilla JavaScript. So feel
free to pause the screencast and click on
07:12 - the link to watch that video if you want.
For now, it's enough to know that the virtual
07:18 - Dom helps make react work a lot faster than
vanilla JavaScript. Another really awesome
07:24 - benefit react gives us is the ability to create
reusable web components. And I'm going to
07:29 - talk about this through an example. Right
here, we have the bootstrap default navbar.
07:36 - If you haven't used bootstrap before, it's
just a CSS library that has pre written code
07:40 - that makes some elements look really good
for you. But you can see that it's about 40
07:45 - lines long, and it's pretty unwieldy and difficult
to understand. And if you were to include
07:50 - this in an HTML page with a bunch of extra
content in it, it would be pretty difficult
07:55 - to decipher, and everything would start to
feel pretty cluttered. reacts, web components
08:00 - allow us to take these pieces of HTML. So
this 40 lines that we see here, and put it
08:06 - into a component of our own, almost like a
JavaScript variable. In this case, we call
08:12 - it my sweet navbar. But you could call it
whatever you want. And we can see that this
08:16 - is a lot easier to read, if you're coming
into it as a developer, to see exactly what
08:21 - is going to be where, in this case, the body
of my HTML will have a navbar on top, some
08:27 - main content in the middle and a footer at
the bottom. The ability to do this is really
08:31 - nice for reusing these components on other
pages if we need to, and for making our code
08:36 - look a lot nicer when we're working in it.
Another reason why react is so awesome that
08:41 - I like to include is that it's maintained
by Facebook, whether you care for Facebook
08:45 - or not. There are a lot of really smart developers
at Facebook whose job it is to work on react.
08:51 - On top of that, because react is so popular.
There's a lot of contributors on their GitHub,
08:55 - which is open source who contribute to the
React framework, which means it's going to
08:59 - be evolving for the foreseeable future. And
last but not least, React is very hireable.
09:06 - At vi school, we focus our curriculum and
our efforts on the things that are most likely
09:11 - to get our students hired. And react is very
in demand right now. So if one of your goals
09:15 - is to get a job as a front end developer,
React is a great choice in terms of frameworks
09:20 - to learn. So that's enough talking for now
let's jump into some code.
09:27 - Okay, we're just gonna jump right into the
code. One thing you're gonna want to be somewhat
09:34 - familiar with is es six, or ACMA script six
or ACMA script 2015. It's a slightly newer
09:40 - version of JavaScript if you're used to using
things like var.
09:45 - We're going to be replacing that with some
Yes, six stuff like const and lead. There
09:50 - are some videos here on screen buy that should
be able to help you learn that if you're not
09:54 - familiar with it, and you'll want to do that
before you move too far along in react because
09:59 - we'll be using a A lot of ESX in react, one
of the things we'll be using really often,
10:03 - in fact, in every react file we create is
the import statement. And so I'm going to
10:08 - import react from react. And you can see over
here on the left, I have react and react Dom
10:15 - dependencies included in this project. So
I'm actually also going to import react Dom
10:23 - from react DOM.
10:25 - And the last thing we're going to do is use
react Dom's render method to render something
10:32 - to our screen. But let's stop and explain
this a little bit here, I'll get to why we're
10:37 - important react in a second. But for now,
I need to import react Dom so that I can use
10:43 - it in my line for code here, where I use the
render method. And what this is going to do
10:49 - is it's going to take two arguments, one is
going to be what you want to render. I'm doing
10:57 - this in pseudocode, obviously, so that it's
clear that this is not the right syntax. And
11:02 - the second parameter is, where do I want to
render it? react Dom dot render makes the
11:10 - second one really easy. Remember, everything
is going to have to tie back to an HTML page
11:15 - of some sort, the JavaScript we are going
to continue to write is simply going to be
11:21 - compiled down to or turned into elements on
a page. And so you can think of it as being
11:26 - inserted into an HTML page of sorts. So let's
go over to index dot HTML really quick. You'll
11:32 - see everything in a basic HTML pages here,
including a link tag and a script. Don't worry
11:38 - about the fact that this is slightly different
right now, it will still connect correctly
11:42 - to our index dot j s. One thing I want to
point your attention to though is this div
11:47 - right here with the idea of Route right in
between the opening and closing div tags is
11:54 - where react is going to be sticking everything
that we create, you can think of this as a
11:59 - container for our entire application. So back
in our index dot j, s, this, where do I want
12:05 - to render, it needs to point to the div with
the ID of route. And the way that I can do
12:12 - that is using a vanilla JavaScript document
dot
12:16 - get element by ID
12:17 - route. This way render looks at the first
parameter, which I haven't filled out yet
12:23 - that says, What do I want to render, and it
will stick it inside of the div with the ID
12:29 - of root. Now let's look at this first part,
what do I want to render? Let's get rid of
12:34 - this placeholder. And let's just start with
a simple h1. And of course, we have to say
12:45 - hello world to refresh the browser over here,
and notice that we actually get an h1 with
12:52 - a Hello World in there. Now the astute of
you might have said, Wait a second, why are
12:56 - you putting an HTML element in the middle
of your JavaScript parameter, that's an obvious
13:01 - syntax error, JavaScript is going to think
that that is a less than symbol and that this
13:05 - is a greater than symbol and not know that
this is an HTML element. Well, fortunately
13:10 - for us, the people that created react created
a little pseudo language, you could call it
13:16 - called JSX. JSX is very much like a JavaScript
rendition or version of HTML. In fact, we're
13:27 - gonna see that most of JSX looks almost identical
to HTML. With this few slight differences
13:32 - that we'll talk about along the way. There's
a lot happening under the hood with react,
13:38 - where everything is getting compiled down
to a plain JavaScript version of itself. But
13:43 - for us, we can just pretend that this will
work just fine. And it turns out, this is
13:48 - why we need to import react from react because
the React library is the one that will enable
13:53 - JSX to work the way it's supposed to work.
In fact, you can see that if I remove the
13:58 - import react line, and try to save it and
refresh the browser, it tells me that react
14:06 - is not defined. Even though I'm not explicitly
using react anywhere in my code here. Under
14:12 - the hood, it's getting used to interpret the
JSX. Another point I want to touch on really
14:17 - quick is also dealing with JSX. It's important
to note that I can't render two JSX elements
14:24 - next to each other. For example, if I wanted
an h1 and a paragraph,
14:35 - you can see that it's already not liking what
I'm doing. And if I were to save the page,
14:41 - it tells me that you can't have two adjacent
JSX elements. But instead they have to be
14:46 - wrapped in something so that it counts as
just one element with two elements inside.
14:52 - For example, I might choose to wrap this in
a div
15:02 - And I need to put my reactant back. And there
we go. Using JSX can take a little bit of
15:11 - getting used to, but it's much better and
nicer after you get used to it, then doing
15:15 - it the old way where you'd have to say things
like, var, my new paragraph equals document
15:23 - dot, create element paragraph, and add some
inner HTML, then take that paragraph and append
15:42 - it to a parent. That was very imperative.
Whereas now we're going to be doing things
15:47 - much more declaratively. I also want to interject
right here that you should remember that the
15:53 - benefit of scrambler is that you can pause
this screencast and play with this code. So
15:58 - please take some time to do that. Not just
at the end, but also throughout the entire
16:03 - screencast. We're also going to be including
entire screencasts that are dedicated to you
16:09 - doing exercises, as mentioned in the first
video. So take some time, play with this,
16:15 - study it up and get ready for the upcoming
exercise.
16:20 - All right, welcome to the first practice of
this course, this is where it makes a lot
16:27 - of sense to you scramble over a regular video.
As we mentioned, we highly encourage you to
16:32 - actually give these practices and exercises
a shot. Sometimes it's really tempting to
16:38 - just skip ahead to the solution. But you're
only going to be hurting your own education.
16:42 - If you do that. So please give it a shot.
The way this will work is I will put an objective
16:47 - up on the screen sometimes some hints as you
see here. And then I'll leave about five to
16:52 - 10 seconds of silence to give you a chance
to pause the video and actually try to accomplish
16:57 - the objective. If you get stuck, I recommend
that you not just skip ahead to the solution.
17:02 - But instead that you go back to a previous
video and relearn the thing that the practice
17:07 - is about, the more effort you put in, the
more likely This is actually going to stick.
17:12 - So let's take a look at this practice. Your
objective is to fill in the basic boilerplate
17:17 - react code needed to render an unordered list
to the page inside that unordered list, you
17:23 - can put three list items with anything that
you want in them, it doesn't really matter.
17:28 - The way that you'll know that it worked is
that it will show up in the little browser
17:32 - window on the right here. Since it may be
your first time working in react, I've included
17:37 - a couple hints that remind you of the steps
you'll need to take. So I'm going to leave
17:41 - some silent space now and go ahead and pause
the screencast and give this a shot. Okay,
17:49 - let's go through the solution together, I'm
going to remove the comments that I have.
17:56 - And the first thing we will need to do in
almost every react file that we create is
18:01 - we're going to need to import react
18:03 - from the React library.
18:07 - And since this is our index dot j s, and we're
going to need to render something to the page.
18:14 - We're going to need the React Dom library.
Last but not least, we're going to use react
18:25 - DOM. We're going to use its render method.
And there are two parameters that we need
18:32 - to pass into render. The first one is what
do we want to render? Well, as the challenge
18:37 - said, we need an unordered list. And inside
that unordered list, we need three list items.
18:47 - Copy and paste this so we don't need to 123
you can see here, this is kind of looking
19:00 - pretty ugly. We're going to see in the future
how obviously, we're not going to put our
19:05 - entire page here in the render. So I'm going
to move this on to its own line so that it
19:11 - looks a little more like regular HTML. If
you didn't do that, that's totally fine. And
19:19 - then I'm going to be really boring and just
put 123 in here.
19:23 - Okay, that's the first parameter. And the
second parameter is where do I want this to
19:33 - load into. If you remember from the last screencast,
we have a div with the ID of route. And that's
19:41 - where we want to place our application. So
in react Dom dot render, I need to provide
19:50 - get element by ID route, so that it will go
find that element and let react Dom dot render
19:57 - node, this is where I want you to put This
code and when we refresh the browser, we get
20:07 - our three bullet points with 123. If any of
that was confusing, I highly encourage you
20:12 - to go back to the previous video, rewatch
it, play with the code, come back, do this
20:18 - practice. Again, mess with the code that I
put here, see if it works, the way you understand
20:22 - it, try to break it, etc. Doing that is going
to really help you understand react on a deeper
20:27 - level than just passively watching me explain
it to you. Awesome job. Let's move on to the
20:32 - next topic.
20:39 - In the last practice video, I mentioned that
you wouldn't want to end up sticking your
20:43 - entire application right here inside of react
Dom dot render. Imagine having a web page
20:49 - with hundreds of elements on it, this would
just be impossible to maintain. Back when
20:54 - we talked about why react was popular. One
of the reasons we mentioned was reusable web
20:58 - components, we're going to get a chance right
now to learn how to create functional components
21:03 - in react. The reason they're called functional
components is simply because you create them
21:08 - by writing a function, I'm going to add some
space here and create a new function
21:14 - called my app.
21:19 - Notice here that I'm using the constructor
convention of having capital camel case for
21:24 - my component name. This is a very strong convention
that you should adhere to in react always
21:29 - have camel case and start your first letter
as a capital letter. And the really simple
21:35 - thing about functional components Is that
all you need to do is return the JSX that
21:41 - you want this component to represent. So in
our case, we can just take this unordered
21:47 - list and return the unordered list from our
functional component. It's important to know
21:56 - that although in this case, it would work
without it, it's always a good idea to wrap
22:00 - this in parentheses. And then another strong
convention that I really like is to put everything
22:09 - on its own lines. This way, it reads a lot
more like HTML. Then in react Dom dot render,
22:17 - we can create an instance of our functional
component by placing the name of the component
22:23 - and wrapping it in basics tags, you'll notice
that I've made this a self closing tag, there
22:32 - are some instances where you'll want to create
components that can accept children elements.
22:38 - But for the next little while, we're going
to make every component a self closing component.
22:42 - Now notice when I refresh, I have the same
thing that I had before. Though the same rules
22:48 - apply to our functional component as they
did in react Dom dot render, meaning I can't
22:53 - return two different elements next to each
other, like having another ordered, ordered
22:59 - list near this one. That just wouldn't work
because our component needs to return a single
23:05 - JSX element. And here it's returning to, you
can usually get around this by just wrapping
23:11 - everything in a div, or whatever other elements
that you want to wrap it with. In this case,
23:21 - we're just going to return the unordered list.
So maybe you can start to see the power in
23:26 - doing this, we're going to be able to create
our own components, which contain pieces of
23:32 - JSX, which represent HTML in our final product,
and we can start composing them together.
23:38 - Here I have a component that I created rendering,
React elements or JSX elements or HTML elements.
23:48 - But as we create more and more complex applications,
I'm going to be creating components that render
23:53 - other components that I have also created.
Eventually, it needs to boil down to a regular
23:59 - HTML element. But sometimes that can happen
over the course of maybe dozens of your own
24:04 - react components that you created. Eventually,
as we start to create more and more components,
24:10 - we're obviously going to split these into
their own files. But for now, it's important
24:14 - to play with this and see what you can get
to work, what doesn't work and get a really
24:19 - good idea of how a functional component works.
As we move on, we'll start to make our file
24:24 - structure more and more complex. Now that
we've learned about basic functional components,
24:29 - let's put it to practice.
24:31 - Okay, let's get some practice of functional
components in. One of the things we really
24:41 - pride ourselves at V school when we're teaching
our curriculum is that we include a lot of
24:46 - spaced learning and repetition, which is a
principle of teaching that helps people retain
24:51 - as much information as possible. As such,
like before, I haven't included any boilerplate
24:55 - code for you to start with. So it's going
to be up to you to build everything from Scratch
25:00 - during this kind of repetition is going to
be really good for your memory and should
25:03 - help you really understand the concepts. So
let's go for the objectives you have. First,
25:08 - you're going to set up the basic react code
from scratch again. And then you'll need to
25:12 - create a functional component called my info
that has an h1 with your name a paragraph
25:17 - with some information about yourself, and
an ordered or unordered list of the top three
25:22 - vacation spots you'd like to visit. Obviously,
since we're not going to be grading this or
25:26 - anything, you're welcome to change this to
whatever UI you'd prefer to present. And then
25:31 - you'll need to make sure to render the instance
of your functional component to the browser.
25:35 - If you want a little extra challenge. Although
we haven't yet gone over how to style your
25:40 - components, feel free to search on Google
how you can add some style to your page. If
25:44 - it's enough of a challenge, just getting the
functional component working, then don't worry
25:48 - about that we're going to cover styling in
a future lesson. One less thing before I give
25:52 - you some space to pause the video and try
this out for yourself, I will once again get
25:56 - on my soapbox for the last time, I promise
that you should definitely actually do this
26:01 - exercise. If you're hoping to get from this
course, a real understanding of how react
26:05 - works just passively watching isn't going
to do it. So please take the time to actually
26:09 - do this. Okay, I won't mention that again.
So go ahead, pause the video. And we'll pick
26:14 - up in just a few seconds and solve this together.
26:19 - Alright, so like last time, we need to start
with some of the boilerplate code, we're going
26:27 - to once again import, React from react, import,
React DOM,
26:37 - React DOM.
26:38 - And this is going to be a little out of order.
But I already know that I need to render something
26:45 - to the page, they already know that I'm going
to call my component my info. So I'm going
26:51 - to put an instance of my info right here.
And lastly, I'm going to do my get element
27:03 - by ID route. So that render knows where to
put the my input component. Okay, now the
27:09 - more fun part, let's build our function. Remember,
the one thing that the functional component
27:18 - needs to do is return the so to speak HTML
that we're going to be putting in the page.
27:23 - In reality, as you know, it's actually JSX.
But sometimes it's helpful just to think of
27:28 - it as HTML. Since I already know this is going
to cover multiple lines, I'm going to put
27:33 - everything inside of parentheses. Now one
thing you may have tried to do just by habit
27:39 - is putting an h1
27:41 - and
27:43 - putting your name and then going to the next
line and trying to put a
27:50 - paragraph.
27:52 - But think for a second what the problem with
this is. If you realize that the reason this
28:05 - is a problem, you may have tried to save this
and it says adjacent JSX elements must be
28:09 - wrapped in a enclosing div for an enclosing
tag. So I'm going to put this whole thing
28:15 - in a div. And it's a very common mistake to
make, especially as you're starting.
28:20 - So if you made that mistake, don't worry about
it. Okay, right here, we should have something
28:25 - that is at least working. So I'm going to
save this and see if it renders and there
28:28 - we go, we have a good start, all I need to
do is add my unordered list and put a few
28:42 - list items in there. And I've always wanted
to visit Thailand, let's say Japan. And I've
28:51 - never been to the Nordic countries. So we'll
just add Nordic countries in general. And
28:59 - when I save this, I should see that my list
shows up in the browser. As a reminder, if
29:05 - you look in the very upper right, there's
a little left arrow. If you press that and
29:08 - open the side menu, there's a chance to ask
questions on any pieces of code you're unfamiliar
29:13 - with or didn't understand. And I'm going to
be trying to check these as often as I can.
29:18 - So if you ask a question there, I'll try to
get back to you as soon as I can. Also, just
29:22 - because we finished this example, don't be
afraid to spend some time playing with this
29:26 - code a little bit more before moving on. Again,
the more you get your hands on the code and
29:31 - actually play with things, the more likely
this information is to actually stick and
29:34 - for you to be able to be productive with react.
Once you feel pretty comfortable with everything
29:39 - we've covered so far. Let's move on to the
next lesson. Let's talk really quickly about
29:48 - our setup here. Right now we have our functional
component inside of our index.js. But remember,
29:54 - one of the main benefits of react is that
we get to create a lot of our own components.
29:58 - Eventually, we're not going to be able to
To put everything right here in this file,
30:02 - so what we need to do is we need to take our
my info component and move it into its own
30:06 - file. And it's a pretty good convention to
have each file contain just one react component.
30:12 - So the first thing I'm going to do is create
a new file. And there's a quirk of Scripture
30:15 - right now that you won't be able to see me
typing this video, I'm going to right click
30:19 - up here by file since a new file and a dialog
box just popped up for me, and I'm going to
30:24 - give it the same name, my info as my component
with the same capital camelcase and everything.
30:30 - And you should see it pop up here now and
notice that the file, my info is spelled exactly
30:35 - the same with the same capitalization as my
component. That's a really good idea, because
30:39 - it will make things a lot easier for you when
you're looking through a complex project tree.
30:44 - The next thing I need to do is take this component
out of this file, so I'm going to cut it,
30:50 - go over to my info dot j s, and paste it in.
There's a few issues here. You may remember
30:57 - in one of the early videos, we talked about
why we import react from react, even though
31:02 - we're not using react anywhere, try to think
if you remember why that is. The reason we
31:09 - had to do that was because of our JSX. We
used to have this component here and it contained
31:14 - JSX. The computer won't know what this is
because it's not normally valid JavaScript.
31:20 - But the React library helps it become legitimate
JavaScript, which means we undo that back
31:26 - over in my info.js. Anywhere we're going to
be using JSX, we need to make sure to import
31:32 - react. Almost every react component you create
is going to have this line in it. The last
31:41 - thing we need to do is make this function
my info available to other places in my application.
31:47 - The way I need to do that is by exporting
it. If you don't feel totally familiar with
31:57 - import exports from ESX, that should be okay,
as long as you remember this export default
32:02 - and then the name of your component. But I
would also recommend that you go check out
32:06 - the free introduction to s6 course here on
screen. But now that this component is exposed
32:12 - through the export default, I'm going to go
over to index dot j s. And let's just Command
32:17 - S, we'll save this and see what comes up.
Notice it says my info is not defined. Well,
32:22 - that's because we used to be declaring that
function here in this file and making an instance
32:27 - of it by putting these braces around it. But
now we're not doing that. So we need to import
32:34 - my info from my info dot j s, that's really
easy to forget that we can't just say my info
32:42 - dot j s. reason is because when imports don't
have a relative path, they will automatically
32:49 - look for a module with the same name that
you're providing. This works okay with react
32:55 - and react Dom because they are third party
modules or dependencies that I've installed
33:00 - into this project. When it's one of my very
own modules, or one of my very own files,
33:05 - I need to make sure to provide a path. So
I'm going to say dot slash, which means from
33:09 - the current directory, look for a file called
my info dot j s. Another important thing to
33:14 - know about imports is that they assume that
you're importing a j s file or in other words,
33:20 - dot j s is the default extension. So I can
delete dot j s, and it will still work just
33:26 - fine. Now if I refresh, you get my component
back in the browser on the right. As your
33:32 - project gets more and more complex, it's going
to be really important that you have a good
33:35 - organizational structure. One simple organizational
structure I can employ right now is by creating
33:40 - a new folder called components where I'm going
to put all of my components in. So I'm going
33:45 - to create a new folder. I like components.
And I'm going to drag my info dot j s into
33:52 - components and looking back@index.js what
do you think I'll need to fix here. If you
34:01 - notice that the path to my my info file is
now incorrect, because it's no longer inside
34:07 - of the root directory, I need to provide dot
slash components slash my info. And when I
34:15 - save this, everything should be working just
fine. Having a components folder is to me
34:20 - a little bit of an oversimplified way to organize
your application, because you're going to
34:24 - have so many components that you create that
you're going to need to find a structure that
34:28 - works best for you. And I'm not going to offer
one that works best. You'll probably even
34:33 - see me throughout this course using a few
different types. But each person has their
34:37 - own opinions about what the best organizational
structure is. And it definitely depends on
34:41 - the project as well. Before moving on, try
playing with this a little bit. Maybe go change
34:45 - some code inside of my info, or maybe move
it into another folder or change the file
34:51 - name and see what you need to fix in order
for everything to keep working. Or if you're
34:55 - really wanting to be forward thinking you're
welcome to try and create a new component
34:59 - and nest that inside of my info, but this
is actually what we're going to cover in the
35:03 - next lesson. Once you feel comfortable with
everything we've talked about here, let's
35:07 - move on.
35:12 - In this lesson, we're going to talk about
parent and child components, our applications
35:16 - are going to be much more complex than just
having a single component my info, for example,
35:20 - render to the DOM. Instead, you're going to
have a complex hierarchy of components that
35:25 - eventually lead down to JSX elements. I'm
going to start from scratch here just for
35:29 - repetition sake, so bear with me.
35:41 - Take a second to see if you can remember what
the next step is, you can start with something
35:44 - simple like getting HelloWorld as an h1 to
show up in our browser. In order for anything
35:52 - to show up on the page, we need to use react
Dom dot render. first parameter is what we
35:58 - want to render, so maybe h1
36:02 - hello world.
36:08 - The second parameter is where do we want to
put that we'll be in an element called route
36:17 - in our index dot HTML. If any of that's confusing,
make sure to go back and review some of the
36:23 - previous lessons. But I'll assume that that
makes sense from now on. I refresh my browser,
36:30 - I get hello world. But we've moved past this
so far. Instead of having an h1 here, we put
36:35 - my info in less time. Instead, this time around,
let's create a component called app. An app
36:43 - is going to be an entry point into our entire
application. In order for this not to fail,
36:47 - we need to import app. And in order for this
not to fail, because that component doesn't
36:57 - exist yet, we need to create it. So I'm going
to create a file called app dot j s. Notice
37:04 - it has a capital A because it's a react component.
In app.js, I need to remember always to import
37:10 - react. And before I forget, I'm going to export
default app works at this point app doesn't
37:18 - exist. So let's create it. Before I put anything
in the return, I'm going to refresh the browser
37:29 - really quick. And notice that there's a problem.
See if you can remember what we need to return
37:33 - here inside of this component.
37:37 - I need some kind of JSX element. So I might
put an h1 Hello, again, refresh. There we
37:50 - go. Or I could put any kind of other HTML
in here as well,
37:59 - maybe a div.
38:03 - Inside I have an h1, maybe something like
an unordered list. Maybe at this point, I
38:16 - decided that I want this to be an actual website
and I start putting things together. So this
38:20 - top section might be a navbar. And below the
nav I might put a main section where most
38:30 - of my content will go. And at this point,
I would do something like add some styling
38:38 - to my unordered list so that this was more
like an F bar. As you can see, this app component
38:43 - is getting pretty large. And it's kind of
defeating the purpose of react, we talked
38:47 - about how we can take each piece of HTML and
put it into its own component. We're not really
38:52 - doing that very well here. Instead, we may
decide to create separate components for each
38:56 - little piece of HTML that we need on our page.
Take a look at this diagram to get a better
39:01 - understanding of what I'm talking about. Here
we're rendering the app component, but app
39:07 - may decide to render another component called
my info where my info may eventually render
39:12 - some kind of regular JSX element. Notice I'm
making a distinction between components and
39:17 - elements. elements are the ones that boil
down essentially to regular HTML code. Notice
39:23 - that here I have a lowercase D and Dev. That's
a dead giveaway that this is a regular element
39:28 - rather than a component that I've created.
On the other hand, my info starts with a capital
39:33 - M. And that helps me understand that this
is a component that I've created. You may
39:37 - have heard of how the DOM or document object
model is oftentimes referred to as a tree
39:41 - where the HTML element is the most base root
of that tree. In our case, we can think of
39:47 - the app component as being the root of this
tree. And the app component isn't limited
39:53 - to just rendering my info. It could also render,
for example, a footer and that footer could
39:59 - render an app actual element called footer,
which has all of the HTML relating to our
40:04 - footer in it. And if we have a footer, we
naturally probably want some kind of header.
40:09 - I've specified these as awesome header and
awesome footer. So it's not to be confusing
40:14 - with the regular footer element. And just
like app is rendering more than one component
40:20 - header may also render multiple components,
for example, a navbar, but also maybe a logo
40:26 - component. And those eventually would need
to end up as regular elements of some sort,
40:32 - in this case, an image element and the nav
element. Hopefully, here, you can start to
40:37 - see how our react application could become
more and more complex as time goes on. And
40:42 - this is only scratching the surface. So in
our sample app here, let's create a little
40:47 - footer really quick, going to create a new
file called footer dot j, s with a capital
40:52 - F, as seen here, which you'll need to import
react from react is always going to export
41:04 - the thing before I even create it just so
that I don't forget.
41:18 - Notice here the difference between the capital
F footer and the lowercase f footer. As I
41:23 - mentioned before, the lowercase f footer is
the actual element that will get rendered
41:27 - to the screen. Whereas the capital F footer
is the component that I'm creating. It's just
41:32 - a function with a name. Inside here, I may
put, I don't know an h3. This is my footer.
41:44 - I've created this component. But notice it's
not showing up on our page. That's because
41:48 - our app is not rendering a footer anywhere
and need that footer in this file in order
41:54 - to create an instance of it. So I'm going
to import
41:57 - footer
42:00 - from dot slash footer. And maybe right under
my main section, I'll include the capital
42:06 - F footer that I just imported. refresh this
now.
42:10 - There's my footer element.
42:13 - At this point, I have kind of a strange mixture
of elements that are regular JSX elements
42:20 - being mixed in with components that I have
here. If I can, I really like to have this
42:25 - app component almost be like a table of contents,
where instead of having some elements in some
42:32 - components, it's mostly just components. So
this might look like this. header, main content,
42:44 - and footer. And then I can go to each of those
individual components and see what elements
42:48 - those are rendering. Now header and main content
don't actually exist. But the point is, you
42:53 - can continue to nest your components as deeply
as you need, we're going to get a chance to
42:57 - practice this in the upcoming lesson. But
if you'd like you can spend some time trying
43:02 - to fix this code. Since header and main content
currently don't exist, go ahead and create
43:05 - them. Also, before we move on, feel free to
click in the blue slides in the lower left
43:10 - to check out that diagram once again. Once
you feel pretty comfortable, let's move on
43:14 - to the practice. Okay, let's jump right into
the challenge, you're gonna set up a react
43:23 - app from scratch. Once again, what you're
going to render is the root app component,
43:29 - as mentioned here, and that app component
should render three separate components, each
43:34 - of which will have some kind of elements that
they render, first, a navbar component. Second,
43:40 - a main content component, and third, a footer
component. So give this your very best shot.
43:46 - Remember, you can always turn to Google for
help. Once you think you have this challenge,
43:50 - then move on with the video and we're going
to do this together. Okay, let's get started.
43:57 - We're going to import react
44:00 - from react,
44:03 - React DOM,
44:05 - React DOM,
44:06 - we're going to use react Gmes render method
to render a component called app ranks you
44:14 - select the root element app doesn't exist,
so we need to import it. That file doesn't
44:26 - exist, so we need to create it
44:28 - epital a app dot j s. Remember, I like to
treat this file as kind of a table of contents.
44:36 - So we'll need to import react from react again.
44:41 - At this point, I'd like to just put something
on the page to make sure that I'm on the right
44:54 - track. Okay, at least not showing up tonight.
No, I haven't made a mistake up to this point.
45:05 - If you look back in the challenge, it said
to create a navbar main content and footer
45:09 - components, we could do this in any order,
we could first create the files, and then
45:14 - import them, we could import them and create
instances here and then create the files,
45:19 - whichever way you want to do and makes most
sense to you is totally fine. I'm gonna finish
45:23 - my app component first,
45:25 - and then
45:26 - go create the components necessary for that
to continue working. And remember, everything
45:30 - needs to be surrounded in a single component,
because any given component can only return
45:36 - one element. Here, I'll put my header
45:46 - content
45:50 - and footer.
45:51 - Up GS needs to know about those first, so
I will import those. And those files don't
45:59 - exist yet. So I'm going to create, you can
imagine as I keep creating new components
46:04 - that this is going to get pretty cluttered.
So I'm actually going to put everything into
46:07 - a components folder. drag my footer, header,
and main content into my components folder.
46:16 - I also need to fix my app j s. References
here. Okay, over in those files, I'm going
46:30 - to start creating those components. This will
just have a basic footer element. For now,
46:42 - I'm just going to fill it with some text because
it's not too important what's there. If creating
46:50 - these components is still a little bit foreign
to you, and you have to remember what step
46:54 - comes next, I'd recommend actually retyping
everything from scratch. Because I've done
46:58 - this enough times, I'm actually just going
to copy everything and paste it into header
47:04 - changing some of the references.
47:10 - It'd be the same thing for main content. elicit
this just says main instead of main content,
47:22 - and that it's got a lowercase M. Hopefully
you understand at this point that this is
47:27 - because this is a regular, you could say HTML
element, main, header and footer are all semantic
47:34 - html5 elements. main content, however, is
something that I created. And so I couldn't
47:40 - say something like main content, because it's
not a real HTML element. Let me refresh the
47:48 - page and see if it's working. Okay, it's pretty
boring. And it looks like I forgot to put
47:53 - this is the main section. Right. In the next
couple videos, we're going to learn about
47:59 - actually styling this because this is pretty
awful. And we want this to start looking good.
48:04 - Once again, feel free to pause the screencast
and play with the code that we have here.
48:08 - Or if any of this was still confusing, go
back to the beginning and try it again from
48:11 - scratch. Once you feel comfortable, let's
move on.
48:18 - Alright, so from what we've learned so far,
we can get started on our phase one of our
48:24 - to do application. So what you'll do is you
will initialize a new react app from scratch,
48:30 - you're going to render an app component in
the index js file here, which means you'll
48:36 - need to create an app component from scratch.
And your app component should render three
48:41 - or four checkboxes with the paragraphs or
spans or whatever kind of text you want next
48:45 - to it as if you're making a to do list with
some hard coded items already in it. So pause
48:50 - the lesson here and give this a try. And then
we'll go over this together. Okay, so let's
48:59 - do this. I'm going to erase my comments here.
And as always, we need to import react from
49:05 - react,
49:06 - import, in this case, React Dom from react
DOM. We're gonna use react Dom to render an
49:18 - app component to the screen. And we want that
to be in the element with the ID
49:24 - of route.
49:25 - The app component doesn't exist yet. So we
need to import it. And this file doesn't exist
49:33 - yet. So I'm going to create it. We'll move
over to that file. Now. Where I want to also
49:40 - import react from react will create it our
functional component and want to remember
49:50 - to export it before we forget. This functional
component should return
49:57 - the div
49:58 - will need to wrap everything in it. Because
it can only return one element at a time.
50:04 - And inside this div, we will put our input
type checkbox. And our paragraph. For now
50:13 - we'll just put some placeholder text. You
save this and see how it looks. Okay? It's
50:20 - pretty ugly. But we're going to get to that
later. And it said to do three or four times,
50:24 - so I'm just going to copy and paste these
two lines here. And there we go, we've started
50:31 - our application. That's pretty straightforward.
And the next time we see this, we're going
50:35 - to have learned about styling. And we're going
to add some style to this, so it isn't quite
50:39 - so ugly. So if anything was confusing, go
back and play with this. Again, try to do
50:43 - everything from scratch if you'd like, feel
free to post a question in the q&a section.
50:49 - And when you're ready, let's move on to learn
more about styling.
50:56 - This example is the same one that we finished
with at the end of the practice in the previous
51:00 - lesson. And I wanted to take some time to
learn how to style this. Now, there's actually
51:05 - a bunch of different ways to style things
in react. And we're going to start with the
51:08 - one that's probably the most familiar to you.
And that's just using CSS classes in CSS rules
51:14 - on those classes. Let's drill down the tree
here and see where we can actually start putting
51:19 - some classes. You'll see on my index js, I'm
rendering an app component. And the app component
51:26 - is rendering a div with three other components
header, main content and footer components.
51:32 - And each one of those is just a basic component
that either has a single element as part of
51:37 - it with some text inside, let's focus our
efforts on styling the header. And normally,
51:42 - what you do in HTML, when you're going to
add a class to something is you add a new
51:46 - property called
51:47 - class.
51:49 - But one thing we need to remember right here
is that we're not actually dealing with HTML.
51:52 - Instead, we're dealing with a variation of
JavaScript JSX. And something you'll just
51:57 - have to remember with JSX is that using class
as a property name doesn't really fly. Instead,
52:04 - we need to use something called class name
52:06 - with a capital N.
52:07 - A lot of places will tell you the reason that
you have to do that is because class is a
52:12 - reserved keyword in JavaScript. But the truth
is underneath JSX is just using the vanilla
52:18 - JavaScript Dom API. And if you've ever used
the vanilla JavaScript Dom API, you'll have
52:24 - something like document dot get element by
ID, something. If you wanted to add a class
52:31 - to that, you could say dot last name, plus
equals and then add a new last name. I prefer
52:43 - class list myself because it has properties
that you can use to add and remove classes.
52:48 - But that's beside the point. Class Name is
an underlying JavaScript Dom API property.
52:54 - And so using class name as part of our JSX
is simply a way to access that Dom API under
53:01 - the hood, which is what JSX and react is doing.
That's just a little bit of extra background
53:06 - that you may or may not be interested in knowing.
But the point is, all you need to do is wherever
53:10 - you normally would say class in HTML use class
name instead. Here I'm going to say class
53:16 - name equals
53:17 - F bar.
53:19 - I'm going to delete this before it becomes
a problem. Then over in my style, that CSS,
53:25 - I just need to select the navbar and include
whatever styles I want. For example, I might
53:30 - change the background color to purple. If
I save and refresh this, you can see that
53:38 - now the background color is purple. I'm going
to copy and paste in some style since this
53:42 - isn't a course on CSS, so that we can get
something that actually looks pretty good.
53:47 - Okay, the only thing I've done here was added
a zero margin to the body so that it went
53:51 - all the way to the edge, and a number of styles
to the navbar. If you're interested in actually
53:57 - checking this out, feel free to pause the
video. But the point is everything that you
54:01 - normally do in CSS is going to be essentially
the same as you do here. The only change we've
54:06 - made so far remember is that we have to use
class name instead of class. One of the other
54:11 - things to keep in mind that maybe tricky to
remember at first is that you can only apply
54:16 - the class name attribute to react elements
like header or paragraph or h1. If you try
54:22 - to apply class name to a component that you've
created, such as header or main content, it's
54:29 - going to do something a little bit different
than you think. And we're going to talk more
54:33 - about that in the future. But for now, just
remember that the only thing you can apply
54:36 - classname to are react elements and not react
components, the things that look basically
54:43 - like regular HTML. Another thing that can
be kind of tricky in the beginning is if you're
54:48 - using something that requires different levels
of your tree hierarchy, like Flexbox or CSS
54:54 - Grid, where you need to know which items are
the flex container and which items are the
54:58 - flex items. be tricky looking at your component
to know exactly how that works. For example,
55:04 - if I wanted to make this div a flex container,
and I wanted to specifically style one of
55:09 - the items they're in, I would need to go to
the header component or the main content component.
55:15 - And look at the elements, they're in order
to give them the class names that are necessary.
55:21 - For example, if I go to header js, this header
element will be the direct child of this div.
55:29 - Think of it as react, taking the contents
that this header component is returning, and
55:35 - copying and pasting it into this place. When
you create your react applications and you
55:40 - inspect with the dev tools, you'll see that
this is actually how things end up in the
55:45 - DOM tree. So take some time to play with classname.
In this project, see if you can style the
55:52 - main section in the footer a little bit differently.
And once you feel good, let's move on to the
55:56 - next lesson.
56:02 - Before we get too much further, I wanted to
cover some caveats about the way that I tend
56:06 - to write my JavaScript, you may have noticed
that I tend to leave out things like semi
56:11 - colons, you may be super used to putting semicolons
everywhere at the end of a statement, I personally
56:16 - have recently decided that I kind of hate
them. And so I've been removing them from
56:21 - my code. Obviously, there's still some places
that you simply can't avoid them. For example,
56:26 - when you're writing a C style for loop, zero
semicolon that's necessary in order to separate
56:35 - the three different statements on one line.
But for the most part, at the end of statements,
56:40 - they're not really required, and they won't
break anything by not having them there. This
56:45 - is totally a personal style decision. And
like I said, one that I've only recently made.
56:50 - In fact, it's such a strong habit for me that
I may accidentally put some semi colons in
56:54 - future videos. Another personal preference
is although ESX technically gives us the ability
57:00 - to put arrow functions everywhere, we used
to have the function keyword. For example,
57:04 - I can say const app equals an arrow function.
And one of the benefits of this is actually
57:12 - that I can actually just wrap everything in
parentheses and get rid of my return. And
57:24 - in this case, I could even simplify it like
this. I've either not yet gotten used to this
57:31 - syntax, or I simply don't care that much for
the look of an arrow function. I think they're
57:37 - extremely useful in certain instances, for
example, whenever you normally would put an
57:41 - anonymous function or when you need to write
a class method, which we'll talk about later.
57:47 - But my personal preference is to keep the
function keyword and it just to me makes it
57:52 - look a lot more like a regular function component.
There's a lot of people who will disagree
57:56 - with that. And I'm totally fine with that
I totally understand the preference for doing
58:01 - it as an arrow function. But me personally,
I tend to keep my function keyword in there
58:05 - for my functional components. I'm not going
to necessarily advocate for one way or the
58:09 - other. So that's totally a decision that's
up to you. Okay, I just wanted to get some
58:13 - of that out of the way. Let's move on.
58:16 - Before we can move on to talk about inline
styles and some dynamic styles, we first need
58:24 - to understand how JSX and JavaScript play
together, we saw that in the middle of our
58:28 - JavaScript, we're able to return something
that looks like HTML, but we've discovered
58:33 - is actually JSX. What if I have a variable
that I want to stick inside of my h1? Maybe
58:39 - for example, I have a first name and the last
name. And instead of saying hello world, I
58:49 - want to say hello, Bob's a role. Well, I might
be tempted to say hello, and then first name,
58:56 - plus space plus last name. But I'm assuming
you can figure out exactly what's going to
59:03 - happen here. When I save this. It literally
interprets every character that I typed as
59:08 - if it were the text inside of the h1, which
is pretty much exactly what we should expect
59:13 - it to do. So how do we jump into JavaScript
while we're in the middle of our JSX, they
59:19 - actually made it really simple. All we have
to do is surround any JavaScript that we want
59:23 - to be interpreted with curly braces. And once
I refresh this, you'll see that it actually
59:30 - interpreted everything inside of the curly
braces as JavaScript. The way I like to think
59:35 - of this is we're looking at JavaScript, JavaScript,
JavaScript, JavaScript, and now we're in JSX
59:41 - land. Once we're in JSX land, which actually
started with this less than symbol, everything
59:47 - will be treated as if it were regular HTML,
meaning any text inside is going to be literally
59:52 - interpreted. However, as soon as we want to
get back into JavaScript, we put a curly brace
59:58 - and now we're back into JavaScript. Learned
JavaScript JavaScript JavaScript, closing
60:03 - curly brace tells me we want to leave JavaScript
and go back into JSX. And you can do pretty
60:09 - complex JavaScript operations inside here.
Since we've mostly converted over to the e6
60:15 - syntax, I'm actually going to change this
to the string templating syntax of ESX, where
60:20 - you put backticks, and then $1, sign curly
brace surrounding any variables that I want
60:25 - to show up, then I can just put a space itself,
and that will be treated as a literal text
60:31 - space, then $1, sign curly braces again, last
name. And I save that and you see, we get
60:36 - the same result over in the browser. Because
this is just regular JavaScript inside pretty
60:40 - much anything that I could regularly do in
JavaScript I can do inside of these curly
60:45 - braces. Let's look at one really simple example.
Maybe when it's morning, I wanted to say good
60:51 - morning. And when it's night, I wanted to
say goodnight, without actually having to
60:54 - come in and change the code manually. Well,
I can just do some simple JavaScript to set
61:00 - that up. I'm gonna speed this up really quick,
but we'll get a chance to explain it in a
61:05 - second. Here, you can see one example where
I've created a new date instance, and simply
61:10 - put in my h1 It is currently about. And then
in JavaScript, I got the hours and did a modular
61:17 - 12, so that it would be in a 12 hour clock
system. Alternatively, I could check the current
61:22 - hours for what time of day it is, and set
a string equal to either morning, afternoon
61:28 - or night, which let's try that out right now.
So here, all I did was set a variable called
61:35 - time of day, and did a simple if else, to
check what time of day it was. Then down here,
61:41 - I simply said good, jumped into JavaScript.
And said time of day, when I refresh this,
61:48 - I get good night. Because it's nighttime where
I'm recording this, hopefully, you can start
61:53 - to see the possibilities that this brings.
And we're gonna see as the course moves on
61:57 - that this is actually really useful. We needed
to see this right here simply so that in the
62:02 - next video, when we talk about inline styling
with the style property, the way that we have
62:06 - to do that, we'll make a little bit more sense.
Feel free to mess with this, there's some
62:10 - pretty fun things you can do. Once you're
ready, let's move on.
62:19 - Let's pick up really quick where we left off
in the previous video, we created this little
62:23 - application to tell you what time of day it
was. Essentially, we want to add some styles
62:27 - with inline styles this time, and we're going
to see why this might be the way we choose
62:31 - to do it instead of using a class name. Normally,
to do inline styling with HTML, we simply
62:37 - put a style property and set it equal to whatever
CSS styles we want. Maybe we want to change
62:44 - the color to be this kind of yellowy color
that I just grabbed. Well, let's see what
62:49 - happens when I try to save this. Let me open
the console. Notice that it says the style
62:55 - prop expects a mapping from style properties
to values instead of a string. We have to
63:00 - remember here that we're not actually inside
of HTML. So sometimes the rules are going
63:05 - to be a little bit different. In this case,
JSX expects style to not be a string, but
63:11 - instead to be an object, a JavaScript object.
So I'm going to delete this and put in an
63:17 - object and say, color colon, and then as a
string. That color again, notice that I have
63:25 - some syntax problems. Remember, anytime I
want to change from JSX into JavaScript, I
63:31 - need to wrap my JavaScript with a set of curly
braces. This can be a little confusing at
63:36 - first, because objects are also wrapped with
curly braces. But in order for this to be
63:40 - a JavaScript object, I need to wrap it in
curly braces. So we end up with two sets of
63:45 - curly braces. Now when I refresh this, you'll
see that I get my more orange or yellow color
63:50 - as the color of this text. If I want to add
additional styles, because this is an object,
63:55 - I just add another key value pair. For example,
maybe I want it to have a background color
64:03 - of
64:04 - this somewhat red or color that I got. Well,
what's my problem now take a second to see
64:08 - if you can figure out what's going on. Remember,
because of this set of curly braces over here,
64:16 - we're actually inside of JavaScript. And inside
of JavaScript, I can't have a dash in the
64:21 - middle of my property name.
64:23 - I technically can
64:25 - in regular JavaScript by surrounding this
with quotes, but that's beside the point.
64:30 - Because of this inside of the object where
we're defining our styles. We're going to
64:35 - change anytime that there's a dash, we're
going to get rid of the dash and make everything
64:39 - camelcase. This right here is the legitimate
style object. Let me refresh. And you can
64:45 - see now we have a different background color.
As you might imagine, this style object right
64:50 - here may end up getting longer and longer,
in which case this h1 line is going to become
64:57 - really long and it looks a little bit ugly.
to split this out onto separate lines, so
65:02 - what I prefer to do is actually make a separate
variable. Let's just generically call it styles
65:07 - for now. And put this entire object into that
variable. We can split this onto its own lines
65:16 - without it looking funny. inside of my curly
braces here, where I'm now inside of JavaScript,
65:24 - I can just put variable name. And that's going
to be exactly the same thing. Notice when
65:29 - I save, it continues to work. What's nice
about this is as I continue to add styles,
65:34 - it doesn't clutter up my h1 down on line 24.
There's a number of little tiny quirks that
65:40 - we have to remember when we're doing these
style objects. For example, anytime I have
65:45 - a measurement that's going to be in pixels,
I technically can just put
65:49 - the actual number value in place, and the
default will be pixels. So when I save this,
65:56 - you see that I get a slightly smaller font.
65:58 - But 200, I get a really big font, and so forth.
I can also still specify pixels. But obviously,
66:07 - that's not going to work with numbers by putting
200 pX because that's not valid JavaScript
66:11 - anymore, I need to turn this into a string.
And now it's valid JavaScript again. And then
66:18 - anytime I want to use another unit like M
or VW or percentage or something like that,
66:25 - I will also put that as a string. Also notice
once again, that I've replaced the dash with
66:30 - a camel cased version of font size. There
are some pretty interesting limitations with
66:36 - this. For example, it looks pretty funny when
you have to add things like vendor prefixes.
66:40 - But there's other things like pseudo selectors,
such as colon hover, that become actually
66:45 - impossible to do inside of these inline styles.
If you need something like that, for now,
66:50 - you're better off just doing that in CSS and
using class name. And in the future, you can
66:54 - learn about really cool styling libraries,
such as styled components. For now, we're
66:59 - just going to keep it simple and stick with
either inline styling or using class name
67:03 - and using CSS styles. You may ask yourself
why you would ever want to even use an inline
67:07 - style like this. Well, one reason is that
you may want something to be more dynamic,
67:12 - in which case JavaScript would actually determine
what the styles are. Let's take a quick look
67:17 - at what that might look like. Notice what
I've done here, where I moved the styles up
67:23 - here above my if else, and set a default font
size of 30 pixels, then I let my if else in
67:30 - my JavaScript actually determine what color
the font is going to be, I changed not only
67:35 - the time of day string, but I also changed
the color property of my styles object. Because
67:41 - it's an object, I can access and create properties
just by using the dot syntax. If it's morning
67:47 - time, I use this color. If it's afternoon,
I use this color instead. And in any other
67:52 - case, when it's night, I use this color instead.
Because I'm recording this at night. This
67:56 - red color is the one that's actually showing
up. But let's see what happens when I create
68:01 - the date not for the current time. But instead
for a time that was this morning. This is
68:08 - the year,
68:09 - a month today.
68:10 - Let's say it's 10am. I save this, notice that
we get instead the color that is the color
68:16 - for morning. If I change this to, let's say
15. And it's hard to see, let me choose a
68:22 - different color for the afternoon.
68:29 - You can see a little more clearly this is
choosing a different color for the afternoon.
68:34 - This may be a little bit contrived. But the
point is we can have dynamic data that actually
68:39 - changes the way that our hard coded components
display. Take a second to try and think of
68:46 - different things that you may be able to accomplish
by having these kinds of inline styles. I'd
68:53 - also at this point, recommend spending as
much time as you can to really solidify the
68:57 - stuff that we've covered together. So far,
we're about to come up on a topic that typically
69:02 - is a little bit challenging for some people
to really help you to make sure that you understand
69:06 - everything we've talked about up until now.
In the next lesson, we're going to talk about
69:10 - a concept called props, and how we can make
our components quite a bit more reusable.
69:15 - Props is a super exciting topic. And we're
about to get into parts of react that make
69:19 - it extremely useful. So get excited. And let's
move on to the next video when you're ready.
69:25 - Alright, so let's pick up where we left off
with the to do list. Now that we understand
69:34 - Parent Child components and how a parent component
can render a child component, and we understand
69:39 - how to inject some styling into our react
apps. Let's progress our to do list forward
69:44 - a little bit. So before we get to styling,
what I want you to do is to take these input
69:49 - and paragraph pairs, and I want you to put
them into their own component called to do
69:55 - item. For now it will still have just this
hard coded placeholder text here paragraph
69:59 - And later, we're going to learn how we can
actually make those different. But that'll
70:03 - be the first thing to start with. And then
essentially, you have a blank canvas to paint
70:08 - whatever kind of picture you want, you can
make this look as traditional or as weird
70:12 - as you'd like. So go ahead and hit pause and
give that a try. Alright, so the first thing
70:22 - is moving each of these into their own component.
So I'm just going to copy this and create
70:28 - a new file called to do item dot j s. And
while I'm still here, I'm going to import
70:37 - the new item from that file. Let's go over
to to do item, we'll import react from react,
70:47 - create our functional component, we'll just
return the thing that we copied before. And
70:56 - remember, I can only have one element that
I'm returning at a time. So I'll wrap this
71:01 - all in a div. And then over in app j s, we
don't need these anymore. But instead, we
71:08 - can just create instances of our to do items.
And everything looks the same. Now since this
71:15 - isn't necessarily a course on styling with
CSS, I'm basically going to cheat right now,
71:20 - I'm going to set myself up by creating a class
here of to do list. And over in my to do items,
71:29 - I'm going to give this div a class name of
your item. And I'm basically just going to
71:36 - paste the styles that I've already created.
Okay, and you'll notice that let me make this
71:42 - a little bit bigger. And notice that I just
kind of came up with a cool little paper looking
71:48 - stack and have a checkbox next to each one
that's a little bit prettier, with nicer font
71:54 - and little separation and so forth. Obviously,
you're welcome to pause this and look through
71:58 - some of the styles that I have. But it's really
nothing too fancy. And since I'm not really
72:03 - a wizard at CSS, stuff like this, with the
cool little effect on there, I basically just
72:07 - found online. main takeaways, though are to
remember that if you want to apply class to
72:13 - your elements, you'll need to use class name
instead of class. And if you wanted, you could
72:18 - apply some of these styles just right here
in line. So with a little bit of CSS styling,
72:24 - our to do list is already looking a lot better
than it was. Now we are checkboxes do technically
72:30 - check and uncheck but what we're going to
do is make sure that when we check these,
72:35 - some actual data is changed, which will allow
us to do something cool, like put a little
72:41 - strike through through these texts. Once you
feel pretty comfortable with this, let's move
72:45 - on.
72:51 - Let's talk first about the concept of props
in react. To do so we're going to look at
72:55 - just a regular HTML file, notice that this
has nothing to do with react. This is just
72:59 - a basic index dot HTML, I want you to take
a close look at the three elements that I've
73:04 - put inside the body, the anchor, the input
and the image and think about what's actually
73:07 - wrong with them right now. None of these things
are actually going to do anything important.
73:14 - anchor tags need an H ref for them to make
any sense at all. This way, the HTML spec
73:20 - can define the anchor tag once and allow us
the ability to change the place that the link
73:26 - sends us. For example, here, I may put a link
to Google. Or obviously, wherever I want to
73:34 - send the user to in this link, an image tag
is very similar. An image tag alone without
73:40 - the source property is pretty useless. An
image element needs a source in order to function
73:46 - correctly. This may either be the path to
a local file or the URL to an image hosted
73:52 - online. In those two examples with anchors
and images, the href and source properties
73:58 - respectively, are required. Inputs technically
will show an input on the page. But I can
74:05 - beef it up a little bit by adding additional
properties such as placeholder, or the name
74:12 - property, or the type property type is an
interesting one. Actually, it allows me to
74:18 - change this input to be multiple different
things. For example, this may be a radio button
74:24 - or a checkbox or a regular input. That input
could be either text or an email or a phone
74:30 - number, and even changing it to a submit button.
A lot of times these are called attributes.
74:34 - But another legitimate word for it is a property.
If this simple concept in HTML makes sense
74:39 - to you, which I assume by now it probably
does. Understanding props in react is not
74:44 - too difficult. Instead of using the built
in HTML tags, since we're creating our own
74:49 - components, we can actually make it so that
we can allow properties to modify the way
74:54 - that the component acts. So in the next video,
we're going to see how we can actually do
74:58 - that.
75:02 - I want to make one more conceptual point before
we actually get into using props with react.
75:09 - This here is from the YouTube homepage. And
while I'm pretty sure the YouTube homepage
75:13 - doesn't use react since Google is the main
backer of Angular, the concept will remain
75:17 - the same. Think for a second how this page
may be developed in react, something you'll
75:22 - begin to get really good at doing is noticing
how something can be divided into separate
75:27 - components. For example, notice that each
of these separate pieces of the page are all
75:33 - very similar in their own way. If you notice,
each one of them has an image on the top that
75:39 - takes up about the same amount of space. Each
of them has a title, which is in bold and
75:44 - appears usually directly below the image.
Each one has a number of views. Each one tells
75:50 - you how many days ago it was published, each
one has a little timestamp inside of the image
75:56 - that tells you how long it is, you can imagine
that the creator of this page didn't actually
76:00 - go into the code and copy and paste this a
bunch of times. If this were developed in
76:05 - react, then you can imagine there might be
a video title component that is created. And
76:11 - that component has a number of components
inside such as an image, maybe an h3, a little
76:18 - timestamp box, and so forth. The main point
of what I just said is that it will be a single
76:23 - component that's developed once, but we need
to make it so that that component can change
76:28 - depending on the different properties such
as the image URL or the title. That's what
76:34 - we're going to be working on in the next video.
Right before we move on, though, I wanted
76:38 - to get you used to the idea of thinking in
terms of react back a few lessons when we
76:43 - talked about parent and child components,
that tree can go as deeply nested as you want.
76:48 - In fact, you can see here, we have different
lists. So there may be a component that is
76:53 - a list component, which renders a number of
video title components, which in themselves
76:59 - render an image and an h3 or whatever, like
we talked about. Also, over here on the left,
77:04 - you can see a number of things on the page
that may have only been developed once as
77:08 - a single component. And then given a property
of maybe a little image on the left and the
77:14 - text that should show up as part of the link.
Hopefully, you can see how the idea of web
77:19 - components and reusable HTML is really powerful.
And this can help you understand why frameworks
77:24 - like Angular and react and Vue JS are very
popular. So that's enough with the conceptual
77:29 - let's move on to some code and see how we
actually do this in react.
77:38 - So let's take a look at an example where it
would be really nice to have separate components,
77:43 - but not just separate components. But those
that could take different attributes or props
77:47 - in order to make them a little bit more dynamic.
Here, I've created just a really basic contact
77:52 - card list, where it shows the image of the
contact and a name for the contact the phone,
78:00 - and email. Right now I only have four contacts
and my contact book. To start, we know that
78:06 - it would be really nice to take these pieces
of repeated HTML code and put them into their
78:11 - own components. But from what we've learned
so far, we would actually have to create four
78:15 - separate components, one for each individual
contact, but that's not really gonna work
78:20 - for us. So first things first, let's actually
create the component. And then we'll learn
78:24 - how to make it more dynamic. We're going to
create a new file called contact card, Gs.
78:33 - And I'm going to take this div, which is the
repeated div across these four contexts, and
78:39 - just copy it. And I'm going to start a new
component. If you'd like, feel free to pause
78:44 - the video and see if you can figure out how
to do that. As always, for components I'll
78:52 - need to import
78:53 - react from react
78:55 - Yak. And I'm going to export the function
that I'm about to make my spacing here. And
79:12 - this is a great start. The problem with this
is that it has a hard coded image source,
79:17 - a hard coded name, hard coded phone, a hard
coded email and so forth. Instead, we're going
79:23 - to want to figure out a way to make it so
that this contact card when I make separate
79:27 - instances of it will be able to take as properties
the different information that I'm going to
79:32 - put into these places. Another quick conceptual
point you can think of has to do with functions,
79:39 - which actually mirrors pretty nicely what
we're doing because we are using functional
79:43 - components. When you create a function, let's
say add numbers. Maybe this function returns
79:51 - the result of one plus one. Well when I want
to do an operation with one and two, or one
79:57 - and three or two and three, I'm not going
to want To create separate functions for every
80:01 - single one of them. Instead, we use function
parameters, maybe a and b. and make it so
80:09 - that any two parameters we pass into this
function, we can get a different result depending
80:15 - on those inputs. The same concept of adding
parameters to a function to allow the function
80:20 - to be more reusable is the same thing we're
going to be doing with react components. Let
80:25 - me delete this. In order for us to illustrate
this, let's go over to App j s. And I want
80:32 - to be able to replace all four of these with
the individual information for each component.
80:38 - But let's start by actually putting the component
in there, I would like to be able to say,
80:45 - I want a contact card here. And I actually
want four of those. Well, for this not to
80:50 - fail, I need to import contact card from that
file. And now comes the time to actually pass
80:58 - down individual information for each contact
card, just like we did with regular HTML where
81:03 - you pass in an attribute or a property right
here, we're going to do the exact same thing,
81:07 - except this time, we get to decide what the
name of that prop is. For example, each of
81:12 - these contact cards has four pieces of dynamic
information, the image URL, the name, the
81:18 - phone number, and the email address. So let's
pass a property down for each one of these,
81:24 - it's actually pretty simple, I'm going to
say name, equals, and then put in the name
81:30 - that I want this contact card to use. And
I'll do the same for the other information,
81:36 - image URL on
81:39 - an email.
81:41 - Now, for me personally, when these start to
wrap on two separate lines, I like to put
81:47 - everything on its own line and in rented,
81:50 - I'm gonna do that really quick.
81:55 - I'm going to go through and do this really
quickly for the rest of the contact cards,
81:59 - putting each of these individual contact card
information into properties of the contact
82:04 - card component.
82:13 - Notice when I just refreshed even though I've
put separate different pieces of information
82:18 - into each one of these contact cards, I'm
still getting Mr. Whiskers send four times.
82:23 - The reason is a contact card currently has
hard coded values inside of itself. But we're
82:29 - passing in separate props, name, image, URL,
phone, and email. So let's see how we can
82:38 - inside of contact card j s access the data
that we're passing down to the contact part,
82:45 - over in contact card, one thing that we haven't
put in quite yet, is inside the parentheses
82:49 - here in this function, it's going to take
a parameter
82:52 - called props.
82:54 - Because it's a function parameter, you technically
can call it whatever you want, but it's a
82:58 - strong convention to call it props. Props
is an object that has properties of that object,
83:04 - each one being a prop that you passed in,
or rather, the name of the prop that you passed
83:11 - in. What I mean by that is, we will have inside
of contact cards will have props dot name,
83:19 - and props dot image URL, over in contact card
j s. Let me just console log
83:26 - ops.
83:30 - Take a look.
83:32 - Take a look at this, we got four console log
entries, the reason being we have four instances
83:38 - of our contact card component. And the props
are an object with a name, image URL, phone
83:45 - and email properties. This means now inside
of my code, instead of having hard coded values
83:50 - here, I can use the property of the props
object that's coming in. So I can say source
83:58 - equals, and I can't just say props dot image
URL, think for a second why that doesn't work.
84:05 - And think of how you might fix it. Remember,
when we're switching between JSX and JavaScript,
84:12 - we need to use curly braces around our JavaScript.
We can do the same thing for the other values
84:17 - here as well. Props dot name. Here, I can
leave phone colon space as a hard coded value.
84:28 - And then just replace this with props phone
in the same thing with the email. Now when
84:40 - I refresh, I actually get my four separate
contact cards with the individual information.
84:47 - I'm going to delete this console log so it's
not cluttering things up. And as easy as that
84:54 - I now have a component that is reusable in
a lot of different ways. Now at this point,
84:59 - I want you to think What would my component
look like if my contacts had, say 50 properties
85:04 - to them over an app js, each of these contact
cards would end up getting pretty long, right?
85:10 - I would have a prop for each individual thing
that I'm saving about that contact, which
85:16 - like I said, perhaps could be something like
50 different properties. Another legitimate
85:20 - way to do this is instead of passing down
each part of this person or contact as an
85:27 - individual property, I could pass down an
object that was the entire contact. For example,
85:34 - instead of name, image URL, phone and email,
I might simply pass down a prop called contact,
85:39 - whose value is an object. Remember, I'm going
between JavaScript and JSX here, so I need
85:46 - to put a double set of curly braces, the first
one getting me into JavaScript, inner one
85:52 - being the object itself, that object would
have a name, an image, URL,
86:05 - phone,
86:07 - and an email.
86:08 - This technically would allow me to get rid
of these four properties, and just pass down
86:13 - the single property called contact. Now, this
may not actually look better than what we
86:17 - had before. But we're going to see eventually
how this data isn't usually hard coded in
86:22 - like this, but rather comes from something
like a JSON file, in which case, it can be
86:26 - really nice to pass down the whole contact
as a single prop. However, our component is
86:31 - going to be broken now. Notice when I refresh,
the only thing that shows up are the phone
86:37 - and email hard coded text. Pause the video
and try to think why that might be. The reason
86:44 - is over in contact card, we're receiving a
props object, and we told it that that object
86:51 - would have a property called image URL and
phone and name and email. However, for our
86:56 - first contact card, we're no longer passing
a phone, email and name or image URL. Instead,
87:02 - we're passing a prop called contact, which
is an object. So let's go over to contact
87:06 - card, pause the video and see if you can fix
this to work. If you're having trouble, one
87:14 - thing that may help is to console log
87:17 - prompts. See what's actually showing up here.
Okay, now that you can see this console log,
87:25 - give it a shot again.
87:29 - Notice the first one is not receiving a name,
image URL, phone and email like I mentioned
87:34 - before, but instead is only receiving a single
property contact. And that contact property
87:40 - is an object, which means I would need to
change everything to props dot contact dot
87:46 - image URL, and props dot contact
87:50 - dot name.
87:53 - And the same for these other ones. Now, of
course, when I refresh, I'm going to have
87:57 - a major problem because my other components
aren't receiving a prop called contact, therefore,
88:02 - it's undefined. And I'm trying to access the
image URL property of undefined. So this won't
88:08 - just not show up, it's actually going to crash,
which means I need to go back to App j s,
88:13 - and fix each of these other contact cards.
I'll spare you the monotony of watching me
88:18 - do that and speed this up. Okay, that was
pretty tedious. Let's refresh and see if that
88:29 - works. Okay, now we're working again, our
contact card is passing down a single prop
88:33 - called contact, which is an object that has
all of the properties that we want. Again,
88:38 - normally, this won't be hard coded, but instead
would be something you get from a data file,
88:42 - such as a JSON file, which we're going to
cover in a future lesson. And over in contact
88:47 - card, I'm receiving all of my props as an
object called props. And since I only pass
88:52 - the single prop down, I have props contact,
but props contact is an object. So that has
88:58 - properties itself like image, URL, name, phone,
and email. Again, this concept can be a little
89:04 - bit tricky. And I totally understand if this
didn't make sense the first time through.
89:09 - As I mentioned before, the sweet benefit of
schema is that you can pause this and actually
89:12 - mess with this code. So even if you feel like
you understood this, I'd really appreciate
89:17 - if you pause the video and go through and
actually mess with this, change the data over
89:22 - in app j s, see if you can then reflect it
to show up correctly on contact card. Also,
89:27 - feel free to go grab different image URLs
and put those in and see how it affects the
89:32 - code. More you mess with this more likely
you'll be to actually understand it well enough
89:36 - to implement it yourself. To Go ahead, give
that a shot. And only after you feel really
89:40 - comfortable with it,
89:42 - move on.
89:44 - Okay, I'm sure this has been pretty obnoxious.
But this is the very last time I'm going to
89:52 - ask you to do this. I want you to create another
react app from scratch. Obviously the repetition
89:58 - is going to be really good for you and what
this react app should do is render an app
90:02 - component which should be in its own file.
And the app component should render five joke
90:06 - components, we can see that this is going
to help us practice the parent child component
90:11 - tree, it's going to help us practice putting
components in their own files. But the main
90:15 - thing we're going to practice is passing props
down through the joke component. So each joke
90:21 - component should receive a question prop and
a punch line Prop, and then render those to
90:25 - the page however you want. That's just kind
of the basic part of the practice. But I've
90:30 - added a little extra credit section, which
I'd really encourage you to try. So in this
90:33 - case, if your component does not receive a
question prompt, you need to think how might
90:38 - you make it so that it only shows the punch
line instead? For example, if you've hard
90:43 - coded in a question, text that says, a question
colon and then appstack question. Obviously,
90:51 - this syntax is incomplete. But how are you
going to make it so that you don't have question,
90:57 - colon, and then an empty space? Also, while
you're at it, see what happens when react
91:02 - receives a prop that's undefined? If you don't
have a question colon, and you're also not
91:06 - passing down a question Prop, see what happens.
And while you're at it, spend some time practicing
91:10 - the style, if you joke component, make it
look good. So pause the video do this practice.
91:16 - And we'll go through this together in just
a few seconds.
91:18 - All right, I'm gonna delete this. And I'm
gonna actually leave some of these comments
91:27 - here, just so that I can remember exactly
what to do. We know we need to in a basic
91:32 - setup, import react, and react,
91:36 - import react DOM, React DOM,
91:41 - when to use react DOM. To render our app,
we're gonna put it at the root element. Don't
91:52 - have apps, I'm going to import app from a
file called app that doesn't yet exist. And
91:58 - I'll create that file. Now. I put a app.js.
Over in that file, I need to again import
92:06 - react from react
92:11 - for the app component that I'm about to make,
wrap everything in a div. Okay, and here,
92:22 - we're going to render our five joke components,
92:25 - that should be capital J
92:26 - 2345. Now for this to know what I'm talking
about, when I am trying to create an instance
92:33 - of a joke component, I will need to import
that. And that doesn't exist yet. So let's
92:42 - make that I'll create a file called capital
J joke. dot j s. And over in joke j s,
92:51 - let's again,
92:53 - import react from react. Default joke. And
before I get too deep into playing with props,
93:06 - I'm going to just have it render something
simple
93:08 - just to see if it's working. I may have forgotten
something. But let's check this out.
93:15 - Okay, yep, my five highs on the screen, which
means my five jet components are working.
93:22 - React Dom dot render is rendering the app
component, the app component is rendering
93:26 - a div with five joke components. And the joke
component is just rendering an h1. And that's
93:32 - how I'm getting five highs on the screen.
And that's the tree that we're working with.
93:36 - While I'm still in this file. I'm going to
work on the props here. So I know that I need
93:41 - to pass in a variable. I'm going to call it
props because that's the standard. And let's
93:48 - start with something simple. I'm going to
render a div with maybe a 
93:57 - couple h threes inside. One will have the
question. One will have the answer. If you
94:09 - had gotten stuck anytime before this, I'd
really like you to pause the video and go
94:14 - review these things that we just went over
and then try it again from scratch. You can
94:18 - go back in time to the beginning and actually
try to build this out yourself. Then once
94:22 - that makes sense. Come back to this point
and move on. Now if everything did make sense
94:26 - up to this point, pause the video here and
see if you can figure out how are we going
94:30 - to get the question from our joke that's being
passed in. Of course right now. It's not yet
94:35 - being passed in the wind it is how are we
going to place it right here. Remember, we're
94:43 - inside of JSX right now. So I can't just say
props question because that would literally
94:49 - put the text prompts question here. When I
want to go inside of JavaScript, I need to
94:55 - surround it in curly braces. Notice that I
get nothing On the screen, think for a second
95:01 - why that might be. Let's actually console
log prompts question. Open the console and
95:12 - see what shows up. That's what I get. No.
That's because this joke component when I'm
95:19 - creating instances of it in my app, I'm not
actually passing in a question or a punchline
95:24 - prop. So when react tries to render a component,
and we're not passing it any props, everything
95:31 - will be set as No. What's really cool about
react is if any JavaScript inside of JSX evaluates
95:37 - to something like undefined or no, it simply
won't display it. This right here is going
95:41 - to be something we need to figure out how
to fix when we have our joke components that
95:45 - don't take a question prop. But for now, let's
assume that they all have a question and an
95:49 - answer or a punch line. So over here, I'm
going to also add props dot punch line, and
95:57 - they can delete my console log here. Let's
go back to App j. s. And let's actually provide
96:03 - a question in punch line for every one of
these jokes.
96:16 - As I mentioned in a previous lesson, I prefer
to put these on their own lines, if they start
96:20 - to get so long that they're wrapping around.
96:28 - You may decide this isn't your style. And
that's totally up to you, I still go back
96:32 - and forth as to whether I want this closing
bracket to be on the previous line or not.
96:38 - So let's refresh this and see what we get.
Cool. Everything's a little bit squished together.
96:46 - So you may decide to do something simple like
at the end of a joke, you may put a little
96:51 - break tag, or maybe something like a horizontal
rule. But obviously, however you want to style
96:58 - it is totally up to you. And there we have
the basics of the first part of our exercise.
97:03 - Now, as we see in the extra credit, some jokes
are only a punch line with no question. And
97:08 - as it stands, I have this hard coded word
question colon space here. I provide a joke
97:14 - that doesn't have a question. Like my favorite
one only has a punch line. See, when I render
97:24 - this, I get a question with nothing there.
We're going to talk in a future lesson about
97:29 - conditionally rendering parts of our page.
But for now, think about the way that we style
97:33 - our page and see if you can think of a way
that we can make this disappear if there is
97:37 - no question. So video and give that a shot.
Again, there's actually going to be a real
97:45 - way we do this with something called conditional
rendering. But for now, you may find a way
97:49 - around it where you can say I want this h3
to have a style feed display of none under
98:00 - certain circumstances. But afraid here I use
the ternary operator to decide what that should
98:05 - be. inside of my object I could say essentially
is props that question a thing? Is it truthy,
98:14 - if so displayed in the regular block format,
but otherwise displayed is none. Notice that
98:20 - my first one has an h3 that is now displayed
none because it no longer has props question.
98:26 - If you're not very familiar with ternary,
I highly recommend you go spend some time
98:29 - learning about them because they're actually
used quite often in react. Another slightly
98:34 - more concise, but perhaps more confusing way
to write this would be instead of using a
98:39 - ternary. And having a default of its own default,
like an h3 being display block. We can get
98:45 - rid of that. And we could actually say if
there isn't
98:48 - a proper question, then we want to display
none. But otherwise, basically ignore this
98:54 - rule totally. If you're not familiar with
using the double ampersand in this way, we're
98:59 - going to talk about it in a future lesson.
But just know for now, this totally works.
99:03 - You can see over in my browser, I have just
an answer to my joke that doesn't have a question
99:08 - in it. But the question does show up in all
of these other instances. Now if you look
99:13 - at my joke that doesn't have a question, it
doesn't stand out very much. Maybe you might
99:17 - decide that you want your answer only jokes,
your punchline only jokes to look a little
99:21 - bit different maybe to be grayed out or to
be a totally different color or underlined.
99:26 - I don't know something, also video for a second
and think how you might do that using inline
99:31 - styling and JavaScript the way that we did
in line six. Maybe what I might do is on my
99:39 - answers, h3 is add an inline style with an
object it says the color should be and then
99:47 - do something similar to what I have on the
question art on the h3 above where I say if
99:52 - there is no props dot action, then I might
want the color to be I don't know some kind
99:58 - of
99:59 - gray
100:00 - This is pretty contrived. But you get the
idea, we can start using the different props
100:05 - that come into our component to display things
differently. And as such, our joke component
100:10 - is now more or less reusable, we can add jokes
that just have punch lines and jokes that
100:15 - have both questions in punch lines. And automatically
the joke component knows how to style itself
100:21 - based on the incoming props. And that's pretty
much it for this practice, feel free to pause
100:26 - this and play with this as much as you want
before moving on.
100:31 - Alright, so we're going to pick up where we
left off in the previous practice with our
100:39 - app component rendering a bunch of joke components.
Some of these have the punch line in them,
100:44 - and some of them have a question and punch
line. But you can see right now that they're
100:48 - hard coded into our components written directly
as text. In reality, most of the data that
100:53 - you'll be displaying on a page will actually
be coming from some kind of HTTP call to an
100:58 - API, where there's a server that hosts the
database, and that database and server are
101:03 - returning JSON data to you. We haven't quite
gotten to the place where we can make API
101:08 - calls quite yet. So what I've done is I've
made this file jokes, data j s, and it's just
101:12 - an array variable that I'm exporting. And
that way in a component, if we want it, we
101:18 - can pull that in and pretend like that's us
getting data from an API. So how am I going
101:23 - to take an array of raw data and turn that
into a number of components? Well, there's
101:28 - a common saying for those that are learning
react, where they say that react helps them
101:33 - become better JavaScript developers. And the
reason is, because things like this are oftentimes
101:38 - handled by methods and kind of magic under
the hood for other frameworks like Angular
101:43 - or view. But in react, a lot of these simple
operations are handled just with vanilla JavaScript.
101:49 - Let me show you what I mean. With a quick
aside, we're going to talk about some higher
101:54 - order array methods. If you're not familiar
with these, these are methods that you can
101:58 - run on an array that take a function as a
parameter and allow you the developer to decide
102:03 - exactly what should happen to the elements
in that array. For example, if I had the following
102:08 - array, I can run a higher order method on
nums.
102:14 - All map,
102:15 - and map is a method of the nums array, and
it takes a function as its parameter, this
102:22 - function will receive each individual number
in the array. So I might say num or number,
102:29 - Tim, this function will then run on every
single item in the array. And with map, whatever
102:37 - I return from my inner function here, will
be placed in the same index of a brand new
102:43 - array with some kind of modification, meaning
map actually returns a brand new array, so
102:49 - I'm going to save a new array called maybe
doubled. Now, if I from my inner function,
102:56 - return, num times two, doubled should be an
array of 2468 1012, and so on, let's take
103:07 - a look. And there's my array of all the double
numbers. If you're not familiar with higher
103:13 - order methods, they're one of the key components
of functional programming in JavaScript, and
103:17 - they're really, really awesome, I'd highly
recommend go study up a little bit on map,
103:23 - and filter and reduce, and some of the other
ones that are really useful. With this, we're
103:28 - gonna stick with map and we're gonna see what
we can use it for. So the first thing I'm
103:32 - going to do is pull in my jokes data importing.
And then we're going to follow the same pattern
103:40 - that we did in our example here, I'm going
to say, oops, data dot map, provide a function.
103:48 - Now before I typed the longhand function,
so that it was a little clear what I was doing,
103:53 - but we're going to use an arrow function,
which can just as legitimately be used here,
104:00 - function is going to receive each individual
joke object, so I'll call it joke. And with
104:05 - arrow functions, if I just have one parameter,
I can get rid of my parentheses. And what
104:09 - I'm going to return from this inner function
isn't some modification on the joke objects
104:14 - per se, but rather, I'm going to return a
component
104:19 - joke component
104:23 - and pass in
104:24 - the data from
104:25 - the individual joke object that I'm looking
at. Because I'm only returning a single component,
104:38 - I can actually just do this on one line if
I want. And if you're familiar with arrow
104:43 - functions, there's an implicit return so I
could actually get rid of some of that extra
104:51 - stuff. If this is confusing at all, then feel
free to put the return in there. It looks
104:56 - like I have an extra space there. And remember,
map returns A new array. So I'm gonna save
105:01 - that in variable. And now I have an array
of components. So what am I going to do with
105:09 - an array of components? Well, React makes
it really nice, where I can just put an array
105:15 - of components directly here in my JSX. And
if I refresh this, you'll notice a couple
105:22 - things. First of all, my jokes on the right
are working again, just like they should be.
105:27 - And second of all, you might have noticed
this little error that popped up that says
105:31 - each child in an array or iterator should
have a key Prop, we won't go too much into
105:36 - the details of why react expects a key prop
on repeated components. But it's enough to
105:41 - know that whenever you're doing a map like
this, you should give the component that you're
105:45 - creating over and over a new prop called key.
Now, whether you're putting this on a component
105:52 - that you've created, or some kind of div that
you're surrounding it with, doesn't really
105:56 - matter. Just give it a key prop and put something
unique inside the key prop. Usually data from
106:03 - an API will include some kind of ID number
or something else that's unique about it.
106:08 - As long as it's unique, it should be fine.
Here, I could use the question because the
106:12 - questions are all unique. But I've also included
for the sake of mimicking real data, some
106:17 - ID numbers that I might decide to use instead
for my key. So over in app j, s, key is going
106:24 - to be choke.id. Now when I refresh, my warning
goes away, my app js is much cleaner than
106:31 - it used to be, my data is coming from somewhere
external, like it would in the real world.
106:35 - One of the main takeaways, though, is that
we're just using the built in JavaScript map
106:40 - method on arrays. In fact, I'm going to include
some links to the MDN docs on these methods
106:46 - that will be really helpful for you to understand,
if you don't already feel comfortable with
106:49 - them,
106:50 - you
106:51 - can see on the far right in the last part
of the URL exactly which method it is that
106:56 - this URL is going to be talking about in this
course, will mostly be using map, but we may
107:01 - throw in one of these other ones every now
and then you don't necessarily have to go
107:04 - memorize these perfectly right now. But this
is just some more material that you'll definitely
107:08 - be interested in learning about. Something
else that I just thought of that may be really
107:12 - helpful to you is to realize that things that
we're teaching here, because so much of react
107:17 - is just vanilla JavaScript, you can use these
things as tools to do a lot of what your imagination
107:22 - could come up with. For example, as I'm iterating
over a joke component and creating a number
107:28 - of jokes, I may find a reason to also put
a map inside of my joke component. And I end
107:34 - up with a loop inside of a loop, where each
joke component renders an array of its own
107:39 - components. That's totally possible. And it's
as simple as putting another map inside of
107:43 - your joke component. One joke component gets
rendered, it renders a number of other components.
107:49 - The second joke component gets rendered, it
also renders a number of other components
107:53 - and so forth. Some of these other methods,
like sort, for example, may be used to put
107:58 - things in an order that you prefer, or something
like filter could only display certain elements
108:04 - of an array rather than the entire array.
If you want an extra challenge, try making
108:09 - it so that our array of joke components gets
filtered to only display those that have fewer
108:16 - than X number of characters in the question,
or maybe filtered to only include items that
108:21 - do have a question rather than those that
are just an answer. This is pretty much everything
108:26 - we have to learn about map right now. So when
you feel pretty comfortable with this, go
108:30 - to the next lesson to practice it.
108:33 - Okay, so I know I told you, I wasn't going
to make you create the entire react app from
108:42 - scratch. But I didn't make it a whole lot
easier for you. I did put the basics in so
108:47 - it's rendering an app component. And the app
component is just rendering an empty div right
108:52 - now. And here we have the instructions for
this exercise. So given a list of products
108:58 - as an array, which will be the products data
that I'm importing from the file called visco
109:04 - products, you need to create first and then
render a product component. For each product
109:10 - in the list, you're going to have a chance
to practice creating your own functional component,
109:15 - passing props to it, and rendering the correct
things to display inside of that component
109:20 - as its receiving props. And you'll also need
to practice using the map method on the products
109:25 - data. This array of data is just an array
of silly objects that I created for a presentation
109:31 - that I gave last week here in Salt Lake City.
And each object has an ID, a name, a price
109:36 - and a description. You won't necessarily need
to display the ID as text on the page, but
109:41 - try to think of what this ID might be helpful
for. So I will go back to the app and I'll
109:46 - give you a chance to give this a shot. Good
luck. Okay, let's start with just a really
109:54 - basic product component. So I'm going to create
a new file and call it product dot j s Which
110:01 - I'll need to import react from react and export
product.
110:06 - It my functional component
110:10 - already know this is going to need to receive
products. So I'll put props there. And let's
110:18 - just return some really basic JSX. For now
we'll wrap everything in a div. I have, let's
110:29 - say an h2.
110:32 - For the
110:36 - props dot product dot name. Now this is a
nested object because I anticipate passing
110:42 - the entire product down as one object rather
than passing down each individual property
110:47 - of the product individually as a prop. Instead,
I'll just pass the whole product down as one
110:52 - object and access the properties through props
dot product, dot and then the name of the
110:58 - property. Down below it, I will put a paragraph
put $1 sign in front of props dot product,
111:10 - price. And then one thing I'm actually going
to put here is a string method called to locale
111:17 - string, which allows me to display this as
currency. And I believe if I do that, it will
111:22 - automatically put the dollar sign there for
me. So I'm actually going to take my dollar
111:25 - sign out. And then after that gets evaluated,
I might do like a dash and put the description.
111:37 - This is pretty boring. But I'd spend some
time if I were you styling this and getting
111:41 - some more practice with styling. So over in
app j s, I know that I'm going to be rendering
111:47 - a number of product components. So I need
to first import my product component
111:52 - file.
111:56 - And at the top of my functional component
here, I'm going to create a new variable called
112:04 - products. That's a product components. That's
going to be coming from products data dot
112:14 - map. So products data dot map, again, we'll
create a new array, and we're going to make
112:18 - sure that array is filled with product components.
So this will receive an individual product
112:25 - or item. Maybe I'll say item just to distinguish
it from all the other things I have named
112:30 - product. I want this to return a product component
112:36 - where the
112:37 - product is my item. And now that I have this
array of product components, I'm going to
112:44 - put it inside of my div here and try refreshing.
Cool. One thing you notice is I got that warning
112:51 - about the key prop over here, I will also
add a key property. And I'm going to pass
112:56 - in the items Id just to allow it to have something
unique so that react can correctly place everything
113:02 - the way that it wants to. And I need to fix
my spelling here. Let's try refreshing again,
113:08 - everything is showing up correctly on the
right, and I no longer have that warning popping
113:12 - up, which is great. I'm a bit of a stickler
for correct indentation, so I'm going to fix
113:18 - by indentation here. And this essentially
is the completion of this exercise. Take some
113:23 - time to try and style this, see if you can
display things a little bit differently. Play
113:27 - with adding products to the visco products
array and see how that affects our website.
113:31 - One thing I didn't show is that I can scroll
down here and see all of the other products
113:35 - that are listed in that array. Maybe try building
a button that when it's clicked in each product
113:41 - tops up an alert with the information about
that individual product to spend some time
113:45 - with this. And once you're ready, we're going
to talk about conditional rendering.
113:50 - Let's use what we just learned about mapping
and props to make our to do list a little
113:59 - more dynamic. What I've done is I've created
a to dues data js file here and all it is
114:04 - doing is exporting an array of objects each
object representing a to do item. Now normally,
114:11 - you wouldn't do it this way, you would get
this data from an API of some sort where the
114:15 - data is living in a database. But since we
haven't really gotten there, this will do
114:18 - for now. Then over in app j s, I've imported
that data as an array called to dues data.
114:25 - So your task is to essentially turn this array
of objects into an array of to do items. Now
114:32 - remember right now to do items are hard coded
with what they're displaying. So that will
114:38 - also need to change. Go ahead and pause the
lesson and give this a try.
114:46 - So the first thing I'm going to do is take
my array and turn it into an array of to do
114:52 - items, then we'll have to fix to do items
so that it can receive props before my return.
114:58 - We're going to create up An array called to
do items, which is the result of doing to
115:06 - dues data dot map, which will pass a function
to that receives an item. Essentially, we're
115:15 - just going to create a to do item. And we're
going to pass the information from the individual
115:21 - item object down to to do item currently to
do item doesn't accept anything, but we'll
115:27 - fix that in a minute. So I'm going to pass
a prop called
115:29 - item.
115:31 - And its value is going to be the object. And
now that I have an array of to do item components,
115:39 - let's take these out
115:41 - and replace it with my array of to do items.
Okay, and you'll notice that I forgot to put
115:49 - a key prop in
115:50 - here, always an important thing to do. And
with the two dues data, what I've done is
115:55 - added an ID property, these IDs we can assume
will always be unique. And so over in app
116:01 - j s, I will just add a key. Let's say it's
item that I be rid of that warning. Now notice
116:09 - that I still have placeholder text here. But
now I have it five times. And that's because
116:14 - I have five items in my to dues data. But
to do items still has placeholder text here
116:19 - hard coded in it. Well, we're passing an item
prop down. So let's go over to to do item,
116:26 - have it accept props. Instead of putting placeholder
text here, we will simply say props dot item
116:34 - dot txt, dot txt, because that's what the
property is called in my object. So I save
116:41 - this. And there we go. We have our to do item
showing up. And essentially, we're declaratively
116:48 - turning an array of raw data into elements
on our application. Now, it's actually going
116:56 - to be quite a while in this course, until
we learn about forms and learn a little bit
117:00 - more about how this input type checkbox works.
But what I can do is give you a little hint
117:05 - as to how to make it so that the checkbox
is checked, when the item is considered completed.
117:12 - Over in the data, you may have noticed that
I've set a couple of these to complete and
117:17 - true. Let's make it so the checkbox actually
gets checked. When that happens. Again, we're
117:21 - going to cover this quite a ways down the
road. But just so you know, for now, every
117:25 - type checkbox gets a property called checked.
And essentially, it tells the checkbox whether
117:31 - or not it should be checked, if the thing
inside is true. And it will be checked. And
117:38 - if not,
117:39 - it won't be checked.
117:40 - This is going to throw a little warning that
basically says you've added a checked property,
117:45 - but you can't change it ever. So it doesn't
have an on change handler. But for now, that's
117:51 - okay. We'll cover this again in the future.
But you can see in my window over here, take
117:57 - out the trash and mow the lawn are already
considered completed. And you'll see when
118:02 - I tried to uncheck it, it won't let me like
I said, we'll fix that in the future. But
118:07 - this is kind of a cool little addition we
can make now, hopefully that wasn't too difficult.
118:12 - If it was feel free once again, go back, rewatch
everything, catch up on any of the lessons
118:17 - that you may have struggled a little bit through
up until now. And once you ready, let's go
118:22 - forward. If any of you have done a react tutorial
before this one, you might be curious why
118:31 - we're using functional components instead
of a class based component. When I'm teaching
118:36 - react, I prefer to start with functional components
simply because functions are really easy to
118:41 - understand. And it's obvious what we're doing,
we are simply creating a component with a
118:46 - function that returns the UI that we want
to show up on the page. But as we go deeper
118:50 - and deeper into react and start learning about
some new parts of react, we're going to find
118:54 - that a functional component can't do everything
that we need it to do. And so at this point,
118:58 - what we're going to do is actually learn to
create a class based component. For now our
119:03 - class based component is going to do exactly
what our functional component does. And then
119:08 - in upcoming lessons, we're going to talk about
what class based components can do for us,
119:12 - such as allowing us to implement state and
lifecycle methods. But for now, let's just
119:18 - look at converting a functional component
into a class based component. If you're not
119:22 - really familiar yet with the class syntax
in e6, then I'd recommend going over to the
119:27 - scrim by six course and learning a little
bit about classes. So instead of converting
119:33 - this functional component to a class component,
I'm actually just going to create a new app
119:38 - class below it. And that way, we can kind
of compare the two. The class base component
119:43 - will always start with the class keyword.
And we're going to give it the same name of
119:48 - the component as we had before app tip instead
of parentheses and curly braces, we're going
119:53 - to extend react component and if you're not
familiar With classes or what this is doing
120:01 - under the hood, essentially, this is still
using a prototype system in JavaScript. And
120:06 - it's setting up a prototype with react component,
all that really means is that we're getting
120:11 - a bunch of goodies from react component that
are pre written for us. And we're gonna get
120:15 - a chance to see that in upcoming lessons.
For now, I'm just going to open this with
120:20 - a set of curly braces. And every class based
component at least needs one method, and that
120:26 - is the render method, and it actually needs
to be spelled exactly this way. And then render
120:31 - will return exactly what we have in our functional
component. In this class component is identical
120:40 - to the functional component we had above.
So I should be able to comment this functional
120:46 - component out and save to watch the browser
refresh. And we have exactly what we had before.
120:51 - Now let's take a look at our render method.
Anytime we have any kind of display logic,
120:57 - that's going to happen, I prefer to do it
inside of my render method before the return.
121:02 - For example, you might remember a few videos
back where we created a date object. And then
121:11 - we use that data to determine what time of
the day it was. And we displayed in the text
121:17 - and used some styling, and all sorts of stuff
like that. If you have any code that determines
121:22 - the display logic, or in other words, what
exactly is going to show up on the page or
121:27 - what the style of that element will be things
like that can go right here inside of the
121:32 - render method before you do the return. So
this is a good place to set up your style
121:37 - objects. If you're doing any inline styling,
running the logic that will determine how
121:41 - something will get displayed on the screen,
things like conditional rendering, all of
121:45 - that can happen here inside of the render
method. Now, if you're familiar with classes,
121:49 - you technically could also take that and put
it inside of a method of your own a class
121:54 - method. To do that, above render, you would
just enter your own method right here. inside
122:03 - of this method, you can do any kind of display
logic that you wish. And then from inside
122:08 - the render method, you can call your method
by using this dot and then the name of your
122:14 - method. If your method returns something,
this is where you put that a few lessons in
122:24 - the future. We're going to talk about some
caveats with this. But for now, it's just
122:28 - as easy to put your display logic here inside
of the render method.
122:32 - There's one other thing that we have to touch
on before we're done with this. And that has
122:36 - to do with props. In our functional component,
we could pass props to the function itself,
122:43 - then inside of our code, we would just say
props dot, whatever the property was on the
122:49 - props object, there's only one small change
we have to make with the class base component.
122:55 - And that's that anytime we use props, we need
to make sure that we are using this dot props.
123:03 - It's a pretty common thing to forget to do,
especially when you're converting from a functional
123:07 - component to a class based component. But
it's also a bug that you'll get really good
123:12 - at catching and being able to fix right away.
And before this becomes confusing, I realized
123:17 - I forgot my curly braces up here. And to be
consistent, we will add a dot whatever here.
123:23 - As I mentioned at the beginning, class base
components enable us to do a lot of really
123:26 - cool new things with react, we're going to
be covering those over the next few lessons.
123:31 - But for now, let's get a chance to practice
this. So take a second to play with this code.
123:35 - And once you're ready, let's move on to the
practice in the next lesson.
123:39 - You can see that I've set this up where I
just put all three of these components in
123:47 - the same file. And as I mentioned before,
you obviously would want to put these in separate
123:51 - files normally. But for the sake of practice,
we're just going to keep them here so you
123:54 - can see everything at once. And as you can
see in the challenge, all you have to do is
123:59 - convert all three of these functional components
to be class based components. And also there's
124:04 - a small bug inside of this program. So see
if you can find it. So now's the time, pause
124:09 - the video and give this a shot.
124:13 - Okay, hopefully this wasn't too difficult.
All we're going to do is every time it says
124:21 - function, and then the component name, we're
going to change that to class. We need to
124:26 - extend react component, get rid of our curly
braces. And then instead of having a bare
124:34 - return here, we need that to be inside of
a method called render. And take this return
124:42 - type here, fix my spacing. And that's it for
the first one. The second one is essentially
124:53 - the same thing except now we have props and
we have to remember exactly what we're going
124:57 - to do when we have props. So Then function
will become class will extend react component
125:05 - and get rid of the parentheses, put my return
inside of a method called render. And then
125:19 - the one thing that's always really easy to
miss here is that instead of props, it needs
125:23 - to be this dot props. Because this is a class
based component. This third component looks
125:28 - a little bit more complex. But essentially,
it's the same thing. Class greeting. And,
125:35 - and now, like I showed you in the previous
lesson, we could decide just to put component
125:39 - here, which then means at the top, we would
need to import react and component, then all
125:50 - of this logic is also going to go inside
125:53 - of the render method.
126:02 - Looks like this component is not using props
anywhere, so I don't need to worry about changing
126:06 - that to this dot props. And you can see I
still am getting exactly what I had at the
126:11 - beginning. Now hopefully, you'll also notice
that there's a bug here, it says welcome,
126:16 - comma, and then a space with nothing in it.
If you didn't do this in the beginning, take
126:21 - a second now to try and figure out why that
is. Well, let's look at the component that's
126:29 - in charge of actually displaying this. And
that's our header. Here, we notice that it's
126:36 - saying welcome, this stop props, that username.
But when I am creating an instance of header,
126:42 - I'm not passing it any props. So it's coming
in as undefined. So it's coming in with nothing.
126:49 - And I need to actually pass something there.
So the prop I'm going to add is username was
126:56 - then we can put whatever we want here.
127:00 - There we go. That's fixed.
127:02 - Hopefully, this wasn't too difficult of a
challenge. If it was then go back through
127:06 - it and try to convert these classes back into
functions. And then from functions back into
127:11 - classes. I know that sounds pretty tedious.
But honestly, it's one of the better ways
127:15 - to learn. Once you're ready, let's move on.
Okay, so we finally come to one of the most
127:24 - important parts of react and that is understanding
state. State is simply the data that a component
127:31 - maintains. And when I say maintains I mean,
it actually can change its value. The reason
127:36 - that's a distinct feature over anything we've
learned so far is because props, the other
127:40 - way to pass data from a component to another
component cannot be changed by the component
127:46 - receiving the props. They say in the React
documentation that props are immutable or
127:50 - unchangeable. All that means is that I can't
receive a prop and then say this dot props
127:57 - dot something equals some new value. Okay,
I can't change props. And if I do, it may
128:05 - cause some weirdness with react. So state
is different in that it's a way that a component
128:11 - can maintain its own data and change its own
data if it needs to. Let me get rid of this
128:15 - before it becomes confusing, because you should
not do this. So anytime we're going to introduce
128:21 - state to a component. The first thing is that
the component needs to be a class based component.
128:26 - We'll talk a little bit in the future why.
But for now, just know that if you want state
128:30 - in a component, or if you want a component
to maintain its own data using state, it will
128:34 - need to be a class based component. The first
thing we'll do to introduce state to this
128:37 - component is we need to add a constructor
method. constructor is a specific method that's
128:46 - built into JavaScript that initializes parts
of this class, if you're feeling a little
128:52 - unfamiliar with classes, I went and grabbed
the link to a screencast that has some information
128:59 - on classes that you're welcome to pause and
go look at really quick. But the important
129:03 - thing to know is that when you have a constructor,
it's a place where you're going to be initializing
129:07 - some values. And the first thing you should
always do inside of a constructor is make
129:11 - a call to a global function called Super.
In short, what super does is it goes to the
129:17 - parent class or what's also called the superclass,
and it grabs some of the goodies there and
129:21 - brings them down so that our class or our
app component can use those goodies. One of
129:27 - the main parts of react component that we'll
be using is a method called set state. And
129:31 - that allows us to change state but we're going
to get there. For now just know that if you
129:35 - have a constructor, you should always add
super. And then the only other thing we need
129:38 - to do to add state to this component is to
add a property to this called state. And state
129:46 - will always be an object. And so I'm going
to set the start state equal to an object.
129:51 - And now I have state in my component. I can
access this state anywhere else my components
129:57 - code by referencing this dot state Now you'll
notice that I have an h1 here that says is
130:02 - state important to know. So I'm going to add
a property to my state as an initial value,
130:08 - the property will be called answer. And its
value will be yes. Now take a second to think
130:15 - how you might get that value to show up inside
the h1 after this question mark right here.
130:21 - Pause the video and see if you can get that
to work. The first thing I'll need to do is
130:28 - add some curly braces, because I'm going to
be interpreting some JavaScript inside of
130:33 - JSX. And then I simply type this dot state
answer.
130:39 - When I refresh the page, you'll see that it
shows up on my browser window over to the
130:44 - right, yes, here, what I'm doing is I'm giving
an initial value to my state. This is the
130:50 - data my component will have when it's first
initialized. And the special thing about state
130:54 - is that I can always change this to something
else later if I want. The only other thing
130:58 - I want to touch on in this lesson before we
move on is to mention that we can pass state
131:04 - from this component down to a child component.
And remember, the only way we can pass information
131:10 - from one component to another is through props.
And so that might look something like this,
131:15 - where I have some kind of child component
right here. And of course, if I want to pass
131:21 - any information down to it, it needs to happen
through props. So maybe I have a prop that
131:26 - I add called answer. And its value is this
dot State DOT answer. The only other thing
131:33 - I want to mention in this lesson for now is
that react will do some really cool stuff
131:39 - if we ever change state. And I don't mean
changing it here manually in the initial value.
131:44 - But I mean, when we use the set state method
that I mentioned, which we'll talk about in
131:48 - a couple of lessons, but if we ever use that
method and change the state, React will automatically
131:54 - update every child component that is receiving
parts of that state. And so changing the state
132:00 - will automatically change how things get displayed
on the screen. But we'll cover that a little
132:05 - more in depth when we start talking about
changing state. Now take a look at this code
132:10 - and try playing with state a little bit. And
we'll move on to a quick practice.
132:15 - Okay, so here's your challenge. And this is
actually a challenge that incorporates a little
132:23 - bit of debugging, not just talking about state
specifically. So you're given an incomplete
132:28 - class based component that doesn't have a
constructor. And your job is to essentially
132:33 - initialize state and make sure that the component
gets fixed. Pay attention to the console,
132:38 - which I've opened in the bottom. So make sure
you look at that. And that should give you
132:42 - some good hints as to what's wrong. And for
the values of state, you should be able to
132:46 - figure those out based on the context of this
component. So go ahead, give this a shot.
132:50 - And we will do this together in just a few
seconds.
132:54 - Okay, so there's a lot to be done here. And
I'm going to start first by adding a method
133:03 - that this return can be inside. It looks kind
of like this was a functional component, and
133:09 - was changed haphazardly to a class based component
but in completely. So the first thing I'm
133:14 - going to do is add a render method that this
return live inside. Okay, so when I refresh
133:24 - this, you'll see it says component is not
defined, well, that's a pretty helpful hint.
133:29 - We either need to extend react component,
or we need to import component from react.
133:39 - If we do it this way, then I can actually
keep it as component either way is totally
133:44 - legitimate. The next area we're going to run
into is a little bit tricky. So I'm going
133:49 - to save this. Notice it says cannot set property
props of undefined. Well, that's pretty confusing,
133:54 - because we're not actually using props anywhere
here. And where this comes from is this little
133:59 - set of parentheses that shouldn't be there.
That's how a function is defined, but not
134:04 - a class. So I'm going to get rid of those
and save it again. You'll see cannot read
134:09 - property name of No, well, here's name, and
it's seeing that this state is no. So as the
134:16 - instructions say I'm going to create a constructor
method. And the first thing we should always
134:24 - do in a constructor method is add super. I'm
going to initialize my state is an object.
134:33 - And I can see from the render method that
that object should have a name property and
134:39 - an age property. So inside this object, I
will add a name property and we'll say le
134:48 - age of saving again, now have a functioning
component. There's no errors in the console
134:58 - and Sally and 13 years old are showing Have
correctly over in the browser. Now one thing
135:02 - we've been talking a lot about at visco, which
is the coding boot camp that I work for, is
135:07 - how important repetition is. And I know I've
tried to get you to write this code over and
135:11 - over again. But I'd highly recommend that
if any part of this was confusing at all,
135:16 - that you go back to the beginning of the screencast.
And you pause the video immediately, and you
135:20 - try to fix it yourself again. And then after
you do that, do it again, go back to the beginning,
135:25 - try and fix it again from scratch, and do
it again, and do that as many times as it
135:29 - takes for the syntax to kind of be second
nature for you. Doing that is going to do
135:34 - a number of things. But mainly, it's going
to make it so that in the future, you don't
135:37 - get so hung up on figuring out and remembering
the syntax as much as figuring out how to
135:43 - solve specific problems. So feel free to stop
here, go back, redo this as many times as
135:48 - is necessary. And then when you're ready,
feel free to move on.
135:52 - Okay, so I actually decided at the last second
that I wanted to add another practice in here.
136:01 - And this practice is going to do two things,
it's going to give you the chance to practice
136:05 - converting a functional stateless component
to a class based component. Again, it's also
136:11 - going to give you a chance to add state to
a component. And then I have kind of an additional
136:16 - challenge here, that covers something we haven't
quite talked about yet, which is conditional
136:21 - rendering. But I want you to just give it
a shot, use your intuition. And if you're
136:26 - wanting to do any kind of Google search, you're
welcome to do that, too. And we are going
136:30 - to cover this soon. But I figured this would
be a good chance for you to exercise your
136:34 - problem solving skills. So given the component
here, change it to a stateful class based
136:40 - component, give the state a property called
is logged in, which should be a Boolean, either
136:45 - true or false. And that's the first part.
If you can do that, that's awesome. Then I
136:50 - want you to give it a shot at rendering the
word in if the state is logged in is true,
136:56 - or the word out if it's false. So go ahead
give this a try.
137:02 - Okay, so the first part, we should be able
to do relatively easily, we need to change
137:09 - our functional component to a class based
component. So I will add class here, going
137:15 - to get rid of my parentheses, add extends
react dot component, I return needs to be
137:24 - returning inside of a method of some sort.
So I'm going to add my render method, my return
137:31 - inside game, then if I'm going to add state
to it, I will need to make sure I have a constructor
137:39 - which calls super. I add a property called
state on this, this that state equals an object.
137:49 - We know that object needs to have a property
called is plugged in. We will initialize it
137:56 - as true. You were able to get to this part,
that's awesome, great job. The next thing
138:01 - is making it so that it renders the word in
here if is logged in is true or out if it's
138:07 - not. And again, we're going to cover this
when we talk about conditional rendering in
138:11 - a few lessons. But one way that we may decide
to do this is to maintain a variable that
138:17 - looks at the current version of is logged
in, and has a string that represents the word
138:23 - that should be displayed here. That display
logic, as I've mentioned, I like to do inside
138:28 - my render method but above my return. And
so I'm going to maybe initialize a variable
138:33 - called Word display. And do a simple if else
statement that says if this start state that
138:40 - is logged in, is true. We're display should
be the word in otherwise, or display should
138:52 - be out. Finally down here, instead of having
both in and out here, I'll put curly braces
138:59 - because I'm interpreting JavaScript inside
of my JSX. I will simply put word display,
139:05 - I noticed that word display is just a local
variable to the render method, I don't need
139:09 - to put this dot State DOT word display or
this dot props that were displayed because
139:13 - it is neither a prop nor a piece of state.
Now when I refresh this, I get you're currently
139:19 - logged in. And that happens because is logged
in is true. And if I change this to false,
139:24 - tell me I'm logged out. We're
139:27 - gonna see more concise ways to actually do
this is a totally legitimate way. And in fact,
139:32 - I believe this is the way that the React docs
tell you to do this. One thing I like to do
139:37 - if my variable is clearly named to be a Boolean,
like is logged in, I'm just going to get rid
139:41 - of my triple equals true because that will
already either be true or false. And that's
139:46 - it. So once again, please go back, try to
redo this yourself. See if you can do it from
139:51 - scratch, even delete the entire file and see
if you can write everything from scratch once
139:56 - again. Repetition is really going to help
you get the syntax down muscle memory so that
140:01 - you can focus more on problem solving. Once
you feel pretty good about this, let's go
140:05 - forward.
140:07 - We are at part four of our to do app. So this
should be a pretty short one. Until now all
140:16 - we've done this loaded our to dues data into
our app component by importing it and then
140:20 - mapping directly over the thing that we imported.
However, eventually, we're going to want to
140:25 - modify this data, which means that it's going
to have to live in state of this component.
140:30 - So all you need to do for this challenge is
to make it essentially so that two dues data
140:34 - lives in the state of this app component.
Pause the lesson here and give that a try.
140:40 - Okay, like I said, to dues data is just imported.
And we originally were mapping directly over
140:50 - the thing that we imported. But let's put
this on state. for that to work, I need this
140:54 - to be a class based component. That will extend
react component. parentheses, we need a constructor
141:10 - always calls super first. And we'll start
some state, which is an object and we'll have
141:17 - maybe just to use is an array, we'll start
as an empty array. And that in just a second,
141:23 - right now, this map and the return need to
happen inside of a render method, we'll just
141:30 - move that in there. And then like the challenge
says, We essentially want to load the imported
141:36 - two dues data into state, which essentially
just means that instead of an empty array
141:40 - here, we will put to dues data, then the last
thing is to change to dues data to this dot
141:47 - State DOT two dues, because that's where the
two dues data is living now. I believe if
141:53 - we refresh, we're working great. The warning
that we receive is from the previous lesson
141:58 - where we had the checked property, and we
don't have an on change. But we're going to
142:03 - get to that later when we talk about forms.
For now, this is heading in a good direction.
142:08 - We will revisit this in a little bit. But
until then, let's learn some more react.
142:15 - Before we can seriously talk about changing
state using the set state method, we're going
142:22 - to need to have an understanding of events
in react and handling events. event handling
142:28 - is essentially allowing the user to interact
with your web page and do something specific
142:33 - when a certain event like a click or hover
happens. And handling events in react is actually
142:38 - quite simple. You might be familiar with regular
HTML is the ability to add something like
142:44 - on click equals and then you execute a function
like my function. React is very similar to
142:52 - this with just a few small changes. The first
thing is that all of our event handlers are
142:58 - going to be the JavaScript version, which
has a camel case convention on click will
143:05 - have a capital C, on mouse over will have
a capital M and a capital O and so forth.
143:13 - And the reason it does this is because it
uses the same convention that regular JavaScript
143:17 - as if you were to add these events to elements
on the page. So let's make it so our button
143:23 - can do something when a click of the button
happens using onClick. And then the only other
143:28 - major change we're going to do is that instead
of passing an executed function as a string,
143:33 - we're going to pass a function directly into
a set of curly braces. I don't have another
143:39 - function pre written so I could just do an
anonymous function right here. And maybe console
143:47 - log something. We can shorten this up quite
a bit by using yes sixes arrow function syntax.
144:01 - Or as always, you could write a separate function
somewhere. And put the reference to the name
144:09 - of that function right here. Any of those
should work just fine. I'm going to save this
144:15 - and click the button. And you'll see that
we get a console log of I was clicked. If
144:21 - we open the console, we will see that more
obviously. As a quick reference, I want you
144:26 - to take a look at the following react documentation.
This is a full list of the supported events
144:36 - in react. The reason I want you to look at
this is because I want you to pause this lesson
144:41 - and add the functionality so that when the
mouse hovers over the image, another thing
144:47 - gets console log. So pause lesson here, feel
free to go to that URL and see if you can
144:53 - find the event that we'll need to use so that
when we move our mouse over the image, it
144:58 - will execute a function And then go ahead
and add that to your image element. Okay,
145:04 - so I think there might be a couple different
mouse events that we could use. But the one
145:10 - that I'm going to use is the on mouse over.
And when that happens, we will run the following
145:17 - function. And we will just console log, Hubbard
save this. And I'll open the console and try
145:27 - hovering over Bill Murray. Like that. Every
time our mouse goes over the image, it runs
145:34 - our function to handling events is going to
be really helpful. Obviously, console logging
145:39 - stuff is not all that exciting. But we're
gonna see how events mixed with the changing
145:44 - of state will allow our application to start
becoming really robust and actually really
145:49 - awesome. Feel free to add a few elements here,
see if you can do some of the other events
145:54 - that are found at this URL. And then we'll
talk about setting state in the next lesson.
146:05 - So we another really quick update to our to
do app, we just learned about how to add event
146:11 - handlers to elements. And you may remember
that we used to have a warning, saying that
146:16 - we have checked prop on our input. But we
don't have any way to change that. So it says
146:23 - it will render a read only field. So your
challenge is to get rid of this warning by
146:27 - simply adding an on change to our input. And
for now it can just console log something.
146:32 - So pause now and give that a try. I'm going
to close this console for some extra room.
146:41 - And this simply entails adding an on change
that is equal to and then I could write this
146:47 - function somewhere else. Or I'll just do an
anonymous inline function that until logs.
146:54 - While I'm at it, I'll put these on their own
lines. And now when I click these, it doesn't
147:05 - change the
147:06 - checkbox.
147:07 - But our warning is gone. And my onchange is
firing correctly. So we're going to learn
147:12 - about how to make these events actually change
our state. And then we'll be revisiting this
147:17 - app again soon.
147:19 - Okay, man, every new lesson just feels so
exciting because you're learning something
147:28 - that's like really bringing you close to making
awesome web applications with react. In this
147:33 - lesson, we're talking about changing state,
okay, having state in your component is great.
147:37 - But if you can only initialize it to a specific
value and can't change it, then frankly, it's
147:42 - kind of pointless to be there. And it's really
no better than just hard coding it into your
147:47 - code. So let's learn about changing state.
And what we have here is a component that
147:52 - is a class based component. Because we're
using state, we have our constructor, we're
147:56 - calling super, as always, we're initializing
state with a property called count, and setting
148:02 - that equal to zero. And then in our render,
we simply have an h1 that displays the current
148:07 - count. And we have a button with the word
change in it. I've added a little bit of CSS,
148:13 - so it wasn't quite so ugly. And now we're
going to learn about how when I click this
148:17 - button, using the event handlers that we just
learned about how can I change the state to
148:22 - be something different, so that clicking the
button will actually change the value that
148:27 - gets displayed here? Well, let's start by
adding an event handler, which should be reviewed
148:32 - from the last lesson. So go ahead and see
if you can make it so that when you click
148:37 - a button, maybe something gets logged to the
console. For now. Remember, to add an event
148:45 - handler I'm going to do on click in this case,
because I want it to handle the click event
148:51 - equals and then inside of curly braces, I'm
going to put some kind of JavaScript function.
148:55 - Now I could put an inline function right here,
which I don't particularly like. So instead,
149:00 - what I'm going to do is I'm now going to create
my own method constructor is a method that's
149:05 - built in to classes in JavaScript. Render
is a reserved method name for react. But in
149:12 - between here, I can put as many methods as
I want. One strong convention that people
149:16 - tend to use is to have a method called handle
click when you're handling a click event.
149:23 - So I'll finish the stubbed out version of
this and then down here, instead of an inline
149:29 - anonymous function, I'll have it run handle
click. Now let's see if I can get a console
149:35 - log to show up. Let's save that. And this
is a common mistake. When the method is part
149:44 - of my class, I need to reference it on the
this object. So this dot handle click to begin,
149:51 - click my button and says I'm working. Okay,
that worked. Well, that's pretty boring. So
149:56 - let's make it so that when I click it, actually
changes my state and increases my count. Now
150:03 - one thing that would be really tempting to
do is to try and modify state directly, as
150:08 - in typing this dot State DOT count equals
one, or saying something like plus plus, or
150:16 - this is something that you will actually never
do, you're never going to want to directly
150:20 - modify the original version of state. You
might remember in the introduction to state,
150:25 - I talked about how state is kind of like the
clothing that you wear. Well, when it comes
150:29 - time to change your clothing, you don't modify
your clothing, right, you don't paint your
150:33 - clothing a different color, you don't cut
a T shirt, and so on buttons, so that you
150:38 - can have a button up shirt instead. But what
you do is you completely replace your old
150:43 - clothes with your new clothes, or rather the
clothes you were wearing with the clothes
150:47 - that you want to wear. And this is essentially
the same thing we're going to do with state.
150:52 - You also might remember that I talked about
some kind of goodies that we're going to get
150:56 - from react component. And that's the reason
we're extending react component. Well, one
151:01 - of the things that we're going to get is a
method called set state. And anytime you want
151:08 - to change state, you're going to use this
method set state. And it's a method or function,
151:12 - so I'm going to call it and there's actually
two different things that you can pass to
151:17 - set state. Let's first look at the easier
one to understand. What I can pass to set
151:21 - state is a new version of state, while state
is just an object as we see up here. So I
151:27 - can pass to set state an object, and I can
say, the count.
151:33 - Now, one might have already figured out what's
going to be the problem with this. But let's
151:38 - see if this works. So once again, my button
has an unclick, that will run this dot handle
151:44 - click when it's click, this dot handle click
uses the set state method that comes from
151:50 - react component. And it provides a new version
of state, okay, like your new t shirt that
151:56 - you're putting on. And it says now the count
should be one, I'll click the button. And
152:02 - we run into a very common error says, cannot
read property set state of undefined. This
152:09 - brings us into a realm that's actually kind
of hotly debated with react. And I'm going
152:15 - to give you a very simple solution to this,
that may not make a whole lot of sense at
152:19 - first. Essentially, anytime you create a class
method that you want to use set state on,
152:27 - you're going to need to bind this method to
your own class. If you're not really familiar
152:34 - with binding, I'm not too worried about that
right now, just know that anytime you write
152:38 - a method that uses a set state, you'll want
to bind it and the way you bind it is inside
152:43 - of your constructor, we're going to say this
dot handle click equals this dot handle click
152:51 - dot bind this, like I said, this is probably
pretty confusing if you're not familiar with
152:58 - binding. But essentially, what it does is
it makes sure that the handle click method
153:04 - is bound to the context of this as it exists
within this class. I'm going to refresh this
153:12 - and click my Change button again. And awesome.
Look, our state changed from zero to one.
153:18 - Now this is where the problem that you may
have figured out already comes into play.
153:21 - If I click Change, again, it looks like nothing's
happening. But in fact, it's actually doing
153:26 - what I told it to do, right? When I click
the Change button, it sets the state to the
153:32 - count. And the count is now one. Well, it
was already one and I'm changing it to one.
153:38 - So it's actually not changing. Therefore,
I can't see it changing on the display. So
153:42 - that brings us to the second way that I could
use set state, if I don't care about what
153:47 - the previous version of state was. passing
in an object is a really nice simple way to
153:53 - provide a new state. But a lot of times we
actually do care what the previous state used
153:57 - to be. In this case, we want to know what
the previous state was. And we want to add
154:02 - one to it. So anytime I need to know what
the previous state was, I can also pass a
154:07 - function to set state that function is going
to receive in its parameter, the previous
154:15 - version of state. This is really important.
And it might be tempting to think that you
154:19 - can just access the previous version of state
using this dot state, which sometimes will
154:24 - work but oftentimes will not. And so it's
really important to always pass previous state
154:31 - or whatever variable name, you want to give
this to your function. Now because it's an
154:35 - arrow function that just has one parameter,
I can get rid of my parentheses around that
154:40 - parameter. And what my function should return
is a new version of state. Okay, so before
154:47 - we provided just a new version of state directly
as an object literal, but this time we're
154:53 - providing a function that returns that object
literal. The benefit of doing it this way
154:58 - is we have access to the previous version
of state. So in my function, I'm going to
155:03 - return an object, that object should have
a count property, so that I don't break my
155:09 - this dot state count down here. And I want
you to take a second and see if you can figure
155:14 - out what the value of that property should
be. So positive lesson and give that a try.
155:20 - So remember, previous state represents the
old version of state. And the old version
155:29 - of state is an object. So I can access the
previous version of state by saying proof
155:34 - state. But that's the whole object, I just
want to count property. And I'm not going
155:39 - to say plus plus, because that's directly
modifying the old version of state. But instead,
155:45 - I'm going to just add one to it, we computer
will do is it will figure out what the count
155:50 - used to be, they will add one to that. And
it will set that as the new count property
155:55 - of my new state object that's getting returned
from this function. Now, when I save this,
156:01 - and refresh, and I click Change, I can click
it multiple times. And it will continue to
156:05 - increase the number that's displayed on the
screen. And this is really cool. I mean, it
156:11 - seems kind of lame, because all I'm doing
is increasing a number. But this opens up
156:14 - so many possibilities. And you're going to
see from here on just how much we're going
156:19 - to be able to do with react. Now that we have
the ability to have components, maintain their
156:24 - own data and state and actually change their
own data using set state. I mentioned before
156:29 - that you are allowed to pass state down to
other components as props, for example, having
156:35 - a
156:37 - child component of some kind that receives,
you know, your account, your state. And if
156:46 - we were to define this child component, we
would see that it's receiving a prop called
156:51 - count, the value of which is the current state
of its parent component app. Well, what react
156:58 - will do is anytime this value changes, anytime
it sees that there's a child component that's
157:05 - receiving a value that changes, it will rerender.
This component, it will run that components
157:13 - render method, once again, or if this is a
functional component, it will just run that
157:17 - function again, so that that component can
reflect the new version of props that it's
157:23 - receiving. And in this case, it will change
every time the state count changes on the
157:29 - app component, which as we just made it do
happens every time we click the Change button.
157:33 - So right now child component isn't actually
defined. So I'm going to get rid of that before
157:37 - I get a syntax here. And let's do a quick
recap of everything we did. We have our h1
157:43 - displaying our state, which just has a count
property, we initialize that count property
157:47 - to zero, we added an event handler to our
button that runs a method called handle click
157:55 - handle click is a method defined on this class.
And because handle click is using the set
158:02 - state method that comes from the parent class
react component, we need to make sure to bind
158:08 - it, which we can do inside of our constructor.
And once it's bound, we can run set state,
158:15 - which can either take an object literal, which
is the new version of state that we want to
158:21 - pass to it. Or if we care about what the previous
state used to be, we'll pass it a function
158:27 - that takes the previous state as a parameter.
And that function should return the object
158:33 - literal that represents the new version of
state. Now I just rattled off a lot of jargony
158:38 - stuff. So I want you to spend some time with
this state is going to be extremely important
158:43 - for you to understand. And we're going to
be using it pretty much through the rest of
158:47 - the course, though spend some serious time
with this, I'd highly recommend as I have
158:52 - in the past tried deleting this entirely writing
it from scratch. And we're probably a good
158:57 - stepping stone to that is rewinding this video
to the beginning and seeing if you can add
159:02 - all of this stuff again, you're also welcome
to try adding different events that may also
159:08 - change state in play with the state that's
getting changed, maybe you want it to increase
159:13 - by more than one or something like that, I
don't know. One really good exercise is to
159:17 - have a button that will double the number
and another button that will have the number.
159:24 - So there's plenty of things that you can try
to do with this. So use your creativity and
159:28 - your imagination, see what you can come up
with. But spend some real time with this and
159:33 - play with it. Then in the next lesson, we're
going to get a chance to practice this.
159:40 - Okay, we've come to a pretty beefy part of
our to do app, we're going to make it so that
159:48 - when we click the checkbox, it actually makes
a change to our state. And this actually is
159:53 - a little more involved than it may sound but
it's really not too bad. up near the top.
159:57 - I've written down what your challenge is and
This will help you accomplish this task. And
160:03 - I've also stubbed out the handle change method
and written some pseudocode inside here. So
160:08 - you have some hints, essentially to help you
accomplish this. And just so there aren't
160:12 - any weird bugs, I've also bound this in the
constructor for you. So your challenge is
160:17 - going to be to take this stubbed out, handle
change and actually implement it so that when
160:23 - somebody clicks the checkbox, it makes a change
to your state and updates the item that they
160:28 - checked so that the completed property flips
from either true to false or false to true.
160:33 - And then you're going to make sure to pass
the handle change method down to your to do
160:38 - item. And then over in your to do item, you'll
need to implement the on change with the new
160:44 - method that you've passed to it. So I go back
here to app. Pause now and go ahead and get
160:49 - started. Okay, so I might do this a little
bit out of order. But I think the very first
160:59 - thing I'm going to do in my handle change
is just to console log something. Say we changed.
161:07 - And since we're getting the ID, let me just
go ahead and add the ID to my console logs,
161:12 - so I can make sure that that's working. And
then I think what I'll do is hook up parts
161:17 - two, or complete parts two, and three, and
just see if I can get this console log to
161:22 - happen. And then we'll go ahead and add this
logic. And so part two says that I need to
161:28 - pass the method down to the to do item components.
So right here, I have my to do item, which
161:34 - gets a key and the item. And let's go ahead
and pass down a handle change was passed down
161:42 - this dot handle change. And then over into
do item, it's now receiving a prop called
161:48 - handle change. So props that handle change.
And notice that it says it's going to be taking
161:53 - the ID as a parameter. However, we know that
events when they fire, they actually receive
162:00 - an event property. And so it won't be good
enough to just say props dot handle change,
162:06 - because because this is not going to receive
an ID property, it's going to receive the
162:11 - event object instead. And so what I can do
is say, Well, this is the function that's
162:17 - receiving the event here. And what it does
is it calls props dot handle change. And now
162:25 - I can pass whatever properties I want to this,
I want to say props.item.id. Since I'm not
162:33 - actually using this event, in this case, I'm
just going to get rid of that, it'll just
162:36 - be an empty function that calls props dot
handle change and passes the ID to it. So
162:42 - let me update my page. And we'll open the
console and just see if my console is working.
162:47 - Okay, change to change three, one, notice
that it's matching up with the ID of the item
162:56 - that I'm clicking. So this is ID of one ID
of two ID of three. And if I click the clean
163:02 - Gecko tank number three, it says Edit change.
Number three, awesome. So we've made some
163:06 - good headway there by finishing parts two
and three. But let's get to actually updating
163:13 - our state. This is the trickier part. The
part that's tricky about this is that we need
163:18 - to deal with the entire array, because we're
saving an array in our state. And we never
163:24 - want to modify state directly, it won't be
as easy as just looping through this array,
163:30 - finding the item with this ID, and then flipping
it because that will actually modify the existing
163:35 - state. But instead, we can essentially do
that same thing. And just make sure that we
163:40 - return a brand new array where almost all
of the items are exactly as they used to be
163:46 - except one item has changed its completed
property from true to false or false to true.
163:51 - And a great way to do that is to use the dot
map method, because this returns a brand new
163:55 - array. And so what I can do is I'm going to
start my set state. Because I do care what
164:03 - I have in my previous state, we're going to
use the function way of updating state and
164:10 - receive my previous state. And then what I'll
do is I will use map to loop over my proof
164:17 - state.to dues array and look for a to do with
the ID that is given here in the method. And
164:25 - so I'll create a variable that says maybe
updated to dues. That's going to be my old
164:33 - version of to dues. And sorry, this shouldn't
be this that state but rather create State
164:38 - DOT map. And we're going to look at each one
of the two dues in
164:41 - this array. We'll run this function and we're
going to say if print to do that we're looking
164:47 - at has an ID that's equal to the ID we received
from our parameter up here. Then we know this
164:55 - is the to do item that we want to flip the
completed property of So I can say the to
165:01 - do dot completed, should equal the opposite
of whatever it currently is. And whether or
165:08 - not we actually did that flipping of the completed
property, we're going to return that to do
165:13 - that makes it so that it puts this to do item
in our new array in the same index have the
165:18 - original array. And all of this is my map.
And so what my set state needs to do is actually
165:25 - return a new version of state, which is just
an object. And our state is an object with
165:31 - a to dues property. So I'll say to dues now
be the updated version of to dues, the array
165:37 - that we just created. Let me clean this up
a little bit, get rid of these comments, this,
165:45 - and let's try flipping these awesome. And
it looks like everything is working the way
165:52 - it should. So as a recap, we are looking at
our previous state, and we're creating a new
165:57 - array that almost perfectly mirrors what it
used to be except one of the items, which
166:03 - has the same ID as this function received
from the on change handler that is happening
166:09 - when we click these checkboxes. That one item
is changing from true to false or false to
166:14 - true. And then this brand new array is essentially
replacing the old array that we had up here,
166:21 - and it gets rendered to the page. Then we're
taking this handle change method, and we're
166:27 - passing it down to every one of the to do
items that we create in our map down here.
166:32 - And those to do items are receiving the handle
change. And anytime it's checkbox gets checked,
166:39 - it calls on change. And that has an anonymous
function, which then calls handle change and
166:45 - passes this items ID so that we can correctly
identify which in the array we need to flip.
166:51 - And as a reminder, the reason the checkbox
is actually showing up or not showing up is
166:55 - because of this checked property checked determines
whether the checkbox should be checked or
167:00 - not. And it says if the item is completed,
then it should be checked. And if the item
167:04 - is not completed, and it shouldn't be checked.
And essentially what we have now is a working
167:08 - to do app, we're going to do some small tweaks
to it. But great job. Hopefully everything
167:14 - that we've covered so far makes sense. And
we'll be revisiting this soon to talk a little
167:18 - bit more about styling, but feel free to celebrate
a little bit and whenever you're ready, we'll
167:22 - go forward.
167:24 - One of the really nice things that we've mentioned
about react is how we get to essentially just
167:34 - write vanilla JavaScript. And react is taking
care of a lot of stuff behind the scenes,
167:40 - will with the stuff that's going on behind
the scenes, every single component that we
167:44 - create, is actually going to go through a
series of phases or milestones during its
167:49 - time being alive in your react application.
Often this is analogous to a human being who
167:55 - is born has life milestones, and dies. Similarly,
every react component will undergo a series
168:02 - of events when it's being rendered and updated.
Now I've divided lifecycle methods into two
168:08 - parts, because the React team has just recently
deprecated or gotten rid of three of the original
168:13 - lifecycle methods that we're about to talk
about. And instead of going through every
168:18 - single one of these individually, I'm actually
mostly going to just talk about the ones that
168:22 - are the most important to you right now as
you're learning react. And then as you continue
168:27 - to learn, you can play with some of these
other ones as well. For for reference, I'm
168:31 - going to post here a URL to a site that does
a really good job explaining the lifecycle
168:37 - methods that were a part of react before version
16.3. Check out those changes that happened
168:45 - in 16.3, you can check out this website, which
is the official blog of the React team. With
168:50 - that being said, let's start talking about
the lifecycle methods that were most likely
168:54 - or most commonly going to use. The first is
one that you're actually already familiar
168:59 - with. And it's a little bit of a gray area,
because this is oftentimes not listed as a
169:03 - lifecycle method. But the render method, right
here is something that we've been using, as
169:09 - we've talked about class based components.
And one analogy that I like to use is that
169:14 - it's like getting dressed for the day. Its
job is to determine exactly what gets rendered
169:20 - to the screen, which in turn is how the component
is displayed to the world. Now the render
169:27 - method can be called many times, anytime react
determines that something changes like state
169:33 - or props, which might affect how the component
is supposed to display, React may run the
169:38 - render method once again. Similarly, you may
have had days where you've decided to change
169:44 - your clothes and look a little bit different
to the world based upon what you're about
169:47 - to do. So hopefully by now that one's pretty
straightforward. The next lifecycle method
169:53 - that I want to talk about is called component
did mount and these lifecycle methods are
169:57 - defined just like other methods inside of
your class. Here. So I might say component
170:02 - did Mount camelcase, like this component did
mount is a lifecycle method that's essentially
170:11 - like saying you were just born the component,
this component did just mount to the screen,
170:18 - the very first time the component shows up,
React will run the component did mount method.
170:23 - This method will only run once while the component
is showing up on the screen. Things like a
170:29 - rerender, which changes the way that the component
is displayed does not rerun component did
170:34 - mount. And that's because the component doesn't
actually unmount and remount. Most common
170:40 - use case for component did mount is to do
things like an API call when you need to get
170:44 - data from some kind of external source. For
example, maybe this component is actually
170:49 - a to do list. And I need to get the list of
to dues from some kind of server or database.
170:57 - Before I'm able to accurately display my to
do list. As soon as the component finishes
171:03 - mounting, I can get the data I need to correctly
display. We're going to see this in a future
171:12 - lesson. But just know that that's one of the
most common use cases for component did mount.
171:17 - The next lifecycle method I want to talk about
right now is called component will receive
171:22 - props
171:29 - component will receive props is kind of like
when someone gives you a gift. This component
171:33 - could be receiving props from a parent component.
And every time this component is receiving
171:38 - props, it will run this component will receive
props method, and component will receive props
171:44 - will not only run the very first time the
component is mounted. But it will also run
171:49 - every single time a parent component decides
to hand props to a child component. For example,
171:54 - if a parent component decides to change the
props that it's passing down to this component,
172:00 - one thing we can do inside of component will
receive props is check to see if the new incoming
172:06 - props are even different at all from the existing
props. Oftentimes, we will then say if they
172:12 - are not different, just don't do anything.
But if they are different, maybe I have some
172:16 - kind of calculation to run or state to set
or something like that. To receive those new
172:21 - incoming props component will receive props
receives a parameter called next props. And
172:27 - it's just a parameter so you can call it whatever
you want. But oftentimes, we put next props.
172:32 - And sometimes you'll see something like an
if statement that says if next props dot whatever
172:38 - property you're looking at, does not equal
the existing props.
172:46 - Then
172:48 - do something important here. So there's some
good use cases for component will receive
172:54 - props. However, as I mentioned, this is actually
one of the lifecycle methods that's going
173:00 - to be deprecated, or actually is deprecated.
Starting in 16.3. Until react 17 comes out
173:07 - they've renamed this with all caps unsafe
underscore component will receive props. So
173:13 - if you really need to use this, you can still
do so. But once react 17 comes out this is
173:19 - going to be completely removed in component
will receive props will no longer mean anything
173:23 - special. So just be aware of that. It's a
good lifecycle method to understand. If you're
173:28 - looking at legacy code. For going forward,
this won't be a part of react anymore. Another
173:34 - cool lifecycle method is called should component
173:36 - update.
173:41 - And in our person analogy, I like to think
of this as making a decision as to whether
173:45 - you need to change your clothes or not. Behind
the Scenes if react has any kind of question
173:50 - at all as to whether a component needs to
rerender it will always choose to rerender
173:54 - it just in case without any logic specific
to your applications needs behind that decision.
174:00 - I think I said in the past that sometimes
react will rerender a component even if nothing
174:05 - about that component has changed. Well, that
can become kind of an expensive or rather
174:10 - slow operation. If you let that happen to
every single component in a large application.
174:16 - Should component update gives us the developer
a chance to optimize our app, we can implement
174:22 - some logic here that allows the component
to determine whether or not it's important
174:27 - for it to even think about updating. To help
make that decision. This is going to receive
174:33 - the incoming props and the incoming state,
which we'll call next props in next state.
174:40 - And in the body of the function we need to
either return true if we do want it to update
174:52 - or we can return false if we don't want it
to returning false Should component update
175:01 - is what will make your application more performant.
But you'll just want to make sure that you
175:06 - actually don't want this component to update.
Otherwise, it could really introduce some
175:10 - weird and hard to debug bugs into your code.
Less lifecycle method we'll talk about right
175:15 - now is component will unmount. Just like in
life, all good things come to an end and your
175:25 - component will eventually unmount from the
screen or disappear altogether from the screen.
175:30 - The main use case for component will unmount
is to do some kind of cleanup or tear down
175:35 - of anything that you've set up, it could potentially
lead to clutter in the DOM or in your application.
175:41 - One of the most common use cases for this
is if you in component did mount set up like
175:46 - an event listener, for example, you wanted
to run some code every time somebody scrolled
175:51 - on the screen, this would be a chance to remove
the event listener, that that's just one example.
176:00 - In general, it's a place to tear down or clean
up your code before your component disappears.
176:07 - I'm going to move to this after that, so that
it's obvious. It's just an example. And that's
176:16 - actually all the lifecycle methods, we're
going to cover in part one here, there are
176:21 - a number of other ones that are important
to understand. But for now, they're more advanced
176:26 - than what we're planning on getting into in
this course. And so I'd recommend if you're
176:31 - interested in learning more about them, going
up to this link up here. Now this link was
176:37 - written before 16.3 was announced. So also
take a look at the second link here, which
176:42 - will talk about the three lifecycle methods
that have been deprecated. As well as the
176:46 - two new lifecycle methods that are introduced
in their place, which we're going to cover
176:52 - in the next lesson.
176:59 - You had a chance to go over this link here,
which is the announcement of react 16.3. And
177:04 - the changes that came with it, you will have
read about the three lifecycle methods that
177:08 - have been deprecated. One we talked about
already, this component will receive props,
177:13 - that's going away. A couple more lifecycle
methods that are also being removed our component
177:18 - will mount I'm just going to comment that
out right away, as well as component will
177:28 - update shall also comment out those three
component will mount component will receive
177:36 - props and component will update are being
deprecated or removed from react. In its place,
177:41 - we're receiving two new lifecycle methods
that we can use. One is called get derived
177:47 - state from props. Now there's one change about
get derived state from props. And that's that
177:53 - it's a static method. So we have to include
the word static beforehand, get derive state
177:58 - from props receives props in state and should
return the new updated state based upon the
178:08 - props. And I don't plan to go too much more
into this. And the reason is because the React
178:14 - team has actually written a blog about how
you probably don't need derived state. A lot
178:20 - of times this has been misused and caused
weird bugs or performance issues in people's
178:26 - applications, when in reality, there's actually
a better way to go about what they were trying
178:30 - to do. The idea behind get derive state from
props is for like it says in the blog, the
178:36 - rare cases when your component needs to take
incoming props it's receiving from its parent,
178:43 - and set its own state based upon those props.
But again, the React team kind of discourages
178:49 - the use of this method. And so I'm not going
to talk too much about it. And we probably
178:53 - won't be using it in this course. However,
if you're interested in learning more about
178:57 - it, here's a link to the docs on get derive
state from props. And the last lifecycle method,
179:05 - the new one that's being introduced is called
get snapshot before update. You can think
179:12 - of get snapshot before update as a lifecycle
method that allows you to sort of create a
179:17 - backup of the current way things are. When
I say backup really all you'll be saving is
179:25 - some kind of data of some sort, probably an
object with multiple points of data inside
179:30 - of it. And that object would be called the
snapshot because it's like a snapshot of the
179:35 - way your application is right now. Again,
the React team says that it's not a super
179:40 - common lifecycle method that you'll end up
using. And so we're not going to talk too
179:44 - much more about it. But once again, here's
the documentation if you're interested in
179:48 - learning more about it. So that's essentially
it for lifecycle methods for now, as you get
179:54 - more and more advanced in the applications
that you're building with react, you'll definitely
179:58 - want to become pretty familiar with these
lifecycle methods. For this course, we'll
180:03 - pretty much plan on sticking to component
did mount and render. And if we end up meeting
180:09 - another one, then I'll make sure to talk more
about it at that time. Feel free to read through
180:14 - some of these articles. And when you're ready,
let's move on.
180:19 - You know, one of the hardest things about
teaching react is that you learn a number
180:26 - of tools that can be used in a variety of
ways. But you aren't necessarily constrained
180:31 - to just one way of using a tool. The other
thing is react uses so much vanilla JavaScript
180:36 - that a lot of what you can do with react is
done a number of different ways, using just
180:41 - vanilla JavaScript. Conditional rendering
is where this kind of comes into full view.
180:47 - So I just wanted to start with that caveat,
before we get into this, because I don't want
180:51 - anyone to think that the way I'm about to
show you conditional rendering is the only
180:55 - way it can be done, I'm going to cover a number
of use cases, but there's for sure going to
180:59 - be other ways to use it that are totally legitimate.
So I've done here is I've added a class based
181:06 - component, it has state with a property called
is loading that is either true or false. This
181:12 - is something that's oftentimes used when you're
making a call to an API. And in the meantime,
181:18 - you want something to show up, perhaps that
call to the API will take three or four seconds.
181:22 - And you don't want the user to think that
your website has crashed. And so you'll maintain
181:26 - something in state that says, hold on just
a second we're loading right now. And conditional
181:31 - rendering will be used to actually display
something on the screen that tells the user
181:36 - that you're currently loading something in
the background. We'll talk about component
181:39 - did mount in a second. But now in the render,
you'll see that we are rendering a component
181:44 - called conditional, which I'm importing up
above, and I'm passing a prop to it called
181:50 - is loading, which is the current version of
state. And then over and conditional, we're
181:55 - going to be adding what gets displayed on
the screen here for now. But before we get
181:59 - there, I want to be clear of what's happening
with our component did mount. Remember that
182:03 - component did mount is a chance for us to
run some code right after the component, our
182:08 - app component in this case mounts on the screen
for the very first time. And what I'm doing
182:13 - here is kind of faking an API call, I've set
a timeout, which will wait one and a half
182:19 - seconds before running the code that's in
the function I provide it. And what's happening
182:24 - in that function is I'm changing the state.
So that loading is false. Think of this as
182:30 - a fake way to pretend that we're making a
call to an API that takes 1500 milliseconds,
182:35 - or one and a half seconds to come back with
data. At which point we're saying we are no
182:40 - longer loading because we finished loading
the data from the API. And once we talk about
182:45 - using fetch to get data in a future lesson,
we're actually going to be doing this for
182:49 - real, but I just wanted to make sure this
wasn't confusing before we move on. And actually,
182:54 - this is a good time to talk about the lifecycle
methods once again, because once set state
182:59 - changes is loading to false, our component
or conditional component, is now receiving
183:04 - a different Prop, because it's receiving is
loading of true when it first loads. And then
183:11 - when state changes and is loading as false.
It's receiving a new Prop, or rather, it's
183:17 - receiving the same is loading prop with a
different value. And so what will happen is
183:22 - when the state changes, our render method
will run again, because something has changed,
183:28 - which means the conditional component will
also rerender. Now conditional is just a functional
183:34 - component, which means the function will just
run again. And whatever we're returning from
183:39 - here could potentially change because props
are going to be changing. When we get to the
183:44 - end of this lesson, I'll highly encourage
you to play with it because this is a really
183:47 - important topic. Okay, so my conditional component
is receiving a prop called is loading. And
183:54 - before we get anywhere else, let's see if
our set state is working. I'm going to fix
183:59 - the syntax error by actually having something
render here. And I'm going to console log
184:07 - props.is loading. Notice that and I'll refresh
this again, notice that immediately, what
184:15 - happens is it shows up as true. And then 1500
milliseconds, or one and a half seconds later,
184:20 - it re console logs false. And that's because
over an app, after 1500 milliseconds, it changes
184:27 - state to false, and that's when conditional
re renders or runs again, and the props that
184:34 - it's receiving changes. So first, it logs
true and then it locks false. Well, let's
184:40 - talk about conditional rendering. Essentially,
all that means is that I'm going to load something
184:45 - on the screen if a condition is true. In this
case, instead of an h1 that says temp. What
184:51 - I might do is say if upstart is loading is
true, then what I want this component to return
185:04 - is an h1 that says loading. But if props that
is loading is not true or in other words,
185:12 - I can put that inside of an else
185:13 - once you to return 
and have different text. And notice what happened
185:29 - when I refreshed, I'll do it again. At first
it says loading. And then it changes to the
185:35 - different h1 that we have here that says some
cool stuff about conditional rendering. The
185:40 - app component starts with is loading is true,
and therefore renders a conditional component
185:47 - where is loading prop is true. And then the
conditional component checks if props that
185:55 - is loading is true. And first, it loads this
h1 or renders this h1, then when props.is
186:03 - loading changes to false because the state
of the parent component changed to false,
186:08 - the conditional component that we have here
runs once again and it notices that prompts
186:13 - that is loading is no longer true. And therefore
what it returns is this h1 instead, this is
186:19 - just using plain JavaScript. And if statements.
One thing that I personally prefer, because
186:25 - I'm returning from my function in my if statement
is I don't actually need my else here. This
186:31 - will simplify my code a little bit. And this
return will only run if my if statement does
186:38 - not evaluate to true. And therefore it's kind
of an implied else. Well, this is a perfect
186:44 - time to talk about a common way to do this
kind of if else rendering using something
186:50 - called a ternary. operator. If you're not
familiar with turn Aires, this is not even
186:54 - a new feature in iOS six, this is something
that's been around for a while. And it's very
186:58 - commonly used in react applications. When
it comes to conditional rendering. Essentially,
187:02 - the way it works is you provide a condition
and then a question mark, you provide a statement
187:10 - if it's true, followed by a colon, and then
a statement. If it's false, in our case, our
187:21 - condition is, is props.is loading equal to
187:25 - true.
187:27 - And then I like to read it like an English
sentence with the question mark props that
187:30 - is loading is true. If so then I want this
h1 otherwise, is what my colon means I want
187:39 - this h1. Well, I'm going to have a syntax
error here. And that's because when we're
187:47 - doing this inside of a component, we have
to do this inside of our return. So I'm going
187:52 - to delete what we have here, I'll delete my
comment, I'll add a return. put this inside
187:59 - of my return. Now, technically, this works.
If I refresh, you'll see it shows loading,
188:05 - and then some cool stuff about conditional
rendering. But this looks really strange to
188:09 - me as because we're not immediately returning
a parent JSX element, which we usually want
188:14 - to do. So I'm going to wrap this whole thing
in a div. And then when I refresh, you're
188:21 - gonna see that there's another error we have
to fix. Notice that it's literally interpreting
188:25 - as text, the stuff that I shoved inside the
div. So if I want this to be interpreted as
188:31 - JavaScript, I need to wrap it in curly braces.
And now when I refresh, we're back to working.
188:37 - What's nice about this is that when I inevitably
have other things on my page, like some kind
188:42 - of navbar, which I'll represent with another
h1 here, maybe a footer, I can still be rendering
188:55 - conditionally parts of my page. Another simplification
that I can make here is because is loading
189:02 - is already a Boolean, I technically don't
need the triple equals true, I can get rid
189:06 - of that. And this will test the truthiness
of props, that is loading, I'll refresh and
189:11 - you'll see it works the same. There we go.
Now, I put in this navbar, and footer as demonstration
189:18 - purposes, but I want to remind you, there's
so many different ways that you can structure
189:22 - this, that it's really hard to teach all of
them. For example, usually you won't have
189:27 - your navbar and your footer inside of a child
component of your app, these would likely
189:31 - go in your app component or somewhere similar.
That's a parent of this little conditional
189:36 - component. And another thing is I've put this
conditional rendering here inside of the conditional
189:43 - component, just so we could see it all in
one place. But the truth is, our app component
189:47 - is probably the one that should be in charge
of the conditional rendering. The reason is
189:52 - whatever we put in our conditional component
should probably just be able to display when
189:58 - it's told to display it. If our app is in
charge of determining if something is loading,
190:04 - then it's probably the one that should determine
what should be rendered down here in the render
190:09 - method. So the way that I would actually probably
structure this in this specific case, when
190:14 - we're talking about having a loading thing
pop up on the page is right here, I would
190:19 - put my conditional this.state.is loading,
question mark, and if so, display our loading
190:28 - word. But otherwise, display our component.
Which means this conditional component wouldn't
190:40 - even need a prop called is loading. In this
particular case, and over in conditional j
190:46 - s, I would just display the stuff that I wanted
it to display. And we see that it's still
190:56 - working this way. Obviously, the navbar and
the footer are gone. But the point is, this
191:01 - function should only really know what to do
when it's supposed to display. And our app
191:06 - component being the one that's maintaining
whether something is loading or not, can determine
191:12 - in its render method, which should display
here. In part two of conditional rendering,
191:16 - we're going to see some other ways that this
can work. But before doing that, I'd really
191:21 - encourage you especially since this is the
first time we're using component did mount
191:25 - in a real way to play with this code, spend
some time playing with the different ways
191:30 - we've already talked about here with conditional
rendering. And once you're ready, let's move
191:34 - on to part two.
191:39 - There's actually only one extra little part
with conditional rendering that I'd like to
191:45 - cover right now. And that has to do with using
the logical AND operator, you may be used
191:51 - to using the logical AND operator to refer
to something on the left and something on
191:56 - the right as billions in determining whether
the entire condition should be considered
192:01 - true or false. So for example, true and false
would be false. Because with the AND operator,
192:08 - both sides need to evaluate to something truthy
in order for the whole thing to be true. Well,
192:13 - in reality, under the hood, what JavaScript
is doing is with the AND operator, it's determining
192:18 - the truthiness of the thing on the left. And
if the thing on the left is truthy, it just
192:24 - immediately returns the thing on the right,
which means when it's true and false, it returns
192:30 - false, because that's the thing on the right.
If the thing on the left is falsie, then it
192:37 - just returns false right from the beginning.
And so the AND operator can be a way to conditionally
192:44 - render something if a condition is true, or
just render nothing if it's false. So with
192:52 - this little example that I've created, I've
added some unread messages in state as an
192:57 - array of strings. And you can see here it
says you have to unread messages because the
193:02 - length of the race too. But a lot of times,
you wouldn't necessarily want it to say you
193:07 - have zero unread messages, you may just want
it to instead not have any h2 there at all.
193:14 - Okay, using the ternary that we learned in
the last lesson, I could say something like
193:18 - wrap this whole thing in curly braces, and
then say, essentially, if this dot state unread
193:26 - messages that length greater than zero, then
render this array, but otherwise render nothing.
193:36 - So I could just say no, let me clean this
up a little bit. It's a little easier to read.
193:42 - But I can simplify this a little bit by getting
rid of my ternary. And my No, and just saying,
193:48 - check the truthiness of this dot State DOT
unread messages dot length is greater than
193:53 - zero. And so in other words, if that's true,
and render this part, however, if it's false,
194:01 - it will just render nothing. And we can see
on our screen, there's nothing there. Once
194:06 - I add some unread messages back
194:08 - shows up. So
194:12 - the AND operator isn't strictly necessary,
because you could most of the time, just use
194:16 - the ternary where one of the results is no,
but this can really kind of simplify it just
194:21 - a little bit. And you may be seeing this every
now and then in the code that you look at
194:26 - with other people's react code. So that's
pretty much it with conditional rendering.
194:30 - Let's go ahead and move on.
194:34 - Okay, let's practice some conditional rendering.
So here your challenge is given a stateless
194:42 - functional component, just this app component
down here, I want you to follow whatever steps
194:48 - it takes to add some state to it. I want you
to then have that state keep track of whether
194:53 - the user is logged in or logged out. Then
you should have a button that will change
195:00 - That state. In other words, a button that
logs them out if they're logged in or logged
195:03 - them in if they're logged out. And there should
be some text on the page that says whether
195:09 - they're logged in or whether they're logged
out. If you want an extra challenge, make
195:13 - it so that the button will actually display,
log in if they're not logged in and log out
195:19 - if they are logged in. So as usual, give us
your very best shot. And we'll give you a
195:24 - few hints if you need them in just a few seconds.
But in the meantime, pause the video and try
195:30 - it out.
195:34 - Okay, really quick, some additional hints
that you might need, because this is actually
195:40 - putting together quite a few of the lessons
that we've talked about recently. So one thing
195:45 - is in order to add state, you'll need this
to be a class based component. And part of
195:54 - that is you'll need to add a constructor method
to that class based component for keeping
196:00 - track of whether the user is logged in or
not, you could use a Boolean is like in the
196:07 - Boolean either true or false. Adding a button
that logs the user out will require an event
196:16 - listener, which would be your unclick. Probably,
and then both the extra challenge and challenge
196:24 - part number four would require some conditional
rendering. So if you're feeling a little bit
196:33 - stuck, feel free to pause it again and try
it out. Now that you have some hints as to
196:38 - how to complete each step. And we'll go through
this together in just a few seconds.
196:42 - Okay, let's try this out. So we need to make
our component into a class based component
196:51 - because well, actually, for a couple of reasons.
One is we want to keep track of state, which
196:56 - means we are required to have a class based
component. But we're also going to be writing
197:00 - an event listener. And technically, I could
just write another function that handles that.
197:05 - But personally, I prefer to have a class based
component and put my event handlers inside
197:10 - of the class itself. Okay, so to change this
to a class based component, we need to change
197:15 - function to class, it rid of our parentheses,
will extends react component return needs
197:25 - to be inside of a render method. We'll move
it there. And to add state to it, we know
197:33 - we need a constructor method. Always call
super First, add a property called this dot
197:41 - state which is an object we'll initialize
it with is logged in of true or actually the
197:49 - start false. Okay, so that is steps number
one and two. Now we need to add a button that
197:55 - will change is logged in to true or false.
And so there's a couple things we can do.
198:01 - One is inside this div, let's get rid of that
and we'll add a button. And for now, I'll
198:09 - just say log in. And we'll play with this
a little bit later with the extra challenge.
198:18 - Now I need to add an event listener to this
so that the button being clicked actually
198:22 - does something. So add an unclick equals a
call this dot handle click. So anytime This
198:30 - button is clicked, it will call this classes
method called handle click well that doesn't
198:34 - exist yet. So let's create it. Right here,
I'll add a handle click. And I'm probably
198:44 - going to run into a binding error here. So
I might as well bind this now. Let's say this
198:49 - dot handle click equals this I have a quick
dot bind this. Before I get too far, sometimes
198:56 - I'd like to have little sanity checks along
the way. I'm just going to put a console log
199:00 - here. Now we can check if I click the button
if it will console lock I'm working. Refresh
199:09 - the page and I get this login button. And
when I click it, okay, our console log is
199:14 - working just fine. And that's awesome. Now
the thing I want handle click to do is change
199:20 - false to true or true to false depending on
which one it currently is. And anytime I'm
199:26 - going to change state, I need to run this
dot set state. And remember, there's two different
199:32 - ways that I can set state two different things
I can provide to the set state method. Take
199:37 - a second to think of what those two things
are and which one is going to be most useful
199:41 - in this case. So I can either provide set
state, just a brand new version of state,
199:50 - and it will smartly combine and replace the
current version of state. But since in this
199:56 - case, I actually need to know whether it currently
is logged in. Rather, if logged in is false
200:03 - or true, I need to instead provide a function
that has the previous state asked to it so
200:10 - that I can use that previous state to determine
what the new state should be. My function
200:15 - is going to return the object literal Where
is logged in, the value of is logged in is
200:23 - the opposite of whatever it used to be.
200:29 - This is a really concise way to change a Boolean
from false to true or true to false. Technically,
200:33 - you could also do an if else statement that
says if proof state.is logged in is true,
200:39 - then return an object Where is logged in as
false. Else return an object Where is logged
200:44 - in is true. But this way, I just say Just
give me the opposite of whatever it used to
200:48 - be. Now, we don't currently have a really
great way to see what the current version
200:54 - of state.is logged in is. But I can do this
extra challenge right now and make the button
201:01 - say login or logged out depending upon what
the current version of status. So I might
201:07 - do that right here in the render. And the
first thing that comes to mind is just to
201:11 - have some button text saved in a variable.
So I can initialize this variable, and then
201:17 - I can say it equals, I'll use a ternary to
determine whether it says log in or log out.
201:25 - So if this.state.is logged in is true, I want
the button text to be logged out. If they're
201:33 - logged out already, I want it to say, login.
Man, instead of hard coding a login here,
201:41 - I will put button text. Hopefully this will
actually show us whether they're logged in
201:46 - or out on the button, it says login, I click
it, and then it says log out. So I know under
201:52 - the hood, my state is actually changing. Awesome.
Okay, Part Four to display text that says
202:02 - log logged in or logged out, depending on
the current version of state is actually pretty
202:09 - straightforward. It's about the same as what
we already have. And so I might say, let display
202:16 - text equal essentially what we have here is
instead of log out and log in, it would be
202:25 - logged out. Or sorry, log in because if they're
logged in, then I want it to display a login
202:31 - logged in.
202:33 - Otherwise,
202:34 - no, no, but I have this display text. I could
put maybe an h1 here uses the display text.
202:49 - So the button says log in because it's a command
to log in, and it says I'm currently logged
202:54 - out. Then when I click it, it says click this
button to log out because you are currently
203:01 - logged in. And that's it for this practice,
then as much time as you need to really understand
203:07 - exactly what's going on. And when you're ready,
let's move on.
203:12 - Alright, we've reached the final part of our
to do app and we're just going to hammer out
203:19 - this last little styling piece. And we'll
be done. So your challenge is notice we're
203:23 - here in the to do item component, what you're
going to do is make it so that the items that
203:28 - are completed look a little bit different
than the items that are incomplete. I'd recommend
203:34 - maybe graying the text out doing a line through
it, maybe turning it to italics or something
203:39 - like that, I'm probably going to do all three.
But whatever kind of styling you want to add,
203:45 - go for it and pause the lesson. Now give that
a try.
203:48 - Okay, so I'm thinking this will be pretty
straightforward. inside of my function here,
203:56 - I'm going to create a inline style to be called
completed style. And let's change the font
204:05 - style to be I like essentially, the styles
represent anytime that one of the items is
204:11 - completed, they will get this style. We'll
make it metallic and then we'll make it maybe
204:19 - a light gray color. And we can put a line
through it with text decoration.
204:25 - And then the thing that I want to style is
the paragraph here that has the text of the
204:31 - to do.
204:32 - So I'm going to add a style property. And
I need to do some conditional rendering here
204:38 - that determines whether or not I should apply
these styles. So I'm going to say if props
204:43 - dot item dot completed is true. I'll just
do this inside of a ternary then I want you
204:50 - to apply the completed style. And if it's
false, then I'll just say no, which essentially
204:55 - means Forget it. I'm not actually going to
do any styling here. So if I Save and refresh
205:00 - this. There we go. My completed items are
grayed out, they're italicized, they have
205:04 - a line through them. If I make it incomplete,
it essentially takes those styles out. Awesome,
205:10 - great job on the to do app, hopefully, you
actually took the time to try and do a lot
205:15 - of this yourself. If you haven't, I really
highly recommend going back and actually doing
205:20 - these. Again, you might remember one of my
strong philosophies is that you'll never actually
205:24 - learn to create these applications unless
you actually do it by hand, just watching
205:29 - somebody else do, it isn't really going to
cut it. Now coming up soon, you'll get a chance
205:33 - to build an entire app from the beginning.
And catching up on things like this to do
205:38 - app and actually trying it yourself is going
to really make that task a lot easier. Once
205:43 - you're ready, let's go to the next lesson.
205:51 - In our past lesson about lifecycle methods,
we talked about a lifecycle method called
205:55 - component did mount, I want you to take a
second and see if you can remember what component
205:59 - did mount does. component did mount is like
a hook in our react component that allows
206:06 - us to run some kind of code immediately after
the component first mounts to the DOM. I mentioned
206:13 - when we were talking about lifecycle methods
that one of the most common uses for component
206:17 - did mount is to get data from somewhere so
that your component can do what it's supposed
206:24 - to do. As a quick refresher, I can add a lifecycle
method right here as a class method has to
206:32 - be spelled correctly though it has to be component
206:34 - did mount
206:40 - and let's just take a look, if I do a quick
console log, see that it ran our console log
206:49 - and it ran the console log immediately after
the component finished mounting to the DOM.
206:54 - Well, like I said, right here is where we
would get any kind of data that's required
206:59 - for this component to display what it needs
to display or do what it needs to do. And
207:04 - so for this lesson, we're going to be using
a couple tools that are really helpful for
207:08 - doing that. The first one is a built in JavaScript
tool that's more or less new, called fetch.
207:14 - and fetch is a nice, easy promise based way
to perform HTTP requests, so that we can get
207:22 - any kind of data that we need. I'll put up
near the top here, a link to the MDN docs
207:28 - on the global fetch function. Another tool
we're going to use is an API called the Star
207:34 - Wars API. Heavy school, we really like the
Star Wars API, because it is cores enabled,
207:39 - which means that there are no issues with
our front end application getting data from
207:44 - their database, you can find the homepage
for the Star Wars API right here. Pretty easy
207:50 - to use. And the data that comes back is pretty
fun to play with. So feel free to take a look
207:54 - at that website, too. And another resource
that I figured out, add here is a medium article
207:59 - that talks about promises just in case you
aren't feeling as familiar with promises as
208:04 - maybe you should. But the truth is, there's
a million articles out there about promises.
208:08 - So you may have to read through a few of them
and just practice them yourself until you
208:12 - feel comfortable with them. Okay, so let's
get started with this inside of my component
208:17 - did mount I'm going to use fetch, which I
use by just typing fetch. And this is a global
208:23 - function. So this should just work. And here,
I'm going to put in the URL where I'm going
208:27 - to be getting the data from. So I'm going
to put in the Star Wars API endpoint here.
208:33 - And we're going to search for slash people.
And we'll just get the person with the ID
208:38 - of one, which happens to be Luke Skywalker.
And that's all we need to do to use fetch
208:43 - to get some data for us. And I'm going to
resolve the promise by using a dot then, which
208:51 - will receive a response that is not quite
yet in the format that we need it to be in.
208:57 - So I'm going to use a method called dot JSON,
which will turn this into a JavaScript object
209:04 - for us. And next in my promise chain, I can
chain on another dot then which will actually
209:10 - receive the data that we want. At this point,
I'd like to do something just like console
209:15 - log the data. So you can see if that worked,
we'll refresh this. And it looks like we got
209:22 - some data down there. It's an object with
some properties, like a name property, which
209:27 - we see is Luke Skywalker and some other properties
that describe Luke Skywalker. Now that I have
209:32 - some data and need to get this to display
on the screen Somehow, I want you to pause
209:36 - the video and just try thinking through what
that would entail. How are we going to get
209:41 - this data that we just received from our fetch
call to actually show up inside of our browser?
209:48 - Well, now that my component has received the
data, if I don't save it somewhere, it's going
209:56 - to disappear. And if you remember the way
that we save data, Within a component is by
210:01 - state. So right here in state, I'm going to
add something like character, maybe, instead
210:08 - of equal to an empty object, I chose an object
because I know the data that's going to come
210:13 - in is going to be an object. And then right
here where I'm receiving my data, I want to
210:18 - make sure that I save it in my state. So I'm
going to set state what's the video again,
210:23 - and see if you can write the set state that
we're going to need to do in order to save
210:28 - this data to our component state. Anytime
we want to change the state, we're going to
210:36 - call this that set state. This case, I really
don't care what the previous state was, because
210:44 - I just want to change this state character
to be the data that I just received. So I'm
210:50 - going to provide an object here,
210:53 - say character
210:55 - is the data that I got. Now, unless I'm inspecting
this with my dev tools, I don't currently
211:01 - have a way to show that this is actually working.
So down here, in our render, I'm just going
211:07 - to choose one of the properties probably name
and see if that will show up on the screen.
211:13 - inside of my curly braces, I'll say this dot
State DOT character, dot name, refresh the
211:19 - page and see what happens. Hey, now this API
call is fairly quick. It made the call, waited
211:27 - for a response, got the response, set the
state and then displayed Luke Skywalker on
211:32 - the screen all pretty quickly. But if the
person using this app has a really slow internet
211:38 - connection, or the API is really bogged down,
or for whatever reason, it's taking a long
211:42 - time for this request to complete, there's
actually going to be nothing that shows up
211:46 - on the page until that request is done, which
is a little bit off putting for a user. So
211:52 - although this doesn't directly relate to this
lesson, fetching data from an API, this is
211:55 - a great place to talk about having some kind
of loading message that lets the user know
212:01 - that the data is on its way. Now usually,
I like to use some kind of fancy loading spinner
212:06 - or something like that. But for now, let's
just make it display the word loading until
212:12 - that data comes back. This will illustrate
a little bit of the power of saving state
212:17 - in your component and updating state as you
go through a really simple way to do this
212:22 - is to add to my state, a Boolean as to whether
or not we're loading, I'll start by saying
212:27 - it's false. And then right before we perform
our fetch, I'm going to change it to true.
212:33 - Pause the video and see if you can figure
out how to change loading to true. Okay, remember,
212:43 - anytime we want to change state, we're going
to use set state. And I don't care again,
212:48 - what the old state was, I'm just going to
provide an object and say, loading is true.
212:54 - Now what we need to do is figure out how to
display the word loading. If state says that
213:00 - the data is loading. Pause the video again,
and see if you can write something down inside
213:06 - a div that shows the word loading if this
dot State DOT loading is true. Right now I
213:15 - have this dot State DOT character dot name.
Here, you can see really quickly when I load
213:21 - this, that there's a moment where it's blank.
So what I could do is right before my return,
213:27 - I could say something like text equal to and
then provide an if else statement. Or I could
213:35 - shorten that by putting a ternary statement
here. So I'm going to say simply, is this
213:41 - dot State DOT loading true? If so I want the
text to say, loading. Otherwise, I want the
213:50 - text to say this dot State DOT character dot
name. And instead of having this done here,
213:55 - I can put in my paragraph or whatever element
of text I want. And I'll say it before I refresh
214:05 - this, I want you to try and think like the
computer and see if you can figure out what's
214:09 - going to happen. Let me refresh this. And
what's going on here. It says that it's loading
214:19 - constantly. To thank for saying it, why would
it be doing that? Why is it consistently saying
214:23 - loading rather than changing it to the character's
name? Well appear we set loading to true,
214:32 - but we never again set loading to false. And
so this is always evaluating to the string
214:38 - loading. So now pause again and see if you
can figure out how to fix this bug. This one's
214:46 - pretty easy here. When we're setting state
of the character. We're also going to set
214:50 - the state of loading back to false. Let's
refresh.
214:57 - You'll see it said loading for just a short
amount of time and And then it resolved to
215:01 - Luke Skywalker. Awesome. Okay, so we have
successfully used component did mount as a
215:08 - place to fetch our data from an external API,
so that our component can do what it's supposed
215:14 - to do. In theory, this components job is to
display one of the characters from the Star
215:19 - Wars API. And it needed the data from the
Star Wars API. To do that. We've also implemented
215:25 - a loading feature that lets the user know
whether it's currently loading or not, so
215:30 - that they don't just give up on our site and
leave. I also think this is a good time to
215:34 - take a step back and remember how awesome
it is that react is so declarative, if you
215:40 - were doing this with vanilla JavaScript, or
jQuery or something more imperative, rather
215:45 - than simply having a ternary, that checks
the current state of your loading variable
215:50 - and deciding whether it should display loading
or not. And then just say whatever that is
215:54 - display the text. Instead, you would have
to manually get an element by its ID, change
216:00 - it to loading, start the API request, and
the data came in, you would have to get the
216:05 - element by its ID, again, you'd have to change
some other kind of style, you'd have to change
216:10 - the word to display the data that just came
in. Whereas here, we simply get to be more
216:15 - declarative and deal with state and say, whether
we're loading or not tell it when to say that
216:22 - it is loading, tell it when to say that it
is no longer loading, and react will handle
216:27 - the rest. So this is pretty cool. But it does
require a completely different way to think
216:32 - about web development. A few minutes to play
with this code, feel free to go check out
216:37 - the Star Wars API and try getting some other
resources, see if you can get different things
216:41 - to show up on the screen. And when you're
ready, let's go to the next lesson. Let's
216:51 - talk a little bit about forms in react forms
tend to be actually a really important part
216:56 - of having a web application. And I found from
teaching students at vi school that it's actually
217:01 - a rather tricky part of react, because we
do things a little bit differently than we're
217:06 - used to when it comes to forms. So I'm going
to do something a little bit different in
217:09 - that I want you to do a couple things before
continuing on with this lesson. The first
217:15 - thing is I want to make sure that you understand
state as well as you can, you don't have to
217:20 - be an expert with it. But as long as you have
been able to follow along with everything
217:24 - we've talked about so far in state, and been
able to complete the challenges, you should
217:29 - be good. If not, please go back and spend
some extra time with state. The next thing
217:34 - is I want you to actually pause this video
and go to the React documentation on forms,
217:40 - I put the link right here. And this does a
pretty thorough job talking about the concept
217:45 - of forms in react. Once you've done that you
can move on. So with forms in react, we actually
217:54 - do things a little bit different than we're
used to with vanilla JavaScript. In the vanilla
217:58 - JavaScript Dom API, you create your form in
the HTML. And once the user decides to submit
218:04 - the form, you go through all of your form
inputs, and gather all the data together pretty
218:09 - much at the last second. And that's when you
would do any kind of form validation that
218:12 - you need, and so forth. Well, with react,
we're going to do it a little bit differently.
218:17 - Instead of waiting until the very end, right
before submitting the form together all of
218:20 - the information, we're actually going to constantly
keep track of all the information in state,
218:26 - which means on every keystroke, we're actually
going to update state so that we can always
218:31 - have the most updated version of what the
user is typing into the form. To really illustrate
218:37 - this, let's just start with a single text
input. Down here, instead of a div, I'm going
218:41 - to render a form. And we'll put a 
single input inside of there.
218:50 - Give it a type of text.
218:54 - Let's give it a placeholder for now, just
to keep things simple. Let's see we're gathering
218:59 - the first and last name of person. We'll start
with first name. Okay, so like I said, normally,
219:06 - our form might have a button that says submit
the form. And at that point in the vanilla
219:11 - JavaScript Dom way of doing things, we would
gather all of the information typed into all
219:16 - the inputs. But in react, we want to watch
for every single change to this input box.
219:21 - So think for a second how we might do something
like that. Well, input boxes have an event
219:30 - that can get fired called on change. So what
we might do is every single time the input
219:37 - changes in the input box, we will run a function.
Let's call it this dot handle change. This
219:45 - function obviously doesn't exist yet. So let's
create it. Now my goal is to make it so that
219:52 - every single time somebody types in here,
I actually update state and I want to do a
219:58 - couple things. I want to Grab the current
value of this input box every single time
220:05 - it changes. And I want to then update state
to reflect what the current value of that
220:10 - input boxes. Well, first of all, my state
currently doesn't have anything saving anything
220:16 - right now, right? So I'm going to add a property
called first name will just started as an
220:22 - empty string. Now I have something that I
can update every time the handle change function
220:27 - runs. Okay, well, to update, I use this dot
set state, anytime I want to change the state.
220:34 - Truthfully, I don't care what the previous
state was, I'm just going to provide an object
220:39 - here that says the first name property should
become something. Well, what am I going to
220:46 - put here? Well, I need this to be the current
value of my input box. If you're familiar
220:52 - at all with vanilla JavaScript Dom API, then
you know that when events fire, they pass
220:57 - a pre determined parameter into our function.
We don't get to choose in this instance, what's
221:04 - actually going to be here, it's always going
to pass to us information about the event
221:09 - that fired. And this event has some really
important information. For example, I can
221:16 - get access to the value of the input box by
saying event got target. Target represents
221:25 - the element in which the event was fired dot
value. And that's the value of the input box.
221:34 - So what I've done here is I've said every
single time a character is typed into this
221:37 - input box, run the handle change function.
And the handle change function changes the
221:42 - state, so that the first name property of
state is updated to reflect whatever the current
221:48 - value of this input box is. I can't open the
dev tools and inspect state inside of scrambler.
221:56 - And so I'm just going to create a little h1
that will display whatever the state is. So
222:03 - we can see it. And now I'm actually going
to run into a little error. You'll see that
222:11 - it says I can't read the property set state
of undefined, see if you can figure out what
222:16 - I'm missing. Anytime we have a class method
that's calling set state, we need to make
222:23 - sure we bind it inside the constructor. And
so inside the constructor, I'll put this dot
222:30 - handle change equals this dot handle change
that by end of this. Okay, so let me refresh
222:36 - this again. And I will start typing and you'll
see every single character is upgrading state.
222:46 - Okay, well, I have something that's going
to violate the DRI principle, don't repeat
222:51 - yourself principle. Now what's going to happen
if I want to create another input for my last
222:57 - name.
223:02 - So I've made another input, that is also running
my handle change function. Let me initialize
223:13 - a last name property in my state. And I added
my h1 to show what the last name property
223:20 - of state is. Okay, so I have a first name,
last name, first name works great. But what
223:26 - happens when I type in the last name? Notice
it just gets rid of everything from the first
223:31 - name. That's because I've hard coded into
my handle change that it's updating the first
223:37 - name property of state. Obviously, one way
around, this would be to make a whole extra
223:42 - function called handle last name change or
something like that. And make this on change
223:48 - be a different function altogether. But that's
not going to work in a larger form that may
223:54 - have like 50 inputs or something crazy like
that. Now instead, what we're going to do
223:59 - is we are not going to hard code first name
here. And we're going to give a name property
224:05 - to our inputs. That perfectly matches what
our state is. First Name, capital N, and last
224:16 - name, capital N. And remember, up in our handle
change, we have this event that we're receiving,
224:22 - well, this event has a bunch of information
about the input that is firing this event.
224:27 - For example, we grabbed the value of the input
box. But I can grab any part of the input
224:33 - object that I want, not only the value, but
I can also grab the name property. And so
224:39 - to the left of my object here in the property
name here. I can say event dot target, which
224:46 - is my input box. Got name, which is the name
property. This isn't quite right, right, because
224:52 - this is a syntax error. If I want this to
actually represent the first name, property
224:57 - or the last name property, I need Make sure
to wrap this in square brackets. And this
225:03 - works because the name property is a string.
And if I'm describing a string property name
225:08 - inside of an object, I can wrap it in square
brackets. This is just a principle of JavaScript
225:13 - that you may or may not be familiar with.
And so now when I refresh this, anytime I
225:18 - type into the first name box, I get a change
to my state in first name. And anytime I type
225:25 - into my last name box, I get a change to the
last name. Okay, as a quick aside, this same
225:31 - principle here is going to work whether I
am using a type of text, or anything else
225:37 - that's text based like an email, or phone
or number, all of those are essentially going
225:43 - to use this exact same handle change function.
And you need to make sure that you give it
225:48 - a name property that perfectly matches the
property and state and that you pass your
225:54 - on change function to it. Now I'm actually
splitting forms into a two part lesson. And
225:59 - in the next one, we're going to talk about
some of the other types like checkboxes, radio
226:02 - buttons, text areas, and select boxes. But
before we get there, there's one more thing
226:07 - I want to touch on. And that's the concept
of a controlled form. If you did what you're
226:11 - supposed to do, and went over and read the
React documentation on forms, you read about
226:16 - controlled forms. The idea is that we actually
want what's displayed inside of our form to
226:23 - perfectly match up with what is in our state.
Right now, state is being reactive, as in
226:29 - every time the input in the box changes state
updates, according to what's in the input
226:35 - box. Well, with a controlled form, state actually
directs what is inside and showing up inside
226:41 - of the input box. This is kind of a splitting
hairs distinction. But it really jives well
226:46 - with the idea that state should be the single
source of truth, it doesn't have to be that
226:50 - complicated, the only thing we really need
to do, especially with these text inputs,
226:55 - is add a value property. and the value should
always be this dot state, dot, and then whatever
227:02 - property that box is holding,
227:05 - first name, last name.
227:09 - And when single elements start to get too
long like this, I like to put each of these
227:14 - attributes into their own lines. Okay, that's
a lot better. Okay, now we can see that everything,
227:24 - I'm going to refresh this, everything is still
working essentially the same as it was before.
227:30 - But now what is showing up in this input box
is because of what the current version of
227:36 - state is, in other words, I'm forcing the
value or what shows up inside of the input
227:41 - box to exactly match what state is also going
to give you one quick best practice that will
227:47 - help you avoid a really difficult to debug
bug that could come up in the future. In this
227:53 - case, we're not seeing it. And I'm not going
to worry too much about explaining what that
227:56 - bug is exactly. But a really good idea is
instead of directly accessing the name and
228:02 - value properties, by drilling into the event,
that target object here, you can save yourself
228:08 - a lot of grief by simply pulling those values
out of the target before you set any state.
228:15 - Using some basic object D structuring, I can
say name, value equals event dot target. Then
228:25 - down here, I can just say name, value. If
this is something that you're actually super
228:32 - interested in understanding, you can look
into reacts synthetic event. And you may get
228:37 - a better understanding of why this is important.
But it can be really helpful to make a copy
228:42 - of the name and value before you run setstate.
Okay, that's enough for this part of the lesson.
228:47 - Take some time to go over this again and digest
it, feel free to practice with it. We're going
228:52 - to talk about forms part two next, and then
we'll have a practice that goes over both
228:56 - of these parts together.
229:03 - So far, we've talked about some of the most
basic input types when it comes to forms,
229:07 - anything text based is essentially going to
act the same way that we've talked about in
229:11 - the previous lesson. But unfortunately, forms
are a little bit more complex than that. And
229:16 - with some of the other elements that you can
use, things start to get a little bit more
229:20 - complicated with react, but it's not too bad.
So let's walk through it. Down here, I've
229:24 - made some notes about some of the elements
that I'd like to talk about the first one
229:28 - and probably the easiest to understand is
the text area element. If you've used the
229:33 - text area element in regular HTML before,
you know that it is not a self closing tag,
229:38 - like the input element, but instead has a
closing tag. If I refresh this page, you can
229:45 - see that it's essentially like an input box,
but it's a little bit taller and the user
229:50 - has the ability to make it bigger or smaller.
We also have the ability to change the default
229:55 - height and width with properties called rows
and columns and in regular HD Well, if you
230:00 - wanted to pre populate some text in here,
you would do so by typing it in between the
230:05 - opening and closing tags, or rather the inner
HTML. Well, what react has done is they wanted
230:10 - to make text area much more similar to the
input element. So in react, there's a major
230:16 - difference in the text area element in that
it is a self closing element. This is actually
230:22 - really nice, because we are able to use the
value property now. And we can use it exactly
230:28 - the same way as we were with an input. This
is nice for consistency. And it also makes
230:34 - it really easy to update the value of the
thing inside the text area by updating state.
230:40 - So you can see if I were to add some default
value in here. That's what shows up in my
230:49 - text area element. And that's it with text
area. Let's move on to checkboxes. checkbox
230:53 - is just a type from input. So input type equals
230:59 - checkbox.
231:00 - But one of the major differences is that you
are not going to use a value property like
231:04 - we did with text area or input. Instead, the
idea of a checkbox is that it's either checked
231:09 - or it's not checked. This means that we are
going to add a checked property here and I'm
231:15 - going to start putting things on their own
lines will have a checked property. And this
231:20 - is going to be determined by some kind of
Boolean because a checkbox is either checked
231:25 - or it's not checked. And so checkboxes typically
maintain Booleans in state. For this example,
231:31 - maybe we are checking if the person that we're
referring to is
231:35 - friendly.
231:38 - Now in state, I haven't yet defined this.
So I would come right up here to state. Ad
231:44 - n is friendly, and maybe we'll initialize
it with true for refresh this, you'll see
231:50 - that I now have a checkbox and it starts out
by being checked. We'll notice that if I click
231:55 - it, it's not letting me uncheck it. Think
for a second why that might be? Well, down
232:04 - in my check box, I've told it that it is checked
if this.state.is friendly is true. And essentially
232:11 - this true value is being forced upon this
input. And so even if the user tries to uncheck
232:17 - it, React will say, Nope, it is actually checked
because this value is true. So you might have
232:23 - noticed something popping up in the console
that says that I've provided a value prop
232:27 - without an unchanged handler, essentially
rendering a read only field. And that's what
232:33 - we're seeing here. It's Read Only I can't
make changes to this because I haven't taught
232:36 - it how to make changes and how to change state.
Well, this is where things get tricky, because
232:41 - what I don't want to do is add an unchanged,
that is looking to something like handle checkbox
232:49 - method. Right? It would be nice if I could
just use my existing handle change method
232:54 - to handle changes on a checkbox. And so we're
gonna see how you can do that. First, I'm
232:59 - going to put this to handle change. And just
like our other inputs, I'm going to give this
233:03 - a name property that is the same as the thing
in state is friendly. And now Give me a second
233:13 - to make this look a little better in our form
over there.
233:20 - Okay, that looks better. And now the tricky
part comes in. Because in an input box, we're
233:27 - keeping track of what's being typed into the
input box. You might remember from our handle
233:33 - change, we are grabbing the value event dot
target dot value, an updating state with the
233:38 - new value. Well, our checkbox doesn't have
a value, it has a checked property. And the
233:43 - checked property is actually going to return
either true or false. So what we're going
233:48 - to need to do in order to use our same handle
change function for our checkbox, is we need
233:54 - to check if the element that is being interacted
with in the form is a checkbox or not. And
234:00 - so there's a couple things that we need to
pull out. First of all, notice how we have
234:04 - type equals checkbox. Type is a property that
we can pull from event target. So besides
234:11 - just the name and the value, if it's an input
or a text area, you can also grab the type.
234:17 - And then just like we discussed how checkboxes
don't have a value, but instead have a checked
234:21 - property, we can pull that from event target
as well. And so now we know that I can check
234:26 - if the type is a checkbox, I won't be able
to do this, this dot set state because I won't
234:33 - have a value property. But instead we'll need
to change the name which is is friendly to
234:39 - whatever the current value of checked is.
You could do an if else statement, or I could
234:44 - just do a ternary here. So I can say is the
type equal to
234:48 - checkbox?
234:52 - If so, we're going to update state in a certain
way. But if it's anything other than a checkbox,
234:58 - we'll use our existing
235:00 - This dot set state. Now here, we will also
run a set state. And we are going to access
235:07 - the name property. But instead of using value,
we're going to set it to whatever the value
235:12 - of checked is. Let me open this up a little
bit so that it's a little bit easier to read.
235:18 - And now when I refresh, let's see if I'm able
to update my checkbox. Now when I click the
235:26 - check box, it's going through my handle change,
it's seeing that the type is a checkbox. And
235:31 - so it's running this, this that set state.
And when I go over to my other input boxes,
235:37 - I can still say,
235:39 - name,
235:40 - and it's updating state in a different way.
And while we're at it, to get rid of the warning
235:45 - that we have in our console, let's add an
on change to our text area, so that it stops
235:51 - yelling at us. Excellent. Well, now let's
talk about radio buttons. Because radio buttons
235:59 - are kind of a combination of the input type
text, and the checkbox. What I mean by that
236:06 - is that they are going to use both a value
property and a checked property. So I'm going
236:12 - to make a copy of my checkbox, so that I can
quickly get something prototyped up, I'm going
236:18 - to change the types here to radio, let's give
the name of maybe its gender. And now notice
236:26 - that I'm giving the same name to both of my
radio buttons. What this tells the DOM to
236:30 - do is to make sure that I can only choose
one of these two radio buttons, wherever they're
236:35 - also going to have value, the value will be
slightly different. So maybe first one is
236:41 - male, and the second one is female. And I'll
update my label here.
236:51 - And let's put some breaks in there. Now notice
what happens when I go over here. Again, I
236:59 - can't change them. But if I click on his friendly,
notice that it chooses one of these two to
237:05 - be checked. This is kind of quirky. And the
reason is, first of all, because I copied
237:10 - and pasted, which sometimes leads to funny
bugs, it's still saying that it's checked
237:14 - if his friendly is true. But this is where
radio buttons are a little bit different,
237:19 - because I can't just say it's checked if some
value in state is true, because radio buttons
237:25 - jobs aren't to maintain true or false values,
right? That's what the checkbox is for. Instead,
237:31 - I want this to be checked if the value of
this dot State DOT gender is equal to male.
237:39 - And similarly, if this one is equal to female,
I don't have gender maintained anywhere in
237:47 - state, so I'll need to go update my state
up here. Maybe we'll just start gender as
237:54 - an empty string. Now, when I choose this,
it will let me choose one or the other. And
238:01 - under the hood, it's maintaining a gender
of either male or female. Again, since I can't
238:06 - pull up the dev tools in scrambled, let's
go down here and just display something here.
238:14 - Okay, and we should probably use some kind
of conditional rendering. So this doesn't
238:20 - show up until one of these is chosen, but
that choose male and female, it's updating
238:26 - state, and therefore updating the text that
we're seeing down here. I think this is probably
238:31 - a good point to mention that a lot of this
stuff may seem really complicated and different
238:37 - from each other. And it's just important to
know that you're not necessarily expected
238:42 - to have all of this memorized. Honestly, I
end up coming back to some previous examples
238:46 - that I've written just so I can remember this
syntax. This is probably also a great time
238:51 - to mention that there's a really excellent
library out there called Formic. There's a
238:55 - few of them, but I'm just gonna put the name
right here. So you can take a look. Formic
239:00 - basically takes all of the pain out of writing
react forms, it's a library that you can install
239:05 - and just use their API to make your life dealing
with forms much nicer. Okay, the last form
239:12 - element that we're going to talk about is
the select box. And in regular HTML, you're
239:19 - probably used to having a select with options.
And fortunately, React has chosen to use the
239:27 - value property again, so that we can easily
determine which of the select elements is
239:34 - chosen. And also to very easily be able to
update state, though for example, maybe we
239:39 - are deciding what our favorite color is. We'll
have a state property called favorite color,
239:47 - and the value of this whole element is going
to be whichever of these options we choose.
239:54 - First thing, let me put favorite color up
in my state. And we'll just start it off as
240:01 - blue. Okay, and then down here, I'm going
to make sure that I'm watching for a change
240:10 - on my select box. So unchanged, I'm still
going to run my handle change, I also need
240:17 - to give it a name, just like I did with my
input boxes will make sure that this matches
240:22 - the name and state. And then the only other
change I need to make is make sure that my
240:26 - options also have value. And the value here
is going to be whatever I want the different
240:34 - options to be. So this will be the value under
the hood. And then the text here in the inner
240:40 - HTML is what will be displayed in the select
box. And that's probably good enough. Oh,
240:50 - and it looks like I put my slash in the wrong
place here. Okay, let's give this a break.
240:56 - So it's on its own line. And maybe put another
label here.
241:07 - And yes, I understand this form is very ugly
right now. But my click my drop down box,
241:12 - you'll see I have my options. And before I
select something, let's just put another thing
241:17 - down here. So I can see that state is updating.
241:26 - Okay, notice that my state initialized correctly.
And when I change this, it's changing the
241:39 - value of state. what's so cool about the way
that react has chosen to implement the API
241:46 - regarding elements and forms is that it makes
it so that we can write a single on change,
241:53 - rather handle change. It had to do one workaround
with the checkboxes simply because the philosophy
241:59 - behind checkboxes is so different than all
the other elements. But essentially, we're
242:03 - reusing this one handle change, and it's working
for all the elements in our form. Yeah, I
242:08 - totally get that this is a lot to digest,
we're gonna do a practice right after this,
242:12 - that should help cement this information a
little bit. Don't feel overwhelmed so much
242:17 - with understanding or rather learning all
of the syntax of every one of these elements,
242:22 - that may distract you from all of the other
coolness that react has to offer. Instead,
242:27 - don't be afraid to just practice this a couple
times, and then come back to it whenever you
242:31 - need to, eventually, you'll gain a muscle
memory that will help you remember all of
242:35 - this. One last thing that I failed to mention
in the previous lesson was how to actually
242:39 - submit this form or do something at the end
of filling out this form. Kind of two general
242:44 - ways that you could do this in either way,
it's going to be a good idea to put a button
242:48 - in your form of some type. Now in html5, the
button element if it's found within a form,
243:00 - acts like the old input type submit, if you're
familiar with using that, where you would
243:07 - give it a value that displayed the text on
the button, and so forth. I personally really
243:13 - dislike the way that input is used in so many
different ways. And so I never use the input
243:18 - type submit myself. Instead, buttons in html5,
if they're found within a form. When they're
243:26 - clicked, they are a submit button. And they
will fire the on submit of the form itself.
243:32 - So when you want to do something, when you're
finished with the form, one thing you could
243:37 - do is to just add an on click on your button.
Personally, I like to handle that action on
243:44 - the form itself. And so I will have an on
submit handler. And we didn't write this but
243:53 - it would be just as easy as creating another
method that's called handle submit and doing
243:58 - something like submitting the form to an API
or something like that. Okay, take a deep
244:03 - breath, you've basically finished all of the
most important parts of forms. We've talked
244:08 - about input type, text, and other text based
inputs like numbers and passwords and so forth.
244:14 - But we've also learned how to handle checkboxes,
radio buttons, and select boxes and text areas.
244:20 - Okay, let's move on to the next lesson, which
will be a practice of forms.
244:30 - So let's practice building forms. Your challenge
is to wire up the partially finished travel
244:34 - form below so that essentially it works in
react. This challenge is actually one that
244:39 - we use at vi school and the URL for the original
challenge is right here, you'll probably want
244:44 - to go there so that you can see exactly what's
supposed to be done. Now in this goal will
244:48 - use this as in plain HTML forms challenge
so it doesn't really have anything to do with
244:53 - react, but I'm just adapting it for react
for this lesson. So pause this lesson, go
244:58 - take a look at this website. Learn some more
about what you're trying to accomplish in
245:02 - this form, and give this a go.
245:06 - Alright, so there's a lot of different ways
that we could approach this, I think what
245:11 - I might do is initialize everything with state
first, and then start wiring things up one
245:16 - at a time. Okay, so I know that my state is
going to have a first name. Last name. We'll
245:27 - also do age, which actually have a little
bit of a question myself on, but I'm just
245:32 - going to initialize it at zero for now, and
then try something a little bit later. Let
245:36 - me scroll down here, I know I'm supposed to
have under and I have a select block for location,
245:44 - I'm pretty sure this is supposed to be destination.
So I'll say destination, then a checkbox for
245:50 - dietary restrictions. Now, what's actually
going to be there for dietary restrictions
245:56 - is a number of checkboxes. And because they're
checkboxes, it's possible that they will check
246:02 - multiple boxes. And so if I'm going to have
multiple dietary restrictions, what I might
246:07 - do is choose to take this as an array. And
okay, that seems to be the last thing because
246:11 - here's my Submit button. Now that I have my
state initialized, I'm just going to start
246:16 - putting some of the things that I know will
need to exist in my existing elements here.
246:21 - So we'll start with my inputs, I know that
I'm going to need a name property for each
246:28 - one. Now I'm going to need a value for each
one. Actually, this is going to be determined
246:35 - by state. So this will be this dot State DOT
something I know each one is going to want
246:42 - to be able to change. So I will have an on
change will probably call it handle change.
246:49 - While I'm added I'm going to put everything
on its own line. Okay, so the names will need
246:59 - to match the parts of state that they're representing.
So this will be first name, last name, and
247:09 - age. And I'll actually have the same thing
for state. So this will be first name, last
247:19 - name and age. So that looks like I lost my
curly braces there. Now maybe before I go
247:27 - creating a bunch of extra elements, I may
finish this part off and make my handle change
247:33 - method. Right here, I will need a handle change.
I'm going to take an event. And before I forget,
247:43 - I should probably find this I know that I
like to pull some of the elements from the
247:55 - event that target. So for this right now,
I just need name and value will add to this
248:02 - later when we get to the checkbox. And I'm
going to set state
248:06 - here whatever name I'm concerned with changes
to the new value. Okay, so the buggy thing
248:15 - here is that this starts with a zero. Let's
go down and see if these three inputs are
248:21 - working correctly. So with your name, going
to put this dot State DOT first name, base,
248:31 - and this dot State DOT
248:33 - last name.
248:34 - If I type in these boxes and see if it's working
great. The same for age. And it already says
248:52 - zero. But if I change this to something different.
Okay, that works. And now the thing I actually
248:59 - wanted to test was to see if react complained
when I started this as No. And it does. Okay,
249:08 - and it looks like it just doesn't like that
the value on the input is no. So it recommends
249:13 - using an empty string. But part of me going
out and doing a bunch of research this will
249:19 - just have to do for now. Okay, so after a
refresh, you can see I don't get my zero age
249:24 - anymore, which is smart, we wouldn't want
that showing up as a default of our form.
249:29 - And it looks like so far, so good. Let's go
down and fill in some of these new elements
249:33 - here. Let's start with the radio buttons for
gender. I like to wrap my radio buttons in
249:41 - a label
249:43 - that said that the person could also click
on the text of male or the text of female
249:48 - and select the associated radio button because
the text is a parent of the radio button.
249:54 - So I'll just put the label as a parent of
my radio button which is an input Type radio.
250:02 - And I like the text to be on the right side
of the radio button myself so that the radio
250:09 - buttons are nice and lined up on the left
side. And remember the radio buttons were
250:13 - kind of a combination of checkboxes where
they have a checked property and also the
250:17 - text inputs where they have a value property.
So I'm going to be adding a lot of stuff to
250:21 - this radio button, I'm gonna go ahead and
start putting things on their own lines already.
250:26 - And then we'll say response has a name, which
will be a gender value, in this case, it will
250:35 - be male. And we're also going to have the
checked property. This one is a little bit
250:42 - trickier because it's going to say this radio
button is the selected one. If this that state
250:47 - that gender is male, then we'll have our on
change to be our this dot handle change. And
250:57 - let me go ahead and just copy this and change
it to work for female as well. Another great
251:06 - here. Hey, let's refresh the page and see
what we got male and female, and it looks
251:13 - like I can check those. Let me see down here,
if that's working. So under your gender, we'll
251:21 - put a start state that gender doesn't start
as anything and choose male. And there we
251:32 - go. Change it to female. Perfect. All right,
we're cruising. So let's do our select box
251:39 - now
251:41 - says the select box for our locations or destinations.
And this is going to be a select box. And
251:52 - we know we're going to have some options in
here.
251:57 - And let's put before options. Obviously, this
is not a great airline that's flying to only
252:03 - three or four locations, but whatever. Now
I remember that our select and our options
252:09 - all take a value property. They're a little
bit different from each other, but I'm going
252:14 - to go ahead and just add a value. Okay, the
value on my options is simply what state should
252:21 - be if this option is the one that's chosen.
So this is where I'm going to put my actual
252:29 - locations. So I might say something like
252:32 - Germany.
252:36 - And I'm going to keep this lowercase for the
extra value just to stay consistent with how
252:40 - I have things elsewhere. Let's do Norway,
252:49 - the North Pole.
252:56 - And why not, say the South Pole. The value
of the select box is not the options that
253:07 - we have, but rather the chosen option. So
this will be determined by state as part of
253:12 - a control perform. We are calling this destination.
Then just like our other ones, we need to
253:19 - make sure that this has a name, say his destination
again, it needs to match the property and
253:26 - state. And we'll have our same on change,
which is the standard change is getting long.
253:33 - So let's put it on its own lines. And down
in the Display area, we will put destination
253:44 - from state. Now you'll notice here that it
has automatically selected the first one,
253:52 - but doing so has not actually updated state.
So my destination is still empty. If I want
253:58 - to Germany, I would actually need to switch
to Norway, and then back to Germany to actively
254:05 - choose this as my option. And so what a lot
of people will do is they'll just put an option
254:11 - at the top that maybe we'll leave empty and
put something like
254:15 - something like that.
254:23 - Okay, Germany gives me Germany and I can actually
actively switch to any one of these that I
254:29 - want. Okay, well, we've saved probably the
more difficult one for last. And that's our
254:34 - checkbox. I feel like I've had some clarity
since I first started state. At the beginning
254:41 - of this lesson, I created an empty array for
my dietary restrictions. And I'm thinking
254:48 - it's actually going to be easier if I save
this as a sub object where I have an option
254:53 - for each one of my dietary restrictions and
the value is going to be a Boolean. So instead
254:58 - of trying to manipulate my bullions into some
kind of text value. Instead, I'm just going
255:03 - to create an object. And each one of these
will represent a Boolean of some kind, I will
255:10 - probably want each of these to be unchecked
as a default. So I'll just say each one is
255:15 - false. The is kosher. Free. That should be
good enough. So now I'll need three checkboxes,
255:27 - each one representing one of these three properties
down here in my form. Again, I will wrap everything
255:36 - in a label
255:37 - type of checkbox.
255:50 - Name,
255:54 - the
255:56 - vegan unchanged will continue to be this handle
change, which if you remember, we're going
256:03 - to need to update in order to correctly handle
the checkbox. And then I need something to
256:09 - direct whether or not this is checked. And
this is going to be a little extra nested
256:14 - level here. So it's going to be dietary restrictions.is
vegan. And as part of my label, I'll just
256:23 - put a label that says vegan. Okay, so I'm
actually just going to create a few of these
256:32 - and update them. So I have is vegan
256:36 - is kosher. And this one was lactose free.
Okay, let's take a look and see what that
256:52 - looks like.
256:53 - Okay, awesome. Now notice that once again,
I'm not able to change any of these checkboxes.
257:01 - If you didn't get this far, when you did this
yourself before we started doing this together,
257:05 - pick the time now to see if you can update
our handle change so that it can handle the
257:11 - changes in a checkbox.
257:15 - Okay, so once again, the checkboxes don't
have a value property. And currently, our
257:23 - handle change only is able to update things
with the value. But we know that we're going
257:28 - to have to check if the type is checkbox.
So I'll need to pull the type from my
257:32 - element.
257:33 - And I'm also going to want to see if property
is true or false. Or rather just see what
257:39 - the check property is, then what I need to
check is if the type
257:44 - is a checkbox, I'm actually going to do my
set state on its own line,
257:51 - it's gonna get a little more complicated.
Remember that in this case, I can't just say
257:58 - to set the state of name
257:59 - checked. That's because
258:02 - I've chosen to have a nested object here.
Apparently state does not have a property
258:07 - called is vegan or is kosher. Instead, it
has a property called dietary restrictions,
258:12 - which has a property called is vegan, or is
kosher. Now normally, React is smart enough
258:18 - to know that if I'm updating just one part
of state like the destination, it will combine
258:23 - that with the rest of state. However, I'm
not 100% sure offhand, if I update just one
258:30 - part of a nested object, if it will also update
the rest of state. So I'm going to be live
258:36 - testing this here with you. Let's give it
a try. First thing is this won't work either
258:41 - way. So this will have to be dietary restrictions.
Be an object, and we will update the name.
258:50 - Before I can test this, I need to finish my
ternary because this is broken Currently,
258:55 - there will say otherwise. This dot set state
name value just like we had before ever feeling
259:02 - this isn't going to work, but let's give it
a shot. So no errors so far. That's good.
259:07 - You know, just put something in here, we'll
see that my name is working. Now if I check
259:14 - vegan, it doesn't seem to like it, it thinks
that I'm changing something from a controlled
259:18 - form to an uncontrolled form. And that has
to do with the way that date is updating out
259:24 - Fortunately, I think I should be able to use
the object spread notation, which means what
259:29 - I can do is pass in the previous state. If
you remember when we talked about that state
259:35 - how I can either provide a brand new version
of state or I can provide a function that
259:39 - receives the previous state as a parameter
and uses that to update state. I'm going to
259:44 - change this to the second way and I return
a new object
259:55 - and inside of dietary restrictions, going
to take all of the property These from proof
260:00 - State DOT dietary restrictions, and then update
the rest. And it actually looks like maybe
260:07 - scripted does not have the ability to do object
spread notation. It really depends on what
260:12 - version of ECMO script you are transpiling
using Babel. In this case, it seems like the
260:17 - object spread notation doesn't work in scrubba.
But at this point, I think it kind of worked
260:22 - myself into a corner. One workaround that
I can do and probably will do for now is to
260:27 - just get rid of my sub object, dietary restrictions.
And make each one of these their own property
260:35 - on state,
260:36 - we just got promoted.
260:39 - which case, I can probably simplify this quite
a bit and go back to the way it was. So we'll
260:44 - get rid of dietary restrictions, we'll get
rid of this name checked. And now that is
260:52 - vegan is kosher, and is lactose free are kind
of first class citizens here in state, I can
260:58 - simply update by its name and determine whether
it's true or false. Let's try this. Okay,
261:04 - we're doing some live debugging here, it says
that it cannot read property is vegan, of
261:08 - undefined. And notice that I still have my
checked saying this dot State DOT dietary
261:15 - restrictions. We don't need that anymore.
Or handle change and try again. Okay, so now
261:23 - I should be able to enter something as a first
name, which shows up in my name, and then
261:28 - choose some of these. And oh, we haven't updated
our dietary restrictions display yet. Down
261:35 - at the bottom, let's just see if we can get
this to work your dietary restrictions, say,
261:46 - vegan. state that is vegan. And we'll just
do the same with kosher
261:53 - and
261:54 - lactose free. You'll notice that it looks
like they're starting out empty. If I had
262:10 - checked them, it's not actually displaying
any text here. Isn't is react does not display
262:16 - Boolean true or false as text on the screen
unless you go out of your way to make it text.
262:22 - But one quick workaround that I could do is
I could put another ternary here that says
262:29 - you should display Yes, if it's true. No,
if it's false, then here, I actually get the
262:39 - nose showing up. Let me put these each in
their own paragraphs, so that they don't mash
262:44 - together this way. And you'll see vegan, no
kosher, no lactose free No. When I select
262:54 - some of these, those have changed. Yes. Or
another fun practice that would just be a
263:00 - regular JavaScript challenge is to try to
get it to display the words vegan, kosher
263:06 - and lactose free is a comma separated list.
I won't do that here. Because I've already
263:11 - taken up time just trying to debug this with
you. If you want, you can pause the lesson
263:15 - and give that a shot might be kind of a fun
challenge. And with a little bit of workaround,
263:21 - and having to change a little bit of our state,
we have been able to successfully build our
263:26 - form. It's obviously not very pretty, but
it seems to be working. So if I fill everything
263:32 - out, not 9999, as it turns out, looks like
oh, I have to select the destination. Let's
263:42 - go to Norway. It looks like everything has
filled that correctly. I mentioned at the
263:48 - beginning of learning forms, it's a kind of
complicated process. And forms in general
263:54 - are very important when it comes to web applications.
Obviously, they're not always going to be
263:58 - filling out lengthy or forms like this. But
if you think about it, anytime you click a
264:04 - checkbox, or anytime you have a radio button,
or a signup form, or a login form, or anything
264:08 - like that, a lot of that is using forms. So
really understanding this is going to help
264:13 - you be a better developer for web applications
that users can interact with. So although
264:19 - I said it's not necessarily important to have
each input type syntax memorized, it's still
264:25 - a really good idea to practice this, play
with it, see if you can really understand
264:30 - it so that when the time comes to build the
form in your react app, you can do so relative
264:34 - ease. Thanks for your patience while we went
through and debug some of this stuff. Hopefully,
264:39 - that was a good exercise in general. When
you're ready, let's move on.
264:48 - So when we built the travel form in react,
you may have noticed that a lot of the time
264:52 - we were scrolling up and down and we have
an component here that's 146 lines long. Now
264:59 - you'll notice that A lot of this space is
being used as display logic, right? It's showing
265:05 - the form, it's displaying UI, it's creating
elements, all of this happening inside of
265:10 - the render. But then we also have a place
where we're maintaining state. And we have
265:15 - our handle change function, which is doing
some business logic. You know, there's been
265:19 - a study done that shows that a programmers
ability to understand the code that they're
265:24 - looking at diminishes dramatically, when the
file that they're looking at is one in which
265:29 - they have to scroll to see everything. And
I've noticed that with my students as well,
265:34 - if I have code that's too long, and I'm scrolling
around the screen all the time, it's very
265:38 - easy to become disoriented and lose your place,
and makes it much more difficult to actually
265:44 - understand what you're looking at. It would
be nice if we separated our concerns between
265:49 - the UI logic or the rendering logic, and the
business logic that actually mandates how
265:55 - the rendered logic changes. And so this idea
emerged a few years ago of having a presentational
266:02 - component and a smart component or component
that's in charge of the business logic. There's
266:07 - a lot of different names that you'll hear
presentational and container components, smart
266:13 - components and dumb components, containers
and components. But they all refer to essentially
266:17 - the same thing. The idea is that you have
one component whose job it is to maintain
266:23 - state, and to have the methods that update
state. And then for that component to essentially
266:30 - delegate all of the UI logic or presentational
logic to another component. That's called
266:36 - the presentational component. That presentational
component will only be in charge of receiving
266:41 - props and displaying things correctly. If
you'd like you could read den epor mobs, medium
266:47 - blog post where he talked about presentational
and inner components at this URL. And if you're
266:54 - unfamiliar with Dan Abramov, he's one of the
primary developers of the React framework.
266:59 - So let's take a minute to organize some of
the code that we've written here. First of
267:03 - all, I currently have everything happening
inside of my app component. And I just did
267:07 - that for simplicity. But in reality, I want
my app to render my form, and let my form
267:13 - do all of the for me things. So I'm going
to create a new component called,
267:19 - let's just say form dot j, s. And I'm essentially
going to take everything here, put it over
267:25 - and farm, clean up a few things.
267:29 - palette form, and export form. And then over
in app, we will make sure to import the form.
267:43 - And since our form is handling all of our
state and everything, we basically can change
267:48 - this into a functional component that just
renders the form. So maybe I'll go ahead and
267:55 - do that. That's pretty simple. And you'll
see that everything is showing up the same.
268:05 - And remember way back when I kind of talked
about how I like my app to be sort of a table
268:09 - of contents where I could put a header above
this and a footer below this and whatever
268:14 - main elements and then delegate the rendering
of those main UI components to the other components.
268:21 - So our problem is essentially still the same
with form j s, because we still have one component
268:25 - that's doing all of this stuff. So what I'm
actually going to do is I'm going to create
268:30 - another component, this one we will call form
component, that j s. But essentially, you
268:37 - could call these whatever you want, you could
have form container dot j, s and form component
268:42 - dot j s, you can even put them into a folder
called form and make form j s actually just
268:48 - index j s and then have form component dot
j s, I've seen it done a bunch of different
268:53 - ways. And for clarity, right now, I'm actually
just going to rename form to form container
268:58 - so that it's obvious which one we're looking
at. And that just means over an app js, I'll
269:03 - need to update this to form container. And
we're still working. Okay, opening the form
269:10 - container, I'm essentially going to take all
of the rendering logic, let's get this whole
269:15 - return statement. I'm going to take it out.
While I still have it in my clipboard, I'm
269:19 - going to go over to the form component and
create just a regular functional component.
269:26 - Thank you receive props. And let's paste our
whole return in there and fix some of our
269:38 - indenting. Awesome. One thing you might notice
that's broken because we copied this from
269:43 - a component that was a class based component.
We have stuff like this dot State DOT first
269:48 - name and this dot handle change. Well, this
functional component doesn't have a handle
269:54 - change method and it doesn't have any state.
Instead, it's going to be receiving everything
269:59 - through props. So we'll come back and fix
this in a minute. But over on our form container,
270:04 - you now have an empty render. And what we're
going to do is let the form container delegate
270:09 - all of the UI stuff to the form component.
So at the top, I will need to import form
270:16 - component, the form component file, and simply
render
270:25 - a component.
270:28 - Like we said, we're gonna have to pass a bunch
of stuff through props down here. But already,
270:33 - we can see that my form is quite a bit simpler
than it used to be. Okay, well, let's wire
270:39 - up our form components so that it has all
of the same information because it right now
270:43 - if I refresh this, you'll see that we have
some problems. And so what I actually need
270:50 - to pass are all of these properties in state.
And I also need to pass my handle change method.
270:57 - So let's start with the handle change method.
And I might as well just keep the name the
271:03 - same. That over in my form component. In props,
I'm receiving a prop called handle change,
271:11 - which means every time I have this dot handle
change, I need this to instead, say props
271:18 - dot handle change.
271:26 - That's a good start. We still have problems
because we have no state in this component.
271:32 - So let's go back to the form container. And
I have a number of different options, the
271:37 - most annoying of which is I could pass down
first name, which is this dot State DOT first
271:44 - name, and then do this for every one of these
properties. But it's really that's pretty
271:49 - obnoxious, right? Because my form component
is now going to have maybe like seven or eight
271:53 - extra lines. Another option is I could just
pass everything, the whole state object down
271:58 - as a property called something like data to
the start state, this is leagues better than
272:05 - what we had just tried to do. But it does
mean that in our form component, we're going
272:09 - to have, instead of this dot State DOT first
name, we'll have props dot data dot first
272:14 - name. And truthfully, that's not so bad. And
in fact, in my personal development life,
272:19 - I have tended towards this, where I pass an
object down and I just give it a name, it
272:26 - does mean that I have a little bit of extra
typing where I say props dot data dot first
272:30 - name, instead of finding a way to just have
props dot first name. But as we discovered,
272:34 - when we were doing the travel form, screenbid
doesn't do so well with the object spread
272:40 - operator. But if you have the correct ECMAScript
versions supported in your project, you could
272:46 - simply say, pass down all of the properties
of this start state. Doing so would allow
272:54 - you to in your form component, say props dot
first name, props, dot last name, and so forth.
273:00 - Again, I have actually leaned towards sending
down an object, simply because it makes following
273:07 - the prompts a little bit easier for myself
in the future and other developers. But I've
273:12 - seen it used both ways. So it's really just
up to you here in screen. But I believe I'm
273:17 - going to have to do something like this. So
now let's go over to our form component and
273:22 - update everywhere it says this, that state
change this to props dot data. Let's see if
273:32 - we have any problems, says nothing was returned
from render usually means a return statement
273:38 - is missing. Yeah, I think in my form container,
I Yep, I got rid of my return, which we cannot
273:44 - do. So we're gonna put the return back. And
we have one more error, it looks like it says
273:54 - that I probably forgot to export my component,
which Sure enough, I did. export our form
274:01 - component. And it says react is not defined.
And that's because I forgot to import react.
274:07 - And you might remember way back in the beginning,
the reason it says that is because JSX is
274:13 - normally not valid JavaScript. And so I actually
need the React library in this file so that
274:19 - it knows how to handle JSX. And our form is
backup. Let's see if it's working.
274:26 - Good news.
274:28 - Choose the destination. And say we have some
allergies or preferences and we're male. And
274:41 - yeah, it looks like everything else is working.
Perfect. And as such, we still have a quite
274:48 - large form that we have to scroll a little
bit in. But this entire file is only caring
274:55 - about the UI component of our form. Whereas
over in the form container is only caring
275:01 - about the business logic of the form. This
way, we have a nice separation of concerns.
275:07 - And it allows us as a developer to essentially
have an easier time when we need to make changes
275:12 - to this file, we don't have to scroll up and
down over hundreds of lines of code. Now,
275:16 - one thing that's probably good to point out
now is with libraries like Redux. And with
275:22 - the recently released context API, notice
that the container component split of components
275:28 - here, like we just did is not actually used
quite as often, especially when you are injecting
275:34 - context or global state from Redux or something
like that into your components. When you do
275:39 - that, a lot of the business logic is delegated
to another place entirely. Which kind of means
275:45 - that you end up writing a lot more functional
components to simply consume the data that
275:51 - lives in Redux or in some global context or
something like that. But as you're developing
275:56 - your applications, this can be a really great
way to separate some concerns, if you find
276:00 - that you have a lot of business logic, and
a lot of display logic happening all inside
276:04 - the same component. Hey, with that, under
our belts, we are ready to move on. Alright,
276:14 - we've made it to our capstone project, where
we're going to build the meme generator that
276:18 - we talked about at the beginning of this course.
Now, the way this will work is part of the
276:22 - time, I will put comments here that will give
you some direction for you to build out parts
276:27 - of the UI yourself, at which point like I
have in the past, I will give you time to
276:31 - pause the lesson and do that afterwards, we'll
go through that together. And there will be
276:36 - other times where I'm just building things
on my own and kind of explaining what I'm
276:39 - doing. Now notice that we're starting almost
completely from scratch, the only thing that
276:44 - I have included already is a bunch of styling
that I've pre written. And the reason I did
276:48 - that is because while this isn't a course
on styling, and just for time sake, so that
276:53 - it's not too boring, but over an index js,
we have nothing here. So get excited, this
276:58 - is gonna be fun. And let's get started. Okay,
so the first thing you need to do is to create
277:06 - that boilerplate code that will get react
to render something on the screen. And the
277:11 - thing you'll render should be an app component,
which you'll need to create separately.
277:15 - Pause now and give that a try. Okay, let's
get rid of this comment. And we'll say import
277:24 - react from react, React DOM, from react dash
DOM. We'll use react Dom to render our app
277:42 - component, which doesn't exist yet. We're
gonna put it
277:47 - at the root.
277:50 - we'll import app. And this is basically the
boilerplate we need for there. So let's create
277:57 - our app.
278:00 - Yes. There we will also import react from
react or export our component. Let's start
278:10 - by making a functional component called app.
Which we will have returned something so we
278:18 - can see that it shows up on the
278:20 - screen. Awesome. Okay, let me type up some
comments for the next thing that you're going
278:29 - to do.
278:34 - Okay, so you need to create two new components
header and meme generator, the header is only
278:43 - going to display things and the meme generator
will be calling to an API and holding on to
278:48 - data. So let that information help you determine
what kind of component you're going to create.
278:53 - And as always, each of those components should
be in their own file of the same name. Pause
278:58 - now and try that. Okay, this one's pretty
straightforward. So let's create a new file
279:07 - called header dot j. s. And a new file called
meme generator. Yes, these comments are in
279:20 - the header import react from
279:23 - react.
279:28 - export the header. And since this is going
to be component that just displays things,
279:32 - we'll make it a functional component.
279:37 - Now,
279:40 - always I'll just put something that says header.
279:44 - And
279:45 - over in meme generators, since this will be
holding data and making calls to an API and
279:49 - so forth. This should be a class component.
We'll still need to import react from react
279:56 - and since it's going to be a class I'll go
ahead and just import opponent as well
280:06 - export the meme generator and create my meme
generator class 
280:17 - that it will need a constructor which calls
super. And I mentioned that it's going to
280:23 - hold some state. So I'll just put some empty
state there. And I will also put my render.
280:30 - So that as before I have something showing
up. Now that I've created both of those over
280:48 - in my app j s, I can import them. I'll go
ahead and use them here, I'll need to wrap
281:00 - everything
281:01 - in a single element. We'll make an instance
of our header of our meme generator. Awesome,
281:12 - good so far. Okay, over in my header, I'm
just going to begin
281:16 - putting some stuff here. So I know that I
want to use the semantic html5 tag header.
281:26 - And I want this to have an image. And we will
set this as our source which is a troll face.
281:36 - And we'll give it an all property of problems.
too long for this line already. So I will
281:49 - separated, we'll just have a paragraph that
says and I save this. Okay, you'll see my
281:57 - styles have kicked in because I used the header
tag. And I'm going to go ahead, I didn't do
282:03 - a great job making this responsive. So I'm
just going to make this window a little bit
282:08 - bigger. If that has overlaid your code a little
bit, you may want to make sure you maximize
282:13 - the window here, first grandpa and go a little
smaller probably. And this is everything we're
282:20 - going to do with the header for this project.
So we're going to go to meme generator, and
282:25 - pretty much everything else we do will just
be in this file. So now it's time for you
282:28 - to get your hands back on the keyboard. So
I will write up some comments here for what
282:33 - you're going to do next.
282:39 - Okay, we'll just take this one small step
at a time. So all you're going to do is initialize
282:48 - state to save the following data, top text,
bottom text, and a random image. And I've
282:53 - provided the URL to the first image that you'll
use. So pause now and do this. It sounds pretty
283:03 - straightforward. So to initialize state, I'm
going to build up this object here and save
283:08 - top text, which is text, but I'll just start
it as an empty string. Bottom text, also an
283:15 - empty string. And my random image, which I'll
just say, IMG is the image I provided. They
283:24 - were not rendering this anywhere. So we can't
really display this. But that's okay. This
283:28 - is good for now.
283:29 - Let me delete these comments. Okay, I have
another challenge for you. Let me write up
283:34 - the comments now.
283:45 - So we're going to be using an API that provides
a bunch of meme images. And your task is to
283:49 - make an API call to that API, which I've provided
the URL to, and save the data that comes back,
283:56 - which you'll find under response dot data
dot meems, to a new state property called
284:00 - all meme images. And the data that comes back
is going to be an array. Let's pause now and
284:06 - give this a try. When we're getting data that
we expect our component to have at the beginning,
284:15 - we're going to use the lifecycle method component
did mount. As soon as the component mounts,
284:21 - we're going to use the native fetch function.
And we're going to call to the URL that I
284:28 - provided. And this will return a promise that
we need to turn into a JavaScript object.
284:37 - We will call the JSON method on that. Then
we'll get the actual response that will be
284:46 - useful to us. And I'm going to pull the memes
array from response dot data. And then like
284:55 - it says, we need to save it to a new state
property called all meme images. So I'm going
285:00 - to initialize that as an empty array, and
start, and then I will set state. And I don't
285:10 - really care what the previous state was. So
I will just say all meme images. Now B means
285:18 - that we just pulled just so I can see that
this data is here, I'm just going to console
285:24 - log, the first item in this meme, and take
a look at what that shows me. Cool. So I've
285:33 - got an ID, a name, and a URL, which is what
we're going to be using is this URL property.
285:40 - Awesome. can delete these comments here, if
you remember back from the demonstration of
285:45 - what this meme generator will look like, there's
going to be two input boxes here that allow
285:50 - you to input the top text and the bottom text
on the image. So what I'm going to do now
285:55 - is just stub out a form. And then I'll have
you create the input boxes. So I'm going to
286:01 - wrap everything in a div building a form.
And for my styling, I'm going to give this
286:12 - a class name.
286:15 - informer.
286:17 - And we'll create a submit button. It says
Jen, all right, and then I'm going to put
286:28 - some comments here for what your task is next.
286:40 - So now that I'm inside of my form element
in JSX, in order to write these comments,
286:45 - I have to put the curly braces. So that basically
tells the system that I'm back inside of JavaScript,
286:50 - so I can write these comments. So what you're
going to do, you can delete this when you're
286:55 - ready, what you're going to do is create two
input fields, one for the top text and one
286:59 - for the bottom text. And remember that this
form should be a controlled form. So you'll
287:04 - need to add any of the attributes to these
inputs that you'll need in order for that
287:08 - to still work. Don't worry at this point about
creating your on change handler, because that
287:13 - will be the next thing that you do. So pause
now and try this. Okay, so this is just creating
287:23 - two inputs, so we will make two inputs. And
save time, I'm going to do this in both places,
287:33 - we will have a name attribute which one of
them is going to be top text. And the one
287:40 - is going to be bottom text. In both of these
should be a type of text,
287:47 - I will give them a placeholder. So I don't
need to worry about having labels. Take up
287:56 - text and say button text. And then for this
to be a controlled form, I need to make sure
288:03 - that I set the value equal to whatever the
current value of state is. Up text, bottom
288:12 - text. Now the last part that I mentioned you'll
be doing next is to write the on change handler.
288:20 - And since these are both text inputs, you
won't have to worry about checkboxes or anything
288:25 - like that. So this one should be fairly straightforward
reference, let me write the comments up here.
288:33 - Create the unchanged handler method here and
it should make sure to update the corresponding
288:40 - state property on every change of the input
box. Pause now and do this. Okay, as I mentioned,
288:50 - this is going to be a fairly straightforward
one, we're going to have a handle change that
288:55 - will receive an event. And to fix my syntax
errors down here, I will add this to this
289:04 - dot handle change. And that method will need
to be bound in my constructor. And while we're
289:15 - at it, I'll just put a console log here. See
if this is working. Let me get rid of that
289:21 - console log from the means console. And our
method is correctly firing. I want to pull
289:37 - the name and value properties from event target
so that I can get the name of state that I'm
289:47 - supposed to update top text or bottom text
and then whatever is actually typed into the
289:52 - box and I'm going to update my state. Now
I don't care about the previous state So I
290:00 - can just provide an object and I can say whatever
the name is it the value that we pulled from
290:06 - the box. Okay, and we'll get a chance to see
that that's working pretty shortly. If you
290:12 - want, you could pause now and there, right
a console log or put something in your render
290:16 - that shows whether or not this is working.
But we'll just move on. Next thing I'm going
290:21 - to do is have a place to display our meme.
Now remember, we're receiving an array of
290:27 - all the memes that this API has. And what
we're going to do is make it so that when
290:32 - they hit the gen button, it just chooses one
of those images at random to display in the
290:37 - area below. So I'm just going to build the
area below right now. Make it a div. And for
290:47 - my styling, I give it the class name of meme.
Have the actual image here. source is going
290:58 - to be what we've saved in state as the random
image. And I'll just put an empty alt property
291:05 - for now. And then for the text itself, I'm
going to have a couple of H twos which have
291:15 - a class name of up and bottom. And all they're
doing is displaying saved in state
291:28 - objects, text and
291:32 - text.
291:33 - Okay, so my image is showing up. This is the
random image that we initialized here.
291:41 - And let's see if my text is working. One does
not simply walk into Mordor and you'll notice
291:55 - that every keystroke, my text is showing up
correctly, which means I'm correctly setting
292:00 - the state on every keystroke. And the time
has come for you to do the last challenge
292:05 - of this Capstone. So let me write out some
comments.
292:15 - I wrote these purposefully a little bit vague
so that you had to think back and look at
292:22 - your notes or go back and look at previous
lessons, whatever it might take, going to
292:26 - create a method that when the gen button is
clicked, chooses one of the memes from our
292:32 - all memes images array at random makes it
so that image that it randomly chose is the
292:38 - one that shows up in our meme display image
area down here. Now remember, the property
292:44 - on the chosen image in the array is dot URL.
You write that here. That URL is the property
292:52 - that is the string of where the actual image
is hosted. This is your final push, give that
293:00 - a try. Okay, so we could make it where I have
an onClick handler for my button. But because
293:09 - this button is inside of a form, I personally
think it's more semantic to have this be an
293:14 - on submit of the form. We'll call this handle
Submit. So this is where we will create that
293:24 - function. Need to grab the event, because
we don't prevent the default into try and
293:35 - refresh our page, which will be annoying.
So we don't want that to happen. And while
293:39 - I'm at it before I forget, let's bind the
handle submit in our constructor. What we
293:49 - have now is just a basic code challenge. Oh,
I will just pseudocode some of this, I'll
293:55 - say I need to get a random number, which represents
index the array and get the meme from that
294:06 - index. Once I have that meme, I'm going to
set my random image property to the URL the
294:22 - random item I grabbed. I've broken this problem
into smaller parts, we're going to get a random
294:30 - number so that I can make sure that it's one
of the indices in our array. We'll make sure
294:39 - that I multiply whatever the random number
I get by the length of the meme images array.
294:47 - And now that I have that random number, it
should be easy to get a random meme just just
294:56 - the index of the all meme images Random number
that we just got. And all I'm concerned with
295:05 - is the URL property. So I'm just going to
snag that right now. And I just need to update
295:12 - state now. We'll use set state. I don't care
what it used to be. And I know that I'm upgrading
295:19 - the random image property, and the value will
be the random meme image. Let's save this
295:26 - and see what we get. Oh, you'll notice that
some of these are funnier than others. But
295:37 - point is we have a random meme generator,
we've written the top text, the bottom text,
295:41 - it's randomly choosing from the array of images
that we pulled from the database online, we
295:47 - now have a completed meme generator. Just
because I'm OCD about this stuff, I'm going
295:52 - to get rid of these comments. This would be
a perfect time to check this code out, see
295:57 - if you can play with it make a better one,
be try to get the gist from a different API.
296:03 - And although it sounds really obnoxious, one
of the best things that you can do to practice
296:07 - stuff like this is delete all of this code
and try it again from scratch. Feel free to
296:12 - take a break at this point, you've really
accomplished a lot of great things by following
296:16 - through this course and learning the things
that you've learned, I have just a few more
296:20 - topics that I want to cover before we finish
up this course. Oh, as always, when you're
296:24 - ready, let's move on.
296:31 - Because react is maintained by Facebook, and
quite a few developers over at Facebook, as
296:36 - well as the open source community react is
progressing really quickly. If you've ever
296:42 - tried to watch tutorials of react from more
than maybe two years ago, you might notice
296:47 - that it's quite a bit different now than it
used to be. And we even had a lesson on how
296:52 - react version 16.3 introduced some new lifecycle
methods and also started the process of deprecating
296:58 - some other lifecycle methods will react 16.6
was just released. And there's even more new
297:04 - functionality now and a lot on the horizon
for react version 17 and onward. So I thought
297:11 - I would make this quick lesson about some
of the more modern features that you can use
297:16 - when you're creating react apps. And a lot
of these features will work or won't work,
297:21 - depending on which versions of ACMA script
you're supporting in your project. But as
297:25 - long as you're using a transpiler, like Babel,
you'll be able to use pretty much the most
297:30 - modern versions of ECMO script and therefore
use some of these things. Now, I didn't do
297:35 - enough research to know which of these are
just experimental or which of these are definitely
297:39 - going to be included in reactor in JavaScript
in general. So you may want to just be aware
297:45 - that any one of these at any given point may
just disappear and not work anymore. But it's
297:52 - pretty widely used. And I'm fairly certain
a lot of this will be included inside of either
297:57 - react or JavaScript itself. Now one of the
major changes is that our methods can be written
298:03 - as arrow functions. And I believe that scrim
that may complain a little bit about this.
298:08 - But if you're doing this in your own environment,
this should be okay. I can change this to
298:12 - be an arrow function, which looks like a very
small change. But in fact, what it does is
298:18 - it gives it a lexical this inside, which means
that it doesn't create its own this context,
298:24 - but instead uses the this of its surrounding
environment. Basically, what this means is
298:31 - I no longer have to bind my methods in the
constructor anymore. So I could get rid of
298:37 - this. And because this is an arrow function,
and it's using the this from the class, everything
298:43 - should just continue to work. So that's a
really easy and convenient update that you
298:48 - can make to your class methods. Now, another
one that's a little more dramatic, but also
298:53 - really nice is the ability to create class
variables, just like we're doing here with
298:58 - this dot state. But doing so outside of a
constructor, so I can create this class property
299:05 - by simply saying state equals an object. And
I guess in this case, to be consistent, we
299:12 - would have a first name, which is an empty
string. And doing this essentially allows
299:18 - me to get rid of my constructor entirely.
The last time I checked, this was still a
299:23 - proposal in JavaScript, but it looked like
it was heading towards being included into
299:29 - the language as a permanent resident. So I
haven't researched this recently, but just
299:34 - take this with a grain of salt and know that
again, this may not be included, but it's
299:38 - looking like it will be we can simplify this
a little bit, since it's just a one liner.
299:44 - So those are both really nice, fairly simple
changes that we can make. I mentioned once
299:48 - again, the changes to the lifecycle methods,
I created a lesson that you've probably already
299:54 - gone through that talks about some of those
new lifecycle methods. So if you need a refresher,
299:58 - go back, watch those again. But Down here
at the bottom, I've included some resources
300:03 - to some of the more either advanced react
topics or brand new react topics. So for example,
300:09 - in react 16.3, they introduced a kind of public
non beta version of their context API, I've
300:18 - had a chance to play around with the context
API, and I'm a total convert. In fact, a Wii
300:23 - school, we have opted to drop Redux in our
curriculum, and OPT instead for using the
300:29 - context API. And there's a number of reasons
to do so that doesn't mean that Redux no longer
300:33 - has a place. But for our purposes, the context
API does everything we want, and it's quite
300:38 - a bit simpler to learn. And then there's some
advanced react topics such as air boundaries,
300:43 - render props, higher order components. All
of these can be found directly inside the
300:48 - React docs, which you can see all of the links
here just go directly to the React docs. And
300:53 - in fact, in the menu bar, they're all part
of an advanced react sub section, that would
300:58 - be a really great resource for learning more.
301:00 - I've also included here, a link to the React
router homepage, the React router is a great
301:07 - way to make single page applications using
a very declarative library, which is react
301:12 - router. It's very widely adopted and used
in most larger applications that are single
301:17 - page applications. Then, at the time of this
recording, these topics react hooks react,
301:23 - lazy, memo, and suspense are all brand new
additions to react. I haven't looked too much
301:29 - into lazy and memo. But I know suspense has
to do with asynchronous loading. And hooks
301:36 - have to do with a way of essentially including
and modifying state in a functional component.
301:42 - And in fact, if you look at some of these
changes that react is making, it's looking
301:46 - like they're heading towards a place where
react will almost completely be written in
301:51 - functional components. And class based components
will not officially be deprecated. I think
301:57 - they even say in their docs that there's no
plans to remove class based components. But
302:01 - it seems pretty clear that they're moving
in a direction that they are encouraging the
302:05 - use of functional components more and more.
Hopefully, I'll get a chance to update this
302:09 - course, to include some more topics as they
become released. And as I become more familiar
302:15 - with them, but for now, just know that react
is changing constantly. And it's always a
302:19 - good idea to be checking the change log to
be engaged in your community and watching
302:24 - for these changes, because it can be really
beneficial to you and your career to be up
302:30 - to date on the most advanced and most modern
react features.
302:39 - So we just went through and created the meme
generator together. And before that, we had
302:44 - done a multi part series on creating a to
do app, but to do apps, honestly, are pretty
302:49 - boring. And the more you do them, the more
boring they get. And so I decided to include
302:54 - here some resources that you might use to
come up with ideas for apps that you might
302:58 - want to build yourself, I was going to come
up with a list of my own ideas. And then I
303:03 - came across Free Code camps lists that they
have built over the years. And each one of
303:08 - these is an entire blog post with a whole
bunch of different ideas that you can use.
303:13 - So I would honestly just recommend visiting
these websites, reading through the ideas
303:17 - that they have, and either picking one or
using that as inspiration for ideas for you
303:21 - to come up with.
303:25 - Alright, you've made it. Now there is so much
more to learn about react. But you now know
303:33 - all the building blocks, you need to start
building react apps for yourself. So let's
303:39 - look at a quick summary of the core concepts
we've talked about in this course, we talked
303:43 - about JSX, and how it's a wrapper around JavaScript
that allows you to write your UI using a familiar
303:49 - syntax. html, we noticed that there were a
couple slight differences here and there.
303:54 - But for the most part, it helps writing components
feel very familiar. We talked about two different
303:59 - kinds of components that you can make a functional
component and a class component and what each
304:04 - one of those is capable of. Basically, if
you need state or lifecycle methods, you will
304:09 - have to use a class based component. Otherwise,
it's a pretty good practice to just stick
304:13 - with a functional component. In fact, going
forward react is kind of looking like there'll
304:18 - be releasing features that allow everything
to be written as a functional component if
304:22 - you want. We talked about some basic ways
to style react. If you're using CSS classes,
304:28 - you'll need to use class name inside of your
JSX in order to assign a class to that element.
304:35 - Or you could write your CSS as a style object
directly in your JavaScript, which can be
304:39 - helpful if you need them to be dynamic, or
you just generally prefer to style right there
304:44 - inside your component. We talked about props
which are the primary way to pass data down
304:49 - the component tree and we covered state, which
allows your components to hold on to and modify
304:55 - the data. Anytime you want to change state
you'll need to use these sets The method,
305:01 - we talked about conditional rendering, using
various vanilla JavaScript techniques, you
305:05 - can determine which parts of your UI you want
to show up at any given time. And oftentimes,
305:10 - this is done based on some variable that's
held in either state or props. And we spend
305:15 - some time learning about forms in react and
how to gather input from users in form elements.
305:21 - And there is so much more about react that
I would love to cover, but we're going to
305:25 - have to save all that other good stuff for
another course. For now, thanks so much for
305:30 - letting me guide you through learning one
of the best frameworks out there.

Cleaned transcript:

Welcome to an introduction to react. My name is Bob Ziroll, and I'm here to guide you through learning how to build front end web applications. using one of the world's most popular front end web frameworks react. But first, a little background about me. I'm the Director of Education at V School, which is a technology education school that teaches full stack JavaScript and UX courses to those looking for a career change. I've been teaching in the boot camp space since the very early days of boot camps starting in 2014. Over the years of teaching and designing curriculum to help students learn difficult topics in a very short amount of time, I've developed my own learning philosophy, which I think would be helpful to share. First of all, the easiest way to learn something is by doing it the hard way, there's truly no substitute for getting your hands on code as soon and as often as possible. During our class orientation at V school, I typically give an analogy about myself. So I've recently developed an interest in woodworking. I've read books, I've watched hours of YouTube videos, I've received new tools as gifts. However, none of those things has actually brought me any closer to becoming a skilled carpenter. It's not until I actually put in the hours of cutting, sanding, gluing, screwing things up. And finally, eventually building things that I'm actually proud of that I can say that I'm actually starting to become a skilled woodworker. As such, if you actually want to learn react well enough to be able to use it, you'll need to be actually writing react code. Most of the lessons in this course are followed up by an exercise that I fully expect you to put in real time and effort into accomplishing on your own. Now, if you decide to breeze through them the easy way without actually doing the exercises, you're actually kind of taking the hardest road possible to learning react. And along those lines, you should really use the scrum platform to its full potential. Throughout the course, I'll be having you pause the lesson and actually dive into the code making changes. But even when I don't ask you to pause and play with the code, you should take the initiative to do it on your own. And just be curious in general, doing this is going to help you avoid what some call tutorial hell. And if you want some more information, there's a medium blog posts that I've linked here in the slides. The idea essentially being that you should get your hands on the code as much as possible. And by doing so actually do the things. Okay, not just necessarily the exercises I asked you to do, but anything that you're interested in curious about. And as I mentioned, scrubba is ideal for this sort of learning if you use it the right way. Another main point of my learning philosophy is that spaced learning and repetition are absolutely key, this information to actually stick in your mind. And one of the main tenants of spaced learning is that you don't just binge on the course, this kind of goes in line with the concept of Tutorial How, where it can be the easy way out to just binge on the course and feel like you're actually learning something when in reality, your brain has been incapable of actually retaining the information. So as you're going through the course, make sure that you take frequent breaks. And I don't just mean for five or 10 minutes here, there. But finish a couple of key principles, practice them quickly, and then rest your brain for the day. And when you come back to the course, don't be afraid to go back to previous courses and review them. Yes, it will obviously take a lot longer to complete the course that way, but it will be super beneficial to your learning. Okay, I'll get down from my soapbox for now. But I'll be reminding you of some of these things frequently throughout the course. So for now, let's quickly cover what you'll actually be learning. When we talk about react, we can't avoid the concept of components. components in react are the core building block for making reusable pieces of HTML. And pretty much everything else that we talk about deals with how to use these components to build the web applications that we want to build. We'll also be talking about JSX, which is reacts proprietary wrapper around JavaScript. And it simply lets you build components in a very familiar way, using the HTML syntax that you're already familiar with. We'll also spend a little bit of time talking about styling your components will get a chance to learn about props and how to pass data around your application. And when we talk about props, we oftentimes talk about state which is how to maintain and change data in your application. We'll talk about event handling, and how you can have strong interactivity with your users. We'll talk about lifecycle methods, which help you hook into different timing events of your react components. We'll talk about fetching data from an API using HTTP. We'll talk about forms and their role in creating a good user experience. And there's plenty more that we'll be covering in this course as well. Now, there's a few things that you should already know before taking this course. And honestly, it's just the basic building blocks. htm Well, CSS, vanilla JavaScript, and ideally a little bit of the updated syntax for JavaScript in iOS six. If you're feeling rusty on any of these topics, I've included links on the logo that you can click, and it will take you to another free course here on scramble to brush up on that topic. Okay, that's plenty of talking. For now, let's actually dive into react. Let's take a quick look at some of the applications that we're going to be building throughout this course, this should give you an idea of what you'll be able to accomplish by the time you're done with this course. The first one is kind of the default required to do list application, it may seem a little bit boring, but it actually covers a lot of the topics that we're going to be talking about in this course. And of course, you can click an item to mark it as completed, and we see some style changes and everything. And is kind of a capstone project to this course, you're going to be building a meme generator. And the idea is you input some top text, some bottom text, hit the button, and it will randomly choose meme image from an API that contains meme images. Some of them are funnier than others. So get excited. React is really exciting technology. And it's going to be an excellent tool in your tool belt as a developer. Alright, let's get started. We're gonna jump right into learning about react. But first things first, let's learn why we're going to be using the React framework, instead of just developing something in vanilla JavaScript. One of the things that you'll hear people talk about with react is its speed, and how fast it is compared to web applications that are developed in vanilla JavaScript. The way that react is able to do that is by using something called the virtual DOM, we're not going to go into a lot of detail about the virtual Dom right now. But if you're interested in learning more about it, I've included here a link to a YouTube video with a pretty simple explanation of how the virtual DOM is different than the way that web applications work when you're developing in vanilla JavaScript. So feel free to pause the screencast and click on the link to watch that video if you want. For now, it's enough to know that the virtual Dom helps make react work a lot faster than vanilla JavaScript. Another really awesome benefit react gives us is the ability to create reusable web components. And I'm going to talk about this through an example. Right here, we have the bootstrap default navbar. If you haven't used bootstrap before, it's just a CSS library that has pre written code that makes some elements look really good for you. But you can see that it's about 40 lines long, and it's pretty unwieldy and difficult to understand. And if you were to include this in an HTML page with a bunch of extra content in it, it would be pretty difficult to decipher, and everything would start to feel pretty cluttered. reacts, web components allow us to take these pieces of HTML. So this 40 lines that we see here, and put it into a component of our own, almost like a JavaScript variable. In this case, we call it my sweet navbar. But you could call it whatever you want. And we can see that this is a lot easier to read, if you're coming into it as a developer, to see exactly what is going to be where, in this case, the body of my HTML will have a navbar on top, some main content in the middle and a footer at the bottom. The ability to do this is really nice for reusing these components on other pages if we need to, and for making our code look a lot nicer when we're working in it. Another reason why react is so awesome that I like to include is that it's maintained by Facebook, whether you care for Facebook or not. There are a lot of really smart developers at Facebook whose job it is to work on react. On top of that, because react is so popular. There's a lot of contributors on their GitHub, which is open source who contribute to the React framework, which means it's going to be evolving for the foreseeable future. And last but not least, React is very hireable. At vi school, we focus our curriculum and our efforts on the things that are most likely to get our students hired. And react is very in demand right now. So if one of your goals is to get a job as a front end developer, React is a great choice in terms of frameworks to learn. So that's enough talking for now let's jump into some code. Okay, we're just gonna jump right into the code. One thing you're gonna want to be somewhat familiar with is es six, or ACMA script six or ACMA script 2015. It's a slightly newer version of JavaScript if you're used to using things like var. We're going to be replacing that with some Yes, six stuff like const and lead. There are some videos here on screen buy that should be able to help you learn that if you're not familiar with it, and you'll want to do that before you move too far along in react because we'll be using a A lot of ESX in react, one of the things we'll be using really often, in fact, in every react file we create is the import statement. And so I'm going to import react from react. And you can see over here on the left, I have react and react Dom dependencies included in this project. So I'm actually also going to import react Dom from react DOM. And the last thing we're going to do is use react Dom's render method to render something to our screen. But let's stop and explain this a little bit here, I'll get to why we're important react in a second. But for now, I need to import react Dom so that I can use it in my line for code here, where I use the render method. And what this is going to do is it's going to take two arguments, one is going to be what you want to render. I'm doing this in pseudocode, obviously, so that it's clear that this is not the right syntax. And the second parameter is, where do I want to render it? react Dom dot render makes the second one really easy. Remember, everything is going to have to tie back to an HTML page of some sort, the JavaScript we are going to continue to write is simply going to be compiled down to or turned into elements on a page. And so you can think of it as being inserted into an HTML page of sorts. So let's go over to index dot HTML really quick. You'll see everything in a basic HTML pages here, including a link tag and a script. Don't worry about the fact that this is slightly different right now, it will still connect correctly to our index dot j s. One thing I want to point your attention to though is this div right here with the idea of Route right in between the opening and closing div tags is where react is going to be sticking everything that we create, you can think of this as a container for our entire application. So back in our index dot j, s, this, where do I want to render, it needs to point to the div with the ID of route. And the way that I can do that is using a vanilla JavaScript document dot get element by ID route. This way render looks at the first parameter, which I haven't filled out yet that says, What do I want to render, and it will stick it inside of the div with the ID of root. Now let's look at this first part, what do I want to render? Let's get rid of this placeholder. And let's just start with a simple h1. And of course, we have to say hello world to refresh the browser over here, and notice that we actually get an h1 with a Hello World in there. Now the astute of you might have said, Wait a second, why are you putting an HTML element in the middle of your JavaScript parameter, that's an obvious syntax error, JavaScript is going to think that that is a less than symbol and that this is a greater than symbol and not know that this is an HTML element. Well, fortunately for us, the people that created react created a little pseudo language, you could call it called JSX. JSX is very much like a JavaScript rendition or version of HTML. In fact, we're gonna see that most of JSX looks almost identical to HTML. With this few slight differences that we'll talk about along the way. There's a lot happening under the hood with react, where everything is getting compiled down to a plain JavaScript version of itself. But for us, we can just pretend that this will work just fine. And it turns out, this is why we need to import react from react because the React library is the one that will enable JSX to work the way it's supposed to work. In fact, you can see that if I remove the import react line, and try to save it and refresh the browser, it tells me that react is not defined. Even though I'm not explicitly using react anywhere in my code here. Under the hood, it's getting used to interpret the JSX. Another point I want to touch on really quick is also dealing with JSX. It's important to note that I can't render two JSX elements next to each other. For example, if I wanted an h1 and a paragraph, you can see that it's already not liking what I'm doing. And if I were to save the page, it tells me that you can't have two adjacent JSX elements. But instead they have to be wrapped in something so that it counts as just one element with two elements inside. For example, I might choose to wrap this in a div And I need to put my reactant back. And there we go. Using JSX can take a little bit of getting used to, but it's much better and nicer after you get used to it, then doing it the old way where you'd have to say things like, var, my new paragraph equals document dot, create element paragraph, and add some inner HTML, then take that paragraph and append it to a parent. That was very imperative. Whereas now we're going to be doing things much more declaratively. I also want to interject right here that you should remember that the benefit of scrambler is that you can pause this screencast and play with this code. So please take some time to do that. Not just at the end, but also throughout the entire screencast. We're also going to be including entire screencasts that are dedicated to you doing exercises, as mentioned in the first video. So take some time, play with this, study it up and get ready for the upcoming exercise. All right, welcome to the first practice of this course, this is where it makes a lot of sense to you scramble over a regular video. As we mentioned, we highly encourage you to actually give these practices and exercises a shot. Sometimes it's really tempting to just skip ahead to the solution. But you're only going to be hurting your own education. If you do that. So please give it a shot. The way this will work is I will put an objective up on the screen sometimes some hints as you see here. And then I'll leave about five to 10 seconds of silence to give you a chance to pause the video and actually try to accomplish the objective. If you get stuck, I recommend that you not just skip ahead to the solution. But instead that you go back to a previous video and relearn the thing that the practice is about, the more effort you put in, the more likely This is actually going to stick. So let's take a look at this practice. Your objective is to fill in the basic boilerplate react code needed to render an unordered list to the page inside that unordered list, you can put three list items with anything that you want in them, it doesn't really matter. The way that you'll know that it worked is that it will show up in the little browser window on the right here. Since it may be your first time working in react, I've included a couple hints that remind you of the steps you'll need to take. So I'm going to leave some silent space now and go ahead and pause the screencast and give this a shot. Okay, let's go through the solution together, I'm going to remove the comments that I have. And the first thing we will need to do in almost every react file that we create is we're going to need to import react from the React library. And since this is our index dot j s, and we're going to need to render something to the page. We're going to need the React Dom library. Last but not least, we're going to use react DOM. We're going to use its render method. And there are two parameters that we need to pass into render. The first one is what do we want to render? Well, as the challenge said, we need an unordered list. And inside that unordered list, we need three list items. Copy and paste this so we don't need to 123 you can see here, this is kind of looking pretty ugly. We're going to see in the future how obviously, we're not going to put our entire page here in the render. So I'm going to move this on to its own line so that it looks a little more like regular HTML. If you didn't do that, that's totally fine. And then I'm going to be really boring and just put 123 in here. Okay, that's the first parameter. And the second parameter is where do I want this to load into. If you remember from the last screencast, we have a div with the ID of route. And that's where we want to place our application. So in react Dom dot render, I need to provide get element by ID route, so that it will go find that element and let react Dom dot render node, this is where I want you to put This code and when we refresh the browser, we get our three bullet points with 123. If any of that was confusing, I highly encourage you to go back to the previous video, rewatch it, play with the code, come back, do this practice. Again, mess with the code that I put here, see if it works, the way you understand it, try to break it, etc. Doing that is going to really help you understand react on a deeper level than just passively watching me explain it to you. Awesome job. Let's move on to the next topic. In the last practice video, I mentioned that you wouldn't want to end up sticking your entire application right here inside of react Dom dot render. Imagine having a web page with hundreds of elements on it, this would just be impossible to maintain. Back when we talked about why react was popular. One of the reasons we mentioned was reusable web components, we're going to get a chance right now to learn how to create functional components in react. The reason they're called functional components is simply because you create them by writing a function, I'm going to add some space here and create a new function called my app. Notice here that I'm using the constructor convention of having capital camel case for my component name. This is a very strong convention that you should adhere to in react always have camel case and start your first letter as a capital letter. And the really simple thing about functional components Is that all you need to do is return the JSX that you want this component to represent. So in our case, we can just take this unordered list and return the unordered list from our functional component. It's important to know that although in this case, it would work without it, it's always a good idea to wrap this in parentheses. And then another strong convention that I really like is to put everything on its own lines. This way, it reads a lot more like HTML. Then in react Dom dot render, we can create an instance of our functional component by placing the name of the component and wrapping it in basics tags, you'll notice that I've made this a self closing tag, there are some instances where you'll want to create components that can accept children elements. But for the next little while, we're going to make every component a self closing component. Now notice when I refresh, I have the same thing that I had before. Though the same rules apply to our functional component as they did in react Dom dot render, meaning I can't return two different elements next to each other, like having another ordered, ordered list near this one. That just wouldn't work because our component needs to return a single JSX element. And here it's returning to, you can usually get around this by just wrapping everything in a div, or whatever other elements that you want to wrap it with. In this case, we're just going to return the unordered list. So maybe you can start to see the power in doing this, we're going to be able to create our own components, which contain pieces of JSX, which represent HTML in our final product, and we can start composing them together. Here I have a component that I created rendering, React elements or JSX elements or HTML elements. But as we create more and more complex applications, I'm going to be creating components that render other components that I have also created. Eventually, it needs to boil down to a regular HTML element. But sometimes that can happen over the course of maybe dozens of your own react components that you created. Eventually, as we start to create more and more components, we're obviously going to split these into their own files. But for now, it's important to play with this and see what you can get to work, what doesn't work and get a really good idea of how a functional component works. As we move on, we'll start to make our file structure more and more complex. Now that we've learned about basic functional components, let's put it to practice. Okay, let's get some practice of functional components in. One of the things we really pride ourselves at V school when we're teaching our curriculum is that we include a lot of spaced learning and repetition, which is a principle of teaching that helps people retain as much information as possible. As such, like before, I haven't included any boilerplate code for you to start with. So it's going to be up to you to build everything from Scratch during this kind of repetition is going to be really good for your memory and should help you really understand the concepts. So let's go for the objectives you have. First, you're going to set up the basic react code from scratch again. And then you'll need to create a functional component called my info that has an h1 with your name a paragraph with some information about yourself, and an ordered or unordered list of the top three vacation spots you'd like to visit. Obviously, since we're not going to be grading this or anything, you're welcome to change this to whatever UI you'd prefer to present. And then you'll need to make sure to render the instance of your functional component to the browser. If you want a little extra challenge. Although we haven't yet gone over how to style your components, feel free to search on Google how you can add some style to your page. If it's enough of a challenge, just getting the functional component working, then don't worry about that we're going to cover styling in a future lesson. One less thing before I give you some space to pause the video and try this out for yourself, I will once again get on my soapbox for the last time, I promise that you should definitely actually do this exercise. If you're hoping to get from this course, a real understanding of how react works just passively watching isn't going to do it. So please take the time to actually do this. Okay, I won't mention that again. So go ahead, pause the video. And we'll pick up in just a few seconds and solve this together. Alright, so like last time, we need to start with some of the boilerplate code, we're going to once again import, React from react, import, React DOM, React DOM. And this is going to be a little out of order. But I already know that I need to render something to the page, they already know that I'm going to call my component my info. So I'm going to put an instance of my info right here. And lastly, I'm going to do my get element by ID route. So that render knows where to put the my input component. Okay, now the more fun part, let's build our function. Remember, the one thing that the functional component needs to do is return the so to speak HTML that we're going to be putting in the page. In reality, as you know, it's actually JSX. But sometimes it's helpful just to think of it as HTML. Since I already know this is going to cover multiple lines, I'm going to put everything inside of parentheses. Now one thing you may have tried to do just by habit is putting an h1 and putting your name and then going to the next line and trying to put a paragraph. But think for a second what the problem with this is. If you realize that the reason this is a problem, you may have tried to save this and it says adjacent JSX elements must be wrapped in a enclosing div for an enclosing tag. So I'm going to put this whole thing in a div. And it's a very common mistake to make, especially as you're starting. So if you made that mistake, don't worry about it. Okay, right here, we should have something that is at least working. So I'm going to save this and see if it renders and there we go, we have a good start, all I need to do is add my unordered list and put a few list items in there. And I've always wanted to visit Thailand, let's say Japan. And I've never been to the Nordic countries. So we'll just add Nordic countries in general. And when I save this, I should see that my list shows up in the browser. As a reminder, if you look in the very upper right, there's a little left arrow. If you press that and open the side menu, there's a chance to ask questions on any pieces of code you're unfamiliar with or didn't understand. And I'm going to be trying to check these as often as I can. So if you ask a question there, I'll try to get back to you as soon as I can. Also, just because we finished this example, don't be afraid to spend some time playing with this code a little bit more before moving on. Again, the more you get your hands on the code and actually play with things, the more likely this information is to actually stick and for you to be able to be productive with react. Once you feel pretty comfortable with everything we've covered so far. Let's move on to the next lesson. Let's talk really quickly about our setup here. Right now we have our functional component inside of our index.js. But remember, one of the main benefits of react is that we get to create a lot of our own components. Eventually, we're not going to be able to To put everything right here in this file, so what we need to do is we need to take our my info component and move it into its own file. And it's a pretty good convention to have each file contain just one react component. So the first thing I'm going to do is create a new file. And there's a quirk of Scripture right now that you won't be able to see me typing this video, I'm going to right click up here by file since a new file and a dialog box just popped up for me, and I'm going to give it the same name, my info as my component with the same capital camelcase and everything. And you should see it pop up here now and notice that the file, my info is spelled exactly the same with the same capitalization as my component. That's a really good idea, because it will make things a lot easier for you when you're looking through a complex project tree. The next thing I need to do is take this component out of this file, so I'm going to cut it, go over to my info dot j s, and paste it in. There's a few issues here. You may remember in one of the early videos, we talked about why we import react from react, even though we're not using react anywhere, try to think if you remember why that is. The reason we had to do that was because of our JSX. We used to have this component here and it contained JSX. The computer won't know what this is because it's not normally valid JavaScript. But the React library helps it become legitimate JavaScript, which means we undo that back over in my info.js. Anywhere we're going to be using JSX, we need to make sure to import react. Almost every react component you create is going to have this line in it. The last thing we need to do is make this function my info available to other places in my application. The way I need to do that is by exporting it. If you don't feel totally familiar with import exports from ESX, that should be okay, as long as you remember this export default and then the name of your component. But I would also recommend that you go check out the free introduction to s6 course here on screen. But now that this component is exposed through the export default, I'm going to go over to index dot j s. And let's just Command S, we'll save this and see what comes up. Notice it says my info is not defined. Well, that's because we used to be declaring that function here in this file and making an instance of it by putting these braces around it. But now we're not doing that. So we need to import my info from my info dot j s, that's really easy to forget that we can't just say my info dot j s. reason is because when imports don't have a relative path, they will automatically look for a module with the same name that you're providing. This works okay with react and react Dom because they are third party modules or dependencies that I've installed into this project. When it's one of my very own modules, or one of my very own files, I need to make sure to provide a path. So I'm going to say dot slash, which means from the current directory, look for a file called my info dot j s. Another important thing to know about imports is that they assume that you're importing a j s file or in other words, dot j s is the default extension. So I can delete dot j s, and it will still work just fine. Now if I refresh, you get my component back in the browser on the right. As your project gets more and more complex, it's going to be really important that you have a good organizational structure. One simple organizational structure I can employ right now is by creating a new folder called components where I'm going to put all of my components in. So I'm going to create a new folder. I like components. And I'm going to drag my info dot j s into components and looking back@index.js what do you think I'll need to fix here. If you notice that the path to my my info file is now incorrect, because it's no longer inside of the root directory, I need to provide dot slash components slash my info. And when I save this, everything should be working just fine. Having a components folder is to me a little bit of an oversimplified way to organize your application, because you're going to have so many components that you create that you're going to need to find a structure that works best for you. And I'm not going to offer one that works best. You'll probably even see me throughout this course using a few different types. But each person has their own opinions about what the best organizational structure is. And it definitely depends on the project as well. Before moving on, try playing with this a little bit. Maybe go change some code inside of my info, or maybe move it into another folder or change the file name and see what you need to fix in order for everything to keep working. Or if you're really wanting to be forward thinking you're welcome to try and create a new component and nest that inside of my info, but this is actually what we're going to cover in the next lesson. Once you feel comfortable with everything we've talked about here, let's move on. In this lesson, we're going to talk about parent and child components, our applications are going to be much more complex than just having a single component my info, for example, render to the DOM. Instead, you're going to have a complex hierarchy of components that eventually lead down to JSX elements. I'm going to start from scratch here just for repetition sake, so bear with me. Take a second to see if you can remember what the next step is, you can start with something simple like getting HelloWorld as an h1 to show up in our browser. In order for anything to show up on the page, we need to use react Dom dot render. first parameter is what we want to render, so maybe h1 hello world. The second parameter is where do we want to put that we'll be in an element called route in our index dot HTML. If any of that's confusing, make sure to go back and review some of the previous lessons. But I'll assume that that makes sense from now on. I refresh my browser, I get hello world. But we've moved past this so far. Instead of having an h1 here, we put my info in less time. Instead, this time around, let's create a component called app. An app is going to be an entry point into our entire application. In order for this not to fail, we need to import app. And in order for this not to fail, because that component doesn't exist yet, we need to create it. So I'm going to create a file called app dot j s. Notice it has a capital A because it's a react component. In app.js, I need to remember always to import react. And before I forget, I'm going to export default app works at this point app doesn't exist. So let's create it. Before I put anything in the return, I'm going to refresh the browser really quick. And notice that there's a problem. See if you can remember what we need to return here inside of this component. I need some kind of JSX element. So I might put an h1 Hello, again, refresh. There we go. Or I could put any kind of other HTML in here as well, maybe a div. Inside I have an h1, maybe something like an unordered list. Maybe at this point, I decided that I want this to be an actual website and I start putting things together. So this top section might be a navbar. And below the nav I might put a main section where most of my content will go. And at this point, I would do something like add some styling to my unordered list so that this was more like an F bar. As you can see, this app component is getting pretty large. And it's kind of defeating the purpose of react, we talked about how we can take each piece of HTML and put it into its own component. We're not really doing that very well here. Instead, we may decide to create separate components for each little piece of HTML that we need on our page. Take a look at this diagram to get a better understanding of what I'm talking about. Here we're rendering the app component, but app may decide to render another component called my info where my info may eventually render some kind of regular JSX element. Notice I'm making a distinction between components and elements. elements are the ones that boil down essentially to regular HTML code. Notice that here I have a lowercase D and Dev. That's a dead giveaway that this is a regular element rather than a component that I've created. On the other hand, my info starts with a capital M. And that helps me understand that this is a component that I've created. You may have heard of how the DOM or document object model is oftentimes referred to as a tree where the HTML element is the most base root of that tree. In our case, we can think of the app component as being the root of this tree. And the app component isn't limited to just rendering my info. It could also render, for example, a footer and that footer could render an app actual element called footer, which has all of the HTML relating to our footer in it. And if we have a footer, we naturally probably want some kind of header. I've specified these as awesome header and awesome footer. So it's not to be confusing with the regular footer element. And just like app is rendering more than one component header may also render multiple components, for example, a navbar, but also maybe a logo component. And those eventually would need to end up as regular elements of some sort, in this case, an image element and the nav element. Hopefully, here, you can start to see how our react application could become more and more complex as time goes on. And this is only scratching the surface. So in our sample app here, let's create a little footer really quick, going to create a new file called footer dot j, s with a capital F, as seen here, which you'll need to import react from react is always going to export the thing before I even create it just so that I don't forget. Notice here the difference between the capital F footer and the lowercase f footer. As I mentioned before, the lowercase f footer is the actual element that will get rendered to the screen. Whereas the capital F footer is the component that I'm creating. It's just a function with a name. Inside here, I may put, I don't know an h3. This is my footer. I've created this component. But notice it's not showing up on our page. That's because our app is not rendering a footer anywhere and need that footer in this file in order to create an instance of it. So I'm going to import footer from dot slash footer. And maybe right under my main section, I'll include the capital F footer that I just imported. refresh this now. There's my footer element. At this point, I have kind of a strange mixture of elements that are regular JSX elements being mixed in with components that I have here. If I can, I really like to have this app component almost be like a table of contents, where instead of having some elements in some components, it's mostly just components. So this might look like this. header, main content, and footer. And then I can go to each of those individual components and see what elements those are rendering. Now header and main content don't actually exist. But the point is, you can continue to nest your components as deeply as you need, we're going to get a chance to practice this in the upcoming lesson. But if you'd like you can spend some time trying to fix this code. Since header and main content currently don't exist, go ahead and create them. Also, before we move on, feel free to click in the blue slides in the lower left to check out that diagram once again. Once you feel pretty comfortable, let's move on to the practice. Okay, let's jump right into the challenge, you're gonna set up a react app from scratch. Once again, what you're going to render is the root app component, as mentioned here, and that app component should render three separate components, each of which will have some kind of elements that they render, first, a navbar component. Second, a main content component, and third, a footer component. So give this your very best shot. Remember, you can always turn to Google for help. Once you think you have this challenge, then move on with the video and we're going to do this together. Okay, let's get started. We're going to import react from react, React DOM, React DOM, we're going to use react Gmes render method to render a component called app ranks you select the root element app doesn't exist, so we need to import it. That file doesn't exist, so we need to create it epital a app dot j s. Remember, I like to treat this file as kind of a table of contents. So we'll need to import react from react again. At this point, I'd like to just put something on the page to make sure that I'm on the right track. Okay, at least not showing up tonight. No, I haven't made a mistake up to this point. If you look back in the challenge, it said to create a navbar main content and footer components, we could do this in any order, we could first create the files, and then import them, we could import them and create instances here and then create the files, whichever way you want to do and makes most sense to you is totally fine. I'm gonna finish my app component first, and then go create the components necessary for that to continue working. And remember, everything needs to be surrounded in a single component, because any given component can only return one element. Here, I'll put my header content and footer. Up GS needs to know about those first, so I will import those. And those files don't exist yet. So I'm going to create, you can imagine as I keep creating new components that this is going to get pretty cluttered. So I'm actually going to put everything into a components folder. drag my footer, header, and main content into my components folder. I also need to fix my app j s. References here. Okay, over in those files, I'm going to start creating those components. This will just have a basic footer element. For now, I'm just going to fill it with some text because it's not too important what's there. If creating these components is still a little bit foreign to you, and you have to remember what step comes next, I'd recommend actually retyping everything from scratch. Because I've done this enough times, I'm actually just going to copy everything and paste it into header changing some of the references. It'd be the same thing for main content. elicit this just says main instead of main content, and that it's got a lowercase M. Hopefully you understand at this point that this is because this is a regular, you could say HTML element, main, header and footer are all semantic html5 elements. main content, however, is something that I created. And so I couldn't say something like main content, because it's not a real HTML element. Let me refresh the page and see if it's working. Okay, it's pretty boring. And it looks like I forgot to put this is the main section. Right. In the next couple videos, we're going to learn about actually styling this because this is pretty awful. And we want this to start looking good. Once again, feel free to pause the screencast and play with the code that we have here. Or if any of this was still confusing, go back to the beginning and try it again from scratch. Once you feel comfortable, let's move on. Alright, so from what we've learned so far, we can get started on our phase one of our to do application. So what you'll do is you will initialize a new react app from scratch, you're going to render an app component in the index js file here, which means you'll need to create an app component from scratch. And your app component should render three or four checkboxes with the paragraphs or spans or whatever kind of text you want next to it as if you're making a to do list with some hard coded items already in it. So pause the lesson here and give this a try. And then we'll go over this together. Okay, so let's do this. I'm going to erase my comments here. And as always, we need to import react from react, import, in this case, React Dom from react DOM. We're gonna use react Dom to render an app component to the screen. And we want that to be in the element with the ID of route. The app component doesn't exist yet. So we need to import it. And this file doesn't exist yet. So I'm going to create it. We'll move over to that file. Now. Where I want to also import react from react will create it our functional component and want to remember to export it before we forget. This functional component should return the div will need to wrap everything in it. Because it can only return one element at a time. And inside this div, we will put our input type checkbox. And our paragraph. For now we'll just put some placeholder text. You save this and see how it looks. Okay? It's pretty ugly. But we're going to get to that later. And it said to do three or four times, so I'm just going to copy and paste these two lines here. And there we go, we've started our application. That's pretty straightforward. And the next time we see this, we're going to have learned about styling. And we're going to add some style to this, so it isn't quite so ugly. So if anything was confusing, go back and play with this. Again, try to do everything from scratch if you'd like, feel free to post a question in the q&a section. And when you're ready, let's move on to learn more about styling. This example is the same one that we finished with at the end of the practice in the previous lesson. And I wanted to take some time to learn how to style this. Now, there's actually a bunch of different ways to style things in react. And we're going to start with the one that's probably the most familiar to you. And that's just using CSS classes in CSS rules on those classes. Let's drill down the tree here and see where we can actually start putting some classes. You'll see on my index js, I'm rendering an app component. And the app component is rendering a div with three other components header, main content and footer components. And each one of those is just a basic component that either has a single element as part of it with some text inside, let's focus our efforts on styling the header. And normally, what you do in HTML, when you're going to add a class to something is you add a new property called class. But one thing we need to remember right here is that we're not actually dealing with HTML. Instead, we're dealing with a variation of JavaScript JSX. And something you'll just have to remember with JSX is that using class as a property name doesn't really fly. Instead, we need to use something called class name with a capital N. A lot of places will tell you the reason that you have to do that is because class is a reserved keyword in JavaScript. But the truth is underneath JSX is just using the vanilla JavaScript Dom API. And if you've ever used the vanilla JavaScript Dom API, you'll have something like document dot get element by ID, something. If you wanted to add a class to that, you could say dot last name, plus equals and then add a new last name. I prefer class list myself because it has properties that you can use to add and remove classes. But that's beside the point. Class Name is an underlying JavaScript Dom API property. And so using class name as part of our JSX is simply a way to access that Dom API under the hood, which is what JSX and react is doing. That's just a little bit of extra background that you may or may not be interested in knowing. But the point is, all you need to do is wherever you normally would say class in HTML use class name instead. Here I'm going to say class name equals F bar. I'm going to delete this before it becomes a problem. Then over in my style, that CSS, I just need to select the navbar and include whatever styles I want. For example, I might change the background color to purple. If I save and refresh this, you can see that now the background color is purple. I'm going to copy and paste in some style since this isn't a course on CSS, so that we can get something that actually looks pretty good. Okay, the only thing I've done here was added a zero margin to the body so that it went all the way to the edge, and a number of styles to the navbar. If you're interested in actually checking this out, feel free to pause the video. But the point is everything that you normally do in CSS is going to be essentially the same as you do here. The only change we've made so far remember is that we have to use class name instead of class. One of the other things to keep in mind that maybe tricky to remember at first is that you can only apply the class name attribute to react elements like header or paragraph or h1. If you try to apply class name to a component that you've created, such as header or main content, it's going to do something a little bit different than you think. And we're going to talk more about that in the future. But for now, just remember that the only thing you can apply classname to are react elements and not react components, the things that look basically like regular HTML. Another thing that can be kind of tricky in the beginning is if you're using something that requires different levels of your tree hierarchy, like Flexbox or CSS Grid, where you need to know which items are the flex container and which items are the flex items. be tricky looking at your component to know exactly how that works. For example, if I wanted to make this div a flex container, and I wanted to specifically style one of the items they're in, I would need to go to the header component or the main content component. And look at the elements, they're in order to give them the class names that are necessary. For example, if I go to header js, this header element will be the direct child of this div. Think of it as react, taking the contents that this header component is returning, and copying and pasting it into this place. When you create your react applications and you inspect with the dev tools, you'll see that this is actually how things end up in the DOM tree. So take some time to play with classname. In this project, see if you can style the main section in the footer a little bit differently. And once you feel good, let's move on to the next lesson. Before we get too much further, I wanted to cover some caveats about the way that I tend to write my JavaScript, you may have noticed that I tend to leave out things like semi colons, you may be super used to putting semicolons everywhere at the end of a statement, I personally have recently decided that I kind of hate them. And so I've been removing them from my code. Obviously, there's still some places that you simply can't avoid them. For example, when you're writing a C style for loop, zero semicolon that's necessary in order to separate the three different statements on one line. But for the most part, at the end of statements, they're not really required, and they won't break anything by not having them there. This is totally a personal style decision. And like I said, one that I've only recently made. In fact, it's such a strong habit for me that I may accidentally put some semi colons in future videos. Another personal preference is although ESX technically gives us the ability to put arrow functions everywhere, we used to have the function keyword. For example, I can say const app equals an arrow function. And one of the benefits of this is actually that I can actually just wrap everything in parentheses and get rid of my return. And in this case, I could even simplify it like this. I've either not yet gotten used to this syntax, or I simply don't care that much for the look of an arrow function. I think they're extremely useful in certain instances, for example, whenever you normally would put an anonymous function or when you need to write a class method, which we'll talk about later. But my personal preference is to keep the function keyword and it just to me makes it look a lot more like a regular function component. There's a lot of people who will disagree with that. And I'm totally fine with that I totally understand the preference for doing it as an arrow function. But me personally, I tend to keep my function keyword in there for my functional components. I'm not going to necessarily advocate for one way or the other. So that's totally a decision that's up to you. Okay, I just wanted to get some of that out of the way. Let's move on. Before we can move on to talk about inline styles and some dynamic styles, we first need to understand how JSX and JavaScript play together, we saw that in the middle of our JavaScript, we're able to return something that looks like HTML, but we've discovered is actually JSX. What if I have a variable that I want to stick inside of my h1? Maybe for example, I have a first name and the last name. And instead of saying hello world, I want to say hello, Bob's a role. Well, I might be tempted to say hello, and then first name, plus space plus last name. But I'm assuming you can figure out exactly what's going to happen here. When I save this. It literally interprets every character that I typed as if it were the text inside of the h1, which is pretty much exactly what we should expect it to do. So how do we jump into JavaScript while we're in the middle of our JSX, they actually made it really simple. All we have to do is surround any JavaScript that we want to be interpreted with curly braces. And once I refresh this, you'll see that it actually interpreted everything inside of the curly braces as JavaScript. The way I like to think of this is we're looking at JavaScript, JavaScript, JavaScript, JavaScript, and now we're in JSX land. Once we're in JSX land, which actually started with this less than symbol, everything will be treated as if it were regular HTML, meaning any text inside is going to be literally interpreted. However, as soon as we want to get back into JavaScript, we put a curly brace and now we're back into JavaScript. Learned JavaScript JavaScript JavaScript, closing curly brace tells me we want to leave JavaScript and go back into JSX. And you can do pretty complex JavaScript operations inside here. Since we've mostly converted over to the e6 syntax, I'm actually going to change this to the string templating syntax of ESX, where you put backticks, and then $1, sign curly brace surrounding any variables that I want to show up, then I can just put a space itself, and that will be treated as a literal text space, then $1, sign curly braces again, last name. And I save that and you see, we get the same result over in the browser. Because this is just regular JavaScript inside pretty much anything that I could regularly do in JavaScript I can do inside of these curly braces. Let's look at one really simple example. Maybe when it's morning, I wanted to say good morning. And when it's night, I wanted to say goodnight, without actually having to come in and change the code manually. Well, I can just do some simple JavaScript to set that up. I'm gonna speed this up really quick, but we'll get a chance to explain it in a second. Here, you can see one example where I've created a new date instance, and simply put in my h1 It is currently about. And then in JavaScript, I got the hours and did a modular 12, so that it would be in a 12 hour clock system. Alternatively, I could check the current hours for what time of day it is, and set a string equal to either morning, afternoon or night, which let's try that out right now. So here, all I did was set a variable called time of day, and did a simple if else, to check what time of day it was. Then down here, I simply said good, jumped into JavaScript. And said time of day, when I refresh this, I get good night. Because it's nighttime where I'm recording this, hopefully, you can start to see the possibilities that this brings. And we're gonna see as the course moves on that this is actually really useful. We needed to see this right here simply so that in the next video, when we talk about inline styling with the style property, the way that we have to do that, we'll make a little bit more sense. Feel free to mess with this, there's some pretty fun things you can do. Once you're ready, let's move on. Let's pick up really quick where we left off in the previous video, we created this little application to tell you what time of day it was. Essentially, we want to add some styles with inline styles this time, and we're going to see why this might be the way we choose to do it instead of using a class name. Normally, to do inline styling with HTML, we simply put a style property and set it equal to whatever CSS styles we want. Maybe we want to change the color to be this kind of yellowy color that I just grabbed. Well, let's see what happens when I try to save this. Let me open the console. Notice that it says the style prop expects a mapping from style properties to values instead of a string. We have to remember here that we're not actually inside of HTML. So sometimes the rules are going to be a little bit different. In this case, JSX expects style to not be a string, but instead to be an object, a JavaScript object. So I'm going to delete this and put in an object and say, color colon, and then as a string. That color again, notice that I have some syntax problems. Remember, anytime I want to change from JSX into JavaScript, I need to wrap my JavaScript with a set of curly braces. This can be a little confusing at first, because objects are also wrapped with curly braces. But in order for this to be a JavaScript object, I need to wrap it in curly braces. So we end up with two sets of curly braces. Now when I refresh this, you'll see that I get my more orange or yellow color as the color of this text. If I want to add additional styles, because this is an object, I just add another key value pair. For example, maybe I want it to have a background color of this somewhat red or color that I got. Well, what's my problem now take a second to see if you can figure out what's going on. Remember, because of this set of curly braces over here, we're actually inside of JavaScript. And inside of JavaScript, I can't have a dash in the middle of my property name. I technically can in regular JavaScript by surrounding this with quotes, but that's beside the point. Because of this inside of the object where we're defining our styles. We're going to change anytime that there's a dash, we're going to get rid of the dash and make everything camelcase. This right here is the legitimate style object. Let me refresh. And you can see now we have a different background color. As you might imagine, this style object right here may end up getting longer and longer, in which case this h1 line is going to become really long and it looks a little bit ugly. to split this out onto separate lines, so what I prefer to do is actually make a separate variable. Let's just generically call it styles for now. And put this entire object into that variable. We can split this onto its own lines without it looking funny. inside of my curly braces here, where I'm now inside of JavaScript, I can just put variable name. And that's going to be exactly the same thing. Notice when I save, it continues to work. What's nice about this is as I continue to add styles, it doesn't clutter up my h1 down on line 24. There's a number of little tiny quirks that we have to remember when we're doing these style objects. For example, anytime I have a measurement that's going to be in pixels, I technically can just put the actual number value in place, and the default will be pixels. So when I save this, you see that I get a slightly smaller font. But 200, I get a really big font, and so forth. I can also still specify pixels. But obviously, that's not going to work with numbers by putting 200 pX because that's not valid JavaScript anymore, I need to turn this into a string. And now it's valid JavaScript again. And then anytime I want to use another unit like M or VW or percentage or something like that, I will also put that as a string. Also notice once again, that I've replaced the dash with a camel cased version of font size. There are some pretty interesting limitations with this. For example, it looks pretty funny when you have to add things like vendor prefixes. But there's other things like pseudo selectors, such as colon hover, that become actually impossible to do inside of these inline styles. If you need something like that, for now, you're better off just doing that in CSS and using class name. And in the future, you can learn about really cool styling libraries, such as styled components. For now, we're just going to keep it simple and stick with either inline styling or using class name and using CSS styles. You may ask yourself why you would ever want to even use an inline style like this. Well, one reason is that you may want something to be more dynamic, in which case JavaScript would actually determine what the styles are. Let's take a quick look at what that might look like. Notice what I've done here, where I moved the styles up here above my if else, and set a default font size of 30 pixels, then I let my if else in my JavaScript actually determine what color the font is going to be, I changed not only the time of day string, but I also changed the color property of my styles object. Because it's an object, I can access and create properties just by using the dot syntax. If it's morning time, I use this color. If it's afternoon, I use this color instead. And in any other case, when it's night, I use this color instead. Because I'm recording this at night. This red color is the one that's actually showing up. But let's see what happens when I create the date not for the current time. But instead for a time that was this morning. This is the year, a month today. Let's say it's 10am. I save this, notice that we get instead the color that is the color for morning. If I change this to, let's say 15. And it's hard to see, let me choose a different color for the afternoon. You can see a little more clearly this is choosing a different color for the afternoon. This may be a little bit contrived. But the point is we can have dynamic data that actually changes the way that our hard coded components display. Take a second to try and think of different things that you may be able to accomplish by having these kinds of inline styles. I'd also at this point, recommend spending as much time as you can to really solidify the stuff that we've covered together. So far, we're about to come up on a topic that typically is a little bit challenging for some people to really help you to make sure that you understand everything we've talked about up until now. In the next lesson, we're going to talk about a concept called props, and how we can make our components quite a bit more reusable. Props is a super exciting topic. And we're about to get into parts of react that make it extremely useful. So get excited. And let's move on to the next video when you're ready. Alright, so let's pick up where we left off with the to do list. Now that we understand Parent Child components and how a parent component can render a child component, and we understand how to inject some styling into our react apps. Let's progress our to do list forward a little bit. So before we get to styling, what I want you to do is to take these input and paragraph pairs, and I want you to put them into their own component called to do item. For now it will still have just this hard coded placeholder text here paragraph And later, we're going to learn how we can actually make those different. But that'll be the first thing to start with. And then essentially, you have a blank canvas to paint whatever kind of picture you want, you can make this look as traditional or as weird as you'd like. So go ahead and hit pause and give that a try. Alright, so the first thing is moving each of these into their own component. So I'm just going to copy this and create a new file called to do item dot j s. And while I'm still here, I'm going to import the new item from that file. Let's go over to to do item, we'll import react from react, create our functional component, we'll just return the thing that we copied before. And remember, I can only have one element that I'm returning at a time. So I'll wrap this all in a div. And then over in app j s, we don't need these anymore. But instead, we can just create instances of our to do items. And everything looks the same. Now since this isn't necessarily a course on styling with CSS, I'm basically going to cheat right now, I'm going to set myself up by creating a class here of to do list. And over in my to do items, I'm going to give this div a class name of your item. And I'm basically just going to paste the styles that I've already created. Okay, and you'll notice that let me make this a little bit bigger. And notice that I just kind of came up with a cool little paper looking stack and have a checkbox next to each one that's a little bit prettier, with nicer font and little separation and so forth. Obviously, you're welcome to pause this and look through some of the styles that I have. But it's really nothing too fancy. And since I'm not really a wizard at CSS, stuff like this, with the cool little effect on there, I basically just found online. main takeaways, though are to remember that if you want to apply class to your elements, you'll need to use class name instead of class. And if you wanted, you could apply some of these styles just right here in line. So with a little bit of CSS styling, our to do list is already looking a lot better than it was. Now we are checkboxes do technically check and uncheck but what we're going to do is make sure that when we check these, some actual data is changed, which will allow us to do something cool, like put a little strike through through these texts. Once you feel pretty comfortable with this, let's move on. Let's talk first about the concept of props in react. To do so we're going to look at just a regular HTML file, notice that this has nothing to do with react. This is just a basic index dot HTML, I want you to take a close look at the three elements that I've put inside the body, the anchor, the input and the image and think about what's actually wrong with them right now. None of these things are actually going to do anything important. anchor tags need an H ref for them to make any sense at all. This way, the HTML spec can define the anchor tag once and allow us the ability to change the place that the link sends us. For example, here, I may put a link to Google. Or obviously, wherever I want to send the user to in this link, an image tag is very similar. An image tag alone without the source property is pretty useless. An image element needs a source in order to function correctly. This may either be the path to a local file or the URL to an image hosted online. In those two examples with anchors and images, the href and source properties respectively, are required. Inputs technically will show an input on the page. But I can beef it up a little bit by adding additional properties such as placeholder, or the name property, or the type property type is an interesting one. Actually, it allows me to change this input to be multiple different things. For example, this may be a radio button or a checkbox or a regular input. That input could be either text or an email or a phone number, and even changing it to a submit button. A lot of times these are called attributes. But another legitimate word for it is a property. If this simple concept in HTML makes sense to you, which I assume by now it probably does. Understanding props in react is not too difficult. Instead of using the built in HTML tags, since we're creating our own components, we can actually make it so that we can allow properties to modify the way that the component acts. So in the next video, we're going to see how we can actually do that. I want to make one more conceptual point before we actually get into using props with react. This here is from the YouTube homepage. And while I'm pretty sure the YouTube homepage doesn't use react since Google is the main backer of Angular, the concept will remain the same. Think for a second how this page may be developed in react, something you'll begin to get really good at doing is noticing how something can be divided into separate components. For example, notice that each of these separate pieces of the page are all very similar in their own way. If you notice, each one of them has an image on the top that takes up about the same amount of space. Each of them has a title, which is in bold and appears usually directly below the image. Each one has a number of views. Each one tells you how many days ago it was published, each one has a little timestamp inside of the image that tells you how long it is, you can imagine that the creator of this page didn't actually go into the code and copy and paste this a bunch of times. If this were developed in react, then you can imagine there might be a video title component that is created. And that component has a number of components inside such as an image, maybe an h3, a little timestamp box, and so forth. The main point of what I just said is that it will be a single component that's developed once, but we need to make it so that that component can change depending on the different properties such as the image URL or the title. That's what we're going to be working on in the next video. Right before we move on, though, I wanted to get you used to the idea of thinking in terms of react back a few lessons when we talked about parent and child components, that tree can go as deeply nested as you want. In fact, you can see here, we have different lists. So there may be a component that is a list component, which renders a number of video title components, which in themselves render an image and an h3 or whatever, like we talked about. Also, over here on the left, you can see a number of things on the page that may have only been developed once as a single component. And then given a property of maybe a little image on the left and the text that should show up as part of the link. Hopefully, you can see how the idea of web components and reusable HTML is really powerful. And this can help you understand why frameworks like Angular and react and Vue JS are very popular. So that's enough with the conceptual let's move on to some code and see how we actually do this in react. So let's take a look at an example where it would be really nice to have separate components, but not just separate components. But those that could take different attributes or props in order to make them a little bit more dynamic. Here, I've created just a really basic contact card list, where it shows the image of the contact and a name for the contact the phone, and email. Right now I only have four contacts and my contact book. To start, we know that it would be really nice to take these pieces of repeated HTML code and put them into their own components. But from what we've learned so far, we would actually have to create four separate components, one for each individual contact, but that's not really gonna work for us. So first things first, let's actually create the component. And then we'll learn how to make it more dynamic. We're going to create a new file called contact card, Gs. And I'm going to take this div, which is the repeated div across these four contexts, and just copy it. And I'm going to start a new component. If you'd like, feel free to pause the video and see if you can figure out how to do that. As always, for components I'll need to import react from react Yak. And I'm going to export the function that I'm about to make my spacing here. And this is a great start. The problem with this is that it has a hard coded image source, a hard coded name, hard coded phone, a hard coded email and so forth. Instead, we're going to want to figure out a way to make it so that this contact card when I make separate instances of it will be able to take as properties the different information that I'm going to put into these places. Another quick conceptual point you can think of has to do with functions, which actually mirrors pretty nicely what we're doing because we are using functional components. When you create a function, let's say add numbers. Maybe this function returns the result of one plus one. Well when I want to do an operation with one and two, or one and three or two and three, I'm not going to want To create separate functions for every single one of them. Instead, we use function parameters, maybe a and b. and make it so that any two parameters we pass into this function, we can get a different result depending on those inputs. The same concept of adding parameters to a function to allow the function to be more reusable is the same thing we're going to be doing with react components. Let me delete this. In order for us to illustrate this, let's go over to App j s. And I want to be able to replace all four of these with the individual information for each component. But let's start by actually putting the component in there, I would like to be able to say, I want a contact card here. And I actually want four of those. Well, for this not to fail, I need to import contact card from that file. And now comes the time to actually pass down individual information for each contact card, just like we did with regular HTML where you pass in an attribute or a property right here, we're going to do the exact same thing, except this time, we get to decide what the name of that prop is. For example, each of these contact cards has four pieces of dynamic information, the image URL, the name, the phone number, and the email address. So let's pass a property down for each one of these, it's actually pretty simple, I'm going to say name, equals, and then put in the name that I want this contact card to use. And I'll do the same for the other information, image URL on an email. Now, for me personally, when these start to wrap on two separate lines, I like to put everything on its own line and in rented, I'm gonna do that really quick. I'm going to go through and do this really quickly for the rest of the contact cards, putting each of these individual contact card information into properties of the contact card component. Notice when I just refreshed even though I've put separate different pieces of information into each one of these contact cards, I'm still getting Mr. Whiskers send four times. The reason is a contact card currently has hard coded values inside of itself. But we're passing in separate props, name, image, URL, phone, and email. So let's see how we can inside of contact card j s access the data that we're passing down to the contact part, over in contact card, one thing that we haven't put in quite yet, is inside the parentheses here in this function, it's going to take a parameter called props. Because it's a function parameter, you technically can call it whatever you want, but it's a strong convention to call it props. Props is an object that has properties of that object, each one being a prop that you passed in, or rather, the name of the prop that you passed in. What I mean by that is, we will have inside of contact cards will have props dot name, and props dot image URL, over in contact card j s. Let me just console log ops. Take a look. Take a look at this, we got four console log entries, the reason being we have four instances of our contact card component. And the props are an object with a name, image URL, phone and email properties. This means now inside of my code, instead of having hard coded values here, I can use the property of the props object that's coming in. So I can say source equals, and I can't just say props dot image URL, think for a second why that doesn't work. And think of how you might fix it. Remember, when we're switching between JSX and JavaScript, we need to use curly braces around our JavaScript. We can do the same thing for the other values here as well. Props dot name. Here, I can leave phone colon space as a hard coded value. And then just replace this with props phone in the same thing with the email. Now when I refresh, I actually get my four separate contact cards with the individual information. I'm going to delete this console log so it's not cluttering things up. And as easy as that I now have a component that is reusable in a lot of different ways. Now at this point, I want you to think What would my component look like if my contacts had, say 50 properties to them over an app js, each of these contact cards would end up getting pretty long, right? I would have a prop for each individual thing that I'm saving about that contact, which like I said, perhaps could be something like 50 different properties. Another legitimate way to do this is instead of passing down each part of this person or contact as an individual property, I could pass down an object that was the entire contact. For example, instead of name, image URL, phone and email, I might simply pass down a prop called contact, whose value is an object. Remember, I'm going between JavaScript and JSX here, so I need to put a double set of curly braces, the first one getting me into JavaScript, inner one being the object itself, that object would have a name, an image, URL, phone, and an email. This technically would allow me to get rid of these four properties, and just pass down the single property called contact. Now, this may not actually look better than what we had before. But we're going to see eventually how this data isn't usually hard coded in like this, but rather comes from something like a JSON file, in which case, it can be really nice to pass down the whole contact as a single prop. However, our component is going to be broken now. Notice when I refresh, the only thing that shows up are the phone and email hard coded text. Pause the video and try to think why that might be. The reason is over in contact card, we're receiving a props object, and we told it that that object would have a property called image URL and phone and name and email. However, for our first contact card, we're no longer passing a phone, email and name or image URL. Instead, we're passing a prop called contact, which is an object. So let's go over to contact card, pause the video and see if you can fix this to work. If you're having trouble, one thing that may help is to console log prompts. See what's actually showing up here. Okay, now that you can see this console log, give it a shot again. Notice the first one is not receiving a name, image URL, phone and email like I mentioned before, but instead is only receiving a single property contact. And that contact property is an object, which means I would need to change everything to props dot contact dot image URL, and props dot contact dot name. And the same for these other ones. Now, of course, when I refresh, I'm going to have a major problem because my other components aren't receiving a prop called contact, therefore, it's undefined. And I'm trying to access the image URL property of undefined. So this won't just not show up, it's actually going to crash, which means I need to go back to App j s, and fix each of these other contact cards. I'll spare you the monotony of watching me do that and speed this up. Okay, that was pretty tedious. Let's refresh and see if that works. Okay, now we're working again, our contact card is passing down a single prop called contact, which is an object that has all of the properties that we want. Again, normally, this won't be hard coded, but instead would be something you get from a data file, such as a JSON file, which we're going to cover in a future lesson. And over in contact card, I'm receiving all of my props as an object called props. And since I only pass the single prop down, I have props contact, but props contact is an object. So that has properties itself like image, URL, name, phone, and email. Again, this concept can be a little bit tricky. And I totally understand if this didn't make sense the first time through. As I mentioned before, the sweet benefit of schema is that you can pause this and actually mess with this code. So even if you feel like you understood this, I'd really appreciate if you pause the video and go through and actually mess with this, change the data over in app j s, see if you can then reflect it to show up correctly on contact card. Also, feel free to go grab different image URLs and put those in and see how it affects the code. More you mess with this more likely you'll be to actually understand it well enough to implement it yourself. To Go ahead, give that a shot. And only after you feel really comfortable with it, move on. Okay, I'm sure this has been pretty obnoxious. But this is the very last time I'm going to ask you to do this. I want you to create another react app from scratch. Obviously the repetition is going to be really good for you and what this react app should do is render an app component which should be in its own file. And the app component should render five joke components, we can see that this is going to help us practice the parent child component tree, it's going to help us practice putting components in their own files. But the main thing we're going to practice is passing props down through the joke component. So each joke component should receive a question prop and a punch line Prop, and then render those to the page however you want. That's just kind of the basic part of the practice. But I've added a little extra credit section, which I'd really encourage you to try. So in this case, if your component does not receive a question prompt, you need to think how might you make it so that it only shows the punch line instead? For example, if you've hard coded in a question, text that says, a question colon and then appstack question. Obviously, this syntax is incomplete. But how are you going to make it so that you don't have question, colon, and then an empty space? Also, while you're at it, see what happens when react receives a prop that's undefined? If you don't have a question colon, and you're also not passing down a question Prop, see what happens. And while you're at it, spend some time practicing the style, if you joke component, make it look good. So pause the video do this practice. And we'll go through this together in just a few seconds. All right, I'm gonna delete this. And I'm gonna actually leave some of these comments here, just so that I can remember exactly what to do. We know we need to in a basic setup, import react, and react, import react DOM, React DOM, when to use react DOM. To render our app, we're gonna put it at the root element. Don't have apps, I'm going to import app from a file called app that doesn't yet exist. And I'll create that file. Now. I put a app.js. Over in that file, I need to again import react from react for the app component that I'm about to make, wrap everything in a div. Okay, and here, we're going to render our five joke components, that should be capital J 2345. Now for this to know what I'm talking about, when I am trying to create an instance of a joke component, I will need to import that. And that doesn't exist yet. So let's make that I'll create a file called capital J joke. dot j s. And over in joke j s, let's again, import react from react. Default joke. And before I get too deep into playing with props, I'm going to just have it render something simple just to see if it's working. I may have forgotten something. But let's check this out. Okay, yep, my five highs on the screen, which means my five jet components are working. React Dom dot render is rendering the app component, the app component is rendering a div with five joke components. And the joke component is just rendering an h1. And that's how I'm getting five highs on the screen. And that's the tree that we're working with. While I'm still in this file. I'm going to work on the props here. So I know that I need to pass in a variable. I'm going to call it props because that's the standard. And let's start with something simple. I'm going to render a div with maybe a couple h threes inside. One will have the question. One will have the answer. If you had gotten stuck anytime before this, I'd really like you to pause the video and go review these things that we just went over and then try it again from scratch. You can go back in time to the beginning and actually try to build this out yourself. Then once that makes sense. Come back to this point and move on. Now if everything did make sense up to this point, pause the video here and see if you can figure out how are we going to get the question from our joke that's being passed in. Of course right now. It's not yet being passed in the wind it is how are we going to place it right here. Remember, we're inside of JSX right now. So I can't just say props question because that would literally put the text prompts question here. When I want to go inside of JavaScript, I need to surround it in curly braces. Notice that I get nothing On the screen, think for a second why that might be. Let's actually console log prompts question. Open the console and see what shows up. That's what I get. No. That's because this joke component when I'm creating instances of it in my app, I'm not actually passing in a question or a punchline prop. So when react tries to render a component, and we're not passing it any props, everything will be set as No. What's really cool about react is if any JavaScript inside of JSX evaluates to something like undefined or no, it simply won't display it. This right here is going to be something we need to figure out how to fix when we have our joke components that don't take a question prop. But for now, let's assume that they all have a question and an answer or a punch line. So over here, I'm going to also add props dot punch line, and they can delete my console log here. Let's go back to App j. s. And let's actually provide a question in punch line for every one of these jokes. As I mentioned in a previous lesson, I prefer to put these on their own lines, if they start to get so long that they're wrapping around. You may decide this isn't your style. And that's totally up to you, I still go back and forth as to whether I want this closing bracket to be on the previous line or not. So let's refresh this and see what we get. Cool. Everything's a little bit squished together. So you may decide to do something simple like at the end of a joke, you may put a little break tag, or maybe something like a horizontal rule. But obviously, however you want to style it is totally up to you. And there we have the basics of the first part of our exercise. Now, as we see in the extra credit, some jokes are only a punch line with no question. And as it stands, I have this hard coded word question colon space here. I provide a joke that doesn't have a question. Like my favorite one only has a punch line. See, when I render this, I get a question with nothing there. We're going to talk in a future lesson about conditionally rendering parts of our page. But for now, think about the way that we style our page and see if you can think of a way that we can make this disappear if there is no question. So video and give that a shot. Again, there's actually going to be a real way we do this with something called conditional rendering. But for now, you may find a way around it where you can say I want this h3 to have a style feed display of none under certain circumstances. But afraid here I use the ternary operator to decide what that should be. inside of my object I could say essentially is props that question a thing? Is it truthy, if so displayed in the regular block format, but otherwise displayed is none. Notice that my first one has an h3 that is now displayed none because it no longer has props question. If you're not very familiar with ternary, I highly recommend you go spend some time learning about them because they're actually used quite often in react. Another slightly more concise, but perhaps more confusing way to write this would be instead of using a ternary. And having a default of its own default, like an h3 being display block. We can get rid of that. And we could actually say if there isn't a proper question, then we want to display none. But otherwise, basically ignore this rule totally. If you're not familiar with using the double ampersand in this way, we're going to talk about it in a future lesson. But just know for now, this totally works. You can see over in my browser, I have just an answer to my joke that doesn't have a question in it. But the question does show up in all of these other instances. Now if you look at my joke that doesn't have a question, it doesn't stand out very much. Maybe you might decide that you want your answer only jokes, your punchline only jokes to look a little bit different maybe to be grayed out or to be a totally different color or underlined. I don't know something, also video for a second and think how you might do that using inline styling and JavaScript the way that we did in line six. Maybe what I might do is on my answers, h3 is add an inline style with an object it says the color should be and then do something similar to what I have on the question art on the h3 above where I say if there is no props dot action, then I might want the color to be I don't know some kind of gray This is pretty contrived. But you get the idea, we can start using the different props that come into our component to display things differently. And as such, our joke component is now more or less reusable, we can add jokes that just have punch lines and jokes that have both questions in punch lines. And automatically the joke component knows how to style itself based on the incoming props. And that's pretty much it for this practice, feel free to pause this and play with this as much as you want before moving on. Alright, so we're going to pick up where we left off in the previous practice with our app component rendering a bunch of joke components. Some of these have the punch line in them, and some of them have a question and punch line. But you can see right now that they're hard coded into our components written directly as text. In reality, most of the data that you'll be displaying on a page will actually be coming from some kind of HTTP call to an API, where there's a server that hosts the database, and that database and server are returning JSON data to you. We haven't quite gotten to the place where we can make API calls quite yet. So what I've done is I've made this file jokes, data j s, and it's just an array variable that I'm exporting. And that way in a component, if we want it, we can pull that in and pretend like that's us getting data from an API. So how am I going to take an array of raw data and turn that into a number of components? Well, there's a common saying for those that are learning react, where they say that react helps them become better JavaScript developers. And the reason is, because things like this are oftentimes handled by methods and kind of magic under the hood for other frameworks like Angular or view. But in react, a lot of these simple operations are handled just with vanilla JavaScript. Let me show you what I mean. With a quick aside, we're going to talk about some higher order array methods. If you're not familiar with these, these are methods that you can run on an array that take a function as a parameter and allow you the developer to decide exactly what should happen to the elements in that array. For example, if I had the following array, I can run a higher order method on nums. All map, and map is a method of the nums array, and it takes a function as its parameter, this function will receive each individual number in the array. So I might say num or number, Tim, this function will then run on every single item in the array. And with map, whatever I return from my inner function here, will be placed in the same index of a brand new array with some kind of modification, meaning map actually returns a brand new array, so I'm going to save a new array called maybe doubled. Now, if I from my inner function, return, num times two, doubled should be an array of 2468 1012, and so on, let's take a look. And there's my array of all the double numbers. If you're not familiar with higher order methods, they're one of the key components of functional programming in JavaScript, and they're really, really awesome, I'd highly recommend go study up a little bit on map, and filter and reduce, and some of the other ones that are really useful. With this, we're gonna stick with map and we're gonna see what we can use it for. So the first thing I'm going to do is pull in my jokes data importing. And then we're going to follow the same pattern that we did in our example here, I'm going to say, oops, data dot map, provide a function. Now before I typed the longhand function, so that it was a little clear what I was doing, but we're going to use an arrow function, which can just as legitimately be used here, function is going to receive each individual joke object, so I'll call it joke. And with arrow functions, if I just have one parameter, I can get rid of my parentheses. And what I'm going to return from this inner function isn't some modification on the joke objects per se, but rather, I'm going to return a component joke component and pass in the data from the individual joke object that I'm looking at. Because I'm only returning a single component, I can actually just do this on one line if I want. And if you're familiar with arrow functions, there's an implicit return so I could actually get rid of some of that extra stuff. If this is confusing at all, then feel free to put the return in there. It looks like I have an extra space there. And remember, map returns A new array. So I'm gonna save that in variable. And now I have an array of components. So what am I going to do with an array of components? Well, React makes it really nice, where I can just put an array of components directly here in my JSX. And if I refresh this, you'll notice a couple things. First of all, my jokes on the right are working again, just like they should be. And second of all, you might have noticed this little error that popped up that says each child in an array or iterator should have a key Prop, we won't go too much into the details of why react expects a key prop on repeated components. But it's enough to know that whenever you're doing a map like this, you should give the component that you're creating over and over a new prop called key. Now, whether you're putting this on a component that you've created, or some kind of div that you're surrounding it with, doesn't really matter. Just give it a key prop and put something unique inside the key prop. Usually data from an API will include some kind of ID number or something else that's unique about it. As long as it's unique, it should be fine. Here, I could use the question because the questions are all unique. But I've also included for the sake of mimicking real data, some ID numbers that I might decide to use instead for my key. So over in app j, s, key is going to be choke.id. Now when I refresh, my warning goes away, my app js is much cleaner than it used to be, my data is coming from somewhere external, like it would in the real world. One of the main takeaways, though, is that we're just using the built in JavaScript map method on arrays. In fact, I'm going to include some links to the MDN docs on these methods that will be really helpful for you to understand, if you don't already feel comfortable with them, you can see on the far right in the last part of the URL exactly which method it is that this URL is going to be talking about in this course, will mostly be using map, but we may throw in one of these other ones every now and then you don't necessarily have to go memorize these perfectly right now. But this is just some more material that you'll definitely be interested in learning about. Something else that I just thought of that may be really helpful to you is to realize that things that we're teaching here, because so much of react is just vanilla JavaScript, you can use these things as tools to do a lot of what your imagination could come up with. For example, as I'm iterating over a joke component and creating a number of jokes, I may find a reason to also put a map inside of my joke component. And I end up with a loop inside of a loop, where each joke component renders an array of its own components. That's totally possible. And it's as simple as putting another map inside of your joke component. One joke component gets rendered, it renders a number of other components. The second joke component gets rendered, it also renders a number of other components and so forth. Some of these other methods, like sort, for example, may be used to put things in an order that you prefer, or something like filter could only display certain elements of an array rather than the entire array. If you want an extra challenge, try making it so that our array of joke components gets filtered to only display those that have fewer than X number of characters in the question, or maybe filtered to only include items that do have a question rather than those that are just an answer. This is pretty much everything we have to learn about map right now. So when you feel pretty comfortable with this, go to the next lesson to practice it. Okay, so I know I told you, I wasn't going to make you create the entire react app from scratch. But I didn't make it a whole lot easier for you. I did put the basics in so it's rendering an app component. And the app component is just rendering an empty div right now. And here we have the instructions for this exercise. So given a list of products as an array, which will be the products data that I'm importing from the file called visco products, you need to create first and then render a product component. For each product in the list, you're going to have a chance to practice creating your own functional component, passing props to it, and rendering the correct things to display inside of that component as its receiving props. And you'll also need to practice using the map method on the products data. This array of data is just an array of silly objects that I created for a presentation that I gave last week here in Salt Lake City. And each object has an ID, a name, a price and a description. You won't necessarily need to display the ID as text on the page, but try to think of what this ID might be helpful for. So I will go back to the app and I'll give you a chance to give this a shot. Good luck. Okay, let's start with just a really basic product component. So I'm going to create a new file and call it product dot j s Which I'll need to import react from react and export product. It my functional component already know this is going to need to receive products. So I'll put props there. And let's just return some really basic JSX. For now we'll wrap everything in a div. I have, let's say an h2. For the props dot product dot name. Now this is a nested object because I anticipate passing the entire product down as one object rather than passing down each individual property of the product individually as a prop. Instead, I'll just pass the whole product down as one object and access the properties through props dot product, dot and then the name of the property. Down below it, I will put a paragraph put $1 sign in front of props dot product, price. And then one thing I'm actually going to put here is a string method called to locale string, which allows me to display this as currency. And I believe if I do that, it will automatically put the dollar sign there for me. So I'm actually going to take my dollar sign out. And then after that gets evaluated, I might do like a dash and put the description. This is pretty boring. But I'd spend some time if I were you styling this and getting some more practice with styling. So over in app j s, I know that I'm going to be rendering a number of product components. So I need to first import my product component file. And at the top of my functional component here, I'm going to create a new variable called products. That's a product components. That's going to be coming from products data dot map. So products data dot map, again, we'll create a new array, and we're going to make sure that array is filled with product components. So this will receive an individual product or item. Maybe I'll say item just to distinguish it from all the other things I have named product. I want this to return a product component where the product is my item. And now that I have this array of product components, I'm going to put it inside of my div here and try refreshing. Cool. One thing you notice is I got that warning about the key prop over here, I will also add a key property. And I'm going to pass in the items Id just to allow it to have something unique so that react can correctly place everything the way that it wants to. And I need to fix my spelling here. Let's try refreshing again, everything is showing up correctly on the right, and I no longer have that warning popping up, which is great. I'm a bit of a stickler for correct indentation, so I'm going to fix by indentation here. And this essentially is the completion of this exercise. Take some time to try and style this, see if you can display things a little bit differently. Play with adding products to the visco products array and see how that affects our website. One thing I didn't show is that I can scroll down here and see all of the other products that are listed in that array. Maybe try building a button that when it's clicked in each product tops up an alert with the information about that individual product to spend some time with this. And once you're ready, we're going to talk about conditional rendering. Let's use what we just learned about mapping and props to make our to do list a little more dynamic. What I've done is I've created a to dues data js file here and all it is doing is exporting an array of objects each object representing a to do item. Now normally, you wouldn't do it this way, you would get this data from an API of some sort where the data is living in a database. But since we haven't really gotten there, this will do for now. Then over in app j s, I've imported that data as an array called to dues data. So your task is to essentially turn this array of objects into an array of to do items. Now remember right now to do items are hard coded with what they're displaying. So that will also need to change. Go ahead and pause the lesson and give this a try. So the first thing I'm going to do is take my array and turn it into an array of to do items, then we'll have to fix to do items so that it can receive props before my return. We're going to create up An array called to do items, which is the result of doing to dues data dot map, which will pass a function to that receives an item. Essentially, we're just going to create a to do item. And we're going to pass the information from the individual item object down to to do item currently to do item doesn't accept anything, but we'll fix that in a minute. So I'm going to pass a prop called item. And its value is going to be the object. And now that I have an array of to do item components, let's take these out and replace it with my array of to do items. Okay, and you'll notice that I forgot to put a key prop in here, always an important thing to do. And with the two dues data, what I've done is added an ID property, these IDs we can assume will always be unique. And so over in app j s, I will just add a key. Let's say it's item that I be rid of that warning. Now notice that I still have placeholder text here. But now I have it five times. And that's because I have five items in my to dues data. But to do items still has placeholder text here hard coded in it. Well, we're passing an item prop down. So let's go over to to do item, have it accept props. Instead of putting placeholder text here, we will simply say props dot item dot txt, dot txt, because that's what the property is called in my object. So I save this. And there we go. We have our to do item showing up. And essentially, we're declaratively turning an array of raw data into elements on our application. Now, it's actually going to be quite a while in this course, until we learn about forms and learn a little bit more about how this input type checkbox works. But what I can do is give you a little hint as to how to make it so that the checkbox is checked, when the item is considered completed. Over in the data, you may have noticed that I've set a couple of these to complete and true. Let's make it so the checkbox actually gets checked. When that happens. Again, we're going to cover this quite a ways down the road. But just so you know, for now, every type checkbox gets a property called checked. And essentially, it tells the checkbox whether or not it should be checked, if the thing inside is true. And it will be checked. And if not, it won't be checked. This is going to throw a little warning that basically says you've added a checked property, but you can't change it ever. So it doesn't have an on change handler. But for now, that's okay. We'll cover this again in the future. But you can see in my window over here, take out the trash and mow the lawn are already considered completed. And you'll see when I tried to uncheck it, it won't let me like I said, we'll fix that in the future. But this is kind of a cool little addition we can make now, hopefully that wasn't too difficult. If it was feel free once again, go back, rewatch everything, catch up on any of the lessons that you may have struggled a little bit through up until now. And once you ready, let's go forward. If any of you have done a react tutorial before this one, you might be curious why we're using functional components instead of a class based component. When I'm teaching react, I prefer to start with functional components simply because functions are really easy to understand. And it's obvious what we're doing, we are simply creating a component with a function that returns the UI that we want to show up on the page. But as we go deeper and deeper into react and start learning about some new parts of react, we're going to find that a functional component can't do everything that we need it to do. And so at this point, what we're going to do is actually learn to create a class based component. For now our class based component is going to do exactly what our functional component does. And then in upcoming lessons, we're going to talk about what class based components can do for us, such as allowing us to implement state and lifecycle methods. But for now, let's just look at converting a functional component into a class based component. If you're not really familiar yet with the class syntax in e6, then I'd recommend going over to the scrim by six course and learning a little bit about classes. So instead of converting this functional component to a class component, I'm actually just going to create a new app class below it. And that way, we can kind of compare the two. The class base component will always start with the class keyword. And we're going to give it the same name of the component as we had before app tip instead of parentheses and curly braces, we're going to extend react component and if you're not familiar With classes or what this is doing under the hood, essentially, this is still using a prototype system in JavaScript. And it's setting up a prototype with react component, all that really means is that we're getting a bunch of goodies from react component that are pre written for us. And we're gonna get a chance to see that in upcoming lessons. For now, I'm just going to open this with a set of curly braces. And every class based component at least needs one method, and that is the render method, and it actually needs to be spelled exactly this way. And then render will return exactly what we have in our functional component. In this class component is identical to the functional component we had above. So I should be able to comment this functional component out and save to watch the browser refresh. And we have exactly what we had before. Now let's take a look at our render method. Anytime we have any kind of display logic, that's going to happen, I prefer to do it inside of my render method before the return. For example, you might remember a few videos back where we created a date object. And then we use that data to determine what time of the day it was. And we displayed in the text and used some styling, and all sorts of stuff like that. If you have any code that determines the display logic, or in other words, what exactly is going to show up on the page or what the style of that element will be things like that can go right here inside of the render method before you do the return. So this is a good place to set up your style objects. If you're doing any inline styling, running the logic that will determine how something will get displayed on the screen, things like conditional rendering, all of that can happen here inside of the render method. Now, if you're familiar with classes, you technically could also take that and put it inside of a method of your own a class method. To do that, above render, you would just enter your own method right here. inside of this method, you can do any kind of display logic that you wish. And then from inside the render method, you can call your method by using this dot and then the name of your method. If your method returns something, this is where you put that a few lessons in the future. We're going to talk about some caveats with this. But for now, it's just as easy to put your display logic here inside of the render method. There's one other thing that we have to touch on before we're done with this. And that has to do with props. In our functional component, we could pass props to the function itself, then inside of our code, we would just say props dot, whatever the property was on the props object, there's only one small change we have to make with the class base component. And that's that anytime we use props, we need to make sure that we are using this dot props. It's a pretty common thing to forget to do, especially when you're converting from a functional component to a class based component. But it's also a bug that you'll get really good at catching and being able to fix right away. And before this becomes confusing, I realized I forgot my curly braces up here. And to be consistent, we will add a dot whatever here. As I mentioned at the beginning, class base components enable us to do a lot of really cool new things with react, we're going to be covering those over the next few lessons. But for now, let's get a chance to practice this. So take a second to play with this code. And once you're ready, let's move on to the practice in the next lesson. You can see that I've set this up where I just put all three of these components in the same file. And as I mentioned before, you obviously would want to put these in separate files normally. But for the sake of practice, we're just going to keep them here so you can see everything at once. And as you can see in the challenge, all you have to do is convert all three of these functional components to be class based components. And also there's a small bug inside of this program. So see if you can find it. So now's the time, pause the video and give this a shot. Okay, hopefully this wasn't too difficult. All we're going to do is every time it says function, and then the component name, we're going to change that to class. We need to extend react component, get rid of our curly braces. And then instead of having a bare return here, we need that to be inside of a method called render. And take this return type here, fix my spacing. And that's it for the first one. The second one is essentially the same thing except now we have props and we have to remember exactly what we're going to do when we have props. So Then function will become class will extend react component and get rid of the parentheses, put my return inside of a method called render. And then the one thing that's always really easy to miss here is that instead of props, it needs to be this dot props. Because this is a class based component. This third component looks a little bit more complex. But essentially, it's the same thing. Class greeting. And, and now, like I showed you in the previous lesson, we could decide just to put component here, which then means at the top, we would need to import react and component, then all of this logic is also going to go inside of the render method. Looks like this component is not using props anywhere, so I don't need to worry about changing that to this dot props. And you can see I still am getting exactly what I had at the beginning. Now hopefully, you'll also notice that there's a bug here, it says welcome, comma, and then a space with nothing in it. If you didn't do this in the beginning, take a second now to try and figure out why that is. Well, let's look at the component that's in charge of actually displaying this. And that's our header. Here, we notice that it's saying welcome, this stop props, that username. But when I am creating an instance of header, I'm not passing it any props. So it's coming in as undefined. So it's coming in with nothing. And I need to actually pass something there. So the prop I'm going to add is username was then we can put whatever we want here. There we go. That's fixed. Hopefully, this wasn't too difficult of a challenge. If it was then go back through it and try to convert these classes back into functions. And then from functions back into classes. I know that sounds pretty tedious. But honestly, it's one of the better ways to learn. Once you're ready, let's move on. Okay, so we finally come to one of the most important parts of react and that is understanding state. State is simply the data that a component maintains. And when I say maintains I mean, it actually can change its value. The reason that's a distinct feature over anything we've learned so far is because props, the other way to pass data from a component to another component cannot be changed by the component receiving the props. They say in the React documentation that props are immutable or unchangeable. All that means is that I can't receive a prop and then say this dot props dot something equals some new value. Okay, I can't change props. And if I do, it may cause some weirdness with react. So state is different in that it's a way that a component can maintain its own data and change its own data if it needs to. Let me get rid of this before it becomes confusing, because you should not do this. So anytime we're going to introduce state to a component. The first thing is that the component needs to be a class based component. We'll talk a little bit in the future why. But for now, just know that if you want state in a component, or if you want a component to maintain its own data using state, it will need to be a class based component. The first thing we'll do to introduce state to this component is we need to add a constructor method. constructor is a specific method that's built into JavaScript that initializes parts of this class, if you're feeling a little unfamiliar with classes, I went and grabbed the link to a screencast that has some information on classes that you're welcome to pause and go look at really quick. But the important thing to know is that when you have a constructor, it's a place where you're going to be initializing some values. And the first thing you should always do inside of a constructor is make a call to a global function called Super. In short, what super does is it goes to the parent class or what's also called the superclass, and it grabs some of the goodies there and brings them down so that our class or our app component can use those goodies. One of the main parts of react component that we'll be using is a method called set state. And that allows us to change state but we're going to get there. For now just know that if you have a constructor, you should always add super. And then the only other thing we need to do to add state to this component is to add a property to this called state. And state will always be an object. And so I'm going to set the start state equal to an object. And now I have state in my component. I can access this state anywhere else my components code by referencing this dot state Now you'll notice that I have an h1 here that says is state important to know. So I'm going to add a property to my state as an initial value, the property will be called answer. And its value will be yes. Now take a second to think how you might get that value to show up inside the h1 after this question mark right here. Pause the video and see if you can get that to work. The first thing I'll need to do is add some curly braces, because I'm going to be interpreting some JavaScript inside of JSX. And then I simply type this dot state answer. When I refresh the page, you'll see that it shows up on my browser window over to the right, yes, here, what I'm doing is I'm giving an initial value to my state. This is the data my component will have when it's first initialized. And the special thing about state is that I can always change this to something else later if I want. The only other thing I want to touch on in this lesson before we move on is to mention that we can pass state from this component down to a child component. And remember, the only way we can pass information from one component to another is through props. And so that might look something like this, where I have some kind of child component right here. And of course, if I want to pass any information down to it, it needs to happen through props. So maybe I have a prop that I add called answer. And its value is this dot State DOT answer. The only other thing I want to mention in this lesson for now is that react will do some really cool stuff if we ever change state. And I don't mean changing it here manually in the initial value. But I mean, when we use the set state method that I mentioned, which we'll talk about in a couple of lessons, but if we ever use that method and change the state, React will automatically update every child component that is receiving parts of that state. And so changing the state will automatically change how things get displayed on the screen. But we'll cover that a little more in depth when we start talking about changing state. Now take a look at this code and try playing with state a little bit. And we'll move on to a quick practice. Okay, so here's your challenge. And this is actually a challenge that incorporates a little bit of debugging, not just talking about state specifically. So you're given an incomplete class based component that doesn't have a constructor. And your job is to essentially initialize state and make sure that the component gets fixed. Pay attention to the console, which I've opened in the bottom. So make sure you look at that. And that should give you some good hints as to what's wrong. And for the values of state, you should be able to figure those out based on the context of this component. So go ahead, give this a shot. And we will do this together in just a few seconds. Okay, so there's a lot to be done here. And I'm going to start first by adding a method that this return can be inside. It looks kind of like this was a functional component, and was changed haphazardly to a class based component but in completely. So the first thing I'm going to do is add a render method that this return live inside. Okay, so when I refresh this, you'll see it says component is not defined, well, that's a pretty helpful hint. We either need to extend react component, or we need to import component from react. If we do it this way, then I can actually keep it as component either way is totally legitimate. The next area we're going to run into is a little bit tricky. So I'm going to save this. Notice it says cannot set property props of undefined. Well, that's pretty confusing, because we're not actually using props anywhere here. And where this comes from is this little set of parentheses that shouldn't be there. That's how a function is defined, but not a class. So I'm going to get rid of those and save it again. You'll see cannot read property name of No, well, here's name, and it's seeing that this state is no. So as the instructions say I'm going to create a constructor method. And the first thing we should always do in a constructor method is add super. I'm going to initialize my state is an object. And I can see from the render method that that object should have a name property and an age property. So inside this object, I will add a name property and we'll say le age of saving again, now have a functioning component. There's no errors in the console and Sally and 13 years old are showing Have correctly over in the browser. Now one thing we've been talking a lot about at visco, which is the coding boot camp that I work for, is how important repetition is. And I know I've tried to get you to write this code over and over again. But I'd highly recommend that if any part of this was confusing at all, that you go back to the beginning of the screencast. And you pause the video immediately, and you try to fix it yourself again. And then after you do that, do it again, go back to the beginning, try and fix it again from scratch, and do it again, and do that as many times as it takes for the syntax to kind of be second nature for you. Doing that is going to do a number of things. But mainly, it's going to make it so that in the future, you don't get so hung up on figuring out and remembering the syntax as much as figuring out how to solve specific problems. So feel free to stop here, go back, redo this as many times as is necessary. And then when you're ready, feel free to move on. Okay, so I actually decided at the last second that I wanted to add another practice in here. And this practice is going to do two things, it's going to give you the chance to practice converting a functional stateless component to a class based component. Again, it's also going to give you a chance to add state to a component. And then I have kind of an additional challenge here, that covers something we haven't quite talked about yet, which is conditional rendering. But I want you to just give it a shot, use your intuition. And if you're wanting to do any kind of Google search, you're welcome to do that, too. And we are going to cover this soon. But I figured this would be a good chance for you to exercise your problem solving skills. So given the component here, change it to a stateful class based component, give the state a property called is logged in, which should be a Boolean, either true or false. And that's the first part. If you can do that, that's awesome. Then I want you to give it a shot at rendering the word in if the state is logged in is true, or the word out if it's false. So go ahead give this a try. Okay, so the first part, we should be able to do relatively easily, we need to change our functional component to a class based component. So I will add class here, going to get rid of my parentheses, add extends react dot component, I return needs to be returning inside of a method of some sort. So I'm going to add my render method, my return inside game, then if I'm going to add state to it, I will need to make sure I have a constructor which calls super. I add a property called state on this, this that state equals an object. We know that object needs to have a property called is plugged in. We will initialize it as true. You were able to get to this part, that's awesome, great job. The next thing is making it so that it renders the word in here if is logged in is true or out if it's not. And again, we're going to cover this when we talk about conditional rendering in a few lessons. But one way that we may decide to do this is to maintain a variable that looks at the current version of is logged in, and has a string that represents the word that should be displayed here. That display logic, as I've mentioned, I like to do inside my render method but above my return. And so I'm going to maybe initialize a variable called Word display. And do a simple if else statement that says if this start state that is logged in, is true. We're display should be the word in otherwise, or display should be out. Finally down here, instead of having both in and out here, I'll put curly braces because I'm interpreting JavaScript inside of my JSX. I will simply put word display, I noticed that word display is just a local variable to the render method, I don't need to put this dot State DOT word display or this dot props that were displayed because it is neither a prop nor a piece of state. Now when I refresh this, I get you're currently logged in. And that happens because is logged in is true. And if I change this to false, tell me I'm logged out. We're gonna see more concise ways to actually do this is a totally legitimate way. And in fact, I believe this is the way that the React docs tell you to do this. One thing I like to do if my variable is clearly named to be a Boolean, like is logged in, I'm just going to get rid of my triple equals true because that will already either be true or false. And that's it. So once again, please go back, try to redo this yourself. See if you can do it from scratch, even delete the entire file and see if you can write everything from scratch once again. Repetition is really going to help you get the syntax down muscle memory so that you can focus more on problem solving. Once you feel pretty good about this, let's go forward. We are at part four of our to do app. So this should be a pretty short one. Until now all we've done this loaded our to dues data into our app component by importing it and then mapping directly over the thing that we imported. However, eventually, we're going to want to modify this data, which means that it's going to have to live in state of this component. So all you need to do for this challenge is to make it essentially so that two dues data lives in the state of this app component. Pause the lesson here and give that a try. Okay, like I said, to dues data is just imported. And we originally were mapping directly over the thing that we imported. But let's put this on state. for that to work, I need this to be a class based component. That will extend react component. parentheses, we need a constructor always calls super first. And we'll start some state, which is an object and we'll have maybe just to use is an array, we'll start as an empty array. And that in just a second, right now, this map and the return need to happen inside of a render method, we'll just move that in there. And then like the challenge says, We essentially want to load the imported two dues data into state, which essentially just means that instead of an empty array here, we will put to dues data, then the last thing is to change to dues data to this dot State DOT two dues, because that's where the two dues data is living now. I believe if we refresh, we're working great. The warning that we receive is from the previous lesson where we had the checked property, and we don't have an on change. But we're going to get to that later when we talk about forms. For now, this is heading in a good direction. We will revisit this in a little bit. But until then, let's learn some more react. Before we can seriously talk about changing state using the set state method, we're going to need to have an understanding of events in react and handling events. event handling is essentially allowing the user to interact with your web page and do something specific when a certain event like a click or hover happens. And handling events in react is actually quite simple. You might be familiar with regular HTML is the ability to add something like on click equals and then you execute a function like my function. React is very similar to this with just a few small changes. The first thing is that all of our event handlers are going to be the JavaScript version, which has a camel case convention on click will have a capital C, on mouse over will have a capital M and a capital O and so forth. And the reason it does this is because it uses the same convention that regular JavaScript as if you were to add these events to elements on the page. So let's make it so our button can do something when a click of the button happens using onClick. And then the only other major change we're going to do is that instead of passing an executed function as a string, we're going to pass a function directly into a set of curly braces. I don't have another function pre written so I could just do an anonymous function right here. And maybe console log something. We can shorten this up quite a bit by using yes sixes arrow function syntax. Or as always, you could write a separate function somewhere. And put the reference to the name of that function right here. Any of those should work just fine. I'm going to save this and click the button. And you'll see that we get a console log of I was clicked. If we open the console, we will see that more obviously. As a quick reference, I want you to take a look at the following react documentation. This is a full list of the supported events in react. The reason I want you to look at this is because I want you to pause this lesson and add the functionality so that when the mouse hovers over the image, another thing gets console log. So pause lesson here, feel free to go to that URL and see if you can find the event that we'll need to use so that when we move our mouse over the image, it will execute a function And then go ahead and add that to your image element. Okay, so I think there might be a couple different mouse events that we could use. But the one that I'm going to use is the on mouse over. And when that happens, we will run the following function. And we will just console log, Hubbard save this. And I'll open the console and try hovering over Bill Murray. Like that. Every time our mouse goes over the image, it runs our function to handling events is going to be really helpful. Obviously, console logging stuff is not all that exciting. But we're gonna see how events mixed with the changing of state will allow our application to start becoming really robust and actually really awesome. Feel free to add a few elements here, see if you can do some of the other events that are found at this URL. And then we'll talk about setting state in the next lesson. So we another really quick update to our to do app, we just learned about how to add event handlers to elements. And you may remember that we used to have a warning, saying that we have checked prop on our input. But we don't have any way to change that. So it says it will render a read only field. So your challenge is to get rid of this warning by simply adding an on change to our input. And for now it can just console log something. So pause now and give that a try. I'm going to close this console for some extra room. And this simply entails adding an on change that is equal to and then I could write this function somewhere else. Or I'll just do an anonymous inline function that until logs. While I'm at it, I'll put these on their own lines. And now when I click these, it doesn't change the checkbox. But our warning is gone. And my onchange is firing correctly. So we're going to learn about how to make these events actually change our state. And then we'll be revisiting this app again soon. Okay, man, every new lesson just feels so exciting because you're learning something that's like really bringing you close to making awesome web applications with react. In this lesson, we're talking about changing state, okay, having state in your component is great. But if you can only initialize it to a specific value and can't change it, then frankly, it's kind of pointless to be there. And it's really no better than just hard coding it into your code. So let's learn about changing state. And what we have here is a component that is a class based component. Because we're using state, we have our constructor, we're calling super, as always, we're initializing state with a property called count, and setting that equal to zero. And then in our render, we simply have an h1 that displays the current count. And we have a button with the word change in it. I've added a little bit of CSS, so it wasn't quite so ugly. And now we're going to learn about how when I click this button, using the event handlers that we just learned about how can I change the state to be something different, so that clicking the button will actually change the value that gets displayed here? Well, let's start by adding an event handler, which should be reviewed from the last lesson. So go ahead and see if you can make it so that when you click a button, maybe something gets logged to the console. For now. Remember, to add an event handler I'm going to do on click in this case, because I want it to handle the click event equals and then inside of curly braces, I'm going to put some kind of JavaScript function. Now I could put an inline function right here, which I don't particularly like. So instead, what I'm going to do is I'm now going to create my own method constructor is a method that's built in to classes in JavaScript. Render is a reserved method name for react. But in between here, I can put as many methods as I want. One strong convention that people tend to use is to have a method called handle click when you're handling a click event. So I'll finish the stubbed out version of this and then down here, instead of an inline anonymous function, I'll have it run handle click. Now let's see if I can get a console log to show up. Let's save that. And this is a common mistake. When the method is part of my class, I need to reference it on the this object. So this dot handle click to begin, click my button and says I'm working. Okay, that worked. Well, that's pretty boring. So let's make it so that when I click it, actually changes my state and increases my count. Now one thing that would be really tempting to do is to try and modify state directly, as in typing this dot State DOT count equals one, or saying something like plus plus, or this is something that you will actually never do, you're never going to want to directly modify the original version of state. You might remember in the introduction to state, I talked about how state is kind of like the clothing that you wear. Well, when it comes time to change your clothing, you don't modify your clothing, right, you don't paint your clothing a different color, you don't cut a T shirt, and so on buttons, so that you can have a button up shirt instead. But what you do is you completely replace your old clothes with your new clothes, or rather the clothes you were wearing with the clothes that you want to wear. And this is essentially the same thing we're going to do with state. You also might remember that I talked about some kind of goodies that we're going to get from react component. And that's the reason we're extending react component. Well, one of the things that we're going to get is a method called set state. And anytime you want to change state, you're going to use this method set state. And it's a method or function, so I'm going to call it and there's actually two different things that you can pass to set state. Let's first look at the easier one to understand. What I can pass to set state is a new version of state, while state is just an object as we see up here. So I can pass to set state an object, and I can say, the count. Now, one might have already figured out what's going to be the problem with this. But let's see if this works. So once again, my button has an unclick, that will run this dot handle click when it's click, this dot handle click uses the set state method that comes from react component. And it provides a new version of state, okay, like your new t shirt that you're putting on. And it says now the count should be one, I'll click the button. And we run into a very common error says, cannot read property set state of undefined. This brings us into a realm that's actually kind of hotly debated with react. And I'm going to give you a very simple solution to this, that may not make a whole lot of sense at first. Essentially, anytime you create a class method that you want to use set state on, you're going to need to bind this method to your own class. If you're not really familiar with binding, I'm not too worried about that right now, just know that anytime you write a method that uses a set state, you'll want to bind it and the way you bind it is inside of your constructor, we're going to say this dot handle click equals this dot handle click dot bind this, like I said, this is probably pretty confusing if you're not familiar with binding. But essentially, what it does is it makes sure that the handle click method is bound to the context of this as it exists within this class. I'm going to refresh this and click my Change button again. And awesome. Look, our state changed from zero to one. Now this is where the problem that you may have figured out already comes into play. If I click Change, again, it looks like nothing's happening. But in fact, it's actually doing what I told it to do, right? When I click the Change button, it sets the state to the count. And the count is now one. Well, it was already one and I'm changing it to one. So it's actually not changing. Therefore, I can't see it changing on the display. So that brings us to the second way that I could use set state, if I don't care about what the previous version of state was. passing in an object is a really nice simple way to provide a new state. But a lot of times we actually do care what the previous state used to be. In this case, we want to know what the previous state was. And we want to add one to it. So anytime I need to know what the previous state was, I can also pass a function to set state that function is going to receive in its parameter, the previous version of state. This is really important. And it might be tempting to think that you can just access the previous version of state using this dot state, which sometimes will work but oftentimes will not. And so it's really important to always pass previous state or whatever variable name, you want to give this to your function. Now because it's an arrow function that just has one parameter, I can get rid of my parentheses around that parameter. And what my function should return is a new version of state. Okay, so before we provided just a new version of state directly as an object literal, but this time we're providing a function that returns that object literal. The benefit of doing it this way is we have access to the previous version of state. So in my function, I'm going to return an object, that object should have a count property, so that I don't break my this dot state count down here. And I want you to take a second and see if you can figure out what the value of that property should be. So positive lesson and give that a try. So remember, previous state represents the old version of state. And the old version of state is an object. So I can access the previous version of state by saying proof state. But that's the whole object, I just want to count property. And I'm not going to say plus plus, because that's directly modifying the old version of state. But instead, I'm going to just add one to it, we computer will do is it will figure out what the count used to be, they will add one to that. And it will set that as the new count property of my new state object that's getting returned from this function. Now, when I save this, and refresh, and I click Change, I can click it multiple times. And it will continue to increase the number that's displayed on the screen. And this is really cool. I mean, it seems kind of lame, because all I'm doing is increasing a number. But this opens up so many possibilities. And you're going to see from here on just how much we're going to be able to do with react. Now that we have the ability to have components, maintain their own data and state and actually change their own data using set state. I mentioned before that you are allowed to pass state down to other components as props, for example, having a child component of some kind that receives, you know, your account, your state. And if we were to define this child component, we would see that it's receiving a prop called count, the value of which is the current state of its parent component app. Well, what react will do is anytime this value changes, anytime it sees that there's a child component that's receiving a value that changes, it will rerender. This component, it will run that components render method, once again, or if this is a functional component, it will just run that function again, so that that component can reflect the new version of props that it's receiving. And in this case, it will change every time the state count changes on the app component, which as we just made it do happens every time we click the Change button. So right now child component isn't actually defined. So I'm going to get rid of that before I get a syntax here. And let's do a quick recap of everything we did. We have our h1 displaying our state, which just has a count property, we initialize that count property to zero, we added an event handler to our button that runs a method called handle click handle click is a method defined on this class. And because handle click is using the set state method that comes from the parent class react component, we need to make sure to bind it, which we can do inside of our constructor. And once it's bound, we can run set state, which can either take an object literal, which is the new version of state that we want to pass to it. Or if we care about what the previous state used to be, we'll pass it a function that takes the previous state as a parameter. And that function should return the object literal that represents the new version of state. Now I just rattled off a lot of jargony stuff. So I want you to spend some time with this state is going to be extremely important for you to understand. And we're going to be using it pretty much through the rest of the course, though spend some serious time with this, I'd highly recommend as I have in the past tried deleting this entirely writing it from scratch. And we're probably a good stepping stone to that is rewinding this video to the beginning and seeing if you can add all of this stuff again, you're also welcome to try adding different events that may also change state in play with the state that's getting changed, maybe you want it to increase by more than one or something like that, I don't know. One really good exercise is to have a button that will double the number and another button that will have the number. So there's plenty of things that you can try to do with this. So use your creativity and your imagination, see what you can come up with. But spend some real time with this and play with it. Then in the next lesson, we're going to get a chance to practice this. Okay, we've come to a pretty beefy part of our to do app, we're going to make it so that when we click the checkbox, it actually makes a change to our state. And this actually is a little more involved than it may sound but it's really not too bad. up near the top. I've written down what your challenge is and This will help you accomplish this task. And I've also stubbed out the handle change method and written some pseudocode inside here. So you have some hints, essentially to help you accomplish this. And just so there aren't any weird bugs, I've also bound this in the constructor for you. So your challenge is going to be to take this stubbed out, handle change and actually implement it so that when somebody clicks the checkbox, it makes a change to your state and updates the item that they checked so that the completed property flips from either true to false or false to true. And then you're going to make sure to pass the handle change method down to your to do item. And then over in your to do item, you'll need to implement the on change with the new method that you've passed to it. So I go back here to app. Pause now and go ahead and get started. Okay, so I might do this a little bit out of order. But I think the very first thing I'm going to do in my handle change is just to console log something. Say we changed. And since we're getting the ID, let me just go ahead and add the ID to my console logs, so I can make sure that that's working. And then I think what I'll do is hook up parts two, or complete parts two, and three, and just see if I can get this console log to happen. And then we'll go ahead and add this logic. And so part two says that I need to pass the method down to the to do item components. So right here, I have my to do item, which gets a key and the item. And let's go ahead and pass down a handle change was passed down this dot handle change. And then over into do item, it's now receiving a prop called handle change. So props that handle change. And notice that it says it's going to be taking the ID as a parameter. However, we know that events when they fire, they actually receive an event property. And so it won't be good enough to just say props dot handle change, because because this is not going to receive an ID property, it's going to receive the event object instead. And so what I can do is say, Well, this is the function that's receiving the event here. And what it does is it calls props dot handle change. And now I can pass whatever properties I want to this, I want to say props.item.id. Since I'm not actually using this event, in this case, I'm just going to get rid of that, it'll just be an empty function that calls props dot handle change and passes the ID to it. So let me update my page. And we'll open the console and just see if my console is working. Okay, change to change three, one, notice that it's matching up with the ID of the item that I'm clicking. So this is ID of one ID of two ID of three. And if I click the clean Gecko tank number three, it says Edit change. Number three, awesome. So we've made some good headway there by finishing parts two and three. But let's get to actually updating our state. This is the trickier part. The part that's tricky about this is that we need to deal with the entire array, because we're saving an array in our state. And we never want to modify state directly, it won't be as easy as just looping through this array, finding the item with this ID, and then flipping it because that will actually modify the existing state. But instead, we can essentially do that same thing. And just make sure that we return a brand new array where almost all of the items are exactly as they used to be except one item has changed its completed property from true to false or false to true. And a great way to do that is to use the dot map method, because this returns a brand new array. And so what I can do is I'm going to start my set state. Because I do care what I have in my previous state, we're going to use the function way of updating state and receive my previous state. And then what I'll do is I will use map to loop over my proof state.to dues array and look for a to do with the ID that is given here in the method. And so I'll create a variable that says maybe updated to dues. That's going to be my old version of to dues. And sorry, this shouldn't be this that state but rather create State DOT map. And we're going to look at each one of the two dues in this array. We'll run this function and we're going to say if print to do that we're looking at has an ID that's equal to the ID we received from our parameter up here. Then we know this is the to do item that we want to flip the completed property of So I can say the to do dot completed, should equal the opposite of whatever it currently is. And whether or not we actually did that flipping of the completed property, we're going to return that to do that makes it so that it puts this to do item in our new array in the same index have the original array. And all of this is my map. And so what my set state needs to do is actually return a new version of state, which is just an object. And our state is an object with a to dues property. So I'll say to dues now be the updated version of to dues, the array that we just created. Let me clean this up a little bit, get rid of these comments, this, and let's try flipping these awesome. And it looks like everything is working the way it should. So as a recap, we are looking at our previous state, and we're creating a new array that almost perfectly mirrors what it used to be except one of the items, which has the same ID as this function received from the on change handler that is happening when we click these checkboxes. That one item is changing from true to false or false to true. And then this brand new array is essentially replacing the old array that we had up here, and it gets rendered to the page. Then we're taking this handle change method, and we're passing it down to every one of the to do items that we create in our map down here. And those to do items are receiving the handle change. And anytime it's checkbox gets checked, it calls on change. And that has an anonymous function, which then calls handle change and passes this items ID so that we can correctly identify which in the array we need to flip. And as a reminder, the reason the checkbox is actually showing up or not showing up is because of this checked property checked determines whether the checkbox should be checked or not. And it says if the item is completed, then it should be checked. And if the item is not completed, and it shouldn't be checked. And essentially what we have now is a working to do app, we're going to do some small tweaks to it. But great job. Hopefully everything that we've covered so far makes sense. And we'll be revisiting this soon to talk a little bit more about styling, but feel free to celebrate a little bit and whenever you're ready, we'll go forward. One of the really nice things that we've mentioned about react is how we get to essentially just write vanilla JavaScript. And react is taking care of a lot of stuff behind the scenes, will with the stuff that's going on behind the scenes, every single component that we create, is actually going to go through a series of phases or milestones during its time being alive in your react application. Often this is analogous to a human being who is born has life milestones, and dies. Similarly, every react component will undergo a series of events when it's being rendered and updated. Now I've divided lifecycle methods into two parts, because the React team has just recently deprecated or gotten rid of three of the original lifecycle methods that we're about to talk about. And instead of going through every single one of these individually, I'm actually mostly going to just talk about the ones that are the most important to you right now as you're learning react. And then as you continue to learn, you can play with some of these other ones as well. For for reference, I'm going to post here a URL to a site that does a really good job explaining the lifecycle methods that were a part of react before version 16.3. Check out those changes that happened in 16.3, you can check out this website, which is the official blog of the React team. With that being said, let's start talking about the lifecycle methods that were most likely or most commonly going to use. The first is one that you're actually already familiar with. And it's a little bit of a gray area, because this is oftentimes not listed as a lifecycle method. But the render method, right here is something that we've been using, as we've talked about class based components. And one analogy that I like to use is that it's like getting dressed for the day. Its job is to determine exactly what gets rendered to the screen, which in turn is how the component is displayed to the world. Now the render method can be called many times, anytime react determines that something changes like state or props, which might affect how the component is supposed to display, React may run the render method once again. Similarly, you may have had days where you've decided to change your clothes and look a little bit different to the world based upon what you're about to do. So hopefully by now that one's pretty straightforward. The next lifecycle method that I want to talk about is called component did mount and these lifecycle methods are defined just like other methods inside of your class. Here. So I might say component did Mount camelcase, like this component did mount is a lifecycle method that's essentially like saying you were just born the component, this component did just mount to the screen, the very first time the component shows up, React will run the component did mount method. This method will only run once while the component is showing up on the screen. Things like a rerender, which changes the way that the component is displayed does not rerun component did mount. And that's because the component doesn't actually unmount and remount. Most common use case for component did mount is to do things like an API call when you need to get data from some kind of external source. For example, maybe this component is actually a to do list. And I need to get the list of to dues from some kind of server or database. Before I'm able to accurately display my to do list. As soon as the component finishes mounting, I can get the data I need to correctly display. We're going to see this in a future lesson. But just know that that's one of the most common use cases for component did mount. The next lifecycle method I want to talk about right now is called component will receive props component will receive props is kind of like when someone gives you a gift. This component could be receiving props from a parent component. And every time this component is receiving props, it will run this component will receive props method, and component will receive props will not only run the very first time the component is mounted. But it will also run every single time a parent component decides to hand props to a child component. For example, if a parent component decides to change the props that it's passing down to this component, one thing we can do inside of component will receive props is check to see if the new incoming props are even different at all from the existing props. Oftentimes, we will then say if they are not different, just don't do anything. But if they are different, maybe I have some kind of calculation to run or state to set or something like that. To receive those new incoming props component will receive props receives a parameter called next props. And it's just a parameter so you can call it whatever you want. But oftentimes, we put next props. And sometimes you'll see something like an if statement that says if next props dot whatever property you're looking at, does not equal the existing props. Then do something important here. So there's some good use cases for component will receive props. However, as I mentioned, this is actually one of the lifecycle methods that's going to be deprecated, or actually is deprecated. Starting in 16.3. Until react 17 comes out they've renamed this with all caps unsafe underscore component will receive props. So if you really need to use this, you can still do so. But once react 17 comes out this is going to be completely removed in component will receive props will no longer mean anything special. So just be aware of that. It's a good lifecycle method to understand. If you're looking at legacy code. For going forward, this won't be a part of react anymore. Another cool lifecycle method is called should component update. And in our person analogy, I like to think of this as making a decision as to whether you need to change your clothes or not. Behind the Scenes if react has any kind of question at all as to whether a component needs to rerender it will always choose to rerender it just in case without any logic specific to your applications needs behind that decision. I think I said in the past that sometimes react will rerender a component even if nothing about that component has changed. Well, that can become kind of an expensive or rather slow operation. If you let that happen to every single component in a large application. Should component update gives us the developer a chance to optimize our app, we can implement some logic here that allows the component to determine whether or not it's important for it to even think about updating. To help make that decision. This is going to receive the incoming props and the incoming state, which we'll call next props in next state. And in the body of the function we need to either return true if we do want it to update or we can return false if we don't want it to returning false Should component update is what will make your application more performant. But you'll just want to make sure that you actually don't want this component to update. Otherwise, it could really introduce some weird and hard to debug bugs into your code. Less lifecycle method we'll talk about right now is component will unmount. Just like in life, all good things come to an end and your component will eventually unmount from the screen or disappear altogether from the screen. The main use case for component will unmount is to do some kind of cleanup or tear down of anything that you've set up, it could potentially lead to clutter in the DOM or in your application. One of the most common use cases for this is if you in component did mount set up like an event listener, for example, you wanted to run some code every time somebody scrolled on the screen, this would be a chance to remove the event listener, that that's just one example. In general, it's a place to tear down or clean up your code before your component disappears. I'm going to move to this after that, so that it's obvious. It's just an example. And that's actually all the lifecycle methods, we're going to cover in part one here, there are a number of other ones that are important to understand. But for now, they're more advanced than what we're planning on getting into in this course. And so I'd recommend if you're interested in learning more about them, going up to this link up here. Now this link was written before 16.3 was announced. So also take a look at the second link here, which will talk about the three lifecycle methods that have been deprecated. As well as the two new lifecycle methods that are introduced in their place, which we're going to cover in the next lesson. You had a chance to go over this link here, which is the announcement of react 16.3. And the changes that came with it, you will have read about the three lifecycle methods that have been deprecated. One we talked about already, this component will receive props, that's going away. A couple more lifecycle methods that are also being removed our component will mount I'm just going to comment that out right away, as well as component will update shall also comment out those three component will mount component will receive props and component will update are being deprecated or removed from react. In its place, we're receiving two new lifecycle methods that we can use. One is called get derived state from props. Now there's one change about get derived state from props. And that's that it's a static method. So we have to include the word static beforehand, get derive state from props receives props in state and should return the new updated state based upon the props. And I don't plan to go too much more into this. And the reason is because the React team has actually written a blog about how you probably don't need derived state. A lot of times this has been misused and caused weird bugs or performance issues in people's applications, when in reality, there's actually a better way to go about what they were trying to do. The idea behind get derive state from props is for like it says in the blog, the rare cases when your component needs to take incoming props it's receiving from its parent, and set its own state based upon those props. But again, the React team kind of discourages the use of this method. And so I'm not going to talk too much about it. And we probably won't be using it in this course. However, if you're interested in learning more about it, here's a link to the docs on get derive state from props. And the last lifecycle method, the new one that's being introduced is called get snapshot before update. You can think of get snapshot before update as a lifecycle method that allows you to sort of create a backup of the current way things are. When I say backup really all you'll be saving is some kind of data of some sort, probably an object with multiple points of data inside of it. And that object would be called the snapshot because it's like a snapshot of the way your application is right now. Again, the React team says that it's not a super common lifecycle method that you'll end up using. And so we're not going to talk too much more about it. But once again, here's the documentation if you're interested in learning more about it. So that's essentially it for lifecycle methods for now, as you get more and more advanced in the applications that you're building with react, you'll definitely want to become pretty familiar with these lifecycle methods. For this course, we'll pretty much plan on sticking to component did mount and render. And if we end up meeting another one, then I'll make sure to talk more about it at that time. Feel free to read through some of these articles. And when you're ready, let's move on. You know, one of the hardest things about teaching react is that you learn a number of tools that can be used in a variety of ways. But you aren't necessarily constrained to just one way of using a tool. The other thing is react uses so much vanilla JavaScript that a lot of what you can do with react is done a number of different ways, using just vanilla JavaScript. Conditional rendering is where this kind of comes into full view. So I just wanted to start with that caveat, before we get into this, because I don't want anyone to think that the way I'm about to show you conditional rendering is the only way it can be done, I'm going to cover a number of use cases, but there's for sure going to be other ways to use it that are totally legitimate. So I've done here is I've added a class based component, it has state with a property called is loading that is either true or false. This is something that's oftentimes used when you're making a call to an API. And in the meantime, you want something to show up, perhaps that call to the API will take three or four seconds. And you don't want the user to think that your website has crashed. And so you'll maintain something in state that says, hold on just a second we're loading right now. And conditional rendering will be used to actually display something on the screen that tells the user that you're currently loading something in the background. We'll talk about component did mount in a second. But now in the render, you'll see that we are rendering a component called conditional, which I'm importing up above, and I'm passing a prop to it called is loading, which is the current version of state. And then over and conditional, we're going to be adding what gets displayed on the screen here for now. But before we get there, I want to be clear of what's happening with our component did mount. Remember that component did mount is a chance for us to run some code right after the component, our app component in this case mounts on the screen for the very first time. And what I'm doing here is kind of faking an API call, I've set a timeout, which will wait one and a half seconds before running the code that's in the function I provide it. And what's happening in that function is I'm changing the state. So that loading is false. Think of this as a fake way to pretend that we're making a call to an API that takes 1500 milliseconds, or one and a half seconds to come back with data. At which point we're saying we are no longer loading because we finished loading the data from the API. And once we talk about using fetch to get data in a future lesson, we're actually going to be doing this for real, but I just wanted to make sure this wasn't confusing before we move on. And actually, this is a good time to talk about the lifecycle methods once again, because once set state changes is loading to false, our component or conditional component, is now receiving a different Prop, because it's receiving is loading of true when it first loads. And then when state changes and is loading as false. It's receiving a new Prop, or rather, it's receiving the same is loading prop with a different value. And so what will happen is when the state changes, our render method will run again, because something has changed, which means the conditional component will also rerender. Now conditional is just a functional component, which means the function will just run again. And whatever we're returning from here could potentially change because props are going to be changing. When we get to the end of this lesson, I'll highly encourage you to play with it because this is a really important topic. Okay, so my conditional component is receiving a prop called is loading. And before we get anywhere else, let's see if our set state is working. I'm going to fix the syntax error by actually having something render here. And I'm going to console log props.is loading. Notice that and I'll refresh this again, notice that immediately, what happens is it shows up as true. And then 1500 milliseconds, or one and a half seconds later, it re console logs false. And that's because over an app, after 1500 milliseconds, it changes state to false, and that's when conditional re renders or runs again, and the props that it's receiving changes. So first, it logs true and then it locks false. Well, let's talk about conditional rendering. Essentially, all that means is that I'm going to load something on the screen if a condition is true. In this case, instead of an h1 that says temp. What I might do is say if upstart is loading is true, then what I want this component to return is an h1 that says loading. But if props that is loading is not true or in other words, I can put that inside of an else once you to return and have different text. And notice what happened when I refreshed, I'll do it again. At first it says loading. And then it changes to the different h1 that we have here that says some cool stuff about conditional rendering. The app component starts with is loading is true, and therefore renders a conditional component where is loading prop is true. And then the conditional component checks if props that is loading is true. And first, it loads this h1 or renders this h1, then when props.is loading changes to false because the state of the parent component changed to false, the conditional component that we have here runs once again and it notices that prompts that is loading is no longer true. And therefore what it returns is this h1 instead, this is just using plain JavaScript. And if statements. One thing that I personally prefer, because I'm returning from my function in my if statement is I don't actually need my else here. This will simplify my code a little bit. And this return will only run if my if statement does not evaluate to true. And therefore it's kind of an implied else. Well, this is a perfect time to talk about a common way to do this kind of if else rendering using something called a ternary. operator. If you're not familiar with turn Aires, this is not even a new feature in iOS six, this is something that's been around for a while. And it's very commonly used in react applications. When it comes to conditional rendering. Essentially, the way it works is you provide a condition and then a question mark, you provide a statement if it's true, followed by a colon, and then a statement. If it's false, in our case, our condition is, is props.is loading equal to true. And then I like to read it like an English sentence with the question mark props that is loading is true. If so then I want this h1 otherwise, is what my colon means I want this h1. Well, I'm going to have a syntax error here. And that's because when we're doing this inside of a component, we have to do this inside of our return. So I'm going to delete what we have here, I'll delete my comment, I'll add a return. put this inside of my return. Now, technically, this works. If I refresh, you'll see it shows loading, and then some cool stuff about conditional rendering. But this looks really strange to me as because we're not immediately returning a parent JSX element, which we usually want to do. So I'm going to wrap this whole thing in a div. And then when I refresh, you're gonna see that there's another error we have to fix. Notice that it's literally interpreting as text, the stuff that I shoved inside the div. So if I want this to be interpreted as JavaScript, I need to wrap it in curly braces. And now when I refresh, we're back to working. What's nice about this is that when I inevitably have other things on my page, like some kind of navbar, which I'll represent with another h1 here, maybe a footer, I can still be rendering conditionally parts of my page. Another simplification that I can make here is because is loading is already a Boolean, I technically don't need the triple equals true, I can get rid of that. And this will test the truthiness of props, that is loading, I'll refresh and you'll see it works the same. There we go. Now, I put in this navbar, and footer as demonstration purposes, but I want to remind you, there's so many different ways that you can structure this, that it's really hard to teach all of them. For example, usually you won't have your navbar and your footer inside of a child component of your app, these would likely go in your app component or somewhere similar. That's a parent of this little conditional component. And another thing is I've put this conditional rendering here inside of the conditional component, just so we could see it all in one place. But the truth is, our app component is probably the one that should be in charge of the conditional rendering. The reason is whatever we put in our conditional component should probably just be able to display when it's told to display it. If our app is in charge of determining if something is loading, then it's probably the one that should determine what should be rendered down here in the render method. So the way that I would actually probably structure this in this specific case, when we're talking about having a loading thing pop up on the page is right here, I would put my conditional this.state.is loading, question mark, and if so, display our loading word. But otherwise, display our component. Which means this conditional component wouldn't even need a prop called is loading. In this particular case, and over in conditional j s, I would just display the stuff that I wanted it to display. And we see that it's still working this way. Obviously, the navbar and the footer are gone. But the point is, this function should only really know what to do when it's supposed to display. And our app component being the one that's maintaining whether something is loading or not, can determine in its render method, which should display here. In part two of conditional rendering, we're going to see some other ways that this can work. But before doing that, I'd really encourage you especially since this is the first time we're using component did mount in a real way to play with this code, spend some time playing with the different ways we've already talked about here with conditional rendering. And once you're ready, let's move on to part two. There's actually only one extra little part with conditional rendering that I'd like to cover right now. And that has to do with using the logical AND operator, you may be used to using the logical AND operator to refer to something on the left and something on the right as billions in determining whether the entire condition should be considered true or false. So for example, true and false would be false. Because with the AND operator, both sides need to evaluate to something truthy in order for the whole thing to be true. Well, in reality, under the hood, what JavaScript is doing is with the AND operator, it's determining the truthiness of the thing on the left. And if the thing on the left is truthy, it just immediately returns the thing on the right, which means when it's true and false, it returns false, because that's the thing on the right. If the thing on the left is falsie, then it just returns false right from the beginning. And so the AND operator can be a way to conditionally render something if a condition is true, or just render nothing if it's false. So with this little example that I've created, I've added some unread messages in state as an array of strings. And you can see here it says you have to unread messages because the length of the race too. But a lot of times, you wouldn't necessarily want it to say you have zero unread messages, you may just want it to instead not have any h2 there at all. Okay, using the ternary that we learned in the last lesson, I could say something like wrap this whole thing in curly braces, and then say, essentially, if this dot state unread messages that length greater than zero, then render this array, but otherwise render nothing. So I could just say no, let me clean this up a little bit. It's a little easier to read. But I can simplify this a little bit by getting rid of my ternary. And my No, and just saying, check the truthiness of this dot State DOT unread messages dot length is greater than zero. And so in other words, if that's true, and render this part, however, if it's false, it will just render nothing. And we can see on our screen, there's nothing there. Once I add some unread messages back shows up. So the AND operator isn't strictly necessary, because you could most of the time, just use the ternary where one of the results is no, but this can really kind of simplify it just a little bit. And you may be seeing this every now and then in the code that you look at with other people's react code. So that's pretty much it with conditional rendering. Let's go ahead and move on. Okay, let's practice some conditional rendering. So here your challenge is given a stateless functional component, just this app component down here, I want you to follow whatever steps it takes to add some state to it. I want you to then have that state keep track of whether the user is logged in or logged out. Then you should have a button that will change That state. In other words, a button that logs them out if they're logged in or logged them in if they're logged out. And there should be some text on the page that says whether they're logged in or whether they're logged out. If you want an extra challenge, make it so that the button will actually display, log in if they're not logged in and log out if they are logged in. So as usual, give us your very best shot. And we'll give you a few hints if you need them in just a few seconds. But in the meantime, pause the video and try it out. Okay, really quick, some additional hints that you might need, because this is actually putting together quite a few of the lessons that we've talked about recently. So one thing is in order to add state, you'll need this to be a class based component. And part of that is you'll need to add a constructor method to that class based component for keeping track of whether the user is logged in or not, you could use a Boolean is like in the Boolean either true or false. Adding a button that logs the user out will require an event listener, which would be your unclick. Probably, and then both the extra challenge and challenge part number four would require some conditional rendering. So if you're feeling a little bit stuck, feel free to pause it again and try it out. Now that you have some hints as to how to complete each step. And we'll go through this together in just a few seconds. Okay, let's try this out. So we need to make our component into a class based component because well, actually, for a couple of reasons. One is we want to keep track of state, which means we are required to have a class based component. But we're also going to be writing an event listener. And technically, I could just write another function that handles that. But personally, I prefer to have a class based component and put my event handlers inside of the class itself. Okay, so to change this to a class based component, we need to change function to class, it rid of our parentheses, will extends react component return needs to be inside of a render method. We'll move it there. And to add state to it, we know we need a constructor method. Always call super First, add a property called this dot state which is an object we'll initialize it with is logged in of true or actually the start false. Okay, so that is steps number one and two. Now we need to add a button that will change is logged in to true or false. And so there's a couple things we can do. One is inside this div, let's get rid of that and we'll add a button. And for now, I'll just say log in. And we'll play with this a little bit later with the extra challenge. Now I need to add an event listener to this so that the button being clicked actually does something. So add an unclick equals a call this dot handle click. So anytime This button is clicked, it will call this classes method called handle click well that doesn't exist yet. So let's create it. Right here, I'll add a handle click. And I'm probably going to run into a binding error here. So I might as well bind this now. Let's say this dot handle click equals this I have a quick dot bind this. Before I get too far, sometimes I'd like to have little sanity checks along the way. I'm just going to put a console log here. Now we can check if I click the button if it will console lock I'm working. Refresh the page and I get this login button. And when I click it, okay, our console log is working just fine. And that's awesome. Now the thing I want handle click to do is change false to true or true to false depending on which one it currently is. And anytime I'm going to change state, I need to run this dot set state. And remember, there's two different ways that I can set state two different things I can provide to the set state method. Take a second to think of what those two things are and which one is going to be most useful in this case. So I can either provide set state, just a brand new version of state, and it will smartly combine and replace the current version of state. But since in this case, I actually need to know whether it currently is logged in. Rather, if logged in is false or true, I need to instead provide a function that has the previous state asked to it so that I can use that previous state to determine what the new state should be. My function is going to return the object literal Where is logged in, the value of is logged in is the opposite of whatever it used to be. This is a really concise way to change a Boolean from false to true or true to false. Technically, you could also do an if else statement that says if proof state.is logged in is true, then return an object Where is logged in as false. Else return an object Where is logged in is true. But this way, I just say Just give me the opposite of whatever it used to be. Now, we don't currently have a really great way to see what the current version of state.is logged in is. But I can do this extra challenge right now and make the button say login or logged out depending upon what the current version of status. So I might do that right here in the render. And the first thing that comes to mind is just to have some button text saved in a variable. So I can initialize this variable, and then I can say it equals, I'll use a ternary to determine whether it says log in or log out. So if this.state.is logged in is true, I want the button text to be logged out. If they're logged out already, I want it to say, login. Man, instead of hard coding a login here, I will put button text. Hopefully this will actually show us whether they're logged in or out on the button, it says login, I click it, and then it says log out. So I know under the hood, my state is actually changing. Awesome. Okay, Part Four to display text that says log logged in or logged out, depending on the current version of state is actually pretty straightforward. It's about the same as what we already have. And so I might say, let display text equal essentially what we have here is instead of log out and log in, it would be logged out. Or sorry, log in because if they're logged in, then I want it to display a login logged in. Otherwise, no, no, but I have this display text. I could put maybe an h1 here uses the display text. So the button says log in because it's a command to log in, and it says I'm currently logged out. Then when I click it, it says click this button to log out because you are currently logged in. And that's it for this practice, then as much time as you need to really understand exactly what's going on. And when you're ready, let's move on. Alright, we've reached the final part of our to do app and we're just going to hammer out this last little styling piece. And we'll be done. So your challenge is notice we're here in the to do item component, what you're going to do is make it so that the items that are completed look a little bit different than the items that are incomplete. I'd recommend maybe graying the text out doing a line through it, maybe turning it to italics or something like that, I'm probably going to do all three. But whatever kind of styling you want to add, go for it and pause the lesson. Now give that a try. Okay, so I'm thinking this will be pretty straightforward. inside of my function here, I'm going to create a inline style to be called completed style. And let's change the font style to be I like essentially, the styles represent anytime that one of the items is completed, they will get this style. We'll make it metallic and then we'll make it maybe a light gray color. And we can put a line through it with text decoration. And then the thing that I want to style is the paragraph here that has the text of the to do. So I'm going to add a style property. And I need to do some conditional rendering here that determines whether or not I should apply these styles. So I'm going to say if props dot item dot completed is true. I'll just do this inside of a ternary then I want you to apply the completed style. And if it's false, then I'll just say no, which essentially means Forget it. I'm not actually going to do any styling here. So if I Save and refresh this. There we go. My completed items are grayed out, they're italicized, they have a line through them. If I make it incomplete, it essentially takes those styles out. Awesome, great job on the to do app, hopefully, you actually took the time to try and do a lot of this yourself. If you haven't, I really highly recommend going back and actually doing these. Again, you might remember one of my strong philosophies is that you'll never actually learn to create these applications unless you actually do it by hand, just watching somebody else do, it isn't really going to cut it. Now coming up soon, you'll get a chance to build an entire app from the beginning. And catching up on things like this to do app and actually trying it yourself is going to really make that task a lot easier. Once you're ready, let's go to the next lesson. In our past lesson about lifecycle methods, we talked about a lifecycle method called component did mount, I want you to take a second and see if you can remember what component did mount does. component did mount is like a hook in our react component that allows us to run some kind of code immediately after the component first mounts to the DOM. I mentioned when we were talking about lifecycle methods that one of the most common uses for component did mount is to get data from somewhere so that your component can do what it's supposed to do. As a quick refresher, I can add a lifecycle method right here as a class method has to be spelled correctly though it has to be component did mount and let's just take a look, if I do a quick console log, see that it ran our console log and it ran the console log immediately after the component finished mounting to the DOM. Well, like I said, right here is where we would get any kind of data that's required for this component to display what it needs to display or do what it needs to do. And so for this lesson, we're going to be using a couple tools that are really helpful for doing that. The first one is a built in JavaScript tool that's more or less new, called fetch. and fetch is a nice, easy promise based way to perform HTTP requests, so that we can get any kind of data that we need. I'll put up near the top here, a link to the MDN docs on the global fetch function. Another tool we're going to use is an API called the Star Wars API. Heavy school, we really like the Star Wars API, because it is cores enabled, which means that there are no issues with our front end application getting data from their database, you can find the homepage for the Star Wars API right here. Pretty easy to use. And the data that comes back is pretty fun to play with. So feel free to take a look at that website, too. And another resource that I figured out, add here is a medium article that talks about promises just in case you aren't feeling as familiar with promises as maybe you should. But the truth is, there's a million articles out there about promises. So you may have to read through a few of them and just practice them yourself until you feel comfortable with them. Okay, so let's get started with this inside of my component did mount I'm going to use fetch, which I use by just typing fetch. And this is a global function. So this should just work. And here, I'm going to put in the URL where I'm going to be getting the data from. So I'm going to put in the Star Wars API endpoint here. And we're going to search for slash people. And we'll just get the person with the ID of one, which happens to be Luke Skywalker. And that's all we need to do to use fetch to get some data for us. And I'm going to resolve the promise by using a dot then, which will receive a response that is not quite yet in the format that we need it to be in. So I'm going to use a method called dot JSON, which will turn this into a JavaScript object for us. And next in my promise chain, I can chain on another dot then which will actually receive the data that we want. At this point, I'd like to do something just like console log the data. So you can see if that worked, we'll refresh this. And it looks like we got some data down there. It's an object with some properties, like a name property, which we see is Luke Skywalker and some other properties that describe Luke Skywalker. Now that I have some data and need to get this to display on the screen Somehow, I want you to pause the video and just try thinking through what that would entail. How are we going to get this data that we just received from our fetch call to actually show up inside of our browser? Well, now that my component has received the data, if I don't save it somewhere, it's going to disappear. And if you remember the way that we save data, Within a component is by state. So right here in state, I'm going to add something like character, maybe, instead of equal to an empty object, I chose an object because I know the data that's going to come in is going to be an object. And then right here where I'm receiving my data, I want to make sure that I save it in my state. So I'm going to set state what's the video again, and see if you can write the set state that we're going to need to do in order to save this data to our component state. Anytime we want to change the state, we're going to call this that set state. This case, I really don't care what the previous state was, because I just want to change this state character to be the data that I just received. So I'm going to provide an object here, say character is the data that I got. Now, unless I'm inspecting this with my dev tools, I don't currently have a way to show that this is actually working. So down here, in our render, I'm just going to choose one of the properties probably name and see if that will show up on the screen. inside of my curly braces, I'll say this dot State DOT character, dot name, refresh the page and see what happens. Hey, now this API call is fairly quick. It made the call, waited for a response, got the response, set the state and then displayed Luke Skywalker on the screen all pretty quickly. But if the person using this app has a really slow internet connection, or the API is really bogged down, or for whatever reason, it's taking a long time for this request to complete, there's actually going to be nothing that shows up on the page until that request is done, which is a little bit off putting for a user. So although this doesn't directly relate to this lesson, fetching data from an API, this is a great place to talk about having some kind of loading message that lets the user know that the data is on its way. Now usually, I like to use some kind of fancy loading spinner or something like that. But for now, let's just make it display the word loading until that data comes back. This will illustrate a little bit of the power of saving state in your component and updating state as you go through a really simple way to do this is to add to my state, a Boolean as to whether or not we're loading, I'll start by saying it's false. And then right before we perform our fetch, I'm going to change it to true. Pause the video and see if you can figure out how to change loading to true. Okay, remember, anytime we want to change state, we're going to use set state. And I don't care again, what the old state was, I'm just going to provide an object and say, loading is true. Now what we need to do is figure out how to display the word loading. If state says that the data is loading. Pause the video again, and see if you can write something down inside a div that shows the word loading if this dot State DOT loading is true. Right now I have this dot State DOT character dot name. Here, you can see really quickly when I load this, that there's a moment where it's blank. So what I could do is right before my return, I could say something like text equal to and then provide an if else statement. Or I could shorten that by putting a ternary statement here. So I'm going to say simply, is this dot State DOT loading true? If so I want the text to say, loading. Otherwise, I want the text to say this dot State DOT character dot name. And instead of having this done here, I can put in my paragraph or whatever element of text I want. And I'll say it before I refresh this, I want you to try and think like the computer and see if you can figure out what's going to happen. Let me refresh this. And what's going on here. It says that it's loading constantly. To thank for saying it, why would it be doing that? Why is it consistently saying loading rather than changing it to the character's name? Well appear we set loading to true, but we never again set loading to false. And so this is always evaluating to the string loading. So now pause again and see if you can figure out how to fix this bug. This one's pretty easy here. When we're setting state of the character. We're also going to set the state of loading back to false. Let's refresh. You'll see it said loading for just a short amount of time and And then it resolved to Luke Skywalker. Awesome. Okay, so we have successfully used component did mount as a place to fetch our data from an external API, so that our component can do what it's supposed to do. In theory, this components job is to display one of the characters from the Star Wars API. And it needed the data from the Star Wars API. To do that. We've also implemented a loading feature that lets the user know whether it's currently loading or not, so that they don't just give up on our site and leave. I also think this is a good time to take a step back and remember how awesome it is that react is so declarative, if you were doing this with vanilla JavaScript, or jQuery or something more imperative, rather than simply having a ternary, that checks the current state of your loading variable and deciding whether it should display loading or not. And then just say whatever that is display the text. Instead, you would have to manually get an element by its ID, change it to loading, start the API request, and the data came in, you would have to get the element by its ID, again, you'd have to change some other kind of style, you'd have to change the word to display the data that just came in. Whereas here, we simply get to be more declarative and deal with state and say, whether we're loading or not tell it when to say that it is loading, tell it when to say that it is no longer loading, and react will handle the rest. So this is pretty cool. But it does require a completely different way to think about web development. A few minutes to play with this code, feel free to go check out the Star Wars API and try getting some other resources, see if you can get different things to show up on the screen. And when you're ready, let's go to the next lesson. Let's talk a little bit about forms in react forms tend to be actually a really important part of having a web application. And I found from teaching students at vi school that it's actually a rather tricky part of react, because we do things a little bit differently than we're used to when it comes to forms. So I'm going to do something a little bit different in that I want you to do a couple things before continuing on with this lesson. The first thing is I want to make sure that you understand state as well as you can, you don't have to be an expert with it. But as long as you have been able to follow along with everything we've talked about so far in state, and been able to complete the challenges, you should be good. If not, please go back and spend some extra time with state. The next thing is I want you to actually pause this video and go to the React documentation on forms, I put the link right here. And this does a pretty thorough job talking about the concept of forms in react. Once you've done that you can move on. So with forms in react, we actually do things a little bit different than we're used to with vanilla JavaScript. In the vanilla JavaScript Dom API, you create your form in the HTML. And once the user decides to submit the form, you go through all of your form inputs, and gather all the data together pretty much at the last second. And that's when you would do any kind of form validation that you need, and so forth. Well, with react, we're going to do it a little bit differently. Instead of waiting until the very end, right before submitting the form together all of the information, we're actually going to constantly keep track of all the information in state, which means on every keystroke, we're actually going to update state so that we can always have the most updated version of what the user is typing into the form. To really illustrate this, let's just start with a single text input. Down here, instead of a div, I'm going to render a form. And we'll put a single input inside of there. Give it a type of text. Let's give it a placeholder for now, just to keep things simple. Let's see we're gathering the first and last name of person. We'll start with first name. Okay, so like I said, normally, our form might have a button that says submit the form. And at that point in the vanilla JavaScript Dom way of doing things, we would gather all of the information typed into all the inputs. But in react, we want to watch for every single change to this input box. So think for a second how we might do something like that. Well, input boxes have an event that can get fired called on change. So what we might do is every single time the input changes in the input box, we will run a function. Let's call it this dot handle change. This function obviously doesn't exist yet. So let's create it. Now my goal is to make it so that every single time somebody types in here, I actually update state and I want to do a couple things. I want to Grab the current value of this input box every single time it changes. And I want to then update state to reflect what the current value of that input boxes. Well, first of all, my state currently doesn't have anything saving anything right now, right? So I'm going to add a property called first name will just started as an empty string. Now I have something that I can update every time the handle change function runs. Okay, well, to update, I use this dot set state, anytime I want to change the state. Truthfully, I don't care what the previous state was, I'm just going to provide an object here that says the first name property should become something. Well, what am I going to put here? Well, I need this to be the current value of my input box. If you're familiar at all with vanilla JavaScript Dom API, then you know that when events fire, they pass a pre determined parameter into our function. We don't get to choose in this instance, what's actually going to be here, it's always going to pass to us information about the event that fired. And this event has some really important information. For example, I can get access to the value of the input box by saying event got target. Target represents the element in which the event was fired dot value. And that's the value of the input box. So what I've done here is I've said every single time a character is typed into this input box, run the handle change function. And the handle change function changes the state, so that the first name property of state is updated to reflect whatever the current value of this input box is. I can't open the dev tools and inspect state inside of scrambler. And so I'm just going to create a little h1 that will display whatever the state is. So we can see it. And now I'm actually going to run into a little error. You'll see that it says I can't read the property set state of undefined, see if you can figure out what I'm missing. Anytime we have a class method that's calling set state, we need to make sure we bind it inside the constructor. And so inside the constructor, I'll put this dot handle change equals this dot handle change that by end of this. Okay, so let me refresh this again. And I will start typing and you'll see every single character is upgrading state. Okay, well, I have something that's going to violate the DRI principle, don't repeat yourself principle. Now what's going to happen if I want to create another input for my last name. So I've made another input, that is also running my handle change function. Let me initialize a last name property in my state. And I added my h1 to show what the last name property of state is. Okay, so I have a first name, last name, first name works great. But what happens when I type in the last name? Notice it just gets rid of everything from the first name. That's because I've hard coded into my handle change that it's updating the first name property of state. Obviously, one way around, this would be to make a whole extra function called handle last name change or something like that. And make this on change be a different function altogether. But that's not going to work in a larger form that may have like 50 inputs or something crazy like that. Now instead, what we're going to do is we are not going to hard code first name here. And we're going to give a name property to our inputs. That perfectly matches what our state is. First Name, capital N, and last name, capital N. And remember, up in our handle change, we have this event that we're receiving, well, this event has a bunch of information about the input that is firing this event. For example, we grabbed the value of the input box. But I can grab any part of the input object that I want, not only the value, but I can also grab the name property. And so to the left of my object here in the property name here. I can say event dot target, which is my input box. Got name, which is the name property. This isn't quite right, right, because this is a syntax error. If I want this to actually represent the first name, property or the last name property, I need Make sure to wrap this in square brackets. And this works because the name property is a string. And if I'm describing a string property name inside of an object, I can wrap it in square brackets. This is just a principle of JavaScript that you may or may not be familiar with. And so now when I refresh this, anytime I type into the first name box, I get a change to my state in first name. And anytime I type into my last name box, I get a change to the last name. Okay, as a quick aside, this same principle here is going to work whether I am using a type of text, or anything else that's text based like an email, or phone or number, all of those are essentially going to use this exact same handle change function. And you need to make sure that you give it a name property that perfectly matches the property and state and that you pass your on change function to it. Now I'm actually splitting forms into a two part lesson. And in the next one, we're going to talk about some of the other types like checkboxes, radio buttons, text areas, and select boxes. But before we get there, there's one more thing I want to touch on. And that's the concept of a controlled form. If you did what you're supposed to do, and went over and read the React documentation on forms, you read about controlled forms. The idea is that we actually want what's displayed inside of our form to perfectly match up with what is in our state. Right now, state is being reactive, as in every time the input in the box changes state updates, according to what's in the input box. Well, with a controlled form, state actually directs what is inside and showing up inside of the input box. This is kind of a splitting hairs distinction. But it really jives well with the idea that state should be the single source of truth, it doesn't have to be that complicated, the only thing we really need to do, especially with these text inputs, is add a value property. and the value should always be this dot state, dot, and then whatever property that box is holding, first name, last name. And when single elements start to get too long like this, I like to put each of these attributes into their own lines. Okay, that's a lot better. Okay, now we can see that everything, I'm going to refresh this, everything is still working essentially the same as it was before. But now what is showing up in this input box is because of what the current version of state is, in other words, I'm forcing the value or what shows up inside of the input box to exactly match what state is also going to give you one quick best practice that will help you avoid a really difficult to debug bug that could come up in the future. In this case, we're not seeing it. And I'm not going to worry too much about explaining what that bug is exactly. But a really good idea is instead of directly accessing the name and value properties, by drilling into the event, that target object here, you can save yourself a lot of grief by simply pulling those values out of the target before you set any state. Using some basic object D structuring, I can say name, value equals event dot target. Then down here, I can just say name, value. If this is something that you're actually super interested in understanding, you can look into reacts synthetic event. And you may get a better understanding of why this is important. But it can be really helpful to make a copy of the name and value before you run setstate. Okay, that's enough for this part of the lesson. Take some time to go over this again and digest it, feel free to practice with it. We're going to talk about forms part two next, and then we'll have a practice that goes over both of these parts together. So far, we've talked about some of the most basic input types when it comes to forms, anything text based is essentially going to act the same way that we've talked about in the previous lesson. But unfortunately, forms are a little bit more complex than that. And with some of the other elements that you can use, things start to get a little bit more complicated with react, but it's not too bad. So let's walk through it. Down here, I've made some notes about some of the elements that I'd like to talk about the first one and probably the easiest to understand is the text area element. If you've used the text area element in regular HTML before, you know that it is not a self closing tag, like the input element, but instead has a closing tag. If I refresh this page, you can see that it's essentially like an input box, but it's a little bit taller and the user has the ability to make it bigger or smaller. We also have the ability to change the default height and width with properties called rows and columns and in regular HD Well, if you wanted to pre populate some text in here, you would do so by typing it in between the opening and closing tags, or rather the inner HTML. Well, what react has done is they wanted to make text area much more similar to the input element. So in react, there's a major difference in the text area element in that it is a self closing element. This is actually really nice, because we are able to use the value property now. And we can use it exactly the same way as we were with an input. This is nice for consistency. And it also makes it really easy to update the value of the thing inside the text area by updating state. So you can see if I were to add some default value in here. That's what shows up in my text area element. And that's it with text area. Let's move on to checkboxes. checkbox is just a type from input. So input type equals checkbox. But one of the major differences is that you are not going to use a value property like we did with text area or input. Instead, the idea of a checkbox is that it's either checked or it's not checked. This means that we are going to add a checked property here and I'm going to start putting things on their own lines will have a checked property. And this is going to be determined by some kind of Boolean because a checkbox is either checked or it's not checked. And so checkboxes typically maintain Booleans in state. For this example, maybe we are checking if the person that we're referring to is friendly. Now in state, I haven't yet defined this. So I would come right up here to state. Ad n is friendly, and maybe we'll initialize it with true for refresh this, you'll see that I now have a checkbox and it starts out by being checked. We'll notice that if I click it, it's not letting me uncheck it. Think for a second why that might be? Well, down in my check box, I've told it that it is checked if this.state.is friendly is true. And essentially this true value is being forced upon this input. And so even if the user tries to uncheck it, React will say, Nope, it is actually checked because this value is true. So you might have noticed something popping up in the console that says that I've provided a value prop without an unchanged handler, essentially rendering a read only field. And that's what we're seeing here. It's Read Only I can't make changes to this because I haven't taught it how to make changes and how to change state. Well, this is where things get tricky, because what I don't want to do is add an unchanged, that is looking to something like handle checkbox method. Right? It would be nice if I could just use my existing handle change method to handle changes on a checkbox. And so we're gonna see how you can do that. First, I'm going to put this to handle change. And just like our other inputs, I'm going to give this a name property that is the same as the thing in state is friendly. And now Give me a second to make this look a little better in our form over there. Okay, that looks better. And now the tricky part comes in. Because in an input box, we're keeping track of what's being typed into the input box. You might remember from our handle change, we are grabbing the value event dot target dot value, an updating state with the new value. Well, our checkbox doesn't have a value, it has a checked property. And the checked property is actually going to return either true or false. So what we're going to need to do in order to use our same handle change function for our checkbox, is we need to check if the element that is being interacted with in the form is a checkbox or not. And so there's a couple things that we need to pull out. First of all, notice how we have type equals checkbox. Type is a property that we can pull from event target. So besides just the name and the value, if it's an input or a text area, you can also grab the type. And then just like we discussed how checkboxes don't have a value, but instead have a checked property, we can pull that from event target as well. And so now we know that I can check if the type is a checkbox, I won't be able to do this, this dot set state because I won't have a value property. But instead we'll need to change the name which is is friendly to whatever the current value of checked is. You could do an if else statement, or I could just do a ternary here. So I can say is the type equal to checkbox? If so, we're going to update state in a certain way. But if it's anything other than a checkbox, we'll use our existing This dot set state. Now here, we will also run a set state. And we are going to access the name property. But instead of using value, we're going to set it to whatever the value of checked is. Let me open this up a little bit so that it's a little bit easier to read. And now when I refresh, let's see if I'm able to update my checkbox. Now when I click the check box, it's going through my handle change, it's seeing that the type is a checkbox. And so it's running this, this that set state. And when I go over to my other input boxes, I can still say, name, and it's updating state in a different way. And while we're at it, to get rid of the warning that we have in our console, let's add an on change to our text area, so that it stops yelling at us. Excellent. Well, now let's talk about radio buttons. Because radio buttons are kind of a combination of the input type text, and the checkbox. What I mean by that is that they are going to use both a value property and a checked property. So I'm going to make a copy of my checkbox, so that I can quickly get something prototyped up, I'm going to change the types here to radio, let's give the name of maybe its gender. And now notice that I'm giving the same name to both of my radio buttons. What this tells the DOM to do is to make sure that I can only choose one of these two radio buttons, wherever they're also going to have value, the value will be slightly different. So maybe first one is male, and the second one is female. And I'll update my label here. And let's put some breaks in there. Now notice what happens when I go over here. Again, I can't change them. But if I click on his friendly, notice that it chooses one of these two to be checked. This is kind of quirky. And the reason is, first of all, because I copied and pasted, which sometimes leads to funny bugs, it's still saying that it's checked if his friendly is true. But this is where radio buttons are a little bit different, because I can't just say it's checked if some value in state is true, because radio buttons jobs aren't to maintain true or false values, right? That's what the checkbox is for. Instead, I want this to be checked if the value of this dot State DOT gender is equal to male. And similarly, if this one is equal to female, I don't have gender maintained anywhere in state, so I'll need to go update my state up here. Maybe we'll just start gender as an empty string. Now, when I choose this, it will let me choose one or the other. And under the hood, it's maintaining a gender of either male or female. Again, since I can't pull up the dev tools in scrambled, let's go down here and just display something here. Okay, and we should probably use some kind of conditional rendering. So this doesn't show up until one of these is chosen, but that choose male and female, it's updating state, and therefore updating the text that we're seeing down here. I think this is probably a good point to mention that a lot of this stuff may seem really complicated and different from each other. And it's just important to know that you're not necessarily expected to have all of this memorized. Honestly, I end up coming back to some previous examples that I've written just so I can remember this syntax. This is probably also a great time to mention that there's a really excellent library out there called Formic. There's a few of them, but I'm just gonna put the name right here. So you can take a look. Formic basically takes all of the pain out of writing react forms, it's a library that you can install and just use their API to make your life dealing with forms much nicer. Okay, the last form element that we're going to talk about is the select box. And in regular HTML, you're probably used to having a select with options. And fortunately, React has chosen to use the value property again, so that we can easily determine which of the select elements is chosen. And also to very easily be able to update state, though for example, maybe we are deciding what our favorite color is. We'll have a state property called favorite color, and the value of this whole element is going to be whichever of these options we choose. First thing, let me put favorite color up in my state. And we'll just start it off as blue. Okay, and then down here, I'm going to make sure that I'm watching for a change on my select box. So unchanged, I'm still going to run my handle change, I also need to give it a name, just like I did with my input boxes will make sure that this matches the name and state. And then the only other change I need to make is make sure that my options also have value. And the value here is going to be whatever I want the different options to be. So this will be the value under the hood. And then the text here in the inner HTML is what will be displayed in the select box. And that's probably good enough. Oh, and it looks like I put my slash in the wrong place here. Okay, let's give this a break. So it's on its own line. And maybe put another label here. And yes, I understand this form is very ugly right now. But my click my drop down box, you'll see I have my options. And before I select something, let's just put another thing down here. So I can see that state is updating. Okay, notice that my state initialized correctly. And when I change this, it's changing the value of state. what's so cool about the way that react has chosen to implement the API regarding elements and forms is that it makes it so that we can write a single on change, rather handle change. It had to do one workaround with the checkboxes simply because the philosophy behind checkboxes is so different than all the other elements. But essentially, we're reusing this one handle change, and it's working for all the elements in our form. Yeah, I totally get that this is a lot to digest, we're gonna do a practice right after this, that should help cement this information a little bit. Don't feel overwhelmed so much with understanding or rather learning all of the syntax of every one of these elements, that may distract you from all of the other coolness that react has to offer. Instead, don't be afraid to just practice this a couple times, and then come back to it whenever you need to, eventually, you'll gain a muscle memory that will help you remember all of this. One last thing that I failed to mention in the previous lesson was how to actually submit this form or do something at the end of filling out this form. Kind of two general ways that you could do this in either way, it's going to be a good idea to put a button in your form of some type. Now in html5, the button element if it's found within a form, acts like the old input type submit, if you're familiar with using that, where you would give it a value that displayed the text on the button, and so forth. I personally really dislike the way that input is used in so many different ways. And so I never use the input type submit myself. Instead, buttons in html5, if they're found within a form. When they're clicked, they are a submit button. And they will fire the on submit of the form itself. So when you want to do something, when you're finished with the form, one thing you could do is to just add an on click on your button. Personally, I like to handle that action on the form itself. And so I will have an on submit handler. And we didn't write this but it would be just as easy as creating another method that's called handle submit and doing something like submitting the form to an API or something like that. Okay, take a deep breath, you've basically finished all of the most important parts of forms. We've talked about input type, text, and other text based inputs like numbers and passwords and so forth. But we've also learned how to handle checkboxes, radio buttons, and select boxes and text areas. Okay, let's move on to the next lesson, which will be a practice of forms. So let's practice building forms. Your challenge is to wire up the partially finished travel form below so that essentially it works in react. This challenge is actually one that we use at vi school and the URL for the original challenge is right here, you'll probably want to go there so that you can see exactly what's supposed to be done. Now in this goal will use this as in plain HTML forms challenge so it doesn't really have anything to do with react, but I'm just adapting it for react for this lesson. So pause this lesson, go take a look at this website. Learn some more about what you're trying to accomplish in this form, and give this a go. Alright, so there's a lot of different ways that we could approach this, I think what I might do is initialize everything with state first, and then start wiring things up one at a time. Okay, so I know that my state is going to have a first name. Last name. We'll also do age, which actually have a little bit of a question myself on, but I'm just going to initialize it at zero for now, and then try something a little bit later. Let me scroll down here, I know I'm supposed to have under and I have a select block for location, I'm pretty sure this is supposed to be destination. So I'll say destination, then a checkbox for dietary restrictions. Now, what's actually going to be there for dietary restrictions is a number of checkboxes. And because they're checkboxes, it's possible that they will check multiple boxes. And so if I'm going to have multiple dietary restrictions, what I might do is choose to take this as an array. And okay, that seems to be the last thing because here's my Submit button. Now that I have my state initialized, I'm just going to start putting some of the things that I know will need to exist in my existing elements here. So we'll start with my inputs, I know that I'm going to need a name property for each one. Now I'm going to need a value for each one. Actually, this is going to be determined by state. So this will be this dot State DOT something I know each one is going to want to be able to change. So I will have an on change will probably call it handle change. While I'm added I'm going to put everything on its own line. Okay, so the names will need to match the parts of state that they're representing. So this will be first name, last name, and age. And I'll actually have the same thing for state. So this will be first name, last name and age. So that looks like I lost my curly braces there. Now maybe before I go creating a bunch of extra elements, I may finish this part off and make my handle change method. Right here, I will need a handle change. I'm going to take an event. And before I forget, I should probably find this I know that I like to pull some of the elements from the event that target. So for this right now, I just need name and value will add to this later when we get to the checkbox. And I'm going to set state here whatever name I'm concerned with changes to the new value. Okay, so the buggy thing here is that this starts with a zero. Let's go down and see if these three inputs are working correctly. So with your name, going to put this dot State DOT first name, base, and this dot State DOT last name. If I type in these boxes and see if it's working great. The same for age. And it already says zero. But if I change this to something different. Okay, that works. And now the thing I actually wanted to test was to see if react complained when I started this as No. And it does. Okay, and it looks like it just doesn't like that the value on the input is no. So it recommends using an empty string. But part of me going out and doing a bunch of research this will just have to do for now. Okay, so after a refresh, you can see I don't get my zero age anymore, which is smart, we wouldn't want that showing up as a default of our form. And it looks like so far, so good. Let's go down and fill in some of these new elements here. Let's start with the radio buttons for gender. I like to wrap my radio buttons in a label that said that the person could also click on the text of male or the text of female and select the associated radio button because the text is a parent of the radio button. So I'll just put the label as a parent of my radio button which is an input Type radio. And I like the text to be on the right side of the radio button myself so that the radio buttons are nice and lined up on the left side. And remember the radio buttons were kind of a combination of checkboxes where they have a checked property and also the text inputs where they have a value property. So I'm going to be adding a lot of stuff to this radio button, I'm gonna go ahead and start putting things on their own lines already. And then we'll say response has a name, which will be a gender value, in this case, it will be male. And we're also going to have the checked property. This one is a little bit trickier because it's going to say this radio button is the selected one. If this that state that gender is male, then we'll have our on change to be our this dot handle change. And let me go ahead and just copy this and change it to work for female as well. Another great here. Hey, let's refresh the page and see what we got male and female, and it looks like I can check those. Let me see down here, if that's working. So under your gender, we'll put a start state that gender doesn't start as anything and choose male. And there we go. Change it to female. Perfect. All right, we're cruising. So let's do our select box now says the select box for our locations or destinations. And this is going to be a select box. And we know we're going to have some options in here. And let's put before options. Obviously, this is not a great airline that's flying to only three or four locations, but whatever. Now I remember that our select and our options all take a value property. They're a little bit different from each other, but I'm going to go ahead and just add a value. Okay, the value on my options is simply what state should be if this option is the one that's chosen. So this is where I'm going to put my actual locations. So I might say something like Germany. And I'm going to keep this lowercase for the extra value just to stay consistent with how I have things elsewhere. Let's do Norway, the North Pole. And why not, say the South Pole. The value of the select box is not the options that we have, but rather the chosen option. So this will be determined by state as part of a control perform. We are calling this destination. Then just like our other ones, we need to make sure that this has a name, say his destination again, it needs to match the property and state. And we'll have our same on change, which is the standard change is getting long. So let's put it on its own lines. And down in the Display area, we will put destination from state. Now you'll notice here that it has automatically selected the first one, but doing so has not actually updated state. So my destination is still empty. If I want to Germany, I would actually need to switch to Norway, and then back to Germany to actively choose this as my option. And so what a lot of people will do is they'll just put an option at the top that maybe we'll leave empty and put something like something like that. Okay, Germany gives me Germany and I can actually actively switch to any one of these that I want. Okay, well, we've saved probably the more difficult one for last. And that's our checkbox. I feel like I've had some clarity since I first started state. At the beginning of this lesson, I created an empty array for my dietary restrictions. And I'm thinking it's actually going to be easier if I save this as a sub object where I have an option for each one of my dietary restrictions and the value is going to be a Boolean. So instead of trying to manipulate my bullions into some kind of text value. Instead, I'm just going to create an object. And each one of these will represent a Boolean of some kind, I will probably want each of these to be unchecked as a default. So I'll just say each one is false. The is kosher. Free. That should be good enough. So now I'll need three checkboxes, each one representing one of these three properties down here in my form. Again, I will wrap everything in a label type of checkbox. Name, the vegan unchanged will continue to be this handle change, which if you remember, we're going to need to update in order to correctly handle the checkbox. And then I need something to direct whether or not this is checked. And this is going to be a little extra nested level here. So it's going to be dietary restrictions.is vegan. And as part of my label, I'll just put a label that says vegan. Okay, so I'm actually just going to create a few of these and update them. So I have is vegan is kosher. And this one was lactose free. Okay, let's take a look and see what that looks like. Okay, awesome. Now notice that once again, I'm not able to change any of these checkboxes. If you didn't get this far, when you did this yourself before we started doing this together, pick the time now to see if you can update our handle change so that it can handle the changes in a checkbox. Okay, so once again, the checkboxes don't have a value property. And currently, our handle change only is able to update things with the value. But we know that we're going to have to check if the type is checkbox. So I'll need to pull the type from my element. And I'm also going to want to see if property is true or false. Or rather just see what the check property is, then what I need to check is if the type is a checkbox, I'm actually going to do my set state on its own line, it's gonna get a little more complicated. Remember that in this case, I can't just say to set the state of name checked. That's because I've chosen to have a nested object here. Apparently state does not have a property called is vegan or is kosher. Instead, it has a property called dietary restrictions, which has a property called is vegan, or is kosher. Now normally, React is smart enough to know that if I'm updating just one part of state like the destination, it will combine that with the rest of state. However, I'm not 100% sure offhand, if I update just one part of a nested object, if it will also update the rest of state. So I'm going to be live testing this here with you. Let's give it a try. First thing is this won't work either way. So this will have to be dietary restrictions. Be an object, and we will update the name. Before I can test this, I need to finish my ternary because this is broken Currently, there will say otherwise. This dot set state name value just like we had before ever feeling this isn't going to work, but let's give it a shot. So no errors so far. That's good. You know, just put something in here, we'll see that my name is working. Now if I check vegan, it doesn't seem to like it, it thinks that I'm changing something from a controlled form to an uncontrolled form. And that has to do with the way that date is updating out Fortunately, I think I should be able to use the object spread notation, which means what I can do is pass in the previous state. If you remember when we talked about that state how I can either provide a brand new version of state or I can provide a function that receives the previous state as a parameter and uses that to update state. I'm going to change this to the second way and I return a new object and inside of dietary restrictions, going to take all of the property These from proof State DOT dietary restrictions, and then update the rest. And it actually looks like maybe scripted does not have the ability to do object spread notation. It really depends on what version of ECMO script you are transpiling using Babel. In this case, it seems like the object spread notation doesn't work in scrubba. But at this point, I think it kind of worked myself into a corner. One workaround that I can do and probably will do for now is to just get rid of my sub object, dietary restrictions. And make each one of these their own property on state, we just got promoted. which case, I can probably simplify this quite a bit and go back to the way it was. So we'll get rid of dietary restrictions, we'll get rid of this name checked. And now that is vegan is kosher, and is lactose free are kind of first class citizens here in state, I can simply update by its name and determine whether it's true or false. Let's try this. Okay, we're doing some live debugging here, it says that it cannot read property is vegan, of undefined. And notice that I still have my checked saying this dot State DOT dietary restrictions. We don't need that anymore. Or handle change and try again. Okay, so now I should be able to enter something as a first name, which shows up in my name, and then choose some of these. And oh, we haven't updated our dietary restrictions display yet. Down at the bottom, let's just see if we can get this to work your dietary restrictions, say, vegan. state that is vegan. And we'll just do the same with kosher and lactose free. You'll notice that it looks like they're starting out empty. If I had checked them, it's not actually displaying any text here. Isn't is react does not display Boolean true or false as text on the screen unless you go out of your way to make it text. But one quick workaround that I could do is I could put another ternary here that says you should display Yes, if it's true. No, if it's false, then here, I actually get the nose showing up. Let me put these each in their own paragraphs, so that they don't mash together this way. And you'll see vegan, no kosher, no lactose free No. When I select some of these, those have changed. Yes. Or another fun practice that would just be a regular JavaScript challenge is to try to get it to display the words vegan, kosher and lactose free is a comma separated list. I won't do that here. Because I've already taken up time just trying to debug this with you. If you want, you can pause the lesson and give that a shot might be kind of a fun challenge. And with a little bit of workaround, and having to change a little bit of our state, we have been able to successfully build our form. It's obviously not very pretty, but it seems to be working. So if I fill everything out, not 9999, as it turns out, looks like oh, I have to select the destination. Let's go to Norway. It looks like everything has filled that correctly. I mentioned at the beginning of learning forms, it's a kind of complicated process. And forms in general are very important when it comes to web applications. Obviously, they're not always going to be filling out lengthy or forms like this. But if you think about it, anytime you click a checkbox, or anytime you have a radio button, or a signup form, or a login form, or anything like that, a lot of that is using forms. So really understanding this is going to help you be a better developer for web applications that users can interact with. So although I said it's not necessarily important to have each input type syntax memorized, it's still a really good idea to practice this, play with it, see if you can really understand it so that when the time comes to build the form in your react app, you can do so relative ease. Thanks for your patience while we went through and debug some of this stuff. Hopefully, that was a good exercise in general. When you're ready, let's move on. So when we built the travel form in react, you may have noticed that a lot of the time we were scrolling up and down and we have an component here that's 146 lines long. Now you'll notice that A lot of this space is being used as display logic, right? It's showing the form, it's displaying UI, it's creating elements, all of this happening inside of the render. But then we also have a place where we're maintaining state. And we have our handle change function, which is doing some business logic. You know, there's been a study done that shows that a programmers ability to understand the code that they're looking at diminishes dramatically, when the file that they're looking at is one in which they have to scroll to see everything. And I've noticed that with my students as well, if I have code that's too long, and I'm scrolling around the screen all the time, it's very easy to become disoriented and lose your place, and makes it much more difficult to actually understand what you're looking at. It would be nice if we separated our concerns between the UI logic or the rendering logic, and the business logic that actually mandates how the rendered logic changes. And so this idea emerged a few years ago of having a presentational component and a smart component or component that's in charge of the business logic. There's a lot of different names that you'll hear presentational and container components, smart components and dumb components, containers and components. But they all refer to essentially the same thing. The idea is that you have one component whose job it is to maintain state, and to have the methods that update state. And then for that component to essentially delegate all of the UI logic or presentational logic to another component. That's called the presentational component. That presentational component will only be in charge of receiving props and displaying things correctly. If you'd like you could read den epor mobs, medium blog post where he talked about presentational and inner components at this URL. And if you're unfamiliar with Dan Abramov, he's one of the primary developers of the React framework. So let's take a minute to organize some of the code that we've written here. First of all, I currently have everything happening inside of my app component. And I just did that for simplicity. But in reality, I want my app to render my form, and let my form do all of the for me things. So I'm going to create a new component called, let's just say form dot j, s. And I'm essentially going to take everything here, put it over and farm, clean up a few things. palette form, and export form. And then over in app, we will make sure to import the form. And since our form is handling all of our state and everything, we basically can change this into a functional component that just renders the form. So maybe I'll go ahead and do that. That's pretty simple. And you'll see that everything is showing up the same. And remember way back when I kind of talked about how I like my app to be sort of a table of contents where I could put a header above this and a footer below this and whatever main elements and then delegate the rendering of those main UI components to the other components. So our problem is essentially still the same with form j s, because we still have one component that's doing all of this stuff. So what I'm actually going to do is I'm going to create another component, this one we will call form component, that j s. But essentially, you could call these whatever you want, you could have form container dot j, s and form component dot j s, you can even put them into a folder called form and make form j s actually just index j s and then have form component dot j s, I've seen it done a bunch of different ways. And for clarity, right now, I'm actually just going to rename form to form container so that it's obvious which one we're looking at. And that just means over an app js, I'll need to update this to form container. And we're still working. Okay, opening the form container, I'm essentially going to take all of the rendering logic, let's get this whole return statement. I'm going to take it out. While I still have it in my clipboard, I'm going to go over to the form component and create just a regular functional component. Thank you receive props. And let's paste our whole return in there and fix some of our indenting. Awesome. One thing you might notice that's broken because we copied this from a component that was a class based component. We have stuff like this dot State DOT first name and this dot handle change. Well, this functional component doesn't have a handle change method and it doesn't have any state. Instead, it's going to be receiving everything through props. So we'll come back and fix this in a minute. But over on our form container, you now have an empty render. And what we're going to do is let the form container delegate all of the UI stuff to the form component. So at the top, I will need to import form component, the form component file, and simply render a component. Like we said, we're gonna have to pass a bunch of stuff through props down here. But already, we can see that my form is quite a bit simpler than it used to be. Okay, well, let's wire up our form components so that it has all of the same information because it right now if I refresh this, you'll see that we have some problems. And so what I actually need to pass are all of these properties in state. And I also need to pass my handle change method. So let's start with the handle change method. And I might as well just keep the name the same. That over in my form component. In props, I'm receiving a prop called handle change, which means every time I have this dot handle change, I need this to instead, say props dot handle change. That's a good start. We still have problems because we have no state in this component. So let's go back to the form container. And I have a number of different options, the most annoying of which is I could pass down first name, which is this dot State DOT first name, and then do this for every one of these properties. But it's really that's pretty obnoxious, right? Because my form component is now going to have maybe like seven or eight extra lines. Another option is I could just pass everything, the whole state object down as a property called something like data to the start state, this is leagues better than what we had just tried to do. But it does mean that in our form component, we're going to have, instead of this dot State DOT first name, we'll have props dot data dot first name. And truthfully, that's not so bad. And in fact, in my personal development life, I have tended towards this, where I pass an object down and I just give it a name, it does mean that I have a little bit of extra typing where I say props dot data dot first name, instead of finding a way to just have props dot first name. But as we discovered, when we were doing the travel form, screenbid doesn't do so well with the object spread operator. But if you have the correct ECMAScript versions supported in your project, you could simply say, pass down all of the properties of this start state. Doing so would allow you to in your form component, say props dot first name, props, dot last name, and so forth. Again, I have actually leaned towards sending down an object, simply because it makes following the prompts a little bit easier for myself in the future and other developers. But I've seen it used both ways. So it's really just up to you here in screen. But I believe I'm going to have to do something like this. So now let's go over to our form component and update everywhere it says this, that state change this to props dot data. Let's see if we have any problems, says nothing was returned from render usually means a return statement is missing. Yeah, I think in my form container, I Yep, I got rid of my return, which we cannot do. So we're gonna put the return back. And we have one more error, it looks like it says that I probably forgot to export my component, which Sure enough, I did. export our form component. And it says react is not defined. And that's because I forgot to import react. And you might remember way back in the beginning, the reason it says that is because JSX is normally not valid JavaScript. And so I actually need the React library in this file so that it knows how to handle JSX. And our form is backup. Let's see if it's working. Good news. Choose the destination. And say we have some allergies or preferences and we're male. And yeah, it looks like everything else is working. Perfect. And as such, we still have a quite large form that we have to scroll a little bit in. But this entire file is only caring about the UI component of our form. Whereas over in the form container is only caring about the business logic of the form. This way, we have a nice separation of concerns. And it allows us as a developer to essentially have an easier time when we need to make changes to this file, we don't have to scroll up and down over hundreds of lines of code. Now, one thing that's probably good to point out now is with libraries like Redux. And with the recently released context API, notice that the container component split of components here, like we just did is not actually used quite as often, especially when you are injecting context or global state from Redux or something like that into your components. When you do that, a lot of the business logic is delegated to another place entirely. Which kind of means that you end up writing a lot more functional components to simply consume the data that lives in Redux or in some global context or something like that. But as you're developing your applications, this can be a really great way to separate some concerns, if you find that you have a lot of business logic, and a lot of display logic happening all inside the same component. Hey, with that, under our belts, we are ready to move on. Alright, we've made it to our capstone project, where we're going to build the meme generator that we talked about at the beginning of this course. Now, the way this will work is part of the time, I will put comments here that will give you some direction for you to build out parts of the UI yourself, at which point like I have in the past, I will give you time to pause the lesson and do that afterwards, we'll go through that together. And there will be other times where I'm just building things on my own and kind of explaining what I'm doing. Now notice that we're starting almost completely from scratch, the only thing that I have included already is a bunch of styling that I've pre written. And the reason I did that is because while this isn't a course on styling, and just for time sake, so that it's not too boring, but over an index js, we have nothing here. So get excited, this is gonna be fun. And let's get started. Okay, so the first thing you need to do is to create that boilerplate code that will get react to render something on the screen. And the thing you'll render should be an app component, which you'll need to create separately. Pause now and give that a try. Okay, let's get rid of this comment. And we'll say import react from react, React DOM, from react dash DOM. We'll use react Dom to render our app component, which doesn't exist yet. We're gonna put it at the root. we'll import app. And this is basically the boilerplate we need for there. So let's create our app. Yes. There we will also import react from react or export our component. Let's start by making a functional component called app. Which we will have returned something so we can see that it shows up on the screen. Awesome. Okay, let me type up some comments for the next thing that you're going to do. Okay, so you need to create two new components header and meme generator, the header is only going to display things and the meme generator will be calling to an API and holding on to data. So let that information help you determine what kind of component you're going to create. And as always, each of those components should be in their own file of the same name. Pause now and try that. Okay, this one's pretty straightforward. So let's create a new file called header dot j. s. And a new file called meme generator. Yes, these comments are in the header import react from react. export the header. And since this is going to be component that just displays things, we'll make it a functional component. Now, always I'll just put something that says header. And over in meme generators, since this will be holding data and making calls to an API and so forth. This should be a class component. We'll still need to import react from react and since it's going to be a class I'll go ahead and just import opponent as well export the meme generator and create my meme generator class that it will need a constructor which calls super. And I mentioned that it's going to hold some state. So I'll just put some empty state there. And I will also put my render. So that as before I have something showing up. Now that I've created both of those over in my app j s, I can import them. I'll go ahead and use them here, I'll need to wrap everything in a single element. We'll make an instance of our header of our meme generator. Awesome, good so far. Okay, over in my header, I'm just going to begin putting some stuff here. So I know that I want to use the semantic html5 tag header. And I want this to have an image. And we will set this as our source which is a troll face. And we'll give it an all property of problems. too long for this line already. So I will separated, we'll just have a paragraph that says and I save this. Okay, you'll see my styles have kicked in because I used the header tag. And I'm going to go ahead, I didn't do a great job making this responsive. So I'm just going to make this window a little bit bigger. If that has overlaid your code a little bit, you may want to make sure you maximize the window here, first grandpa and go a little smaller probably. And this is everything we're going to do with the header for this project. So we're going to go to meme generator, and pretty much everything else we do will just be in this file. So now it's time for you to get your hands back on the keyboard. So I will write up some comments here for what you're going to do next. Okay, we'll just take this one small step at a time. So all you're going to do is initialize state to save the following data, top text, bottom text, and a random image. And I've provided the URL to the first image that you'll use. So pause now and do this. It sounds pretty straightforward. So to initialize state, I'm going to build up this object here and save top text, which is text, but I'll just start it as an empty string. Bottom text, also an empty string. And my random image, which I'll just say, IMG is the image I provided. They were not rendering this anywhere. So we can't really display this. But that's okay. This is good for now. Let me delete these comments. Okay, I have another challenge for you. Let me write up the comments now. So we're going to be using an API that provides a bunch of meme images. And your task is to make an API call to that API, which I've provided the URL to, and save the data that comes back, which you'll find under response dot data dot meems, to a new state property called all meme images. And the data that comes back is going to be an array. Let's pause now and give this a try. When we're getting data that we expect our component to have at the beginning, we're going to use the lifecycle method component did mount. As soon as the component mounts, we're going to use the native fetch function. And we're going to call to the URL that I provided. And this will return a promise that we need to turn into a JavaScript object. We will call the JSON method on that. Then we'll get the actual response that will be useful to us. And I'm going to pull the memes array from response dot data. And then like it says, we need to save it to a new state property called all meme images. So I'm going to initialize that as an empty array, and start, and then I will set state. And I don't really care what the previous state was. So I will just say all meme images. Now B means that we just pulled just so I can see that this data is here, I'm just going to console log, the first item in this meme, and take a look at what that shows me. Cool. So I've got an ID, a name, and a URL, which is what we're going to be using is this URL property. Awesome. can delete these comments here, if you remember back from the demonstration of what this meme generator will look like, there's going to be two input boxes here that allow you to input the top text and the bottom text on the image. So what I'm going to do now is just stub out a form. And then I'll have you create the input boxes. So I'm going to wrap everything in a div building a form. And for my styling, I'm going to give this a class name. informer. And we'll create a submit button. It says Jen, all right, and then I'm going to put some comments here for what your task is next. So now that I'm inside of my form element in JSX, in order to write these comments, I have to put the curly braces. So that basically tells the system that I'm back inside of JavaScript, so I can write these comments. So what you're going to do, you can delete this when you're ready, what you're going to do is create two input fields, one for the top text and one for the bottom text. And remember that this form should be a controlled form. So you'll need to add any of the attributes to these inputs that you'll need in order for that to still work. Don't worry at this point about creating your on change handler, because that will be the next thing that you do. So pause now and try this. Okay, so this is just creating two inputs, so we will make two inputs. And save time, I'm going to do this in both places, we will have a name attribute which one of them is going to be top text. And the one is going to be bottom text. In both of these should be a type of text, I will give them a placeholder. So I don't need to worry about having labels. Take up text and say button text. And then for this to be a controlled form, I need to make sure that I set the value equal to whatever the current value of state is. Up text, bottom text. Now the last part that I mentioned you'll be doing next is to write the on change handler. And since these are both text inputs, you won't have to worry about checkboxes or anything like that. So this one should be fairly straightforward reference, let me write the comments up here. Create the unchanged handler method here and it should make sure to update the corresponding state property on every change of the input box. Pause now and do this. Okay, as I mentioned, this is going to be a fairly straightforward one, we're going to have a handle change that will receive an event. And to fix my syntax errors down here, I will add this to this dot handle change. And that method will need to be bound in my constructor. And while we're at it, I'll just put a console log here. See if this is working. Let me get rid of that console log from the means console. And our method is correctly firing. I want to pull the name and value properties from event target so that I can get the name of state that I'm supposed to update top text or bottom text and then whatever is actually typed into the box and I'm going to update my state. Now I don't care about the previous state So I can just provide an object and I can say whatever the name is it the value that we pulled from the box. Okay, and we'll get a chance to see that that's working pretty shortly. If you want, you could pause now and there, right a console log or put something in your render that shows whether or not this is working. But we'll just move on. Next thing I'm going to do is have a place to display our meme. Now remember, we're receiving an array of all the memes that this API has. And what we're going to do is make it so that when they hit the gen button, it just chooses one of those images at random to display in the area below. So I'm just going to build the area below right now. Make it a div. And for my styling, I give it the class name of meme. Have the actual image here. source is going to be what we've saved in state as the random image. And I'll just put an empty alt property for now. And then for the text itself, I'm going to have a couple of H twos which have a class name of up and bottom. And all they're doing is displaying saved in state objects, text and text. Okay, so my image is showing up. This is the random image that we initialized here. And let's see if my text is working. One does not simply walk into Mordor and you'll notice that every keystroke, my text is showing up correctly, which means I'm correctly setting the state on every keystroke. And the time has come for you to do the last challenge of this Capstone. So let me write out some comments. I wrote these purposefully a little bit vague so that you had to think back and look at your notes or go back and look at previous lessons, whatever it might take, going to create a method that when the gen button is clicked, chooses one of the memes from our all memes images array at random makes it so that image that it randomly chose is the one that shows up in our meme display image area down here. Now remember, the property on the chosen image in the array is dot URL. You write that here. That URL is the property that is the string of where the actual image is hosted. This is your final push, give that a try. Okay, so we could make it where I have an onClick handler for my button. But because this button is inside of a form, I personally think it's more semantic to have this be an on submit of the form. We'll call this handle Submit. So this is where we will create that function. Need to grab the event, because we don't prevent the default into try and refresh our page, which will be annoying. So we don't want that to happen. And while I'm at it before I forget, let's bind the handle submit in our constructor. What we have now is just a basic code challenge. Oh, I will just pseudocode some of this, I'll say I need to get a random number, which represents index the array and get the meme from that index. Once I have that meme, I'm going to set my random image property to the URL the random item I grabbed. I've broken this problem into smaller parts, we're going to get a random number so that I can make sure that it's one of the indices in our array. We'll make sure that I multiply whatever the random number I get by the length of the meme images array. And now that I have that random number, it should be easy to get a random meme just just the index of the all meme images Random number that we just got. And all I'm concerned with is the URL property. So I'm just going to snag that right now. And I just need to update state now. We'll use set state. I don't care what it used to be. And I know that I'm upgrading the random image property, and the value will be the random meme image. Let's save this and see what we get. Oh, you'll notice that some of these are funnier than others. But point is we have a random meme generator, we've written the top text, the bottom text, it's randomly choosing from the array of images that we pulled from the database online, we now have a completed meme generator. Just because I'm OCD about this stuff, I'm going to get rid of these comments. This would be a perfect time to check this code out, see if you can play with it make a better one, be try to get the gist from a different API. And although it sounds really obnoxious, one of the best things that you can do to practice stuff like this is delete all of this code and try it again from scratch. Feel free to take a break at this point, you've really accomplished a lot of great things by following through this course and learning the things that you've learned, I have just a few more topics that I want to cover before we finish up this course. Oh, as always, when you're ready, let's move on. Because react is maintained by Facebook, and quite a few developers over at Facebook, as well as the open source community react is progressing really quickly. If you've ever tried to watch tutorials of react from more than maybe two years ago, you might notice that it's quite a bit different now than it used to be. And we even had a lesson on how react version 16.3 introduced some new lifecycle methods and also started the process of deprecating some other lifecycle methods will react 16.6 was just released. And there's even more new functionality now and a lot on the horizon for react version 17 and onward. So I thought I would make this quick lesson about some of the more modern features that you can use when you're creating react apps. And a lot of these features will work or won't work, depending on which versions of ACMA script you're supporting in your project. But as long as you're using a transpiler, like Babel, you'll be able to use pretty much the most modern versions of ECMO script and therefore use some of these things. Now, I didn't do enough research to know which of these are just experimental or which of these are definitely going to be included in reactor in JavaScript in general. So you may want to just be aware that any one of these at any given point may just disappear and not work anymore. But it's pretty widely used. And I'm fairly certain a lot of this will be included inside of either react or JavaScript itself. Now one of the major changes is that our methods can be written as arrow functions. And I believe that scrim that may complain a little bit about this. But if you're doing this in your own environment, this should be okay. I can change this to be an arrow function, which looks like a very small change. But in fact, what it does is it gives it a lexical this inside, which means that it doesn't create its own this context, but instead uses the this of its surrounding environment. Basically, what this means is I no longer have to bind my methods in the constructor anymore. So I could get rid of this. And because this is an arrow function, and it's using the this from the class, everything should just continue to work. So that's a really easy and convenient update that you can make to your class methods. Now, another one that's a little more dramatic, but also really nice is the ability to create class variables, just like we're doing here with this dot state. But doing so outside of a constructor, so I can create this class property by simply saying state equals an object. And I guess in this case, to be consistent, we would have a first name, which is an empty string. And doing this essentially allows me to get rid of my constructor entirely. The last time I checked, this was still a proposal in JavaScript, but it looked like it was heading towards being included into the language as a permanent resident. So I haven't researched this recently, but just take this with a grain of salt and know that again, this may not be included, but it's looking like it will be we can simplify this a little bit, since it's just a one liner. So those are both really nice, fairly simple changes that we can make. I mentioned once again, the changes to the lifecycle methods, I created a lesson that you've probably already gone through that talks about some of those new lifecycle methods. So if you need a refresher, go back, watch those again. But Down here at the bottom, I've included some resources to some of the more either advanced react topics or brand new react topics. So for example, in react 16.3, they introduced a kind of public non beta version of their context API, I've had a chance to play around with the context API, and I'm a total convert. In fact, a Wii school, we have opted to drop Redux in our curriculum, and OPT instead for using the context API. And there's a number of reasons to do so that doesn't mean that Redux no longer has a place. But for our purposes, the context API does everything we want, and it's quite a bit simpler to learn. And then there's some advanced react topics such as air boundaries, render props, higher order components. All of these can be found directly inside the React docs, which you can see all of the links here just go directly to the React docs. And in fact, in the menu bar, they're all part of an advanced react sub section, that would be a really great resource for learning more. I've also included here, a link to the React router homepage, the React router is a great way to make single page applications using a very declarative library, which is react router. It's very widely adopted and used in most larger applications that are single page applications. Then, at the time of this recording, these topics react hooks react, lazy, memo, and suspense are all brand new additions to react. I haven't looked too much into lazy and memo. But I know suspense has to do with asynchronous loading. And hooks have to do with a way of essentially including and modifying state in a functional component. And in fact, if you look at some of these changes that react is making, it's looking like they're heading towards a place where react will almost completely be written in functional components. And class based components will not officially be deprecated. I think they even say in their docs that there's no plans to remove class based components. But it seems pretty clear that they're moving in a direction that they are encouraging the use of functional components more and more. Hopefully, I'll get a chance to update this course, to include some more topics as they become released. And as I become more familiar with them, but for now, just know that react is changing constantly. And it's always a good idea to be checking the change log to be engaged in your community and watching for these changes, because it can be really beneficial to you and your career to be up to date on the most advanced and most modern react features. So we just went through and created the meme generator together. And before that, we had done a multi part series on creating a to do app, but to do apps, honestly, are pretty boring. And the more you do them, the more boring they get. And so I decided to include here some resources that you might use to come up with ideas for apps that you might want to build yourself, I was going to come up with a list of my own ideas. And then I came across Free Code camps lists that they have built over the years. And each one of these is an entire blog post with a whole bunch of different ideas that you can use. So I would honestly just recommend visiting these websites, reading through the ideas that they have, and either picking one or using that as inspiration for ideas for you to come up with. Alright, you've made it. Now there is so much more to learn about react. But you now know all the building blocks, you need to start building react apps for yourself. So let's look at a quick summary of the core concepts we've talked about in this course, we talked about JSX, and how it's a wrapper around JavaScript that allows you to write your UI using a familiar syntax. html, we noticed that there were a couple slight differences here and there. But for the most part, it helps writing components feel very familiar. We talked about two different kinds of components that you can make a functional component and a class component and what each one of those is capable of. Basically, if you need state or lifecycle methods, you will have to use a class based component. Otherwise, it's a pretty good practice to just stick with a functional component. In fact, going forward react is kind of looking like there'll be releasing features that allow everything to be written as a functional component if you want. We talked about some basic ways to style react. If you're using CSS classes, you'll need to use class name inside of your JSX in order to assign a class to that element. Or you could write your CSS as a style object directly in your JavaScript, which can be helpful if you need them to be dynamic, or you just generally prefer to style right there inside your component. We talked about props which are the primary way to pass data down the component tree and we covered state, which allows your components to hold on to and modify the data. Anytime you want to change state you'll need to use these sets The method, we talked about conditional rendering, using various vanilla JavaScript techniques, you can determine which parts of your UI you want to show up at any given time. And oftentimes, this is done based on some variable that's held in either state or props. And we spend some time learning about forms in react and how to gather input from users in form elements. And there is so much more about react that I would love to cover, but we're going to have to save all that other good stuff for another course. For now, thanks so much for letting me guide you through learning one of the best frameworks out there.
