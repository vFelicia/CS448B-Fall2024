With timestamps:

00:51 - SPEAKER 1: This is CS50,
and this is week 1.
00:54 - And by the end of the
day, you will know how
00:57 - to create programs that look like this.
01:00 - So this, of course, is binary.
01:01 - This is the only language that
machines ultimately understand.
01:04 - But thankfully, per last week,
there's so many abstractions
01:07 - and there are so many humans that have
come before us that we don't actually
01:10 - have to write anything at this level.
01:11 - We can abstract way above it
like we did with Scratch already
01:14 - and like we will starting today with C.
01:17 - But does anyone nonetheless
want to take a guess
01:19 - at what that program, when fed
to your Mac or PC, actually does?
01:26 - Anyone recognize?
01:29 - Anyone want to hazard a guess?
01:31 - It's perhaps the simplest
program you could write.
01:34 - Indeed, it does, when fed to
the brain of your computer,
01:38 - the so-called CPU simply prints that.
01:41 - So how do we actually get to that point?
01:43 - Well, recall where we started
this conversation last time
01:45 - talking about computer
science more generally
01:47 - and problem solving-- we proposed
could be distilled really is this.
01:50 - You've got some inputs.
01:51 - You want some outputs.
01:52 - And somewhere in the middle, you need
to do something with those inputs.
01:55 - And to get to that point, though, we had
to represent those inputs and outputs.
01:59 - We just had to decide as humans, how are
we going to represent all of the inputs
02:03 - to our problem when it comes time to
have a computer actually process them.
02:07 - And at the end of the day, all of the
phones and the computers that we're all
02:10 - using only at the end of
the day plug into the wall
02:12 - to get their physical
resource, electricity,
02:15 - and they might store that
temporarily in a battery.
02:17 - But that really is our only input.
02:18 - It's either plugged in or it's not.
02:21 - It's either a 1 or a 0, true or false.
02:24 - So the world really reduces to
those two states, so to speak.
02:27 - And so you can think of those states
then as just being like a light bulb,
02:30 - on or off.
02:31 - I pulled up my cell phone last time
to turn the flashlight on or off,
02:34 - 1 or 0, true or false.
02:36 - Now of course, if you
only have one light bulb,
02:38 - you can only count from 0 to 1.
02:41 - But if you start to have a bunch of
them back to back to back to back,
02:44 - you can permute them
like I did my finger--
02:46 - 0, 1, 2, 3, and so forth.
02:50 - And so we started talking
about binary more generally.
02:53 - And so here for instance
were three sequences
02:57 - of 0's and 1's and each of
those represented something,
03:00 - but we don't need to think
about the world at that level.
03:03 - We can abstract on top of that.
03:04 - All of us are so much more
familiar with decimal of course,
03:07 - and indeed recall that this was just
72, 73, and 33, which if anyone recalls,
03:12 - when you use ASCII--
03:13 - which is this global
standard for mapping numbers
03:15 - to letters-- we got what message?
03:17 - Yeah, it was just high, capital
H capital I exclamation point.
03:21 - And so that's an abstraction on top
of those otherwise binary numbers.
03:25 - But we don't have to model
just text using numbers.
03:28 - At the end of the day, our only
resource is still that electricity,
03:31 - and the only way we think about it
digitally is still zeros and ones.
03:34 - But if we take the same value--
03:35 - 72, 73, 33-- and treat them
in the context of Photoshop
03:41 - or a photo program or
a graphics program,
03:42 - we can instead interpret
them as like some amount
03:45 - of red, some amount of
green, some amount of blue,
03:47 - which gave us last time,
recall, this yellowish color.
03:50 - So now we had another abstraction
on top of binary colors,
03:53 - and this is just one pixel.
03:54 - What can you do once you
have more than one pixel?
03:57 - What can you represent next?
03:59 - Yeah, right, images.
04:01 - So we're continuing the
conversation up and up and up,
04:03 - and we could represents something like
a graphical emoji on the screen, which
04:06 - has more than just one yellow dot.
04:07 - It's got a whole bunch of yellow
dots and other colors as well.
04:10 - And recall that, if we
want to animate things,
04:13 - whether it's through silly things like
animojis on a phone or just more proper
04:16 - videos and movies, well,
those are just sequences
04:20 - of images flying past your
human eyes really quite quickly.
04:23 - So that's where we kind of left off
last time starting at the base level
04:26 - and abstracting away so that we
could stipulate thereafter we
04:29 - can represent inputs,
and we can represent
04:33 - outputs, whatever those happen to be.
04:34 - And here on out, we don't
need to think at that level.
04:36 - We can just assume we
all know how to do this.
04:38 - And even if it eventually
becomes kind of a distant memory,
04:41 - we know that someone can indeed do this.
04:43 - And that's the value of abstraction.
04:45 - But inside of this black box
are so-called algorithms,
04:48 - the secret sauce--
04:50 - this is where the problems
are actually solved.
04:52 - And we not only talked about what
these algorithms are, but for instance,
04:57 - how efficient they were.
04:58 - So recall that this red line represented
a very simple algorithm just turning
05:02 - the phone book page
by page one at a time.
05:04 - And the reason that it's a straight
line is because there's a one to one
05:07 - correspondence between how many
pages there are in the book
05:10 - and how many page turns there are--
one page, one more page, one more
05:13 - turn, and so forth.
05:14 - If I fly through it at twice the speed--
05:16 - 2, 4, 6, 8--
05:18 - I can do better.
05:19 - And so that yellow line now,
recall, was lower on the graph.
05:23 - If you just look at any
two points, yellow and red,
05:25 - yellow is below red,
saying it takes less time.
05:28 - But it was not quite correct.
05:30 - There was one bug when I was looking
for Mike two pages at a time.
05:34 - What was that issue?
05:36 - Yeah, I might miss him.
05:37 - He might accidentally get sandwiched
in between two pages-- not a huge deal
05:40 - because I could fix it,
but I have to fix it.
05:42 - I have to apply that additional
logic and double back
05:44 - at least a page if I go too fast.
05:46 - But of course the final algorithm-- and
frankly all of our initial intuition
05:50 - probably-- was the dividing and
conquer, open it roughly to the middle,
05:54 - look down, and then
go left, and go right,
05:56 - and just repeat that
process as the problem gets
05:58 - this big to this big to this big
to this big to just one page left.
06:01 - So that was all about efficiency.
06:04 - But to get to that point we needed
to express ourselves more precisely.
06:07 - And so we introduced pseudo code.
06:09 - There's no formal definition.
06:10 - It can be English, English like.
06:12 - It's just meant to be succinct
and get the point across.
06:14 - And recall that, along the way, we
introduced a whole bunch of concepts,
06:17 - many of which you probably
experimented with Scratch, like loops
06:21 - and conditions, Boolean expressions,
variables, and so forth.
06:25 - And those were building blocks that came
out of this kind of demonstration here.
06:30 - But honestly, even in this
demonstration, in this pseudo code,
06:33 - there were a whole bunch of assumptions.
06:35 - If you read these
instructions one at a time
06:37 - and you're holding the
phone book yourself,
06:39 - odds are you can execute this
pseudocode, this algorithm.
06:42 - But what does it really mean to, say,
open to the middle of the phone book?
06:47 - All of us have an intuitive
understanding of what that means.
06:50 - But honestly, if you
were explaining that
06:52 - to a kid or someone who's learning
English or whatever language
06:55 - for the first time, open to
the middle of the phone book,
06:57 - you should probably sets
forth some assumptions.
06:59 - OK, this thing in front of you
has 1,000 pages, pieces of paper.
07:03 - Turn to the 500th page, and
let's call that the middle.
07:06 - This would very quickly get
tedious if all of us humans
07:09 - are talking at that level of detail.
07:11 - And so we abstract
away with more sweeping
07:13 - statements like open to the
middle of the phone book,
07:15 - but that's an abstraction.
07:17 - And it's not quite as
precise as is probably ideal,
07:19 - especially feeding this algorithm to
a newbie or to a robot or a computer.
07:24 - But it's useful because we can then make
a 12 step program instead of a 20 step
07:27 - program by elaborating too much.
07:29 - And for instance, throughout here
too we had our loops and conditions
07:32 - and so forth, but even call Mike.
07:34 - What does that mean?
07:36 - Well, if you imagine that the
human knows how to use the phone,
07:38 - then it goes without saying.
07:39 - But if he or she also needs to
be programmed to use the phone,
07:42 - you've got to explain-- pick
it up, hit this button, type
07:45 - this sequence of buttons, and so forth.
07:47 - So call Mike is also an abstraction.
07:50 - So these abstractions are useful, but
they can sometimes get in the way,
07:54 - especially if you're not precise enough
to program the computer correctly.
08:00 - And to paint this picture, I thought
we could begin a little heartedly here.
08:06 - I brought some breakfast, if you didn't
quite make it next door or beyond.
08:09 - Just need a couple of
volunteers if you're
08:11 - comfortable appearing on stage
and on the internet here.
08:14 - Let me kind of-- there's
a lot of lights here.
08:16 - How about over there on the
left and over here in the front?
08:20 - Yeah, right there.
08:20 - I think your hand was up.
08:21 - Come on down.
08:23 - And Brian, do you mind
lending us a hand here, too?
08:26 - Come on down.
08:28 - If you want to take control
here, let you go ahead
08:31 - and switch over to
another program for you.
08:35 - What's your name?
08:36 - JEAN: Jean.
08:36 - DAVID: Jean, David.
08:37 - Nice to meet you.
08:37 - Have a seat on the far left.
08:38 - And your name?
08:39 - ABBY: Hi, I'm Abby.
08:40 - Nice to meet you as well.
08:41 - On the far right if you could.
08:42 - So Jean and Abby, do you want to say
a little something about yourselves
08:46 - quickly?
08:47 - JEAN: I'm Jean.
08:48 - I'm a Massachusetts native, and
I'm taking CS for the first.
08:52 - It's my first coding or anything.
08:54 - Or I'm doing and I'm enjoying it.
08:56 - DAVID: Nice, glad to have you with us.
08:57 - And Abby?
08:59 - ABBY: Hi, I'm Abby.
09:00 - I'm taking this as a
sophomore, and I know nothing
09:02 - about computers or computer science.
09:04 - So I'm probably taking it stat on stat.
09:06 - DAVID: OK, well, nice
to have you as well.
09:08 - So in front of us is a
whole bunch of ingredients,
09:10 - and hopefully we can start
this semester off gently.
09:12 - And if we're successful, we'll
actually have a quick bite here.
09:15 - But we thought we'd defer
to the audience here,
09:17 - and Brian's going to scribe as we go.
09:18 - And all we want to do
this morning is just
09:20 - make a peanut butter and jelly
sandwich, one instruction at a time.
09:24 - And each of us will just
execute what we hear.
09:26 - How does that sound?
09:27 - All right, if someone could volunteer
with the first instruction and Brian
09:30 - will type it down.
09:33 - AUDIENCE: Open bread.
09:36 - DAVID: Open bread we heard.
09:37 - Open bread is the first instruction.
09:38 - So each of you would like
to execute open bread.
09:46 - No, don't look at me.
09:50 - All right, so we're kind of on our way.
09:56 - I think Abby did it better certainly,
but we did it correctly arguably.
10:00 - So let's move on to step 2
and see if we can't improve.
10:04 - Take out bread.
10:11 - Welcome to the team now.
10:14 - Nice, all right, step three.
10:16 - Yeah.
10:17 - AUDIENCE: Place two pieces
of bread on the table.
10:19 - DAVID: Place two pieces
of bread on the table.
10:26 - Never mind the plates.
10:27 - OK, step four.
10:30 - AUDIENCE: Twist cover
of jelly till it opens.
10:34 - DAVID: Twist cover of
jelly till it opens.
10:36 - Thank you.
10:41 - Step five?
10:45 - Step five?
10:45 - Yeah?
10:46 - AUDIENCE: Place the lid to the side.
10:48 - DAVID: Thank you.
10:49 - Place the lid to the side.
10:51 - I took some liberties myself.
10:52 - AUDIENCE: Take the knife.
10:53 - DAVID: Take the knife.
11:00 - Peel off the cover of the jelly.
11:06 - No covers on ours.
11:11 - Stick knife into the bottle?
11:16 - From the top.
11:18 - Stick-- step nine.
11:24 - AUDIENCE: Rotate hands
so jelly ends up on.
11:27 - DAVID: Rotate hands
so jelly ends up on--
11:35 - OK, step-- quickly--
11:37 - 10.
11:41 - Yes, step 10?
11:43 - AUDIENCE: Pull out knife.
11:45 - DAVID: Pull out knife.
11:46 - OK, step 11.
11:52 - Jelly side down on bread.
12:01 - All right, step 12.
12:08 - Step 12, anyone?
12:10 - Yes.
12:11 - Thank you.
12:14 - Step 13.
12:18 - Pour jelly on bread.
12:24 - JEAN: Pour jelly--
12:25 - DAVID: Pour jelly, jelly.
12:27 - All of it?
12:28 - OK, now you're just messing with us.
12:35 - Step 14.
12:38 - AUDIENCE: Put jelly down.
12:39 - DAVID: Put jelly down.
12:40 - Thank you.
12:42 - 15?
12:44 - Pick up peanut butter.
12:46 - AUDIENCE: Take the lid off.
12:47 - DAVID: Take lid off.
12:48 - Thank you.
12:52 - Peel off lid.
12:54 - Thank you.
12:57 - Step 18?
12:59 - Pick up knife by blunt end, scoop.
13:13 - Scoop.
13:14 - Step 20?
13:18 - Put peanut butter on bread?
13:25 - 21?
13:26 - AUDIENCE: Move the knife left to right.
13:27 - DAVID: Move-- move the
knife left to right, please.
13:31 - Left to right.
13:37 - Step 22?
13:41 - AUDIENCE: Put down knife.
13:42 - DAVID: Thank you.
13:43 - 23?
13:44 - AUDIENCE: Put down jar.
13:46 - DAVID: 24.
13:48 - What was that?
13:53 - Eat sandwich.
13:54 - OK, I think we're--
13:56 - well, why don't each take a bite?
13:58 - And a round of applause, if
we could, for our volunteers.
14:06 - Thank you.
14:09 - ABBY: Mind if I take some for the row?
14:11 - DAVID: You can take some
for the row if you'd like.
14:14 - Thank you.
14:14 - So-- thank you, Brian.
14:17 - OK, now I need a minute.
14:21 - Thank you.
14:22 - So suffice it to say, this
obviously demonstrated even more so
14:28 - than the phone book example
where our certain assumptions are
14:31 - and our abstractions are.
14:33 - And honestly, almost all
the time those are useful.
14:35 - And of course, we kind
of hammed things up.
14:36 - And I think the instructions were
kind of helping with that here.
14:39 - But when it comes time to program
with Scratch and certainly with C
14:42 - starting this week, you can't really
make as many of those assumptions
14:45 - anymore because, if you don't
handle these corner cases
14:48 - and if you don't think about
what that instruction means,
14:51 - you're going to get the proverbial
spinning beachball or the hourglass
14:54 - that you're familiar
with on your Mac or PC.
14:55 - The program is going
to crash, something's
14:57 - going to go wrong just because you
miss some specificity or precision.
15:02 - Now we're full of peanut butter.
15:04 - So over time, we're going to
find that, much like in Scratch,
15:08 - we were able to make
our own building blocks.
15:10 - You might recall the short examples
we did with the cough example
15:14 - where I had cough 0 and
then cough 1 and cough 2
15:16 - where I was making my own
puzzle piece within Scratch.
15:19 - That was useful because, after
that example theoretically,
15:21 - I never again need to think about or
worry about how to implement cough.
15:26 - I can just use that abstraction.
15:27 - But someone has to implement
them, and sometimes it's
15:29 - going to be other people
who have come before us.
15:31 - And sometimes it's going to be us.
15:33 - So this isn't to say that
programming ends up being so tedious
15:36 - that you have to point
out every little thing,
15:38 - but you or someone does have to do
that level of precision at least once.
15:42 - And nicely enough in Scratch, MIT
did most of that legwork for you.
15:46 - We all had the building
blocks with which
15:48 - to make our own animation or
game or artwork or the like.
15:51 - But even then, you probably had to
connect several dozen puzzle pieces
15:54 - or even more to get
those fundamentals to do
15:56 - what it is that you wanted it to do.
15:59 - So today we're going to start
to transition from Scratch,
16:01 - this graphical programming language,
that while targeted at younger
16:04 - students, is typically
representative of a lot
16:07 - of the same concepts that are now going
to be laced throughout the semester.
16:10 - But we're going to introduce today an
older, more traditional language that's
16:13 - just text based.
16:15 - And as such it's a lot more powerful.
16:16 - But at first glance, it's actually
going to look a lot more cryptic.
16:19 - In fact, instead of writing
zeros and ones starting today,
16:23 - we're instead going to
write something like this.
16:25 - Now if you've never programmed
before, odds are, at first glance,
16:28 - this does look pretty
cryptic, and there's
16:30 - a lot of symbols within it,
punctuation from the keyboard.
16:33 - There's probably some
familiar English like words.
16:36 - And frankly, even after doing Scratch
anyone, even with no prior background,
16:39 - can probably hazard a guess as
to what this program written
16:43 - in this other language called
C does when you run it.
16:46 - It just prints hello world.
16:48 - Now granted there's a decent
amount of overhead syntactically.
16:51 - There's a bunch of stuff
you have to type to make
16:53 - this program do what you want it to do.
16:55 - But at the end of the day,
that's all it's going to do.
16:58 - And this is among the
simplest of programs
17:00 - we're going to add to
our puzzle pieces, so
17:02 - to speak, today and see
some of those same concepts
17:05 - that we saw last time as well.
17:07 - So let's do this first though.
17:09 - Let me take a moment
to compare Scratch to C
17:12 - because the most important
takeaway for today
17:14 - is going to be that, even if the
syntax doesn't look so obvious--
17:17 - and frankly, even if your
first minutes or hours
17:19 - with writing your own code in
C is frustrating because, oh,
17:22 - dammit, you left off
a semi-colon or, oh,
17:25 - I had a parenthesis in the wrong place.
17:26 - There's a lot of these
stupid syntactic hangups
17:28 - that make you feel quite often
that you really aren't getting it.
17:31 - But that's not the important stuff.
17:32 - A lot of the syntax is
the least important.
17:35 - That's not at all fundamentally
intellectually interesting.
17:37 - So try to see past that, and
try to take comfort in the fact
17:40 - that it's the principles that
are going to be important.
17:43 - And honestly, just muscle memory
and practice, all of the other stuff
17:47 - that at first is going to be
an occasional frustration,
17:49 - it just starts to go
away as you start to see
17:51 - this for what it is
and not for the syntax
17:54 - alone that you see on first glance.
17:56 - So this is to say this
program on the right in C
18:01 - is equivalent to what we did just a week
ago with two puzzle pieces in Scratch.
18:04 - Now there isn't going to be a
green flag on my Mac or my PC
18:07 - as we move forward that
you can just click.
18:09 - We're going to run these programs
in a little different way,
18:11 - but that's all the code
on the right is doing.
18:13 - It's equivalent to the code on the left.
18:15 - So let's do this again and again
for just a few of those concepts
18:17 - from last time, and then we'll start
writing some of our own programs.
18:20 - So this was an example, this purple
block, of what concept in programming?
18:26 - Yeah, a function.
18:27 - So it was a verb.
18:27 - It was an action, and we're going
to call those generally functions.
18:30 - They just have functionality
built into them.
18:32 - So how do we do this in C?
18:33 - Well, you might remember
from just a moment ago,
18:35 - because one of the lines of
code was representative of this,
18:38 - it had some of this syntax.
18:39 - So in fact, if I were
to translate the block
18:42 - on the left in Scratch to the
equivalent code in this other text based
18:45 - language called C, I'm going
to start by writing print
18:47 - and then open parenthesis
and then close parenthesis.
18:50 - And those parentheses represent the
oval, the white oval on the left,
18:54 - that we typed hello world into before.
18:56 - Now in C, it's not quite
as literal as that.
18:58 - The function, or the verb,
is actually not called print.
19:01 - It's called printf, and
the F stands for formatted.
19:04 - And it just means that
in C you can actually
19:06 - format your text in different ways.
19:08 - So we'll see that before
long, and it turns out
19:10 - that you don't just write hello
world between those parentheses
19:13 - like we did in Scratch.
19:14 - You also actually have to surround
them with double quotes in C.
19:18 - Not such a big deal, but something
you didn't have to do before.
19:20 - But in C, you're also
going to generally want
19:23 - to be super specific to the computer.
19:26 - And when you want the cursor
the text on the screen
19:28 - to move down to the next line,
you need to tell the computer that
19:31 - by literally typing backslash n.
19:33 - The human is not going to
see a backslash and an n.
19:36 - He or she is actually going
to see the cursor move
19:38 - to the next line of the
screen like in Google Docs
19:41 - or in Microsoft Word or the like.
19:42 - But this just speaks to
the precision that you
19:45 - need to have when talking
to a computer at this level
19:47 - and not just with the puzzle pieces.
19:49 - And then one last thing--
and I alluded to it earlier
19:51 - because it's the bane of a
lot of programmers early on.
19:54 - Most lines of code in C
have to end in a semi-colon.
19:58 - That's the sort of code equivalent
of a period in an English
20:01 - or some other languages sentence.
20:02 - So that's it.
20:03 - It took us a little
while to build that up.
20:05 - But that's all it is.
20:06 - The idea on the left of saying
something is the same in C
20:09 - as printing something with
this function called printf.
20:12 - And before I forge ahead
with some other comparisons,
20:15 - any questions on just this translation?
20:18 - AUDIENCE: How do you write backslash n?
20:20 - DAVID: How do you write backslash n?
20:21 - Good, so thinking ahead, this would
seem to make it hard to literally show
20:25 - the user backslash n.
20:27 - Well, it turns out that this
backslash, because it's not
20:30 - a terribly common character,
the programming world
20:33 - uses it as what's called
an escape character.
20:35 - It's one that you use when you want
to escape information and show it
20:38 - in a slightly different way.
20:40 - So the way you would show
literally to the human
20:42 - a actual backslash n is
to actually in your code
20:46 - do backslash backslash n
because the second backslash is
20:50 - like saying treat the
next character special
20:53 - and actually show it to the human.
20:54 - And there's other such examples of that.
20:56 - So how about this one?
20:57 - This orange block was an example
of one concept in Scratch?
21:02 - Yeah, so this was a variable,
like an x and y in algebra.
21:05 - This was just a placeholder for
data, and you could store numbers.
21:08 - It turns out you can store words.
21:09 - You can store other things
too in other languages.
21:12 - So in C, we're going to do this.
21:14 - We're going to say, literally, the name
of the variable we want-- for instance,
21:16 - counter.
21:17 - But we could call anything we want--
21:18 - equals zero if we're setting
it initially equal to zero.
21:22 - But C is a little more pedantic.
21:24 - You've also got to tell the
computer, the type of variable I want
21:27 - is specifically for an integer,
otherwise abbreviated int.
21:31 - So you have to tell the computer
in advance what type of data
21:33 - you're going to store on it.
21:35 - And take a guess.
21:35 - You've got to finish the thought ion
C. What more do we need to add to the--
21:40 - yeah, just a semi-colon.
21:41 - And that's it.
21:41 - It looks a little more cryptic, but
the idea is fundamentally the same.
21:46 - So what if we wanted
to do this in Scratch?
21:48 - Change counter by 1-- this was
equivalent to incrementing or adding 1
21:52 - to counter.
21:53 - Well, let me go ahead and propose
that you could literally just
21:56 - do this in C. Set counter equal to
whatever counter currently is plus 1.
22:03 - That seems to be the right intuition.
22:04 - And now notice, what's
key to note here is
22:07 - that this equal sign isn't saying
that counter equals counter plus 1
22:12 - because that just doesn't seem possible.
22:14 - If you pick any value for
counter, like the number 1,
22:17 - well, one definitely does not
equal 1 plus 1, which is 2.
22:21 - And 1 does not equal
2, and you can come up
22:23 - with an infinite number of
worrisome incorrect comparisons.
22:27 - So the equal sign in C, like a lot
of languages we'll see in the class,
22:30 - actually means assignment.
22:31 - Copy the value on the right
into the value on the left.
22:35 - So set counter equal to
whatever it is plus 1.
22:38 - What?
22:38 - We've got to finish the thought.
22:40 - So we need a semi-colon.
22:42 - I don't though need to remention
int, and why might that be?
22:47 - Yeah, I already told the
computer it's an integer.
22:49 - You don't need to repeat
yourself by mentioning int again,
22:52 - assuming in this context, even though
we're looking at it just on the slide,
22:55 - has actually been created
before just like you did
22:58 - with Scratch by saying make a variable.
23:00 - So it turns out you can be a little more
succinct in C and a lot of languages.
23:04 - If you find this a little tedious
to type-- and it's a little verbose.
23:07 - It's a bunch of keystrokes.
23:08 - You can actually abbreviate
it with just this.
23:10 - So plus equals is just syntactic
sugar, as a programmer would say.
23:15 - It's just a nice fancy feature that
lets you write fewer words or characters
23:18 - but do the same thing.
23:19 - And frankly, we can do a little better.
23:21 - And if you've taken a PCS, you might
have seen this in Java as well.
23:24 - You can also simplify this even more
to just counter plus plus semi-colon.
23:29 - So that's it-- all equivalent.
23:30 - This is just a little more efficient.
23:32 - And as you get more
comfortable programming,
23:34 - saving keystrokes just saves you time.
23:35 - Now this of course was an example
of what in Scratch by contrast?
23:40 - Yeah, we called this a condition.
23:41 - And it had a Boolean expression
that we were asking a question of.
23:45 - In this case, we're apparently asking
in Scratch is x less than y and, if so,
23:49 - say it on the screen.
23:50 - So how might we translate this to see?
23:52 - Well, it turns out we can quite simply
translate this one pretty literally.
23:56 - We've seen almost all of the
building blocks thus far,
23:58 - but we do have to introduce
a little something new here.
24:01 - Notice that the printf line
is almost identical to what
24:04 - I used earlier for just hello world.
24:05 - I've obviously just changed the words
in it, but I still have the backslash n.
24:09 - I still have the quotes,
still have the semi-colon.
24:11 - So the rest of that is the same.
24:13 - Now if is new, but this is
a one to one translation.
24:16 - Scratch calls it if.
24:17 - C calls it if.
24:18 - And the only additional
thing you need in C
24:20 - is parentheses around
the Boolean expression.
24:22 - So that's what takes the place
of the little green block there.
24:25 - And then assuming x and
y are indeed variables
24:28 - that we created earlier, you
can just compare them like this
24:31 - and you can use greater than and
other symbols for comparison as well.
24:34 - But there is something a little
interesting, and most of us
24:36 - don't often have occasion to even
use these keys on our keyboard.
24:39 - Curly braces, on a US
keyboard they tend to be
24:42 - over on the top right
above your Enter key.
24:44 - These are just C's
equivalent of this shape.
24:49 - Notice that most of the
yellow blocks in Scratch
24:51 - had this embracing or this
embracing shape to them.
24:55 - You can simulate that in C by having
what's called an open curly brace
24:59 - and then a closed curly brace.
25:00 - So that's the same exact idea.
25:01 - Now as an aside, you don't technically
always need these curly braces.
25:05 - If you just got a one
liner like this, you
25:07 - can omit them as you might
see online or in textbooks.
25:10 - But we'll just always draw them for
consistency so that the C code always
25:13 - looks like this.
25:16 - What if you wanted to
express this, though?
25:19 - If x is less than y, then say x is less
than y, else say x is not less than y.
25:24 - Well, it turns out this
is almost identical.
25:27 - The first four lines,
perfectly the same as before.
25:30 - But it turns out in C,
you can literally say else
25:33 - after that closing curly brace.
25:35 - And then just print out alternatively
whatever it is you want to say.
25:38 - So this is like the fork in the road.
25:40 - If you go one way, say this.
25:41 - If you go the other way,
say this other thing.
25:44 - Any questions on these
comparisons thus far?
25:46 - Yeah.
25:47 - AUDIENCE: Should we put the first
bracket on the same line as the if?
25:52 - DAVID: Really good question.
25:53 - Can you or do you put the curly
brace on the same line is the if?
25:56 - You can, and we're going to talk
about this the next couple of weeks,
25:59 - this matter of style.
26:00 - There are different ways I could
express this exact same code.
26:03 - Frankly, I could write out all of
this code with no spaces whatsoever.
26:08 - In fact, just to make that point, if I
go ahead and just open up a simple text
26:13 - editor here--
26:13 - not to actually program,
but to just type something--
26:16 - I could actually do something
like this if x less than y.
26:21 - Then go ahead and print out x is less
than y backslash n semi-colon curly
26:28 - brace else print and so forth--
26:30 - completely unreadable at the end
of the day or unmaintainable,
26:33 - especially when the
code gets complicated.
26:35 - But whitespace does not tend
to matter to the computer,
26:37 - but it does matter to the human.
26:39 - And as you're alluding
to in some languages,
26:41 - it's actually conventional to
do this, where you actually
26:44 - keep the curly brace on the same line.
26:46 - And indeed, you might see
textbooks do this as well.
26:49 - Some people will even do this.
26:51 - These are all long story
short matters of style.
26:53 - In CS50, in the earliest
weeks of the class,
26:56 - we're going to insist that
everyone follow the same style so
26:58 - that we have some basis for comparison.
27:00 - But eventually, this
is the kind of thing
27:02 - that, like in your own English
writing or whatever language you
27:05 - tend to write in, you have your own
stylistic or linguistic flair to it.
27:09 - Code has that as well.
27:10 - Other questions?
27:12 - Yeah.
27:13 - AUDIENCE: When you establish
the counter-variable,
27:16 - do you always have to
say what it is equal to,
27:19 - or can you just say int counter section?
27:21 - DAVID: Really good question.
27:22 - When you declare a
variable, create a variable,
27:25 - do you have to set it equal
to something right away?
27:27 - Short answer, no.
27:28 - And we'll see examples of that
before long, where you can actually
27:31 - say give me a variable called
counter, but don't actually
27:34 - set it equal to some value.
27:36 - Come back to that in a bit.
27:38 - So what if we want to add this logic?
27:40 - Frankly, in Scratch it's starting
to look a little overwhelming.
27:43 - But this is just a three
way fork in the road.
27:45 - If x is less than y, say so,
else if x is greater than y,
27:50 - say so, else if x equals y, then
go ahead and say they're equal.
27:56 - And in C, we can do this
translation pretty directly as well.
28:00 - In fact, now the first
eight lines of code
28:02 - are identical to before
except this middle one
28:05 - here where I'm adding a
second Boolean expression.
28:07 - Is x greater than y?
28:09 - And then I have this third
condition, else if x equals y.
28:13 - But there seems to be a typo
perhaps or something anomalous here.
28:18 - So anything jump out?
28:19 - Yeah.
28:21 - I have a double equal sign, which
maybe is just a typographical error
28:25 - on my part, but turns out it's not.
28:27 - This is deliberate.
28:29 - But why?
28:29 - This seems like our first example
of where Scratch doesn't really
28:32 - map perfectly to C?
28:34 - AUDIENCE: Well, because the
equal sign is like an assignment.
28:36 - And so counting the equal
sign actively sets it equal--
28:40 - DAVID: Exactly.
28:40 - We already a moment ago decided as
humans-- or really, years ago-- equals
28:45 - is actually in the context of
C going to be assignment-- copy
28:47 - the value from the right
to the value on the left.
28:50 - And so we kind of painted
ourselves into a corner.
28:52 - We still as humans, as
programmers, want to be
28:54 - able to express the notion
of equality and comparing.
28:57 - But if we've already used the
equal sign for assignment,
29:00 - we need another pattern of
symbols to represent equality.
29:03 - And as it turns out, humans just
chose two equal signs instead--
29:06 - so slightly different from Scratch.
29:08 - The reason Scratch does it this
way is because you don't really
29:10 - want to have to get into
those weeds certainly
29:12 - when the target audience
is 8-year-olds just
29:14 - learning to program in the first place.
29:15 - It's not important nor is
it really important for us.
29:18 - But for us there's going
to be a logical difference
29:22 - because, if we use the wrong one,
the behavior is going to be wrong.
29:24 - If we had just one equal sign, we would
literally be changing x to equal y
29:29 - rather than just comparing it.
29:31 - Was there a hand in here?
29:33 - Yeah.
29:34 - AUDIENCE: Just a quick question.
29:34 - So if you wanted to express
greater than or equal to,
29:37 - would you write equal and greater than?
29:39 - DAVID: Good question.
29:40 - If you wanted to express greater than
or equal to, how might you do that?
29:43 - It turns out there are ways to do that.
29:45 - And if I go ahead and just give myself
someplace to draw here for a moment,
29:49 - you can actually indeed do less than
or equal or greater than or equal.
29:55 - There's no way on a typical
keyboard to put them atop each other
29:57 - like you might recall for math.
29:59 - You just put them next to each other.
30:04 - Well, it depends.
30:05 - I want the double equal
sign here because I
30:08 - want to explicitly check this
third case and say x is equal to y.
30:14 - So that was my goal.
30:15 - But logically, this is not necessary.
30:17 - Let's make the program a
little better designed.
30:19 - How many possible cases are there
when comparing two integers, x
30:24 - and y, for greater than,
less than, or equality?
30:27 - Well, I kinda of just answered
the question, didn't I?
30:31 - Three.
30:32 - Excellent!
30:32 - There's three scenarios there-- x
is either less than or greater than
30:36 - or equal to.
30:37 - And I'm hard pressed
to think of a fourth.
30:40 - So do I need this amount of specificity?
30:45 - What could I do to give
myself a slight optimization,
30:48 - improve the code just a
little bit just to save myself
30:50 - a little bit of time writing
it and maybe even the computer
30:53 - a little time running it?
30:54 - Yeah.
30:54 - AUDIENCE: You don't
need the last condition.
30:55 - DAVID: Yeah, I don't need
the last condition because,
30:58 - if we all agree logically that either
x is less than y or greater than y
31:02 - or maybe equal to y, well, if there's
only a third and final case that
31:05 - can just be my so-called else.
31:06 - Just make that be the
so-called default case.
31:08 - And in fact, even though this
is what most people would
31:11 - call an over optimization, you
are saving the computer some time.
31:15 - Because suppose that
x does in fact equal y
31:17 - and they're both the value number 1.
31:19 - So is 1 less than 1 when this
line of code is executed?
31:24 - Yes or no?
31:25 - No, obviously not.
31:26 - 1 is not less than 1.
31:27 - So this code does not execute.
31:29 - But the Boolean expression
is evaluated, so to speak.
31:31 - The question is asked.
31:33 - Is 1 greater than 1?
31:35 - No, and so this code is not executed,
but this Boolean expression is.
31:38 - So we just spent another step or
second or however fast the computer is.
31:42 - Is 1 equal to 1?
31:45 - Yeah, it is.
31:45 - So this actually prints.
31:46 - But to your point, you don't
need to ask that question.
31:49 - And in fact, you just
increased by a factor of 50%
31:52 - how many questions you're asking.
31:54 - So you just wasted a little bit of time.
31:56 - Now as an aside, our
Macs and PCs and phones
31:57 - these days, I mean, again, they're
operating at like a gigahertz
32:00 - speed, one billion things per second.
32:02 - So in practice, who cares if
you're asking that third question?
32:06 - And frankly, if it makes your code more
readable or to your teaching fellow
32:10 - or to a colleague or friend who's
working on the program for you,
32:13 - then that's great.
32:14 - If it's more clear from the code
what's going on, leave it that way.
32:17 - But these are the kinds of design
decisions that we'll now make.
32:20 - And arguably this version of the scratch
program and this version of the C code
32:24 - is just a little better
designed because why
32:26 - write more code than you need
to express the exact same idea.
32:32 - So what about this?
32:33 - This was a loop in Scratch.
32:34 - This was an infinite loop because it
was just forever saying hello world.
32:38 - Now in C, this gets a little
less directly translated.
32:40 - It turns out c uses the key word while.
32:43 - So there is no forever keyword in
C, but there is the word while.
32:47 - And of course, I'm going
to use my curly braces--
32:50 - curly braces, curly brackets to
encompass the following lines of code.
32:54 - The line of code I want in
there is just another printf.
32:56 - So that's the exact same as before, but
it's not sufficient to just say while.
33:00 - It turns out that while wants you
to ask it a question every time
33:05 - the loop executes.
33:06 - And it's going to check that question.
33:08 - And if the answer is yes,
it's going to run the loop.
33:10 - But if the answer being asked
in C is ever no or false,
33:14 - it's going to not execute
the code and it's just
33:16 - going to move on to any further
lines of code lower down in the file.
33:20 - So in C, you actually need a pair
parentheses after the keyword while.
33:23 - And then you need to ask a question.
33:26 - You need to ask a question
like, is x less than y
33:29 - or a question like is x greater
than y or is x equal to y.
33:32 - But none of those scenarios
apply because the whole purpose
33:35 - of this Scratch block is
literally to do something forever.
33:39 - So what's a question we could ask
to which the answer is surely true?
33:46 - Does 1 equal 1?
33:47 - We could contrive an arbitrary but very
met mathematically correct scenario.
33:51 - We can just say just 1 equal equal 1.
33:53 - But it turns out you can be even
more succinct because in C there's
33:57 - a couple of keywords, one of which
is true, one of which is false.
34:01 - And the word true is by
definition always true,
34:04 - and the word false is by
definition always false.
34:06 - So you don't need to contrive
some arbitrary but correct idea
34:09 - of does 1 equal equal 1
or does 50 equal equal 50.
34:12 - You don't need to just come up
with some arbitrary solution.
34:15 - You can literally just say true because
that key word true never changes value.
34:20 - So even though this is
a little weird looking,
34:22 - it's how you induce
something to happen forever.
34:26 - You asked the same question again
and assume that the question always
34:29 - has the same answer of true.
34:30 - Any questions on that one?
34:34 - Yeah, in the back.
34:36 - AUDIENCE: Do spaces matter?
34:37 - Can you take out the
space between y and 0?
34:39 - DAVID: Good question.
34:40 - Do spaces matter?
34:42 - Short answer, no, not in this case.
34:44 - You can in fact delete
all of the space here
34:47 - except for the one in
the English phrase,
34:49 - and it would still be
functionally correct.
34:51 - You can even add spaces
anywhere you want.
34:53 - You can make this taller by
hitting Enter a bunch of times,
34:55 - tabs, spaces around the word true.
34:58 - All of the examples I"ll show here today
and you'll see in the coming weeks are
35:01 - the better way to do things
because they're more readable.
35:04 - But again, as you get
more comfortable with code
35:06 - or if you're coming in
with some prior experience,
35:07 - you might already have
your own opinions.
35:09 - And frankly, this is
just a religious debate
35:11 - among programmers, which is the
right way to write your code.
35:13 - And that's fine.
35:14 - Once you get comfy, so long as you're
consistent is the most important thing.
35:17 - You don't need to adhere to
one person's or the other.
35:20 - So how does this code work logically?
35:21 - Well, the first thing the computer,
your Mac or PC or your phone
35:24 - or whatever is going to do,
it's going to ask the question.
35:27 - Well, true.
35:28 - Well, true is always true.
35:29 - So it's going to proceed to
execute the line of code.
35:31 - But after it does, because that's
the entirety of the code that's
35:34 - in between the curly braces,
we could have more lines.
35:36 - These are just short programs.
35:38 - The computer is going to
check, OK, is true still true.
35:41 - Yes.
35:42 - So it's going to execute it again.
35:43 - Then it's going to ask
the question again.
35:45 - Is true still true?
35:46 - Yes, so it's going to
execute the code again,
35:48 - and this is going to
repeat literally forever.
35:52 - But what if you don't want
to repeat something forever?
35:54 - What if you only want
to repeat it 50 times?
35:56 - Scratch doesn't make you
think very hard about this.
35:58 - People just figure out how to keep
track of 1, 2, 3, 4, 5, and all the way
36:02 - up to 50 and then stop.
36:04 - That's nice.
36:04 - It makes it easy to use the block.
36:06 - C and a lot of languages aren't
quite that user friendly.
36:10 - You will see later in the
semester that newer languages are
36:13 - a little closer to what Scratch offers.
36:15 - But in C, we need to be
more explicit, but this
36:17 - is a chance to use some of these
more primitive building blocks.
36:20 - In C, the equivalent of repeat is going
to be the proposition for just because,
36:26 - for now.
36:27 - And then, just as before,
if we want to do something
36:30 - again and again within
this loop, we're going
36:32 - to use the curly braces, similar
to the little orange block there.
36:35 - And then what am I going to do?
36:37 - I'm going to do this every time, 50
times hopefully, print out hello world.
36:41 - So now I just need to figure
out and see how to express
36:44 - the number of times specifically 50.
36:47 - So it turns out in C--
use parentheses again--
36:50 - this is going to be a pretty common
characteristic of a lot of the code
36:53 - we write.
36:54 - And then you need to do three things.
36:56 - The burden is now going
to be on us the programmer
36:59 - to keep track of how many times we want
to execute this code to how many times
37:04 - we've already executed this code
and then constantly make sure
37:07 - that one does not exceed the other.
37:09 - So we stop once we hit 50.
37:11 - So what's the fundamental construct
that we use to keep track of anything
37:15 - in a program?
37:17 - A counter, which was an
example of a variable.
37:19 - So we just need to use a variable.
37:21 - Now it's actually going to be
inside of the parentheses this time.
37:24 - So it's not on its own as it was just
a bit ago, but the syntax is the same.
37:28 - I could call it counter, but the reality
is that the convention in programming
37:31 - is just to use shorter variables when
you're just doing something mundane.
37:34 - And if all you're doing is looping--
37:36 - i stands for integer, is sort of
many programmers' go-to variable name
37:40 - rather than the more verbose
but correct counter or whatever.
37:43 - So this says, hey, computer,
give me a variable called i.
37:47 - Let me store integers or ints in
it and set the initial value to 0.
37:52 - Why?
37:52 - Well, almost everyone in this room
probably starts counting from 1.
37:56 - Computers just tend to
start counting from 0.
37:59 - But why?
37:59 - What's the rationale for
starting to count from 0
38:01 - perhaps based on last week?
38:06 - Why does that kind of makes sense?
38:07 - Yeah, what do you think?
38:09 - AUDIENCE: Well, because it's
ones and zeros, and it's binary.
38:11 - DAVID: Yeah, it's just
ones and zeros, and what's
38:14 - the smallest number,
negative values aside,
38:16 - that you can represent in binary?
38:17 - Well, it's just 0, 0,
0, a bunch of zeros.
38:20 - So why would you waste
that representation,
38:23 - that permutation of bits?
38:24 - Let's just start counting
at 0 and then add to that.
38:26 - So you can start counting from 1 in C,
but the convention in most languages
38:31 - is count from 0.
38:31 - So we'll get off on that foot as well.
38:33 - And you might recall even that in our
PBJ, for the peanut butter and jelly--
38:37 - not for the PDJ code--
38:40 - for the phone pseudo code, I
actually deliberately started
38:43 - numbering the lines from 0 to
1 to 2 for that same intuition.
38:47 - So here's how you then say to
the computer check, if you would,
38:50 - whether i is less than 50.
38:51 - Now, initially it's obviously
going to be less than 50
38:54 - because zero is less than 50
but that same condition is
38:56 - going to be checked again and again
and again as this loop executes.
39:00 - And then recall from before, we can just
plus plus a variable to add 1 to it.
39:05 - We can do this more verbosely.
39:07 - We could say i equals
i plus 1, but it's just
39:10 - more conventional to
write i plus plus just
39:13 - to say the same thing more tersely.
39:15 - So what happens next logically?
39:16 - That's the code I've written.
39:17 - What does the computer do with it?
39:19 - Well, it initialises i to 0 and
prepare to store integers in it.
39:23 - It checks the condition just in case
you initialized it too big of a value.
39:27 - You might not want the
loop to execute at all.
39:29 - But obviously 0 is less than 50.
39:31 - So this line of code executes.
39:33 - Take a guess as to what happens next.
39:37 - Yeah, you probably
want to do i plus plus
39:39 - because you're done executing
all the lines of code
39:41 - in between the curly braces,
even though there's just one.
39:43 - So let's go ahead and increment i.
39:45 - So i is now 1.
39:47 - Let's now make sure-- is 1 less than 50?
39:49 - Obviously.
39:50 - Execute the code.
39:51 - I plus plus-- is 2 less than 50.
39:54 - Obviously execute the code. i plus
plus-- is 3 less than 50, obviously.
39:59 - Now go ahead and execute the code,
and again and again and again.
40:03 - And at some point, we're going to get up
to i equals 49, and is 49 less than 50?
40:09 - Obviously.
40:10 - So we print out hello world.
40:12 - And then i plus plus kicks in,
and then it's, is 50 less than 50.
40:17 - No.
40:18 - So wait that feels like
a logical error, no?
40:20 - Should I be checking if i
is less than or equal to 50?
40:24 - Yeah, because if I
started from 0, I already
40:26 - spent that one additional cycle.
40:28 - So I can count from 0 through 49 which
seems to work or from 1 through 50,
40:34 - but the convention in
programming honestly
40:36 - is typically to start
counting at some value
40:38 - and then count up to but not
through some value just because.
40:43 - But logically, you can implement this
in half a dozen different ways most
40:46 - likely.
40:47 - Let's look at one final
example that allowed us
40:49 - to actually get user input in Scratch.
40:52 - Recall that we used this
block to actually get
40:54 - the name of someone in
lecture, and we also
40:57 - in the animation with the gingerbread
house used it to get yes or no--
41:00 - do you want the cupcake
or the apple or the like.
41:03 - So this is an example
of a function in Scratch
41:05 - that actually takes input like
the sentence what's your name,
41:09 - but it also returns a
value, which in this case
41:12 - was just hard coded in Scratch
by MIT to be called answer.
41:15 - So it's like a special
variable called answer,
41:17 - but effectively it's being
handed back to the user.
41:20 - So how might we think about this?
41:22 - In C it turns out that you can express
this line of code a little more
41:26 - verbosely than before but using a
new function called get string--
41:30 - so get underscore string is
the name of the function.
41:32 - The underscore is convention in C.
If you ever want to have a space,
41:35 - you can't have spaces in
the names of functions.
41:37 - So people just started using underscores
like you might in your own social media
41:41 - user names and the like-- is
a convention there as well.
41:44 - Here's the sentence I
want to display, and I'm
41:48 - going to start calling this
more formally a string.
41:50 - A string in a programming language
is just a sequence of characters.
41:53 - It's a word, it's a phrase, it's
a character, it's a paragraph.
41:56 - This is a string.
41:57 - Anything between double
quotes is a string in C,
41:59 - and the backslash n it's
just end of line as before.
42:03 - We still already have
the semi-colon, but this
42:05 - isn't quite a literal translation
of what's going on just yet
42:08 - because I also now need to
do something with the answer.
42:13 - So if get string is a function that
actually gets input from the user,
42:16 - as via his or her keyboard, just
like the blue block in Scratch, in C
42:20 - we need to be a little
more explicit as to where
42:23 - we're putting the return value from that
function, what it is it's handing back.
42:28 - And so I can store in a
variable called answer.
42:30 - I could call it anything I want.
42:32 - But for consistency with
Scratch, let's call it answer.
42:35 - But recall what we have to do in
C anytime we create a variable.
42:40 - We have to be more precise.
42:41 - Yeah.
42:42 - AUDIENCE: Define its class as a string.
42:44 - DAVID: We have to define its--
let me call it a type or class,
42:46 - if you've taken a previous class.
42:47 - It's type and it's not going to be an
int because probably the words being
42:51 - typed in are not numbers.
42:52 - It's going to be this time
what I just called it a string.
42:54 - And so, indeed, we would
declare the variable on the left
42:58 - by saying give me a
string, call it answer,
43:00 - and assign to it
whatever's on the right.
43:03 - Well, what's on the right?
43:04 - What is on the right is
whatever this function
43:06 - get string comes back with and
gets stored from right to left.
43:12 - So how do I now say this person's name?
43:15 - Well, in Scratch I just say and then
I drag and drop the answer variable,
43:18 - and it's done.
43:19 - What's the function in C with
which we can say something, though,
43:22 - on the screen?
43:23 - So printf, print a formatted string,
even though we haven't really seen
43:26 - any formatting yet until now.
43:28 - It turns out in C, You
have to actually tell
43:32 - d if you're not passing in a
hard coded string or sentence,
43:38 - you have to pass to printf what's called
a format code or a format string--
43:43 - this first input to printf.
43:46 - Now printf apparently
seems to take two things.
43:48 - The first is this one before the comma.
43:50 - The second is the thing after the comma.
43:52 - And we've not seen this
before yet in C. So printf
43:55 - is being told, go ahead and print
out a string that looks like this.
43:59 - Percent S is a placeholder,
and S stands for string.
44:03 - And that literally is
a placeholder saying,
44:05 - printf, I'm going to give you a
string to plug in to this first input.
44:11 - What is that string?
44:12 - Literally, the answer variable.
44:14 - Now it feels like we're
jumping through hoops here.
44:16 - It would have been nice to just say
printf, open parenthesis, answer,
44:19 - close parenthesis, semi-colon,
and be done with it.
44:21 - That's just not the way printf works.
44:23 - In older versions, you
could maybe do something
44:25 - a little more simple like that.
44:26 - But honestly, we're not typically
going to be printing out
44:28 - just what the human typed in.
44:30 - After all, this is kind of a
stupid example at the moment.
44:32 - I'm typing in a word.
44:33 - You're just saying it on the screen.
44:34 - We already decided in
Scratch that's kind of lame.
44:36 - It'd would be nice to at least
have the program, not just
44:39 - say David or whatever the name
is-- but what did we do last time?
44:44 - Like hello comma David.
44:46 - But this would seem to
give us that capability.
44:50 - Right now I'm literally just
printing out the human's name in C,
44:54 - but let me change this ever so
slightly just as we did in Scratch.
44:57 - Recall that in C we did this green
block of join where I literally
45:03 - get past join two arguments.
45:04 - The first one was hello comma space.
45:07 - The second one was answer,
and this concatenated.
45:09 - This combined back to
back those two strings.
45:12 - Well, in C, thanks to printf,
we can do that same thing.
45:16 - It's just a different syntax.
45:17 - Printf still gets one argument first,
that is, the string you want to format,
45:23 - ergo the F in printf.
45:24 - But this time I'm going to literally
say H-E-L-L-O comma space percent S
45:30 - for string and then give
printf a second argument,
45:34 - which is its instruction to go ahead
and plug in whatever this variable is
45:38 - to whatever this placeholder is.
45:42 - And so here we've now joined the
two strings effectively and thus
45:45 - was born our first formatted string.
45:50 - Well, any questions then on that?
45:53 - Yeah.
45:54 - AUDIENCE: What if you wanted to
say something extra after it?
45:58 - DAVID: What if you want to
say something extra after?
46:00 - You could certainly continue the logic.
46:02 - You don't have to end
this quoted expression
46:05 - with percent S. You could
say, hello, comma percent S
46:08 - comma, nice to meet you.
46:10 - And then what printf
will do is it's only
46:12 - going to substitute that variable
called answer where the percent S is.
46:16 - And if you want to give 2% S's, you
could just add another comma here
46:20 - and pass in another variable and
a third variable and even more,
46:23 - thus formatting the
string even more detailed.
46:26 - Question over here.
46:27 - Yeah.
46:28 - Other questions?
46:28 - Yeah, in the back.
46:30 - AUDIENCE: How do you make a
distinction between the placeholders
46:33 - if you have different variables?
46:34 - DAVID: How do you make a
distinction between the placeholders
46:37 - if you have different variables?
46:38 - It's the ordering from left to right.
46:40 - So in this case, it's a
trivial example because there's
46:42 - only one variable and one placeholder.
46:44 - But if as you were hinting, I had
multiple percent S something something
46:48 - something, percent S
something something something,
46:50 - I would just make sure that I pass
printf the first variable comma
46:54 - the second variable comma the third
variable and so forth left to right.
46:59 - Other questions?
47:00 - Yeah.
47:01 - AUDIENCE: Why is there no backslash n?
47:03 - DAVID: Oh, damn it.
47:03 - Because I screwed up and
didn't include that and I
47:06 - was going to fix it after class quickly.
47:08 - Bug, it's a bug.
47:10 - Yeah.
47:11 - AUDIENCE: What if you wanted to
use the int twice in the string?
47:14 - So you wanted to say,
hello, David, hi, David.
47:17 - DAVID: Sure, same exact thing--
47:18 - comma answer, comma answer with 2% S. If
you want to say the same variable twice
47:23 - in two places for whatever reason,
two placeholders and then answer comma
47:27 - answer to plug that in twice.
47:30 - Other que-- yeah.
47:31 - AUDIENCE: Is percent a universal
placeholder in terms of integers?
47:34 - DAVID: No, and we're going to
see some others in just a bit.
47:36 - It turns out there's others.
47:38 - It's percent i integer,
and there's going
47:40 - to be even more than that-- percent
c for a single character and more.
47:44 - Other questions?
47:45 - Yeah.
47:46 - AUDIENCE: Since the backslash n is a
variable, would you put it after n?
47:49 - So will you put it in the quotation?
47:51 - DAVID: Good question.
47:51 - If I did have correctly--
and if this weren't a PDF,
47:54 - I would just edit it on the fly--
47:55 - if I had the percent n, it always
has to go in the formatted string,
48:01 - in the first argument.
48:03 - So the only thing that comes
after printf's first argument
48:06 - is optionally variable comma variable
comma variable comma variable.
48:11 - Other questions?
48:14 - so Let's go ahead and actually
do something with code.
48:18 - I'm going to go ahead and
open up another window,
48:20 - and this is a tool
called with CS50 Sandbox,
48:22 - and this is a tool via the web by a
which you can actually play with code.
48:26 - And I'll show in just a moment how
I get to this particular location,
48:29 - but let me first explain the user
interface much like we started off
48:33 - our conversation with Scratch.
48:34 - So I need a place to write code.
48:35 - The reality is I could
just use my own Mac.
48:38 - I could just use my own PC.
48:39 - Frankly, I could even use certain
mobile devices these days.
48:42 - But then we would have hundreds
of other people in the class
48:45 - all with slightly
different configurations
48:47 - on their Max and their PCs
and their phones and the like.
48:50 - And so everyone would have different
software and different settings,
48:53 - and they just never works very well.
48:54 - So at the beginning
of the course, we just
48:56 - standardize everything by actually
using a web based environment
48:59 - just like Scratch is, whereby we'll all
have access to the exact same computer
49:04 - but virtualized in the so-called cloud.
49:07 - If you've ever wondered
what the cloud is,
49:09 - it just means other people's
server somewhere on the internet
49:11 - that people can use for
free or to rent and not
49:14 - have to host those physical
servers themselves.
49:17 - So CS50 Sandbox, just like Scratch,
is a cloud based application
49:21 - that someone else wrote
that's hosted on the internet,
49:24 - and the user interface, at first
glance, looks just like this.
49:27 - There are only two components to it.
49:29 - At the top of the user
interface of CS50 Sandbox
49:32 - is just a code editor, a
very simple text editor
49:35 - similar in spirit to Google Docs
and Microsoft Word and so forth
49:38 - but much simpler.
49:39 - There's no formatting.
49:40 - There's no bold facing and centering.
49:41 - You can just type words of text.
49:43 - Down here is the
so-called terminal window,
49:45 - but we'll come back to
that in just a moment.
49:48 - Let me go ahead and
write my first program.
49:50 - Let me go ahead and write
include standard IO dot age
49:57 - int main void open curly brace printf
hello world backslash and semi-colon,
50:04 - done.
50:05 - Now few people in this room could
probably whip up a apparent program
50:09 - that quickly unless you
do have prior background.
50:12 - And if you did take APCS or something
else, it looks kind of like Java
50:15 - but not quite the same.
50:17 - But this is my first program.
50:18 - Now recall from earlier this
was the black and white program
50:21 - we saw on the slide
just a little bit ago.
50:24 - And even if you didn't quite appreciate
what all the funky syntax is doing,
50:27 - all of us probably had the
intuition of what this program does,
50:31 - which is just to print out the words
at the end of the day hello world.
50:34 - And we'll tease apart in just a bit
what all these various lines are doing.
50:38 - But the interesting part is
what's highlighted in green here,
50:40 - and this is just one of the
features of CS50 Sandbox.
50:44 - It will color code different
concepts within your code
50:47 - so that they just jump out at you.
50:49 - The colors aren't actually there.
50:52 - You don't have to color
code things yourself.
50:53 - It just does it automatically so
you can see the different components
50:56 - just like MIT colorizes is the various
Scratch puzzle pieces the same.
51:00 - So this is a program that
I want to call hello.
51:05 - It's in a file.
51:06 - This is just a tab up
top called hello dot C
51:09 - because it turns out, when
you write a program in C,
51:11 - you save it in files by human convention
whatever dot C as the file extension,
51:16 - so to speak.
51:18 - How do I run this program?
51:20 - There's no green flag to
click, which Scratch gave us.
51:25 - So how do I actually run the program.
51:27 - And frankly, moreover, the green flag
seems to be the least of my concerns.
51:31 - What is the language that
any computer understands
51:34 - whether it's my Mac here or the
cloud server where this thing is?
51:38 - Zeros and ones, right?
51:39 - And we started with that overwhelming
slide of a lots of 0's and 1's, and
51:43 - that is the point we need to get to.
51:45 - But hopefully, we ourselves don't
have to write at that level of tedium.
51:49 - So we need some way of
converting this code
51:52 - from C, which we'll start calling source
code, which is the English like code we
51:57 - see on the screen that's mildly
pleasurable to write as opposed
52:01 - to just zeros and ones.
52:02 - But we nonetheless need to convert
it somehow to zeros and ones.
52:06 - And so the way we can do this
is essentially as follows.
52:09 - If we have what we'll start calling
our source code, which can be written,
52:14 - in our case, in C, but you can write
source code in Java, in C++, in Python,
52:19 - in dozens of other language.
52:21 - Source code's a generic term.
52:22 - That just means the code
that we humans have written.
52:24 - We need some way of converting
it into zeros and ones, which
52:28 - henceforth we're just going
to call machine code, which
52:30 - feels like a reasonable name.
52:31 - It's the zeros and ones
that a machine understands.
52:34 - How does a machine know what
zeros and ones to understand?
52:37 - Well, that's the whole reasoning
behind having CPU, Central Processing
52:40 - Unit, the brains of a computer.
52:42 - They are just hardwired
at the factory, so
52:44 - to speak, at Intel's
factory to understand
52:47 - certain patterns of zeros and ones.
52:49 - But the point for us now is we need to
take a source code, like the C program
52:53 - I wrote a moment ago that's
supposed to print hello world,
52:56 - and somehow convert it to machine code.
53:00 - So it turns out this is the step
that humans who've come before us
53:03 - have solved for us.
53:04 - Other humans have
already written programs
53:07 - that we're going to start
calling a compiler that allows us
53:10 - to convert source code to machine code.
53:13 - It's just one additional step.
53:14 - This step did not exist
in Scratch, but we're
53:16 - going to run a program that's generally
called a compiler that we pass
53:21 - our program to as input, and we
get as output machine code, thereby
53:28 - perfectly bringing us full circle
to what computer science is
53:31 - is in now the context
of programming-- input
53:33 - source code, outputs machine code.
53:35 - The algorithm or the special software
we're going to use in just a moment is
53:39 - called a compiler that just converts
one to the other so that none of us have
53:42 - to ever think about or
write in 0's and 1's.
53:45 - So it's a little old
school how you do this.
53:47 - In Scratch, you obviously just
hit the green flag and MIT
53:50 - and all those folks
took care of it for you.
53:52 - We have to be a little
more manual about this,
53:55 - and that's where the second piece
of CS50 Sandbox user interface
53:59 - comes into play.
54:00 - Notice I have a blinking prompt here.
54:02 - There's dollar sign at left,
which is just a common convention.
54:04 - A dollar sign tends to in these types
of computers represent a prompt.
54:09 - It's waiting for me to type something,
and indeed it's literally blinking,
54:13 - waiting for me to type something.
54:14 - This is an example of a terminal window,
and your own iMac and your own PC
54:18 - actually has or can't have
this exact same feature.
54:21 - It's just all of us operate with
graphical user interfaces these days.
54:24 - So we've got buttons
and menus and things
54:26 - to drag and click, but back in the day--
54:28 - and typically in programming-- you
don't bother with these aesthetics.
54:32 - You actually get your hands dirtier
with just the keyboard alone typing
54:36 - anything you want to do.
54:37 - And at first, it might
feel like a regression.
54:39 - Like, why are we giving up
all these beautiful amenities
54:43 - of modern computers?
54:44 - But it's more powerful,
and it's more explicit.
54:47 - It lets you do exactly what you want to
do by sending commands to the computer.
54:51 - So this is my terminal 1.
54:52 - I can create others just
to have multiple windows,
54:54 - but this is giving me access to
the underlying server that I now
54:58 - have access to.
54:59 - So if any of you, when it comes
time to the first problem set,
55:02 - log into the same tool, you don't
all have the same environment.
55:05 - You all have your own isolated copies of
the same software but your own storage
55:10 - space, so to speak.
55:12 - So I need to somehow convert
hello dot C to zeros and ones.
55:17 - And the way I'm going to
do this is like this--
55:20 - clang, which stands for C
language, hello dot C enter.
55:28 - And the fact that I see nothing
happening is actually an amazing thing
55:32 - because there's an infinite number of
things, frankly, that can go wrong,
55:35 - and the computer will
happily yell at you
55:36 - with cryptic looking error messages
if any of those things do go wrong.
55:40 - So seeing nothing but another
blinking prompt with the dollar
55:43 - sign is actually a good thing.
55:45 - My code has somehow been
converted to zeros and ones.
55:48 - Where are those zeros and ones?
55:50 - Well, by convention, they are
stored in a file that's weirdly
55:54 - and historically just called a
dot out, and we can see that.
55:57 - If I click this folder
icon up here, you'll
56:00 - actually see my file hello dot C and
another file now called a dot out.
56:06 - It stands for assembly output,
but for historical reasons.
56:09 - Now let me close the folder icon
because we're generally not going
56:12 - to use the graphical user interface.
56:14 - How do I run that program?
56:15 - I couldn't just double
click on the icon.
56:17 - This isn't a Mac.
56:17 - This isn't a PC.
56:18 - This is a cloud based Linux environment.
56:21 - Linux is a super popular
operating system.
56:23 - It happens to be used by lots of
computer scientists, lots of websites,
56:26 - lots of servers.
56:27 - In fact, almost every website
you visit these days is powered,
56:29 - if not by Windows by Linux,
and variations thereof
56:33 - called Unix and other flavors still.
56:35 - It's just a very popular and
often free operating system
56:38 - that CS50 Sandbox itself uses.
56:40 - To run a file called a dot out
that's in this folder, so to speak,
56:45 - even though you don't see
a graphical version of it.
56:47 - You literally just type
dot slash a dot out.
56:50 - Completely non-obvious and kind
of a stupid name for the program,
56:55 - but this is the equivalent in your Mac
or PC of double clicking on an icon.
56:59 - Let me go ahead and hit enter.
57:00 - And when I do, I should
hopefully see what?
57:03 - Hello world.
57:04 - And here we go.
57:06 - Wow, that's our first program.
57:09 - It's not doing all that
much, but it's at least
57:11 - doing what we promised it would do.
57:13 - And this is the equivalent in Scratch of
just saying on the screen hello world.
57:16 - Now to be fair, there
were more steps involved,
57:18 - and God knows there was more
cryptic looking code to write.
57:22 - But at the end of the
day all we've done now
57:24 - is re-implement last week's
logic in this new language,
57:27 - but we're now going to very quickly
introduce new puzzle pieces but in C.
57:31 - But first let's solve
this minor headache.
57:33 - I don't really want
to tell friends like,
57:35 - hey, everyone, come run
my a dot out program.
57:39 - Let's give it a real name.
57:40 - Suppose I just want to
call my program hello
57:42 - like you might download from the
App Store or Google Play Store.
57:44 - Programs have names.
57:46 - So how do I do that?
57:47 - Well, it turns out in a terminal window,
the so-called command line environment,
57:52 - which is just a fancy way of
saying you write lines of commands
57:55 - with your keyboard,
you can actually pass
57:57 - in what are called command line
arguments, additional inputs
58:02 - to programs that are just words that
you type at your keyboard that tell it
58:06 - how to behave.
58:07 - So instead of just
running clang on hello dot
58:10 - C, I'm actually going
to be more explicit
58:13 - and I'm going to tell
clang please output--
58:16 - as is implied by literally
typing dash 0 for output--
58:19 - a file called hello instead.
58:22 - So it's a little more verbose--
58:24 - hello dash O hello-- or, sorry
clang dash O hello hello dot C.
58:29 - But what this is going to
do now is still convert
58:31 - source code to machine
code, but it's going
58:33 - to save it in a file called hello.
58:36 - And indeed now I have hello
dot C a dot out and hello as
58:40 - pictured in the little
graphical folder there.
58:42 - So now I can instead
run dot slash hello.
58:46 - What should it say?
58:47 - Hopefully the same, enter.
58:50 - So that's it.
58:51 - Those are called command
line arguments, and it's just
58:53 - the old school way of
telling a text based command
58:56 - how to behave a little bit
differently from its defaults.
58:58 - But frankly, this is going
to get tedious quickly.
59:01 - We aren't going to
want to write our code
59:03 - and then every darn time we want to
convert it to zeros and ones to run it
59:06 - actually remember these magical
incantations of commands.
59:10 - And so humans have
abstracted these away too.
59:13 - It turns out that, if you want to
make a program from source code
59:16 - into machine code, there's
another command you can use.
59:18 - And you can literally
type make hello, where
59:21 - hello is the name of the
program you want to make,
59:24 - this program, whose name is
make, will look for a file
59:28 - by default called hello dot C, therefore
saving you the time of specifying it.
59:34 - Hit Enter now, and, oh my
god, look what it just did.
59:38 - It has even more configuration
options that are baked into it,
59:42 - and we as CS50 staff, configured CS50
sandbox to have these various features.
59:47 - And even though we're not going
to go into detail on them now,
59:50 - I'm going to wave my hand
at what they actually do.
59:52 - They just make additional features
possible that we'll eventually get to.
59:55 - But this would be otherwise
the command that you all
59:57 - do have to type in just two
or three or four weeks time,
60:01 - and no one can ever remember that.
60:03 - I certainly couldn't.
60:04 - So Make just automates that for you.
60:06 - But when you run Make,
Make is not a compiler.
60:10 - Make is not the thing in the middle here
converting source code to machine code.
60:14 - It's just a second program that
some humans wrote years ago that use
60:19 - clang in an automated way
to achieve the same output.
60:23 - Because people got tired
of typing stuff like this.
60:25 - So someone made a program
called Make that does it for us.
60:29 - Any questions?
60:32 - Let's add a little bit
then to this program.
60:34 - Instead of this version of
hello, let me get some user input
60:38 - and actually do something with it.
60:40 - Suppose I actually want to get the
user's name and then print that out.
60:43 - Well, we saw the spoiler
for that just a moment ago,
60:46 - but let me go ahead and
add to this program here.
60:48 - Now I have a second line of code, and
I want to get a string from a user.
60:51 - And with what function do I
get a string from the user?
60:56 - Get string was the one,
and recall I can do get
60:58 - underscore string open parenthesis.
61:01 - And then I have to pass in an argument,
so to speak, like give me your name--
61:05 - or actually, what did we say before?
61:07 - What is your name, I think was
the prompt backslash n semi-colon.
61:12 - Now it's not enough to
just get the string.
61:13 - What do I want to do with it?
61:15 - Yes, store in a variable.
61:17 - What type of variable?
61:18 - A string.
61:20 - So I just need to go on the left
hand side of this line of code
61:23 - and say, OK, well, give me a string.
61:25 - I'll call it name, but I could
call it x or y or anything.
61:28 - But name feels like a
good descriptor for it,
61:30 - using a single equal sign
to copy from right to left.
61:33 - And now I've got that.
61:35 - Now it's not sufficient to just
store the value in the variable.
61:38 - I need to print it out.
61:40 - So let me start with this.
61:44 - It autosaves, the Sandbox.
61:45 - So I don't even have to go
up to File, Save or anything.
61:47 - Let me go ahead and do make hello now--
61:50 - oh uh, oh my god, look at
all these errors already.
61:54 - So clearly something is wrong, as the
computer is fond of telling me in red.
61:58 - And frankly, this is
where you very quickly
62:00 - get derailed or kind
of freaked out because,
62:01 - oh my god, I only wrote
two lines of code.
62:03 - How do I have 20 lines
of errors somehow?
62:06 - So the computer is kind
of as confused as you.
62:09 - And the most important thing, when
you face this kind of situation
62:12 - where it's just cryptic, erroneous
output, start at the top.
62:14 - Even if your window's kind of small
and therefore a whole bunch of stuff
62:17 - scrolls on the screen
quickly, scroll up to the top
62:20 - because odds are there's one
mistake up at the very top
62:22 - and that one mistake just had a
cascading effect on the compiler.
62:26 - Then it just got really confused, and
it just kept spitting out messages
62:29 - because it got tripped up early.
62:31 - So let's scroll back up to the top here.
62:34 - And here is the very long command
that I said make automates for you.
62:38 - So that's not erroneous.
62:40 - Here seems to be the first error,
and it's a little cryptic still.
62:44 - But let's glean some information.
62:46 - Here's a familiar phrase--
62:48 - hello dot C. Let me go ahead
and zoom in on the bottom here.
62:51 - So hello dot C recalls
the name of my file.
62:54 - Albeit not obviously, clang is
telling me look at line 5 and then
62:58 - your fifth character.
63:00 - So this something colon something means
line number character or column number
63:03 - if you're looking from left to right.
63:05 - Error means error.
63:06 - And then this is where things
get a little sophisticated.
63:10 - Use of undeclared identifier string--
63:13 - did you mean standard n?
63:16 - No I didn't, but I do
recognize standard n,
63:19 - or rather it seems similar to standard
I/O. But no, I didn't mean that.
63:22 - I'm pretty sure this code is right.
63:25 - Well, why am I getting this error?
63:27 - It sounds like string, on line
five, fifth character, right there,
63:31 - that is wrong.
63:33 - Well, it turns out, there is
no such thing as a string.
63:36 - C, the language, has integers,
and it has Booleans, it turns out.
63:40 - And it has characters
and a few other things.
63:43 - It actually doesn't have strings.
63:44 - Strings is a word that's
useful to describe sequences
63:47 - of characters, paragraphs, words.
63:49 - But string is not a type.
63:51 - It's not a type of variable
unless you make it so.
63:54 - And in fact, this is one of
the simplifications we do.
63:57 - In just the first couple of weeks of
the course to get us off the ground,
64:00 - it turns out that we need to
add one line of code here.
64:05 - We need to do, not only include standard
I/O-- which we'll explain in a moment--
64:09 - but also CS50 so-called library.
64:13 - So CS50 has a lot of humans involved
with it, and over time we've decided,
64:17 - you know what, we could make the
first hour of CS50 a little easier
64:20 - and the on ramp a little cleaner
for folks with no background
64:24 - by just inventing a few features
ourselves such as the ability
64:27 - to get strings from the user.
64:29 - So it turns out get string
is also not a function that
64:31 - comes with C. That is a custom puzzle
piece, so to speak, that CS50 made.
64:35 - And where we created that
function is essentially in a file
64:39 - called CS50 dot age.
64:41 - And so by including dot
age, you now get access
64:44 - to more puzzle pieces, if you
will, that we have created for you.
64:47 - And it turns out this
line of code that has
64:49 - been here before is also
giving you features, too.
64:53 - We're just doing what
everyone does in programming,
64:56 - which is solve a problem once and then
let other people use that solution.
64:59 - Take a guess.
65:00 - What functionality is
actually implemented
65:03 - in a file called standard
I/O input output dot h?
65:07 - This is just a file somewhere on the
server that actually does come with C,
65:11 - and it provides you with
handy features like what?
65:15 - Say again.
65:17 - Once more.
65:18 - Printf.
65:19 - It turns out that the means by which
you are allowed to use a function
65:23 - called printf here is
you have to include
65:26 - the file in which it is declared.
65:28 - So some humans, years ago, literally
wrote a function, a puzzle piece,
65:32 - called printf, and they figured
out how to actually draw
65:34 - characters on the screen.
65:35 - They then stored information
about that function in a file
65:38 - called standard IO dot age.
65:40 - If I had not included that
seemingly cryptic line of code
65:43 - at the very top of my previous program,
even that hello world program would not
65:48 - have worked because clang,
the compiler, wouldn't
65:50 - have known what I'm talking about.
65:52 - What is printf?
65:52 - I don't know what that
is unless you tell
65:55 - it to also include this
file that humans wrote years
65:58 - ago in which printf has been created.
66:00 - And now if I want to use get string,
as well as the new keyword string,
66:05 - I need to tell clang the
compiler, also go ahead
66:08 - and look in CS50.h for more
functionality, such as string
66:12 - and get string.
66:13 - So let me go ahead now
and try this again.
66:16 - I'm going to clear my terminal here
and just try that same command again--
66:20 - make hello, enter, dammit.
66:25 - Now I've got another error.
66:26 - But, but, but, progress.
66:28 - Well, no, just as many errors as
before somehow, but different ones.
66:33 - Notice now-- wait, that was before.
66:36 - Oh, no, I'm sorry.
66:37 - It has fewer errors.
66:38 - Here's where I ran the
command a moment ago,
66:40 - and now I'm getting this error instead.
66:43 - So progress.
66:44 - Now my error is not on line 5.
66:45 - It's on line 6, though fun
fact, line 6 used to be line 5.
66:49 - So it's apparently still
involved in the problem.
66:52 - So let's read the error message.
66:54 - The problem is on line 6, which is
no surprising is that one there.
66:58 - But this time it's different--
error, unused variable name.
67:03 - That one I kind of understand
even without being a programmer.
67:06 - What does that mean?
67:08 - Yeah.
67:12 - Maybe declare prior to using, but it
turns out this is how you declare it.
67:16 - But I'm actually-- yeah.
67:18 - AUDIENCE: You're not actually
using the variable you declared.
67:20 - DAVID: Yeah, I'm just kind of
wasting the computer's time.
67:23 - I'm creating it.
67:23 - So line 6 on the left is correct.
67:25 - Hey, computer, give
me a string variable,
67:27 - and call it name and put a value in it.
67:29 - But what's the point of that
exercise if you're never,
67:32 - as you say, doing anything with it.
67:34 - And in fact, recall from
the slide a moment ago,
67:36 - how do I do something with it?
67:38 - Well, this is not how
you do something with it.
67:40 - If I go ahead and run this
program now successfully,
67:42 - what would I actually see on the screen?
67:45 - Literally hello name, H-E-L-L-O comma
space N-A-M-E, obviously not correct.
67:50 - So how do I plug in the variable?
67:52 - What was the trick?
67:54 - Yeah, percent S for
string, a format code,
67:57 - so to speak-- hence the name printf.
67:59 - And then I need to pass a
second argument to printf,
68:02 - and I do that with a comma and then the
name of the variable I want to plug in.
68:06 - Now notice there are two
commas in this line here.
68:08 - If I zoom in, notice there's
two commas, but there's only
68:11 - two arguments or inputs to printf.
68:14 - The input to a function is just
typically called an argument
68:17 - or also called a parameter.
68:19 - So there are two commas, but this one is
an English comma just separating hello
68:24 - from the person's name.
68:25 - This white comma here, color coded
because the Sandbox is doing the for me
68:29 - is actually separating--
excuse me-- the first argument
68:32 - from the second argument.
68:34 - So now, for a third
time, make hello enter.
68:38 - Oh my god, thank you.
68:40 - Now it worked.
68:41 - It still spit out this pretty
long, cryptic command in white,
68:44 - but that's OK.
68:44 - That is, again, the automated command
that Make is making possible for us.
68:49 - But the fact that I see no red, no
errors, just another blinking prompt
68:52 - means that my program has been made.
68:54 - So let me go ahead and do--
68:55 - how do I run a program
if it's called hello?
68:59 - Yeah, dot slash hello,
and we'll see why you
69:01 - have the stupid dot at the beginning.
69:03 - It essentially means run
the program called hello
69:05 - that's right here in your
current folder on the server--
69:09 - dot slash hello.
69:10 - What is your name?
69:11 - Very nice.
69:12 - David, enter.
69:14 - Hello, David.
69:15 - Interesting.
69:16 - Let's make one tweak, because I did
this by accident earlier as you noted.
69:19 - What if I left off for instance
one of these backslash n's
69:23 - that's literally now
not telling the computer
69:25 - to move the cursor to another line?
69:27 - So let me go ahead
and rerun the program.
69:30 - Wait a minute.
69:31 - That looks the same.
69:33 - I just changed the code, but it's
still behaving exactly the same.
69:37 - Where's my confusion?
69:40 - I didn't recompile it.
69:41 - Unlike Scratch, which is amazing
because you just hit the green flag
69:44 - and it runs the code again, we
have a second intermediate step.
69:46 - I have to re-run the code.
69:48 - Now how do you get out of a program?
69:50 - I could just hit Enter.
69:51 - You can also hit Control C for
cancel, and that will just get you out
69:53 - of whatever confusion you're in.
69:55 - Let me go ahead and rerun, make hello--
69:58 - seems to be OK--
69:59 - dot slash hello, enter.
70:02 - OK, this is why I've had
all those backslash n's.
70:05 - Let me zoom in on what's happening.
70:07 - I mean, it doesn't look horrible,
but frankly it kind of rubs me
70:11 - the wrong way if this
is what my program looks
70:13 - like when I'm typing in user input.
70:14 - I mean, this just looks stupid.
70:15 - Minimally, I should add a space.
70:17 - Maybe I can put a backslash
n to move the character.
70:19 - This is user interface now.
70:21 - This isn't really logic.
70:22 - It's just aesthetics, but
I think this looks stupid.
70:24 - So that's why I've had the
backslash n's there all the time,
70:27 - but that's why they need to be there
to tell the computer to actually put
70:30 - things where you want them.
70:32 - Alternatively, you know
what, OK, I don't like that.
70:34 - Control-C for cancel.
70:35 - Let me put this one back.
70:37 - What happens if I get rid of this one?
70:39 - And let me go ahead and
recompile the code first
70:41 - as you note dot slash hello enter.
70:45 - OK, I've cleaned up that
aesthetic headache, enter.
70:50 - I mean, it's not quite the same
problem, but this looks stupid too
70:54 - because the dollar sign just
represents my prompt where
70:56 - I'm supposed to type commands
and yet hello comma David prompt.
70:59 - And that's just messy.
71:00 - So this is why we've had
all of these new lines.
71:02 - Now you asked earlier, what if you put
the new line elsewhere in the string.
71:05 - Well, suppose I do that.
71:06 - Suppose I put a couple of them.
71:08 - Let me do this and no spaces whatsoever.
71:11 - Now this is looking a little weird, but
the computer is just going to interpret
71:14 - this literally-- print H-E-L-L-O comma
new line substitute in the string
71:19 - for percent S then another new line.
71:21 - So how many lines of output
is this going to display?
71:25 - I heard four.
71:29 - Other values?
71:30 - Let's see.
71:30 - Let's go ahead and
make hello and then run
71:33 - dot slash hello, what is your name
as before enter hello comma new line
71:39 - David-- so four total lines certainly
or just two lines from the computer
71:43 - itself.
71:44 - So just to recap then,
with code like this
71:47 - how many functions have I used
in this particular program?
71:54 - How many functions?
71:58 - So it's two-- printf, which
we've been using and get
72:01 - string, which is the new one.
72:02 - Where is string declared?
72:05 - CS50 dot h, printf meanwhile is declared
in standard IO.h standard input output.
72:10 - Meanwhile, string, this data
type also comes from CS50 itself,
72:14 - and then we've used the
format codes, and we've
72:16 - use variables to
achieve the same result.
72:18 - And let's just hammer this home.
72:20 - Brian and Karim, do you mind
popping up for just a second?
72:23 - Or who's there?
72:24 - Erin, come on up.
72:25 - So just to make this
clear because there is now
72:27 - some terminology that we want to use.
72:30 - Let's see.
72:31 - Do you want to be--
72:32 - you'll be get string.
72:33 - So we have some name tags
here like you get at events.
72:37 - So Erin shall be get underscore string.
72:41 - If you want go ahead and put this on.
72:45 - And Brian, you want to be printf.
72:48 - So we won't act out all
of our actual programs
72:51 - because this will
quickly become obvious.
72:52 - So Brian is printf.
72:53 - So this point though,
remains in that this is nice
72:57 - that I have some colleagues
with whom I work here
72:59 - because I don't really want to do all of
the hard work of making things happen.
73:04 - And so if I'm instead the
programmer or the orchestrator
73:06 - of a whole bunch of things happening,
I can actually implement this code now
73:10 - more physically.
73:11 - And let's focus, though, for just a
moment on what the key takeaways are.
73:14 - One, functions can take input.
73:17 - Those inputs are called
arguments or parameters,
73:21 - and functions can return things.
73:23 - They can have return values.
73:24 - Printf, for instance,
does it take input?
73:29 - What's the input to
printf, for instance?
73:33 - Yeah, like hello world.
73:34 - Whatever it is you want to print is
by definition the input to printf.
73:39 - Does print return a value thus far?
73:43 - It does do something on
the screen certainly.
73:45 - It prints stuff on the
screen, but we haven't
73:47 - seen it return something because
we haven't seen it with equal sign
73:51 - to the left.
73:51 - Now it turns out printf
does return things.
73:53 - It's just not often that
useful to use, but we've only
73:56 - seen printf for the moment as taking
inputs-- more on that another time.
73:59 - Get string, meanwhile--
does get string take inputs?
74:03 - How many inputs?
74:05 - Just one, the prompt that
you want the human to see.
74:08 - The first prompt I used
was what is your name.
74:10 - I could make the prompt
anything, but that's
74:12 - the question that get string is asking.
74:14 - Does get string return a value?
74:16 - It does.
74:16 - That's of course in Scratch called
answer, hard coded as answer.
74:20 - We can store in any variable we want.
74:22 - So let me just go ahead
and implement this program.
74:24 - Erin, go get me a string and ask
the person, what is their name.
74:29 - So--
74:30 - ERIN: What is your name?
74:31 - AUDIENCE: Elizabeth.
74:37 - DAVID: So she's writing
down Elizabeth now.
74:40 - But Erin has taken input from me.
74:41 - Erin, go get someone's name and
ask them, what is their name.
74:44 - And now you've produce output for me.
74:46 - Thank you.
74:47 - This is the return value,
storing the value Elizabeth,
74:49 - and I'm going to go
ahead and took it away
74:50 - in a variable called name
like this piece of paper here.
74:53 - OK, Brian, could you go ahead
and say hello Elizabeth.
75:08 - So what's going on here?
75:11 - I'm just doing less work.
75:13 - I am writing this program--
75:14 - Erin, go get someone's name,
Brian, could you print this out.
75:17 - That's what I've been
doing, is programming,
75:19 - just delegating functionality to
other functions or in this case
75:22 - other humans who know how to do that.
75:23 - And honestly, I don't have to
know how Erin got that name.
75:26 - She just got it.
75:27 - I don't have to know how Brian wrote
in that particular kind of style
75:31 - of English on the screen.
75:32 - I just know that he can do it,
and now my program is complete.
75:36 - Thank you very much to
both of these two here.
75:38 - We'll continue in just
a moment as follows.
75:41 - So all this time, we've
been taking for granted
75:44 - that we have an actual computer
on which we can execute code,
75:47 - and I keep saying Intel inside that's
the silly slogan that you see inside
75:52 - of most Macs and PCs with
the hardware they have.
75:54 - But the CPU is just the
brains of the computer.
75:57 - And at the end of the
day, recall that the goal
75:59 - is to actually have the computer
turn something like this--
76:02 - source code-- into actual
machine code, zeros and ones.
76:06 - And that's all Clang was
actually doing for us.
76:09 - Of course, we've only just scratched
the surface now of what we can do.
76:12 - It turns out there's going
to be, not just these
76:14 - commands that we can run,
but other features of C
76:17 - and in particular the CS50 library.
76:19 - We've only seen thus
far how to get a string,
76:21 - but you can get integers and
characters and funky things
76:23 - like floats and doubles, which
actually open a can of worms
76:26 - as to problems that can
happen in a computer.
76:28 - And it turns out you can store
different types of variables, not just
76:32 - integers and strings, but bool for
Boolean and chars for characters.
76:36 - And you can format
those things in printf.
76:38 - We've only seen percent S. I
alluded to percent i earlier,
76:42 - but there's a few other still.
76:43 - But we've got a lot
of possibilities here.
76:45 - But let's go ahead and take, say, a
five minute break to give everyone
76:48 - bit of a respite, turn on some
music, and come back in five and dive
76:51 - in deeper to more
sophisticated programs in C.
76:56 - So recall we began by
comparing some Scratch
76:59 - blocks against the corresponding
C code, but we didn't actually
77:02 - use most of those blocks in C just yet.
77:05 - So let's try out a number of examples,
some of which I'll write on the fly
77:08 - in typing code out on my
own keyboard, some of which
77:11 - we already have in the
course's web sites.
77:12 - So we can just open
them to save some time.
77:14 - But let me just draw
your attention to what
77:16 - CS50 Sandbox is because this was the
step that I skipped over earlier.
77:19 - CS50 Sandbox can be used to
program in bunches of languages.
77:23 - We'll initially in the
semester use it for C.
77:25 - But if you've written Java before or
Python or any number of languages,
77:29 - when you go to
Sandbox.CS50.io, you can simply
77:33 - choose the language
you want to write in.
77:34 - And then at the bottom,
you'll see you can
77:36 - specify the name of the
file you want to precreate.
77:39 - So for instance, what I did earlier
was I selected C at top, and then
77:43 - at the bottom I typed in
Hello dot C because that
77:46 - was the name of the file I wanted.
77:47 - And then I clicked start.
77:48 - And what that led me to was precisely
the interface in which we wrote hello
77:53 - dot C just a moment ago, where my
code editor appears on the top here,
77:57 - my terminal window
appears at the bottom,
77:59 - and then I'm allowed to
just start writing code.
78:01 - So that's how we got to where we were.
78:03 - And if you want to follow along
now with some of these examples,
78:06 - note that on the course's website
we have all of them premade.
78:09 - And you can actually click the
links on the course's web site
78:12 - and open up your own copy
of a sandbox with that code.
78:15 - So if the Wi-Fi cooperates, you're
welcome to tinker and play and run
78:18 - the same commands.
78:19 - But everything is also on
the course's website after.
78:21 - So you needn't type everything out.
78:23 - So let's go ahead and
do just a quick example.
78:25 - I'm going to call this int dot
C just so that we can reinforce
78:29 - some of what we did just a moment ago.
78:31 - Rather than get a string like we did
with our hello example, let me go ahead
78:35 - and just get, say, an
integer, and then print it out
78:39 - just as we did print a name.
78:41 - So I'm going to have to go ahead
and, just through muscle memory,
78:43 - I remember that I need
standard IO dot h of the top
78:47 - and then int main void
and then curly braces.
78:50 - And then I can do the act of
actually getting the input.
78:54 - So there was a function
before called get string.
78:56 - It turns out there's
another function called
78:58 - get int if you want to get an integer.
79:00 - So I can actually call get
int, and I can say something
79:02 - like integer is the prompt.
79:04 - Like, hey, human, please
give me an integer.
79:06 - I need a semi-colon at
the end of this line.
79:09 - And then how do I actually store the
return value of get int in a variable?
79:14 - Just as Erin handed me a
sheet of paper with a string,
79:17 - I'm handed a sheet of paper with a
number, how do I store it somewhere?
79:22 - What's should I literally
type line five here?
79:26 - Int space and then number or something.
79:28 - So I'm going to call it i
just because it's an integer,
79:30 - but I could call it
number or anything else.
79:32 - And then I'm going to go
ahead and print this out.
79:34 - So printf-- let's say something
like hello i backslash n semi-colon.
79:41 - Not quite correct, right?
79:43 - This is going to literally
print hello comma.
79:45 - How do I actually
substitute something in?
79:47 - Well, we've only seen how
to substitute in strings,
79:49 - but I think I spoiled
earlier the answer.
79:51 - If you use percent i, that says,
hey, computer, put an integer here.
79:55 - Then I need a second
argument to printf just
79:58 - as we handed Brian an argument as well.
80:01 - And I said i.
80:03 - I want to say i here.
80:05 - But this program isn't
quite correct yet.
80:07 - It's in a file called int dot C.
I've included standard IO dot h.
80:10 - It's in main, and so what is main?
80:13 - Well, today were largely going
to wave our hands at that.
80:15 - But int main void is
perhaps the most cryptic way
80:19 - you can say the equivalent
of when green flag clicked.
80:21 - That's all that does, and
we'll come back in the weeks
80:24 - to come as to why it's int,
why it's main, why it's void.
80:27 - But for now, humans
years ago just decided
80:29 - that, when you're writing a program in
C and you want to start the program off,
80:32 - you literally have to type int
main void with those parentheses
80:35 - with those curly braces, and
it's the equivalent to Scratch
80:38 - is when green flag clicked.
80:40 - But this program will not
compile, and I don't even
80:42 - want to induce the stress
of seeing those errors.
80:44 - How do I void it?
80:46 - Yeah, I need to teach the
computer that get int exists,
80:50 - and I know how to do that from before
by including the CS50 so-called library.
80:54 - Technically, CS50 dot
h is a header file.
80:57 - Dot h means header, and it's
just a file containing C code
81:01 - in which the functions are created.
81:03 - More on that another time, but that
just gives us access to printf.
81:06 - So if I've made no typos,
I should be able to compile
81:08 - this program by running what command?
81:12 - Make int.
81:13 - I could do Clang.
81:14 - I could do Clang dash O. But for now
I'm going to do it simpler with just
81:18 - make int and let make automate the
process of compiling this program.
81:23 - No error messages is good.
81:25 - Let me go ahead and zoom in--
81:26 - dot slash int I think
would run the program.
81:29 - Integer, how about 42?
81:31 - Hello 42.
81:33 - And notice, I can save time now.
81:34 - And if I want to run it again, I don't
have to do slash int all the time.
81:37 - It turns out that in this
kind of Linux environment,
81:40 - this operating system called Linux,
you can actually go up and down
81:43 - and see previous commands you've
typed and some others that
81:46 - happen to be system specific.
81:48 - And if you just set up and enter, you
can run it again, type in 50 this time,
81:52 - and see another output as well.
81:54 - So any questions then on
just an example like that?
81:58 - No?
81:59 - Well, let me go ahead, and I'm going
to save time in this environment.
82:02 - I can actually create files in here
if I want by clicking the folder icon,
82:06 - clicking the plus.
82:07 - And then I can actually say give
me a file called float dot C.
82:10 - So this is equivalent to
going back to the main menu
82:12 - and typing in the name of the file.
82:13 - I'm just going to do it
a little more quickly
82:14 - now in this graphical environment.
82:16 - And I want to call it float dot C.
82:18 - It's A bit of a weird name because
at least growing up you probably
82:21 - learned maybe about integers.
82:23 - You probably learned about
real numbers, numbers
82:25 - that can have decimal points and
then things after the decimal point.
82:27 - In a computer, those
things with decimal points
82:29 - are called floating
point values, or floats.
82:32 - And you can think of it as the
decimal point can kind of float
82:35 - to the left or the right, depending
on how big or small the number is
82:38 - or how precise the numbers
after the decimal point are.
82:40 - That's a float.
82:41 - So let me go ahead and implement
a very similar program--
82:44 - include CS50 dot h include,
standard IO h int main void--
82:50 - and this is after 20 years of doing
this that you can do it so quickly.
82:53 - Now let me instead get
a float from the user--
82:56 - so a real number that may very
well have a decimal point in it.
83:00 - I'm going to do that
a little differently.
83:02 - I'll zoom in, and I'm going to say,
hey, computer, give me a float,
83:05 - as is the data type called--
83:07 - not int, not string but float.
83:09 - I'll call it f just because that
sounds like float, and it's nice
83:11 - and succinct-- equals get float.
83:15 - And then I'm just going to say float.
83:17 - That's the prompt.
83:18 - I could make the prompt
in green anything I want.
83:20 - And now I'm going to print it--
83:21 - printf hello f, but I don't want f.
83:25 - I want to actually print out a
placeholder and you can probably
83:28 - guess by now what the pattern is--
83:30 - percent f for a float new
line comma f semi-colon.
83:37 - So this is like the same program three
times now with a string, with an int,
83:40 - and a float.
83:41 - But again, it's just for some muscle
memory and going through the pattern,
83:44 - but let's see what
happens differently here.
83:45 - Let me go ahead and
type make float enter.
83:48 - OK, good, no errors.
83:49 - Let me zoom in and run this
now as dot slash float.
83:58 - And let me go ahead
and type in a number.
83:59 - I'm going to just say 42.
84:01 - But the computer now has the
capability of storing more precision.
84:05 - Before it was just an
integer by definition of int.
84:07 - Now it's a float.
84:08 - So even though it's pretty
precise, this 42.0000,
84:12 - that's indeed a real number now,
storing some amount of precision there.
84:17 - So it turns out though that we
can do more interesting math.
84:21 - Let me go ahead and just
open this example in advance.
84:24 - This one is going to
be called int dot C.
84:26 - So then I don't have
to type everything out.
84:29 - And in ints dot C, we're going to
see some math written in code that I
84:33 - pre-created just to reinforce
that you can actually
84:35 - do some basic arithmetic in a program.
84:37 - I can make see more of the code
here by just scrolling down,
84:41 - and let me scroll this up
so we can focus on main.
84:43 - And let me zoom in on
the first few lines.
84:46 - On this first line, I'm just getting
an int, and I'm calling it x.
84:49 - We've not used a variable
called x recently.
84:51 - But now we are.
84:51 - It's no different logically than before.
84:54 - Here get me another variable.
84:55 - So we can see now that you can get
multiple variables from the user
84:58 - just like in Scratch.
84:59 - And now in these lines, in
green are just some format
85:04 - strings-- just what do I
want printf to display?
85:06 - I literally, in this highlighted line
here, want printf to display x plus y
85:12 - equals something.
85:13 - What is that something?
85:14 - Well, notice what's cool about printf
is that, before it is passed in input,
85:20 - you can perform simple
arithmetic operations.
85:22 - So if you want to add x and y
together, literally do x plus y.
85:25 - Then the sum of those numbers is what
will get handed to printf as its input.
85:30 - Just like I handed Erin's piece
of paper to Brian as input,
85:32 - I'm handing not x and y to
Brian in this case, but x plus y
85:37 - or some value, the actual sum.
85:39 - Similarly, subtraction is
the hyphen on your keyboard.
85:43 - For multiplication, it's not an x.
85:45 - That would be weird, xxy.
85:46 - It's instead star, or an
asterisk on your keyboard.
85:49 - Division is the single slash, and
then this one is a little funky,
85:52 - but we'll come up with
some uses for this.
85:53 - You can actually do modular arithmetic
or just more simply remainders.
85:58 - If you do x percent y, you'll get
back the remainder of dividing x by y.
86:05 - And what's the remainder?
86:06 - So if x is 20 and y is 10, well, 20
divided by 10 goes in twice perfectly.
86:14 - So remainder is 0, for instance.
86:15 - But it's been a while.
86:16 - So notice, though, what's curious here.
86:18 - In this context, percent
is not a placeholder.
86:21 - It's not percent S. It's not percent i.
86:22 - It's not percent Notice it's not
inside of printf's format string.
86:26 - This is just literally
math, a math operator
86:29 - as is implied by the
different color blue there.
86:32 - So if I actually run this--
86:33 - let's go ahead and run this program.
86:35 - I'm going to go ahead
and do our make ints--
86:37 - plural because that's
the name of the file--
86:39 - enter dot slash ints.
86:41 - And let me zoom in and clear the screen.
86:44 - Enter.
86:45 - Give me a number.
86:47 - 2 I heard.
86:48 - And another.
86:50 - 10 I heard.
86:51 - So FYI, 2 plus 10 is 12, 2 minus
10 is negative 8, 2 times 10 is 20,
86:58 - 2 divided by 10 is--
87:02 - 2 mod y, or 2 and then take the
remainder when dividing by y
87:07 - is what mod means is 2.
87:10 - So I get four out of
five for correctness?
87:14 - What's a little funky here?
87:18 - Yeah, 2 divided by 10?
87:22 - Like, I'm pretty sure that's like
2/10 or maybe one fifth or 0.2.
87:27 - I mean, I'll take any
number of answers but not 0.
87:29 - So what's going on?
87:30 - Well, this is a matter
of representation.
87:32 - It turns out in a computer
program, we decided
87:35 - in advance I'm going to store ints.
87:37 - An int is something that does
not have a decimal point.
87:40 - And yet here I am rather
presumptuously trying
87:42 - to do to 2, an integer,
divided by 10, an integer,
87:46 - and expecting something
other than an integer.
87:48 - No, I literally am doing
integer arithmetic.
87:52 - So what's the computer apparently
doing just intuitively?
87:55 - Why, when dividing x by y
as I did in this line here--
88:00 - or specifically in this example
you proposed, 2 divide by 10--
88:03 - where is my 2/10 going?
88:08 - Yeah, it's technically what?
88:09 - Supposed to be 0.2, or 0.2.
88:12 - That's actually the solution
because, if it's 0.2 but integers
88:16 - can't store decimal points or anything
after them, what do you have left?
88:19 - Just the zero at the beginning.
88:21 - So integer arithmetic is fine
if you're working with integers,
88:24 - but if you want floating
point arithmetic,
88:27 - you're going to need
to make some changes.
88:29 - And so I can fix this.
88:30 - In fact, let me go ahead and
write a different program here.
88:33 - Let me go ahead and open up
from the course's website
88:36 - floats dot C. That's going to give
me this example, which is implemented
88:43 - using floating point values instead.
88:46 - So once this loads, I'm going to
see a program I wrote in advance.
88:48 - It's a little shorter because now I
only care about looking at one problem.
88:52 - And notice now x and y are
now floats and not ints,
88:56 - another data type that exists.
88:57 - And I'm using get float, which
also comes from CS50's library.
89:00 - And then this line is almost
the same, but you know what?
89:03 - Let me let me tweak this.
89:04 - Let me just make it exactly the same.
89:06 - This line now that I've highlighted
is exactly the same as before.
89:10 - So if I do type in the same number--
89:12 - so let's go ahead and zoom in and
do make floats plural and dot slash
89:17 - floats.
89:18 - I'll give it 2 and 10, and I
should hopefully see what now?
89:23 - 0.2.
89:25 - That's pretty good, pretty precise.
89:27 - But you know what?
89:29 - I hate to tell you, but
let's look a little farther.
89:34 - It turns out by default,
when you percent
89:36 - f, you only see a few decimal places,
like five or so it looks, by default.
89:41 - Let me see a few more so.
89:43 - This was one one, two,
three, four, five, six
89:47 - points after the decimal point.
89:49 - So you know what?
89:49 - I'm going to say, hey, computer,
give me decimal points.
89:52 - This looks completely
cryptic and you just
89:54 - have to kind of remember this
or look it up if you forget.
89:56 - If you put a dot and a number in
between the percent and the f,
90:00 - that's the cryptic way of
telling the computer show
90:03 - me a float but with this
many decimal places, please.
90:05 - So that just gives me decimal places,
weird as the expression looks.
90:10 - Now hopefully I'm just going
to see some more zeros.
90:12 - So let me go ahead and make
floats, and let me go ahead
90:15 - and zoom in and do dot
slash floats 2 10 enter.
90:20 - OK, still correct.
90:22 - Let me get a little curious.
90:25 - Let's see a lot of
zeros, like 50 of them.
90:28 - Let me go down here and do make
floats, because I changed the code,
90:32 - dot slash floats 2 10.
90:36 - Ha, your grade school
teachers lied to you.
90:41 - 2 divided by 10 is apparently
not 0.2000000 infinitely.
90:49 - It's apparently
0.20000000298023223876953125 and then
90:59 - all of those zeros.
91:00 - What the hell is going on?
91:03 - Where's the bug?
91:04 - Where's my mistake?
91:05 - Where's my misunderstanding?
91:09 - What's the explanation for this?
91:13 - Well, what if I told you that inside
of your computer is stuff like this?
91:18 - This is RAM or memory, and you've
probably generally known this idea.
91:21 - They just store files.
91:22 - They store music and videos.
91:24 - You need memory, some kind of space.
91:25 - Hard disk space is permanent storage.
91:27 - RAM, or Random Access
Memory, is temporary storage.
91:31 - So when your laptop is open and
your desktop computers is on
91:33 - or your phone is powered, you're
using RAM for all of the programs
91:36 - you're running at once.
91:37 - If you open a file, that
file is stored in RAM,
91:40 - but it's permanently
stored on your hard drive.
91:42 - So there's different types of memory.
91:43 - But notice, this is zoomed in.
91:45 - In reality, this is like couple of
inches wide and maybe an inch tall.
91:49 - So it's pretty small, but it
doesn't really matter how big it is.
91:52 - It just matters that
it's finite in size.
91:54 - You have physical hardware on your
laps or in your pockets or at home
91:58 - that only are so big and
therefore only have so many parts
92:01 - and therefore only have
so many transistors
92:04 - and other pieces of
hardware that's actually
92:06 - doing the work of storing information.
92:08 - And so if you only have a finite
amount of memory, how in the world
92:13 - are we going to represent an
infinite number of numbers?
92:18 - Because I do recall
from grade school I was
92:19 - taught there is an infinite number of
numbers, certainly real numbers, where
92:22 - the decimal point can go on forever.
92:25 - That is a problem if you want to
represent all possible numbers
92:28 - in the universe, which is infinitely
many, with a finite amount of hardware.
92:34 - So at some point, the computer's
gotta start cutting some corners.
92:39 - And so what you're really
seeing here is as close
92:42 - as the computer can get to storing
that fraction for you precisely,
92:46 - and I got a little greedy.
92:47 - I looked a little too far to the right.
92:50 - And granted, these are
infinitesimally small values.
92:52 - It's not hugely, hugely
off, but it is off
92:55 - because they can't expect
the computer to represent
92:58 - an infinite number of values
using a finite amount of memory.
93:01 - It's got to round off here or there
and be imprecise, so to speak.
93:06 - So is this a problem?
93:10 - I mean, we would never have known
this if I hadn't gotten greedy
93:13 - and looked at 50 decimal places instead
of 7, which was already pretty precise.
93:18 - Is this a problem?
93:21 - Yeah, like why?
93:23 - Why?
93:24 - AUDIENCE: If you use the
equal function, [INAUDIBLE]..
93:27 - DAVID: Yeah, that's a good one.
93:29 - Logically, if I start using equals
equals to compare things for equality,
93:33 - it's going to be really hard for me
to ever compare something for 2/10
93:36 - as it's value because I'm
going to literally have
93:38 - to remember or write down or figure
out this value and compare against that
93:42 - and not just compare
more loosely against 0.2.
93:45 - And that's true, you should actually
never compare floating point values
93:48 - in code for equality.
93:50 - I could probably get away with
less than or greater than,
93:53 - but even then it's going to be
a little off from what I expect.
93:57 - Why else might this
imprecision be worrisome?
94:02 - When might you not want your
computer being imprecise?
94:05 - What domains?
94:06 - What worlds outside of a classroom?
94:08 - Yeah?
94:10 - What's that?
94:10 - AUDIENCE: Rocket.
94:11 - DAVID: Yeah, so rockets, or anything
involving math and physics and danger.
94:17 - You don't want numbers to
be ever so slightly off.
94:20 - And if you think about it,
rockets is a good example
94:22 - because I don't know much about
rockets, but I know they go pretty fast
94:26 - and there's probably angles
involved because you're
94:28 - trying to keep them on a trajectory.
94:29 - And that's fine.
94:30 - But if your trajectory
is ever so slightly off
94:32 - and something's going
really fast and really far,
94:35 - I'm pretty sure that eventually those
small imprecisions start to add up.
94:40 - And indeed, there's been
historical incidents
94:42 - where that kind of imprecision
does, in fact, add up
94:45 - in the realm of militaristic
operations or in financial operations.
94:49 - In fact, if you've ever seen Office
Space or way back when Superman 3,
94:52 - this is how some people made
some money because they just
94:56 - kept all of the fractions of pennies
that computer systems were just
94:59 - ignoring.
95:00 - And eventually, they start to add up.
95:02 - So long story short, any time
you have scientific or financial
95:06 - or any sort of large data sets that
involve big numbers and lots of them
95:10 - and lots of time, this is a problem.
95:12 - And it almost suggests you shouldn't
you C or let alone computers
95:16 - unless we actually address this.
95:17 - Now as a spoiler, humans have
chipped away at this problem,
95:20 - and you can use more and more
bits but not infinitely many bits.
95:25 - At some point you have
to draw a line, but this
95:27 - is why, for instance, a
stock exchange might only
95:29 - represent two decimal
points of precision
95:31 - for dollars or maybe four decimal points
to the thousandths place for dollars
95:35 - and cents.
95:35 - And they just have to decide,
that's all the precision
95:37 - we can actually store precisely.
95:39 - But you've got to decide how to handle
it and not just ignore the problem.
95:42 - But we can do a little better.
95:44 - You know what?
95:44 - It turns out that in
most computers a float,
95:47 - it takes up, yes, a
finite amount of space,
95:49 - but very specifically 32
bits of space or 4 bytes.
95:53 - A byte, recall, is 8 bits.
95:54 - So 4 bytes is 32 bits, and that's
just a very common unit of measure.
95:59 - But there's another one.
96:00 - It turns out, if you
want twice as many bits,
96:02 - you can literally use a
data type called double.
96:06 - And in the CS50 Library, there
is a function called get double.
96:11 - And if I go ahead and do it here,
I can now recompile this code,
96:16 - make floats, even though they're
not technically float types anymore.
96:20 - And let me go ahead and
do dot slash floats enter,
96:23 - and let me type in 2 and 10.
96:26 - And now it's still imprecise.
96:28 - But notice, instead of seven
zeros, which I think I had before,
96:32 - now I've got 1, 2, 3, 4, 5, 6, 7,
8, 9, 10, 11, 12, 13, 14, 15 zeros.
96:38 - So I've kind of pushed the
problem further out, so to speak,
96:41 - so it's more precise.
96:42 - But it's not perfect.
96:43 - You can't get certain
values perfect if you
96:45 - want to be able to
represent an infinite range.
96:49 - Any questions then about this?
96:52 - And we'll come back as
to some implications.
96:54 - Yeah, here.
96:56 - AUDIENCE: So would it
always be better if you
96:57 - use doubles because it's more precise?
96:59 - DAVID: Good question.
97:00 - Would always be better to use
doubles because they're more precise?
97:03 - Short answer, yes, but we're going
to see thematically in this course
97:06 - and computer science more generally
there's always a trade-off.
97:09 - And yes, if you use a double, you
will avoid this problem a bit more,
97:13 - but what price will
you pay, so to speak?
97:15 - Maybe processing power because it's
got to deal with more bits at once,
97:18 - and even more literally, more space.
97:22 - I mean, sure we can take
your solution, but I'm
97:24 - going to charge you twice as many bits.
97:25 - And back in the day, decades ago,
when C was first being invented
97:28 - and computers were really coming into
play, spending twice as many bits,
97:32 - even if it's only 32
more tiny zeros and ones,
97:35 - that was actually expensive literally
financially, and it adds up.
97:38 - And even today, if you
want to spend more space,
97:40 - that's fine, but you're going to spend.
97:42 - More space, therefore
more money, and therefore
97:43 - have less space available
for other things.
97:45 - So it's just a trade-off.
97:46 - And you have to decide,
as an intelligent human,
97:51 - where the right inflection point
is between what's more important.
97:54 - Let me open up a very different example
now called parity, just as an example.
97:59 - And let me ask this d how do you
know if a number is even or odd?
98:05 - What's the trick?
98:07 - Yeah, if it's divided by
2-- so 0 and 2 and 4 and 6
98:11 - are even because, if you divide
by 2, you don't get a remainder.
98:15 - So actually, if you just want
to see a quick example of why
98:17 - you might use a remainder, even
though it's out of context.
98:20 - Here's an example for parity.
98:21 - Parity is just a term referring
to even or odd in this context.
98:25 - How might we use this?
98:26 - Well, notice I can get an int
from the user up at the top.
98:29 - I can then check the parity
of the integer-- is it even
98:31 - or odd-- with syntax like this.
98:33 - Now I'm combining some
of these operators
98:35 - as you might be inclined intuitively.
98:37 - If n, the number user typed
in, mod 2, or divided by
98:42 - and then check the remainder of, but
that's a mouthful equals equals 0,
98:46 - you just said it's an even number--
98:48 - so print even else print odd.
98:50 - Because what's the
possible other remainder?
98:52 - If you do n or any value divided by 2,
you might get a remainder of 0 or 1.
98:58 - I only have to check for one of
those, 0 because the else implies
99:02 - the other thing.
99:02 - So again, very simple example.
99:04 - But honestly, all of us probably
have an intuitive understanding
99:07 - of what's even and odd.
99:08 - A computer needs to be
taught that, and so there's
99:10 - a program that does exactly that.
99:13 - Let me open up a larger
program called conditions,
99:16 - and rather than type this one out,
because it's a few lines of code,
99:19 - let me just open it up
because it concludes
99:21 - exactly the code we saw a
little bit ago on the slide
99:23 - when we compared it
to a similar C block.
99:27 - In this program, in my main function--
let me focus on the first few lines
99:31 - there--
99:31 - I have an int called x that
I'm getting via get int,
99:35 - another int called y that
I'm getting via get int,
99:38 - and then I'm just doing
some simple comparisons.
99:40 - We saw this again when we
compared it to Scratch,
99:43 - but this is quite simply
that same code in context
99:46 - rather than just seeing
it statically on a slide.
99:49 - So let me go ahead and compile
this-- make conditions enter.
99:53 - It seems to compile.
99:54 - Let me zoom in and do dot
slash conditions enter.
99:58 - x will be, say, 2 again, y will be 10.
100:02 - x is indeed less than y.
100:03 - If I run it again-- and I can save
time by hitting up through my history
100:07 - and just hitting Enter.
100:08 - Let's do 2 and 2, and indeed
x is equal to y and so forth.
100:12 - So again, just the exact same
kind of code as before but now
100:15 - in the context of a working program.
100:17 - What if I actually wanted to get user
input kind of like our past student did
100:21 - with getting a yes or no answers to
the apple and the cupcake question?
100:25 - Well in answer dot C, it
turns out you can actually
100:29 - get textual input from the user,
perhaps a simple yes or no or just y
100:33 - or n for succinctness.
100:35 - And in this case, if I just
get back a single character,
100:37 - it turns out there's a separate
data type for character.
100:40 - If you don't want a whole
string, like a whole word
100:42 - or a paragraph or sentence or
whatever, you just want one character.
100:45 - You can actually use what's
called a char or character.
100:48 - And so here I'm using one other function
appropriately named called get char.
100:54 - I'm storing it in a variable called C
because it's nice and succinct of type
100:58 - char, and then notice this.
101:01 - You might not have seen
this syntax before,
101:03 - especially if you've never
programmed before even in Scratch.
101:06 - But you might have seen this
block similar to this in Scratch.
101:10 - What does the vertical double
bar probably imply here?
101:14 - Or, that's it.
101:14 - So in Scratch, it's
nice and user friendly.
101:16 - They literally just say
O-R. In programming, it's
101:19 - often the case that use just more
cryptic sequences of characters
101:22 - and two vertical bars,
which are typically
101:24 - above the Enter key on a US keyboard.
101:26 - If C equals equals capital y or
C equals equals lowercase y--
101:31 - let's assume that the user wanted
to say yes and go ahead and say yes.
101:35 - Else if the user typed in n in
capitals or and in lowercase,
101:39 - let's assume he or she meant
no and say no accordingly.
101:42 - And what are we going to do otherwise?
101:45 - Apparently nothing, and that's fine.
101:47 - You don't need to have a default case
if you want the program to do nothing.
101:50 - It might be a little confusing because
the user can type in some random word
101:54 - and get no output, but
that's a design decision.
101:56 - Logically this is just
how we might express this.
102:02 - What about actually
building our own blocks?
102:06 - Any questions, though,
before we start to create?
102:11 - So recall that in Scratch
we had that cough example.
102:15 - Let me go ahead and create
a file here real quickly
102:17 - called cough zero dot C and just kind
of recreate what we did last week.
102:22 - Include standard IO
dot h int main void--
102:26 - again, just muscle memory now--
102:27 - and then printf quote unquote
"cough" backslash n semi-colon.
102:32 - And you know what?
102:33 - Let me go ahead and cough not
once, but twice, three times.
102:37 - The moment you start
copying and pasting,
102:39 - you're probably not writing good code.
102:42 - It's not very maintainable.
102:43 - Now if I want to change the word or
translate it to another language,
102:46 - I have to change it in three places.
102:47 - We already decided
last week that was bad.
102:49 - So what would be better in C
or in Scratch or in general
102:54 - than this approach?
102:56 - Yeah, so a for loop.
102:57 - So let me do that let
me create another file.
102:59 - I'm going to call this one cough
one dot C, is my second version.
103:02 - Let me go ahead now and just
copy and paste the original code,
103:06 - and let's just improve it.
103:07 - Let's get rid of two of these, and
let's see if we can't express the 4.
103:11 - So it was 4--
103:13 - let me zoom in--
103:14 - int i get 0.
103:16 - i is less than some number.
103:18 - Before it was 50.
103:19 - Now I'm going to have it be 3.
103:20 - i plus plus curly braces, and now let
me move the cough block inside of there
103:27 - and indent it just to be pretty.
103:29 - And notice stylistically, I've been
doing this instinctively for some time.
103:33 - Everything's nicely indented
just to make it more readable,
103:36 - quite like the Scratch blocks, even
though again a lot of white space
103:39 - doesn't matter to the computer.
103:41 - So if I go ahead and run this--
103:43 - let me pull up the terminal
window so I can see it.
103:46 - Make cough one, enter--
103:49 - looks good-- dot slash
cough one cough cough cough.
103:53 - That's good, but recall that we
actually improved this design further
103:57 - by abstracting it away.
103:58 - Let me go ahead and make
my own function now.
104:00 - Let me go ahead and open
up a new file, cough 2
104:05 - dot C, just like I had
another scratch program.
104:10 - Again, include standard IO dot h
int main void, and then in here
104:19 - let me go ahead and do what?
104:21 - Well, for int i get 0, i less than
3, i plus plus plus curly braces.
104:29 - Then let me go ahead
and just call cough.
104:32 - It would be nice if cough existed, but
unfortunately cough does not exist.
104:35 - It's not in the CS50 library even.
104:37 - So that's not going to help us.
104:38 - I have to make my own function.
104:40 - So in Scratch, you went
to the block's thing
104:42 - and you make your own block
and the big prompt comes up
104:45 - and you make your new puzzle piece.
104:46 - Here we're going to have to
be a little more deliberate,
104:48 - and it turns out you
can do it like this.
104:51 - Some of these details will
be non-obvious at first,
104:54 - but I'm going to go ahead
and call the function cough.
104:57 - And cough at the moment does
not need to take any inputs.
104:59 - So the key word there is void.
105:01 - And we've actually seen that before.
105:02 - Main also has not been
taking any inputs.
105:04 - That's why we had the word void,
but more on that another time.
105:07 - And cough is not going to
return anything either.
105:09 - It's going to print on the
screen just like Brian did.
105:12 - But Brian, recall, didn't hand
me anything back physically.
105:14 - So there's no return value.
105:16 - So I'm going to say void
to the left of cough.
105:19 - So for today's purposes, this just
means that cough neither takes
105:23 - input nor returns a value as output.
105:25 - That's it, void, void.
105:28 - Now as the body of that
function, so to speak,
105:30 - I'm just going to go ahead and say quite
simply cough backslash n semi-colon.
105:35 - That's it.
105:36 - So now I have a puzzle piece, if
you will, whose purpose in life
105:38 - is to cough, which means now I can
magically just call it by its name
105:42 - up here as many times as I want.
105:45 - So let's go ahead and compile this.
105:47 - I'm really on a good roll.
105:48 - Everything's been working out great so
far-- make cough 2, enter, red errors.
105:55 - So this is interesting, and this kind
of reminds me of the previous error.
105:58 - So first of all, what
line is my error on?
106:02 - Seven and character nine, if you
care, but it's seven, on line seven--
106:06 - implicit declaration of function
cough is invalid in C99.
106:09 - C99 is referring to literally 1999
when this version of C was invented,
106:14 - and so implicit declaration
of function cough.
106:17 - But it's right here.
106:20 - OK, wait a minute.
106:21 - Instinct, let me just move this.
106:25 - Let me just put it up top.
106:26 - Let's see what happens.
106:28 - Make cough 2-- oh my god.
106:30 - That fixed it.
106:32 - Why?
106:34 - Even if you've never programmed
before, reason through intuitively
106:37 - why this solved something.
106:39 - AUDIENCE: You are holding
a function that you
106:41 - have had been declared previously.
106:43 - So even though you are making it
void, you at least have [INAUDIBLE]..
106:48 - DAVID: Exactly.
106:49 - Because I previously was trying
to use cough early on line 7,
106:53 - but I was only teaching
the computer what cough
106:55 - was farther down in the file.
106:57 - Frankly C is kind of dumb.
106:58 - It literally reads your code
top to bottom left or right.
107:01 - And if you try to do something
before you've taught the computer how
107:04 - to do that, you're going to get
that kind of undeclared identifier
107:07 - because it just doesn't
know what the word is yet.
107:09 - Now in Scratch, this isn't a big deal.
107:11 - You just move the puzzle
pieces anywhere you want.
107:13 - Order of blocks physically on
the screen does not matter.
107:15 - But in C, it does.
107:17 - But frankly, this
seems a little annoying
107:19 - that now the main program here keeps
getting pushed farther and farther
107:23 - down the more kind of complexity
I want to add to my program.
107:26 - So there's another solution.
107:28 - Let me actually go ahead
and put this back where
107:30 - it is because I'm a little particular.
107:32 - I just like by convention main to be at
the top, and frankly that's good style.
107:37 - If main is the most important
function in your program by default--
107:40 - because it is the main function and it's
what gets called per earlier by default
107:44 - by the computer--
107:45 - why am I going to push
it all the way down just
107:48 - to work around this stupid detail?
107:50 - Well, I just need to teach the
computer what the function is,
107:55 - and I can do that a little
redundantly by just saying this.
108:01 - This is what we're going to call
the prototype for a function.
108:04 - If you literally just
copy the very first line
108:07 - of it that has its name, its inputs
if any, and its output if any,
108:12 - that's a prototype semi-colon.
108:13 - It's literally copy paste
from the function itself,
108:16 - but this is now enough of a hint to
say, hey, computer, this shell exists.
108:21 - This is enough information for you
to then call it because the computer,
108:25 - so long as ir has seen the
function's name before, it's
108:28 - OK if the zeros and ones, so to speak,
that implement it come a little later.
108:34 - And so that's the more conventional
way to solve that problem.
108:37 - So just intuitively then,
take a guess, if it's not
108:41 - too much of a indirect leap, what is in
standard I/O h, what is in CS50 dot h.
108:51 - Those kinds d we'll
call them declarations.
108:54 - So literally in standard IO
dot h is a line of code that
108:59 - teaches the computer
what printf's inputs are
109:02 - and what printf's output is if any.
109:04 - In CS50 dot h, there is
literally a line of code
109:06 - that tells the computer what get
strings input is and what its output is.
109:11 - And the same for get int and get
float and get char and others--
109:14 - that's all that's in those header files.
109:16 - The zeros and ones, so
to speak, are actually
109:18 - in files literally called
standard IO dot C and CS50 dot C,
109:23 - although that's technically source code.
109:24 - The zeros and ones are in a compiled
file elsewhere on the system.
109:28 - But all of these things we've
been taking for granted,
109:30 - now hopefully it makes
a little more sense
109:32 - because, the fact that
I'm doing the sharp
109:34 - include at the top, that's
just a solution to a problem.
109:36 - In that file is enough information
to teach the computer what's printf
109:40 - or what get string and
other things are so
109:44 - that I don't need to bother
moving things around myself
109:47 - or copying and pasting whoever
wrote printf, his or her code,
109:51 - into my program.
109:52 - Now let's do one final
example with coughing
109:54 - and go ahead and call this
call this cough 3 dot C
109:57 - and go ahead and paste my same code as
a moment ago just to get us started.
110:01 - And recall that the last
step of our cough example
110:03 - last week was to actually
give cough an input.
110:06 - I'd kind of like to
whittle this code down
110:08 - to literally cough 3 because this
is a really nice abstraction.
110:13 - I don't want main to have to
think about how many times--
110:15 - just cough three times.
110:16 - That's a nice, useful human abstraction.
110:19 - Now let's put the
functionality down here.
110:22 - So if I want cough to
be able to tolerate
110:24 - an input like 3, which mentions of
void presumably needs to change?
110:29 - The one on the left or the right?
110:31 - The right, the one
inside the parentheses.
110:33 - And it turns out, just like you can
declare variables inside of a function,
110:37 - as we've done, so can you declare
arguments to a function like this.
110:42 - So you can call it anything you want,
though the data type matters, but this
110:46 - is now saying, hey, computer,
cough does not return a value,
110:49 - like Erin did return a piece of paper.
110:52 - Hey, computer, cough
does take one input.
110:55 - It's an integer and just call it n.
110:57 - And now that you've done this, now
you can have a line of code in here
111:00 - like this.
111:01 - For int i get 0, i is
less than n i plus plus--
111:09 - and then, OK, off by keystrokes here.
111:13 - Then I can move this inside
here, indent it nicely.
111:16 - And now notice, all of
the complexity of coughing
111:19 - has been factored out into a
function, my own puzzle piece,
111:22 - if you will, that even takes an
argument so that now you can literally,
111:26 - if I move this far away
and out of mind, now
111:28 - your program is getting pretty
interesting because it really
111:32 - just does what it says.
111:33 - And this is a nice functional
abstraction, if you will,
111:37 - so that now I have a new verb, a new
action, a new function called cough.
111:42 - Any questions on that one?
111:44 - Yeah.
111:46 - Sorry, say again.
111:47 - AUDIENCE: What integer
would main return?
111:49 - DAVID: What integer would main return?
111:50 - It turns out we'll come back to this.
111:52 - It's going to return 0
almost always by default,
111:54 - but that leaves you with almost an
infinite number of non-zero values
111:57 - which represent all of the
many things that can go wrong.
112:00 - So more on that when we
start creating more mistakes.
112:03 - Let's look at one other.
112:04 - Let me go ahead and open
this file in advance
112:07 - myself called positive dot
C. Suppose that I'm not
112:10 - content to just have access to get int.
112:13 - I want a function called
get positive int because,
112:15 - for whatever reason,
my program, my game,
112:17 - my whatever needs to
know a positive value.
112:19 - Maybe I'm asking the user
how many players are there,
112:22 - and that shouldn't be negative.
112:23 - It should be a positive integer
like one or two or more.
112:26 - So it turns out I could write a
program if I want that looks like this.
112:31 - Call on this line here a function called
get positive int, pass it in a prompt,
112:36 - and then store the value, still in
an integer, on the left hand side,
112:40 - and then just go ahead and print it out.
112:42 - Get positive int has this
prototype at the top of the file.
112:47 - Notice this is not a function that
comes with CS50s library, CS50 dot h.
112:50 - The function is called get positive int.
112:52 - As you would hope, it returns
an int, and it takes a string
112:56 - as it's prompt, whatever words
you want the human to see.
112:59 - Let's scroll down now, and this
one looks a little more involved,
113:03 - and this is not a
feature that Scratch has.
113:05 - But let's take a look.
113:07 - The first line is
identical to the prototype
113:10 - because I literally
copied and pasted it.
113:11 - Everything between these
brackets is the function itself.
113:15 - And here, to answer someone's
question from earlier on,
113:18 - do you have to declare a variable
and then use it right away?
113:21 - No, and that's actually a
helpful solution to a problem
113:24 - that we'll see in a moment.
113:25 - Notice here this new keyword--
didn't see it before--
113:28 - do the following while n is less than 1.
113:33 - Previously, we saw a while
loop and we saw a for loop.
113:36 - We did not see a do while loop.
113:38 - And a do while loop, while it
sounds obviously similar to a while
113:41 - loop, what seems a little different?
113:44 - When I had that forever block
earlier translated to while true,
113:48 - what was the order of operations?
113:51 - Did we check the condition, the
true, and then print hello world?
113:55 - Or did we just print hello world
and then check the condition?
113:59 - Yeah, you might not recall
precisely, but I did actually--
114:02 - I checked is true true, and
we all said yes obviously.
114:05 - Printf-- is it true?
114:08 - Printf-- so it checked
the condition first.
114:11 - You might infer then this
loop is a little different.
114:14 - It has another word, do.
114:15 - This is literally going to do this
first and then check the condition
114:20 - and only do it again if
the condition is true.
114:23 - So it's a nice way of just flipping
things around in terms of order
114:26 - to do something at least once
rather than potentially never at all
114:31 - like was the case earlier.
114:32 - So what are we doing?
114:34 - Get an int, passing in
this prompt, store it in n.
114:37 - And if the user types in a
value that's less than 1,
114:40 - is this going to be true or
false, if n is less than 1?
114:44 - So if the human types
in 0, is 0 less than 1?
114:49 - True, yes, so what happens, you go
back to the do and you do it again.
114:53 - If the user types in negative
1, is negative 1 less than 1?
114:56 - Yes or true.
114:57 - So you do it again.
114:58 - If he or she types in
negative 2, again, again.
115:01 - What if he or she types in 50?
115:03 - Well, 50 is not less than one.
115:05 - So this is false.
115:07 - And so then you proceed to the
next line of code altogether.
115:10 - But what's interesting
about the next line of code
115:12 - is that, unlike the cough example,
which had void as its return type,
115:17 - get positive int by default
it's supposed to return an int,
115:20 - just like, again, Erin handed me a
piece of paper with a string on it.
115:24 - And so here, if I want my
own custom function called
115:27 - get positive int to
return value, there's
115:29 - another word in C. You
literally write return and then
115:32 - the name of the variable
or the value that you
115:34 - want to hand back on a metaphorical
piece of paper to whatever code
115:39 - is using this.
115:41 - So what's this oddity?
115:43 - Why can I not do this?
115:46 - If I were to mimic the code
we wrote earlier like this,
115:51 - why does this line of code
not work just logically using
115:55 - some of the mental models
that we've had thus far?
116:00 - AUDIENCE: Declaring the code again.
116:01 - DAVID: Say again.
116:02 - AUDIENCE: Declaring again and again.
116:04 - DAVID: Yeah, so declaring
just means creating,
116:06 - is the fancy way in
programming of saying creating.
116:08 - So this says, hey, computer,
give me an integer, call it n,
116:11 - and set it equal to the
return value of get int.
116:13 - So whatever the function or Erin
hands me back, put it over here.
116:17 - But the problem is that
in C variables have scope.
116:20 - Scope is a fancy way of
saying they only exist in
116:23 - between the curly braces between
which they were declared.
116:28 - So that means that this
variable n literally only
116:32 - exists between here and here, and
then it just kind of goes away.
116:36 - The computer doesn't
know about it anymore.
116:37 - But that's a problem
because, on what line number
116:40 - do we actually need to know n?
116:43 - It looks like 21, and that's
outside the curly braces.
116:47 - So just based on that
basic definition, scope
116:49 - is the two curly braces between
which a variable is declared.
116:52 - It doesn't exist outside of them.
116:53 - This code just won't work.
116:55 - And I'll fix it later so that you
see the correct error message.
116:57 - Why does this not work?
116:58 - Well, you're declaring n
inside of those curly braces.
117:01 - So how do you avoid this?
117:03 - Well, it turns out, as someone posited
earlier, just declare it by itself
117:07 - without even giving it a value.
117:09 - And indeed the syntax for that
is just to do half of a thought--
117:12 - int n semi-colon.
117:14 - It has no value that we know yet.
117:16 - It has a garbage value, but
more on that another time.
117:18 - But it does now exist.
117:19 - And now notice which curly
braces does it exist within--
117:22 - this one and this one, which means
now it's accessible everywhere.
117:27 - And if you in your Scratch
programs actually used variables,
117:29 - you might have noticed
that you had to choose.
117:31 - You had to make a decision for
this sprite or for all sprites.
117:35 - That was an allusion to what's
called in programming a local
117:39 - or a global variable.
117:40 - These are still local, and we'll
come back to this term earlier.
117:43 - But it has to do with scope because, if
you had specified for this sprite only,
117:47 - MIT would have only let you use that
variable for that specific sprite,
117:51 - that cat or sheep or whatever
it was you were programming.
117:55 - Just as in C, this now means
n can be used here and here
117:59 - but not elsewhere like
higher up in my program.
118:02 - That's the matter of scope.
118:05 - So let's now see what
can go wrong beyond that.
118:09 - Let me go ahead and open up
this because it turns out,
118:12 - when programming, there is
other issues that can happen,
118:15 - not just floating point in precision,
as I described it as earlier.
118:18 - It turns out that there's other problems
that can go wrong even with integers
118:23 - that we kind of avoided altogether.
118:25 - So recall that we started talking about
1, 2, and 3 and why it's 123 last week.
118:29 - Well, what happens in
decimal if you add 1 to 123?
118:33 - What number do you get?
118:35 - Obviously, 124.
118:35 - If we do it again, 125, 26 27, 28, 29.
118:39 - What happens in decimal
if I add 1 to a 9?
118:44 - Well, I should get 10, but that's
not how we would write this.
118:47 - You put down the 0 instead,
and you carry the 1.
118:50 - Remember those mental heuristics?
118:53 - So that's all we did there.
118:54 - And then it's 2 plus 1.
118:55 - So that's why 129 plus 1 is 130
because you put the 0, you carry the 1,
119:02 - and so forth.
119:03 - So we just all do that intuitively now.
119:04 - But this has implications
for what computers do too
119:07 - because suppose that we consider
a bigger number like 999.
119:11 - And so what do you get
when you add 1 to 999?
119:15 - Well, you carry the 1, you carry
the 1, and you get hopefully 1,000.
119:19 - But what if your computer only
has space for three digits?
119:24 - Or what if your phone or
what if your alarm clock
119:26 - or whatever the device
is literally only has
119:28 - room for 3 digits, what is 999 plus 1
if your hardware only has three digits?
119:37 - Well, it's apparently 0.
119:38 - So you get this overflow 998, 999, 0.
119:44 - It overflows, so to speak.
119:45 - The one kind of falls off conceptually,
and you roll over to the next value,
119:49 - which is 000.
119:51 - So what about in binary?
119:53 - What number is this in binary if you
translated the decimal in your head?
119:57 - And remember, it's the ones column,
the twos columns, and the fours column.
120:01 - So this was 7 in binary--
120:03 - 1, so it's 4 plus 2
plus 1, so 7 in binary.
120:07 - So how do you do arithmetic with binary?
120:09 - It's actually the same thing.
120:10 - It's just you don't have twos or
threes or nines or anything in between.
120:14 - You just have ones and zeros.
120:15 - So what do you get
when you add 1 to 111?
120:19 - Well, it's the same idea.
120:20 - You put down a 0 and you
carry the 1 because 1 plus 1
120:23 - you want to say 2 in
decimal, but there is no 2.
120:25 - So it rolls over to 0.
120:27 - But you carry the 1.
120:28 - 1 plus 1 is 2, but, OK,
that's 0, carry the 1.
120:32 - 1 plus 1, that's 2.
120:32 - But I don't have a 2.
120:33 - So I go back to 0, carry the 1.
120:35 - So in binary, if you only have
three bytes or bits rather,
120:41 - if you only have three bits, what do
you get when you add 1 to 7 in binary?
120:47 - You apparently get 0.
120:48 - And now it's getting more real.
120:50 - In my computer, in my phone,
in all of your hardware
120:52 - it's just a finite amount of
memory, RAM, that little chip
120:54 - that I showed on the screen
with all the little circuits.
120:57 - And that has more than 3 bits of
memory certainly, but it is finite.
121:01 - And if we're only using, as a
matter of convention, 32 bits
121:04 - to represent things or 64 bits, maybe
if we use doubles or something else
121:07 - called a long-- a long is a 64-bit
integer, whereas an integer is
121:11 - typically 32 bits.
121:13 - It seems that, at some
point, numbers might overflow
121:17 - and we're going to actually
have some, so to speak,
121:19 - imprecision-- ergo, integer overflow.
121:22 - So you can actually see this or
defenses against this in the real world.
121:25 - So this is a screenshot from a game that
is common on a few different platforms,
121:30 - and it's a game that allows you to
accumulate coins or points really,
121:33 - or little Lego pieces.
121:35 - And if you accumulate these points,
you'll notice that eventually,
121:38 - if you have way too much free time, you
can only score so high in this game.
121:43 - What's the highest score
apparently, according
121:45 - to the screenshot from whoever took
this after playing for too many hours?
121:48 - Wasn't me.
121:50 - 4 million-- no, 4 billion, 4 billion.
121:53 - Why is that?
121:55 - Well, it turns out that, if numbers
and computers, as I've proposed,
121:58 - are generally stored using 32 bits.
122:01 - That kind of invites the question, well,
how high can you count with 32 bits?
122:04 - Well, 32 bits means you
have 32 zeros and ones.
122:07 - The biggest they could be
is like 11111, 32 ones.
122:10 - And if you actually do the math using
our little columns and so forth,
122:14 - it's roughly 4 billion, a
little bigger than 4 billion.
122:17 - So the authors of this
Lego game just decided,
122:20 - you know what, let's just
say that the maximum number
122:22 - of points or coins you can accumulate
in this Lego game is 4 billion even.
122:26 - Why?
122:26 - It just looks even cleaner than
whatever the actual value is.
122:30 - But why?
122:31 - How many bits are they using to store
your score in this game presumably?
122:37 - 32 bits or 4 bytes, and
that's just convention.
122:40 - Whatever language they
programmed this game is,
122:42 - probably has a data type called
an int, and that int by convention
122:46 - uses 32 bits.
122:47 - So at some point, they had to
decide, we can either use more memory
122:51 - as you proposed earlier for doubles.
122:52 - Let's use 64 bits.
122:53 - Then you can have crazy numbers
of hours playing the game
122:55 - and getting more and more points.
122:57 - Or we can just say that's enough
points to accumulate in the game.
123:00 - Now that's when you
actually anticipate this.
123:02 - This doesn't always actually happen.
123:04 - If we go ahead and take a
look at some example code--
123:08 - let me go ahead and open up
overflow dot C. In this program
123:12 - here, you'll see line 8
the slash slash syntax,
123:17 - and I've had a bunch of these so far.
123:18 - But I haven't actually mentioned them.
123:20 - It turns out in C, just in Scratch-- the
odds are you didn't notice this little
123:23 - feature of Scratch--
123:24 - you can have what are called comments.
123:25 - A comment is just a note to
yourself, to your TF, to your friend,
123:29 - to your colleague, with whoever
whom you're writing code with.
123:31 - And it's just a note to self to
remind yourself of what the code does.
123:35 - Without this line, I could once,
I'm comfortable enough programming,
123:38 - figure out what these
lines of code are doing.
123:40 - But frankly, that's a waste
of time I wrote the code once.
123:43 - And if I look at it weeks or months
later or someone else wrote it,
123:46 - just tell me what it does.
123:47 - So a comment in a program is just like
a nice summary of a few lines of code,
123:52 - or it's a summary in
English or whatever spoken
123:54 - language that describes what
otherwise a cryptic looking code
123:58 - might actually be doing.
123:59 - So you don't have to think too hard
about it to understand a program.
124:02 - So iteratively double i-- iteratively
just means loopingly, again and again
124:06 - and again.
124:07 - This is funky.
124:08 - We didn't see this, before but
you might guess what it does.
124:11 - What the star equals do?
124:14 - It does double.
124:15 - It's like plus equals
adds 1, star equals
124:18 - doubles if the value on the right is 2.
124:20 - So this is going to start printing
1 then 2 then 4 and 8 and so forth.
124:26 - And notice this function.
124:27 - It's called sleep.
124:28 - It literally is going
to sleep for a second,
124:30 - and that sleep function has a prototype
that someone else wrote in a file
124:34 - called uni standard dot h.
124:36 - I only know that by looking
it up in the documentation.
124:39 - But that's a new file just for sleeping.
124:41 - Make overflow, which is apt here.
124:44 - And let me go ahead and make
the terminal window even bigger
124:47 - for this one-- dot slash overflow.
124:51 - OK, it's going.
124:54 - It's going.
124:54 - It's going to go faster
and faster, so to speak,
124:56 - because we're adding more and
more each time by doubling.
125:02 - 2000, 4000, 8000, 16,000--
125:06 - it's still going-- 64,000, 65,000.
125:10 - Now we're into the millions--
125:11 - 2 million, 4, 8, 16 million.
125:15 - It's getting bigger and bigger,
all of these big numbers.
125:21 - Ooh, interesting.
125:23 - What just happened?
125:25 - So it turns out, if you double numbers
big enough, you get 0 eventually,
125:28 - also something you
probably weren't taught.
125:30 - So what actually happened?
125:32 - Control-C, we'll cancel this.
125:33 - What happened?
125:34 - I mean, the program is trying to tell
me, even though it's a little cryptic,
125:38 - signed integer overflow.
125:39 - Signed just means it went from
positive to negative essentially.
125:42 - So what happened?
125:45 - What's that?
125:46 - Yeah, it ran out of bits.
125:47 - I'm doubling the number
again and again and again.
125:49 - And at some point, we carried the
one so to speak and it was a 33rd 1,
125:53 - therefore past the
boundaries of a 32-bit value,
125:55 - and it just rolled over to apparently
a negative because at some point--
125:58 - and we haven't talked about it--
126:00 - you can use like the leftmost bit in
some sense to say positive or negative.
126:03 - We've just talked about positive so far.
126:05 - And then at that point,
frankly, the computer
126:07 - just gave up not really knowing
what you intended beyond that.
126:10 - So if you don't write code
to handle this situation
126:13 - and make sure that your numbers are less
than 4 billion before you roll over,
126:17 - just bugs will happen.
126:19 - And this might seem contrived here,
but this happened not too long ago.
126:23 - So 1999 was just before
a lot of people thought
126:26 - the world was going to end
because of the so-called Y2K bug,
126:30 - and it really wasn't so much a bug
as it was lack of forethought or lack
126:34 - of features.
126:35 - What was the Y2K problem in a nutshell?
126:41 - Someone want to propose?
126:42 - Even in a non-technical sense, yeah.
126:44 - AUDIENCE: Computers couldn't
display the number 2000.
126:47 - DAVID: Yeah, so let me summarize here.
126:50 - So if they are only using
two digits to display values,
126:54 - you could confuse the year 2000
with actually the year 1900 because,
126:59 - long story short, what humans did
kind of reasonably decades ago was--
127:04 - space was expensive.
127:05 - Computers were expensive.
127:06 - Memory was not as abundant as
it is now with all the cloud
127:10 - storage and the like.
127:11 - So you know what?
127:12 - If it was like 1970, do we really
care about 1969, 1968, let alone 1900?
127:18 - Not really let's just assume
we're all in the 1900s
127:21 - and never show or store one 9.
127:24 - Let's just store two
digits for every year.
127:26 - So 70 is '70 99 is 1999.
127:30 - But the problem is the
humans ended up running code
127:33 - that they wrote years ago,
decades ago way longer than humans
127:37 - thought they might why.
127:38 - Well, it's expensive, it's
time consuming to change code,
127:41 - the code is working.
127:42 - Why try to break it?
127:43 - Problem is, too, as people
aged in and passed away,
127:46 - there's fewer and fewer people that
even knew the languages in which
127:49 - those programs were written in.
127:51 - And so now who's going to
even update the software?
127:53 - So lots of problems were
feared, and this really just
127:57 - boils down to because 1999
might have overflowed to not
128:01 - zero per se but an implicit 1900.
128:05 - And indeed, this definitely
happened, though not nearly
128:07 - on the scale as people thought.
128:08 - But it does happen in even more
real terms just a few years ago.
128:11 - This is a Boeing 787,
an actual airplane that
128:15 - had to be grounded for
some amount of time
128:17 - because it had a programming error.
128:20 - And its summarized here
in an online article.
128:23 - A 787 airplane that has been
powered continuously for 248 days,
128:29 - it turns out was the warning, can
lose all of its electrical power
128:34 - due to the generator
going into fail safe mode.
128:37 - Why is that?
128:38 - This condition is caused
by a software counter
128:41 - internal to the generator
that will overflow
128:44 - after 248 days of continuous power.
128:48 - So translate that.
128:49 - That just means there's software
running in the Boeing's actual 787s.
128:53 - They were using 32-bit integers.
128:55 - They were using those integers
to store hundredths of seconds.
128:59 - And at some point if you leave your
plane on for 248 days, each of which
129:04 - has 24 hours, 60 minutes in an
hour, 60 seconds in a minute,
129:09 - and 100 tenths of a seconds or 100 one
hundredths of a second in every second,
129:15 - that product of multiplying
things out gets big pretty fast.
129:19 - And on day 249, planes
theoretically would shut down even
129:24 - in the middle of flight
for very real reasons
129:26 - because a really big
number rolls over to zero
129:28 - and that confused the generator.
129:30 - And these are actual
smart airplane engineers
129:34 - making these kinds of
mistakes because of software,
129:36 - not anticipating one line of code
or some number of lines of code.
129:39 - Or, as you proposed, why
didn't they just use more bits?
129:42 - And again, these are very real concerns.
129:44 - So this was thankfully addressed and
solved, but not before of course there
129:48 - was quite the scare there.
129:50 - So it turns out, in an older game,
this was the game of Civilization.
129:53 - It turns out that one of the
characters as whom you can play,
129:56 - Gandhi, is actually not as
peaceful a character in the game
130:00 - is as you might think.
130:01 - And let's for context just
take a look here for a second.
130:04 - If we actually take a look at
some more binary, this in binary
130:10 - is what number in decimal?
130:12 - OK, 1.
130:13 - And this is 8-bit.
130:14 - So it's a full byte.
130:15 - 8 bits is a byte--
130:16 - 1, 2, 3, 4, 5, 6, 7, 8.
130:19 - So what do you get if you do a 1 minus--
130:24 - well, if you subtract 1 from
this, you obviously get what?
130:27 - All zeros.
130:28 - So 1 minus 1 is just 0.
130:30 - What if you subtract 2 from this value?
130:34 - What happens?
130:36 - This is actually called integer
underflow, which is just the opposite,
130:39 - but there's really not too many
options to think about this.
130:41 - If you only have zeros
and ones, you can probably
130:43 - imagine what the bad scenario is.
130:45 - If 0000001, if you subtract 1, goes
to zeros, and then you do it again,
130:50 - you now underflow, which just brings
you around to the opposite 11111111.
130:57 - So if you have 8 ones, what
value is that if you do the math?
131:01 - Ones, twos, fours, eight 16s.
131:04 - It turns out it's 255 if you
actually do all the math.
131:07 - So it turns out that
this game Civilization
131:10 - was using a single byte to
represent every character's
131:13 - level of aggressiveness in the game.
131:15 - And Gandhi's was, as you
would expect, by default
131:17 - initialized to 1, very non-aggressive.
131:20 - Unfortunately, in this
game of Civilization,
131:23 - when a player adopts democracy
in his or her civilization,
131:27 - their aggression would be
automatically reduced by two.
131:32 - And so if Gandhi went democratic, his
aggression wouldn't go to negative 1.
131:36 - It looped back around to the
ludicrously high figure of 255,
131:40 - making him as aggressive as a
civilization could possibly be.
131:44 - So less impactful, to be sure, than
something like the airplane example,
131:48 - but these problems are omnipresent.
131:50 - And if you start to keep an
eye out in the popular media
131:52 - or when there are bugs
or hacks or exploits,
131:54 - it's so often because a programmer
has made a mistake in his or her code.
132:00 - They didn't anticipate a scenario or
they made maybe reasonable decisions
132:04 - years ago, but that
eventually proved to be
132:06 - naive in that we're still running the
same code, numbers are getting too big,
132:10 - their math is wrong.
132:11 - And so very real things happen.
132:12 - But what's most important
for us is just understanding
132:14 - how and why those things happen.
132:17 - And so what will we
do in the days ahead?
132:19 - So the next homework assignment, as with
Scratch, will be to program something
132:21 - but this time in C. You
will use an environment
132:23 - called CS50 lab, which essentially
is CS50 sandbox, with which we've
132:27 - been tinkering today.
132:28 - But it adds to it the instructions
and the specification of the problems
132:31 - that you'll want to solve.
132:32 - And it'll hold your hands initially
through some of these steps.
132:34 - You don't need to have written
everything down and memorized
132:36 - everything I typed today, but
do feel free in the meantime
132:39 - to go to the course's website and
play with any of those examples.
132:42 - Among the challenges ahead will be
to recreate some snippets of games
132:46 - from yesteryear, thinking about how
things you might have seen growing up
132:49 - can be translated to actual code.
132:50 - And undoubtedly, among the first things
you'll experience, is frustration.
132:54 - You'll forget the stupid semi-colon
or where does the parentheses go?
132:56 - And you'll have to look back at code.
132:58 - But keep in mind, none
of that stuff matters.
133:00 - It's absolutely frustrating initially,
but what's most important is the ideas
133:03 - and, honestly, the
sense of gratification
133:05 - that you, like all of
CS50 staff before you,
133:08 - ultimately feel when actually building
and creating something of your own.
133:11 - Let's call it a day there,
and we'll see you next time.

Cleaned transcript:

SPEAKER 1 This is CS50, and this is week 1. And by the end of the day, you will know how to create programs that look like this. So this, of course, is binary. This is the only language that machines ultimately understand. But thankfully, per last week, there's so many abstractions and there are so many humans that have come before us that we don't actually have to write anything at this level. We can abstract way above it like we did with Scratch already and like we will starting today with C. But does anyone nonetheless want to take a guess at what that program, when fed to your Mac or PC, actually does? Anyone recognize? Anyone want to hazard a guess? It's perhaps the simplest program you could write. Indeed, it does, when fed to the brain of your computer, the socalled CPU simply prints that. So how do we actually get to that point? Well, recall where we started this conversation last time talking about computer science more generally and problem solving we proposed could be distilled really is this. You've got some inputs. You want some outputs. And somewhere in the middle, you need to do something with those inputs. And to get to that point, though, we had to represent those inputs and outputs. We just had to decide as humans, how are we going to represent all of the inputs to our problem when it comes time to have a computer actually process them. And at the end of the day, all of the phones and the computers that we're all using only at the end of the day plug into the wall to get their physical resource, electricity, and they might store that temporarily in a battery. But that really is our only input. It's either plugged in or it's not. It's either a 1 or a 0, true or false. So the world really reduces to those two states, so to speak. And so you can think of those states then as just being like a light bulb, on or off. I pulled up my cell phone last time to turn the flashlight on or off, 1 or 0, true or false. Now of course, if you only have one light bulb, you can only count from 0 to 1. But if you start to have a bunch of them back to back to back to back, you can permute them like I did my finger 0, 1, 2, 3, and so forth. And so we started talking about binary more generally. And so here for instance were three sequences of 0's and 1's and each of those represented something, but we don't need to think about the world at that level. We can abstract on top of that. All of us are so much more familiar with decimal of course, and indeed recall that this was just 72, 73, and 33, which if anyone recalls, when you use ASCII which is this global standard for mapping numbers to letters we got what message? Yeah, it was just high, capital H capital I exclamation point. And so that's an abstraction on top of those otherwise binary numbers. But we don't have to model just text using numbers. At the end of the day, our only resource is still that electricity, and the only way we think about it digitally is still zeros and ones. But if we take the same value 72, 73, 33 and treat them in the context of Photoshop or a photo program or a graphics program, we can instead interpret them as like some amount of red, some amount of green, some amount of blue, which gave us last time, recall, this yellowish color. So now we had another abstraction on top of binary colors, and this is just one pixel. What can you do once you have more than one pixel? What can you represent next? Yeah, right, images. So we're continuing the conversation up and up and up, and we could represents something like a graphical emoji on the screen, which has more than just one yellow dot. It's got a whole bunch of yellow dots and other colors as well. And recall that, if we want to animate things, whether it's through silly things like animojis on a phone or just more proper videos and movies, well, those are just sequences of images flying past your human eyes really quite quickly. So that's where we kind of left off last time starting at the base level and abstracting away so that we could stipulate thereafter we can represent inputs, and we can represent outputs, whatever those happen to be. And here on out, we don't need to think at that level. We can just assume we all know how to do this. And even if it eventually becomes kind of a distant memory, we know that someone can indeed do this. And that's the value of abstraction. But inside of this black box are socalled algorithms, the secret sauce this is where the problems are actually solved. And we not only talked about what these algorithms are, but for instance, how efficient they were. So recall that this red line represented a very simple algorithm just turning the phone book page by page one at a time. And the reason that it's a straight line is because there's a one to one correspondence between how many pages there are in the book and how many page turns there are one page, one more page, one more turn, and so forth. If I fly through it at twice the speed 2, 4, 6, 8 I can do better. And so that yellow line now, recall, was lower on the graph. If you just look at any two points, yellow and red, yellow is below red, saying it takes less time. But it was not quite correct. There was one bug when I was looking for Mike two pages at a time. What was that issue? Yeah, I might miss him. He might accidentally get sandwiched in between two pages not a huge deal because I could fix it, but I have to fix it. I have to apply that additional logic and double back at least a page if I go too fast. But of course the final algorithm and frankly all of our initial intuition probably was the dividing and conquer, open it roughly to the middle, look down, and then go left, and go right, and just repeat that process as the problem gets this big to this big to this big to this big to just one page left. So that was all about efficiency. But to get to that point we needed to express ourselves more precisely. And so we introduced pseudo code. There's no formal definition. It can be English, English like. It's just meant to be succinct and get the point across. And recall that, along the way, we introduced a whole bunch of concepts, many of which you probably experimented with Scratch, like loops and conditions, Boolean expressions, variables, and so forth. And those were building blocks that came out of this kind of demonstration here. But honestly, even in this demonstration, in this pseudo code, there were a whole bunch of assumptions. If you read these instructions one at a time and you're holding the phone book yourself, odds are you can execute this pseudocode, this algorithm. But what does it really mean to, say, open to the middle of the phone book? All of us have an intuitive understanding of what that means. But honestly, if you were explaining that to a kid or someone who's learning English or whatever language for the first time, open to the middle of the phone book, you should probably sets forth some assumptions. OK, this thing in front of you has 1,000 pages, pieces of paper. Turn to the 500th page, and let's call that the middle. This would very quickly get tedious if all of us humans are talking at that level of detail. And so we abstract away with more sweeping statements like open to the middle of the phone book, but that's an abstraction. And it's not quite as precise as is probably ideal, especially feeding this algorithm to a newbie or to a robot or a computer. But it's useful because we can then make a 12 step program instead of a 20 step program by elaborating too much. And for instance, throughout here too we had our loops and conditions and so forth, but even call Mike. What does that mean? Well, if you imagine that the human knows how to use the phone, then it goes without saying. But if he or she also needs to be programmed to use the phone, you've got to explain pick it up, hit this button, type this sequence of buttons, and so forth. So call Mike is also an abstraction. So these abstractions are useful, but they can sometimes get in the way, especially if you're not precise enough to program the computer correctly. And to paint this picture, I thought we could begin a little heartedly here. I brought some breakfast, if you didn't quite make it next door or beyond. Just need a couple of volunteers if you're comfortable appearing on stage and on the internet here. Let me kind of there's a lot of lights here. How about over there on the left and over here in the front? Yeah, right there. I think your hand was up. Come on down. And Brian, do you mind lending us a hand here, too? Come on down. If you want to take control here, let you go ahead and switch over to another program for you. What's your name? JEAN Jean. DAVID Jean, David. Nice to meet you. Have a seat on the far left. And your name? ABBY Hi, I'm Abby. Nice to meet you as well. On the far right if you could. So Jean and Abby, do you want to say a little something about yourselves quickly? JEAN I'm Jean. I'm a Massachusetts native, and I'm taking CS for the first. It's my first coding or anything. Or I'm doing and I'm enjoying it. DAVID Nice, glad to have you with us. And Abby? ABBY Hi, I'm Abby. I'm taking this as a sophomore, and I know nothing about computers or computer science. So I'm probably taking it stat on stat. DAVID OK, well, nice to have you as well. So in front of us is a whole bunch of ingredients, and hopefully we can start this semester off gently. And if we're successful, we'll actually have a quick bite here. But we thought we'd defer to the audience here, and Brian's going to scribe as we go. And all we want to do this morning is just make a peanut butter and jelly sandwich, one instruction at a time. And each of us will just execute what we hear. How does that sound? All right, if someone could volunteer with the first instruction and Brian will type it down. AUDIENCE Open bread. DAVID Open bread we heard. Open bread is the first instruction. So each of you would like to execute open bread. No, don't look at me. All right, so we're kind of on our way. I think Abby did it better certainly, but we did it correctly arguably. So let's move on to step 2 and see if we can't improve. Take out bread. Welcome to the team now. Nice, all right, step three. Yeah. AUDIENCE Place two pieces of bread on the table. DAVID Place two pieces of bread on the table. Never mind the plates. OK, step four. AUDIENCE Twist cover of jelly till it opens. DAVID Twist cover of jelly till it opens. Thank you. Step five? Step five? Yeah? AUDIENCE Place the lid to the side. DAVID Thank you. Place the lid to the side. I took some liberties myself. AUDIENCE Take the knife. DAVID Take the knife. Peel off the cover of the jelly. No covers on ours. Stick knife into the bottle? From the top. Stick step nine. AUDIENCE Rotate hands so jelly ends up on. DAVID Rotate hands so jelly ends up on OK, step quickly 10. Yes, step 10? AUDIENCE Pull out knife. DAVID Pull out knife. OK, step 11. Jelly side down on bread. All right, step 12. Step 12, anyone? Yes. Thank you. Step 13. Pour jelly on bread. JEAN Pour jelly DAVID Pour jelly, jelly. All of it? OK, now you're just messing with us. Step 14. AUDIENCE Put jelly down. DAVID Put jelly down. Thank you. 15? Pick up peanut butter. AUDIENCE Take the lid off. DAVID Take lid off. Thank you. Peel off lid. Thank you. Step 18? Pick up knife by blunt end, scoop. Scoop. Step 20? Put peanut butter on bread? 21? AUDIENCE Move the knife left to right. DAVID Move move the knife left to right, please. Left to right. Step 22? AUDIENCE Put down knife. DAVID Thank you. 23? AUDIENCE Put down jar. DAVID 24. What was that? Eat sandwich. OK, I think we're well, why don't each take a bite? And a round of applause, if we could, for our volunteers. Thank you. ABBY Mind if I take some for the row? DAVID You can take some for the row if you'd like. Thank you. So thank you, Brian. OK, now I need a minute. Thank you. So suffice it to say, this obviously demonstrated even more so than the phone book example where our certain assumptions are and our abstractions are. And honestly, almost all the time those are useful. And of course, we kind of hammed things up. And I think the instructions were kind of helping with that here. But when it comes time to program with Scratch and certainly with C starting this week, you can't really make as many of those assumptions anymore because, if you don't handle these corner cases and if you don't think about what that instruction means, you're going to get the proverbial spinning beachball or the hourglass that you're familiar with on your Mac or PC. The program is going to crash, something's going to go wrong just because you miss some specificity or precision. Now we're full of peanut butter. So over time, we're going to find that, much like in Scratch, we were able to make our own building blocks. You might recall the short examples we did with the cough example where I had cough 0 and then cough 1 and cough 2 where I was making my own puzzle piece within Scratch. That was useful because, after that example theoretically, I never again need to think about or worry about how to implement cough. I can just use that abstraction. But someone has to implement them, and sometimes it's going to be other people who have come before us. And sometimes it's going to be us. So this isn't to say that programming ends up being so tedious that you have to point out every little thing, but you or someone does have to do that level of precision at least once. And nicely enough in Scratch, MIT did most of that legwork for you. We all had the building blocks with which to make our own animation or game or artwork or the like. But even then, you probably had to connect several dozen puzzle pieces or even more to get those fundamentals to do what it is that you wanted it to do. So today we're going to start to transition from Scratch, this graphical programming language, that while targeted at younger students, is typically representative of a lot of the same concepts that are now going to be laced throughout the semester. But we're going to introduce today an older, more traditional language that's just text based. And as such it's a lot more powerful. But at first glance, it's actually going to look a lot more cryptic. In fact, instead of writing zeros and ones starting today, we're instead going to write something like this. Now if you've never programmed before, odds are, at first glance, this does look pretty cryptic, and there's a lot of symbols within it, punctuation from the keyboard. There's probably some familiar English like words. And frankly, even after doing Scratch anyone, even with no prior background, can probably hazard a guess as to what this program written in this other language called C does when you run it. It just prints hello world. Now granted there's a decent amount of overhead syntactically. There's a bunch of stuff you have to type to make this program do what you want it to do. But at the end of the day, that's all it's going to do. And this is among the simplest of programs we're going to add to our puzzle pieces, so to speak, today and see some of those same concepts that we saw last time as well. So let's do this first though. Let me take a moment to compare Scratch to C because the most important takeaway for today is going to be that, even if the syntax doesn't look so obvious and frankly, even if your first minutes or hours with writing your own code in C is frustrating because, oh, dammit, you left off a semicolon or, oh, I had a parenthesis in the wrong place. There's a lot of these stupid syntactic hangups that make you feel quite often that you really aren't getting it. But that's not the important stuff. A lot of the syntax is the least important. That's not at all fundamentally intellectually interesting. So try to see past that, and try to take comfort in the fact that it's the principles that are going to be important. And honestly, just muscle memory and practice, all of the other stuff that at first is going to be an occasional frustration, it just starts to go away as you start to see this for what it is and not for the syntax alone that you see on first glance. So this is to say this program on the right in C is equivalent to what we did just a week ago with two puzzle pieces in Scratch. Now there isn't going to be a green flag on my Mac or my PC as we move forward that you can just click. We're going to run these programs in a little different way, but that's all the code on the right is doing. It's equivalent to the code on the left. So let's do this again and again for just a few of those concepts from last time, and then we'll start writing some of our own programs. So this was an example, this purple block, of what concept in programming? Yeah, a function. So it was a verb. It was an action, and we're going to call those generally functions. They just have functionality built into them. So how do we do this in C? Well, you might remember from just a moment ago, because one of the lines of code was representative of this, it had some of this syntax. So in fact, if I were to translate the block on the left in Scratch to the equivalent code in this other text based language called C, I'm going to start by writing print and then open parenthesis and then close parenthesis. And those parentheses represent the oval, the white oval on the left, that we typed hello world into before. Now in C, it's not quite as literal as that. The function, or the verb, is actually not called print. It's called printf, and the F stands for formatted. And it just means that in C you can actually format your text in different ways. So we'll see that before long, and it turns out that you don't just write hello world between those parentheses like we did in Scratch. You also actually have to surround them with double quotes in C. Not such a big deal, but something you didn't have to do before. But in C, you're also going to generally want to be super specific to the computer. And when you want the cursor the text on the screen to move down to the next line, you need to tell the computer that by literally typing backslash n. The human is not going to see a backslash and an n. He or she is actually going to see the cursor move to the next line of the screen like in Google Docs or in Microsoft Word or the like. But this just speaks to the precision that you need to have when talking to a computer at this level and not just with the puzzle pieces. And then one last thing and I alluded to it earlier because it's the bane of a lot of programmers early on. Most lines of code in C have to end in a semicolon. That's the sort of code equivalent of a period in an English or some other languages sentence. So that's it. It took us a little while to build that up. But that's all it is. The idea on the left of saying something is the same in C as printing something with this function called printf. And before I forge ahead with some other comparisons, any questions on just this translation? AUDIENCE How do you write backslash n? DAVID How do you write backslash n? Good, so thinking ahead, this would seem to make it hard to literally show the user backslash n. Well, it turns out that this backslash, because it's not a terribly common character, the programming world uses it as what's called an escape character. It's one that you use when you want to escape information and show it in a slightly different way. So the way you would show literally to the human a actual backslash n is to actually in your code do backslash backslash n because the second backslash is like saying treat the next character special and actually show it to the human. And there's other such examples of that. So how about this one? This orange block was an example of one concept in Scratch? Yeah, so this was a variable, like an x and y in algebra. This was just a placeholder for data, and you could store numbers. It turns out you can store words. You can store other things too in other languages. So in C, we're going to do this. We're going to say, literally, the name of the variable we want for instance, counter. But we could call anything we want equals zero if we're setting it initially equal to zero. But C is a little more pedantic. You've also got to tell the computer, the type of variable I want is specifically for an integer, otherwise abbreviated int. So you have to tell the computer in advance what type of data you're going to store on it. And take a guess. You've got to finish the thought ion C. What more do we need to add to the yeah, just a semicolon. And that's it. It looks a little more cryptic, but the idea is fundamentally the same. So what if we wanted to do this in Scratch? Change counter by 1 this was equivalent to incrementing or adding 1 to counter. Well, let me go ahead and propose that you could literally just do this in C. Set counter equal to whatever counter currently is plus 1. That seems to be the right intuition. And now notice, what's key to note here is that this equal sign isn't saying that counter equals counter plus 1 because that just doesn't seem possible. If you pick any value for counter, like the number 1, well, one definitely does not equal 1 plus 1, which is 2. And 1 does not equal 2, and you can come up with an infinite number of worrisome incorrect comparisons. So the equal sign in C, like a lot of languages we'll see in the class, actually means assignment. Copy the value on the right into the value on the left. So set counter equal to whatever it is plus 1. What? We've got to finish the thought. So we need a semicolon. I don't though need to remention int, and why might that be? Yeah, I already told the computer it's an integer. You don't need to repeat yourself by mentioning int again, assuming in this context, even though we're looking at it just on the slide, has actually been created before just like you did with Scratch by saying make a variable. So it turns out you can be a little more succinct in C and a lot of languages. If you find this a little tedious to type and it's a little verbose. It's a bunch of keystrokes. You can actually abbreviate it with just this. So plus equals is just syntactic sugar, as a programmer would say. It's just a nice fancy feature that lets you write fewer words or characters but do the same thing. And frankly, we can do a little better. And if you've taken a PCS, you might have seen this in Java as well. You can also simplify this even more to just counter plus plus semicolon. So that's it all equivalent. This is just a little more efficient. And as you get more comfortable programming, saving keystrokes just saves you time. Now this of course was an example of what in Scratch by contrast? Yeah, we called this a condition. And it had a Boolean expression that we were asking a question of. In this case, we're apparently asking in Scratch is x less than y and, if so, say it on the screen. So how might we translate this to see? Well, it turns out we can quite simply translate this one pretty literally. We've seen almost all of the building blocks thus far, but we do have to introduce a little something new here. Notice that the printf line is almost identical to what I used earlier for just hello world. I've obviously just changed the words in it, but I still have the backslash n. I still have the quotes, still have the semicolon. So the rest of that is the same. Now if is new, but this is a one to one translation. Scratch calls it if. C calls it if. And the only additional thing you need in C is parentheses around the Boolean expression. So that's what takes the place of the little green block there. And then assuming x and y are indeed variables that we created earlier, you can just compare them like this and you can use greater than and other symbols for comparison as well. But there is something a little interesting, and most of us don't often have occasion to even use these keys on our keyboard. Curly braces, on a US keyboard they tend to be over on the top right above your Enter key. These are just C's equivalent of this shape. Notice that most of the yellow blocks in Scratch had this embracing or this embracing shape to them. You can simulate that in C by having what's called an open curly brace and then a closed curly brace. So that's the same exact idea. Now as an aside, you don't technically always need these curly braces. If you just got a one liner like this, you can omit them as you might see online or in textbooks. But we'll just always draw them for consistency so that the C code always looks like this. What if you wanted to express this, though? If x is less than y, then say x is less than y, else say x is not less than y. Well, it turns out this is almost identical. The first four lines, perfectly the same as before. But it turns out in C, you can literally say else after that closing curly brace. And then just print out alternatively whatever it is you want to say. So this is like the fork in the road. If you go one way, say this. If you go the other way, say this other thing. Any questions on these comparisons thus far? Yeah. AUDIENCE Should we put the first bracket on the same line as the if? DAVID Really good question. Can you or do you put the curly brace on the same line is the if? You can, and we're going to talk about this the next couple of weeks, this matter of style. There are different ways I could express this exact same code. Frankly, I could write out all of this code with no spaces whatsoever. In fact, just to make that point, if I go ahead and just open up a simple text editor here not to actually program, but to just type something I could actually do something like this if x less than y. Then go ahead and print out x is less than y backslash n semicolon curly brace else print and so forth completely unreadable at the end of the day or unmaintainable, especially when the code gets complicated. But whitespace does not tend to matter to the computer, but it does matter to the human. And as you're alluding to in some languages, it's actually conventional to do this, where you actually keep the curly brace on the same line. And indeed, you might see textbooks do this as well. Some people will even do this. These are all long story short matters of style. In CS50, in the earliest weeks of the class, we're going to insist that everyone follow the same style so that we have some basis for comparison. But eventually, this is the kind of thing that, like in your own English writing or whatever language you tend to write in, you have your own stylistic or linguistic flair to it. Code has that as well. Other questions? Yeah. AUDIENCE When you establish the countervariable, do you always have to say what it is equal to, or can you just say int counter section? DAVID Really good question. When you declare a variable, create a variable, do you have to set it equal to something right away? Short answer, no. And we'll see examples of that before long, where you can actually say give me a variable called counter, but don't actually set it equal to some value. Come back to that in a bit. So what if we want to add this logic? Frankly, in Scratch it's starting to look a little overwhelming. But this is just a three way fork in the road. If x is less than y, say so, else if x is greater than y, say so, else if x equals y, then go ahead and say they're equal. And in C, we can do this translation pretty directly as well. In fact, now the first eight lines of code are identical to before except this middle one here where I'm adding a second Boolean expression. Is x greater than y? And then I have this third condition, else if x equals y. But there seems to be a typo perhaps or something anomalous here. So anything jump out? Yeah. I have a double equal sign, which maybe is just a typographical error on my part, but turns out it's not. This is deliberate. But why? This seems like our first example of where Scratch doesn't really map perfectly to C? AUDIENCE Well, because the equal sign is like an assignment. And so counting the equal sign actively sets it equal DAVID Exactly. We already a moment ago decided as humans or really, years ago equals is actually in the context of C going to be assignment copy the value from the right to the value on the left. And so we kind of painted ourselves into a corner. We still as humans, as programmers, want to be able to express the notion of equality and comparing. But if we've already used the equal sign for assignment, we need another pattern of symbols to represent equality. And as it turns out, humans just chose two equal signs instead so slightly different from Scratch. The reason Scratch does it this way is because you don't really want to have to get into those weeds certainly when the target audience is 8yearolds just learning to program in the first place. It's not important nor is it really important for us. But for us there's going to be a logical difference because, if we use the wrong one, the behavior is going to be wrong. If we had just one equal sign, we would literally be changing x to equal y rather than just comparing it. Was there a hand in here? Yeah. AUDIENCE Just a quick question. So if you wanted to express greater than or equal to, would you write equal and greater than? DAVID Good question. If you wanted to express greater than or equal to, how might you do that? It turns out there are ways to do that. And if I go ahead and just give myself someplace to draw here for a moment, you can actually indeed do less than or equal or greater than or equal. There's no way on a typical keyboard to put them atop each other like you might recall for math. You just put them next to each other. Well, it depends. I want the double equal sign here because I want to explicitly check this third case and say x is equal to y. So that was my goal. But logically, this is not necessary. Let's make the program a little better designed. How many possible cases are there when comparing two integers, x and y, for greater than, less than, or equality? Well, I kinda of just answered the question, didn't I? Three. Excellent! There's three scenarios there x is either less than or greater than or equal to. And I'm hard pressed to think of a fourth. So do I need this amount of specificity? What could I do to give myself a slight optimization, improve the code just a little bit just to save myself a little bit of time writing it and maybe even the computer a little time running it? Yeah. AUDIENCE You don't need the last condition. DAVID Yeah, I don't need the last condition because, if we all agree logically that either x is less than y or greater than y or maybe equal to y, well, if there's only a third and final case that can just be my socalled else. Just make that be the socalled default case. And in fact, even though this is what most people would call an over optimization, you are saving the computer some time. Because suppose that x does in fact equal y and they're both the value number 1. So is 1 less than 1 when this line of code is executed? Yes or no? No, obviously not. 1 is not less than 1. So this code does not execute. But the Boolean expression is evaluated, so to speak. The question is asked. Is 1 greater than 1? No, and so this code is not executed, but this Boolean expression is. So we just spent another step or second or however fast the computer is. Is 1 equal to 1? Yeah, it is. So this actually prints. But to your point, you don't need to ask that question. And in fact, you just increased by a factor of 50% how many questions you're asking. So you just wasted a little bit of time. Now as an aside, our Macs and PCs and phones these days, I mean, again, they're operating at like a gigahertz speed, one billion things per second. So in practice, who cares if you're asking that third question? And frankly, if it makes your code more readable or to your teaching fellow or to a colleague or friend who's working on the program for you, then that's great. If it's more clear from the code what's going on, leave it that way. But these are the kinds of design decisions that we'll now make. And arguably this version of the scratch program and this version of the C code is just a little better designed because why write more code than you need to express the exact same idea. So what about this? This was a loop in Scratch. This was an infinite loop because it was just forever saying hello world. Now in C, this gets a little less directly translated. It turns out c uses the key word while. So there is no forever keyword in C, but there is the word while. And of course, I'm going to use my curly braces curly braces, curly brackets to encompass the following lines of code. The line of code I want in there is just another printf. So that's the exact same as before, but it's not sufficient to just say while. It turns out that while wants you to ask it a question every time the loop executes. And it's going to check that question. And if the answer is yes, it's going to run the loop. But if the answer being asked in C is ever no or false, it's going to not execute the code and it's just going to move on to any further lines of code lower down in the file. So in C, you actually need a pair parentheses after the keyword while. And then you need to ask a question. You need to ask a question like, is x less than y or a question like is x greater than y or is x equal to y. But none of those scenarios apply because the whole purpose of this Scratch block is literally to do something forever. So what's a question we could ask to which the answer is surely true? Does 1 equal 1? We could contrive an arbitrary but very met mathematically correct scenario. We can just say just 1 equal equal 1. But it turns out you can be even more succinct because in C there's a couple of keywords, one of which is true, one of which is false. And the word true is by definition always true, and the word false is by definition always false. So you don't need to contrive some arbitrary but correct idea of does 1 equal equal 1 or does 50 equal equal 50. You don't need to just come up with some arbitrary solution. You can literally just say true because that key word true never changes value. So even though this is a little weird looking, it's how you induce something to happen forever. You asked the same question again and assume that the question always has the same answer of true. Any questions on that one? Yeah, in the back. AUDIENCE Do spaces matter? Can you take out the space between y and 0? DAVID Good question. Do spaces matter? Short answer, no, not in this case. You can in fact delete all of the space here except for the one in the English phrase, and it would still be functionally correct. You can even add spaces anywhere you want. You can make this taller by hitting Enter a bunch of times, tabs, spaces around the word true. All of the examples I"ll show here today and you'll see in the coming weeks are the better way to do things because they're more readable. But again, as you get more comfortable with code or if you're coming in with some prior experience, you might already have your own opinions. And frankly, this is just a religious debate among programmers, which is the right way to write your code. And that's fine. Once you get comfy, so long as you're consistent is the most important thing. You don't need to adhere to one person's or the other. So how does this code work logically? Well, the first thing the computer, your Mac or PC or your phone or whatever is going to do, it's going to ask the question. Well, true. Well, true is always true. So it's going to proceed to execute the line of code. But after it does, because that's the entirety of the code that's in between the curly braces, we could have more lines. These are just short programs. The computer is going to check, OK, is true still true. Yes. So it's going to execute it again. Then it's going to ask the question again. Is true still true? Yes, so it's going to execute the code again, and this is going to repeat literally forever. But what if you don't want to repeat something forever? What if you only want to repeat it 50 times? Scratch doesn't make you think very hard about this. People just figure out how to keep track of 1, 2, 3, 4, 5, and all the way up to 50 and then stop. That's nice. It makes it easy to use the block. C and a lot of languages aren't quite that user friendly. You will see later in the semester that newer languages are a little closer to what Scratch offers. But in C, we need to be more explicit, but this is a chance to use some of these more primitive building blocks. In C, the equivalent of repeat is going to be the proposition for just because, for now. And then, just as before, if we want to do something again and again within this loop, we're going to use the curly braces, similar to the little orange block there. And then what am I going to do? I'm going to do this every time, 50 times hopefully, print out hello world. So now I just need to figure out and see how to express the number of times specifically 50. So it turns out in C use parentheses again this is going to be a pretty common characteristic of a lot of the code we write. And then you need to do three things. The burden is now going to be on us the programmer to keep track of how many times we want to execute this code to how many times we've already executed this code and then constantly make sure that one does not exceed the other. So we stop once we hit 50. So what's the fundamental construct that we use to keep track of anything in a program? A counter, which was an example of a variable. So we just need to use a variable. Now it's actually going to be inside of the parentheses this time. So it's not on its own as it was just a bit ago, but the syntax is the same. I could call it counter, but the reality is that the convention in programming is just to use shorter variables when you're just doing something mundane. And if all you're doing is looping i stands for integer, is sort of many programmers' goto variable name rather than the more verbose but correct counter or whatever. So this says, hey, computer, give me a variable called i. Let me store integers or ints in it and set the initial value to 0. Why? Well, almost everyone in this room probably starts counting from 1. Computers just tend to start counting from 0. But why? What's the rationale for starting to count from 0 perhaps based on last week? Why does that kind of makes sense? Yeah, what do you think? AUDIENCE Well, because it's ones and zeros, and it's binary. DAVID Yeah, it's just ones and zeros, and what's the smallest number, negative values aside, that you can represent in binary? Well, it's just 0, 0, 0, a bunch of zeros. So why would you waste that representation, that permutation of bits? Let's just start counting at 0 and then add to that. So you can start counting from 1 in C, but the convention in most languages is count from 0. So we'll get off on that foot as well. And you might recall even that in our PBJ, for the peanut butter and jelly not for the PDJ code for the phone pseudo code, I actually deliberately started numbering the lines from 0 to 1 to 2 for that same intuition. So here's how you then say to the computer check, if you would, whether i is less than 50. Now, initially it's obviously going to be less than 50 because zero is less than 50 but that same condition is going to be checked again and again and again as this loop executes. And then recall from before, we can just plus plus a variable to add 1 to it. We can do this more verbosely. We could say i equals i plus 1, but it's just more conventional to write i plus plus just to say the same thing more tersely. So what happens next logically? That's the code I've written. What does the computer do with it? Well, it initialises i to 0 and prepare to store integers in it. It checks the condition just in case you initialized it too big of a value. You might not want the loop to execute at all. But obviously 0 is less than 50. So this line of code executes. Take a guess as to what happens next. Yeah, you probably want to do i plus plus because you're done executing all the lines of code in between the curly braces, even though there's just one. So let's go ahead and increment i. So i is now 1. Let's now make sure is 1 less than 50? Obviously. Execute the code. I plus plus is 2 less than 50. Obviously execute the code. i plus plus is 3 less than 50, obviously. Now go ahead and execute the code, and again and again and again. And at some point, we're going to get up to i equals 49, and is 49 less than 50? Obviously. So we print out hello world. And then i plus plus kicks in, and then it's, is 50 less than 50. No. So wait that feels like a logical error, no? Should I be checking if i is less than or equal to 50? Yeah, because if I started from 0, I already spent that one additional cycle. So I can count from 0 through 49 which seems to work or from 1 through 50, but the convention in programming honestly is typically to start counting at some value and then count up to but not through some value just because. But logically, you can implement this in half a dozen different ways most likely. Let's look at one final example that allowed us to actually get user input in Scratch. Recall that we used this block to actually get the name of someone in lecture, and we also in the animation with the gingerbread house used it to get yes or no do you want the cupcake or the apple or the like. So this is an example of a function in Scratch that actually takes input like the sentence what's your name, but it also returns a value, which in this case was just hard coded in Scratch by MIT to be called answer. So it's like a special variable called answer, but effectively it's being handed back to the user. So how might we think about this? In C it turns out that you can express this line of code a little more verbosely than before but using a new function called get string so get underscore string is the name of the function. The underscore is convention in C. If you ever want to have a space, you can't have spaces in the names of functions. So people just started using underscores like you might in your own social media user names and the like is a convention there as well. Here's the sentence I want to display, and I'm going to start calling this more formally a string. A string in a programming language is just a sequence of characters. It's a word, it's a phrase, it's a character, it's a paragraph. This is a string. Anything between double quotes is a string in C, and the backslash n it's just end of line as before. We still already have the semicolon, but this isn't quite a literal translation of what's going on just yet because I also now need to do something with the answer. So if get string is a function that actually gets input from the user, as via his or her keyboard, just like the blue block in Scratch, in C we need to be a little more explicit as to where we're putting the return value from that function, what it is it's handing back. And so I can store in a variable called answer. I could call it anything I want. But for consistency with Scratch, let's call it answer. But recall what we have to do in C anytime we create a variable. We have to be more precise. Yeah. AUDIENCE Define its class as a string. DAVID We have to define its let me call it a type or class, if you've taken a previous class. It's type and it's not going to be an int because probably the words being typed in are not numbers. It's going to be this time what I just called it a string. And so, indeed, we would declare the variable on the left by saying give me a string, call it answer, and assign to it whatever's on the right. Well, what's on the right? What is on the right is whatever this function get string comes back with and gets stored from right to left. So how do I now say this person's name? Well, in Scratch I just say and then I drag and drop the answer variable, and it's done. What's the function in C with which we can say something, though, on the screen? So printf, print a formatted string, even though we haven't really seen any formatting yet until now. It turns out in C, You have to actually tell d if you're not passing in a hard coded string or sentence, you have to pass to printf what's called a format code or a format string this first input to printf. Now printf apparently seems to take two things. The first is this one before the comma. The second is the thing after the comma. And we've not seen this before yet in C. So printf is being told, go ahead and print out a string that looks like this. Percent S is a placeholder, and S stands for string. And that literally is a placeholder saying, printf, I'm going to give you a string to plug in to this first input. What is that string? Literally, the answer variable. Now it feels like we're jumping through hoops here. It would have been nice to just say printf, open parenthesis, answer, close parenthesis, semicolon, and be done with it. That's just not the way printf works. In older versions, you could maybe do something a little more simple like that. But honestly, we're not typically going to be printing out just what the human typed in. After all, this is kind of a stupid example at the moment. I'm typing in a word. You're just saying it on the screen. We already decided in Scratch that's kind of lame. It'd would be nice to at least have the program, not just say David or whatever the name is but what did we do last time? Like hello comma David. But this would seem to give us that capability. Right now I'm literally just printing out the human's name in C, but let me change this ever so slightly just as we did in Scratch. Recall that in C we did this green block of join where I literally get past join two arguments. The first one was hello comma space. The second one was answer, and this concatenated. This combined back to back those two strings. Well, in C, thanks to printf, we can do that same thing. It's just a different syntax. Printf still gets one argument first, that is, the string you want to format, ergo the F in printf. But this time I'm going to literally say HELLO comma space percent S for string and then give printf a second argument, which is its instruction to go ahead and plug in whatever this variable is to whatever this placeholder is. And so here we've now joined the two strings effectively and thus was born our first formatted string. Well, any questions then on that? Yeah. AUDIENCE What if you wanted to say something extra after it? DAVID What if you want to say something extra after? You could certainly continue the logic. You don't have to end this quoted expression with percent S. You could say, hello, comma percent S comma, nice to meet you. And then what printf will do is it's only going to substitute that variable called answer where the percent S is. And if you want to give 2% S's, you could just add another comma here and pass in another variable and a third variable and even more, thus formatting the string even more detailed. Question over here. Yeah. Other questions? Yeah, in the back. AUDIENCE How do you make a distinction between the placeholders if you have different variables? DAVID How do you make a distinction between the placeholders if you have different variables? It's the ordering from left to right. So in this case, it's a trivial example because there's only one variable and one placeholder. But if as you were hinting, I had multiple percent S something something something, percent S something something something, I would just make sure that I pass printf the first variable comma the second variable comma the third variable and so forth left to right. Other questions? Yeah. AUDIENCE Why is there no backslash n? DAVID Oh, damn it. Because I screwed up and didn't include that and I was going to fix it after class quickly. Bug, it's a bug. Yeah. AUDIENCE What if you wanted to use the int twice in the string? So you wanted to say, hello, David, hi, David. DAVID Sure, same exact thing comma answer, comma answer with 2% S. If you want to say the same variable twice in two places for whatever reason, two placeholders and then answer comma answer to plug that in twice. Other que yeah. AUDIENCE Is percent a universal placeholder in terms of integers? DAVID No, and we're going to see some others in just a bit. It turns out there's others. It's percent i integer, and there's going to be even more than that percent c for a single character and more. Other questions? Yeah. AUDIENCE Since the backslash n is a variable, would you put it after n? So will you put it in the quotation? DAVID Good question. If I did have correctly and if this weren't a PDF, I would just edit it on the fly if I had the percent n, it always has to go in the formatted string, in the first argument. So the only thing that comes after printf's first argument is optionally variable comma variable comma variable comma variable. Other questions? so Let's go ahead and actually do something with code. I'm going to go ahead and open up another window, and this is a tool called with CS50 Sandbox, and this is a tool via the web by a which you can actually play with code. And I'll show in just a moment how I get to this particular location, but let me first explain the user interface much like we started off our conversation with Scratch. So I need a place to write code. The reality is I could just use my own Mac. I could just use my own PC. Frankly, I could even use certain mobile devices these days. But then we would have hundreds of other people in the class all with slightly different configurations on their Max and their PCs and their phones and the like. And so everyone would have different software and different settings, and they just never works very well. So at the beginning of the course, we just standardize everything by actually using a web based environment just like Scratch is, whereby we'll all have access to the exact same computer but virtualized in the socalled cloud. If you've ever wondered what the cloud is, it just means other people's server somewhere on the internet that people can use for free or to rent and not have to host those physical servers themselves. So CS50 Sandbox, just like Scratch, is a cloud based application that someone else wrote that's hosted on the internet, and the user interface, at first glance, looks just like this. There are only two components to it. At the top of the user interface of CS50 Sandbox is just a code editor, a very simple text editor similar in spirit to Google Docs and Microsoft Word and so forth but much simpler. There's no formatting. There's no bold facing and centering. You can just type words of text. Down here is the socalled terminal window, but we'll come back to that in just a moment. Let me go ahead and write my first program. Let me go ahead and write include standard IO dot age int main void open curly brace printf hello world backslash and semicolon, done. Now few people in this room could probably whip up a apparent program that quickly unless you do have prior background. And if you did take APCS or something else, it looks kind of like Java but not quite the same. But this is my first program. Now recall from earlier this was the black and white program we saw on the slide just a little bit ago. And even if you didn't quite appreciate what all the funky syntax is doing, all of us probably had the intuition of what this program does, which is just to print out the words at the end of the day hello world. And we'll tease apart in just a bit what all these various lines are doing. But the interesting part is what's highlighted in green here, and this is just one of the features of CS50 Sandbox. It will color code different concepts within your code so that they just jump out at you. The colors aren't actually there. You don't have to color code things yourself. It just does it automatically so you can see the different components just like MIT colorizes is the various Scratch puzzle pieces the same. So this is a program that I want to call hello. It's in a file. This is just a tab up top called hello dot C because it turns out, when you write a program in C, you save it in files by human convention whatever dot C as the file extension, so to speak. How do I run this program? There's no green flag to click, which Scratch gave us. So how do I actually run the program. And frankly, moreover, the green flag seems to be the least of my concerns. What is the language that any computer understands whether it's my Mac here or the cloud server where this thing is? Zeros and ones, right? And we started with that overwhelming slide of a lots of 0's and 1's, and that is the point we need to get to. But hopefully, we ourselves don't have to write at that level of tedium. So we need some way of converting this code from C, which we'll start calling source code, which is the English like code we see on the screen that's mildly pleasurable to write as opposed to just zeros and ones. But we nonetheless need to convert it somehow to zeros and ones. And so the way we can do this is essentially as follows. If we have what we'll start calling our source code, which can be written, in our case, in C, but you can write source code in Java, in C++, in Python, in dozens of other language. Source code's a generic term. That just means the code that we humans have written. We need some way of converting it into zeros and ones, which henceforth we're just going to call machine code, which feels like a reasonable name. It's the zeros and ones that a machine understands. How does a machine know what zeros and ones to understand? Well, that's the whole reasoning behind having CPU, Central Processing Unit, the brains of a computer. They are just hardwired at the factory, so to speak, at Intel's factory to understand certain patterns of zeros and ones. But the point for us now is we need to take a source code, like the C program I wrote a moment ago that's supposed to print hello world, and somehow convert it to machine code. So it turns out this is the step that humans who've come before us have solved for us. Other humans have already written programs that we're going to start calling a compiler that allows us to convert source code to machine code. It's just one additional step. This step did not exist in Scratch, but we're going to run a program that's generally called a compiler that we pass our program to as input, and we get as output machine code, thereby perfectly bringing us full circle to what computer science is is in now the context of programming input source code, outputs machine code. The algorithm or the special software we're going to use in just a moment is called a compiler that just converts one to the other so that none of us have to ever think about or write in 0's and 1's. So it's a little old school how you do this. In Scratch, you obviously just hit the green flag and MIT and all those folks took care of it for you. We have to be a little more manual about this, and that's where the second piece of CS50 Sandbox user interface comes into play. Notice I have a blinking prompt here. There's dollar sign at left, which is just a common convention. A dollar sign tends to in these types of computers represent a prompt. It's waiting for me to type something, and indeed it's literally blinking, waiting for me to type something. This is an example of a terminal window, and your own iMac and your own PC actually has or can't have this exact same feature. It's just all of us operate with graphical user interfaces these days. So we've got buttons and menus and things to drag and click, but back in the day and typically in programming you don't bother with these aesthetics. You actually get your hands dirtier with just the keyboard alone typing anything you want to do. And at first, it might feel like a regression. Like, why are we giving up all these beautiful amenities of modern computers? But it's more powerful, and it's more explicit. It lets you do exactly what you want to do by sending commands to the computer. So this is my terminal 1. I can create others just to have multiple windows, but this is giving me access to the underlying server that I now have access to. So if any of you, when it comes time to the first problem set, log into the same tool, you don't all have the same environment. You all have your own isolated copies of the same software but your own storage space, so to speak. So I need to somehow convert hello dot C to zeros and ones. And the way I'm going to do this is like this clang, which stands for C language, hello dot C enter. And the fact that I see nothing happening is actually an amazing thing because there's an infinite number of things, frankly, that can go wrong, and the computer will happily yell at you with cryptic looking error messages if any of those things do go wrong. So seeing nothing but another blinking prompt with the dollar sign is actually a good thing. My code has somehow been converted to zeros and ones. Where are those zeros and ones? Well, by convention, they are stored in a file that's weirdly and historically just called a dot out, and we can see that. If I click this folder icon up here, you'll actually see my file hello dot C and another file now called a dot out. It stands for assembly output, but for historical reasons. Now let me close the folder icon because we're generally not going to use the graphical user interface. How do I run that program? I couldn't just double click on the icon. This isn't a Mac. This isn't a PC. This is a cloud based Linux environment. Linux is a super popular operating system. It happens to be used by lots of computer scientists, lots of websites, lots of servers. In fact, almost every website you visit these days is powered, if not by Windows by Linux, and variations thereof called Unix and other flavors still. It's just a very popular and often free operating system that CS50 Sandbox itself uses. To run a file called a dot out that's in this folder, so to speak, even though you don't see a graphical version of it. You literally just type dot slash a dot out. Completely nonobvious and kind of a stupid name for the program, but this is the equivalent in your Mac or PC of double clicking on an icon. Let me go ahead and hit enter. And when I do, I should hopefully see what? Hello world. And here we go. Wow, that's our first program. It's not doing all that much, but it's at least doing what we promised it would do. And this is the equivalent in Scratch of just saying on the screen hello world. Now to be fair, there were more steps involved, and God knows there was more cryptic looking code to write. But at the end of the day all we've done now is reimplement last week's logic in this new language, but we're now going to very quickly introduce new puzzle pieces but in C. But first let's solve this minor headache. I don't really want to tell friends like, hey, everyone, come run my a dot out program. Let's give it a real name. Suppose I just want to call my program hello like you might download from the App Store or Google Play Store. Programs have names. So how do I do that? Well, it turns out in a terminal window, the socalled command line environment, which is just a fancy way of saying you write lines of commands with your keyboard, you can actually pass in what are called command line arguments, additional inputs to programs that are just words that you type at your keyboard that tell it how to behave. So instead of just running clang on hello dot C, I'm actually going to be more explicit and I'm going to tell clang please output as is implied by literally typing dash 0 for output a file called hello instead. So it's a little more verbose hello dash O hello or, sorry clang dash O hello hello dot C. But what this is going to do now is still convert source code to machine code, but it's going to save it in a file called hello. And indeed now I have hello dot C a dot out and hello as pictured in the little graphical folder there. So now I can instead run dot slash hello. What should it say? Hopefully the same, enter. So that's it. Those are called command line arguments, and it's just the old school way of telling a text based command how to behave a little bit differently from its defaults. But frankly, this is going to get tedious quickly. We aren't going to want to write our code and then every darn time we want to convert it to zeros and ones to run it actually remember these magical incantations of commands. And so humans have abstracted these away too. It turns out that, if you want to make a program from source code into machine code, there's another command you can use. And you can literally type make hello, where hello is the name of the program you want to make, this program, whose name is make, will look for a file by default called hello dot C, therefore saving you the time of specifying it. Hit Enter now, and, oh my god, look what it just did. It has even more configuration options that are baked into it, and we as CS50 staff, configured CS50 sandbox to have these various features. And even though we're not going to go into detail on them now, I'm going to wave my hand at what they actually do. They just make additional features possible that we'll eventually get to. But this would be otherwise the command that you all do have to type in just two or three or four weeks time, and no one can ever remember that. I certainly couldn't. So Make just automates that for you. But when you run Make, Make is not a compiler. Make is not the thing in the middle here converting source code to machine code. It's just a second program that some humans wrote years ago that use clang in an automated way to achieve the same output. Because people got tired of typing stuff like this. So someone made a program called Make that does it for us. Any questions? Let's add a little bit then to this program. Instead of this version of hello, let me get some user input and actually do something with it. Suppose I actually want to get the user's name and then print that out. Well, we saw the spoiler for that just a moment ago, but let me go ahead and add to this program here. Now I have a second line of code, and I want to get a string from a user. And with what function do I get a string from the user? Get string was the one, and recall I can do get underscore string open parenthesis. And then I have to pass in an argument, so to speak, like give me your name or actually, what did we say before? What is your name, I think was the prompt backslash n semicolon. Now it's not enough to just get the string. What do I want to do with it? Yes, store in a variable. What type of variable? A string. So I just need to go on the left hand side of this line of code and say, OK, well, give me a string. I'll call it name, but I could call it x or y or anything. But name feels like a good descriptor for it, using a single equal sign to copy from right to left. And now I've got that. Now it's not sufficient to just store the value in the variable. I need to print it out. So let me start with this. It autosaves, the Sandbox. So I don't even have to go up to File, Save or anything. Let me go ahead and do make hello now oh uh, oh my god, look at all these errors already. So clearly something is wrong, as the computer is fond of telling me in red. And frankly, this is where you very quickly get derailed or kind of freaked out because, oh my god, I only wrote two lines of code. How do I have 20 lines of errors somehow? So the computer is kind of as confused as you. And the most important thing, when you face this kind of situation where it's just cryptic, erroneous output, start at the top. Even if your window's kind of small and therefore a whole bunch of stuff scrolls on the screen quickly, scroll up to the top because odds are there's one mistake up at the very top and that one mistake just had a cascading effect on the compiler. Then it just got really confused, and it just kept spitting out messages because it got tripped up early. So let's scroll back up to the top here. And here is the very long command that I said make automates for you. So that's not erroneous. Here seems to be the first error, and it's a little cryptic still. But let's glean some information. Here's a familiar phrase hello dot C. Let me go ahead and zoom in on the bottom here. So hello dot C recalls the name of my file. Albeit not obviously, clang is telling me look at line 5 and then your fifth character. So this something colon something means line number character or column number if you're looking from left to right. Error means error. And then this is where things get a little sophisticated. Use of undeclared identifier string did you mean standard n? No I didn't, but I do recognize standard n, or rather it seems similar to standard I/O. But no, I didn't mean that. I'm pretty sure this code is right. Well, why am I getting this error? It sounds like string, on line five, fifth character, right there, that is wrong. Well, it turns out, there is no such thing as a string. C, the language, has integers, and it has Booleans, it turns out. And it has characters and a few other things. It actually doesn't have strings. Strings is a word that's useful to describe sequences of characters, paragraphs, words. But string is not a type. It's not a type of variable unless you make it so. And in fact, this is one of the simplifications we do. In just the first couple of weeks of the course to get us off the ground, it turns out that we need to add one line of code here. We need to do, not only include standard I/O which we'll explain in a moment but also CS50 socalled library. So CS50 has a lot of humans involved with it, and over time we've decided, you know what, we could make the first hour of CS50 a little easier and the on ramp a little cleaner for folks with no background by just inventing a few features ourselves such as the ability to get strings from the user. So it turns out get string is also not a function that comes with C. That is a custom puzzle piece, so to speak, that CS50 made. And where we created that function is essentially in a file called CS50 dot age. And so by including dot age, you now get access to more puzzle pieces, if you will, that we have created for you. And it turns out this line of code that has been here before is also giving you features, too. We're just doing what everyone does in programming, which is solve a problem once and then let other people use that solution. Take a guess. What functionality is actually implemented in a file called standard I/O input output dot h? This is just a file somewhere on the server that actually does come with C, and it provides you with handy features like what? Say again. Once more. Printf. It turns out that the means by which you are allowed to use a function called printf here is you have to include the file in which it is declared. So some humans, years ago, literally wrote a function, a puzzle piece, called printf, and they figured out how to actually draw characters on the screen. They then stored information about that function in a file called standard IO dot age. If I had not included that seemingly cryptic line of code at the very top of my previous program, even that hello world program would not have worked because clang, the compiler, wouldn't have known what I'm talking about. What is printf? I don't know what that is unless you tell it to also include this file that humans wrote years ago in which printf has been created. And now if I want to use get string, as well as the new keyword string, I need to tell clang the compiler, also go ahead and look in CS50.h for more functionality, such as string and get string. So let me go ahead now and try this again. I'm going to clear my terminal here and just try that same command again make hello, enter, dammit. Now I've got another error. But, but, but, progress. Well, no, just as many errors as before somehow, but different ones. Notice now wait, that was before. Oh, no, I'm sorry. It has fewer errors. Here's where I ran the command a moment ago, and now I'm getting this error instead. So progress. Now my error is not on line 5. It's on line 6, though fun fact, line 6 used to be line 5. So it's apparently still involved in the problem. So let's read the error message. The problem is on line 6, which is no surprising is that one there. But this time it's different error, unused variable name. That one I kind of understand even without being a programmer. What does that mean? Yeah. Maybe declare prior to using, but it turns out this is how you declare it. But I'm actually yeah. AUDIENCE You're not actually using the variable you declared. DAVID Yeah, I'm just kind of wasting the computer's time. I'm creating it. So line 6 on the left is correct. Hey, computer, give me a string variable, and call it name and put a value in it. But what's the point of that exercise if you're never, as you say, doing anything with it. And in fact, recall from the slide a moment ago, how do I do something with it? Well, this is not how you do something with it. If I go ahead and run this program now successfully, what would I actually see on the screen? Literally hello name, HELLO comma space NAME, obviously not correct. So how do I plug in the variable? What was the trick? Yeah, percent S for string, a format code, so to speak hence the name printf. And then I need to pass a second argument to printf, and I do that with a comma and then the name of the variable I want to plug in. Now notice there are two commas in this line here. If I zoom in, notice there's two commas, but there's only two arguments or inputs to printf. The input to a function is just typically called an argument or also called a parameter. So there are two commas, but this one is an English comma just separating hello from the person's name. This white comma here, color coded because the Sandbox is doing the for me is actually separating excuse me the first argument from the second argument. So now, for a third time, make hello enter. Oh my god, thank you. Now it worked. It still spit out this pretty long, cryptic command in white, but that's OK. That is, again, the automated command that Make is making possible for us. But the fact that I see no red, no errors, just another blinking prompt means that my program has been made. So let me go ahead and do how do I run a program if it's called hello? Yeah, dot slash hello, and we'll see why you have the stupid dot at the beginning. It essentially means run the program called hello that's right here in your current folder on the server dot slash hello. What is your name? Very nice. David, enter. Hello, David. Interesting. Let's make one tweak, because I did this by accident earlier as you noted. What if I left off for instance one of these backslash n's that's literally now not telling the computer to move the cursor to another line? So let me go ahead and rerun the program. Wait a minute. That looks the same. I just changed the code, but it's still behaving exactly the same. Where's my confusion? I didn't recompile it. Unlike Scratch, which is amazing because you just hit the green flag and it runs the code again, we have a second intermediate step. I have to rerun the code. Now how do you get out of a program? I could just hit Enter. You can also hit Control C for cancel, and that will just get you out of whatever confusion you're in. Let me go ahead and rerun, make hello seems to be OK dot slash hello, enter. OK, this is why I've had all those backslash n's. Let me zoom in on what's happening. I mean, it doesn't look horrible, but frankly it kind of rubs me the wrong way if this is what my program looks like when I'm typing in user input. I mean, this just looks stupid. Minimally, I should add a space. Maybe I can put a backslash n to move the character. This is user interface now. This isn't really logic. It's just aesthetics, but I think this looks stupid. So that's why I've had the backslash n's there all the time, but that's why they need to be there to tell the computer to actually put things where you want them. Alternatively, you know what, OK, I don't like that. ControlC for cancel. Let me put this one back. What happens if I get rid of this one? And let me go ahead and recompile the code first as you note dot slash hello enter. OK, I've cleaned up that aesthetic headache, enter. I mean, it's not quite the same problem, but this looks stupid too because the dollar sign just represents my prompt where I'm supposed to type commands and yet hello comma David prompt. And that's just messy. So this is why we've had all of these new lines. Now you asked earlier, what if you put the new line elsewhere in the string. Well, suppose I do that. Suppose I put a couple of them. Let me do this and no spaces whatsoever. Now this is looking a little weird, but the computer is just going to interpret this literally print HELLO comma new line substitute in the string for percent S then another new line. So how many lines of output is this going to display? I heard four. Other values? Let's see. Let's go ahead and make hello and then run dot slash hello, what is your name as before enter hello comma new line David so four total lines certainly or just two lines from the computer itself. So just to recap then, with code like this how many functions have I used in this particular program? How many functions? So it's two printf, which we've been using and get string, which is the new one. Where is string declared? CS50 dot h, printf meanwhile is declared in standard IO.h standard input output. Meanwhile, string, this data type also comes from CS50 itself, and then we've used the format codes, and we've use variables to achieve the same result. And let's just hammer this home. Brian and Karim, do you mind popping up for just a second? Or who's there? Erin, come on up. So just to make this clear because there is now some terminology that we want to use. Let's see. Do you want to be you'll be get string. So we have some name tags here like you get at events. So Erin shall be get underscore string. If you want go ahead and put this on. And Brian, you want to be printf. So we won't act out all of our actual programs because this will quickly become obvious. So Brian is printf. So this point though, remains in that this is nice that I have some colleagues with whom I work here because I don't really want to do all of the hard work of making things happen. And so if I'm instead the programmer or the orchestrator of a whole bunch of things happening, I can actually implement this code now more physically. And let's focus, though, for just a moment on what the key takeaways are. One, functions can take input. Those inputs are called arguments or parameters, and functions can return things. They can have return values. Printf, for instance, does it take input? What's the input to printf, for instance? Yeah, like hello world. Whatever it is you want to print is by definition the input to printf. Does print return a value thus far? It does do something on the screen certainly. It prints stuff on the screen, but we haven't seen it return something because we haven't seen it with equal sign to the left. Now it turns out printf does return things. It's just not often that useful to use, but we've only seen printf for the moment as taking inputs more on that another time. Get string, meanwhile does get string take inputs? How many inputs? Just one, the prompt that you want the human to see. The first prompt I used was what is your name. I could make the prompt anything, but that's the question that get string is asking. Does get string return a value? It does. That's of course in Scratch called answer, hard coded as answer. We can store in any variable we want. So let me just go ahead and implement this program. Erin, go get me a string and ask the person, what is their name. So ERIN What is your name? AUDIENCE Elizabeth. DAVID So she's writing down Elizabeth now. But Erin has taken input from me. Erin, go get someone's name and ask them, what is their name. And now you've produce output for me. Thank you. This is the return value, storing the value Elizabeth, and I'm going to go ahead and took it away in a variable called name like this piece of paper here. OK, Brian, could you go ahead and say hello Elizabeth. So what's going on here? I'm just doing less work. I am writing this program Erin, go get someone's name, Brian, could you print this out. That's what I've been doing, is programming, just delegating functionality to other functions or in this case other humans who know how to do that. And honestly, I don't have to know how Erin got that name. She just got it. I don't have to know how Brian wrote in that particular kind of style of English on the screen. I just know that he can do it, and now my program is complete. Thank you very much to both of these two here. We'll continue in just a moment as follows. So all this time, we've been taking for granted that we have an actual computer on which we can execute code, and I keep saying Intel inside that's the silly slogan that you see inside of most Macs and PCs with the hardware they have. But the CPU is just the brains of the computer. And at the end of the day, recall that the goal is to actually have the computer turn something like this source code into actual machine code, zeros and ones. And that's all Clang was actually doing for us. Of course, we've only just scratched the surface now of what we can do. It turns out there's going to be, not just these commands that we can run, but other features of C and in particular the CS50 library. We've only seen thus far how to get a string, but you can get integers and characters and funky things like floats and doubles, which actually open a can of worms as to problems that can happen in a computer. And it turns out you can store different types of variables, not just integers and strings, but bool for Boolean and chars for characters. And you can format those things in printf. We've only seen percent S. I alluded to percent i earlier, but there's a few other still. But we've got a lot of possibilities here. But let's go ahead and take, say, a five minute break to give everyone bit of a respite, turn on some music, and come back in five and dive in deeper to more sophisticated programs in C. So recall we began by comparing some Scratch blocks against the corresponding C code, but we didn't actually use most of those blocks in C just yet. So let's try out a number of examples, some of which I'll write on the fly in typing code out on my own keyboard, some of which we already have in the course's web sites. So we can just open them to save some time. But let me just draw your attention to what CS50 Sandbox is because this was the step that I skipped over earlier. CS50 Sandbox can be used to program in bunches of languages. We'll initially in the semester use it for C. But if you've written Java before or Python or any number of languages, when you go to Sandbox.CS50.io, you can simply choose the language you want to write in. And then at the bottom, you'll see you can specify the name of the file you want to precreate. So for instance, what I did earlier was I selected C at top, and then at the bottom I typed in Hello dot C because that was the name of the file I wanted. And then I clicked start. And what that led me to was precisely the interface in which we wrote hello dot C just a moment ago, where my code editor appears on the top here, my terminal window appears at the bottom, and then I'm allowed to just start writing code. So that's how we got to where we were. And if you want to follow along now with some of these examples, note that on the course's website we have all of them premade. And you can actually click the links on the course's web site and open up your own copy of a sandbox with that code. So if the WiFi cooperates, you're welcome to tinker and play and run the same commands. But everything is also on the course's website after. So you needn't type everything out. So let's go ahead and do just a quick example. I'm going to call this int dot C just so that we can reinforce some of what we did just a moment ago. Rather than get a string like we did with our hello example, let me go ahead and just get, say, an integer, and then print it out just as we did print a name. So I'm going to have to go ahead and, just through muscle memory, I remember that I need standard IO dot h of the top and then int main void and then curly braces. And then I can do the act of actually getting the input. So there was a function before called get string. It turns out there's another function called get int if you want to get an integer. So I can actually call get int, and I can say something like integer is the prompt. Like, hey, human, please give me an integer. I need a semicolon at the end of this line. And then how do I actually store the return value of get int in a variable? Just as Erin handed me a sheet of paper with a string, I'm handed a sheet of paper with a number, how do I store it somewhere? What's should I literally type line five here? Int space and then number or something. So I'm going to call it i just because it's an integer, but I could call it number or anything else. And then I'm going to go ahead and print this out. So printf let's say something like hello i backslash n semicolon. Not quite correct, right? This is going to literally print hello comma. How do I actually substitute something in? Well, we've only seen how to substitute in strings, but I think I spoiled earlier the answer. If you use percent i, that says, hey, computer, put an integer here. Then I need a second argument to printf just as we handed Brian an argument as well. And I said i. I want to say i here. But this program isn't quite correct yet. It's in a file called int dot C. I've included standard IO dot h. It's in main, and so what is main? Well, today were largely going to wave our hands at that. But int main void is perhaps the most cryptic way you can say the equivalent of when green flag clicked. That's all that does, and we'll come back in the weeks to come as to why it's int, why it's main, why it's void. But for now, humans years ago just decided that, when you're writing a program in C and you want to start the program off, you literally have to type int main void with those parentheses with those curly braces, and it's the equivalent to Scratch is when green flag clicked. But this program will not compile, and I don't even want to induce the stress of seeing those errors. How do I void it? Yeah, I need to teach the computer that get int exists, and I know how to do that from before by including the CS50 socalled library. Technically, CS50 dot h is a header file. Dot h means header, and it's just a file containing C code in which the functions are created. More on that another time, but that just gives us access to printf. So if I've made no typos, I should be able to compile this program by running what command? Make int. I could do Clang. I could do Clang dash O. But for now I'm going to do it simpler with just make int and let make automate the process of compiling this program. No error messages is good. Let me go ahead and zoom in dot slash int I think would run the program. Integer, how about 42? Hello 42. And notice, I can save time now. And if I want to run it again, I don't have to do slash int all the time. It turns out that in this kind of Linux environment, this operating system called Linux, you can actually go up and down and see previous commands you've typed and some others that happen to be system specific. And if you just set up and enter, you can run it again, type in 50 this time, and see another output as well. So any questions then on just an example like that? No? Well, let me go ahead, and I'm going to save time in this environment. I can actually create files in here if I want by clicking the folder icon, clicking the plus. And then I can actually say give me a file called float dot C. So this is equivalent to going back to the main menu and typing in the name of the file. I'm just going to do it a little more quickly now in this graphical environment. And I want to call it float dot C. It's A bit of a weird name because at least growing up you probably learned maybe about integers. You probably learned about real numbers, numbers that can have decimal points and then things after the decimal point. In a computer, those things with decimal points are called floating point values, or floats. And you can think of it as the decimal point can kind of float to the left or the right, depending on how big or small the number is or how precise the numbers after the decimal point are. That's a float. So let me go ahead and implement a very similar program include CS50 dot h include, standard IO h int main void and this is after 20 years of doing this that you can do it so quickly. Now let me instead get a float from the user so a real number that may very well have a decimal point in it. I'm going to do that a little differently. I'll zoom in, and I'm going to say, hey, computer, give me a float, as is the data type called not int, not string but float. I'll call it f just because that sounds like float, and it's nice and succinct equals get float. And then I'm just going to say float. That's the prompt. I could make the prompt in green anything I want. And now I'm going to print it printf hello f, but I don't want f. I want to actually print out a placeholder and you can probably guess by now what the pattern is percent f for a float new line comma f semicolon. So this is like the same program three times now with a string, with an int, and a float. But again, it's just for some muscle memory and going through the pattern, but let's see what happens differently here. Let me go ahead and type make float enter. OK, good, no errors. Let me zoom in and run this now as dot slash float. And let me go ahead and type in a number. I'm going to just say 42. But the computer now has the capability of storing more precision. Before it was just an integer by definition of int. Now it's a float. So even though it's pretty precise, this 42.0000, that's indeed a real number now, storing some amount of precision there. So it turns out though that we can do more interesting math. Let me go ahead and just open this example in advance. This one is going to be called int dot C. So then I don't have to type everything out. And in ints dot C, we're going to see some math written in code that I precreated just to reinforce that you can actually do some basic arithmetic in a program. I can make see more of the code here by just scrolling down, and let me scroll this up so we can focus on main. And let me zoom in on the first few lines. On this first line, I'm just getting an int, and I'm calling it x. We've not used a variable called x recently. But now we are. It's no different logically than before. Here get me another variable. So we can see now that you can get multiple variables from the user just like in Scratch. And now in these lines, in green are just some format strings just what do I want printf to display? I literally, in this highlighted line here, want printf to display x plus y equals something. What is that something? Well, notice what's cool about printf is that, before it is passed in input, you can perform simple arithmetic operations. So if you want to add x and y together, literally do x plus y. Then the sum of those numbers is what will get handed to printf as its input. Just like I handed Erin's piece of paper to Brian as input, I'm handing not x and y to Brian in this case, but x plus y or some value, the actual sum. Similarly, subtraction is the hyphen on your keyboard. For multiplication, it's not an x. That would be weird, xxy. It's instead star, or an asterisk on your keyboard. Division is the single slash, and then this one is a little funky, but we'll come up with some uses for this. You can actually do modular arithmetic or just more simply remainders. If you do x percent y, you'll get back the remainder of dividing x by y. And what's the remainder? So if x is 20 and y is 10, well, 20 divided by 10 goes in twice perfectly. So remainder is 0, for instance. But it's been a while. So notice, though, what's curious here. In this context, percent is not a placeholder. It's not percent S. It's not percent i. It's not percent Notice it's not inside of printf's format string. This is just literally math, a math operator as is implied by the different color blue there. So if I actually run this let's go ahead and run this program. I'm going to go ahead and do our make ints plural because that's the name of the file enter dot slash ints. And let me zoom in and clear the screen. Enter. Give me a number. 2 I heard. And another. 10 I heard. So FYI, 2 plus 10 is 12, 2 minus 10 is negative 8, 2 times 10 is 20, 2 divided by 10 is 2 mod y, or 2 and then take the remainder when dividing by y is what mod means is 2. So I get four out of five for correctness? What's a little funky here? Yeah, 2 divided by 10? Like, I'm pretty sure that's like 2/10 or maybe one fifth or 0.2. I mean, I'll take any number of answers but not 0. So what's going on? Well, this is a matter of representation. It turns out in a computer program, we decided in advance I'm going to store ints. An int is something that does not have a decimal point. And yet here I am rather presumptuously trying to do to 2, an integer, divided by 10, an integer, and expecting something other than an integer. No, I literally am doing integer arithmetic. So what's the computer apparently doing just intuitively? Why, when dividing x by y as I did in this line here or specifically in this example you proposed, 2 divide by 10 where is my 2/10 going? Yeah, it's technically what? Supposed to be 0.2, or 0.2. That's actually the solution because, if it's 0.2 but integers can't store decimal points or anything after them, what do you have left? Just the zero at the beginning. So integer arithmetic is fine if you're working with integers, but if you want floating point arithmetic, you're going to need to make some changes. And so I can fix this. In fact, let me go ahead and write a different program here. Let me go ahead and open up from the course's website floats dot C. That's going to give me this example, which is implemented using floating point values instead. So once this loads, I'm going to see a program I wrote in advance. It's a little shorter because now I only care about looking at one problem. And notice now x and y are now floats and not ints, another data type that exists. And I'm using get float, which also comes from CS50's library. And then this line is almost the same, but you know what? Let me let me tweak this. Let me just make it exactly the same. This line now that I've highlighted is exactly the same as before. So if I do type in the same number so let's go ahead and zoom in and do make floats plural and dot slash floats. I'll give it 2 and 10, and I should hopefully see what now? 0.2. That's pretty good, pretty precise. But you know what? I hate to tell you, but let's look a little farther. It turns out by default, when you percent f, you only see a few decimal places, like five or so it looks, by default. Let me see a few more so. This was one one, two, three, four, five, six points after the decimal point. So you know what? I'm going to say, hey, computer, give me decimal points. This looks completely cryptic and you just have to kind of remember this or look it up if you forget. If you put a dot and a number in between the percent and the f, that's the cryptic way of telling the computer show me a float but with this many decimal places, please. So that just gives me decimal places, weird as the expression looks. Now hopefully I'm just going to see some more zeros. So let me go ahead and make floats, and let me go ahead and zoom in and do dot slash floats 2 10 enter. OK, still correct. Let me get a little curious. Let's see a lot of zeros, like 50 of them. Let me go down here and do make floats, because I changed the code, dot slash floats 2 10. Ha, your grade school teachers lied to you. 2 divided by 10 is apparently not 0.2000000 infinitely. It's apparently 0.20000000298023223876953125 and then all of those zeros. What the hell is going on? Where's the bug? Where's my mistake? Where's my misunderstanding? What's the explanation for this? Well, what if I told you that inside of your computer is stuff like this? This is RAM or memory, and you've probably generally known this idea. They just store files. They store music and videos. You need memory, some kind of space. Hard disk space is permanent storage. RAM, or Random Access Memory, is temporary storage. So when your laptop is open and your desktop computers is on or your phone is powered, you're using RAM for all of the programs you're running at once. If you open a file, that file is stored in RAM, but it's permanently stored on your hard drive. So there's different types of memory. But notice, this is zoomed in. In reality, this is like couple of inches wide and maybe an inch tall. So it's pretty small, but it doesn't really matter how big it is. It just matters that it's finite in size. You have physical hardware on your laps or in your pockets or at home that only are so big and therefore only have so many parts and therefore only have so many transistors and other pieces of hardware that's actually doing the work of storing information. And so if you only have a finite amount of memory, how in the world are we going to represent an infinite number of numbers? Because I do recall from grade school I was taught there is an infinite number of numbers, certainly real numbers, where the decimal point can go on forever. That is a problem if you want to represent all possible numbers in the universe, which is infinitely many, with a finite amount of hardware. So at some point, the computer's gotta start cutting some corners. And so what you're really seeing here is as close as the computer can get to storing that fraction for you precisely, and I got a little greedy. I looked a little too far to the right. And granted, these are infinitesimally small values. It's not hugely, hugely off, but it is off because they can't expect the computer to represent an infinite number of values using a finite amount of memory. It's got to round off here or there and be imprecise, so to speak. So is this a problem? I mean, we would never have known this if I hadn't gotten greedy and looked at 50 decimal places instead of 7, which was already pretty precise. Is this a problem? Yeah, like why? Why? AUDIENCE If you use the equal function, [INAUDIBLE].. DAVID Yeah, that's a good one. Logically, if I start using equals equals to compare things for equality, it's going to be really hard for me to ever compare something for 2/10 as it's value because I'm going to literally have to remember or write down or figure out this value and compare against that and not just compare more loosely against 0.2. And that's true, you should actually never compare floating point values in code for equality. I could probably get away with less than or greater than, but even then it's going to be a little off from what I expect. Why else might this imprecision be worrisome? When might you not want your computer being imprecise? What domains? What worlds outside of a classroom? Yeah? What's that? AUDIENCE Rocket. DAVID Yeah, so rockets, or anything involving math and physics and danger. You don't want numbers to be ever so slightly off. And if you think about it, rockets is a good example because I don't know much about rockets, but I know they go pretty fast and there's probably angles involved because you're trying to keep them on a trajectory. And that's fine. But if your trajectory is ever so slightly off and something's going really fast and really far, I'm pretty sure that eventually those small imprecisions start to add up. And indeed, there's been historical incidents where that kind of imprecision does, in fact, add up in the realm of militaristic operations or in financial operations. In fact, if you've ever seen Office Space or way back when Superman 3, this is how some people made some money because they just kept all of the fractions of pennies that computer systems were just ignoring. And eventually, they start to add up. So long story short, any time you have scientific or financial or any sort of large data sets that involve big numbers and lots of them and lots of time, this is a problem. And it almost suggests you shouldn't you C or let alone computers unless we actually address this. Now as a spoiler, humans have chipped away at this problem, and you can use more and more bits but not infinitely many bits. At some point you have to draw a line, but this is why, for instance, a stock exchange might only represent two decimal points of precision for dollars or maybe four decimal points to the thousandths place for dollars and cents. And they just have to decide, that's all the precision we can actually store precisely. But you've got to decide how to handle it and not just ignore the problem. But we can do a little better. You know what? It turns out that in most computers a float, it takes up, yes, a finite amount of space, but very specifically 32 bits of space or 4 bytes. A byte, recall, is 8 bits. So 4 bytes is 32 bits, and that's just a very common unit of measure. But there's another one. It turns out, if you want twice as many bits, you can literally use a data type called double. And in the CS50 Library, there is a function called get double. And if I go ahead and do it here, I can now recompile this code, make floats, even though they're not technically float types anymore. And let me go ahead and do dot slash floats enter, and let me type in 2 and 10. And now it's still imprecise. But notice, instead of seven zeros, which I think I had before, now I've got 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 zeros. So I've kind of pushed the problem further out, so to speak, so it's more precise. But it's not perfect. You can't get certain values perfect if you want to be able to represent an infinite range. Any questions then about this? And we'll come back as to some implications. Yeah, here. AUDIENCE So would it always be better if you use doubles because it's more precise? DAVID Good question. Would always be better to use doubles because they're more precise? Short answer, yes, but we're going to see thematically in this course and computer science more generally there's always a tradeoff. And yes, if you use a double, you will avoid this problem a bit more, but what price will you pay, so to speak? Maybe processing power because it's got to deal with more bits at once, and even more literally, more space. I mean, sure we can take your solution, but I'm going to charge you twice as many bits. And back in the day, decades ago, when C was first being invented and computers were really coming into play, spending twice as many bits, even if it's only 32 more tiny zeros and ones, that was actually expensive literally financially, and it adds up. And even today, if you want to spend more space, that's fine, but you're going to spend. More space, therefore more money, and therefore have less space available for other things. So it's just a tradeoff. And you have to decide, as an intelligent human, where the right inflection point is between what's more important. Let me open up a very different example now called parity, just as an example. And let me ask this d how do you know if a number is even or odd? What's the trick? Yeah, if it's divided by 2 so 0 and 2 and 4 and 6 are even because, if you divide by 2, you don't get a remainder. So actually, if you just want to see a quick example of why you might use a remainder, even though it's out of context. Here's an example for parity. Parity is just a term referring to even or odd in this context. How might we use this? Well, notice I can get an int from the user up at the top. I can then check the parity of the integer is it even or odd with syntax like this. Now I'm combining some of these operators as you might be inclined intuitively. If n, the number user typed in, mod 2, or divided by and then check the remainder of, but that's a mouthful equals equals 0, you just said it's an even number so print even else print odd. Because what's the possible other remainder? If you do n or any value divided by 2, you might get a remainder of 0 or 1. I only have to check for one of those, 0 because the else implies the other thing. So again, very simple example. But honestly, all of us probably have an intuitive understanding of what's even and odd. A computer needs to be taught that, and so there's a program that does exactly that. Let me open up a larger program called conditions, and rather than type this one out, because it's a few lines of code, let me just open it up because it concludes exactly the code we saw a little bit ago on the slide when we compared it to a similar C block. In this program, in my main function let me focus on the first few lines there I have an int called x that I'm getting via get int, another int called y that I'm getting via get int, and then I'm just doing some simple comparisons. We saw this again when we compared it to Scratch, but this is quite simply that same code in context rather than just seeing it statically on a slide. So let me go ahead and compile this make conditions enter. It seems to compile. Let me zoom in and do dot slash conditions enter. x will be, say, 2 again, y will be 10. x is indeed less than y. If I run it again and I can save time by hitting up through my history and just hitting Enter. Let's do 2 and 2, and indeed x is equal to y and so forth. So again, just the exact same kind of code as before but now in the context of a working program. What if I actually wanted to get user input kind of like our past student did with getting a yes or no answers to the apple and the cupcake question? Well in answer dot C, it turns out you can actually get textual input from the user, perhaps a simple yes or no or just y or n for succinctness. And in this case, if I just get back a single character, it turns out there's a separate data type for character. If you don't want a whole string, like a whole word or a paragraph or sentence or whatever, you just want one character. You can actually use what's called a char or character. And so here I'm using one other function appropriately named called get char. I'm storing it in a variable called C because it's nice and succinct of type char, and then notice this. You might not have seen this syntax before, especially if you've never programmed before even in Scratch. But you might have seen this block similar to this in Scratch. What does the vertical double bar probably imply here? Or, that's it. So in Scratch, it's nice and user friendly. They literally just say OR. In programming, it's often the case that use just more cryptic sequences of characters and two vertical bars, which are typically above the Enter key on a US keyboard. If C equals equals capital y or C equals equals lowercase y let's assume that the user wanted to say yes and go ahead and say yes. Else if the user typed in n in capitals or and in lowercase, let's assume he or she meant no and say no accordingly. And what are we going to do otherwise? Apparently nothing, and that's fine. You don't need to have a default case if you want the program to do nothing. It might be a little confusing because the user can type in some random word and get no output, but that's a design decision. Logically this is just how we might express this. What about actually building our own blocks? Any questions, though, before we start to create? So recall that in Scratch we had that cough example. Let me go ahead and create a file here real quickly called cough zero dot C and just kind of recreate what we did last week. Include standard IO dot h int main void again, just muscle memory now and then printf quote unquote "cough" backslash n semicolon. And you know what? Let me go ahead and cough not once, but twice, three times. The moment you start copying and pasting, you're probably not writing good code. It's not very maintainable. Now if I want to change the word or translate it to another language, I have to change it in three places. We already decided last week that was bad. So what would be better in C or in Scratch or in general than this approach? Yeah, so a for loop. So let me do that let me create another file. I'm going to call this one cough one dot C, is my second version. Let me go ahead now and just copy and paste the original code, and let's just improve it. Let's get rid of two of these, and let's see if we can't express the 4. So it was 4 let me zoom in int i get 0. i is less than some number. Before it was 50. Now I'm going to have it be 3. i plus plus curly braces, and now let me move the cough block inside of there and indent it just to be pretty. And notice stylistically, I've been doing this instinctively for some time. Everything's nicely indented just to make it more readable, quite like the Scratch blocks, even though again a lot of white space doesn't matter to the computer. So if I go ahead and run this let me pull up the terminal window so I can see it. Make cough one, enter looks good dot slash cough one cough cough cough. That's good, but recall that we actually improved this design further by abstracting it away. Let me go ahead and make my own function now. Let me go ahead and open up a new file, cough 2 dot C, just like I had another scratch program. Again, include standard IO dot h int main void, and then in here let me go ahead and do what? Well, for int i get 0, i less than 3, i plus plus plus curly braces. Then let me go ahead and just call cough. It would be nice if cough existed, but unfortunately cough does not exist. It's not in the CS50 library even. So that's not going to help us. I have to make my own function. So in Scratch, you went to the block's thing and you make your own block and the big prompt comes up and you make your new puzzle piece. Here we're going to have to be a little more deliberate, and it turns out you can do it like this. Some of these details will be nonobvious at first, but I'm going to go ahead and call the function cough. And cough at the moment does not need to take any inputs. So the key word there is void. And we've actually seen that before. Main also has not been taking any inputs. That's why we had the word void, but more on that another time. And cough is not going to return anything either. It's going to print on the screen just like Brian did. But Brian, recall, didn't hand me anything back physically. So there's no return value. So I'm going to say void to the left of cough. So for today's purposes, this just means that cough neither takes input nor returns a value as output. That's it, void, void. Now as the body of that function, so to speak, I'm just going to go ahead and say quite simply cough backslash n semicolon. That's it. So now I have a puzzle piece, if you will, whose purpose in life is to cough, which means now I can magically just call it by its name up here as many times as I want. So let's go ahead and compile this. I'm really on a good roll. Everything's been working out great so far make cough 2, enter, red errors. So this is interesting, and this kind of reminds me of the previous error. So first of all, what line is my error on? Seven and character nine, if you care, but it's seven, on line seven implicit declaration of function cough is invalid in C99. C99 is referring to literally 1999 when this version of C was invented, and so implicit declaration of function cough. But it's right here. OK, wait a minute. Instinct, let me just move this. Let me just put it up top. Let's see what happens. Make cough 2 oh my god. That fixed it. Why? Even if you've never programmed before, reason through intuitively why this solved something. AUDIENCE You are holding a function that you have had been declared previously. So even though you are making it void, you at least have [INAUDIBLE].. DAVID Exactly. Because I previously was trying to use cough early on line 7, but I was only teaching the computer what cough was farther down in the file. Frankly C is kind of dumb. It literally reads your code top to bottom left or right. And if you try to do something before you've taught the computer how to do that, you're going to get that kind of undeclared identifier because it just doesn't know what the word is yet. Now in Scratch, this isn't a big deal. You just move the puzzle pieces anywhere you want. Order of blocks physically on the screen does not matter. But in C, it does. But frankly, this seems a little annoying that now the main program here keeps getting pushed farther and farther down the more kind of complexity I want to add to my program. So there's another solution. Let me actually go ahead and put this back where it is because I'm a little particular. I just like by convention main to be at the top, and frankly that's good style. If main is the most important function in your program by default because it is the main function and it's what gets called per earlier by default by the computer why am I going to push it all the way down just to work around this stupid detail? Well, I just need to teach the computer what the function is, and I can do that a little redundantly by just saying this. This is what we're going to call the prototype for a function. If you literally just copy the very first line of it that has its name, its inputs if any, and its output if any, that's a prototype semicolon. It's literally copy paste from the function itself, but this is now enough of a hint to say, hey, computer, this shell exists. This is enough information for you to then call it because the computer, so long as ir has seen the function's name before, it's OK if the zeros and ones, so to speak, that implement it come a little later. And so that's the more conventional way to solve that problem. So just intuitively then, take a guess, if it's not too much of a indirect leap, what is in standard I/O h, what is in CS50 dot h. Those kinds d we'll call them declarations. So literally in standard IO dot h is a line of code that teaches the computer what printf's inputs are and what printf's output is if any. In CS50 dot h, there is literally a line of code that tells the computer what get strings input is and what its output is. And the same for get int and get float and get char and others that's all that's in those header files. The zeros and ones, so to speak, are actually in files literally called standard IO dot C and CS50 dot C, although that's technically source code. The zeros and ones are in a compiled file elsewhere on the system. But all of these things we've been taking for granted, now hopefully it makes a little more sense because, the fact that I'm doing the sharp include at the top, that's just a solution to a problem. In that file is enough information to teach the computer what's printf or what get string and other things are so that I don't need to bother moving things around myself or copying and pasting whoever wrote printf, his or her code, into my program. Now let's do one final example with coughing and go ahead and call this call this cough 3 dot C and go ahead and paste my same code as a moment ago just to get us started. And recall that the last step of our cough example last week was to actually give cough an input. I'd kind of like to whittle this code down to literally cough 3 because this is a really nice abstraction. I don't want main to have to think about how many times just cough three times. That's a nice, useful human abstraction. Now let's put the functionality down here. So if I want cough to be able to tolerate an input like 3, which mentions of void presumably needs to change? The one on the left or the right? The right, the one inside the parentheses. And it turns out, just like you can declare variables inside of a function, as we've done, so can you declare arguments to a function like this. So you can call it anything you want, though the data type matters, but this is now saying, hey, computer, cough does not return a value, like Erin did return a piece of paper. Hey, computer, cough does take one input. It's an integer and just call it n. And now that you've done this, now you can have a line of code in here like this. For int i get 0, i is less than n i plus plus and then, OK, off by keystrokes here. Then I can move this inside here, indent it nicely. And now notice, all of the complexity of coughing has been factored out into a function, my own puzzle piece, if you will, that even takes an argument so that now you can literally, if I move this far away and out of mind, now your program is getting pretty interesting because it really just does what it says. And this is a nice functional abstraction, if you will, so that now I have a new verb, a new action, a new function called cough. Any questions on that one? Yeah. Sorry, say again. AUDIENCE What integer would main return? DAVID What integer would main return? It turns out we'll come back to this. It's going to return 0 almost always by default, but that leaves you with almost an infinite number of nonzero values which represent all of the many things that can go wrong. So more on that when we start creating more mistakes. Let's look at one other. Let me go ahead and open this file in advance myself called positive dot C. Suppose that I'm not content to just have access to get int. I want a function called get positive int because, for whatever reason, my program, my game, my whatever needs to know a positive value. Maybe I'm asking the user how many players are there, and that shouldn't be negative. It should be a positive integer like one or two or more. So it turns out I could write a program if I want that looks like this. Call on this line here a function called get positive int, pass it in a prompt, and then store the value, still in an integer, on the left hand side, and then just go ahead and print it out. Get positive int has this prototype at the top of the file. Notice this is not a function that comes with CS50s library, CS50 dot h. The function is called get positive int. As you would hope, it returns an int, and it takes a string as it's prompt, whatever words you want the human to see. Let's scroll down now, and this one looks a little more involved, and this is not a feature that Scratch has. But let's take a look. The first line is identical to the prototype because I literally copied and pasted it. Everything between these brackets is the function itself. And here, to answer someone's question from earlier on, do you have to declare a variable and then use it right away? No, and that's actually a helpful solution to a problem that we'll see in a moment. Notice here this new keyword didn't see it before do the following while n is less than 1. Previously, we saw a while loop and we saw a for loop. We did not see a do while loop. And a do while loop, while it sounds obviously similar to a while loop, what seems a little different? When I had that forever block earlier translated to while true, what was the order of operations? Did we check the condition, the true, and then print hello world? Or did we just print hello world and then check the condition? Yeah, you might not recall precisely, but I did actually I checked is true true, and we all said yes obviously. Printf is it true? Printf so it checked the condition first. You might infer then this loop is a little different. It has another word, do. This is literally going to do this first and then check the condition and only do it again if the condition is true. So it's a nice way of just flipping things around in terms of order to do something at least once rather than potentially never at all like was the case earlier. So what are we doing? Get an int, passing in this prompt, store it in n. And if the user types in a value that's less than 1, is this going to be true or false, if n is less than 1? So if the human types in 0, is 0 less than 1? True, yes, so what happens, you go back to the do and you do it again. If the user types in negative 1, is negative 1 less than 1? Yes or true. So you do it again. If he or she types in negative 2, again, again. What if he or she types in 50? Well, 50 is not less than one. So this is false. And so then you proceed to the next line of code altogether. But what's interesting about the next line of code is that, unlike the cough example, which had void as its return type, get positive int by default it's supposed to return an int, just like, again, Erin handed me a piece of paper with a string on it. And so here, if I want my own custom function called get positive int to return value, there's another word in C. You literally write return and then the name of the variable or the value that you want to hand back on a metaphorical piece of paper to whatever code is using this. So what's this oddity? Why can I not do this? If I were to mimic the code we wrote earlier like this, why does this line of code not work just logically using some of the mental models that we've had thus far? AUDIENCE Declaring the code again. DAVID Say again. AUDIENCE Declaring again and again. DAVID Yeah, so declaring just means creating, is the fancy way in programming of saying creating. So this says, hey, computer, give me an integer, call it n, and set it equal to the return value of get int. So whatever the function or Erin hands me back, put it over here. But the problem is that in C variables have scope. Scope is a fancy way of saying they only exist in between the curly braces between which they were declared. So that means that this variable n literally only exists between here and here, and then it just kind of goes away. The computer doesn't know about it anymore. But that's a problem because, on what line number do we actually need to know n? It looks like 21, and that's outside the curly braces. So just based on that basic definition, scope is the two curly braces between which a variable is declared. It doesn't exist outside of them. This code just won't work. And I'll fix it later so that you see the correct error message. Why does this not work? Well, you're declaring n inside of those curly braces. So how do you avoid this? Well, it turns out, as someone posited earlier, just declare it by itself without even giving it a value. And indeed the syntax for that is just to do half of a thought int n semicolon. It has no value that we know yet. It has a garbage value, but more on that another time. But it does now exist. And now notice which curly braces does it exist within this one and this one, which means now it's accessible everywhere. And if you in your Scratch programs actually used variables, you might have noticed that you had to choose. You had to make a decision for this sprite or for all sprites. That was an allusion to what's called in programming a local or a global variable. These are still local, and we'll come back to this term earlier. But it has to do with scope because, if you had specified for this sprite only, MIT would have only let you use that variable for that specific sprite, that cat or sheep or whatever it was you were programming. Just as in C, this now means n can be used here and here but not elsewhere like higher up in my program. That's the matter of scope. So let's now see what can go wrong beyond that. Let me go ahead and open up this because it turns out, when programming, there is other issues that can happen, not just floating point in precision, as I described it as earlier. It turns out that there's other problems that can go wrong even with integers that we kind of avoided altogether. So recall that we started talking about 1, 2, and 3 and why it's 123 last week. Well, what happens in decimal if you add 1 to 123? What number do you get? Obviously, 124. If we do it again, 125, 26 27, 28, 29. What happens in decimal if I add 1 to a 9? Well, I should get 10, but that's not how we would write this. You put down the 0 instead, and you carry the 1. Remember those mental heuristics? So that's all we did there. And then it's 2 plus 1. So that's why 129 plus 1 is 130 because you put the 0, you carry the 1, and so forth. So we just all do that intuitively now. But this has implications for what computers do too because suppose that we consider a bigger number like 999. And so what do you get when you add 1 to 999? Well, you carry the 1, you carry the 1, and you get hopefully 1,000. But what if your computer only has space for three digits? Or what if your phone or what if your alarm clock or whatever the device is literally only has room for 3 digits, what is 999 plus 1 if your hardware only has three digits? Well, it's apparently 0. So you get this overflow 998, 999, 0. It overflows, so to speak. The one kind of falls off conceptually, and you roll over to the next value, which is 000. So what about in binary? What number is this in binary if you translated the decimal in your head? And remember, it's the ones column, the twos columns, and the fours column. So this was 7 in binary 1, so it's 4 plus 2 plus 1, so 7 in binary. So how do you do arithmetic with binary? It's actually the same thing. It's just you don't have twos or threes or nines or anything in between. You just have ones and zeros. So what do you get when you add 1 to 111? Well, it's the same idea. You put down a 0 and you carry the 1 because 1 plus 1 you want to say 2 in decimal, but there is no 2. So it rolls over to 0. But you carry the 1. 1 plus 1 is 2, but, OK, that's 0, carry the 1. 1 plus 1, that's 2. But I don't have a 2. So I go back to 0, carry the 1. So in binary, if you only have three bytes or bits rather, if you only have three bits, what do you get when you add 1 to 7 in binary? You apparently get 0. And now it's getting more real. In my computer, in my phone, in all of your hardware it's just a finite amount of memory, RAM, that little chip that I showed on the screen with all the little circuits. And that has more than 3 bits of memory certainly, but it is finite. And if we're only using, as a matter of convention, 32 bits to represent things or 64 bits, maybe if we use doubles or something else called a long a long is a 64bit integer, whereas an integer is typically 32 bits. It seems that, at some point, numbers might overflow and we're going to actually have some, so to speak, imprecision ergo, integer overflow. So you can actually see this or defenses against this in the real world. So this is a screenshot from a game that is common on a few different platforms, and it's a game that allows you to accumulate coins or points really, or little Lego pieces. And if you accumulate these points, you'll notice that eventually, if you have way too much free time, you can only score so high in this game. What's the highest score apparently, according to the screenshot from whoever took this after playing for too many hours? Wasn't me. 4 million no, 4 billion, 4 billion. Why is that? Well, it turns out that, if numbers and computers, as I've proposed, are generally stored using 32 bits. That kind of invites the question, well, how high can you count with 32 bits? Well, 32 bits means you have 32 zeros and ones. The biggest they could be is like 11111, 32 ones. And if you actually do the math using our little columns and so forth, it's roughly 4 billion, a little bigger than 4 billion. So the authors of this Lego game just decided, you know what, let's just say that the maximum number of points or coins you can accumulate in this Lego game is 4 billion even. Why? It just looks even cleaner than whatever the actual value is. But why? How many bits are they using to store your score in this game presumably? 32 bits or 4 bytes, and that's just convention. Whatever language they programmed this game is, probably has a data type called an int, and that int by convention uses 32 bits. So at some point, they had to decide, we can either use more memory as you proposed earlier for doubles. Let's use 64 bits. Then you can have crazy numbers of hours playing the game and getting more and more points. Or we can just say that's enough points to accumulate in the game. Now that's when you actually anticipate this. This doesn't always actually happen. If we go ahead and take a look at some example code let me go ahead and open up overflow dot C. In this program here, you'll see line 8 the slash slash syntax, and I've had a bunch of these so far. But I haven't actually mentioned them. It turns out in C, just in Scratch the odds are you didn't notice this little feature of Scratch you can have what are called comments. A comment is just a note to yourself, to your TF, to your friend, to your colleague, with whoever whom you're writing code with. And it's just a note to self to remind yourself of what the code does. Without this line, I could once, I'm comfortable enough programming, figure out what these lines of code are doing. But frankly, that's a waste of time I wrote the code once. And if I look at it weeks or months later or someone else wrote it, just tell me what it does. So a comment in a program is just like a nice summary of a few lines of code, or it's a summary in English or whatever spoken language that describes what otherwise a cryptic looking code might actually be doing. So you don't have to think too hard about it to understand a program. So iteratively double i iteratively just means loopingly, again and again and again. This is funky. We didn't see this, before but you might guess what it does. What the star equals do? It does double. It's like plus equals adds 1, star equals doubles if the value on the right is 2. So this is going to start printing 1 then 2 then 4 and 8 and so forth. And notice this function. It's called sleep. It literally is going to sleep for a second, and that sleep function has a prototype that someone else wrote in a file called uni standard dot h. I only know that by looking it up in the documentation. But that's a new file just for sleeping. Make overflow, which is apt here. And let me go ahead and make the terminal window even bigger for this one dot slash overflow. OK, it's going. It's going. It's going to go faster and faster, so to speak, because we're adding more and more each time by doubling. 2000, 4000, 8000, 16,000 it's still going 64,000, 65,000. Now we're into the millions 2 million, 4, 8, 16 million. It's getting bigger and bigger, all of these big numbers. Ooh, interesting. What just happened? So it turns out, if you double numbers big enough, you get 0 eventually, also something you probably weren't taught. So what actually happened? ControlC, we'll cancel this. What happened? I mean, the program is trying to tell me, even though it's a little cryptic, signed integer overflow. Signed just means it went from positive to negative essentially. So what happened? What's that? Yeah, it ran out of bits. I'm doubling the number again and again and again. And at some point, we carried the one so to speak and it was a 33rd 1, therefore past the boundaries of a 32bit value, and it just rolled over to apparently a negative because at some point and we haven't talked about it you can use like the leftmost bit in some sense to say positive or negative. We've just talked about positive so far. And then at that point, frankly, the computer just gave up not really knowing what you intended beyond that. So if you don't write code to handle this situation and make sure that your numbers are less than 4 billion before you roll over, just bugs will happen. And this might seem contrived here, but this happened not too long ago. So 1999 was just before a lot of people thought the world was going to end because of the socalled Y2K bug, and it really wasn't so much a bug as it was lack of forethought or lack of features. What was the Y2K problem in a nutshell? Someone want to propose? Even in a nontechnical sense, yeah. AUDIENCE Computers couldn't display the number 2000. DAVID Yeah, so let me summarize here. So if they are only using two digits to display values, you could confuse the year 2000 with actually the year 1900 because, long story short, what humans did kind of reasonably decades ago was space was expensive. Computers were expensive. Memory was not as abundant as it is now with all the cloud storage and the like. So you know what? If it was like 1970, do we really care about 1969, 1968, let alone 1900? Not really let's just assume we're all in the 1900s and never show or store one 9. Let's just store two digits for every year. So 70 is '70 99 is 1999. But the problem is the humans ended up running code that they wrote years ago, decades ago way longer than humans thought they might why. Well, it's expensive, it's time consuming to change code, the code is working. Why try to break it? Problem is, too, as people aged in and passed away, there's fewer and fewer people that even knew the languages in which those programs were written in. And so now who's going to even update the software? So lots of problems were feared, and this really just boils down to because 1999 might have overflowed to not zero per se but an implicit 1900. And indeed, this definitely happened, though not nearly on the scale as people thought. But it does happen in even more real terms just a few years ago. This is a Boeing 787, an actual airplane that had to be grounded for some amount of time because it had a programming error. And its summarized here in an online article. A 787 airplane that has been powered continuously for 248 days, it turns out was the warning, can lose all of its electrical power due to the generator going into fail safe mode. Why is that? This condition is caused by a software counter internal to the generator that will overflow after 248 days of continuous power. So translate that. That just means there's software running in the Boeing's actual 787s. They were using 32bit integers. They were using those integers to store hundredths of seconds. And at some point if you leave your plane on for 248 days, each of which has 24 hours, 60 minutes in an hour, 60 seconds in a minute, and 100 tenths of a seconds or 100 one hundredths of a second in every second, that product of multiplying things out gets big pretty fast. And on day 249, planes theoretically would shut down even in the middle of flight for very real reasons because a really big number rolls over to zero and that confused the generator. And these are actual smart airplane engineers making these kinds of mistakes because of software, not anticipating one line of code or some number of lines of code. Or, as you proposed, why didn't they just use more bits? And again, these are very real concerns. So this was thankfully addressed and solved, but not before of course there was quite the scare there. So it turns out, in an older game, this was the game of Civilization. It turns out that one of the characters as whom you can play, Gandhi, is actually not as peaceful a character in the game is as you might think. And let's for context just take a look here for a second. If we actually take a look at some more binary, this in binary is what number in decimal? OK, 1. And this is 8bit. So it's a full byte. 8 bits is a byte 1, 2, 3, 4, 5, 6, 7, 8. So what do you get if you do a 1 minus well, if you subtract 1 from this, you obviously get what? All zeros. So 1 minus 1 is just 0. What if you subtract 2 from this value? What happens? This is actually called integer underflow, which is just the opposite, but there's really not too many options to think about this. If you only have zeros and ones, you can probably imagine what the bad scenario is. If 0000001, if you subtract 1, goes to zeros, and then you do it again, you now underflow, which just brings you around to the opposite 11111111. So if you have 8 ones, what value is that if you do the math? Ones, twos, fours, eight 16s. It turns out it's 255 if you actually do all the math. So it turns out that this game Civilization was using a single byte to represent every character's level of aggressiveness in the game. And Gandhi's was, as you would expect, by default initialized to 1, very nonaggressive. Unfortunately, in this game of Civilization, when a player adopts democracy in his or her civilization, their aggression would be automatically reduced by two. And so if Gandhi went democratic, his aggression wouldn't go to negative 1. It looped back around to the ludicrously high figure of 255, making him as aggressive as a civilization could possibly be. So less impactful, to be sure, than something like the airplane example, but these problems are omnipresent. And if you start to keep an eye out in the popular media or when there are bugs or hacks or exploits, it's so often because a programmer has made a mistake in his or her code. They didn't anticipate a scenario or they made maybe reasonable decisions years ago, but that eventually proved to be naive in that we're still running the same code, numbers are getting too big, their math is wrong. And so very real things happen. But what's most important for us is just understanding how and why those things happen. And so what will we do in the days ahead? So the next homework assignment, as with Scratch, will be to program something but this time in C. You will use an environment called CS50 lab, which essentially is CS50 sandbox, with which we've been tinkering today. But it adds to it the instructions and the specification of the problems that you'll want to solve. And it'll hold your hands initially through some of these steps. You don't need to have written everything down and memorized everything I typed today, but do feel free in the meantime to go to the course's website and play with any of those examples. Among the challenges ahead will be to recreate some snippets of games from yesteryear, thinking about how things you might have seen growing up can be translated to actual code. And undoubtedly, among the first things you'll experience, is frustration. You'll forget the stupid semicolon or where does the parentheses go? And you'll have to look back at code. But keep in mind, none of that stuff matters. It's absolutely frustrating initially, but what's most important is the ideas and, honestly, the sense of gratification that you, like all of CS50 staff before you, ultimately feel when actually building and creating something of your own. Let's call it a day there, and we'll see you next time.
