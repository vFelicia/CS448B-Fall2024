With timestamps:

00:00 - what's up programmers and subscriptors
00:01 - this is ryan here and in this course you
00:03 - are going to learn how to build a native
00:05 - android application using kotlin jetpack
00:09 - libraries and a little bit of help from
00:11 - firebase
00:12 - now before we jump into the android
00:14 - stuff please be aware that the audio
00:16 - quality does improve after the first
00:18 - section of this course
00:20 - be sure to check out the timestamps in
00:21 - the description box and also check out
00:23 - the pinned comment down below for links
00:25 - to more awesome educational content so
00:28 - that's it hopefully you enjoyed the
00:29 - tutorial
00:30 - what's up everybody this is ryan here
00:32 - and you are watching my jetpack notes
00:34 - mdvm android kotlin tutorial
00:37 - so in this video what i'm going to do is
00:39 - i'm going to demonstrate the application
00:42 - that we'll be building throughout this
00:43 - tutorial series or building in
00:45 - increments
00:46 - and then we'll also have a look at
00:48 - basically a huge list of topics that
00:50 - we'll be covering so that you know what
00:52 - to expect in this tutorial series
00:55 - so before we get to those finer details
00:56 - let's do a quick demo of the application
00:59 - jetpack notes has three features or
01:02 - primary user interface screens
01:05 - we're looking at the note list feature
01:07 - currently
01:08 - and as you can see we don't have any
01:10 - notes so it's kind of in an idle state
01:13 - so note list display displays all of the
01:15 - notes which are currently stored either
01:16 - in the local room database or the remote
01:19 - firestore database
01:21 - and the decision of where to save or
01:23 - retrieve notes is based on whether the
01:26 - user is logged in or not and that's
01:28 - actually a concern which is handled in
01:29 - the back end of the application
01:32 - so uh from this screen we can also
01:34 - create a new node so i'm just going to
01:36 - hit the plus button
01:39 - and we'll just create new oops i can't
01:42 - type
01:43 - new note
01:46 - like so
01:47 - and then i'll hit the check mark button
01:49 - this is also where you can delete notes
01:51 - and as you can see we have the new note
01:53 - here
01:54 - next thing i'm going to do is i'm going
01:55 - to hit the key i icon which will open
01:58 - the login feature
02:01 - and as you can see we are currently
02:02 - signed in so what i'm going to do is i'm
02:05 - going to sign
02:06 - out okay and then i'm gonna head back to
02:10 - the note list feature by hitting the
02:12 - back button
02:14 - and as you can see we have a totally
02:16 - different note currently present for
02:18 - because that is uh what's coming from
02:21 - the local
02:23 - room database so i'm just going to hit
02:25 - that
02:26 - hit the delete button
02:28 - and as you can see that's cleared that
02:29 - out and then we'll just log back in
02:31 - again
02:37 - sometimes it takes a moment there we go
02:44 - there we are
02:46 - and boom new note
02:48 - so that's a quick demo of the
02:49 - application and this is what we will be
02:51 - building in this tutorial so in order to
02:53 - follow along with the tutorial you're
02:55 - going to need to visit the repository
02:57 - link down in the description box below
03:00 - and you'll need to either clone or
03:01 - download the code so that you can follow
03:04 - along properly what i'll do is in each
03:07 - lesson i'll sort of go through with you
03:10 - i'll give you specific instructions on
03:11 - how to create a starting point so we're
03:13 - all on the same page and then we'll
03:15 - carry on from there
03:17 - this tutorial will cover both front end
03:19 - middle and back end topics for android
03:22 - development
03:23 - for front end we'll look at constraint
03:25 - layout simple android animations using
03:28 - animation lists using vector graphics
03:31 - which will basically allow you to have
03:33 - cool graphics and animations which will
03:35 - scale with whatever
03:37 - uh resolution or screen size you're
03:39 - working with i'll show you how to build
03:41 - a recycler view which happens to be the
03:43 - first thing i ever taught people to do
03:45 - on youtube
03:47 - and then we will look at implementing
03:49 - the navigation library from jetpack
03:51 - uh view models from android architecture
03:53 - components fragments and i'll do in the
03:56 - next video a big talk about model view
03:59 - view model front-end architecture
04:01 - pattern
04:02 - for back-end topics i'll teach you about
04:04 - using firebase auth and google sign-in
04:07 - provider for quick and easy user
04:08 - management we'll look at using room and
04:11 - firestore for local and remote data
04:14 - storage respectively
04:16 - i'll teach you how to hide these things
04:18 - behind a repository so that the front
04:20 - end doesn't know or care where the notes
04:22 - come from
04:24 - and we'll also learn about simple
04:25 - dependency injection using android view
04:27 - model
04:28 - and view model providers to get
04:30 - everything nice and wired together
04:33 - and finally we'll talk about how to wire
04:36 - the end-to-end application together
04:38 - using kotlin co routines and let me tell
04:40 - you i think you're really going to enjoy
04:42 - that part
04:46 - and in this video i'm going to be giving
04:48 - you an overview and kind of an
04:50 - examination of the pros and cons
04:53 - of using the model view view model
04:56 - architecture which is the architecture
04:58 - that we'll be using in this particular
05:00 - tutorial series
05:01 - we'll also have a quick look at the
05:03 - packages and files for the demo
05:05 - application just so you understand
05:06 - what's going on there
05:08 - now before we look at this pattern in
05:10 - detail i'd like to address what i
05:12 - consider to be a few misconceptions
05:13 - about not just model view view model but
05:16 - software architecture front-end gui
05:18 - patterns in general so i'm going to
05:21 - assume that most of you have heard about
05:23 - all kinds of different three layer
05:25 - architectures there's model view
05:26 - controller model v presenter model view
05:29 - view model which google seems to be
05:30 - putting all of their weight behind or
05:32 - sorry the android team rather and then
05:34 - we have other options like viper or
05:36 - there's model view intent by hannes
05:38 - dorfman and i'm sure what most of you
05:40 - are wondering is would someone please
05:42 - just tell me which one of these is the
05:44 - best architecture
05:46 - well i'm going to try and burst your
05:48 - bubble right now because in my personal
05:50 - opinion the answer and this opinion is
05:53 - fairly widely shared among senior
05:56 - developers
05:57 - is that
05:58 - the project requirements at hand will
06:01 - dictate the best architecture for you
06:04 - so one of the things that i've noticed
06:06 - over the years of trying several
06:08 - different approaches different patterns
06:10 - is that they work good in some
06:12 - situations and they can be
06:14 - uh counterproductive in others now
06:18 - it's better to follow an architecture
06:21 - which doesn't really work super well for
06:23 - your problem requirements than no
06:24 - architecture at all but what i'm trying
06:27 - to say here is that over time when you
06:30 - know things about all these different
06:31 - patterns you'll start to see okay well
06:34 - this particular feature of this pattern
06:36 - is useful in situation a but it's kind
06:38 - of a problem in situation b
06:40 - so what i would like to do is basically
06:42 - explain in this video that uh model view
06:44 - view model is not an exception to that
06:46 - rule it is not necessarily the best
06:48 - architecture for all situations even on
06:51 - the android platform but it does have
06:53 - some benefits and some deficits so what
06:55 - i would like to do is basically give you
06:57 - an idea of what those benefits and
06:59 - deficits are
07:00 - and uh yeah we'll get into that in a
07:02 - moment but before we talk about that i'm
07:04 - going to try to give you like a general
07:06 - overview of the architecture using
07:09 - whiteboard example
07:11 - okay so what we're going to do now is
07:12 - we're going to talk a little about the
07:14 - model view view model front end
07:17 - graphical user interface pattern before
07:20 - i jump into this one thing to note is
07:22 - that unfortunately
07:24 - developers do not
07:26 - always consistently build these things
07:28 - the same way so what i'm going to
07:31 - explain to you is a generalization
07:34 - this is my interpretation of the model
07:36 - view view model
07:38 - architecture but like i say you're going
07:40 - to find different variations of this and
07:43 - the most important thing for you to know
07:45 - is that different variations will work
07:47 - better in different situations so
07:50 - what exactly
07:52 - happens how does it work so the first
07:54 - and most important thing the the
07:56 - defining characteristic of model view
07:59 - view model in my opinion
08:01 - is that uh essentially we have this
08:04 - thing called a view model in the middle
08:07 - which encapsulates the
08:09 - both the behavior
08:11 - and the state
08:13 - of the front end of the view both the
08:15 - behavior and the state so state being
08:17 - the data
08:18 - and the behavior being what do we do
08:20 - when some event happens kind of deal
08:25 - so the thing that's unique about model v
08:27 - view model is that the this thing in the
08:29 - middle the view model you're not allowed
08:32 - to have this view model actually
08:35 - directly tell
08:36 - the view what to do i'm not allowed to
08:39 - draw a line from here to here which
08:41 - would be a dependency
08:43 - so if you're doing model v presenter you
08:45 - are allowed to do that in model view
08:47 - model you're not
08:48 - based on my interpretation
08:50 - instead what happens is we basically
08:52 - have to have two dependencies
08:55 - two different channels
08:57 - from the view
08:59 - to the view model
09:01 - this is typically how we like to set it
09:03 - up so one channel is just synchronous
09:05 - and this would be the kind of thing
09:06 - where let's say for example if we're
09:09 - coding for android or whatever the user
09:12 - hits a button
09:13 - and then the view can just if
09:16 - you know just do a synchronous call just
09:19 - a function call to the view model hey
09:21 - this button was clicked
09:23 - so that's one of the ways it can
09:24 - communicate with the view model
09:26 - the other way and this is how it
09:28 - actually
09:30 - gets the data out of the view model and
09:32 - this is confusing for some people is
09:35 - that do you see this eyeball thing here
09:37 - this is my representation of what's
09:38 - known as the observer pattern so you
09:41 - could use data binding what i like to do
09:43 - is i like to use basically
09:46 - a producer consumer consumer
09:48 - relationship or the observer pattern
09:50 - it's called between the view model
09:53 - between the view and the view model so
09:54 - basically what i'm saying here is at the
09:56 - start at some point the view model will
09:59 - ask for observables
10:01 - so it's going to ask for something from
10:03 - the view and this thing that it it gets
10:06 - sorry it's going to ask for something in
10:07 - the out of the view model and when it
10:10 - gets that object that observable object
10:13 - i want you to think of that observable
10:14 - object as like a pipe
10:17 - that data pops out of at on
10:19 - indeterminate time whenever the data
10:21 - pops out of the pipe whenever the v
10:23 - model asks the model the back end for
10:26 - some data it's going to then
10:29 - publish that data and if the view is
10:32 - listening then the view is going to grab
10:34 - that data that pops out of the the
10:36 - observable pipe
10:38 - and then it's going to render that on
10:40 - the screen
10:41 - so that's basically how model view view
10:43 - model generally speaking works so one of
10:46 - the things to keep in mind about this is
10:48 - that the the benefit of model via view
10:51 - model is can also be the deficit so one
10:54 - of the main benefits of it is we can
10:55 - have a many to one ratio
10:58 - of views to view models and that's
11:00 - because the view model does not depend
11:03 - on any view specifically the cost of
11:07 - that is that you lose fine-grained
11:10 - control
11:11 - over what the view does
11:13 - so naturally in many cases
11:15 - you're going to have to actually have
11:18 - more logic in your view
11:21 - because the view is going to have to be
11:22 - able to
11:23 - interpret what's coming in from the
11:26 - observable streams
11:28 - so there's different ways to solve that
11:31 - and the logic isn't necessarily going to
11:33 - be super complicated but this is one of
11:35 - the things you want to think about when
11:36 - you're working with model view via model
11:39 - in particular
11:41 - so now that i've given you like a
11:42 - general overview of the pattern i just
11:44 - wanted to get a little bit more specific
11:46 - about the things i am fond of and not so
11:49 - fond of in this particular architecture
11:51 - with the hopes that it can help you
11:52 - inform your decision about whether you
11:54 - think it's a good idea to use it or not
11:57 - so the most important thing just to
12:00 - start with the cons here in this
12:01 - particular architecture
12:03 - is that the synchronization between the
12:06 - view and the view model
12:08 - presents a problem of separation of
12:11 - concerns if you're not sure what
12:12 - separation of concerns is i've written
12:14 - an article and i'll link it down in the
12:16 - description box below and it'll
12:18 - basically explain my perspective on
12:21 - separation of concerns but i actually do
12:23 - consider it to be probably the most
12:25 - important principle to observe in
12:28 - software architecture
12:30 - anyways the reason why the
12:31 - synchronization logic can be awkward and
12:34 - there are ways around it is because we
12:36 - don't have that fine range control over
12:40 - the view
12:41 - so this means we have basically two
12:43 - options and these are kind of what i
12:45 - would consider to be
12:46 - subsets of model view view model
12:49 - so option number one is to basically
12:52 - fill
12:53 - the view with a whole bunch of logic to
12:56 - interpret
12:57 - the data which the view model publishes
13:00 - to it
13:01 - so this approach will allow you to have
13:04 - very reusable view models
13:07 - but it's going to basically make it so
13:09 - that you fill your fragments or whatever
13:11 - view class you're using with a whole
13:13 - bunch of logic when you fill something
13:15 - with a whole bunch of logic
13:16 - that's really the time when you really
13:18 - need to be careful about testing now i
13:21 - personally don't like to test ui classes
13:24 - instead i use humble object or passive
13:27 - view which basically makes those classes
13:29 - generally speaking one-liners
13:32 - and
13:33 - it makes them
13:34 - simple enough that they don't even
13:36 - directly need to be tested
13:38 - if you don't take that approach and you
13:39 - want to fill your fragments or views
13:41 - with lots of logic you will need to
13:44 - probably use espresso or roboelectric to
13:46 - make sure that you're testing everything
13:48 - adequately
13:49 - so one of the ways around this and this
13:52 - is the key problem is the presentation
13:54 - logic is awkwardly distributed between
13:56 - the view and the view model one of the
13:58 - ways around this is to actually make it
14:01 - so that your view model knows a fair
14:04 - amount about the particular view
14:07 - that uh it's working with so what i mean
14:09 - by that is it's not that it has a direct
14:11 - dependency but you can fill your view
14:14 - model with all kinds of in this tutorial
14:16 - would be like live data observables
14:19 - uh
14:20 - you can fill it with a whole bunch of
14:22 - these observable fields which will
14:24 - dictate for example should this text box
14:27 - be highlighted or
14:29 - this that and the other basically
14:30 - details about the view
14:33 - without actually having a direct
14:34 - dependency
14:35 - so this will allow you to basically pull
14:37 - a lot of logic out of back out of the
14:40 - view and into the view model
14:42 - and that's going to make for a much
14:44 - easier to test view the caveat to doing
14:46 - this is that if you have all kinds of
14:49 - details about a specific view in a view
14:51 - model even if there's no direct
14:53 - dependency you are still tightly
14:55 - coupling that view model to that
14:57 - particular view so you lose the
15:00 - reusability of the view model if you
15:03 - take that approach in exchange for not
15:06 - having to have a whole bunch of logic in
15:08 - your fragments
15:09 - so with those considerations in mind
15:11 - which aren't necessarily application
15:13 - breaking but as you can see there's not
15:16 - actually a truly specific
15:19 - model view view model pattern here
15:20 - there's actually some variations in it
15:23 - and this is something that i've even
15:25 - heard the android team admit when they
15:27 - were looking into this particular
15:29 - pattern so as you can see we've kind of
15:30 - got these different approaches to it and
15:32 - they're going to have different benefits
15:34 - so if your user interfaces are like
15:35 - super simple then you're probably going
15:38 - to be able to get away with having
15:40 - fairly decoupled unspecific view models
15:43 - and that's kind of one of the main
15:44 - benefits of this particular approach is
15:47 - that if you don't tightly couple
15:50 - your viewmodels to
15:52 - particular views great english here
15:55 - um then you can promote the reusability
15:57 - of those view models
15:59 - uh side benefits is of course you are
16:01 - applying some kind of separation of
16:03 - concerns by separating these things out
16:05 - so you're going to get some benefits to
16:07 - testing and modularity as well
16:10 - and one important feature
16:12 - which this is something that's specific
16:14 - to
16:15 - android's particular
16:17 - tools so android architecture components
16:19 - and jetpack and that but one of the
16:22 - biggest benefits
16:23 - uh for this particular approach on the
16:26 - android platform is that concurrency and
16:29 - lifecycle really is a breeze when you
16:32 - apply this particular architecture and
16:34 - you use their components so the final
16:37 - more detailed point i'd like to make on
16:39 - this particular architecture is that if
16:41 - you confine yourself to just having
16:44 - model view view model then you are
16:47 - definitely well i won't say definitely
16:49 - but probably
16:50 - going to run into problems where you
16:52 - have this awkward separation between the
16:55 - synchronization logic of the view model
16:58 - and the view and you have to kind of
16:59 - pick one path or the other reusability
17:02 - or
17:03 - not filling your views full of logic
17:05 - there's actually another solution which
17:07 - you can apply which is actually what i
17:09 - apply in my production code i don't
17:12 - confine myself to just using model view
17:16 - view model in fact most of my
17:18 - architectures when you look at them
17:20 - you'll usually see something which
17:22 - is something along the lines of like
17:25 - model view presenter view model and the
17:28 - view model has a different role it's not
17:30 - so much a logic class as just a front
17:32 - end
17:33 - session data container
17:36 - so anyways the point of that is just to
17:37 - say here for the people listening this
17:40 - certainly
17:41 - do model view view model and carry it as
17:43 - far as you would like but if you get
17:46 - into a situation where
17:48 - you have this ugly awkward division of
17:51 - presentation logic
17:53 - between this the view and the view model
17:56 - another option is to actually create a
17:59 - fourth class like a presenter call it
18:01 - whatever the hell you want i just call
18:02 - it a logic class
18:04 - and then you can actually pull out that
18:06 - logic again decouple it from the view
18:08 - model and then you can have this sort of
18:10 - fourth object handle things like click
18:12 - events it's going to simplify your view
18:14 - models and i would kind of suggest that
18:16 - as you start to build more and more
18:18 - complicated applications if you're
18:20 - building simple applications though
18:22 - usually you can get away just fine with
18:24 - just having the view view model in the
18:26 - model
18:28 - so the last thing i'll be doing in this
18:30 - video is giving you an overview of the
18:32 - package structure of this particular
18:35 - application
18:36 - so the repository is at jetpack notes
18:38 - mvvm kotlin under bracket cove link in
18:42 - the description box down below and what
18:44 - we'll do is we'll just open up the app
18:46 - module here let me just zoom in a little
18:50 - and i just wanted to talk about what's
18:52 - within the main package here so we've
18:54 - got four primary packages or directories
18:58 - so within common you're going to find
19:01 - classes which are
19:02 - shared across different parts of the
19:05 - application so that's why we have this
19:07 - common module here so this is where i
19:09 - like to put things like for example base
19:12 - classes so we have a base view model
19:14 - which is like an abstract class which
19:17 - shares some code across a set of
19:20 - different view models constants and a
19:22 - lot of extensions so there's a lot of
19:24 - ugly kind of data mapping stuff and this
19:27 - is something that basically converts
19:29 - from a firebase task into uh uh rxj or
19:33 - sorry co routines not rx java
19:36 - force of habit and yeah just all kinds
19:38 - of mappers and stuff like that so uh
19:40 - we'll be going into more detail but i
19:42 - just wanted to give you a quick glimpse
19:43 - there so that's uh common uh we have the
19:47 - basically two primary features of the
19:49 - application so we have the login feature
19:51 - and the note feature
19:52 - within login you'll of course find the
19:54 - login activity login event login view
19:58 - and user view model and then in each of
20:00 - these
20:01 - feature packages you're going to find a
20:04 - sub directory called build logic
20:06 - which will basically contain the
20:08 - dependency injection and user review
20:10 - model factory stuff to create the view
20:12 - models
20:13 - no dagger 2 required so everyone can
20:16 - chill the
20:16 - chill out about that
20:19 - so anyways one important point here is
20:21 - that i did actually
20:23 - try to do a single activity approach in
20:26 - this particular application as per what
20:29 - they suggest in navigation i was not
20:32 - able to due to tight coupling to
20:35 - on activity result which as of making
20:38 - this tutorial is not supported by the
20:41 - navigation library if you're watching
20:43 - this in the future it may be now and
20:46 - that is probably my biggest criticism of
20:49 - the navigation library at this point is
20:51 - that it did not
20:53 - support on activity result which is
20:55 - problematic anyways i will be demoing
20:57 - the navigation library in this tutorial
21:00 - but i
21:01 - even though i tried to do single
21:03 - activity i literally couldn't so there's
21:05 - two activities and three features
21:08 - next we have the model package so this
21:11 - is basically going to contain everything
21:13 - which is related to
21:15 - storage
21:16 - and access to data so we're thinking
21:19 - repositories implementations firebase
21:22 - stuff room stuff data models that kind
21:25 - of stuff like i say we'll go into more
21:27 - detail later so then we have the note
21:29 - directory which contains all the
21:31 - different files necessary for the note
21:32 - detail and the note list features so as
21:35 - you can see here it's pretty much what
21:38 - we like to call package by feature
21:40 - approach but something which isn't
21:43 - doesn't necessarily fit into a
21:44 - particular feature i will put that in a
21:46 - common directory
21:48 - so within the note package you see we
21:50 - have the note detail and note list
21:52 - subdirectories and these this will
21:55 - contain the views and view events and
21:57 - build logic for this particular ui
21:59 - screen
22:00 - and i chose to group them together
22:02 - because they both work on the same
22:04 - concept conceptual
22:06 - note object and then we of course have
22:08 - the view models and factories and stuff
22:11 - like that for these different views
22:13 - so that's it for this particular video
22:15 - hopefully you learned not just about
22:17 - model v view model but a little bit
22:19 - about software architecture in general
22:21 - and my goal here isn't to crap on model
22:24 - view view model or to say that you
22:25 - shouldn't use that approach i think you
22:27 - can build beautiful applications with
22:29 - this particular pattern what i wanted to
22:31 - do though is kind of explain to a lot of
22:33 - the beginners out there who are confused
22:35 - about this particular point
22:37 - that the big kind of consideration with
22:40 - this architecture is that
22:42 - synchronization between the view and the
22:44 - view model can be a little bit awkward
22:47 - there's ways to solve it though and
22:49 - we'll talk about that as we progress
22:50 - through the tutorial
22:55 - so for starters i'm going to show you
22:56 - how to find free open license images
22:59 - like the one this animation is based off
23:02 - of
23:03 - i'm going to show you how to create
23:04 - scalable
23:06 - vector graphics out of these pngs or
23:09 - raster graphics using some free tools
23:11 - i'm going to show you how to import
23:13 - those vector graphics into android
23:15 - studio so that we can actually use them
23:17 - in our applications
23:19 - and finally i'll show you how to create
23:20 - some simple but effective animations
23:24 - which scale
23:26 - and it won't require you learning 15
23:28 - different animation apis because we all
23:30 - know there's quite a few different
23:32 - animation apis on the android platform
23:34 - so if all of that sounds interesting to
23:36 - you please do consider hitting the like
23:38 - but like button down below consider
23:41 - subscribing and with that let's jump
23:43 - into some discussion on vector
23:46 - drawables and graphics versus raster
23:50 - drawables and graphics
23:52 - now you may be wondering what exactly is
23:54 - a vector drawable and how is it
23:56 - different from say like a bitmap png
23:59 - jpeg or all those other formats that
24:01 - you're used to working with
24:02 - well the key difference is that bitmaps
24:05 - or pngs or jpegs all those sorts of
24:07 - things which are known as raster
24:09 - graphics
24:10 - are in essence a collection of bits
24:14 - bitmap hence
24:16 - which ultimately represent pixels drawn
24:19 - on the screen so for example if we
24:22 - wanted to in a raster graphic type
24:24 - format render a triangle then ultimately
24:27 - you're going to end up with something
24:28 - that looks about like this if you zoom
24:30 - in close enough so we want to think of
24:32 - like
24:33 - each sort of segment of some screen or
24:36 - device
24:37 - has a finite number of pixels then we
24:40 - basically say these are the pixels that
24:42 - we want to draw this is the color and
24:44 - you end up with something like that
24:46 - so the problem with these particular
24:48 - formats which are as i said known as
24:50 - raster graphics is that they don't scale
24:53 - well across a variety of different
24:55 - displays or resolutions
24:57 - one solution to this is to provide many
25:00 - different versions of the same images
25:02 - the same image
25:04 - which have different resolutions so on a
25:07 - really high quality device you're going
25:09 - to provide a much higher resolution icon
25:12 - or image or something like that
25:14 - while this kind of works the problem
25:16 - with it is that you can end up with a
25:18 - situation where you're bloating your
25:20 - packaged applications or taking up a
25:23 - whole bunch of your users data
25:25 - by downloading a whole bunch of really
25:27 - large image files so if possible we kind
25:30 - of try to advise against having just a
25:33 - huge number of image files
25:35 - in your apk
25:37 - so as opposed to having say a finite
25:40 - number of pixels represented in some
25:43 - kind of collection format vector
25:45 - drawables take a different approach so
25:47 - essentially what we're doing is we're
25:48 - supplying a series of coordinates and
25:52 - you can add much more detail than just
25:53 - coordinates
25:55 - but say for example if we wanted to
25:56 - render a triangle we would for example
25:59 - give in this file
26:02 - we would write down a series of points
26:04 - so for example x1 y1 x2 y2 x3 x3 y3
26:11 - and then what you would do is you would
26:12 - instruct the computer to draw say lines
26:15 - of a particular color between these
26:17 - points and as you can see the benefit of
26:20 - doing this is that the actual work of
26:22 - figuring out the scaling and resolution
26:24 - and how to render it on a particular
26:26 - device screen uh it's done on the fly
26:29 - and it's independent of a finite set of
26:32 - pixels so that's a big fancy way of
26:35 - saying it makes it scalable it's
26:37 - basically like saying hey here's what i
26:38 - want you to draw and then the computer
26:41 - basically figures out the mathematics of
26:43 - doing all the scaling and stuff like
26:44 - that
26:45 - the end result is that you get images
26:48 - one image file which can be rendered for
26:51 - basically
26:52 - almost any kind of screen size or zoom
26:54 - level or things like that
26:56 - the vector graphic we'll be creating
26:58 - today forms the basis of the rocket ship
27:00 - animation in my jetpack notes android
27:03 - architecture components application
27:05 - so just an important thing to point out
27:07 - notice how this animation scales really
27:10 - quickly and easily to a variety of
27:13 - different
27:14 - screen sizes as you can see here
27:17 - and so what i'll do is i'll show you
27:19 - where i got the basis of this particular
27:21 - image from
27:26 - please visit the repository link down in
27:30 - the description box below clone the
27:32 - application and in this application
27:34 - you're going to find a png image file
27:37 - which is of course a raster
27:39 - graphic type file
27:41 - and what i'd like you to do is go ahead
27:43 - and download that repository and this is
27:45 - the file that will be basically turning
27:48 - into a vector drawable so you don't have
27:51 - to download it from say open clipart
27:54 - so if you happen to have a more
27:56 - all-encompassing video editing software
27:58 - tool like photoshop or something like
28:00 - that chances are it does have the option
28:02 - to export from say a bitmap or png
28:06 - to an svg file
28:08 - or some other kind of vector drawable
28:11 - if you have that option do export to svg
28:14 - and you can basically skip this part of
28:15 - the tutorial i'm going to be using
28:17 - inkscape and the reason for that is
28:20 - does not actually allow you to export to
28:22 - svg
28:23 - inkscape is a free open source software
28:26 - so that's why i chose it in particular
28:28 - but you can use whatever you prefer to
28:31 - create your vector drawable
28:33 - so what you want to do is go ahead and
28:34 - open up the particular png file rocket
28:37 - underscore one dot png from the
28:39 - repository
28:41 - and you're going to need to select it so
28:43 - click on it and hit control a
28:45 - and then go to path
28:48 - trace bitmap
28:50 - now there's a couple different options
28:52 - you can select here you're going to of
28:53 - course want to pick the option which
28:56 - renders your image
28:58 - as you prefer i'm going to select colors
29:01 - like so
29:02 - and as you can see here that looks about
29:03 - right i'm also going to click remove
29:05 - background
29:06 - and then we'll hit ok to actually
29:08 - execute the trace and looks like it has
29:11 - worked
29:12 - and now we have our traced out svg
29:16 - uh file going on here our collection of
29:18 - paths
29:19 - and the last thing we need to do is go
29:21 - to file
29:22 - save as and you can just save it right
29:25 - into the same drawable folder that you
29:26 - grab the png file from i'm going to name
29:29 - it the same thing just make sure that
29:31 - for the save as type thing you have
29:32 - selected here you're going to want to
29:34 - pick inkscape svg
29:37 - all right so we've created our svg file
29:39 - through
29:40 - inkscape but as you can see here
29:43 - it has a whole bunch of metadata and
29:45 - crap in here that we don't actually
29:47 - really want to include in the thing that
29:49 - we'll be using in our project so what
29:51 - we're going to do is you can just go
29:53 - right click on resources or drawable
29:55 - select new
29:57 - vector asset like so
30:00 - so uh just a quick little tip here if
30:03 - you in the asset type field here if you
30:05 - select clipart and then you can and then
30:08 - click on this clip art icon here
30:11 - you can actually select from a whole
30:13 - bunch of pre-made icons and then create
30:15 - vector assets in android studio out of
30:17 - those as well so just a quick little tip
30:20 - you don't have to go to the website and
30:21 - download these assets you can
30:23 - do it right here and this is far more
30:25 - efficient
30:26 - anyways we're going to go to local file
30:29 - and so go ahead and give the thing an
30:31 - appropriate name so i'm going to call
30:32 - this
30:33 - we'll call it i am for image and we'll
30:36 - call it what was it called uh
30:38 - let's say rocket
30:40 - one for example
30:42 - and then we need to of course select it
30:44 - uh find it in the path
30:47 - variable here
30:48 - so we're going to select rocket 1 svg
30:51 - like so
30:52 - this particular size variable can be
30:54 - easily changed and it's not actually
30:56 - that important i do like to leave the
30:58 - opacity on 86 percent especially in like
31:01 - a dark themed application like this one
31:03 - so i'm going to leave that
31:06 - at where it is and we can basically just
31:08 - leave all of these different defaults
31:09 - here
31:10 - once that is selected we're just going
31:12 - to hit next i'll pull this into view
31:16 - and it's going to tell us that the
31:17 - output directory is going straight into
31:19 - drawable that's totally fine res main is
31:22 - fine and go ahead and hit finish
31:26 - so what that has done is as you can see
31:28 - down here that's created a new uh
31:32 - drawable
31:33 - this one's called ic rocket one i
31:34 - thought i typed i am rocket one but i'm
31:37 - i'm totally confused now anyways uh so
31:40 - what you can do is go ahead and open up
31:41 - this thing and just notice that it's
31:43 - also an xml
31:45 - vector drawable file but it's just a
31:48 - little more purpose-built for android we
31:50 - have our android variables in here and
31:52 - that's basically all we need to do to
31:54 - import our svg drawable
31:57 - into android studio and then now what we
32:00 - can do is we can just refer to this
32:01 - particular xml file like any other kind
32:04 - of drawable and it should show up uh
32:07 - appropriately
32:08 - so one of the easiest ways of thinking
32:10 - of and designing animations is just to
32:13 - suppose that we have a series of still
32:16 - images
32:17 - being looped through over time kind of
32:20 - like a projector with a film reel if you
32:22 - ever go to the movies
32:24 - so uh what we're going to do is we're
32:25 - going to create an animation list xml
32:28 - file it's going to be super easy and in
32:30 - this list we'll supply a series of
32:32 - different
32:33 - drawables to animate through and that's
32:35 - kind of how we'll actually create the
32:37 - animation effect
32:38 - so in android studio what i'd like you
32:40 - to do is you're going to right click on
32:42 - the drawable folder go to new drawable
32:45 - resource file and what we're going to do
32:47 - is we're going to call this thing
32:49 - rocket
32:50 - loop
32:51 - 2 i'm going to call it that because
32:53 - there's already a file called rocket
32:54 - loop and you can leave the qualifiers in
32:58 - that as defaults
33:00 - so the first thing i'm going to do is
33:01 - i'm going to
33:03 - change this to an animation list
33:05 - as you can see here
33:07 - and then in this animation list is where
33:09 - we will supply the different drawables
33:11 - that we want to
33:13 - loop through so we're going to create
33:14 - items and we're going to say item
33:17 - android drawable
33:19 - and so what we're going to do
33:21 - is i'm not going to show you the whole
33:23 - process of creating all three different
33:26 - drawables but what we want to do is we
33:28 - want to supply our scalable vector
33:31 - graphics here so the thing we had was i
33:34 - am
33:34 - actually got turned into ic rocket
33:38 - one
33:40 - and what we'll do so that's the one we
33:42 - created in this tutorial i'm actually
33:44 - just going to change this back to the
33:45 - default so this is i am rocket one and
33:48 - you can do this too if you downloaded
33:49 - the repository or you can use the ic
33:52 - rocket one i don't really care
33:54 - and then what we're going to do so we've
33:56 - supplied a particular drawable then we
33:58 - want to supply a duration in this case
34:00 - so i'm going to type 200 which is about
34:03 - a fifth of a second so this is going to
34:05 - be a pretty quick animation
34:08 - and then we can go ahead and close off
34:10 - that particular
34:11 - xml tag there i'm going to click at the
34:13 - end here and hit ctrl d twice
34:16 - and that's just going to copy to the
34:17 - next line and then of course we're going
34:19 - to add i am rocket
34:22 - 2
34:24 - and then i am rocket 3
34:27 - like so
34:28 - and that is it for our animation list so
34:31 - go ahead and create that and then
34:33 - finally we'll look at how to actually
34:35 - access this thing in the code
34:37 - all right so i've opened up fragment
34:39 - note detail xml which is the thing i
34:41 - demoed earlier and so what you can do
34:44 - here is uh using either
34:46 - an image button or in this case an image
34:49 - view you're going to want to specify the
34:52 - source of this particular
34:54 - uh view as being the animation not of
34:58 - course the drawables so go ahead and do
35:00 - that and then what i'll do next is i'll
35:02 - show you how to actually get hold of
35:05 - this thing and start the animation in
35:07 - the
35:08 - java or kotlin code
35:10 - alright so i've opened up note detail
35:12 - view which is in the repository and what
35:15 - we'll do now is we'll see how to
35:16 - actually start our animation list going
35:20 - so uh just a quick note here if you're
35:21 - wondering why there isn't any fine view
35:23 - by id or anything like that going on in
35:25 - this particular file it's because i'm
35:27 - using kotlin synthetic properties for
35:29 - the user interface
35:31 - but in any case however you prefer to
35:34 - get a hold of the particular views in
35:36 - xml you're going to want to do that if
35:38 - you have to use find view by id that's
35:40 - fine
35:41 - so what i'm going to do is i'm going to
35:42 - scroll down to the
35:44 - function where we actually start this
35:46 - animation drawable i'm just going to
35:47 - give us some more
35:51 - room here
35:52 - so the way that we actually start these
35:54 - drawables going is you're going to want
35:56 - to get a hold of the actual view
35:59 - uh which possesses the animation and
36:01 - then you're going to get a hold of the
36:02 - drawable so you could say say in java
36:05 - imv imb no detail satellite dot get
36:08 - drawable or something like that
36:10 - you're going to want to cast it to an
36:13 - animation drawable this is how we do
36:14 - casting in kotlin and then the function
36:17 - we want to call is start
36:19 - so what that's going to do is in this
36:21 - particular case that's going to start
36:23 - our
36:24 - animation here going now in this
36:26 - particular feature of the application uh
36:28 - the animation just runs uh permanently
36:31 - just as a little visual ui effect so
36:34 - i'll show you a few other little options
36:36 - for these particular animation list
36:37 - drawables
36:39 - okay so what i've done is i've opened up
36:41 - note list view which has a few more
36:43 - things going on with these particular
36:44 - animation list drawables or animation
36:47 - drawables rather
36:48 - so uh first off i've showed you how to
36:50 - start
36:52 - just a plain animation there are other
36:54 - animations in this uh particular
36:56 - application so there's actually a
36:58 - background space animation which is
37:00 - always looping and one thing in
37:02 - particular i do with that and i've
37:04 - actually just added this into an
37:06 - extension function in kotlin so i'll
37:07 - show you what it does
37:09 - so basically if you want to specify say
37:12 - a fade
37:13 - animation then you're going to want to
37:15 - set the enter fade duration set x at
37:18 - fade duration and then that'll allow you
37:20 - to fade between the particular drawables
37:22 - we don't need to do that with the rocket
37:24 - ship animation but it works nicely with
37:26 - our space loop animation
37:28 - and then of course we call start to
37:30 - actually get it animating now in this
37:32 - particular feature depending on what
37:34 - goes on we do need to actually stop the
37:37 - animation so when you want to do that
37:39 - again you're going to want to cast the
37:41 - drawable of the view that possesses the
37:43 - animation and then you just want to call
37:46 - stop as we see here so that's basically
37:49 - it
37:52 - so what we're going to do is we are
37:54 - going to build the login form of the
37:57 - space notes application
37:59 - quite specifically we're going to be
38:01 - building this layout
38:04 - and the purpose here is to teach you
38:06 - some of the basics of applying some
38:08 - principles of material design
38:11 - and also the basics of using the
38:13 - constraint layout effectively because
38:16 - one of the things with the constraint
38:17 - layout is that uh there's a way you can
38:19 - work with the tool in the design editor
38:22 - where you're clicking dragging like 50
38:24 - different constraints and attaching all
38:26 - these things together and then
38:28 - more recently they've added some
38:30 - features where we can streamline a lot
38:32 - of a lot of that process so that'll be
38:34 - the main focus of today's video also
38:37 - talk a little bit about uh styles and a
38:40 - couple different things like that but
38:41 - yeah let's get started
38:43 - so before we build the layout itself i
38:45 - wanted to talk about some styles and
38:47 - resources that we'll be using so we will
38:49 - be using animation drawables for the
38:51 - animated background the space animation
38:54 - and also for the antenna animation
38:57 - and we'll also be using some vector
38:59 - drawables for our icons and also the
39:02 - antenna animation so if you're not
39:04 - familiar with those topics what i'm
39:06 - going to suggest you do is head over to
39:08 - the previous video in this series number
39:11 - three
39:12 - because in that video i cover how to
39:14 - create uh vector drawables and animation
39:17 - lists
39:18 - and how to do that with totally free
39:19 - tools and if you're curious about what a
39:22 - vector
39:23 - drawable is
39:24 - uh just go watch that video but
39:26 - understand it's uh you don't necessarily
39:28 - want to use them everywhere but the
39:30 - benefit of using them is that you can
39:32 - have one file which scales to multiple
39:35 - different resolutions as opposed to
39:37 - having to supply images for each
39:40 - particular resolution so definitely
39:42 - consider checking that out but what i'm
39:44 - going to ask you to do now is in the
39:46 - description box below
39:48 - there is a repository a link to the
39:50 - repository that'll be which contains the
39:53 - code that we'll be working with
39:54 - so hopefully you've already done this
39:57 - before but if you haven't and you're
39:58 - just jumping into this tutorial series
40:00 - go ahead and clone or download
40:02 - that code because that will be the basis
40:04 - from which we uh work from we'll also be
40:06 - using some styles which are located in
40:08 - the view styles xml file so the purpose
40:11 - there is just to remove some redundant
40:13 - xml attributes and try to get it so that
40:16 - if i need to change something i'm only
40:18 - changing it in one place i won't be
40:20 - going into detail about that in this
40:21 - particular tutorial but do consider
40:24 - checking that out because as you'll see
40:25 - we'll be adding some styles
40:27 - to our layout files for that purpose
40:30 - all right so the file that we're going
40:32 - to be rebuilding specifically is
40:34 - fragment login so hopefully at this
40:36 - point you have downloaded or cloned the
40:38 - repository if not you can of course
40:40 - still follow along with what i'm doing
40:42 - here
40:43 - so uh yeah as i say we're going to be
40:44 - rebuilding fragment login and in order
40:47 - to have the code easy for you to
40:48 - reference just go ahead and right click
40:50 - on the layout
40:51 - folder go to new layout resource file
40:53 - and we're going to create a new one
40:54 - called fragment
40:57 - underscore login underscore demo like so
41:00 - and go ahead and set the root element as
41:03 - a constraint layout there's a couple
41:05 - different options here so just make sure
41:06 - you select the constraint layout but if
41:08 - you have to change it later that's fine
41:09 - too
41:11 - there we are
41:13 - and we are ready to get started
41:15 - so first thing let's go ahead and give
41:17 - it an id here so i'm going to type id at
41:20 - plus id and this one's going to be
41:22 - called root
41:23 - fragment
41:24 - login
41:26 - just be aware there's going to be some
41:27 - overwrites here because we have the same
41:29 - layout in a different file but that
41:31 - should make things a little bit easier
41:32 - in terms of auto complete
41:34 - so yeah we've added an id to that layout
41:36 - and then the next thing we're going to
41:37 - want to do is set the background
41:40 - like so
41:41 - so the specific background we're going
41:43 - to be using is called space loop like i
41:46 - said before if you want a detailed
41:48 - explanation of how to set these things
41:49 - up you can you're going to want to watch
41:50 - the previous video but let me just open
41:52 - up space loop really quickly here so
41:54 - that was just ctrl shift n to open a
41:56 - file
41:58 - and this is basically what it looks like
41:59 - here so as you can see we've got a
42:01 - couple different drawables
42:03 - uh the root tag is animation list and
42:05 - the duration is basically
42:07 - uh it's going to loop through these
42:10 - animations kind of gradually this will
42:12 - be a like a two second delay and these
42:15 - drawables just are so you're aware
42:17 - these ones are going to be
42:20 - png files whereas we'll see with the
42:22 - icon animation they are actually vector
42:25 - drawables so anyways
42:27 - so what i'll do next is i'm going to
42:29 - click on this image button and just
42:31 - click and drag it into the top left
42:33 - corner of the screen like so
42:36 - this is going to open up a dialog to
42:37 - select some kind of resource so you can
42:40 - select some
42:41 - kind of pre-made resources that they
42:43 - provide for you for different uh
42:46 - just like kind of placeholders and icons
42:50 - and all kinds of different things in
42:51 - this particular case uh we also have
42:53 - these really horrendously weird looking
42:56 - avatars
42:58 - i have a specific file in mind which
42:59 - i've added ahead of time so the drawable
43:02 - we'll be using in this case is in the
43:04 - project tab and we're just going to
43:06 - navigate to
43:08 - let's see here this is going to be
43:10 - i see arrow back black like so so i'm
43:13 - just going to click on that it's not
43:14 - actually black as you can see here but
43:16 - that's fine so i'm just going to click
43:18 - on that and hit the ok button
43:20 - and that has added in this particular
43:22 - image button drawable
43:25 - so what we're going to do first is i'm
43:27 - going to show you
43:28 - one of the ways to kind of manually set
43:30 - the constraints for a constraint layout
43:32 - and then for the rest of this particular
43:34 - layout we'll see a way to do it way
43:36 - quicker that works in certain situations
43:39 - so the first thing i'm going to want to
43:40 - do is now that i've dragged this thing
43:42 - into a particular area of the screen i'm
43:44 - going to want to basically constrain the
43:47 - top
43:48 - of this view to the parent top so i'm
43:50 - just going to click and drag
43:52 - and then kind of bring it to the top of
43:55 - the screen here can't really see what's
43:57 - going on in this editor so let me switch
43:58 - to the blueprint editor here and i'm
44:00 - going to click and drag to the left side
44:02 - of the screen
44:04 - and as you can see that has constrained
44:05 - our back button like so
44:08 - and what i'm going to want to do is i'm
44:10 - just going to want to play with the
44:12 - margins a little bit i think i'm going
44:14 - to do 16 by 16 for the margins uh sorry
44:18 - for the very crowded screen
44:20 - so um we're almost done with the image
44:23 - button
44:24 - and this is going to be like our back
44:26 - button here but one thing i wanted to do
44:28 - is i want to make it so that it it's
44:31 - actually styled like a toolbar button
44:33 - since we're kind of doing a custom
44:34 - toolbar so one of the hacky but totally
44:38 - legitimate ways i do that is i type
44:40 - style
44:42 - so this isn't actually a style which i
44:44 - created i'm just going to type at style
44:47 - slash widget
44:49 - dot
44:50 - app compat
44:52 - and then we're going to select action
44:53 - button so that's going to do a couple of
44:55 - things it's going to remove that ugly
44:57 - sort of
44:58 - dark gray background it's also going to
45:00 - add things like
45:03 - an animation when the image is clicked
45:05 - and things like that so it's just going
45:06 - to add a bunch of styling information
45:08 - and i do recommend that you do that now
45:11 - in the text editor we're also going to
45:12 - want to rename this view so i'm going to
45:14 - call this thing imb toolbar
45:17 - back like so
45:19 - and that's basically all we need to do
45:20 - here so one quick point you'll notice
45:22 - that here
45:24 - android studio has automatically added
45:26 - this source compat
45:29 - attribute here so this is because we're
45:31 - dealing with uh vector drawables so just
45:34 - uh one quick thing to point out here if
45:37 - you're basically targeting applications
45:40 - on api lower than 21
45:43 - then this thing isn't actually going to
45:44 - work properly with all views and i'm not
45:47 - sure if it actually is back ported to
45:48 - everything but if you're using vector
45:51 - drawables you're going to want to go to
45:53 - your app level build gradle file or
45:55 - module level build gradle file whatever
45:57 - you've called it you're going to want to
45:58 - add in this vectordrawables equals or
46:01 - vectordrawables.use support library
46:03 - thing into your build gradle file now in
46:06 - this case because we are only targeting
46:08 - api 21 and above i don't think that's
46:10 - actually necessary but just for
46:12 - backwards compatibility i wanted to
46:14 - mention that
46:15 - okay so what we're going to do next is
46:17 - we're going to add a whole bunch of
46:18 - different views to the layout
46:21 - and we're not actually going to manually
46:23 - set the constraints because that can be
46:25 - quite tedious and instead we're going to
46:27 - use one of the helpers in order to do
46:30 - that for us but before i worry about the
46:32 - constraints we're just going to add the
46:34 - views into the layout set the ids add a
46:37 - little bit of design time attributes so
46:39 - we can get a rough idea of what it'll
46:41 - look like and then we'll figure out how
46:42 - to do the constraints
46:44 - so i'm going to open up the palette
46:47 - and so we'll start with a couple
46:48 - different things here so first and
46:50 - foremost i'm going to want a
46:53 - text view
46:55 - and so our goal here uh basically when
46:57 - we click and drag these into the design
46:59 - time editor here
47:01 - they're not constrained but they're
47:02 - going to set like an absolute value of
47:05 - where they're positioned so i just want
47:07 - to kind of roughly position them where i
47:10 - think i want them to go and that should
47:12 - be adequate so we have
47:15 - our first sort of login status drawable
47:17 - then we're going to add in
47:19 - this is going to be an image view so
47:21 - we'll go to common
47:24 - and it's of course going to take us
47:25 - through the dialogue here
47:27 - so what we're going to do for this
47:29 - particular image view
47:30 - is it's going to be
47:32 - antenna loop is the drawable that we're
47:35 - looking for so again this is actually an
47:37 - animation
47:39 - animation list in resources
47:42 - and so i don't really want it there
47:43 - let's just kind of position it right
47:45 - there
47:46 - and we'll have to fiddle around a little
47:48 - bit with some of the attributes in a
47:49 - minute so i've got that thing positioned
47:51 - there
47:52 - and then we have another text view below
47:54 - that so i'm just going to click and drag
47:57 - i know this isn't super visible it's
47:58 - okay we'll figure that out in a minute
48:01 - all right so we've got that text view
48:02 - and then finally there's a button so
48:04 - we're just going to click and drag that
48:05 - down to the bottom
48:08 - and there we go so as you can see we
48:10 - have a basic
48:11 - setup but everything is really ugly so
48:13 - the next thing we'll do is we're going
48:15 - to hop into the text editor and then
48:17 - just set a couple of things
48:19 - very often what i'll do is i'll spend
48:21 - most of my time in the text editor but
48:23 - when it comes to like setting up the
48:24 - actual constraints then oftentimes i
48:26 - find it easier to do it in the design
48:28 - editor so the first thing i'm going to
48:30 - do is i'm just going to fix all the
48:31 - different
48:33 - generated ids
48:35 - so using uh whatever convention you like
48:38 - as you can see i have some habits of
48:40 - mine from other platforms but we're
48:42 - going to type
48:43 - lbl
48:45 - this one's going to be called login
48:47 - status header
48:50 - then we have our image view so i don't
48:53 - want this thing to be wrap content wrap
48:55 - content this thing's actually going to
48:56 - be 128
48:58 - dip
49:01 - anyways we can fiddle with that in a
49:02 - minute uh for its id that's going to be
49:05 - imb
49:06 - antenna animation like so
49:10 - so i'm trying to find an adequate zoom
49:11 - level here that's not too obnoxious
49:14 - and uh yeah then we've got our text view
49:17 - so this one is going to be called
49:21 - lbl login
49:23 - oops login status display
49:26 - and then we have our button at the
49:29 - bottom so this one is going to be called
49:31 - btn
49:33 - auth attempt so you don't have to use my
49:36 - particular convention for naming these
49:37 - ids but i do suggest you use a
49:40 - convention
49:41 - i'll probably end up switching to camel
49:44 - case for these because using
49:47 - kotlin synthetic properties
49:49 - i end up having to have this ugly
49:51 - underscore case in my kotlin code so
49:55 - just something to consider all right so
49:57 - i wanted to set the ids in particular
49:59 - before we go messing around here with
50:01 - the uh constraint layout editor
50:04 - because uh once the constraints are set
50:06 - you need to mess around with the ids
50:08 - afterwards if you change them so now
50:10 - that we've got that set let's hop in
50:12 - back into the design time editor
50:15 - and so in this case uh i see that
50:18 - the image view has gotten positioned a
50:20 - little bit weirdly so i'm just going to
50:22 - again kind of manually position these
50:24 - things where i think i want them
50:29 - something about like that
50:32 - and then what i'm gonna do is i'm going
50:34 - to switch to the
50:37 - blueprint editor here
50:39 - just so we can have a pretty clear view
50:40 - of what's going on
50:42 - and then what we'll do is so i'm going
50:44 - to click on each of these views and
50:47 - holding shift
50:49 - i'm going to select all of them
50:51 - alright once we have everything selected
50:53 - just right click on one of the views and
50:55 - go to chains and then we're going to
50:57 - create a vertical chain
51:00 - so what that's done for us is it's
51:01 - basically constrained all of these views
51:04 - to each other and the parent as you can
51:06 - see in this sort of chain
51:08 - so let's just hop back into the design
51:11 - editor for a minute so as you can see we
51:13 - have everything kind of aligned
51:15 - horizontally the way we want but the
51:17 - actual spacing here is pretty ridiculous
51:19 - so what we're going to do is we're just
51:21 - going to click on this little chain icon
51:23 - here and this is going to change the
51:25 - type of chain so there's a couple
51:28 - different options there is let me just
51:30 - grab my notes
51:34 - so there's going to be spread inside
51:36 - spread
51:37 - and packed in this particular case we're
51:40 - probably going to want packed i think
51:45 - that's not it
51:46 - there we go something like that
51:48 - okay so we've got these views roughly
51:50 - where we want them what i'll do next is
51:52 - i'm just going to select each of them
51:53 - and then we're going to constrain them
51:56 - horizontally so again just click and
51:58 - holding shift select all of them this
52:01 - can be a little bit tricky with
52:03 - these buttons popping up just be aware
52:04 - that
52:05 - and then once we have these things
52:07 - selected i'm just going to right click
52:08 - on them and then we're going to go to
52:10 - center
52:11 - and then we're going to select
52:13 - horizontally
52:14 - and what that's going to do is it's
52:15 - going to horizontally constrain all of
52:18 - those views and as i said before this is
52:20 - a lot quicker than having to do this
52:21 - manually that's how i used to do it and
52:24 - it works but it's kind of tedious so one
52:26 - of the main takeaways here is just learn
52:29 - a little bit about these different
52:30 - options that they provide you in the
52:31 - editor and see if you can use them to
52:34 - expedite the process of building your
52:36 - layouts a little bit quicker
52:38 - okay so we've got everything roughly
52:40 - where we want it to go so the last thing
52:42 - we'll do is we'll play around with some
52:43 - of the specifics here just to get a more
52:45 - material design and stylish look
52:48 - so up here we can probably add some
52:50 - design time text to this particular
52:54 - view
52:55 - actually this thing i believe is always
52:56 - login status
52:59 - so we'll just set it to that
53:02 - and looks like that thing needs a little
53:04 - this bit of styling so i'm going to type
53:06 - style
53:07 - and we're going to use yeah that's the
53:09 - one
53:10 - text.primary.login header
53:12 - and that should just give it a larger
53:13 - font size as you can see here
53:15 - it's looking a little bit better
53:17 - uh we'll move down to the image view
53:19 - and for the image view it's already
53:22 - pretty close to being good to go
53:24 - one important thing if i wanted to
53:26 - support
53:27 - tablets and things like that i would
53:28 - probably not want to actually hard code
53:30 - these layout height and width
53:33 - values instead i would want to provide
53:34 - them in resources but like i say we're
53:36 - skipping a couple of things here for the
53:38 - sake of the tutorial
53:40 - anyways
53:41 - so what we want to change here is that
53:43 - uh the sizing is all good but we would
53:46 - prefer a white drawable in this
53:49 - particular case on the dark background
53:51 - so i'm going to type android tint and
53:55 - we're just going to
53:56 - hard code in
54:00 - ffff6fs which is the hex code for
54:05 - white and as you can see here that's
54:07 - looking like that so let's move to the
54:09 - next text view below
54:12 - so this one the text changes frequently
54:15 - i'm just going to type tools text
54:17 - instead
54:18 - and so we're going to type signed
54:21 - in as one particular example status
54:24 - and then we also have some styling for
54:26 - this view so this one is i believe
54:28 - text.primary.loginheader.sub
54:34 - yep that's looking a little bit better
54:36 - and finally let's head down to our
54:38 - button
54:39 - so i've made another special style
54:41 - attribute for this thing which is going
54:43 - to be style slash off button
54:46 - and this is the button that i actually
54:47 - used to trigger the google sign-in so
54:50 - anyways the text for this particular
54:51 - button is going to be
54:54 - uh it changes frequently at run time but
54:56 - we're just going to type tools
54:59 - text and then we're going to type sign
55:02 - out
55:03 - like so and let's just have a quick look
55:06 - at what that looks like
55:09 - all right
55:10 - not looking bad
55:14 - so that's basically it for the xml stuff
55:16 - here as far as the layout is concerned i
55:18 - know earlier i mentioned i wouldn't go
55:20 - into detail about the styles but i
55:22 - thought i would just show you a little
55:23 - bit about this particular file
55:26 - viewstyles.xml and so one of the biggest
55:29 - tips i can give you in terms of giving
55:32 - like a nice material design look to your
55:34 - application
55:35 - um use the sans serif
55:38 - uh
55:39 - font families and that'll give you some
55:42 - nice roboto fonts and then also the
55:45 - different sizes that i use to basically
55:47 - come from the android material design
55:49 - documentation so well the google's
55:52 - material design documentation rather so
55:54 - i do highly suggest you check that out
55:56 - and just try to follow what they
55:57 - recommend as best as you can but also
56:00 - you know feel free to take some creative
56:01 - license over what you do as well
56:04 - also one quick point with uh styles that
56:06 - you can actually use them
56:09 - like
56:09 - in sort of a css way so you can
56:12 - overwrite different values but also
56:14 - inherit from parents and and stuff like
56:16 - that and i use that quite frequently
56:21 - and in today's video i'm going to be
56:23 - showing you how to set up the navigation
56:25 - component from android jetpack so
56:28 - firstly as of making this video the
56:30 - navigation component does not work out
56:32 - of the box with on activity result i did
56:35 - see a couple people had some really
56:37 - hacky shared mutable state solutions for
56:40 - solving this problem but i wouldn't
56:42 - actually recommend them when it's
56:44 - actually easier to just
56:46 - not use the library in the activity
56:49 - which receives the result which is what
56:50 - i chose to do in this particular
56:52 - application
56:53 - so that's kind of one of my criticisms
56:55 - here is there's kind of a strong push to
56:57 - move to a single activity approach and
56:59 - this was one case where i wanted to do
57:02 - that and couldn't based on framework
57:04 - limitations
57:05 - now like i say as i'm making this video
57:07 - i have seen that there's some discussion
57:09 - about adding integration
57:11 - with navigation and on activity result
57:13 - possibly in later versions although it
57:15 - doesn't appear to be a very high
57:16 - priority anyways in fairness if you're
57:19 - watching this video several months or
57:21 - even years from now there's a chance
57:23 - that it has been integrated with the
57:25 - library and if that's the case then that
57:27 - would make me very happy i was also told
57:29 - recently by a friend of mine davora
57:31 - maric who's an awesome programmer that
57:33 - navigation does not play nice with few
57:35 - pagers and fragments so another thing to
57:37 - be aware of
57:38 - so while i'm not really happy about some
57:41 - pretty common use cases having some
57:43 - problems with the library
57:45 - i think those are things which hopefully
57:47 - will be improved on over time so let me
57:50 - get to the second reason why i'm not
57:51 - super happy with the library
57:53 - so
57:54 - i just didn't really feel like the steps
57:57 - required to implement navigation and the
57:59 - fact that we're basically pulling logic
58:01 - out of kotlin code or java code and
58:03 - putting it back into xml
58:06 - was really worth the effort of setting
58:08 - up relative to the problems that it
58:10 - actually actually solved in my
58:12 - applications
58:13 - so what i'm basically saying here is uh
58:15 - what this library will do for you is
58:17 - it'll allow you to basically get rid of
58:19 - some of the fragment transaction or
58:22 - start activity type logic which you
58:25 - would normally use to navigate to
58:26 - different screens in your application
58:28 - and so it's not that we're actually just
58:30 - getting rid of all of that logic in a
58:33 - sense we're basically pulling a bunch of
58:34 - it out into an xml file and then we're
58:37 - having this framework generate a lot of
58:39 - that logic for us
58:41 - now if you get fast enough with the
58:43 - visual editor and you're familiar with
58:45 - all of the features you can actually
58:47 - write this logic pretty quickly using
58:49 - the tool but i just wanted to mention
58:51 - that relative to say handwriting this
58:54 - code with kotlin extensions or something
58:55 - like that i didn't feel like i saved
58:58 - much time okay so with all that
59:00 - criticism in mind and let's just keep in
59:02 - mind this is a fairly new tool i did
59:05 - like the navigation feature in the parts
59:07 - of the app where it didn't cause any
59:09 - problems it worked quite well in that
59:11 - regard in particular i do like the say
59:14 - fargs option for basically sending type
59:16 - safe arguments between different screens
59:19 - of your application and i will be
59:21 - demonstrating that feature today finally
59:23 - if you'd like to follow along with this
59:25 - tutorial please clone or download the
59:27 - repository link in the description box
59:29 - down below
59:31 - okay so the first thing we'll do is
59:32 - we'll look at configuring this thing
59:34 - with gradle
59:35 - so
59:36 - in your build script function here in
59:39 - your project level build gradle file
59:42 - we need to add a particular
59:43 - configuration to the build script
59:45 - dependencies in particular we need to
59:47 - add this thing here android x dot
59:49 - navigation colon navigation safehargs
59:52 - blah blah blah
59:54 - and once you add this thing in uh that's
59:56 - going to allow you to use the safe arcs
59:58 - plugin and what we'll do next is we'll
60:00 - see how to add that to the module level
60:02 - build gradle file in the module level
60:04 - build gradle file you're going to want
60:06 - to add up at the top here apply plugin
60:09 - androidx.navigation.safeargs.kotlin
60:12 - now if you're in java you're going to
60:14 - want to probably delete the dot kotlin
60:16 - and i think that's the appropriate
60:18 - plugin for java
60:19 - anyways uh down in the dependencies the
60:21 - two dependencies that we'll really be
60:23 - working with are the
60:26 - navigation that fragment dash ktx and
60:29 - the navigation dash ui
60:31 - ktx so again i think if you're working
60:34 - with java or something like that you
60:35 - just delete the dash ktx and it'll work
60:37 - work for you but there is a page where
60:40 - you can figure out the particular
60:41 - dependencies so just go check that out
60:43 - in the android documentation okay so
60:45 - let's get started building out the
60:47 - navigation component so the first thing
60:49 - we're going to need is a navigation
60:51 - graph and this is basically like an xml
60:53 - resource which specifies all the
60:55 - different destinations which our
60:57 - navigation component can travel to along
61:00 - with plenty of other details
61:02 - so what i'd like you to do so presumably
61:04 - you have downloaded the repository so go
61:07 - ahead and in the res navigation
61:09 - directory just notice we have this file
61:12 - nav graph which is what we will be
61:14 - building
61:15 - what we'll do is we'll create another
61:17 - file
61:18 - so i'm just going to right click on
61:19 - navigation we'll go to navigation
61:21 - resource file we're going to call this
61:23 - nav
61:24 - graph demo you can call it whatever you
61:27 - like
61:28 - and so what we'll do is we'll basically
61:30 - rebuild this nav graph file over here
61:33 - and i just want to have it there so that
61:34 - you can reference it so here we have the
61:37 - navigation editor so we've got a couple
61:40 - different things here on the side panel
61:41 - we have this destinations tab here and
61:44 - as you can see we don't currently have
61:46 - any destinations and no nav host
61:49 - fragments is found so we can go ahead
61:51 - and ignore that for a minute and what
61:52 - i'd like you to do is uh we've got this
61:55 - new destination button up here so go
61:58 - ahead and click on that one and it's
62:00 - basically what we're going to do is
62:01 - we're going to add all the different uh
62:04 - fragments and or activities which we
62:06 - want to be able to navigate to and these
62:08 - things are known in this library as
62:10 - destinations obviously
62:12 - so we'll need to add the note detail
62:14 - view fragment
62:16 - then i'm just going to add in the note
62:18 - list fragment and as i mentioned before
62:20 - just due to the integration limitations
62:23 - with onactivityresult uh we're not
62:25 - actually going to jump to the login view
62:28 - which is a fragment we're actually going
62:30 - to have to jump to the login activity so
62:33 - we'll just select this option here all
62:35 - right so we've added all the different
62:36 - destinations but as you can see we have
62:38 - a little bit of work to do so the first
62:40 - thing i'm going to do is i'm basically
62:41 - just going to click and drag these
62:42 - things storyboard style and roughly
62:44 - where i want them
62:46 - so we're going to drag login activity up
62:48 - here
62:49 - and we'll
62:50 - note listview is actually kind of like
62:51 - the main
62:53 - sort of dashboard of the application and
62:55 - we'll bring note detail view down here
62:58 - and before we do anything else i just
63:00 - want to do a little bit of clean up okay
63:02 - so we've added our destinations but i
63:04 - think we need to hop into the text
63:06 - editor for a minute and just make a
63:07 - couple of adjustments
63:09 - so i'd like to be able to actually
63:10 - preview visually the screens that are
63:13 - that the application has in the each
63:16 - given destination and one of the ways we
63:18 - can do that is we can use this tools
63:21 - layout
63:22 - attribute here so for those who aren't
63:24 - aware
63:25 - the tools name space is basically like a
63:28 - design time namespace and whatever
63:31 - details you add here actually get
63:33 - stripped out of the packaged application
63:36 - so in this case we don't actually want
63:37 - to refer to the activity login layout
63:39 - because the activity login is just a
63:41 - container
63:43 - what we'll want is i believe it's called
63:44 - fragment login
63:46 - there we go
63:47 - and as you can see that should fix that
63:50 - up there we go that's exactly what i'm
63:52 - talking about there so we'll just add
63:54 - that in for the other
63:56 - fragment destinations here so in this
63:59 - one here i'll zoom in a little for
64:01 - everybody
64:02 - so on that one that's going to be
64:04 - fragment
64:06 - note detail
64:08 - and then
64:10 - up above here
64:12 - fragment note list
64:18 - all right loading
64:20 - and that's looking a lot better
64:23 - except i think i've reversed them
64:26 - okay so this is fragment no detail
64:30 - you know i could edit this out but i'm
64:31 - just going to leave this in here
64:34 - that's uh
64:36 - it's pretty spectacular ryan okay and
64:38 - let's just hop back to the design editor
64:41 - okay that looks more like it so as you
64:43 - can see it's added a two onto these
64:45 - names because we've already defined them
64:46 - in the other file but that's totally
64:48 - fine okay so the way that we actually
64:52 - kind of define how to navigate between
64:55 - these different destinations
64:57 - is by setting up actions so the way that
64:59 - you set up actions in the visual editor
65:02 - is uh you'll notice a lot like
65:03 - constraint layout each of these
65:05 - different destinations will have this
65:06 - little thing you can click on here so
65:08 - you can click and drag that to a
65:10 - particular destination
65:12 - and what that has done here is it's
65:14 - added this arrow and the arrow basically
65:17 - represents an action
65:19 - so go ahead and do that now how this
65:21 - thing basically works is that the
65:24 - note
65:26 - list view is able to jump to either the
65:28 - login activity or it's able to jump to
65:31 - the note detail activity so i'm just
65:33 - going to click there again
65:35 - come on
65:36 - there we go
65:37 - and i'm going to click and drag that to
65:39 - the note detail view now in this
65:40 - particular case once the user is done
65:42 - messing around with the note detail view
65:45 - either when they hit the delete button
65:47 - kind of hard to see but
65:49 - yeah there's either a delete or a check
65:51 - mark button there so once the user does
65:53 - that then they're basically going to
65:55 - jump back to the note list view so i'm
65:57 - going to select no detail view and then
65:59 - i'm going to click and drag this one oh
66:00 - that's not what i wanted to do and we'll
66:02 - just have it point back to the note list
66:05 - view so as you can see we've defined
66:07 - pretty much all of the different actions
66:09 - or navigation actions which we'd like
66:12 - the application to be capable of
66:14 - implementing
66:15 - uh there is one last thing we need to do
66:17 - here though well there might be a couple
66:19 - of things but what we need to do is uh
66:21 - in this particular case often what will
66:23 - happen is uh this is basically like a
66:26 - list view and oftentimes the user will
66:28 - be selecting an item in a recycler view
66:31 - here then we'll need to send the id
66:34 - of that item over to the note detail
66:36 - view and this is a very common
66:39 - pattern you'll see this all the time
66:42 - it's a lot better than actually sending
66:43 - the whole
66:45 - note item you just send the id over
66:48 - so what we can do there is we're going
66:50 - to click on the action between the note
66:53 - list destination and the note detail
66:55 - destination here
66:56 - and i'm going to click on the attributes
66:58 - panel here and what we can do is we can
67:00 - actually add some argument values
67:04 - uh to note detail view sorry don't
67:06 - actually click on the
67:08 - action here click on no detail view and
67:10 - this is where we can add arguments
67:12 - so in this tab here
67:14 - we have arguments we're just going to
67:15 - hit plus
67:17 - and so the name of this argument is
67:19 - going to be note id
67:22 - definitely try and give it a good name
67:23 - of course the inferred type is going to
67:26 - be a string sorry not the inferred type
67:29 - the type is going to be a string
67:31 - you can select inferred type but we're
67:32 - just going to use some simple data here
67:36 - and then it's not going to be nullable
67:38 - and we don't really care especially
67:40 - about a default value in this case so
67:42 - yeah just go ahead and type node id
67:44 - select uh string as a type and hit add
67:47 - and so just as a reminder to everyone
67:49 - all the stuff we're doing in the visual
67:50 - editor is basically just uh
67:54 - creating a whole bunch of boilerplate in
67:55 - the xml for us so what we can do here is
67:59 - uh now that i've added that particular
68:01 - argument to
68:03 - our note detail view
68:05 - uh it's added this little entry down
68:06 - here so that's basically all we need to
68:10 - do to actually configure this thing
68:11 - properly just one final note here up in
68:14 - the top of the navigation tab here we
68:18 - have this app start destination
68:20 - attribute so this is where you specify
68:23 - basically which particular destination
68:25 - you want to start the application from
68:27 - and in this case we don't want to start
68:29 - in note detail view
68:31 - we want to start in the note list view
68:32 - so i'm just going to type note
68:34 - list view 2 or whatever name it has and
68:37 - that'll be the starting point of the
68:39 - application now when i say starting
68:41 - point of the application that's assuming
68:43 - that your application's manifest file
68:46 - points to the activity
68:48 - which will be basically like the host
68:50 - for our navigation setup and we'll look
68:52 - at that in a moment
68:54 - okay so now that we've built out this
68:56 - particular xml file here uh what i'm
68:58 - going to suggest you do is unless you
69:00 - actually want to keep this thing just
69:02 - for notes or something like that please
69:04 - go ahead and delete this file we just
69:06 - created because we want to actually be
69:08 - using the old file just so it works well
69:10 - with everything in our application i
69:12 - just wanted to show you the actual
69:14 - process of building out the navigation
69:16 - graph using the design editor all right
69:19 - so now that we've got our navigation
69:21 - graph set up what we can do is we can
69:23 - set up our nav host fragment
69:26 - now uh again just a really quick bit of
69:28 - practical information here
69:30 - what i would suggest is
69:33 - so the one of the goals of this
69:34 - particular library is to go for a single
69:37 - activity approach i think that's totally
69:39 - great except as i mentioned before i
69:41 - literally wasn't able to do that
69:43 - due to uh library limitation but what
69:46 - i'm going to suggest to people is for
69:48 - different features of your application
69:50 - where you're running into trouble with
69:52 - this particular library my
69:54 - recommendation is to just pull that into
69:56 - a separate activity
69:58 - and you can you you can apply like a
69:59 - model view presenter or whatever to that
70:01 - particular feature of the application
70:04 - just have your navigation graph point to
70:06 - its activity instead of the fragment and
70:09 - then just do what you would normally do
70:11 - and when you need to jump back into the
70:13 - navigation graph you're of course going
70:15 - to have to start
70:17 - the uh sort of navigation host activity
70:20 - which in this case is note activity so
70:23 - anyways enough rambling let's go ahead
70:24 - and configure that node activity and so
70:27 - the node activity basically manages both
70:29 - the note detail view and the note list
70:31 - view okay so what we'll do is again
70:34 - we're going to create an extra file
70:35 - which we'll delete afterwards so just go
70:37 - ahead and right click on the layout here
70:39 - and we're going to go to new layout
70:41 - resource file
70:42 - and this file is going to be called
70:44 - activity
70:46 - note demo
70:48 - and for the root layout we're going to
70:49 - select a constraint layout
70:52 - there we go
70:55 - and that's what we'll start with here
70:57 - okay so what we need to do here is we
70:59 - need to add this thing called a nav host
71:02 - fragment
71:03 - and we could add that manually but
71:05 - there's actually a way to do it really
71:06 - quickly in the design editor so in the
71:09 - palette here just on the side
71:11 - there's the containers menu here and in
71:14 - the containers menu you're going to find
71:16 - down below this thing called nav host
71:19 - fragment so what you'll want to do is
71:21 - just click and drag this nav host
71:23 - fragment we can center it doesn't really
71:26 - especially matter here and it's going to
71:28 - give you a list of navigation graphs to
71:31 - select from of course select nav graph
71:35 - and as you can see here it's
71:38 - done most of the work for us we're just
71:39 - going to hop into the text editor
71:41 - so for the layout width we're going to
71:44 - say match parent
71:45 - same thing for the layout height
71:48 - and there's a couple other things we can
71:49 - just remove the absolute
71:52 - layout editor here so we're specifying
71:54 - the navigation graph that we built
71:57 - um we have this thing set as the default
72:00 - nav host so this is kind of like a
72:02 - default configuration which will work
72:03 - kind of easier
72:05 - and then also when we see this android
72:07 - name attribute this actually refers to
72:09 - the particular
72:10 - class name
72:12 - of whatever fragment so in this case
72:15 - just note that nav host fragment is not
72:17 - something that we are going to actually
72:19 - create we're going to use the default
72:21 - implementation and this is basically how
72:24 - we point to it up here now in this
72:26 - application we of course call this thing
72:29 - fragment
72:30 - i can't type
72:32 - fragment nav
72:34 - but yeah this is basically all the
72:35 - configuration we need to do and then
72:37 - what you can do is just go ahead and
72:38 - delete this file or keep it if you like
72:40 - okay so the next thing we need to do is
72:43 - we need to have a nav controller which
72:46 - generally speaking will be an activity
72:48 - so what we're going to do is in the note
72:51 - package of our main package here just
72:53 - open that up and so the file will be
72:56 - rebuilding it won't take long is note
72:58 - activity and again what we'll do is just
73:00 - right click on note go to new kotlin or
73:03 - java class whichever you prefer go to
73:05 - note
73:06 - active type note activity
73:09 - demo
73:10 - and don't worry about actually creating
73:11 - a proper activity and adding it to the
73:13 - manifest okay so what we'll do next is
73:15 - we'll just type class note activity demo
73:19 - and then that thing is going to extend
73:21 - app compat activity like so give it a
73:25 - constructor
73:26 - and the particular function that we're
73:28 - going to need to add in here is we'll
73:30 - need to override
73:32 - oncreate so usually it'll auto complete
73:35 - for us here let's see
73:38 - let's go with this option here
73:40 - okay
73:42 - so what we basically need to do here is
73:44 - we need a nav controller object which
73:47 - fortunately is super easy to correct or
73:50 - to create
73:51 - and what we'll basically do is when we
73:53 - need to actually perform these
73:55 - navigation operations we'll be basically
73:57 - getting a hook to this nav controller
74:00 - through the library
74:01 - so anyways what you need to do is go
74:03 - ahead and add private
74:04 - late init var
74:06 - nav
74:07 - and that's going to be of type nav
74:09 - controller
74:10 - like so
74:12 - then we need to create this nav
74:13 - controller
74:14 - so we'll say nav
74:16 - equals navigation
74:19 - dot find nav controller and what we'll
74:23 - do is we'll pass
74:24 - this for the activity and then it also
74:27 - requires a layout res id
74:30 - which is the nav host fragment and so
74:33 - the nav post fragment is basically what
74:35 - what we sort of swap the views in and
74:37 - out of so in that case that thing is
74:39 - called r dot id dot fragment
74:43 - nav like so so it's complaining that i
74:46 - need to import r but i'm just not going
74:48 - to worry about that if i hop over to
74:50 - note activity as you can see that's
74:52 - actually all we need to do
74:54 - and this was one part of setting this
74:55 - thing up that was actually like really
74:57 - quick and painless so now that we've got
75:00 - that done we can actually take a look at
75:01 - how to actually use this library in
75:04 - action
75:06 - okay so i'm going to open up a note list
75:09 - view and we'll look at some different
75:11 - ways to actually use this library to
75:13 - navigate to different
75:15 - destinations so i'm going to hit control
75:17 - n
75:18 - note
75:19 - list view
75:21 - and we'll just look at two particular
75:23 - situations here
75:25 - so in the first case we have a situation
75:28 - where we're basically just navigating to
75:32 - a particular destination without any
75:34 - arguments so there's actually a lot of
75:37 - different options we have as we can see
75:39 - for navigation so basically how this
75:43 - tool pretty much works
75:45 - is at least when we're calling it from a
75:46 - fragment here we have this find nav
75:48 - controller function
75:50 - so what happens is we call find nav
75:52 - controller and that's of course going to
75:54 - through the framework grab this thing we
75:56 - have here in the activity
75:58 - and then we can perform navigate
76:00 - operations among other things to jump to
76:03 - different destinations so this is almost
76:05 - kind of equivalent to like saying start
76:07 - activity except we're not working with
76:09 - activities here
76:11 - so i just want to bring your attention
76:12 - so if i click within the parentheses of
76:14 - this navigate function here and hit
76:16 - control p
76:18 - i just want you to notice that there are
76:19 - a lot of different options for what you
76:22 - can pass here so in a really simple case
76:24 - we basically just pass it the
76:27 - id of a particular destination so we
76:29 - have r dot id
76:31 - login view if i hop into the nav graph
76:33 - here
76:35 - just notice that if we go to this
76:36 - activity uh the id of this destination
76:39 - is login view so that's where that's
76:41 - coming from
76:42 - so that's kind of the first case now
76:44 - what about when we actually want to pass
76:46 - arguments type safe arguments to a
76:49 - particular destination and let me tell
76:51 - you this is
76:52 - one of the things
76:54 - that i actually quite like about this
76:56 - library and probably the main reason why
76:58 - i'm actually doing this video to be
76:59 - honest is the safe arguments feature
77:02 - here
77:02 - so when you want to navigate with
77:06 - arguments to a particular feature so in
77:09 - this case we want to go to the note
77:11 - detail view
77:13 - and here and we need to pass some kind
77:16 - of id to it so when we're creating a new
77:20 - note so when the user hits the create
77:22 - new this is like a floating action
77:24 - button and they want to create a new
77:25 - note then we pass just an empty note id
77:29 - and just understand that on the other
77:30 - side
77:31 - node note detail fragment and its uh
77:34 - view model is going to be aware that
77:36 - this is a new note so that's just in
77:39 - case you're wondering why we're passing
77:40 - that now what we need to do when we
77:43 - actually want to jump to a particular
77:44 - destination with arguments is we need to
77:47 - use this note list view directions dot
77:49 - action note list view to note detail
77:51 - view where the hell did that come from
77:54 - obviously we didn't write that so this
77:56 - is kind of one of the main points of
77:57 - this library is that the work you do in
77:59 - the xml
78:01 - will generate some functions like this
78:04 - that you can use to perform these
78:06 - different navigation operations so
78:08 - obviously in the simple case we can just
78:10 - call navigate in this case we need to
78:12 - use these note this note
78:13 - listviewdirections object and where this
78:16 - function came from and this uh or sorry
78:19 - where this class came from and this
78:21 - function of the class came from is based
78:23 - on some generated code from our xml
78:26 - configuration here so with that in mind
78:28 - you may need to build your project in
78:31 - order to actually create these things
78:33 - because i'm pretty sure they're made at
78:34 - compile time so in this case once we've
78:36 - created our direction and we've given it
78:38 - the particular action and the arguments
78:41 - that are required of that action and all
78:43 - of this has been generated for us then
78:45 - we pass that direction object
78:48 - to our nav controller and then that's
78:50 - how we actually get
78:52 - to the other uh fragment with the
78:54 - arguments okay so the last thing we'll
78:57 - do is we'll look at how to get the
78:58 - arguments out of our receiving
79:00 - destination which in this case is of
79:02 - course a fragment so i'm going to scroll
79:04 - down
79:05 - to the
79:07 - viewmodel.handlevent function here
79:09 - that's within onstart
79:11 - and so basically what goes on is uh we
79:14 - have this note detail view args object
79:17 - which is of course generated for us then
79:19 - we call dot from bundle and we supply
79:22 - the arguments property of this fragment
79:25 - and then where does dot note id come
79:27 - from so this is actually the name of the
79:30 - arguments that we defined in the nav
79:32 - graph as you can see here and in this
79:34 - case once we grab those arguments we
79:36 - just pass them to the view model in the
79:39 - form of a sealed event class and then
79:42 - the application figures out what to do
79:43 - from there
79:47 - and in this video i'm going to be
79:49 - talking to you
79:50 - about using fragments as views
79:54 - in model view view model architecture
79:57 - and we'll also look at how to use kotlin
79:59 - synthetic properties
80:02 - to eliminate boilerplate ui code and
80:04 - refer directly
80:06 - to xml views
80:09 - now how this is going to work is in this
80:11 - video we will write the fragment and
80:13 - then of course in the next video we will
80:16 - write the view model which our fragment
80:18 - currently talks to before we get to
80:20 - coding the fragment i just wanted to
80:21 - talk about model view view model
80:23 - architecture for a moment so as
80:25 - discussed in the second video in this
80:26 - series and you should probably go and
80:28 - watch that if you haven't and you're
80:29 - curious about this particular pattern
80:31 - there's a couple really subtle ways to
80:33 - do it differently which don't actually
80:35 - break the pattern entirely so i won't be
80:38 - going into great detail on this but
80:40 - basically what i'm saying here is the
80:41 - style of view model and view that we're
80:44 - going to be writing today
80:46 - is basically such that it allows the
80:49 - view to be very simple and easy to write
80:53 - and easy to test
80:55 - at the expense of moving a lot of the
80:56 - presentation logic of the view into the
80:59 - view model it'll basically simplify
81:01 - construction of the view but the key
81:03 - point here is the more details or the
81:04 - more presentation logic we include about
81:07 - a specific view in a view model the less
81:10 - reusable the view model becomes so what
81:14 - i'm saying here is if you have a view
81:16 - model which you plan to use for a
81:17 - variety of different
81:19 - views
81:20 - you're going to want to take the other
81:22 - approach that i discussed not the one
81:24 - where you have lots of details about the
81:26 - view in the actual view model just so
81:28 - there's no confusion about what i just
81:30 - said there let's have a quick look at
81:32 - two different view models in this
81:33 - project so the one we'll be writing
81:35 - today or sorry the one that our fragment
81:38 - that we write today we'll be talking to
81:41 - and the one we'll write in the next
81:42 - video
81:43 - is the user view model so the thing
81:45 - about this view model is in keeping with
81:48 - the pattern it does not directly
81:49 - reference any particular view however it
81:52 - does have like i said before specific
81:55 - details about a particular view so we
81:58 - see fields in here like sign in status
82:00 - text
82:01 - auth button text satellite drawable so
82:04 - as you can see this view model is going
82:06 - to work really well with a particular
82:09 - view but it's not necessarily going to
82:11 - be something that we can reuse with a
82:12 - whole bunch of different views
82:14 - when i open up note view model
82:17 - i basically you will pretty much not see
82:20 - any specific details about a particular
82:23 - view
82:24 - within reason so we're not going to see
82:26 - these show error state type functions
82:29 - we are going to see things like note was
82:31 - deleted note was updated and we'll see
82:33 - that we do actually publish a note
82:36 - object to whatever observable is or
82:38 - sorry whatever observer is listening but
82:40 - the thing about this is by taking this
82:43 - approach of having more reusable view
82:45 - models we're now relying on the fragment
82:48 - or the view
82:50 - to basically handle this presentation
82:52 - logic okay so if you would like to
82:55 - follow along with this tutorial and i do
82:57 - suggest you do if you're going to watch
82:59 - it
83:00 - then check out the description box down
83:02 - below you'll find a link to the open
83:04 - source code repository and you can
83:06 - either clone or download it
83:09 - anyways what we'll be looking at first
83:11 - is how to configure
83:13 - kotlin synthetic properties in gradle
83:16 - so the first thing you need to make sure
83:18 - is that you have the kotlin gradle
83:21 - plug-in installed
83:24 - this one here
83:25 - sorry my word wrap is going to screw it
83:27 - up so if you check marked the box that
83:30 - your project is supposed to be a kotlin
83:31 - project in android studio most likely
83:34 - you won't actually have to add this in
83:35 - manually it should be there if you've
83:37 - configured a kotlin project in a more
83:40 - recent version of android studio but i
83:42 - just want to point this out in case
83:44 - there's any confusion
83:45 - secondly one thing you probably will
83:46 - need to add is go ahead and open up the
83:49 - app level build gradle file and this is
83:52 - true for whatever module you might want
83:54 - to use
83:55 - the kotlin synthetic properties in
83:58 - you're just going to want to apply this
84:00 - particular plug-in here kotlin android
84:03 - extensions apply plug-in and that will
84:05 - allow you to use kotlin synthetic
84:07 - properties
84:08 - so the view class that we'll be writing
84:11 - today is called login view
84:14 - and i just want to make one more final
84:15 - note here
84:16 - uh there are two functions in it so in
84:19 - particular i'm talking about start sign
84:21 - and flow and on activity result and
84:23 - we're actually not going to be coding
84:25 - out those two functions and the reason
84:27 - why is that i'm going to go over those
84:28 - when i talk about implementing firebase
84:31 - with google sign in provider
84:33 - so we won't be coding these two
84:35 - functions here in this video but like i
84:37 - say we'll get to that eventually
84:39 - okay so what i would like you to do to
84:41 - get started here is you can either make
84:43 - a new file with a slightly different
84:45 - name
84:46 - for login view because that's what we'll
84:48 - be rebuilding or what you can do is you
84:50 - can just select everything under the
84:52 - package declaration here just scroll
84:54 - down
84:55 - and have a good delete and that will be
84:58 - our starting point for today's tutorial
85:01 - all right so the first thing we'll be
85:02 - doing is we'll write out the class
85:04 - declaration
85:06 - so go ahead and type class login view
85:10 - extends fragment
85:12 - like so
85:15 - just line that up a little better and of
85:17 - course we will have to import the
85:18 - appropriate library so in my case i'm
85:20 - using the android x library so go ahead
85:23 - and pick that so the next thing we'll
85:25 - need to do is we want to add a reference
85:28 - to our view model and we'll have to use
85:30 - a late in it var for that also in
85:33 - general since i don't want anything else
85:35 - kind of messing around with this
85:36 - particular reference we're going to make
85:38 - it private
85:40 - private basically just means that we can
85:42 - only see it in this particular class all
85:44 - right so when we're working with
85:46 - fragments
85:47 - we need to tell the fragment
85:51 - which layout to inflate now if you're
85:54 - using data binding there's a slightly
85:56 - different process for this but what
85:57 - we're going to do today
85:59 - is we are going to override
86:02 - the
86:03 - on
86:04 - create
86:05 - view function like so and uh really
86:09 - appreciate that autocomplete there all
86:10 - right so go ahead and select everything
86:12 - after this return statement here and
86:15 - delete that so what we're going to do
86:17 - instead is we are going to inflate a
86:19 - specific layout
86:21 - so we're going to take the past in
86:22 - inflator
86:24 - and we're going to say inflator dot
86:25 - inflate
86:27 - and the resource we're going to give it
86:28 - is we're going to point to the
86:30 - fragments layout file so we're going to
86:32 - type r
86:34 - dot layout dot fragment
86:37 - login now it's going to be complaining
86:39 - because it wants to import r so you can
86:41 - go ahead and do that i just hit alt
86:43 - enter there to import it and that's
86:46 - satisfied that particular problem and
86:48 - then we need to
86:49 - give the container so this is where the
86:52 - view will be inflated into
86:54 - then we're going to type false for
86:56 - attach to root now this particular
86:59 - option falls for attached to root can be
87:00 - a little bit confusing for people but
87:02 - just understand that most of the time
87:04 - you want to leave it false and it will
87:06 - still actually appropriately add our
87:08 - fragment to the activities view
87:10 - hierarchy so don't worry about it
87:12 - anyways what we'll do next is we'll
87:13 - begin writing out our onstart function
87:16 - so again i'm going to type override
87:18 - fun
87:20 - on start
87:21 - like so
87:24 - and so what we need to do at this point
87:27 - is uh we're going to already start to
87:29 - refer to a couple different views in the
87:31 - xml layout from our onstart function
87:33 - here so what we need to do is we need to
87:35 - set up our synthetic functions now
87:38 - luckily this is like seriously one of
87:41 - the easiest things to do ever once
87:43 - you've added the library as we discussed
87:46 - before so all you need to do is just go
87:48 - up to your import statements here so
87:51 - what we're going to write is we're going
87:52 - to type import
87:54 - kotlin x dot android
87:57 - dot synthetic
87:59 - dot main
88:01 - dot fragment login dot
88:05 - asterisk so in case you're curious the
88:08 - asterisk is basically saying whatever is
88:11 - a for lack of a better term uh member of
88:14 - fragment login then we want to import
88:17 - all of those things so effectively what
88:19 - that's going to do
88:20 - is if i open up a fragment
88:23 - login here which is the actual view
88:34 - oh that took a while to load so
88:35 - basically what's going to happen is we
88:37 - can now refer explicitly to these
88:39 - particular
88:40 - view ids we don't need to do any fine
88:43 - view by id stuff all we need to do is
88:46 - just add in the appropriate layout and
88:48 - we're good to go okay so what we're
88:50 - going to do now is we are going to
88:52 - assign our view model
88:54 - now we'll type the code out here by hand
88:57 - but i'm actually going to be covering
88:58 - how to actually set the dependency
89:00 - injection and view model provider stuff
89:02 - up in a different video so if you're
89:06 - curious about how to do this in more
89:07 - detail i will eventually get to that
89:09 - covering a lot of stuff in this tutorial
89:11 - so what we can do is we're going to type
89:12 - view model of course referring to our
89:15 - reference above then we're going to say
89:17 - equals
89:18 - view model providers with an s
89:22 - of and then for this particular thing
89:26 - let's just go ahead and import that so
89:27 - it stops screaming at me
89:29 - um we're going to type this passing in
89:32 - our fragment again i'm not going to go
89:33 - into detail about this we're just going
89:35 - to type this out all right and then
89:36 - we'll type login injector
89:39 - which is a custom written dependency
89:41 - injection class which extends android
89:43 - via model so when we do that we need to
89:45 - type require activity this might be a
89:48 - new function for some people around here
89:50 - i'll get into that when i talk about
89:52 - this particular code in the other
89:54 - tutorial but
89:55 - this is kind of a handy little function
89:56 - that's been added somewhat recently and
89:58 - then we're going to refer to the that's
90:00 - going to get our activity and then we
90:02 - get the application
90:04 - and then once that happens there's one
90:05 - function in this particular
90:08 - class login injector which is provide
90:10 - user view model factory
90:13 - like so
90:14 - now we're not totally done yet because
90:16 - uh we've configured that aspect and now
90:18 - what we need to do is we might need to
90:20 - type dot get
90:22 - on our view model providers
90:24 - and then we're going to pass the
90:26 - specific view model that we require here
90:29 - so we're going to type
90:30 - user view model which is the view model
90:34 - that we will be talking to
90:36 - and we need to kind of refer to the
90:38 - class file here so what we're going to
90:39 - do is we're going to type double
90:41 - colon
90:42 - class dot java like so this is one of
90:45 - the things about kotlin the uh the um
90:48 - when you need to reference a particular
90:49 - java class the syntax for it is kinda
90:52 - wacky but whatever it works so uh that's
90:55 - all we need to do to assign our view
90:58 - model our first order of business now is
91:00 - going to be starting the background
91:02 - animation so if i briefly look at the
91:05 - layout that we're
91:07 - writing the fragment for or vice versa
91:09 - you understand what i mean
91:11 - it has a background which is like a
91:13 - space background basically and in the
91:15 - application it actually kind of animates
91:17 - if you're wondering how i did that i did
91:19 - cover vector drawables and animations in
91:22 - a particular video in this series i'm
91:24 - sure you're tired of hearing that but
91:25 - yeah go and watch that video if you want
91:26 - to figure out how to do that in detail
91:29 - so we're going to need to cast it as an
91:31 - animation drawable so type brackets
91:33 - first
91:34 - and then what we'll type is root
91:37 - fragment
91:39 - oops i can't fragment
91:41 - root fragment there we go holy crap that
91:44 - was pathetic and then so what we need to
91:46 - do is we want to get a hook to the
91:49 - background
91:51 - of this layout the space loop drawable
91:53 - here so what we can do is we're going to
91:55 - type root fragment login so we're
91:56 - referring specifically to this layout
92:00 - and then we're going to type dot
92:02 - background
92:04 - which is going to return a normal
92:05 - drawable now this
92:07 - the thing we have in this drawable is
92:09 - actually an animation list
92:11 - so what we can do is we're going to type
92:12 - as
92:13 - sorry animation drawable is what i meant
92:17 - animation drawable okay and then what
92:19 - we're going to do is we're going to type
92:20 - dot start with fade
92:23 - so immediately you're going to be
92:24 - wondering ryan what the hell is start
92:26 - with fade so it's actually just an
92:28 - extension function that i wrote in this
92:30 - project so i'm going to hit ctrl shift n
92:32 - and we'll type android and then there's
92:34 - a file called android extensions in the
92:37 - common package
92:38 - and you'll notice it has this particular
92:40 - function here start with fade so all it
92:43 - does is instead of having to repeatedly
92:45 - write this code out i've just pulled
92:47 - that code out and put it in an extension
92:49 - function which just means that i can
92:51 - just type start with fade and have
92:53 - instead of having to type
92:55 - this crap here so there's no magic this
92:58 - well there's the magic of kotlin
93:00 - extension functions which i really like
93:02 - but there's nothing too crazy going on
93:03 - here so the next thing we'll do is we
93:05 - will set up our click listeners and kind
93:08 - of bind them to the view model
93:10 - appropriately
93:11 - so since there's a couple of lines in
93:13 - that function
93:14 - or there's a number of things we need to
93:16 - do in order to set that up we're going
93:18 - to create a helper function
93:20 - so we're just going to call this thing
93:22 - set up oops
93:24 - set up click
93:26 - listeners i've got my keyboard in an
93:27 - awkward position and it's just ruining
93:29 - my typing skills my apologies set up
93:32 - click click listeners like so
93:35 - and then i'm just going to click on that
93:36 - hit alt enter
93:38 - create function and that's going to
93:39 - build it down there
93:41 - and then this is what we'll do next
93:42 - so like i said before now that we have
93:44 - kotlin synthetic properties set up we
93:46 - can just refer directly to the xml ids
93:50 - so the first one we're going to assign
93:52 - is the
93:53 - auth button so that's going to be this
93:55 - button in particular here the
93:58 - thing that currently says sign out but
93:59 - what it says changes frequently
94:01 - so we're going to type btn underscore
94:04 - auth attempt let it autocomplete dot set
94:07 - on click listener
94:09 - and we're going to give it a lambda
94:11 - expression here
94:13 - and so what we want to do when this on
94:16 - click listener fires it's going to
94:18 - basically call the code in our lambda
94:20 - that's how this kind of works in that
94:22 - event we want to type view
94:24 - model
94:25 - dot handle
94:27 - event
94:28 - so this is basically like a generic
94:30 - function which you'll see in all of my
94:32 - view models
94:34 - and how they work let me just pull the
94:36 - code up really quickly here type base
94:38 - view model
94:39 - so we'll go into more detail about this
94:41 - in the next video but just so you
94:42 - understand what's going on here we have
94:44 - this abstract function handle event and
94:46 - it takes some particular type so let's
94:49 - have a quick look at the view model
94:50 - itself that we're going to be working
94:52 - with that's again going to be user
94:55 - view model and just notice that it
94:57 - extends base view model
94:59 - and the generic type which i pass for
95:03 - each given view model
95:05 - is some particular kind of sealed class
95:08 - which represents different events
95:11 - i know this is a lot but just understand
95:13 - that what this login event thing does is
95:16 - it basically just represents different
95:17 - events which could possibly propagate
95:20 - from a particular view or a set of views
95:22 - so i just wanted to show you the code
95:24 - really quickly so you know what's going
95:25 - on here anyways back to our view so uh
95:28 - we're going to call our viewmodel.handle
95:31 - event function and what we're going to
95:33 - pass to that is login event
95:36 - dot
95:37 - on
95:38 - auth button click
95:40 - so this is basically our way of telling
95:43 - the uh user view model hey someone just
95:46 - clicked the auth button so you need to
95:48 - do something
95:49 - so that's not the only thing we need to
95:51 - assign here we're we're also going to
95:54 - basically make it so that if the user
95:56 - hits the back button then it's going to
95:57 - start the list activity so what i'm
96:00 - going to do is i'm going to type imb
96:02 - toolbar back is what it's called
96:05 - dot set on click listener
96:08 - there we go again lambda that
96:11 - pardon my language
96:13 - and then what we're going to do is we're
96:15 - going to type start list activity so
96:17 - this is actually a function we will code
96:19 - so i'm just going to hit alt enter
96:22 - create function start list activity down
96:24 - below
96:25 - so we're going to use kotlin single
96:27 - expression syntax so we're going to type
96:29 - require activity again
96:32 - dot start activity
96:35 - and in our start activity block we're
96:37 - just going to go ahead and create an
96:39 - intent so we're going to say intent
96:42 - and then in this intent we're going to
96:45 - type activity
96:47 - which is uh basically the activity for
96:49 - this particular fragment then we're
96:51 - going to type where we want to get to
96:52 - which is note activity and then we'll do
96:54 - our handy reference to java class syntax
96:58 - like so
96:59 - and that'll need to be imported
97:02 - okay so with that when someone hits the
97:05 - back button they're going to be sent to
97:07 - the note activity now some of you may be
97:09 - wondering hey i thought you were using
97:11 - navigation in this particular library
97:13 - well actually because of limitations
97:15 - which i discussed in the video where i
97:17 - covered the navigation library we do use
97:21 - the navigation library but not in this
97:24 - particular feature of the application
97:26 - and the reason is because it doesn't
97:28 - play nice with on activity result okay
97:31 - so we're almost done with our setup
97:32 - click listeners function there's just
97:34 - one more thing we need to do we need to
97:35 - intercept
97:36 - on back pressed and the reason for that
97:39 - is just because of the awkward
97:40 - integration with the navigation library
97:42 - which is not really my fault so we're
97:44 - going to say require activity and then
97:46 - we're going to type that dot
97:49 - add on back pressed callback i can't
97:51 - talk today for some reason
97:52 - so uh we're going to have to monkey
97:54 - around with this a little bit so we're
97:55 - going to basically put
97:57 - some parentheses here around our lambda
98:00 - we will still need the lambda expression
98:03 - so for the first parameter we're going
98:04 - to type view
98:06 - lifecycle owner and that's a property of
98:09 - our fragment here so if you're wondering
98:12 - where that's coming from that's where
98:14 - it's coming from and then we need to
98:16 - create an on back pressed callback from
98:19 - our lambda so we're going to type on
98:21 - back pressed callback
98:23 - actually autocompleted this time that
98:24 - was handy and then what we'll do inside
98:28 - of this on back pressed callback
98:31 - is uh we're going to type start list
98:34 - activity and this thing's complaining
98:36 - because this function must return a
98:38 - boolean and the boolean that we'll be
98:40 - returning is true so the reason why we
98:43 - return true here is because we're
98:45 - basically telling the operas operating
98:46 - system hey don't worry about handling
98:48 - that back click event we've got it
98:50 - covered don't do your thing anyways
98:52 - let's move on here so the next thing
98:55 - we'll do is we're going to write our
98:58 - basically another helper function called
99:00 - observe
99:01 - view model
99:03 - and what this particular function is
99:05 - going to do is we are going to observe
99:07 - some view models so i'm just going to
99:09 - hit alt enter create function down below
99:13 - so basically what we're going to be
99:15 - doing here is we want our view to pretty
99:18 - much attach to
99:20 - if i can find it here pretty much every
99:23 - publicly visible observable
99:26 - that our user view model possesses so
99:29 - basically what that's going to look like
99:31 - is we're going to be typing view model
99:35 - so the first one we'll do is sign in
99:37 - status text dot observe
99:42 - so we're going to pass view lifecycle
99:44 - owner which is a property of this
99:46 - fragment so it knows to pay attention to
99:48 - that particular
99:50 - life cycle
99:51 - and then we're going to create an
99:53 - observer
99:54 - lambda function
99:56 - and so again this is basically just what
99:58 - do we do when this particular
100:01 - observable publishes data so how do we
100:03 - handle the data and this is where this
100:05 - particular style of view model is really
100:07 - quite handy because basically all we do
100:09 - is we just bind it directly
100:11 - to whatever gets passed in
100:14 - so in this case i'll type up here that
100:18 - if you don't understand how lambda
100:19 - syntax works
100:21 - just understand that whatever gets
100:22 - passed in here is inferred to be this
100:24 - variable called it
100:27 - so for the first one i'll actually give
100:29 - it a different name than it we're just
100:31 - going to call this text and then i'm
100:33 - going to hit
100:34 - the arrow
100:35 - thingy here and then we're going to type
100:37 - um
100:39 - we're going to leave it like that
100:41 - and that's going to assign the name text
100:42 - instead of just using it i'm just doing
100:45 - this so hopefully you kind of understand
100:46 - what's going on so this particular field
100:48 - that we're working with here basically
100:50 - dictates what is displayed in
100:53 - this text view down here i know that's
100:55 - hard to see but this uh basically login
100:58 - status display down here
101:00 - so what we can do
101:02 - is we can refer to that particular view
101:04 - so lbl login status display and we're
101:07 - going to get its text property and we're
101:09 - going to assign that to text
101:11 - so for the rest of them we're going to
101:12 - use the it syntax but i just wanted to
101:15 - demonstrate that here in case anyone's
101:17 - confused about that i did do a video
101:19 - about that what what does it mean in
101:21 - kotlin so you can go and check that out
101:22 - if you like
101:24 - so what we'll do is we'll type out
101:26 - another
101:26 - uh observable here so we're going to
101:28 - type
101:29 - viewmodel.off button text so this is
101:32 - going to be the text for this button
101:34 - here that currently says sign out
101:36 - and it's the same process here so we're
101:39 - going to type observe
101:40 - give it the view life cycle owner give
101:42 - it a hook to our fragments life cycle
101:45 - and then we're going to give it another
101:46 - observer and in that observer so now
101:49 - we're referring to btn auth attempt then
101:52 - we're going to say
101:53 - dot text
101:55 - equals it
101:57 - so the rest of this observe view model
101:59 - function is just a whole bunch more
102:01 - livedata.observe functions so there's
102:04 - nothing really new there and i don't
102:05 - think there's actually any point in us
102:07 - typing that code out together what i'm
102:09 - going to suggest is if you'd like to
102:10 - practice maybe try implementing
102:13 - the rest of this function yourself and
102:15 - what you need to do is basically you
102:17 - just need to write one of these
102:18 - statements one of these observed
102:20 - statements
102:21 - for
102:23 - basically everything you see here now
102:26 - just one important thing to note these
102:28 - two live data observables here
102:31 - as opposed to well actually this one
102:33 - does affect the user interface but this
102:35 - one in particular is actually just a way
102:37 - to communicate back to the view
102:41 - based on what happens in a particular
102:43 - auth state so we're going to learn a
102:44 - little bit more about that in the next
102:46 - video where we actually write out this
102:47 - view model but yeah that's basically all
102:50 - i wanted to cover in this particular
102:52 - tutorial
102:56 - and you're watching video number seven
103:00 - of my android 2019 tutorial playlist so
103:03 - in this video we're going to be looking
103:04 - at wiring up the
103:07 - view model
103:09 - and in the previous video number six
103:11 - basically uh we'll be writing the view
103:13 - model that we hooked our fragment up to
103:16 - so if you're curious about how to
103:17 - actually write the fragment
103:19 - that this particular view model is going
103:21 - to publish events to or data too then
103:25 - you want to go back and watch that video
103:26 - first now once again before i proceed if
103:29 - you haven't already watched video number
103:31 - two where i go into detail about the
103:34 - model view view model architecture on
103:36 - android you might want to watch that
103:38 - first and the reason why is it's
103:40 - important you understand that there's a
103:41 - couple different ways to do
103:43 - uh the interaction between the fragment
103:46 - and the view model or the view in the
103:48 - view model in general and the approach
103:50 - we're going to be taking today is
103:51 - basically good in a situation where you
103:54 - don't need to reuse your view model
103:58 - and you would prefer to have a fairly
104:01 - simple
104:02 - view which doesn't have a whole lot of
104:04 - logic so basically like i explained in
104:06 - detail in that video what we'll be doing
104:09 - today is we'll write a view model which
104:11 - basically allows us to pull pretty much
104:13 - almost all of the presentation logic
104:16 - of the fragment the view
104:18 - out of the view and the good thing about
104:20 - this approach is that we can still
104:22 - maintain the model view view model
104:24 - pattern
104:25 - uh by communicating with the fragment
104:27 - only through live data objects so like i
104:30 - said in the previous video you can also
104:32 - use data binding but today we're just
104:33 - going to be using
104:34 - live data to communicate between the via
104:36 - model and the fragment all right so
104:39 - before we proceed you may want to grab
104:42 - the repository or the code that we'll be
104:44 - working with today link down in the
104:46 - description box below and you're going
104:47 - to want to either clone or download that
104:50 - particular project and pull it up in
104:52 - android studio or whatever is your
104:53 - preferred ide anyways before we get to
104:56 - the specific view model that we'll be
104:58 - writing today i wanted to show you the
105:01 - abstract class called base view model
105:04 - which the v model that we'll be writing
105:06 - extends so we're not actually going to
105:08 - write this class out
105:10 - but what i wanted to do is basically
105:12 - just talk about it really briefly and
105:14 - what it does for us so there's a couple
105:16 - different options for extending the
105:18 - functionality of existing sources in
105:21 - kotlin
105:22 - and when we want to really object
105:24 - oriented solution one of the best ways
105:26 - to do that is with an abstract class so
105:29 - the purpose of this base view model
105:30 - class is basically anything that is
105:33 - going to be common to basically every
105:36 - view model in this application
105:38 - i want to include that in the abstract
105:40 - class so if you'd like a detailed
105:42 - explanation of this kind of thing i do
105:44 - go into a detail about all kinds of
105:46 - different things including how to
105:48 - achieve similar behavior with extension
105:50 - functions
105:51 - in my kotlin course link in the
105:53 - description box down below so do
105:55 - consider checking that out
105:57 - anyways what we're looking at here is
106:00 - our base view model class
106:02 - basically is going to be containing
106:04 - a co-routine context object
106:08 - and it extends of course view model from
106:10 - architecture components and then it also
106:13 - extends coroutine scope so the reason
106:16 - why i wanted to bring this up is it's
106:18 - important you understand that this is
106:19 - how or where we're going to kind of
106:22 - launch our co routines from now i'm not
106:25 - actually going to go into detail on core
106:27 - routines in this particular video i will
106:28 - go into more detail in another video in
106:30 - this series but just understand that uh
106:33 - when we look at a particular view model
106:36 - so for example we have our co-routine
106:38 - scope set setup in this class
106:40 - and then we have our routine context
106:42 - down here
106:43 - and just notice it's going to be
106:45 - basically placed on the ui context
106:48 - dispatchers.uh main thread
106:51 - and then we have our job tracker object
106:53 - which allows for cancellation
106:55 - uh functionality so when i open up a
106:58 - particular view model which
107:00 - basically that's not a view model good
107:02 - job ryan when i open up a particular
107:04 - view model which extends
107:07 - our base view model
107:09 - just under understand that every time
107:10 - we're making this
107:12 - launch builder here
107:15 - it's going to be an extension on our
107:18 - root coroutine scope so anyways i'm not
107:20 - going to go into more detail on that
107:23 - in this video but i will talk about that
107:24 - in detail in another video and i just
107:26 - wanted to mention it here in case you're
107:28 - wondering why is the launch thing all
107:30 - yellow here uh that basically means that
107:32 - it's an extension
107:34 - on our view model so one other thing i
107:37 - would like to mention
107:38 - so the thing about working with this
107:39 - view model is obviously our live data
107:42 - objects have to be publicly visible but
107:45 - since we're not returning live data
107:47 - objects from the back end we have to
107:50 - work with mutable live data so one
107:52 - suggestion from al warren who's been a
107:54 - really awesome contributor to the wyze
107:57 - slack channel
107:58 - he just mentioned that one of the ways
108:00 - you can kind of get around this issue of
108:02 - having a publicly visible mutable live
108:04 - data object is to basically make the
108:08 - live data field
108:10 - which is publicly visible
108:13 - or the live data reference rather
108:16 - you basically make the actual data the
108:19 - actual mutable live data object as what
108:22 - you would maybe call an implicit backing
108:24 - field in technical language but
108:26 - basically what we're talking about here
108:28 - is this thing here the error state which
108:32 - is the mutable object and we'll see a
108:33 - couple different examples of this we can
108:35 - kind of hide those behind hide them
108:39 - the mutable live data reference behind a
108:42 - immutable live data publicly visible
108:45 - reference so basically what i'm saying
108:48 - here is if you want to improve your
108:50 - encapsulation then do consider taking
108:52 - this particular approach here all right
108:54 - so the class we'll be writing today is
108:56 - user view model
108:58 - so there's kind of two ways you can do
109:00 - this so i'm assuming you've downloaded
109:02 - or cloned the repository or you can just
109:04 - watch if you like but you can either
109:06 - basically just uh delete everything in
109:09 - here except for the package statement up
109:11 - top or you can just create a new file
109:13 - maybe call it login view model and build
109:15 - them kind of side by side whichever you
109:18 - prefer today what i'm going to do is i'm
109:20 - going to just actually select everything
109:22 - here
109:23 - and delete it now before i do that
109:26 - i just want to mention very briefly one
109:29 - thing we're not going to code today in
109:31 - this particular view model is the on
109:33 - sign in result function now the reason
109:36 - for that is that i'm going to be
109:37 - covering that in the part of this
109:38 - tutorial where we discuss using firebase
109:41 - and google sign in provider anyways with
109:43 - that being said i'm just going to delete
109:44 - everything there and maybe i'll leave
109:46 - this comment up top just for the fun of
109:48 - things
109:49 - and we can get started building our view
109:51 - model so the first thing we'll do is
109:54 - we'll build out our class declaration
109:57 - so we're going to type class
110:00 - login view model
110:02 - actually sorry user view model
110:05 - probably should have picked a better
110:06 - name for it so we've got a login view
110:08 - model and this thing is going to extend
110:11 - our base
110:12 - view model class
110:14 - now when we extend the base view model
110:16 - if i just hop back to it really quickly
110:19 - we have this function here abstract fun
110:22 - handle event and then we also have
110:25 - what's known as a generic
110:27 - type
110:28 - so basically what this is all about is
110:30 - that uh t is going to be some kind of
110:33 - sealed class
110:34 - which represents different events which
110:36 - can propagate from the user interface so
110:39 - we won't write that particular class but
110:41 - i'll just uh show you what it is in this
110:44 - particular case so it's going to be a
110:47 - login event
110:49 - class
110:50 - let me actually just pull that sealed
110:51 - class up so you know what's going on
110:54 - so we've got login event
110:56 - and uh so yeah as you can see just a
110:58 - pretty
110:58 - run-of-the-mill uh
111:00 - sealed class here now one of the things
111:02 - to mention is that we in some cases will
111:05 - be returning this login result class
111:07 - here
111:08 - so that's just basically like a data
111:11 - wrapper essentially
111:13 - so it just maintains
111:15 - a request code and a user token so this
111:17 - is the stuff which will be dealing with
111:19 - in the firebase video but again since
111:22 - we're kind of using it in this
111:23 - particular tutorial i just wanted to
111:25 - briefly mention what it is
111:26 - so we've got a
111:28 - not too many different events here just
111:29 - the three so there's on off button click
111:32 - on start and on google sign in result
111:35 - and these are all events if i open up uh
111:38 - so this is going to be
111:40 - fragment
111:42 - login
111:43 - so that's basically all the events for
111:45 - this particular
111:47 - layout here back to our user view model
111:50 - all right so we have our login event
111:52 - class and because we have that one
111:55 - type in here we do need to supply a
111:58 - particular type for our ceo class
112:01 - so that one is going to be a login
112:04 - result
112:05 - like so
112:06 - and then we need our constructor our
112:08 - initializer i think it's actually called
112:10 - and uh that's not all though so i'm just
112:13 - going to give our curly brackets here
112:18 - so base view model is expecting
112:21 - a co-routine context object so what
112:24 - we're going to do
112:26 - is
112:26 - we're going to basically pass in a
112:29 - reference here called ui context
112:34 - which is going to extend coroutine
112:36 - context
112:37 - and so that's going to get passed into
112:38 - our view model here
112:40 - so in our base view model here that's
112:42 - going to get passed in so during testing
112:45 - we would basically want to mock or fake
112:47 - this particular object and return
112:49 - dispatchers dot
112:51 - unconfined but when the application is
112:53 - actually deployed then this is going to
112:55 - be basically running on the main thread
112:57 - or rather our co-routine scope will be
112:59 - scoped to the main thread anyways back
113:01 - to our user view model all right so
113:03 - we've got our ui context object so what
113:06 - we need to do is we don't actually want
113:08 - to hold on to this thing in our actual
113:10 - view model we just want to pass that
113:11 - thing
113:12 - to the super class here the base view
113:14 - model class so i'm just going to type ui
113:16 - context
113:17 - and that should satisfy that particular
113:20 - error
113:21 - and now it's going to scream at us
113:23 - because we need to implement our handle
113:25 - event function
113:27 - so i'm going to click on that hit alt
113:29 - enter and then implement members
113:32 - handle event and there we have our
113:34 - handle event class with the appropriate
113:37 - sealed class accompanying it all right
113:40 - now there's one more thing we need to do
113:41 - with our constructor so the way that we
113:44 - actually get data basically in and out
113:47 - of this particular view model is through
113:49 - a repository
113:51 - again i will go into more detail on this
113:53 - in its own particular video in this
113:55 - series but what we're going to do is
113:57 - we're going to type val repo
113:59 - and that's going to be of type i user
114:02 - repository all right so we'll actually
114:04 - get to coding our handle event function
114:06 - a little bit later
114:07 - what i wanted to start with here is the
114:09 - various view model objects or sorry the
114:12 - various mutable live data objects that
114:15 - we'll need to be working with
114:17 - so uh let me write one out here and then
114:19 - we'll talk about how this kind of works
114:21 - so the first one we're going to write is
114:22 - the actual data model which this
114:25 - particular view model
114:27 - uh holds on to and we are going to make
114:29 - that one private because i don't want
114:31 - that one to be uh tampered with
114:33 - whatsoever except for within this
114:35 - particular
114:36 - viewmodel class so we're going to type
114:38 - private val
114:40 - user state
114:41 - and that's going to equal
114:43 - mutable
114:45 - live data and the type is going to be
114:48 - user
114:49 - so if you're not familiar with live data
114:51 - so basically how this works is it's
114:53 - going to pretty much
114:54 - wrap some kind of object it could be a
114:56 - string in this case it's the user data
114:59 - model i'll just open that up really
115:00 - quickly here and it's just like a really
115:02 - simple data class which has a uid
115:05 - and a name
115:06 - so this mutable live data is going to
115:08 - basically wrap that object it's
115:10 - complaining because i need to add that
115:12 - and then that's how we'll actually kind
115:13 - of persist the data in this view
115:16 - model now some of you might be wondering
115:19 - what's the difference between mutable
115:21 - live data what's and live data
115:24 - and when should you use them
115:26 - so i would basically put it like this
115:30 - live data is essentially an immutable
115:33 - class so basically what that means is
115:36 - that you can't change a live data object
115:39 - sort of within the class that's holding
115:41 - it so what you can do is let's say
115:43 - hypothetically we were actually working
115:45 - with a
115:47 - uh user data model which was coming in
115:50 - from a back end tool like say room so
115:53 - the important thing to know here is if
115:55 - we were returning a live data object
115:57 - from the backend then you would want to
115:59 - make this live data but in this
116:01 - particular case since we're returning an
116:03 - object just the user object which isn't
116:06 - a live data object that means we need to
116:09 - make our live data mutable so this
116:12 - basically means as you'll see in a
116:13 - moment that we can actually from within
116:15 - this class
116:16 - change the particular value that our
116:19 - mutable live data object wraps okay so
116:22 - we've made our actual
116:24 - data model wrapped by a mutable live
116:26 - data object and then what we need to do
116:29 - is we basically need to write out a
116:30 - couple different
116:32 - more live data objects
116:34 - with the goal of basically covering all
116:36 - of the different widgets and control
116:40 - operations control logic
116:42 - which our
116:43 - view will need to implement or or listen
116:46 - to essentially
116:48 - okay so what this particular thing is
116:49 - going to look like is we're going to
116:50 - type internal
116:53 - val
116:55 - off oops
116:57 - auth attempt
116:58 - so the reason why we're using internal
117:00 - is i basically want these things to be
117:02 - visible by anything within this
117:04 - particular module so for example our
117:07 - fragments
117:08 - but just for better encapsulation we're
117:10 - making it uh invisible outside of any
117:14 - outside of any other context so anyways
117:16 - we've got internal val auth attempt and
117:19 - then that's going to equal
117:21 - uh mutable
117:23 - live data again
117:24 - now for the type here we're going to use
117:26 - unit so why exactly would i use unit
117:30 - this is very similar to like void in
117:33 - java not exactly the same but quite
117:35 - similar in fact it does get mapped to
117:37 - void in uh when it's decompiled into
117:40 - java anyways how this thing basically
117:42 - works is i suggest using unit when you
117:45 - want to trigger some kind of event but
117:48 - you don't actually care about any
117:50 - particular
117:51 - value being passed into that event so
117:53 - what i think i'll do is i'll just show
117:54 - you really quickly what this looks like
117:56 - in the view
117:57 - so if i look at auth attempt here just
117:59 - notice that
118:01 - we're not actually returning any kind of
118:03 - value there is kind of an it which is of
118:06 - type unit that will get passed in here
118:09 - but in this particular case all we want
118:11 - to do is we just want to call a
118:12 - particular function
118:14 - uh when this particular
118:16 - mutable live data is changed so we're
118:19 - changing it and triggering the function
118:21 - but we're not actually changing it to a
118:22 - particular value anyways what i'll do
118:25 - next is i'm just going to hit control
118:27 - just put my mouse right there and then
118:28 - i'm going to hit ctrl d
118:30 - which will copy the line and then we're
118:32 - going to have a second control logic
118:36 - observable here so this is going to be
118:37 - called start
118:39 - animation
118:41 - and again that's just going to return
118:42 - unit same idea all right so we have our
118:45 - two control logic fields here or
118:48 - observables or whatever the hell you
118:49 - want to call them and in case there's
118:51 - any confusion here the reason why we're
118:53 - doing this is we need some way to call
118:56 - back to the view
118:57 - so in this way we can call back to it
118:59 - indirectly
119:01 - anyways we need a couple more mutable
119:03 - live data objects so in this particular
119:06 - style of building view models we
119:09 - basically want a live data object to
119:11 - represent every item
119:14 - in the
119:15 - uh layout that we're dealing with here
119:18 - so i'm just gonna again open up let's do
119:20 - ctrl shift n
119:22 - and let's see fragment
119:25 - login
119:26 - so what i'm saying here is we basically
119:28 - the way i actually built this thing is i
119:29 - said okay for every item
119:32 - in this layout every widget which
119:34 - changes we need a mutable live data
119:37 - object to basically represent the value
119:40 - that it will have so in this particular
119:42 - case we have this animation drawable
119:44 - here we have this
119:46 - text view
119:48 - which basically just displays the
119:50 - current login status and then we have
119:52 - this off button down here which is how
119:54 - we trigger auth events and this thing's
119:57 - text will change as well
119:59 - so it follows that we'll need a mutable
120:01 - live data object for each of these
120:03 - things
120:04 - so uh what we'll do is uh so i'm just
120:06 - going to type ui binding here because
120:08 - that's basically what we're doing
120:10 - and then we're gonna again use internal
120:13 - val
120:14 - sign in status
120:17 - text so that'll be for our sign in
120:21 - status text view and that's gonna be a
120:23 - mutable
120:25 - live data object and it's going to be of
120:26 - type string
120:29 - perfect
120:30 - now
120:30 - since even the
120:32 - animation drawable we're going to be
120:34 - giving it a url to a particular resource
120:38 - all of these things are going to be
120:39 - strings so again i'm just going to hit
120:41 - ctrl d twice like so
120:43 - and we're just going to update the names
120:44 - here so the first one is going to be off
120:46 - button
120:47 - text and by the way pick good names for
120:50 - these things like don't don't do
120:52 - short ugly names that leave people
120:54 - guessing about what they mean then we
120:56 - have the satellite drawable
121:00 - like so
121:01 - i can actually probably pick a better
121:02 - name for that one too to be honest but
121:04 - that's okay good enough
121:06 - all right so we have our live data
121:09 - objects and then what we'll do next is
121:11 - we'll get started kind of working with
121:12 - our handle event function here
121:15 - all right so what we'll do next is we
121:17 - will code our handle event function and
121:19 - that way you'll get to see
121:21 - our sealed class in action how it
121:23 - actually works
121:24 - so what we're going to do
121:26 - so there's a couple different things
121:27 - going on here what i'm going to do is
121:29 - i'm going to stub out the presentation
121:32 - logic functions
121:34 - and then we'll kind of implement those
121:36 - towards the end here but we can actually
121:39 - get started with them so
121:41 - we're just going to type show loading
121:43 - state
121:45 - and i'm going to hit alt enter create
121:48 - function show loading state and i'm
121:50 - actually just going to leave this to to
121:51 - do function here this is actually quite
121:54 - a handy function because if we do end up
121:56 - calling this particular
121:58 - function when we've forgotten to
121:59 - implement it then we will actually get a
122:02 - an error popping up which is actually
122:04 - what we want we want to know if this
122:05 - thing has been implemented or not before
122:07 - we ship the application
122:09 - so anyways we're actually going to as i
122:11 - say we're going to implement these
122:12 - functions a little bit later
122:14 - what we'll do now is so this is kind of
122:17 - the the main point of using a sealed
122:19 - class is we can represent a number of
122:22 - different finite states that the sealed
122:25 - class can represent and that can
122:27 - represent different events in the
122:30 - front end or back end of an application
122:32 - so i use sealed classes all of the time
122:35 - and if you're not familiar with them you
122:37 - probably should be if you're right in
122:39 - kotlin
122:40 - so
122:41 - uh what we're going to do is we're going
122:43 - to use a when matcher so we're saying
122:45 - when
122:46 - event which is what is passed in here
122:49 - then we'll give it some curly brackets
122:51 - and then this is where we list out our
122:52 - different cases so this is quite like a
122:54 - switch statement in
122:56 - java and c-sharp and those sorts of
122:58 - things
122:59 - so we're going to type is login event
123:03 - dot onstart
123:05 - so we're basically just going to make a
123:06 - function for each of these objects here
123:08 - and the data class as well
123:11 - and then we do an arrow sign thingy and
123:14 - then what we're going to do is we're
123:15 - going to type get user
123:18 - so we'll need to code this function out
123:19 - and what i'd like to do first is i'm
123:22 - just going to hit alt enter again create
123:24 - function get user
123:25 - and then we'll just finish off this
123:27 - particular handle event function before
123:29 - we get to that so we have two other
123:31 - cases so again i'm just going to hit
123:32 - ctrl d just speed things up a little bit
123:35 - this one's going to be on off button
123:37 - click
123:38 - and in that case we're going to type on
123:41 - off button click
123:43 - and again
123:44 - click on that hit alt enter create
123:46 - function cool
123:48 - and then for our last event here we have
123:50 - on google sign in result
123:53 - so in this particular case we're going
123:56 - to type in the on sign in result
123:59 - and then how do we actually get data out
124:02 - of our
124:04 - sealed class here so what we can do in
124:05 - this particular case is we type onsign
124:08 - in result
124:09 - and then by saying this is
124:12 - clause here this actually will cast our
124:16 - event to the on google sign in result if
124:19 - it does happen to be that particular
124:21 - class
124:22 - how we get our data out of that is we
124:23 - say event
124:25 - dot result which returns our
124:29 - login result object here
124:31 - okay
124:32 - and that's the property right there
124:36 - and then again we'll just hit alt enter
124:38 - create function
124:39 - now this is the function that we're not
124:42 - going to be
124:43 - coding out today
124:45 - so i'll just make a note here not coding
124:48 - this one today
124:50 - but in a later video where we talk about
124:53 - firebase and co-routines and stuff like
124:55 - that all right so that is our handle
124:58 - event function
125:00 - and then what we'll do next is let's go
125:01 - ahead and get started with our get user
125:03 - function here so for get user we are
125:06 - going to be talking to the repository
125:08 - object up here repo
125:11 - and let me just open that up really
125:13 - quickly i note repository sorry this is
125:16 - i user repository and just notice that
125:19 - these things basically they're all
125:21 - suspend
125:22 - functions so we're getting into
125:24 - co-routines land so in order to actually
125:27 - call these suspend functions we need to
125:29 - basically use uh some kind of co-routine
125:32 - builder generally speaking in this
125:34 - particular case since we have configured
125:36 - our base view model to be our root
125:39 - co-routine scope
125:41 - and our user view model extends that and
125:44 - i do recommend this
125:46 - i do recommend this approach for co
125:48 - routines uh we need to basically make
125:51 - this function into a launch builder so
125:54 - what we're going to do is we're going to
125:55 - type equals launch
125:57 - like so
125:59 - now it's important to note if you do not
126:01 - configure
126:02 - uh the appropriate co-routine scope just
126:05 - notice that this thing has this this
126:07 - protein scope thing right here
126:10 - if you do not configure that properly
126:12 - things aren't necessarily going to work
126:14 - the same way you're not necessarily
126:15 - going to be constrained to the
126:17 - appropriate con coroutine scope and i do
126:21 - not recommend you use globalscope.launch
126:23 - so what we're going to do it's actually
126:25 - really simple the way i build
126:27 - applications so we're just going to type
126:28 - val result
126:31 - which is going to be
126:33 - uh we won't specify the type here we're
126:35 - going to say val result equals repo dot
126:37 - get
126:38 - current user like so so if you're
126:41 - wondering what the type is here we're
126:42 - returning this result wrapper so this is
126:44 - a result wrapper that i've written
126:46 - myself there's a couple different
126:48 - libraries and stuff like that you can
126:49 - use i'll just open it up really quickly
126:52 - result
126:53 - and it just basically represents a value
126:56 - so like a success case and then it
126:58 - represents an error so like an error
127:00 - case big surprise there and then the way
127:02 - that we actually use it is with this
127:04 - handy build function
127:06 - so anyways that's what we're going to be
127:07 - returning
127:09 - but more specifically it's going to
127:10 - return either an exception
127:14 - or a nullable user object
127:17 - so why does it have both exception and
127:19 - then a nullable user well the reason for
127:21 - this is that we might end up checking
127:24 - our firebase auth for the current user
127:26 - and there's no current user so in that
127:28 - case we would return null
127:30 - this isn't necessarily an error case
127:32 - maybe the user just hasn't logged in yet
127:35 - so i'm trying to be a little bit more
127:36 - specific if there's an actual error
127:38 - occurring then i want that to basically
127:40 - be a different path that the
127:43 - event stream takes so anyways what we're
127:45 - going to do is we're going to hop back
127:46 - to user view model
127:48 - so how i like to use these result
127:50 - wrappers is again we're going to use a
127:51 - when
127:52 - when matcher
127:55 - so when result
127:59 - is oops not os
128:01 - result dot value
128:04 - like so
128:07 - then in that particular case uh we have
128:10 - a block going on here so there's a
128:12 - couple things we need to do here
128:14 - if we actually get a user object
128:18 - from our repo the first thing we want to
128:20 - do
128:21 - whether it's null or not is we want to
128:23 - say user state
128:25 - dot value
128:28 - so this is the
128:29 - value
128:32 - of our user state object here and this
128:34 - is how mutable live data
128:36 - mutable live data works
128:38 - so we can say user state dot value
128:42 - equals result
128:43 - dot value
128:46 - so what we're doing is we're taking the
128:48 - value out of our result obviously and
128:50 - then we're just assigning it to our
128:51 - mutable live data object
128:53 - so that fixes up our
128:56 - uh the the state of the view model here
128:59 - but of course we're still going to need
129:00 - to update everything else appropriately
129:02 - so in particular we need to update our
129:04 - ui binding so how we're going to do that
129:08 - is we're going to basically represent
129:10 - the user interface with a couple of
129:13 - different
129:14 - finite sort of states
129:16 - so what we'll do is we're going to write
129:18 - out all of those one after another i'm
129:20 - just going to actually stub them out
129:21 - first off
129:22 - so what we're going to do is we're going
129:24 - to hit
129:25 - enter again so the first thing i want to
129:27 - know is is this thing a
129:30 - null
129:31 - value which again isn't necessarily an
129:34 - error case
129:36 - and if it's a null value that means the
129:38 - user is currently signed out so we're
129:41 - going to type show signed out
129:43 - state
129:45 - like so then we're just again going to
129:47 - hit alt enter stub that function out
129:50 - and then
129:51 - we'll add an else case so we're going to
129:53 - say else show
129:55 - signed in state
129:58 - there we go
129:59 - just stub that bad boy out
130:02 - awesome
130:03 - so the only other thing we need to do
130:05 - here is we need to handle our error case
130:08 - so we're going to say is result
130:11 - dot
130:11 - error
130:14 - if that's the case then we want to show
130:17 - error state
130:20 - cool all right there we go
130:23 - and as you can see here we have all of
130:25 - our different
130:26 - ui state functions coded out
130:29 - okay so we're still not ready to
130:30 - implement these particular functions yet
130:32 - what we'll do first is we'll implement
130:34 - our on off button click function
130:38 - so basically what this is going to look
130:39 - like is we're going to type
130:42 - if
130:43 - user state dot value
130:46 - which is our live mutable live data
130:48 - object equals equals null
130:51 - which means that the user is not logged
130:53 - in
130:54 - then we want to call auth attempt
130:57 - dot
130:58 - value
131:00 - equals
131:01 - unit
131:02 - so what that's going to do is it's going
131:04 - to trigger
131:06 - the auth attempt observable in our login
131:08 - view here what that's going to do is
131:11 - that's going to call the start sign-in
131:13 - flow function down below here
131:16 - and this basically prepares the
131:17 - application to open up basically a new
131:21 - sort of activity
131:23 - using on activity result and what's
131:25 - going to happen is the user can
131:28 - basically choose to sign in with their
131:30 - google account and then once that
131:32 - process is ready
131:33 - then that result will be propagated
131:36 - to on activity result when the
131:38 - activity returns so anyways going back
131:40 - to the view model that's what we're
131:41 - going to trigger here so if user state
131:44 - value is null
131:46 - the user is currently logged out
131:49 - and they have pressed this particular
131:51 - button here except it would say sign in
131:53 - for example
131:54 - and that starts our sign in process
131:57 - now if the user else
132:00 - if the user value is not
132:03 - null then that means the user is
132:05 - currently logged in and they want to
132:07 - basically log out so in that case we're
132:08 - going to call sign out
132:11 - user
132:12 - and let's just code that function out so
132:15 - once again in order to actually sign the
132:17 - user out we need to talk to the uh
132:20 - repository object which means once again
132:22 - we're going to be dealing with our
132:24 - suspend functions so we can go ahead and
132:27 - make that into a launch co-routine
132:29 - builder
132:30 - like so
132:33 - just get rid of that there
132:34 - and so what this thing is going to look
132:36 - like is very similar to get user we're
132:38 - going to type val
132:39 - result
132:40 - equals repo dot sign out current user
132:45 - and then we're going to use our when
132:47 - matcher so when
132:48 - result
132:51 - is his
132:52 - result dot value
132:57 - do something so in this particular case
132:59 - what we're going to do is we're going to
133:01 - type user state
133:04 - dot value
133:05 - equals null so in this case we're not
133:08 - actually returning a value we just want
133:10 - to know if the user was successfully
133:12 - signed out or not if they were
133:13 - successfully signed out then we just
133:15 - want to make sure that the view model
133:17 - reflects that so we type user state dot
133:19 - value equals null and then we're going
133:21 - to again call our show signed out state
133:24 - function
133:25 - cool then we'll handle our error case is
133:28 - result dot error
133:32 - and then again we're just going to call
133:33 - show error state as you can see there so
133:36 - that's it for the different control
133:38 - logic functions that we're going to be
133:39 - coding out today there is of course the
133:41 - on google sign-in result but as i said
133:44 - several times we're going to cover that
133:45 - in a different video the last thing we
133:47 - need to do is we need to actually code
133:50 - out
133:50 - our
133:52 - different states here so i'm actually
133:54 - going to select all of this hit control
133:56 - x and i'm going to bring it up top to
133:58 - just below our view model objects here
134:02 - and then we get started all right it's
134:04 - time to code out our presentation logic
134:06 - functions now before we do that i just
134:08 - want to share really quickly i have this
134:11 - file in the common package called
134:13 - constants.kt
134:15 - so what we have here are a whole bunch
134:17 - of const val
134:19 - references so these are compile time
134:21 - constants which means that they're very
134:23 - efficient now if you need to localize
134:25 - your application for uh different
134:28 - localizations then probably you would
134:30 - want to go with strings.xml in this
134:32 - particular case this is me just being
134:34 - super lazy and efficient and just typing
134:36 - out different strings
134:38 - which ultimately will be rendered on our
134:41 - uh ui here uh just in an easily
134:44 - accessible file
134:46 - so what we'll do is uh
134:48 - instead of sort of hard coding these
134:50 - different values we're gonna refer to
134:52 - each appropriate constant and that'll
134:55 - just as you'll see in a moment make our
134:58 - presentation logic a little bit easier
134:59 - to write and a little bit
135:01 - harder to screw up
135:03 - so the first thing we'll do is we'll
135:04 - work with our error state here
135:06 - so in this particular case we're going
135:07 - to say sign oops
135:10 - sign in
135:12 - status text dot value so again we're
135:15 - updating the value of our live data
135:16 - object
135:17 - so the first one is going to be
135:19 - login
135:20 - error
135:22 - and then the next one so pretty much how
135:24 - this is going to work is i'm just going
135:25 - to hit ctrl d twice
135:27 - and we're going to update these values
135:28 - this one's going to be off button text
135:30 - dot value
135:32 - and so when there's an error we want the
135:34 - user to be able to sign in again so that
135:36 - one's going to be sign in
135:38 - and then for the uh next one we have the
135:41 - satellite drawable which is like the
135:44 - animation right here so if there's an
135:47 - error then we want to basically show
135:48 - antenna empty
135:50 - so that's a url to a particular drawable
135:53 - it's actually this one here the empty
135:55 - antenna animation here
135:57 - all right so once we have that figured
136:00 - out and let me just double check to make
136:01 - sure i didn't screw anything up
136:03 - ah looks okay good enough for now
136:06 - uh goodknow anyways uh so i'm gonna hit
136:08 - ctrl c
136:10 - and i'm just gonna paste this into each
136:12 - of these functions since this won't
136:13 - change too much
136:15 - again this is the kind of work that you
136:17 - really need to test because when you're
136:18 - doing this kind of copy paste crap you
136:20 - almost always screw something up
136:23 - all right so show signed in state is
136:25 - what we'll be working with next so when
136:28 - the user is signed in we want the sign
136:30 - in status to say signed in
136:34 - we want our off button
136:37 - to basically say
136:39 - sign out
136:42 - and then for our
136:43 - antenna drawable we want it to say
136:45 - antenna
136:46 - full
136:47 - which is basically this drawable here
136:49 - except with the wavy things on top
136:52 - just
136:53 - deploy the application if you want to
136:54 - see what it looks like
136:55 - okay so we've got our state here so show
136:58 - signed in state
137:01 - signed in sign out antenna full that's
137:04 - looking good next we'll go to show
137:06 - signed out state so it's basically going
137:08 - to mirror this one here
137:11 - so for show
137:13 - signed out state we're going to say
137:14 - signed out up here
137:17 - and this one is going to say
137:20 - show signed in state so this one's going
137:22 - to say sign in that's correct and then
137:24 - this one's going to be
137:26 - antenna empty that's actually correct
137:29 - it's quite similar to our error state as
137:31 - you can see
137:32 - all right so for show loading state it's
137:34 - actually going to be much simpler so
137:36 - we're just going to type
137:38 - sign in
137:39 - status text and we're going to set that
137:41 - one to
137:43 - loading
137:44 - oops kind of need an equal sign in there
137:47 - okay and then all we're going to do is
137:49 - we're going to call our start animation
137:53 - function here value equals unit so uh
137:57 - earlier on um you may have noticed in
137:59 - the view if you watched it previously
138:02 - what we ended up doing is we actually
138:04 - set the animation drawable in the view
138:08 - so the reason why we're doing that and
138:09 - not actually
138:11 - uh updating the particular drawable in
138:13 - this case is if we hop into login view
138:16 - notice that i actually specified
138:19 - explicitly that before we animate our
138:22 - drawable it must be assigned to our
138:26 - antenna loop drawable so the reason for
138:29 - this is that antenna loop is actually
138:30 - like the only drawable
138:33 - which is actually an animation list and
138:35 - i don't want to have a situation where
138:37 - i'm say for example assigning just a
138:39 - regular svg drawable
138:42 - and then somehow accidentally i forgot
138:44 - to
138:46 - change that to the actual animation
138:48 - drawable and then we are starting an
138:50 - animation drawable which isn't actually
138:51 - an animation drawable so basically what
138:53 - we're saying here is this is a little
138:56 - place where i actually did include a
138:58 - little bit of presentation logic in the
139:00 - view
139:01 - but this is for the sake of avoiding
139:03 - problems with shared mutable state
139:09 - so the very first tutorial i ever made
139:13 - at least on the topic of android on
139:14 - youtube was for the recyclerview way
139:17 - back in 2016. now back then there was a
139:21 - couple things about it which made it
139:22 - kind of tricky to set up for people so
139:24 - that's kind of what inspired me to try
139:26 - and make a video on it
139:27 - well i'll be basically teaching the same
139:30 - api today but luckily there are a couple
139:32 - improvements to it which will allow us
139:34 - to do a couple of things so for stars
139:36 - the recycler view we'll be building
139:38 - today is going to be the adapter at
139:40 - least is going to be decoupled from the
139:42 - fragment which is kind of important
139:45 - it's going to handle click events super
139:47 - easily as we'll see we don't have to
139:49 - have like seven different interfaces
139:51 - going on we'll actually handle click
139:53 - events just by using a mutable live data
139:56 - object
139:57 - and then finally our recycler view that
139:59 - we're going to build here we're going to
140:01 - use a particular class called list
140:04 - adapter which is like kind of a
140:06 - specialized adapter and what it's going
140:08 - to allow us to do
140:10 - is it'll basically remove our need to
140:12 - have
140:13 - to call functions like notify dataset
140:16 - changed notify item range change notify
140:19 - item inserted there's basically if
140:21 - you're not familiar in earlier
140:23 - recyclerview api implementations you had
140:25 - to call these different methods on the
140:27 - adapter based on what happened in your
140:29 - recycler view
140:31 - and it could actually get pretty
140:32 - annoying and complicated so what we'll
140:34 - do is we'll basically set up a bit of a
140:36 - boilerplate class called a diff util
140:40 - and dot item callback i believe it's
140:43 - called we'll see it in a minute but
140:44 - basically what this thing's going to
140:45 - allow us to do is it'll basically remove
140:48 - the need to call all those different
140:51 - functions and instead we'll just be
140:52 - calling one function and then we'll let
140:54 - this diff util our list adapter and a
140:58 - couple other things which we'll go into
140:59 - in the video handle all of those updates
141:02 - for us so it's going to be way simpler
141:04 - and best of all
141:06 - this particular implementation is going
141:07 - to figure out the or calculate the
141:10 - changes that need to be made to the
141:12 - recycler view on a background thread so
141:14 - no more blocking the main thread now
141:16 - since this is tutorial number eight and
141:19 - i've already covered a whole bunch of
141:20 - topics such as writing a view model
141:24 - writing a fragment model view view model
141:26 - architecture in general constraint
141:28 - layout all those different things
141:30 - what we're going to do is there's
141:32 - certain parts of this tutorial that
141:33 - we're not going to go into much detail
141:35 - in however i will show you all of the
141:37 - different steps necessary to actually
141:39 - set up the recyclerview what we won't be
141:42 - doing is we won't code out the whole
141:43 - fragment which displays the recyclerview
141:46 - and for the layouts that we'll be using
141:48 - in the recyclerview i'll show them to
141:50 - you and mention anything that's
141:51 - important but we're not going to build
141:53 - them on camera if you want to learn how
141:54 - to do that i have a whole tutorial on
141:56 - constraint layout which will help you
141:57 - figure that kind of thing out now before
141:59 - you proceed if you want to actually
142:01 - follow along with the tutorial in real
142:03 - time you're going to want to either
142:04 - clone or download the repository link in
142:07 - the description box down below now this
142:09 - could end up being a fairly long video
142:11 - so i'll make sure i include timestamps
142:13 - in the description box down below if you
142:14 - want a detailed idea of the topics and
142:17 - when we cover them in this video the
142:19 - first file that we'll be looking at is
142:21 - called fragmentnote list so this is the
142:24 - layout which actually contains the
142:26 - recyclerview
142:27 - so as i say i'm not going to go into too
142:29 - much detail here but here's a preview of
142:31 - the layout you can't actually see the
142:33 - recyclerview here but this is basically
142:35 - what it would look like if there are no
142:37 - items in the recycler view
142:39 - so i'm just going to open up the text
142:40 - editor here and we'll just look at this
142:42 - particular
142:44 - xml view so the first thing i want to
142:46 - bring your attention to is we have this
142:48 - color transparent black background so
142:51 - what i wanted to do here is instead of
142:53 - just setting the alpha of the which
142:55 - alpha means opacity or the degree to
142:58 - which something is transparent
143:00 - um instead of just setting that directly
143:01 - on the recycler view and kind of
143:03 - blurring things i just wanted to make
143:04 - sure that the background of the
143:06 - recyclerview
143:07 - basically made the elements in it a
143:09 - little more viewable a little more
143:11 - visible
143:13 - but you could still see the space
143:15 - background behind it so the way that i
143:17 - achieved that effect is i basically just
143:19 - set the background of the recyclerview
143:21 - to color transparent black and if i open
143:23 - up colors.xml that's basically just the
143:26 - color black with a hex value of 52 for
143:31 - the opacity
143:32 - so in the sense this is like setting the
143:35 - alpha except only for the background
143:37 - image so the second thing to point out
143:39 - here is that i've specified a linear
143:41 - layout manager in the xml so i used to
143:44 - do this in the java or kotlin code but i
143:48 - actually find it simpler to just do it
143:49 - declaratively in the xml in this
143:51 - particular case and notice that i'm
143:53 - using a linear layout manager depending
143:56 - on what kind of layout manager you use
143:58 - that will kind of dictate how your
144:00 - recyclerview behaves and how it kind of
144:02 - arranges the different items within it
144:04 - final thing to note here is that i've
144:06 - specified the default visibility of this
144:09 - particular view to be invisible and as i
144:12 - explained before that's because when
144:13 - there's no items retrieved from the
144:15 - database then i basically just want the
144:17 - recyclerview to be entirely invisible
144:20 - all right so the next file we'll be
144:21 - looking at is itemnote.xml
144:24 - so again i'm just going to talk about
144:25 - some general things but we're not going
144:27 - to actually code this particular view
144:29 - out
144:30 - so uh the first thing i wanted to
144:31 - mention is that both the primary graphic
144:34 - and the
144:35 - little icon down here are vector
144:38 - drawable resources so i have a tutorial
144:41 - on that and you can go and watch video
144:43 - number three in this series if you're
144:45 - curious about how to set these up but
144:47 - just to explain really quickly how they
144:48 - work
144:49 - uh basically they will scale to pretty
144:52 - much any screen size within reason
144:55 - and they won't lose quality or anything
144:57 - like that and the best part about that
144:59 - is that all of that happens through one
145:01 - single drawable resource so we don't
145:04 - need to specify resources for different
145:06 - screen sizes with vector drawables now
145:09 - looking at some of the more specific
145:10 - details here i just want you to note a
145:12 - couple of things
145:13 - so the way that i arrived at the general
145:16 - dimensions margins padding and those
145:19 - sorts of things
145:21 - is i basically went to the material
145:23 - design guidelines website and pretty
145:26 - much copied what they did
145:28 - now i do align things a little bit
145:30 - differently than what they suggest and
145:33 - so what i recommend is if you want to
145:34 - figure out how to align these things
145:36 - appropriately go check out what their
145:38 - guidelines are start from there and then
145:41 - tweak things a little bit in order to
145:43 - get the effect that you prefer so
145:44 - there's one last thing that i want to
145:46 - mention about this file if i scroll down
145:48 - to our primary text view here
145:50 - i just want you to notice that i've
145:51 - specified single line equal to true
145:55 - and then i've specified ellipsis dot end
145:59 - so what exactly is a lip size dot end
146:01 - this is kind of important if the text in
146:03 - your recycler view may end up being
146:05 - longer than the screen
146:07 - what ellipse size means is it's just
146:09 - whenever the text kind of cuts off it's
146:12 - just going to add a dot dot dot or
146:14 - ellipses as they're known and that's
146:16 - just going to make our recycler view
146:18 - look a little bit prettier in the event
146:20 - that the text is too long for the screen
146:22 - okay so we will end up coding the
146:24 - adapter by hand but there's one little
146:26 - boilerplate class here which is
146:28 - necessary to write before our list
146:31 - adapter
146:32 - and basically what it is is it's a
146:34 - diffutil dot item callback object
146:37 - so don't let all these scary names
146:40 - confuse you all this little class here
146:42 - does is it basically takes in some kind
146:45 - of datum model so let me open up note
146:49 - so note is basically the conceptual data
146:54 - which each item in our recycler view
146:57 - will represent
146:58 - so whatever data model you're trying to
147:01 - display so it could be like a user it
147:03 - could be an exercise it could be
147:06 - a note for example
147:08 - you're basically going to want to create
147:10 - a diff util
147:12 - dot item callback object which basically
147:15 - includes that particular data model as a
147:18 - generic type here
147:20 - so what is that going to do all it's
147:22 - going to do is it's going to allow you
147:23 - to to have some way
147:26 - if your data models have a unique
147:28 - identifier which they probably should
147:31 - of figuring out if an item at a given
147:33 - position has changed or not
147:36 - so if that's not super clear i think
147:39 - once i dive into the source code of the
147:41 - list adapter you'll probably understand
147:42 - how it kind of works all you need to
147:44 - understand here is that if you want to
147:46 - set this thing up properly whatever data
147:49 - model you have
147:50 - needs to have some kind of unique
147:53 - identifier in this case i've chosen the
147:56 - creation date of when the user basically
147:59 - creates the new node to be its unique
148:01 - identifier and then at some point as
148:03 - we'll see later on some internal class
148:06 - is basically going to use our callback
148:08 - object here
148:10 - in order to determine what
148:12 - uh items in the new list are different
148:15 - from the old list type of thing
148:17 - okay so in a moment we're actually going
148:19 - to basically delete this entire class
148:21 - and then rebuild it this is our adapter
148:23 - for our recyclerview but before we do
148:26 - that i want to take you through a bit of
148:28 - the source code of the list adapter
148:30 - class
148:31 - so as we'll see in a moment this thing
148:33 - is actually a sub class of
148:35 - recyclerview.adapter
148:37 - but it's integrated with a note
148:40 - or not a note in particular but some
148:42 - kind of diff util
148:44 - dot item callback and so as we'll see in
148:47 - a moment we that's why we needed to
148:49 - create that particular thing first and
148:52 - what i'd like to do is i'll take you
148:53 - through some of the internals of this
148:55 - class so that you can actually
148:56 - understand what's going on here so what
148:58 - i'm going to do now is i'm going to hit
149:00 - ctrl n
149:02 - and then i'm going to delete that
149:03 - because that's totally in my way and
149:06 - what i'm going to type is list adapter
149:10 - now up in this check box here you can
149:12 - see we have this include non-project
149:14 - items so i'm going to click that and i
149:17 - want you to notice that all of a sudden
149:18 - we have a whole bunch of different
149:20 - options that have popped up so the one
149:22 - we're actually going to look at from the
149:23 - library the recyclerview library is list
149:26 - adapter here
149:28 - okay so what's going on here so all of a
149:31 - sudden we're in java land because this
149:32 - is a java class but
149:34 - what i'll do is i'll just kind of
149:35 - explain what's going on here so the
149:37 - first thing i want to point out here is
149:38 - that this list adapter class as i said
149:40 - before extends recyclerview.adapter
149:43 - so it's capable of behaving as a
149:45 - recyclerview adapter now the most
149:48 - important thing you need to unders
149:49 - understand with this particular class is
149:51 - that it has this async list differ
149:55 - member here called mdiffer
149:58 - now there's two constructors we can use
150:00 - to create one of these list adapters and
150:03 - the one we use accepts our diffutil dot
150:07 - item callback object
150:09 - that's important because it's going to
150:12 - basically create a new mdiffer
150:15 - member
150:16 - partly out of the callback that we
150:18 - supply so in a moment we'll actually see
150:21 - how this diff callback actually saves us
150:23 - time and effort but there's a couple
150:25 - other things in this class that i wanted
150:26 - to point out so as i mentioned before
150:28 - how we used to have to deal with our
150:30 - recyclerview adapter when the underlying
150:33 - data set that it's looking at changed is
150:35 - we had to call all these different
150:37 - functions like notify item inserted
150:39 - notify item range removed and all kinds
150:41 - of things like that
150:43 - so this was really annoying and caused a
150:45 - lot of problems for different developers
150:48 - and also the thing about using notify
150:50 - dataset changed is that it was a very
150:52 - inefficient function
150:54 - so anyways what we're going to do is as
150:56 - we'll see in a moment
150:58 - this list adapter when we want to
151:00 - actually update the contents of the
151:03 - adapter all we have to do is we just
151:06 - call this submit list function down here
151:09 - and we provide a list which contains
151:11 - whatever data model that we're working
151:13 - with so what i want to point out here is
151:15 - that when this function is called it's
151:17 - going to call the same function on our
151:19 - mdiffer object and then it's going to
151:21 - pass the list in what we'll do next is
151:23 - we'll look at the async list differ
151:25 - source and then we'll kind of see what
151:26 - goes on inside of there okay so there's
151:28 - one more source class that we're going
151:30 - to look at and understand i i'm just
151:32 - trying to give you an idea of how this
151:34 - thing works under the hood so i'm going
151:36 - to hit control n twice and then we're
151:38 - going to look up async list differ here
151:41 - so this is a pretty complicated class
151:44 - all i want you to want you to understand
151:46 - here
151:47 - is that this async list differ class has
151:50 - a main thread executor object here
151:52 - and what that's going to do is it's
151:54 - going to allow it to call back to the
151:56 - main thread and then we'll see it also
151:58 - is capable of doing work on a background
152:00 - thread this is important because if
152:03 - you're making a huge update to a
152:06 - recyclerview that could potentially be a
152:09 - long-running operation so this is part
152:12 - of the magic of using this particular
152:13 - setup with listadapter and async list
152:16 - differ is that it's going to allow us to
152:17 - figure these updates out on the
152:19 - background thread appropriately and you
152:22 - don't actually even need to know what's
152:24 - going on here i'm basically just taking
152:25 - you through the source code as an extra
152:27 - step
152:28 - so we have our main thread executor and
152:30 - the only other thing i want to show you
152:32 - uh in this particular object here is i
152:35 - want to scroll down to the
152:38 - submit list function
152:40 - and just remember submit list is what
152:42 - we're calling on our list adapter and
152:44 - then that's going to get called on our
152:46 - mdiffer member
152:48 - okay so if we go down to submit list
152:50 - here we'll see the first function here
152:53 - accepts a list
152:54 - and then the next one is basically going
152:56 - to call the
152:57 - uh it's going to call an overloaded
152:59 - version of this function down here
153:01 - submit list and this is actually where
153:03 - the magic happens
153:05 - now the thing you i just want to point
153:07 - out to you is if i scroll down i i know
153:10 - this is a really horrendously
153:12 - uh huge function here
153:14 - but if i scroll down here just
153:16 - understand at a certain point we're
153:17 - going to say mconfig don't worry about
153:20 - what that is it's basically going to get
153:23 - a background thread executor and this is
153:25 - how it's going to actually calculate
153:28 - the difference between the old list and
153:31 - the new list
153:32 - and do that work on the background
153:34 - thread for us
153:35 - now importantly one little detail if
153:38 - you're wondering how it actually gets a
153:39 - hold of the
153:41 - note diffutile callback that we created
153:43 - understand that it's going to get a hook
153:45 - to that class through this m config
153:48 - object here which we actually created up
153:50 - in the list adapter somewhere
153:52 - here
153:54 - and we have a little builder class there
153:57 - and so it's going to get a hook to the
153:59 - diff util callback that you wrote and
154:01 - then from there it's going to ask it to
154:03 - compare the different items and that's
154:05 - ultimately why we needed to create our
154:07 - diff util callback once all of this is
154:10 - done it's going to dispatch this result
154:12 - to the main thread okay so now that
154:15 - we've had a look at the internals of the
154:16 - list adapter class that we'll be working
154:18 - with and hopefully that was interesting
154:20 - to you uh if you enjoyed going through
154:22 - the source code then please let me know
154:24 - down in the description box below and
154:26 - i'll try and do that kind of thing in
154:27 - the future
154:28 - so anyways at this point we're going to
154:30 - rebuild our note list adapter class and
154:32 - what we're going to do is just go ahead
154:34 - and open it up and we're just going to
154:36 - select everything in here except the
154:37 - import statement at the top and we're
154:39 - just going to delete it like so all
154:41 - right so you might be wondering at this
154:42 - point ryan how exactly is that making
154:45 - things easier for us that seems kind of
154:47 - complicated well the good news is that
154:49 - the complexity in the classes that we
154:51 - just went through is going to result in
154:53 - less complexity in the classes that
154:55 - we're going to be writing momentarily so
154:57 - in order to actually write out our
154:59 - adapters constructor we need to create
155:01 - our view holder object first so we'll
155:04 - start with that so this class is going
155:06 - to be called class
155:09 - note
155:10 - oops can't type note view holder
155:14 - it's going to have one property here
155:16 - which is going to be called root
155:18 - and it's going to be of type view and
155:20 - we'll see what happens in a moment
155:22 - with that
155:23 - and then it's going to have
155:25 - it's going to extend recycler view oops
155:28 - that's not what i wanted recyclerview
155:30 - dot view holder like so
155:34 - and what we'll do is it's going to
155:36 - complain because it's expecting this
155:37 - thing to accept a view so that's where
155:40 - we'll pass in this root view object here
155:42 - and so that will become the item view
155:45 - property of the view holder and just
155:47 - take note of that because we'll use it
155:49 - later on so the purpose of this class is
155:51 - it's basically kind of like a bridge
155:53 - between our note data model or whatever
155:56 - data model you'll be using
155:58 - and our item note layout so it's kind of
156:01 - like a virtual representation of the
156:03 - layout and so in our particular layout
156:05 - we really only need to represent the
156:08 - in this case the creation date and also
156:11 - the contents of the note in the actual
156:14 - layout so it follows that we just need
156:17 - to include two different uh
156:19 - references here so the first one is
156:20 - going to be called var content for the
156:23 - contents of the note
156:25 - it's going to be a text view
156:28 - and it's going to equal root
156:31 - dot lbl
156:33 - message
156:35 - so again don't forget root is referring
156:36 - to this thing here
156:38 - and then i'm just going to select at the
156:40 - click at the end of here and i'm going
156:41 - to hit ctrl d
156:43 - and this next one is also a text view
156:45 - it's going to be called date
156:47 - and it's going to point to root dot lbl
156:51 - date and time so just a really quick
156:53 - aside here about the note view holder if
156:56 - you're wondering where the name
156:57 - recyclerview actually comes from or what
156:59 - it refers to it basically means that as
157:02 - the user is scrolling through their list
157:04 - of items in the recycler view the
157:07 - recyclerview adapter is going to recycle
157:11 - the viewholder objects instead of
157:13 - creating a viewholder object for
157:16 - every item in the recycler view so minor
157:19 - point here but it's just kind of
157:20 - important to understand that that's
157:21 - where we actually get the efficiency of
157:24 - the recycler view and why it's called as
157:26 - such okay so now that we've got our view
157:29 - holder set up we can actually write the
157:31 - class declaration for our adapter
157:34 - so what that's going to look like is
157:35 - we're going to type class
157:38 - note list adapter
157:40 - i'm going to leave the
157:42 - constructor empty for a moment but we
157:44 - will put something in there and then
157:46 - this this class here is going to extend
157:49 - list
157:50 - adapter
157:51 - and it's going to basically accept a
157:54 - couple of different uh types here
157:56 - so what we need to do here is if you
157:58 - want to figure out what this particular
158:00 - what a given class needs in android
158:02 - studio for constructors or types like
158:05 - this generic types we can hit control p
158:08 - and it's actually going to kind of give
158:10 - us some kind of idea so in the case of t
158:12 - this actually refers to our data model
158:15 - so in this case i'm going to type note
158:18 - and then for the second one we have some
158:20 - kind of view holder object and that's
158:22 - going to end up being our note view
158:24 - holder and that's why we needed to
158:26 - create that thing first so in here i'm
158:28 - going to type note list adapter
158:32 - dot note view holder now it's still
158:36 - complaining because as you can see here
158:38 - we're referring to something which is
158:39 - supposed to be within note list adapter
158:42 - so i'm just going to throw down some
158:44 - curly brackets here and then we're going
158:45 - to move that note view holder object
158:47 - into the adapter like so so there's
158:50 - obviously a couple things we need to fix
158:52 - here so go ahead and click on the red
158:55 - highlighted note list adapter here
158:57 - and what i'm going to do is i'm going to
158:59 - hit alt enter and then we can click on
159:02 - implement members or hit enter and make
159:04 - sure you select both of these and then
159:06 - hit ok
159:07 - and so these are the
159:09 - functions that you basically need to
159:11 - implement in order for this thing to
159:12 - work properly
159:14 - notice how there's a couple fewer
159:15 - functions than compared to a normal
159:18 - recyclerview adapter and that's because
159:20 - some of those functions are actually
159:21 - handled inside this list adapter class
159:24 - so we'll get to implementing those in a
159:26 - moment there's another thing we need to
159:27 - deal with so our list adapter is showing
159:29 - up red and if i click inside the
159:31 - parentheses here and hit ctrl p
159:34 - it's going to say that it's expecting
159:36 - some kind of diffutil dot item callback
159:39 - object so all we need to do in this case
159:42 - is i'm just going to type note diff util
159:45 - callback and then we'll add brackets at
159:48 - the end of it and that's going to
159:49 - actually create an instance of the note
159:51 - diffutile callback object
159:53 - so in my older tutorials the way that i
159:56 - handled click events was basically to
159:58 - either nest the adapter
160:00 - inside of the fragment or activity which
160:03 - it was supposed to call back to
160:05 - or by holding reference to whatever
160:08 - class it was trying to call back to as
160:10 - an interface
160:11 - so we're gonna do neither of those and
160:14 - take an option which is a little bit
160:16 - more decoupled and i think a little bit
160:18 - safer so what we're going to do instead
160:21 - is we're going to use a mutable live
160:23 - data object to call back to the fragment
160:26 - so what we'll do is we're going to type
160:27 - val
160:28 - event
160:30 - and it's going to be of type mutable
160:32 - live data and the type is going to be a
160:35 - sealed class which is
160:38 - note list event
160:40 - so if you're wondering exactly what this
160:42 - is and how mutable live data work
160:45 - go and check out the particular part of
160:46 - the tutorial where i actually discuss
160:48 - these topics
160:50 - just really really quickly note list
160:51 - event is a sealed class which represents
160:54 - different events which can occur in the
160:56 - front end
160:57 - and mutable live data is basically
160:59 - something that can be observed but this
161:02 - mutable word means that we can change
161:04 - its value and the value is what's
161:07 - basically wrapped up here
161:10 - whenever we want to and when we change
161:12 - it if our
161:14 - fragment for example happens to be
161:16 - listening to this mutable live data
161:18 - object then it will know when a
161:20 - particular event happens and what the
161:22 - details are so in order to complete this
161:24 - we're just going to have to actually
161:26 - create this thing so we'll say equals
161:29 - mutable live data and we'll give it our
161:31 - constructor so the first function that
161:33 - we'll implement is oncreateviewholder
161:37 - so uh beyond what the name implies here
161:40 - basically what this particular function
161:42 - does is this is where we actually
161:44 - inflate
161:45 - the layout which our recyclerview will
161:48 - use
161:49 - so what we're going to do is we're just
161:51 - going to mess around a little bit here
161:52 - so
161:53 - we're going to say val
161:55 - inflator
161:57 - equals
161:59 - layout inflator
162:01 - dot from
162:03 - and so we're going to use this parent
162:05 - object here which is a view group so
162:07 - from parent
162:09 - dot context and that's going to get a
162:12 - hold of a context object now this is
162:15 - really important
162:17 - whenever you're messing with context you
162:19 - need to be careful about memory leaks
162:21 - and there's a particular step we're
162:23 - going to go over
162:25 - in the fragment
162:26 - which is going to prevent this
162:28 - particular adapter from leaking this is
162:30 - kind of a problem with adapters is we
162:32 - have this ugly situation where it's a
162:34 - class that needs to have access to
162:37 - things like layout inflators and the
162:39 - view hierarchy but it might be somewhat
162:42 - detached from the life cycle of say the
162:44 - fragment so like i say we'll see a
162:47 - specific step we need to follow in the
162:48 - fragment in order to make sure that this
162:50 - isn't an issue for memory leaks
162:53 - anyways once we have our layout inflator
162:56 - object what we'll do next is we're going
162:57 - to type
162:58 - return
163:00 - note view holder
163:02 - like so and inside of this note view
163:05 - holder object which expects a root view
163:08 - this is where we'll actually do our
163:10 - inflation so we're going to say inflator
163:13 - dot inflate
163:16 - and so in here we're going to provide
163:18 - the actual item note layout which is the
163:21 - layout of each item in the recycler view
163:24 - r.layout.item note
163:27 - and then we're going to give it parent
163:29 - which was passed in up here
163:32 - and then we're also going to provide
163:35 - we're going to say false for attach to
163:38 - root okay so some of you might be
163:40 - wondering what exactly is this attached
163:42 - to root and why is it false if we leave
163:45 - it false does that mean that our views
163:47 - our view holders are going to be
163:48 - magically floating around the user
163:50 - interface and unbound to anything
163:52 - the reason why we're passing false in
163:54 - here is because we do not actually
163:58 - we don't write the code
164:00 - to attach this particular view to the
164:03 - view hierarchy
164:04 - so basically what that means is that
164:06 - it's going to inflate
164:08 - this r.layout.itemnote
164:11 - view
164:12 - it's going to get some layout parameters
164:14 - from this parent object and if i hit
164:16 - control p notice this thing is called
164:19 - root
164:20 - and so just understand that everything
164:22 - is going to work fine
164:24 - when would you want to use attach to
164:26 - root true that would be if
164:28 - you are writing some particular class
164:31 - which is responsible for attaching a
164:34 - view to the hierarchy in this case this
164:37 - occurs internally so we can just leave
164:39 - it false and we don't have to worry
164:40 - about it all right so what we're going
164:42 - to do next is we're going to write out
164:43 - our onbindviewholder function
164:46 - so the first thing we'll do is we want
164:49 - to basically get a hold of the note item
164:52 - at a given position and position is
164:55 - provided here
164:56 - so what we'll do is we'll call getitem
164:58 - which is a function from the adapter
165:01 - and then we'll pass in position
165:03 - then we're going to say dot let so
165:06 - basically what's going to happen here is
165:07 - we're saying okay get this thing
165:10 - and then in this block of code as soon
165:12 - as you get that thing i want to do
165:14 - something with it so in this case just
165:17 - to make things a little bit more legible
165:18 - instead of using the it reference which
165:20 - is a little bit confusing to some people
165:22 - i'm just going to type note so we're
165:24 - going to give a name to the thing that
165:26 - is returned by this function and then it
165:29 - kind of pops up up in here then we need
165:32 - to add an arrow thingy here so what
165:34 - we're actually going to do is once we
165:36 - get our note object here we need to bind
165:39 - it to the viewholder object which was
165:42 - passed in so what we're going to do is
165:44 - we're going to type holder dot content
165:47 - for the first one and remember that's
165:49 - just what we defined down here
165:52 - holder.content.txt because it's a text
165:54 - view equals note dot contents
165:58 - i'm going to hit control d and for this
166:00 - one we're going to say holder.date.txt
166:03 - equals note dot
166:05 - creation date
166:07 - and then what we'll do after that is
166:09 - we're going to add a click listener to
166:11 - the entire
166:12 - sort of root layout of the view holder
166:14 - object so we're going to say
166:16 - holder dot item view
166:20 - dot set on click listener and we're just
166:24 - going to use a lambda in this case again
166:26 - so what's going to happen is when this
166:28 - on click listener is fired whatever we
166:31 - write in here is going to be executed
166:34 - and so what we're going to do in that
166:36 - case is we're going to publish an event
166:39 - to anything which is listening and the
166:42 - way we're going to do that is we're
166:43 - going to use our
166:45 - event mutable live data property up here
166:47 - so what we want to do there is we're
166:49 - going to type event dot value to get the
166:52 - value of the mutable live data object
166:55 - then we're going to set that value to a
166:58 - particular kind of event
167:00 - in this case the event will be note list
167:03 - event
167:04 - dot on note item click
167:08 - and then that thing requires a position
167:11 - which will be the position that is
167:13 - passed in in on bind view holder now i'm
167:16 - sure some of you are wondering what this
167:17 - class looks like so i'll pull it up
167:19 - really quickly so note list event
167:22 - and just understand it has a couple
167:24 - different events basically any event
167:26 - which can occur in the note list feature
167:29 - of the application and the one we used
167:31 - is on note item click and as you can see
167:33 - here it accepts a position
167:36 - as a property which is what we pass into
167:38 - it so that's actually it for our adapter
167:41 - object so what we'll do to finish this
167:43 - video off is i'll take you through the
167:46 - fragment which holds the recyclerview
167:49 - and interacts with the adapter now we're
167:51 - not going to code everything out because
167:53 - that would take a needlessly long time
167:55 - and i've already explained how to code
167:57 - up fragments in a previous video but
167:59 - what i will do is take you through
168:01 - specific steps which you probably should
168:04 - take to avoid things like memory leaks
168:06 - and to make sure that everything gets
168:07 - set up properly okay so i've opened up
168:09 - note list view now as you can see here
168:12 - we have a reference to the adapter in
168:14 - the fragment i do recommend taking that
168:17 - route and not putting a reference to the
168:19 - adapter in something like a view model
168:22 - the reason why is that you don't really
168:24 - want to be putting classes which have a
168:26 - reference to like layout inflator and
168:28 - context and the view hierarchy
168:31 - in something like view model so in this
168:33 - case like i say we're talking to it
168:35 - through the fragment here now this is a
168:38 - really important step here you can see
168:39 - i've overridden on destroy view in the
168:42 - fragment
168:43 - so what was happening is that after i
168:45 - got this thing all set up
168:47 - i was getting a very strange
168:49 - memory leak and i figured that out by
168:51 - using the tool leak canary a very
168:54 - awesome tool
168:55 - so i was trying to figure out what was
168:56 - going on here and after a bit of
168:57 - googling i figured out that
169:00 - in certain cases and again this is just
169:02 - the feature a feature of the fact that
169:04 - our
169:05 - adapter is tightly coupled to the view
169:08 - hierarchy and context and layout
169:10 - inflator and all that stuff
169:12 - if you do not set the adapter property
169:15 - of the recycler
169:17 - view and that's what this thing is here
169:20 - to null then
169:22 - chances are you may get a memory leak i
169:25 - think it partly depends on how you have
169:27 - everything set up here but in this
169:28 - particular case if we want to have our
169:30 - adapter sort of
169:32 - separate from the fragment i did need to
169:35 - include this detail here otherwise i got
169:37 - a memory leak now some of you may be
169:39 - wondering and i went over this in the
169:41 - fragment tutorial in this series but the
169:43 - way that we're able to just directly
169:45 - refer to these xml views
169:48 - like so is by using kotlin synthetic
169:51 - properties up here so go check the
169:54 - fragment tutorial out if you want an
169:56 - idea of how to do that it basically
169:58 - completely eliminates fine view by id
170:00 - which is really handy
170:02 - anyways the only uh function well
170:05 - there's two functions we're going to
170:06 - look at next so one of them is going to
170:07 - be setup adapter here
170:10 - and so this is just a helper function
170:12 - that i've created so that we don't have
170:13 - just one giant onstart function
170:16 - and when i scroll down to it this is
170:18 - what we have here
170:19 - so what we end up doing is we create a
170:22 - new instance of our note list adapter
170:25 - and we assign it to our adapter
170:27 - reference
170:29 - the next thing that we do is we get a
170:31 - hook to the event
170:33 - property remember that's our mutable
170:35 - live data object and then we observe it
170:38 - so that when a click event happens in
170:41 - the adapter in the recyclerview it's
170:44 - going to pop up here
170:45 - now since our fragment has referenced
170:48 - the viewmodel as well what we'll do is
170:50 - through this lambda function here that's
170:52 - where we will pass
170:54 - the particular event and remember that
170:56 - contains the position of the item that
170:59 - was clicked we passed that into the view
171:01 - model and then let the view model figure
171:03 - out what to do from there now the last
171:05 - thing that we do after we get that set
171:07 - up is we assign our recyclerview
171:10 - its property its adapter property to the
171:13 - adapter we just created and now for the
171:16 - moment you've all been waiting for how
171:18 - do we actually get our data into this
171:21 - particular
171:22 - recyclerview adapter and recyclerview so
171:24 - if i scroll down to the observe
171:26 - viewmodel function and just note that
171:29 - i'm calling that after i set the adapter
171:32 - up so just for people watching this make
171:33 - sure you kind of don't mix these steps
171:35 - up here we're setting it up first
171:38 - and then we're asking the viewmodel for
171:40 - the data so if i scroll down to the
171:42 - particular observable
171:44 - which is note list so that's of course
171:46 - our list of notes
171:48 - we observe it and then when we receive a
171:51 - new note list
171:53 - all we have to call
171:54 - is adapter dot submit list now don't
171:57 - worry about this function here this is
171:58 - just like ui animation boilerplate stuff
172:01 - this is seriously all we need to do to
172:04 - provide a new list to our adapter and
172:07 - anytime we change the underlying list
172:09 - it's going to pop up in here
172:11 - we're going to call adapter.submit list
172:14 - the diffutil is going to figure out what
172:15 - to do from there and then we are set no
172:18 - more notified data set change notify
172:21 - item inserted or confusion with creating
172:24 - a new list of data or all those kinds of
172:26 - things because for anyone who worked
172:28 - with recyclerview before it was actually
172:31 - kind of difficult and confusing how to
172:33 - like for example update an entire list
172:36 - or change part of it or things like that
172:38 - so all of that work that we did earlier
172:40 - did actually ultimately make our adapter
172:43 - simpler to work with
172:48 - and in this video i'm going to talk
172:50 - about integrating firebase auth and
172:52 - google sign-in provider in your android
172:54 - applications so in order to set up
172:56 - firebase authentication with google
172:58 - sign-in provider we will need to perform
173:00 - the following steps we'll create and
173:02 - configure firebase for an android
173:03 - project
173:04 - we'll set up a shawling certificate in
173:07 - android studio for debug builds we'll
173:09 - download the google services.json file
173:11 - after all the configuration is done
173:14 - we'll have a quick look at what we need
173:15 - in our project level and module level
173:17 - build gradle files and once that's all
173:19 - complete we will implement firebase off
173:21 - and google sign in provider in a small
173:23 - little android application and i will
173:25 - show you where to get the source in a
173:26 - moment now before proceeding i will need
173:29 - you to have an account set up with
173:30 - firebase so go ahead and do that if you
173:32 - haven't already so assuming you have an
173:34 - android app which you want to connect to
173:36 - firebase the easiest way to integrate it
173:38 - in recent versions of android studio is
173:40 - to select tools firebase authentication
173:46 - and then click connect to firebase if
173:49 - this process worked for you it should
173:51 - have created a new android project in
173:53 - firebase if it doesn't i suggest you
173:55 - enter the firebase console and create a
173:56 - new android based project manually next
174:00 - click the add firebase authentication to
174:02 - your app button this will add in some
174:04 - gradle dependencies to make things a
174:05 - little bit easier for you for the next
174:07 - step we will set up authentication in
174:09 - firebase go ahead and open up the
174:11 - firebase console and click on the
174:13 - authentication page next click sign in
174:16 - method in the following tutorial where
174:18 - we actually implement code for firebase
174:20 - auth we just use google sign in provider
174:23 - for your first try this you might want
174:24 - to just stick with email password
174:26 - authentication
174:29 - before we can do much else we need to
174:30 - configure a shell one certificate for
174:32 - our application this is just a unique
174:35 - identifier which we will add to our
174:36 - firebase project's configuration to get
174:39 - the debug certificate which android
174:40 - studio generates for us simply build
174:42 - your project at least once open the
174:44 - gradle tab in android studio and try
174:47 - either project name tasks android
174:51 - signing report or if that doesn't show
174:53 - up try app tasks android signing report
174:58 - in the run console locate your sha-1
175:00 - certificate and copy it
175:03 - back in the firebase console navigate to
175:05 - settings towards the bottom of the
175:07 - general tab you should see a card which
175:08 - holds your app id and allows you to
175:11 - download your google services json file
175:13 - on that card click add fingerprint
175:16 - and paste in the debug certificate
175:19 - now there's something very important i
175:21 - need to mention i'm going to show you
175:23 - how to set this up using a debug sha-1
175:25 - certificate which android studio
175:27 - automatically creates for you so this
175:29 - will allow you to test debug versions of
175:32 - your application but just understand
175:34 - that when you upload your application to
175:36 - google play if you sign that application
175:39 - with a different sha-1 certificate which
175:41 - you really should do then you're going
175:43 - to need to add that certificate back
175:45 - into firebase as well and also if you're
175:47 - like me and you use app signing by
175:49 - google play you're going to want to go
175:51 - into the play console open release
175:53 - management and then app signing and
175:55 - you're going to want to paste the public
175:57 - sha-1 certificate fingerprint in the
175:59 - console into firebase as well now that
176:02 - we have our certificate set up it's time
176:04 - to download our google services json
176:06 - file this file contains keys and
176:08 - configurations which will allow our
176:10 - client app to work with firebase and
176:11 - google sign in now if you downloaded
176:13 - this file before adding your shawlwind
176:15 - certificate you will need to download it
176:17 - again alright now that we have all that
176:19 - configuration done it's time to see how
176:21 - we actually implement firebase off and
176:23 - google sign-in provider in the
176:24 - application this will require properly
176:27 - configuring gradle implementing start
176:29 - sign-in flow and on activity result
176:31 - which are functions in the front end
176:33 - and implementing firebase auth in the
176:36 - back end of the application now i will
176:38 - only be writing out a couple functions
176:40 - in an entire application so please check
176:42 - the description box for the source code
176:44 - for the entire application i also build
176:46 - this application out in many different
176:48 - segments in this whole tutorial series
176:50 - so consider checking out the other
176:51 - videos if you want to know how i set up
176:53 - the view model the rest of the view and
176:55 - things like that
176:57 - before proceeding please double check
176:58 - that in your project level build gradle
177:00 - file you have the google repository
177:02 - present in the all project script within
177:04 - the build script and also that you have
177:06 - a dependency to google services in the
177:09 - build script as well in your module
177:12 - level build gradle file you'll want to
177:13 - have at least firebase core firebase
177:15 - auth and play services auth if you wish
177:18 - to use google sign-in in this app i
177:20 - chose to build a custom login ui and if
177:22 - you want to learn how to do that please
177:24 - watch part 4 of this tutorial series
177:26 - where i demonstrate how to build a
177:27 - custom material design login ui using
177:30 - constraint layout alright we need to
177:32 - write a couple of functions in the view
177:33 - so the first one is start sign in flow
177:38 - start sign and flow will start an
177:40 - external activity which will display the
177:42 - google sign-in user interface this will
177:44 - briefly pause our application and open
177:46 - up an external
177:48 - application now important point here
177:51 - r.string.defaultwebclient.id
177:53 - is not something that you actually write
177:55 - yourself and add to your strings xml
177:58 - file this is something which is
178:00 - generated dynamically from your
178:02 - googleservices.json file in older
178:04 - versions of google sign in and firebase
178:06 - you did have to add this in yourself but
178:07 - at this point there's just less
178:08 - configuration you have to do for google
178:11 - sign in dot get client if you're writing
178:13 - this in an activity you can just type
178:15 - this
178:16 - since this particular login view happens
178:17 - to be a fragment instead we'll just type
178:19 - in require activity
178:24 - like i said before we're going to be
178:25 - actually starting a different
178:27 - application so that's why we're creating
178:29 - an intent here
178:30 - and whether or not the user signs in the
178:33 - result will still get passed into on
178:35 - activity result once the user finishes
178:37 - the google sign-in user interface
178:44 - a quick point here rc sign in is just
178:47 - some unique integer key let me just show
178:50 - you it really quick
178:52 - yeah it's literally just leat
178:54 - so rc sign in which stands for request
178:57 - code sign in is going to get passed into
178:59 - on activity result if you are working in
179:02 - an application which uses on activity
179:04 - result for a couple different things
179:06 - then you're going to want to actually
179:08 - check to see if rc sign in equals leet
179:11 - in this case in this application we're
179:13 - only working with google sign in so i
179:15 - don't expect it to be called in any
179:16 - other case
179:20 - so basically what we're writing here is
179:22 - this is just a bunch of boilerplate code
179:23 - to see if the user signed in properly
179:26 - and also to see if we were able to get a
179:28 - user token from their google account
179:36 - what will happen is if we successfully
179:38 - get a user token we will end up passing
179:40 - that to the back end of the application
179:42 - and that's how we'll kind of connect
179:44 - both google sign-in and also firebase
179:46 - together but yeah this is pretty typical
179:48 - boilerplate code
179:50 - now google sign in dot get signed in
179:52 - account from intent returns a task
179:55 - object and our task object can throw an
179:57 - exception so we'll just need to make
179:58 - sure that we're handling that somehow
180:00 - since this is a demo application we'll
180:02 - just print it out to the console
180:04 - the last thing we'll do is we'll
180:05 - actually inform the view model that
180:07 - onactivityresult has been called
180:13 - here i'm using a sealed class to kind of
180:15 - model that particular ui event and i'm
180:17 - also creating this login result object
180:25 - let me show you what login result looks
180:27 - like it's actually just a simple data
180:29 - class as you can see it holds the
180:30 - request code and the user token
180:33 - which could be null all right now that
180:35 - our view is wired up the next thing
180:36 - we'll write is our implementation of
180:38 - firebase auth and google sign in
180:40 - provider in the back end now there are a
180:42 - couple different ways to write this code
180:44 - depending on what tools you use for
180:45 - concurrency since this is a kotlin app
180:48 - and i want the back end to be very
180:50 - decoupled from the front end we will
180:51 - manage concurrency and callbacks using
180:54 - co-routines so our first function here
180:56 - is called sign in google user this
180:59 - function takes in the id token we
181:00 - collected when the user successfully
181:02 - signs in with their google account this
181:04 - function is used to create a new user
181:06 - and to log in a user which already
181:09 - exists assuming they're using google
181:11 - sign-in as i explained in my kotlin
181:12 - course an easy way to move a
181:14 - long-running operation into a background
181:16 - thread in a suspend function is to use
181:18 - the with context dispatchers.io
181:21 - co-routine builder to wrap the function
181:23 - body
181:25 - my general goal with co-routines is to
181:27 - write code in direct style which is
181:30 - basically a word for no callbacks this
181:32 - makes code more legible and helps to
181:34 - avoid callback health so the first thing
181:36 - we'll do is we will request a credential
181:39 - from google auth provider then we're
181:41 - going to try and give that credential to
181:43 - firebase off
181:48 - so firebaseauth.sign in with credential
181:50 - returns a task object which we can add
181:53 - an oncomplete listener to in order to
181:55 - keep my goal of writing code in direct
181:57 - style we will create an extension
181:59 - function which will wrap the callbacks
182:01 - using the suspend co-routine builder so
182:04 - we're not actually going to write it out
182:05 - but i'll just walk you through it really
182:06 - quickly so we're going to be using await
182:08 - task completable what that basically
182:10 - means is we're going to await the task
182:13 - and we want to know if it completes or
182:15 - not but we don't actually care about
182:17 - returning any particular value in order
182:19 - to create this function we simply take
182:21 - in a task as a parameter and then we use
182:23 - the suspend coroutine builder so the way
182:26 - that this works is the continuation
182:28 - object is how we actually call back to
182:30 - the call site of the function which will
182:32 - be using our extension function here so
182:34 - what we do is uh we just add an
182:36 - oncomplete listener to our task object
182:39 - and we check to see if it's successful
182:41 - or not if it's successful we just resume
182:44 - the execution of the call cite function
182:48 - now i'm returning unit here because it
182:49 - doesn't actually matter what value i
182:51 - return and if it fails we call resume
182:54 - with exception
182:56 - let's see how that works back at the
182:57 - call site so what we'll do is we'll add
182:59 - a try catch block to wrap that
183:01 - particular function call
183:06 - now if it just resumes then like i said
183:08 - before it will just synchronously jump
183:10 - to the next line after await task
183:12 - completable in this case we will
183:14 - create a result wrapper result.build to
183:17 - signify that we just want to return the
183:18 - function successfully
183:21 - if we get an exception we will catch
183:22 - that exception and throw it also in our
183:25 - result wrapper
183:28 - all right so we only have two other
183:29 - functions to write out here so signing a
183:31 - user out is very easy at least in this
183:34 - particular application all i do is i
183:36 - just call off dot sign out now what i'll
183:38 - do is i'll just add that particular call
183:40 - into a result wrapper if it succeeds it
183:42 - will return unit which is basically a
183:44 - signal that things happen successfully
183:46 - but we don't care about any particular
183:48 - return value next we have get current
183:50 - user when the user opens the login
183:52 - screen the first thing the app does is
183:54 - request the current user from this
183:55 - particular backend function now it's
183:58 - important to understand that i've
183:59 - initialized firebase ahead of time in
184:01 - this class by calling
184:02 - firebaseauth.getinstance
184:05 - generally speaking you will want to
184:06 - initialize firebase ahead of time
184:08 - instead of calling it just before you
184:10 - call for example auth.currentuser and
184:12 - the reason for that is if you call
184:14 - off.currentuser before firebase is
184:16 - properly initialized then it will
184:18 - basically just return null to you no
184:20 - matter what happens
184:21 - that's even if the user is actually
184:23 - signed in
184:26 - so if off.user does equal null then we
184:29 - will actually just return null in the
184:30 - result wrapper
184:36 - we will return a user object now again
184:38 - this is basically just a plain domain
184:40 - model which will hold on to the uid
184:43 - and the display name of a user if they
184:45 - happen to have one
184:46 - now the truth here is that i don't
184:48 - actually use the uid or the display name
184:51 - for anything so i could actually just
184:53 - return unit here as well and that would
184:55 - function perfectly fine for this
184:56 - application
184:57 - so that's all you need to set up
184:58 - firebase auth and google sign in
185:00 - provider
185:04 - in this video i'm going to show you how
185:05 - to put together a room database using
185:08 - kotlin co-routines
185:09 - here's a quick overview of what we'll be
185:11 - doing in this tutorial first we will
185:13 - build a room entity which is kind of
185:15 - like a bridge between sql and kotlin or
185:18 - java then we will build a data access
185:21 - object interface which is how we will
185:23 - actually get the data in and out of our
185:24 - room database then we will look at our
185:26 - room database class and a bit of
185:28 - information on threading and concurrency
185:31 - and finally we will see how to perform
185:33 - crud operations on the database using
185:35 - co-routines code operations stands for
185:38 - create read update and delete just a
185:40 - quick reminder that as usual the source
185:43 - code for this example will be in the
185:45 - description box
185:46 - so let's get started entities in room
185:49 - are essentially a bridge between a java
185:52 - or in this case kotlin data model and
185:54 - the schema of an sql database in simpler
185:57 - terms an sql database is basically a
186:00 - spreadsheet and each property of our
186:02 - entity will represent a cell in that
186:05 - spreadsheet so to set up an entity in
186:07 - room what you want to do is you'll want
186:09 - to start with a basic data model like i
186:11 - have here so what we'll need to do to
186:13 - set up this data model for room is we'll
186:15 - need to add a bunch of annotations to it
186:18 - above the class declaration you will
186:19 - want to add the entity annotation this
186:22 - annotation accepts quite a few different
186:24 - arguments depending on what kind of
186:25 - configurations you want or you can leave
186:27 - it blank for defaults this annotation
186:29 - accepts quite a few different arguments
186:31 - depending on what configurations you
186:32 - want or you can leave it blank and it
186:34 - will just use the defaults table name
186:37 - and indices shown in blue here are what
186:39 - are known as kotlin default arguments
186:42 - table name basically states that i want
186:44 - the name of the database table to quite
186:47 - specifically be notes if you were to
186:49 - leave that blank then room would simply
186:51 - use the name of your entity class by
186:54 - default as for indices here i'm
186:56 - basically saying that i want this
186:57 - particular value creation date to be
187:00 - indexed and we'll actually see where
187:01 - that comes from in a moment but what the
187:03 - indexing does is it basically just makes
187:05 - it more efficient to look up these
187:07 - particular room note objects by this
187:09 - particular value creation date
187:11 - every room entity needs to have at least
187:14 - one primary key you can also create a
187:17 - primary key out of multiple different
187:19 - properties using a composite primary key
187:21 - but we won't worry about that here what
187:23 - this annotation does is it basically
187:24 - tells room that this is the actual value
187:27 - which we want to use to distinguish
187:29 - between the different objects in our
187:31 - database in essence we are saying that
187:32 - this is the unique identifier for each
187:35 - room note object now in case you're
187:37 - wondering creation date is actually
187:39 - created in the front end of the
187:40 - application and it's essentially just
187:42 - the system time at which the note object
187:44 - was created at and then translated into
187:46 - a legible date format another optional
187:49 - annotation is the column info annotation
187:52 - basically what it allows me to do is
187:53 - specify a different name for each column
187:55 - in the database and this is really just
187:57 - convention sql doesn't typically use
188:00 - camel case like in java or kotlin but
188:02 - you don't really need to do this if you
188:04 - don't want to
188:05 - one final note here if you've read the
188:06 - documentation then you're probably aware
188:08 - that room can auto generate and auto
188:11 - increment primary keys we don't do that
188:13 - in this particular tutorial but i just
188:14 - wanted to mention that that is a
188:16 - possibility it does have some
188:18 - consequences though when it comes to
188:19 - updating rows in the database which i'll
188:21 - talk about later next we have our data
188:24 - access object or dao now essentially
188:26 - what this is is it's just an interface
188:28 - with a bunch more annotations which
188:30 - we'll look at in a moment this dao
188:31 - object will allow us to give our room
188:33 - database a bunch of functions which we
188:35 - can call on it to manipulate our data
188:38 - basically what it'll do once we set up
188:40 - all of the annotations is it'll handle
188:41 - most of the work of writing really ugly
188:43 - sql queries if that's not something
188:45 - you're interested in
188:46 - now there's an important point here many
188:48 - people use live data with room and that
188:51 - is acceptable since i'm a big fan of
188:54 - clean architecture i don't actually like
188:56 - to be passing live data objects through
188:58 - my domain layer so instead of using live
189:01 - data objects for concurrency we are
189:03 - going to be using co-routines thankfully
189:05 - in recent versions of room it basically
189:08 - works out of the box all we need to do
189:10 - is just add the suspend co-routine
189:12 - keyword and this will actually make it
189:14 - super easy for us to get the data in and
189:16 - out of the room database without
189:17 - blocking the main threat anyways the
189:19 - first annotation that we'll need is at
189:21 - the top of the interface declaration
189:23 - just at dao for our first function we
189:26 - will use the query annotation
189:28 - so basically how this works is the
189:30 - particular things we put within this
189:31 - query annotation will be translated into
189:34 - proper sql this basically just makes it
189:36 - so that it's easier for us to read and
189:38 - write the particular queries
189:40 - this first statement here select is
189:42 - pretty self-explanatory but when it's
189:44 - followed by this asterisk it basically
189:46 - means select all from is also quite
189:49 - self-explanatory and just remember notes
189:51 - is what i called the actual database so
189:54 - basically what we're saying here is get
189:56 - everything from the note database now
189:58 - when we want to get a note by id
190:00 - basically what we're saying here is
190:01 - select any note from the note database
190:05 - where the creation date
190:07 - which is a particular column in the
190:10 - database matches this creation date
190:12 - string which we pass into this function
190:15 - so notice how in this particular case we
190:17 - have this colon followed by the name of
190:19 - the argument that we give to the
190:20 - function this is how we actually pass
190:22 - that string data into the sql statement
190:24 - delete is much simpler all we do is we
190:26 - just add in this delete annotation we
190:28 - pass in the room note object and room
190:30 - will sort out the rest of the details
190:32 - for inserter update i'm doing something
190:34 - a little bit more complicated now
190:36 - remember how i said earlier that room is
190:38 - capable of auto
190:39 - ids dynamically for you since we are not
190:42 - doing that that's actually going to
190:44 - allow us to use this kind of upsert
190:46 - functionality here so how this basically
190:48 - works is we pass in a room note object
190:51 - into the room database and room will
190:52 - search to see if there's any note which
190:54 - exists in the database that matches the
190:56 - one we passed in here if it does happen
190:58 - to find one where the creation date
191:00 - matches then we are telling it
191:01 - explicitly using the on conflict default
191:04 - argument to replace that particular note
191:07 - object so effectively what we have here
191:09 - is both an update and a create new entry
191:13 - in the database at the same time now
191:15 - this works because creation date does
191:17 - not change whenever we update the
191:19 - particular note object again if you're
191:21 - using dynamically generated ids you have
191:23 - to be a little bit more careful about
191:25 - that before we move on to writing the
191:27 - database it's worth mentioning that room
191:29 - will generate an implementation of our
191:31 - dao class in the build folder of your
191:33 - android project you don't need to look
191:35 - at it but for those of you who are
191:36 - curious about how room works under the
191:38 - hood it might be interesting in
191:40 - particular notice how it does have a
191:42 - reference to a room database object and
191:44 - also it does override the functions in
191:46 - our interface such as insert or update
191:48 - note delete note and so forth in the
191:51 - case of get notes as you can see here it
191:53 - does a lot of tedious work for us so
191:55 - that is kind of the magic of room next
191:57 - we come to the room database class now
192:00 - this class is basically just a bunch of
192:01 - boilerplate and i would not advise you
192:03 - to write this out by hand just copy and
192:06 - paste it and change what you need in my
192:08 - case i copied and pasted this originally
192:10 - from android sunflower which is from the
192:12 - google samples repositories anyways
192:14 - there's only a few things to mention
192:15 - here notice how we are referencing our
192:18 - room note class also for some reason we
192:20 - change the structure of our database
192:22 - schema we will want to increment the
192:24 - version by 1 or something like that and
192:26 - also notice that we have a function
192:28 - which returns our note dao object as
192:31 - we'll see in a moment we actually create
192:32 - the room note database object and then
192:34 - we request this room note dao from it
192:37 - and that's how we'll actually make calls
192:39 - to the database as for this companion
192:41 - object it's basically just a really
192:43 - powerful singleton initializer and it
192:45 - ensures that we never have more than one
192:47 - instance of our database in memory for
192:50 - those curious the volatile annotation
192:52 - ensures that no matter what thread tries
192:54 - to access the instance it will always
192:55 - get a current instance not something
192:58 - that's cached and therefore out of date
193:00 - also this synchronized block here is
193:01 - kind of interesting so this is a lock
193:03 - which is a concept you'll be familiar
193:05 - with if you've studied operating systems
193:07 - basically what this means is that
193:09 - whenever a thread of the application
193:11 - enters this particular code block it
193:14 - essentially locks it off so that no
193:16 - other threads can access it at the same
193:18 - time it will go about doing its business
193:20 - building the database or retrieving it
193:22 - if necessary and this essentially doubly
193:25 - ensures that this thing does not get
193:27 - created more than once now if you're
193:28 - just here to use a room database this
193:30 - kind of concurrency stuff is not really
193:32 - that important to you so if it didn't
193:33 - make sense don't worry about it i just
193:35 - thought it was worth mentioning one
193:36 - final point here just like our dow you
193:38 - can actually look up the implementation
193:40 - of your abstract database class in the
193:43 - build folder if you want to see how it
193:45 - works the code is really ugly but i
193:47 - always encourage people to actually look
193:48 - at the source code of these things to
193:50 - better learn how they work so before i
193:52 - show you how we manipulate the room
193:53 - database i just want to show you how i
193:55 - actually create it each feature of this
193:57 - class has its very own injector which is
194:00 - a very simple dependency injection
194:02 - container written by hand so how we
194:04 - actually do things here is we will
194:05 - create an instance of our room database
194:08 - which requires context but we don't
194:10 - actually want to pass a reference to the
194:12 - database itself rather we will call dot
194:14 - room note dao to get an instance to the
194:17 - data access object in this app i use a
194:19 - repository which handles both online and
194:21 - offline calls to different data sources
194:24 - essentially how this works is we just
194:25 - check to see if there is an active user
194:27 - if there is an active user then we will
194:29 - of course perform our operations on a
194:31 - remote firestore database if no user
194:33 - exists then we just write to our local
194:36 - room note database so this reference
194:38 - local refers to our dow
194:41 - so working with the dow is super easy
194:43 - again we're using cortines so note that
194:45 - these are suspend functions anyways all
194:47 - we do is we just call whatever function
194:49 - we want on the dao so get local notes we
194:52 - call local.getnotes and it's a similar
194:54 - situation for the other functions we
194:56 - have here now you may be wondering why
194:58 - i'm returning unit here in these result
195:00 - wrappers just note that for the case of
195:02 - deletes and insert or updates i don't
195:04 - actually care about returning a
195:06 - particular value so to satisfy the
195:08 - signature of these result wrappers i
195:11 - just return unit also note that in my
195:13 - result wrapper if an exception is thrown
195:15 - it will be gobbled up by the result
195:17 - wrapper so that's basically how i handle
195:19 - errors at the same time the only other
195:21 - thing we need to look at here which i've
195:22 - added as kind of a custom addition is i
195:24 - have a bunch of extension functions and
195:26 - properties to map to and from note
195:29 - objects and room note objects let's have
195:31 - a quick look at those so in this project
195:33 - i have a big file called
195:35 - dataextensions.kt and i put in a whole
195:37 - bunch of different extension functions
195:39 - and extension properties so this is
195:41 - pretty typical mapping stuff the reason
195:43 - why i do this is i don't want all of the
195:45 - different room dependencies to be
195:47 - passing through my domain layer so
195:49 - basically before i write to the database
195:51 - or retrieve data from the database i
195:53 - just make sure that i'm mapping to and
195:55 - from some kind of plain note object as
195:58 - you can see this is why i choose not to
196:00 - use live data i want to try and keep
196:01 - things as clean as possible
196:06 - and in this video i'm going to show you
196:08 - how to manage a firestore cloud database
196:10 - quickly and easily using kotlin
196:12 - co-routines before proceeding please
196:15 - create a new firebase project for
196:16 - android let's enable firestore through
196:19 - android studio to do this you can go to
196:21 - tools firebase scroll down to the bottom
196:23 - of the assistant tab
196:25 - there you'll see firestore click on that
196:27 - click read and write documents from
196:29 - cloud firestore
196:30 - and click add cloud firestore to your
196:33 - app if necessary click connect your app
196:35 - to firebase then click add cloud
196:38 - firestore to your app which will add the
196:40 - appropriate gradle dependency to your
196:42 - build gradle file next we will hop into
196:44 - the firebase console and set up
196:46 - firestore we'll start it in test mode
196:48 - which does not have any access
196:50 - restrictions on reads and writes but
196:52 - obviously you want to avoid doing that
196:53 - for production builds once that process
196:56 - is done we're ready to go firestore is
196:58 - schemeless so we can start adding data
197:00 - without needing to configure things
197:02 - further as discussed in a previous
197:04 - tutorial number 10 where we built a room
197:06 - database this application uses a
197:08 - repository to hide the details of the
197:11 - end from the front end how it works is
197:13 - that we first check firebase auth to see
197:15 - if a user is in in this get active user
197:17 - function and depending on what that
197:19 - result is we either make our operations
197:22 - on the local room database or we perform
197:25 - operations on the firestore remote
197:27 - database also note that i have created a
197:29 - specific data model for firestore notes
197:32 - the only difference here is that i store
197:34 - just the user id in the firestore node
197:36 - whereas in the other node object it
197:38 - stores a nested user object this makes
197:40 - it easy to serialize and deserialize the
197:43 - data and also keeps references to
197:44 - firestore out of my repository interface
197:47 - finally as usual i encourage you to
197:48 - check out the source code in the
197:50 - description box as this is an open
197:51 - source application let's take a look at
197:53 - the functions we will be implementing
197:55 - for firestore get remote notes will get
197:58 - all notes by a particular user get
198:00 - remote note we'll get a particular note
198:03 - by a particular user delete remote node
198:05 - is pretty self-explanatory and update
198:08 - remote note will be used to both create
198:10 - and update notes which already exist now
198:13 - like i discussed in part 9 of this
198:14 - tutorial i've created some quick and
198:16 - easy co-routine extension functions
198:18 - which wrap the calls to firebase as you
198:20 - can see here please watch the tutorial
198:22 - for a detailed explanation all of our
198:24 - calls to firestore and that's what this
198:26 - remote reference is here we'll start
198:27 - with this collection function which
198:29 - accepts a collection path argument of
198:32 - type string instead of having rows and
198:34 - columns which represent different items
198:36 - in a database firestore has documents to
198:38 - represent individual items or models
198:41 - grouped into collections so while it's
198:43 - important to remember that firestore is
198:45 - not an sql database this collection path
198:48 - is similar to the name of a table in a
198:50 - database if you happen to be familiar
198:52 - likewise each document is in some sense
198:55 - similar to a row or entry in a database
198:58 - table this app only has one collection
199:00 - and it's just called notes as we'll see
199:02 - with all of these different functions
199:03 - here
199:04 - we start everything by retrieving a
199:06 - collection and then we'll add some other
199:08 - functions to start manipulating it this
199:10 - call to the document function will
199:12 - either retrieve or create a reference to
199:14 - a document based on the path we give it
199:17 - now in this case the document path is a
199:19 - combination of the date at which the
199:21 - note was created down to the second
199:24 - combined with the uid of the firebase
199:26 - user this set function which accepts an
199:29 - arbitrary data model is how we actually
199:31 - populate our newly created document with
199:33 - the appropriate data so in other words
199:35 - what we're basically saying here is grab
199:36 - a reference to the notes collection
199:39 - create a document with this particular
199:41 - key or name or path and set the data at
199:44 - that path to be equal to the note which
199:46 - we passed in converted into a firebase
199:49 - note object in any case all we do is
199:51 - call this function here and if it
199:52 - succeeds properly we will return unit
199:55 - which basically just means hey this
199:56 - thing was successful and if an error
199:59 - gets thrown in away test completable
200:00 - then our catch block here will gobble it
200:03 - up and we'll know that something went
200:04 - wrong
200:05 - delete is really easy we just do exactly
200:07 - what we did before except instead of
200:09 - saying dot set we just call dot delete
200:12 - the process for retrieving a specific
200:14 - node is also similar in this case we
200:16 - call the same thing except in this case
200:18 - we will call get at the end of our
200:20 - change document request now this will
200:22 - return a task object which possesses a
200:25 - document snapshot so what we do is we
200:28 - call this to object function to turn it
200:31 - into a firebase so what we do is we call
200:33 - this two object function here which
200:35 - accepts some kind of data model in this
200:38 - case firebase note which is what i used
200:40 - to upload originally with and if we can
200:42 - successfully retrieve that i just turn
200:44 - it back into a plain old note object and
200:46 - then it's good to go forget remote notes
200:48 - which will return all notes for a given
200:50 - user again we request a particular
200:52 - collection and then we use this where
200:54 - equal to function which accepts the name
200:56 - of the field in firebase and then we
200:58 - just pass in the user id of the
201:00 - currently logged in user and then we
201:01 - call this get function now this
201:03 - particular task object will of course
201:05 - hold a list of document snapshots so
201:08 - what we end up doing is i pass it into
201:10 - this function here result to note list
201:12 - and it just returns everything as a
201:14 - result wrapper containing a list of
201:17 - notes that's just a basic mapping
201:19 - operation going on here so that's
201:21 - actually all we need to do to set up
201:23 - firestore it is ready to go and out of
201:25 - the box it actually works both online
201:27 - and offline which is pretty handy
201:34 - in this tutorial i'm going to show you
201:36 - how to set up dependency injection in a
201:38 - very simple modular way which does not
201:41 - require you to use a dependency
201:43 - injection framework this hand-written
201:45 - dependency injection implementation or
201:47 - build logic as i like to call it is
201:49 - suitable for small to medium scale
201:51 - applications
201:52 - if you are building a very large scale
201:54 - application then writing this code can
201:56 - be very tedious in which case i do
201:58 - recommend using dagger 2. dependency
202:01 - injection in simple english really just
202:03 - means giving an object its dependencies
202:06 - in the application we've been building
202:08 - our viewmodel classes talk to repository
202:11 - interfaces to perform i o operations on
202:14 - the data these repository interfaces can
202:17 - therefore be said to be dependencies of
202:20 - the viewmodel classes
202:22 - again the key difference here is that if
202:24 - the view model builds its own dependency
202:27 - as you can see on the right example here
202:29 - this is not dependency injection as i
202:32 - have said time and time again likely the
202:34 - most important concept in good software
202:36 - design is separation of concerns
202:39 - dependency injection is a form of
202:42 - separation of concerns except that
202:44 - instead of separating things like user
202:46 - interface code logic and data we are
202:49 - separating things which use dependencies
202:52 - from things which create dependencies as
202:54 - martin fowler summarizes it very well
202:57 - dependency injection is about separating
202:59 - configuration from use the way which i
203:02 - separate objects that build repositories
203:04 - from the objects which use repositories
203:07 - in this project is by writing an
203:08 - injector class for each feature of the
203:11 - application
203:12 - this class extends androidview model
203:15 - which is a subclass of view model
203:17 - designed to hold onto an instance of the
203:19 - application context
203:21 - the idea is simple for each dependency
203:23 - that i require i will write the code
203:25 - necessary to build that dependency
203:28 - and provide a public function which can
203:30 - be called for another class to get a
203:31 - hold of that dependency in this case we
203:34 - will be providing dependencies for a
203:35 - view model so we actually end up giving
203:38 - the repository to a view model factory
203:40 - object which we'll look at next note
203:42 - list view model factory is in some sense
203:45 - also an application of separating
203:47 - configuration from use this is the class
203:49 - i give the repository to and then it in
203:52 - turn gives that repository and the
203:54 - appropriate coroutine dispatcher to note
203:56 - list view model the only other piece of
203:58 - this puzzle is the place where we
204:00 - actually make our calls to our di
204:02 - implementation which in this case is
204:04 - within the onstart function of a
204:06 - fragment view model provider which is
204:08 - how we actually get a hold of our view
204:10 - models accepts a view model provider
204:12 - factory object as a second parameter
204:14 - which i showed you moments ago so all we
204:17 - do is we create an instance of the note
204:19 - list injector give it context so that it
204:22 - can build room and then invoke its
204:24 - function to return a factory there are
204:26 - many other approaches to separating
204:28 - configuration from use such as using the
204:30 - service locator pattern which i also use
204:32 - quite frequently
204:33 - the approach i showed you today
204:35 - hopefully gave you a way to start
204:36 - applying dependency injection without
204:38 - spending weeks configuring dagger 2.
204:41 - we've all been there and yeah it sucks

Cleaned transcript:

what's up programmers and subscriptors this is ryan here and in this course you are going to learn how to build a native android application using kotlin jetpack libraries and a little bit of help from firebase now before we jump into the android stuff please be aware that the audio quality does improve after the first section of this course be sure to check out the timestamps in the description box and also check out the pinned comment down below for links to more awesome educational content so that's it hopefully you enjoyed the tutorial what's up everybody this is ryan here and you are watching my jetpack notes mdvm android kotlin tutorial so in this video what i'm going to do is i'm going to demonstrate the application that we'll be building throughout this tutorial series or building in increments and then we'll also have a look at basically a huge list of topics that we'll be covering so that you know what to expect in this tutorial series so before we get to those finer details let's do a quick demo of the application jetpack notes has three features or primary user interface screens we're looking at the note list feature currently and as you can see we don't have any notes so it's kind of in an idle state so note list display displays all of the notes which are currently stored either in the local room database or the remote firestore database and the decision of where to save or retrieve notes is based on whether the user is logged in or not and that's actually a concern which is handled in the back end of the application so uh from this screen we can also create a new node so i'm just going to hit the plus button and we'll just create new oops i can't type new note like so and then i'll hit the check mark button this is also where you can delete notes and as you can see we have the new note here next thing i'm going to do is i'm going to hit the key i icon which will open the login feature and as you can see we are currently signed in so what i'm going to do is i'm going to sign out okay and then i'm gonna head back to the note list feature by hitting the back button and as you can see we have a totally different note currently present for because that is uh what's coming from the local room database so i'm just going to hit that hit the delete button and as you can see that's cleared that out and then we'll just log back in again sometimes it takes a moment there we go there we are and boom new note so that's a quick demo of the application and this is what we will be building in this tutorial so in order to follow along with the tutorial you're going to need to visit the repository link down in the description box below and you'll need to either clone or download the code so that you can follow along properly what i'll do is in each lesson i'll sort of go through with you i'll give you specific instructions on how to create a starting point so we're all on the same page and then we'll carry on from there this tutorial will cover both front end middle and back end topics for android development for front end we'll look at constraint layout simple android animations using animation lists using vector graphics which will basically allow you to have cool graphics and animations which will scale with whatever uh resolution or screen size you're working with i'll show you how to build a recycler view which happens to be the first thing i ever taught people to do on youtube and then we will look at implementing the navigation library from jetpack uh view models from android architecture components fragments and i'll do in the next video a big talk about model view view model frontend architecture pattern for backend topics i'll teach you about using firebase auth and google signin provider for quick and easy user management we'll look at using room and firestore for local and remote data storage respectively i'll teach you how to hide these things behind a repository so that the front end doesn't know or care where the notes come from and we'll also learn about simple dependency injection using android view model and view model providers to get everything nice and wired together and finally we'll talk about how to wire the endtoend application together using kotlin co routines and let me tell you i think you're really going to enjoy that part and in this video i'm going to be giving you an overview and kind of an examination of the pros and cons of using the model view view model architecture which is the architecture that we'll be using in this particular tutorial series we'll also have a quick look at the packages and files for the demo application just so you understand what's going on there now before we look at this pattern in detail i'd like to address what i consider to be a few misconceptions about not just model view view model but software architecture frontend gui patterns in general so i'm going to assume that most of you have heard about all kinds of different three layer architectures there's model view controller model v presenter model view view model which google seems to be putting all of their weight behind or sorry the android team rather and then we have other options like viper or there's model view intent by hannes dorfman and i'm sure what most of you are wondering is would someone please just tell me which one of these is the best architecture well i'm going to try and burst your bubble right now because in my personal opinion the answer and this opinion is fairly widely shared among senior developers is that the project requirements at hand will dictate the best architecture for you so one of the things that i've noticed over the years of trying several different approaches different patterns is that they work good in some situations and they can be uh counterproductive in others now it's better to follow an architecture which doesn't really work super well for your problem requirements than no architecture at all but what i'm trying to say here is that over time when you know things about all these different patterns you'll start to see okay well this particular feature of this pattern is useful in situation a but it's kind of a problem in situation b so what i would like to do is basically explain in this video that uh model view view model is not an exception to that rule it is not necessarily the best architecture for all situations even on the android platform but it does have some benefits and some deficits so what i would like to do is basically give you an idea of what those benefits and deficits are and uh yeah we'll get into that in a moment but before we talk about that i'm going to try to give you like a general overview of the architecture using whiteboard example okay so what we're going to do now is we're going to talk a little about the model view view model front end graphical user interface pattern before i jump into this one thing to note is that unfortunately developers do not always consistently build these things the same way so what i'm going to explain to you is a generalization this is my interpretation of the model view view model architecture but like i say you're going to find different variations of this and the most important thing for you to know is that different variations will work better in different situations so what exactly happens how does it work so the first and most important thing the the defining characteristic of model view view model in my opinion is that uh essentially we have this thing called a view model in the middle which encapsulates the both the behavior and the state of the front end of the view both the behavior and the state so state being the data and the behavior being what do we do when some event happens kind of deal so the thing that's unique about model v view model is that the this thing in the middle the view model you're not allowed to have this view model actually directly tell the view what to do i'm not allowed to draw a line from here to here which would be a dependency so if you're doing model v presenter you are allowed to do that in model view model you're not based on my interpretation instead what happens is we basically have to have two dependencies two different channels from the view to the view model this is typically how we like to set it up so one channel is just synchronous and this would be the kind of thing where let's say for example if we're coding for android or whatever the user hits a button and then the view can just if you know just do a synchronous call just a function call to the view model hey this button was clicked so that's one of the ways it can communicate with the view model the other way and this is how it actually gets the data out of the view model and this is confusing for some people is that do you see this eyeball thing here this is my representation of what's known as the observer pattern so you could use data binding what i like to do is i like to use basically a producer consumer consumer relationship or the observer pattern it's called between the view model between the view and the view model so basically what i'm saying here is at the start at some point the view model will ask for observables so it's going to ask for something from the view and this thing that it it gets sorry it's going to ask for something in the out of the view model and when it gets that object that observable object i want you to think of that observable object as like a pipe that data pops out of at on indeterminate time whenever the data pops out of the pipe whenever the v model asks the model the back end for some data it's going to then publish that data and if the view is listening then the view is going to grab that data that pops out of the the observable pipe and then it's going to render that on the screen so that's basically how model view view model generally speaking works so one of the things to keep in mind about this is that the the benefit of model via view model is can also be the deficit so one of the main benefits of it is we can have a many to one ratio of views to view models and that's because the view model does not depend on any view specifically the cost of that is that you lose finegrained control over what the view does so naturally in many cases you're going to have to actually have more logic in your view because the view is going to have to be able to interpret what's coming in from the observable streams so there's different ways to solve that and the logic isn't necessarily going to be super complicated but this is one of the things you want to think about when you're working with model view via model in particular so now that i've given you like a general overview of the pattern i just wanted to get a little bit more specific about the things i am fond of and not so fond of in this particular architecture with the hopes that it can help you inform your decision about whether you think it's a good idea to use it or not so the most important thing just to start with the cons here in this particular architecture is that the synchronization between the view and the view model presents a problem of separation of concerns if you're not sure what separation of concerns is i've written an article and i'll link it down in the description box below and it'll basically explain my perspective on separation of concerns but i actually do consider it to be probably the most important principle to observe in software architecture anyways the reason why the synchronization logic can be awkward and there are ways around it is because we don't have that fine range control over the view so this means we have basically two options and these are kind of what i would consider to be subsets of model view view model so option number one is to basically fill the view with a whole bunch of logic to interpret the data which the view model publishes to it so this approach will allow you to have very reusable view models but it's going to basically make it so that you fill your fragments or whatever view class you're using with a whole bunch of logic when you fill something with a whole bunch of logic that's really the time when you really need to be careful about testing now i personally don't like to test ui classes instead i use humble object or passive view which basically makes those classes generally speaking oneliners and it makes them simple enough that they don't even directly need to be tested if you don't take that approach and you want to fill your fragments or views with lots of logic you will need to probably use espresso or roboelectric to make sure that you're testing everything adequately so one of the ways around this and this is the key problem is the presentation logic is awkwardly distributed between the view and the view model one of the ways around this is to actually make it so that your view model knows a fair amount about the particular view that uh it's working with so what i mean by that is it's not that it has a direct dependency but you can fill your view model with all kinds of in this tutorial would be like live data observables uh you can fill it with a whole bunch of these observable fields which will dictate for example should this text box be highlighted or this that and the other basically details about the view without actually having a direct dependency so this will allow you to basically pull a lot of logic out of back out of the view and into the view model and that's going to make for a much easier to test view the caveat to doing this is that if you have all kinds of details about a specific view in a view model even if there's no direct dependency you are still tightly coupling that view model to that particular view so you lose the reusability of the view model if you take that approach in exchange for not having to have a whole bunch of logic in your fragments so with those considerations in mind which aren't necessarily application breaking but as you can see there's not actually a truly specific model view view model pattern here there's actually some variations in it and this is something that i've even heard the android team admit when they were looking into this particular pattern so as you can see we've kind of got these different approaches to it and they're going to have different benefits so if your user interfaces are like super simple then you're probably going to be able to get away with having fairly decoupled unspecific view models and that's kind of one of the main benefits of this particular approach is that if you don't tightly couple your viewmodels to particular views great english here um then you can promote the reusability of those view models uh side benefits is of course you are applying some kind of separation of concerns by separating these things out so you're going to get some benefits to testing and modularity as well and one important feature which this is something that's specific to android's particular tools so android architecture components and jetpack and that but one of the biggest benefits uh for this particular approach on the android platform is that concurrency and lifecycle really is a breeze when you apply this particular architecture and you use their components so the final more detailed point i'd like to make on this particular architecture is that if you confine yourself to just having model view view model then you are definitely well i won't say definitely but probably going to run into problems where you have this awkward separation between the synchronization logic of the view model and the view and you have to kind of pick one path or the other reusability or not filling your views full of logic there's actually another solution which you can apply which is actually what i apply in my production code i don't confine myself to just using model view view model in fact most of my architectures when you look at them you'll usually see something which is something along the lines of like model view presenter view model and the view model has a different role it's not so much a logic class as just a front end session data container so anyways the point of that is just to say here for the people listening this certainly do model view view model and carry it as far as you would like but if you get into a situation where you have this ugly awkward division of presentation logic between this the view and the view model another option is to actually create a fourth class like a presenter call it whatever the hell you want i just call it a logic class and then you can actually pull out that logic again decouple it from the view model and then you can have this sort of fourth object handle things like click events it's going to simplify your view models and i would kind of suggest that as you start to build more and more complicated applications if you're building simple applications though usually you can get away just fine with just having the view view model in the model so the last thing i'll be doing in this video is giving you an overview of the package structure of this particular application so the repository is at jetpack notes mvvm kotlin under bracket cove link in the description box down below and what we'll do is we'll just open up the app module here let me just zoom in a little and i just wanted to talk about what's within the main package here so we've got four primary packages or directories so within common you're going to find classes which are shared across different parts of the application so that's why we have this common module here so this is where i like to put things like for example base classes so we have a base view model which is like an abstract class which shares some code across a set of different view models constants and a lot of extensions so there's a lot of ugly kind of data mapping stuff and this is something that basically converts from a firebase task into uh uh rxj or sorry co routines not rx java force of habit and yeah just all kinds of mappers and stuff like that so uh we'll be going into more detail but i just wanted to give you a quick glimpse there so that's uh common uh we have the basically two primary features of the application so we have the login feature and the note feature within login you'll of course find the login activity login event login view and user view model and then in each of these feature packages you're going to find a sub directory called build logic which will basically contain the dependency injection and user review model factory stuff to create the view models no dagger 2 required so everyone can chill the chill out about that so anyways one important point here is that i did actually try to do a single activity approach in this particular application as per what they suggest in navigation i was not able to due to tight coupling to on activity result which as of making this tutorial is not supported by the navigation library if you're watching this in the future it may be now and that is probably my biggest criticism of the navigation library at this point is that it did not support on activity result which is problematic anyways i will be demoing the navigation library in this tutorial but i even though i tried to do single activity i literally couldn't so there's two activities and three features next we have the model package so this is basically going to contain everything which is related to storage and access to data so we're thinking repositories implementations firebase stuff room stuff data models that kind of stuff like i say we'll go into more detail later so then we have the note directory which contains all the different files necessary for the note detail and the note list features so as you can see here it's pretty much what we like to call package by feature approach but something which isn't doesn't necessarily fit into a particular feature i will put that in a common directory so within the note package you see we have the note detail and note list subdirectories and these this will contain the views and view events and build logic for this particular ui screen and i chose to group them together because they both work on the same concept conceptual note object and then we of course have the view models and factories and stuff like that for these different views so that's it for this particular video hopefully you learned not just about model v view model but a little bit about software architecture in general and my goal here isn't to crap on model view view model or to say that you shouldn't use that approach i think you can build beautiful applications with this particular pattern what i wanted to do though is kind of explain to a lot of the beginners out there who are confused about this particular point that the big kind of consideration with this architecture is that synchronization between the view and the view model can be a little bit awkward there's ways to solve it though and we'll talk about that as we progress through the tutorial so for starters i'm going to show you how to find free open license images like the one this animation is based off of i'm going to show you how to create scalable vector graphics out of these pngs or raster graphics using some free tools i'm going to show you how to import those vector graphics into android studio so that we can actually use them in our applications and finally i'll show you how to create some simple but effective animations which scale and it won't require you learning 15 different animation apis because we all know there's quite a few different animation apis on the android platform so if all of that sounds interesting to you please do consider hitting the like but like button down below consider subscribing and with that let's jump into some discussion on vector drawables and graphics versus raster drawables and graphics now you may be wondering what exactly is a vector drawable and how is it different from say like a bitmap png jpeg or all those other formats that you're used to working with well the key difference is that bitmaps or pngs or jpegs all those sorts of things which are known as raster graphics are in essence a collection of bits bitmap hence which ultimately represent pixels drawn on the screen so for example if we wanted to in a raster graphic type format render a triangle then ultimately you're going to end up with something that looks about like this if you zoom in close enough so we want to think of like each sort of segment of some screen or device has a finite number of pixels then we basically say these are the pixels that we want to draw this is the color and you end up with something like that so the problem with these particular formats which are as i said known as raster graphics is that they don't scale well across a variety of different displays or resolutions one solution to this is to provide many different versions of the same images the same image which have different resolutions so on a really high quality device you're going to provide a much higher resolution icon or image or something like that while this kind of works the problem with it is that you can end up with a situation where you're bloating your packaged applications or taking up a whole bunch of your users data by downloading a whole bunch of really large image files so if possible we kind of try to advise against having just a huge number of image files in your apk so as opposed to having say a finite number of pixels represented in some kind of collection format vector drawables take a different approach so essentially what we're doing is we're supplying a series of coordinates and you can add much more detail than just coordinates but say for example if we wanted to render a triangle we would for example give in this file we would write down a series of points so for example x1 y1 x2 y2 x3 x3 y3 and then what you would do is you would instruct the computer to draw say lines of a particular color between these points and as you can see the benefit of doing this is that the actual work of figuring out the scaling and resolution and how to render it on a particular device screen uh it's done on the fly and it's independent of a finite set of pixels so that's a big fancy way of saying it makes it scalable it's basically like saying hey here's what i want you to draw and then the computer basically figures out the mathematics of doing all the scaling and stuff like that the end result is that you get images one image file which can be rendered for basically almost any kind of screen size or zoom level or things like that the vector graphic we'll be creating today forms the basis of the rocket ship animation in my jetpack notes android architecture components application so just an important thing to point out notice how this animation scales really quickly and easily to a variety of different screen sizes as you can see here and so what i'll do is i'll show you where i got the basis of this particular image from please visit the repository link down in the description box below clone the application and in this application you're going to find a png image file which is of course a raster graphic type file and what i'd like you to do is go ahead and download that repository and this is the file that will be basically turning into a vector drawable so you don't have to download it from say open clipart so if you happen to have a more allencompassing video editing software tool like photoshop or something like that chances are it does have the option to export from say a bitmap or png to an svg file or some other kind of vector drawable if you have that option do export to svg and you can basically skip this part of the tutorial i'm going to be using inkscape and the reason for that is does not actually allow you to export to svg inkscape is a free open source software so that's why i chose it in particular but you can use whatever you prefer to create your vector drawable so what you want to do is go ahead and open up the particular png file rocket underscore one dot png from the repository and you're going to need to select it so click on it and hit control a and then go to path trace bitmap now there's a couple different options you can select here you're going to of course want to pick the option which renders your image as you prefer i'm going to select colors like so and as you can see here that looks about right i'm also going to click remove background and then we'll hit ok to actually execute the trace and looks like it has worked and now we have our traced out svg uh file going on here our collection of paths and the last thing we need to do is go to file save as and you can just save it right into the same drawable folder that you grab the png file from i'm going to name it the same thing just make sure that for the save as type thing you have selected here you're going to want to pick inkscape svg all right so we've created our svg file through inkscape but as you can see here it has a whole bunch of metadata and crap in here that we don't actually really want to include in the thing that we'll be using in our project so what we're going to do is you can just go right click on resources or drawable select new vector asset like so so uh just a quick little tip here if you in the asset type field here if you select clipart and then you can and then click on this clip art icon here you can actually select from a whole bunch of premade icons and then create vector assets in android studio out of those as well so just a quick little tip you don't have to go to the website and download these assets you can do it right here and this is far more efficient anyways we're going to go to local file and so go ahead and give the thing an appropriate name so i'm going to call this we'll call it i am for image and we'll call it what was it called uh let's say rocket one for example and then we need to of course select it uh find it in the path variable here so we're going to select rocket 1 svg like so this particular size variable can be easily changed and it's not actually that important i do like to leave the opacity on 86 percent especially in like a dark themed application like this one so i'm going to leave that at where it is and we can basically just leave all of these different defaults here once that is selected we're just going to hit next i'll pull this into view and it's going to tell us that the output directory is going straight into drawable that's totally fine res main is fine and go ahead and hit finish so what that has done is as you can see down here that's created a new uh drawable this one's called ic rocket one i thought i typed i am rocket one but i'm i'm totally confused now anyways uh so what you can do is go ahead and open up this thing and just notice that it's also an xml vector drawable file but it's just a little more purposebuilt for android we have our android variables in here and that's basically all we need to do to import our svg drawable into android studio and then now what we can do is we can just refer to this particular xml file like any other kind of drawable and it should show up uh appropriately so one of the easiest ways of thinking of and designing animations is just to suppose that we have a series of still images being looped through over time kind of like a projector with a film reel if you ever go to the movies so uh what we're going to do is we're going to create an animation list xml file it's going to be super easy and in this list we'll supply a series of different drawables to animate through and that's kind of how we'll actually create the animation effect so in android studio what i'd like you to do is you're going to right click on the drawable folder go to new drawable resource file and what we're going to do is we're going to call this thing rocket loop 2 i'm going to call it that because there's already a file called rocket loop and you can leave the qualifiers in that as defaults so the first thing i'm going to do is i'm going to change this to an animation list as you can see here and then in this animation list is where we will supply the different drawables that we want to loop through so we're going to create items and we're going to say item android drawable and so what we're going to do is i'm not going to show you the whole process of creating all three different drawables but what we want to do is we want to supply our scalable vector graphics here so the thing we had was i am actually got turned into ic rocket one and what we'll do so that's the one we created in this tutorial i'm actually just going to change this back to the default so this is i am rocket one and you can do this too if you downloaded the repository or you can use the ic rocket one i don't really care and then what we're going to do so we've supplied a particular drawable then we want to supply a duration in this case so i'm going to type 200 which is about a fifth of a second so this is going to be a pretty quick animation and then we can go ahead and close off that particular xml tag there i'm going to click at the end here and hit ctrl d twice and that's just going to copy to the next line and then of course we're going to add i am rocket 2 and then i am rocket 3 like so and that is it for our animation list so go ahead and create that and then finally we'll look at how to actually access this thing in the code all right so i've opened up fragment note detail xml which is the thing i demoed earlier and so what you can do here is uh using either an image button or in this case an image view you're going to want to specify the source of this particular uh view as being the animation not of course the drawables so go ahead and do that and then what i'll do next is i'll show you how to actually get hold of this thing and start the animation in the java or kotlin code alright so i've opened up note detail view which is in the repository and what we'll do now is we'll see how to actually start our animation list going so uh just a quick note here if you're wondering why there isn't any fine view by id or anything like that going on in this particular file it's because i'm using kotlin synthetic properties for the user interface but in any case however you prefer to get a hold of the particular views in xml you're going to want to do that if you have to use find view by id that's fine so what i'm going to do is i'm going to scroll down to the function where we actually start this animation drawable i'm just going to give us some more room here so the way that we actually start these drawables going is you're going to want to get a hold of the actual view uh which possesses the animation and then you're going to get a hold of the drawable so you could say say in java imv imb no detail satellite dot get drawable or something like that you're going to want to cast it to an animation drawable this is how we do casting in kotlin and then the function we want to call is start so what that's going to do is in this particular case that's going to start our animation here going now in this particular feature of the application uh the animation just runs uh permanently just as a little visual ui effect so i'll show you a few other little options for these particular animation list drawables okay so what i've done is i've opened up note list view which has a few more things going on with these particular animation list drawables or animation drawables rather so uh first off i've showed you how to start just a plain animation there are other animations in this uh particular application so there's actually a background space animation which is always looping and one thing in particular i do with that and i've actually just added this into an extension function in kotlin so i'll show you what it does so basically if you want to specify say a fade animation then you're going to want to set the enter fade duration set x at fade duration and then that'll allow you to fade between the particular drawables we don't need to do that with the rocket ship animation but it works nicely with our space loop animation and then of course we call start to actually get it animating now in this particular feature depending on what goes on we do need to actually stop the animation so when you want to do that again you're going to want to cast the drawable of the view that possesses the animation and then you just want to call stop as we see here so that's basically it so what we're going to do is we are going to build the login form of the space notes application quite specifically we're going to be building this layout and the purpose here is to teach you some of the basics of applying some principles of material design and also the basics of using the constraint layout effectively because one of the things with the constraint layout is that uh there's a way you can work with the tool in the design editor where you're clicking dragging like 50 different constraints and attaching all these things together and then more recently they've added some features where we can streamline a lot of a lot of that process so that'll be the main focus of today's video also talk a little bit about uh styles and a couple different things like that but yeah let's get started so before we build the layout itself i wanted to talk about some styles and resources that we'll be using so we will be using animation drawables for the animated background the space animation and also for the antenna animation and we'll also be using some vector drawables for our icons and also the antenna animation so if you're not familiar with those topics what i'm going to suggest you do is head over to the previous video in this series number three because in that video i cover how to create uh vector drawables and animation lists and how to do that with totally free tools and if you're curious about what a vector drawable is uh just go watch that video but understand it's uh you don't necessarily want to use them everywhere but the benefit of using them is that you can have one file which scales to multiple different resolutions as opposed to having to supply images for each particular resolution so definitely consider checking that out but what i'm going to ask you to do now is in the description box below there is a repository a link to the repository that'll be which contains the code that we'll be working with so hopefully you've already done this before but if you haven't and you're just jumping into this tutorial series go ahead and clone or download that code because that will be the basis from which we uh work from we'll also be using some styles which are located in the view styles xml file so the purpose there is just to remove some redundant xml attributes and try to get it so that if i need to change something i'm only changing it in one place i won't be going into detail about that in this particular tutorial but do consider checking that out because as you'll see we'll be adding some styles to our layout files for that purpose all right so the file that we're going to be rebuilding specifically is fragment login so hopefully at this point you have downloaded or cloned the repository if not you can of course still follow along with what i'm doing here so uh yeah as i say we're going to be rebuilding fragment login and in order to have the code easy for you to reference just go ahead and right click on the layout folder go to new layout resource file and we're going to create a new one called fragment underscore login underscore demo like so and go ahead and set the root element as a constraint layout there's a couple different options here so just make sure you select the constraint layout but if you have to change it later that's fine too there we are and we are ready to get started so first thing let's go ahead and give it an id here so i'm going to type id at plus id and this one's going to be called root fragment login just be aware there's going to be some overwrites here because we have the same layout in a different file but that should make things a little bit easier in terms of auto complete so yeah we've added an id to that layout and then the next thing we're going to want to do is set the background like so so the specific background we're going to be using is called space loop like i said before if you want a detailed explanation of how to set these things up you can you're going to want to watch the previous video but let me just open up space loop really quickly here so that was just ctrl shift n to open a file and this is basically what it looks like here so as you can see we've got a couple different drawables uh the root tag is animation list and the duration is basically uh it's going to loop through these animations kind of gradually this will be a like a two second delay and these drawables just are so you're aware these ones are going to be png files whereas we'll see with the icon animation they are actually vector drawables so anyways so what i'll do next is i'm going to click on this image button and just click and drag it into the top left corner of the screen like so this is going to open up a dialog to select some kind of resource so you can select some kind of premade resources that they provide for you for different uh just like kind of placeholders and icons and all kinds of different things in this particular case uh we also have these really horrendously weird looking avatars i have a specific file in mind which i've added ahead of time so the drawable we'll be using in this case is in the project tab and we're just going to navigate to let's see here this is going to be i see arrow back black like so so i'm just going to click on that it's not actually black as you can see here but that's fine so i'm just going to click on that and hit the ok button and that has added in this particular image button drawable so what we're going to do first is i'm going to show you one of the ways to kind of manually set the constraints for a constraint layout and then for the rest of this particular layout we'll see a way to do it way quicker that works in certain situations so the first thing i'm going to want to do is now that i've dragged this thing into a particular area of the screen i'm going to want to basically constrain the top of this view to the parent top so i'm just going to click and drag and then kind of bring it to the top of the screen here can't really see what's going on in this editor so let me switch to the blueprint editor here and i'm going to click and drag to the left side of the screen and as you can see that has constrained our back button like so and what i'm going to want to do is i'm just going to want to play with the margins a little bit i think i'm going to do 16 by 16 for the margins uh sorry for the very crowded screen so um we're almost done with the image button and this is going to be like our back button here but one thing i wanted to do is i want to make it so that it it's actually styled like a toolbar button since we're kind of doing a custom toolbar so one of the hacky but totally legitimate ways i do that is i type style so this isn't actually a style which i created i'm just going to type at style slash widget dot app compat and then we're going to select action button so that's going to do a couple of things it's going to remove that ugly sort of dark gray background it's also going to add things like an animation when the image is clicked and things like that so it's just going to add a bunch of styling information and i do recommend that you do that now in the text editor we're also going to want to rename this view so i'm going to call this thing imb toolbar back like so and that's basically all we need to do here so one quick point you'll notice that here android studio has automatically added this source compat attribute here so this is because we're dealing with uh vector drawables so just uh one quick thing to point out here if you're basically targeting applications on api lower than 21 then this thing isn't actually going to work properly with all views and i'm not sure if it actually is back ported to everything but if you're using vector drawables you're going to want to go to your app level build gradle file or module level build gradle file whatever you've called it you're going to want to add in this vectordrawables equals or vectordrawables.use support library thing into your build gradle file now in this case because we are only targeting api 21 and above i don't think that's actually necessary but just for backwards compatibility i wanted to mention that okay so what we're going to do next is we're going to add a whole bunch of different views to the layout and we're not actually going to manually set the constraints because that can be quite tedious and instead we're going to use one of the helpers in order to do that for us but before i worry about the constraints we're just going to add the views into the layout set the ids add a little bit of design time attributes so we can get a rough idea of what it'll look like and then we'll figure out how to do the constraints so i'm going to open up the palette and so we'll start with a couple different things here so first and foremost i'm going to want a text view and so our goal here uh basically when we click and drag these into the design time editor here they're not constrained but they're going to set like an absolute value of where they're positioned so i just want to kind of roughly position them where i think i want them to go and that should be adequate so we have our first sort of login status drawable then we're going to add in this is going to be an image view so we'll go to common and it's of course going to take us through the dialogue here so what we're going to do for this particular image view is it's going to be antenna loop is the drawable that we're looking for so again this is actually an animation animation list in resources and so i don't really want it there let's just kind of position it right there and we'll have to fiddle around a little bit with some of the attributes in a minute so i've got that thing positioned there and then we have another text view below that so i'm just going to click and drag i know this isn't super visible it's okay we'll figure that out in a minute all right so we've got that text view and then finally there's a button so we're just going to click and drag that down to the bottom and there we go so as you can see we have a basic setup but everything is really ugly so the next thing we'll do is we're going to hop into the text editor and then just set a couple of things very often what i'll do is i'll spend most of my time in the text editor but when it comes to like setting up the actual constraints then oftentimes i find it easier to do it in the design editor so the first thing i'm going to do is i'm just going to fix all the different generated ids so using uh whatever convention you like as you can see i have some habits of mine from other platforms but we're going to type lbl this one's going to be called login status header then we have our image view so i don't want this thing to be wrap content wrap content this thing's actually going to be 128 dip anyways we can fiddle with that in a minute uh for its id that's going to be imb antenna animation like so so i'm trying to find an adequate zoom level here that's not too obnoxious and uh yeah then we've got our text view so this one is going to be called lbl login oops login status display and then we have our button at the bottom so this one is going to be called btn auth attempt so you don't have to use my particular convention for naming these ids but i do suggest you use a convention i'll probably end up switching to camel case for these because using kotlin synthetic properties i end up having to have this ugly underscore case in my kotlin code so just something to consider all right so i wanted to set the ids in particular before we go messing around here with the uh constraint layout editor because uh once the constraints are set you need to mess around with the ids afterwards if you change them so now that we've got that set let's hop in back into the design time editor and so in this case uh i see that the image view has gotten positioned a little bit weirdly so i'm just going to again kind of manually position these things where i think i want them something about like that and then what i'm gonna do is i'm going to switch to the blueprint editor here just so we can have a pretty clear view of what's going on and then what we'll do is so i'm going to click on each of these views and holding shift i'm going to select all of them alright once we have everything selected just right click on one of the views and go to chains and then we're going to create a vertical chain so what that's done for us is it's basically constrained all of these views to each other and the parent as you can see in this sort of chain so let's just hop back into the design editor for a minute so as you can see we have everything kind of aligned horizontally the way we want but the actual spacing here is pretty ridiculous so what we're going to do is we're just going to click on this little chain icon here and this is going to change the type of chain so there's a couple different options there is let me just grab my notes so there's going to be spread inside spread and packed in this particular case we're probably going to want packed i think that's not it there we go something like that okay so we've got these views roughly where we want them what i'll do next is i'm just going to select each of them and then we're going to constrain them horizontally so again just click and holding shift select all of them this can be a little bit tricky with these buttons popping up just be aware that and then once we have these things selected i'm just going to right click on them and then we're going to go to center and then we're going to select horizontally and what that's going to do is it's going to horizontally constrain all of those views and as i said before this is a lot quicker than having to do this manually that's how i used to do it and it works but it's kind of tedious so one of the main takeaways here is just learn a little bit about these different options that they provide you in the editor and see if you can use them to expedite the process of building your layouts a little bit quicker okay so we've got everything roughly where we want it to go so the last thing we'll do is we'll play around with some of the specifics here just to get a more material design and stylish look so up here we can probably add some design time text to this particular view actually this thing i believe is always login status so we'll just set it to that and looks like that thing needs a little this bit of styling so i'm going to type style and we're going to use yeah that's the one text.primary.login header and that should just give it a larger font size as you can see here it's looking a little bit better uh we'll move down to the image view and for the image view it's already pretty close to being good to go one important thing if i wanted to support tablets and things like that i would probably not want to actually hard code these layout height and width values instead i would want to provide them in resources but like i say we're skipping a couple of things here for the sake of the tutorial anyways so what we want to change here is that uh the sizing is all good but we would prefer a white drawable in this particular case on the dark background so i'm going to type android tint and we're just going to hard code in ffff6fs which is the hex code for white and as you can see here that's looking like that so let's move to the next text view below so this one the text changes frequently i'm just going to type tools text instead and so we're going to type signed in as one particular example status and then we also have some styling for this view so this one is i believe text.primary.loginheader.sub yep that's looking a little bit better and finally let's head down to our button so i've made another special style attribute for this thing which is going to be style slash off button and this is the button that i actually used to trigger the google signin so anyways the text for this particular button is going to be uh it changes frequently at run time but we're just going to type tools text and then we're going to type sign out like so and let's just have a quick look at what that looks like all right not looking bad so that's basically it for the xml stuff here as far as the layout is concerned i know earlier i mentioned i wouldn't go into detail about the styles but i thought i would just show you a little bit about this particular file viewstyles.xml and so one of the biggest tips i can give you in terms of giving like a nice material design look to your application um use the sans serif uh font families and that'll give you some nice roboto fonts and then also the different sizes that i use to basically come from the android material design documentation so well the google's material design documentation rather so i do highly suggest you check that out and just try to follow what they recommend as best as you can but also you know feel free to take some creative license over what you do as well also one quick point with uh styles that you can actually use them like in sort of a css way so you can overwrite different values but also inherit from parents and and stuff like that and i use that quite frequently and in today's video i'm going to be showing you how to set up the navigation component from android jetpack so firstly as of making this video the navigation component does not work out of the box with on activity result i did see a couple people had some really hacky shared mutable state solutions for solving this problem but i wouldn't actually recommend them when it's actually easier to just not use the library in the activity which receives the result which is what i chose to do in this particular application so that's kind of one of my criticisms here is there's kind of a strong push to move to a single activity approach and this was one case where i wanted to do that and couldn't based on framework limitations now like i say as i'm making this video i have seen that there's some discussion about adding integration with navigation and on activity result possibly in later versions although it doesn't appear to be a very high priority anyways in fairness if you're watching this video several months or even years from now there's a chance that it has been integrated with the library and if that's the case then that would make me very happy i was also told recently by a friend of mine davora maric who's an awesome programmer that navigation does not play nice with few pagers and fragments so another thing to be aware of so while i'm not really happy about some pretty common use cases having some problems with the library i think those are things which hopefully will be improved on over time so let me get to the second reason why i'm not super happy with the library so i just didn't really feel like the steps required to implement navigation and the fact that we're basically pulling logic out of kotlin code or java code and putting it back into xml was really worth the effort of setting up relative to the problems that it actually actually solved in my applications so what i'm basically saying here is uh what this library will do for you is it'll allow you to basically get rid of some of the fragment transaction or start activity type logic which you would normally use to navigate to different screens in your application and so it's not that we're actually just getting rid of all of that logic in a sense we're basically pulling a bunch of it out into an xml file and then we're having this framework generate a lot of that logic for us now if you get fast enough with the visual editor and you're familiar with all of the features you can actually write this logic pretty quickly using the tool but i just wanted to mention that relative to say handwriting this code with kotlin extensions or something like that i didn't feel like i saved much time okay so with all that criticism in mind and let's just keep in mind this is a fairly new tool i did like the navigation feature in the parts of the app where it didn't cause any problems it worked quite well in that regard in particular i do like the say fargs option for basically sending type safe arguments between different screens of your application and i will be demonstrating that feature today finally if you'd like to follow along with this tutorial please clone or download the repository link in the description box down below okay so the first thing we'll do is we'll look at configuring this thing with gradle so in your build script function here in your project level build gradle file we need to add a particular configuration to the build script dependencies in particular we need to add this thing here android x dot navigation colon navigation safehargs blah blah blah and once you add this thing in uh that's going to allow you to use the safe arcs plugin and what we'll do next is we'll see how to add that to the module level build gradle file in the module level build gradle file you're going to want to add up at the top here apply plugin androidx.navigation.safeargs.kotlin now if you're in java you're going to want to probably delete the dot kotlin and i think that's the appropriate plugin for java anyways uh down in the dependencies the two dependencies that we'll really be working with are the navigation that fragment dash ktx and the navigation dash ui ktx so again i think if you're working with java or something like that you just delete the dash ktx and it'll work work for you but there is a page where you can figure out the particular dependencies so just go check that out in the android documentation okay so let's get started building out the navigation component so the first thing we're going to need is a navigation graph and this is basically like an xml resource which specifies all the different destinations which our navigation component can travel to along with plenty of other details so what i'd like you to do so presumably you have downloaded the repository so go ahead and in the res navigation directory just notice we have this file nav graph which is what we will be building what we'll do is we'll create another file so i'm just going to right click on navigation we'll go to navigation resource file we're going to call this nav graph demo you can call it whatever you like and so what we'll do is we'll basically rebuild this nav graph file over here and i just want to have it there so that you can reference it so here we have the navigation editor so we've got a couple different things here on the side panel we have this destinations tab here and as you can see we don't currently have any destinations and no nav host fragments is found so we can go ahead and ignore that for a minute and what i'd like you to do is uh we've got this new destination button up here so go ahead and click on that one and it's basically what we're going to do is we're going to add all the different uh fragments and or activities which we want to be able to navigate to and these things are known in this library as destinations obviously so we'll need to add the note detail view fragment then i'm just going to add in the note list fragment and as i mentioned before just due to the integration limitations with onactivityresult uh we're not actually going to jump to the login view which is a fragment we're actually going to have to jump to the login activity so we'll just select this option here all right so we've added all the different destinations but as you can see we have a little bit of work to do so the first thing i'm going to do is i'm basically just going to click and drag these things storyboard style and roughly where i want them so we're going to drag login activity up here and we'll note listview is actually kind of like the main sort of dashboard of the application and we'll bring note detail view down here and before we do anything else i just want to do a little bit of clean up okay so we've added our destinations but i think we need to hop into the text editor for a minute and just make a couple of adjustments so i'd like to be able to actually preview visually the screens that are that the application has in the each given destination and one of the ways we can do that is we can use this tools layout attribute here so for those who aren't aware the tools name space is basically like a design time namespace and whatever details you add here actually get stripped out of the packaged application so in this case we don't actually want to refer to the activity login layout because the activity login is just a container what we'll want is i believe it's called fragment login there we go and as you can see that should fix that up there we go that's exactly what i'm talking about there so we'll just add that in for the other fragment destinations here so in this one here i'll zoom in a little for everybody so on that one that's going to be fragment note detail and then up above here fragment note list all right loading and that's looking a lot better except i think i've reversed them okay so this is fragment no detail you know i could edit this out but i'm just going to leave this in here that's uh it's pretty spectacular ryan okay and let's just hop back to the design editor okay that looks more like it so as you can see it's added a two onto these names because we've already defined them in the other file but that's totally fine okay so the way that we actually kind of define how to navigate between these different destinations is by setting up actions so the way that you set up actions in the visual editor is uh you'll notice a lot like constraint layout each of these different destinations will have this little thing you can click on here so you can click and drag that to a particular destination and what that has done here is it's added this arrow and the arrow basically represents an action so go ahead and do that now how this thing basically works is that the note list view is able to jump to either the login activity or it's able to jump to the note detail activity so i'm just going to click there again come on there we go and i'm going to click and drag that to the note detail view now in this particular case once the user is done messing around with the note detail view either when they hit the delete button kind of hard to see but yeah there's either a delete or a check mark button there so once the user does that then they're basically going to jump back to the note list view so i'm going to select no detail view and then i'm going to click and drag this one oh that's not what i wanted to do and we'll just have it point back to the note list view so as you can see we've defined pretty much all of the different actions or navigation actions which we'd like the application to be capable of implementing uh there is one last thing we need to do here though well there might be a couple of things but what we need to do is uh in this particular case often what will happen is uh this is basically like a list view and oftentimes the user will be selecting an item in a recycler view here then we'll need to send the id of that item over to the note detail view and this is a very common pattern you'll see this all the time it's a lot better than actually sending the whole note item you just send the id over so what we can do there is we're going to click on the action between the note list destination and the note detail destination here and i'm going to click on the attributes panel here and what we can do is we can actually add some argument values uh to note detail view sorry don't actually click on the action here click on no detail view and this is where we can add arguments so in this tab here we have arguments we're just going to hit plus and so the name of this argument is going to be note id definitely try and give it a good name of course the inferred type is going to be a string sorry not the inferred type the type is going to be a string you can select inferred type but we're just going to use some simple data here and then it's not going to be nullable and we don't really care especially about a default value in this case so yeah just go ahead and type node id select uh string as a type and hit add and so just as a reminder to everyone all the stuff we're doing in the visual editor is basically just uh creating a whole bunch of boilerplate in the xml for us so what we can do here is uh now that i've added that particular argument to our note detail view uh it's added this little entry down here so that's basically all we need to do to actually configure this thing properly just one final note here up in the top of the navigation tab here we have this app start destination attribute so this is where you specify basically which particular destination you want to start the application from and in this case we don't want to start in note detail view we want to start in the note list view so i'm just going to type note list view 2 or whatever name it has and that'll be the starting point of the application now when i say starting point of the application that's assuming that your application's manifest file points to the activity which will be basically like the host for our navigation setup and we'll look at that in a moment okay so now that we've built out this particular xml file here uh what i'm going to suggest you do is unless you actually want to keep this thing just for notes or something like that please go ahead and delete this file we just created because we want to actually be using the old file just so it works well with everything in our application i just wanted to show you the actual process of building out the navigation graph using the design editor all right so now that we've got our navigation graph set up what we can do is we can set up our nav host fragment now uh again just a really quick bit of practical information here what i would suggest is so the one of the goals of this particular library is to go for a single activity approach i think that's totally great except as i mentioned before i literally wasn't able to do that due to uh library limitation but what i'm going to suggest to people is for different features of your application where you're running into trouble with this particular library my recommendation is to just pull that into a separate activity and you can you you can apply like a model view presenter or whatever to that particular feature of the application just have your navigation graph point to its activity instead of the fragment and then just do what you would normally do and when you need to jump back into the navigation graph you're of course going to have to start the uh sort of navigation host activity which in this case is note activity so anyways enough rambling let's go ahead and configure that node activity and so the node activity basically manages both the note detail view and the note list view okay so what we'll do is again we're going to create an extra file which we'll delete afterwards so just go ahead and right click on the layout here and we're going to go to new layout resource file and this file is going to be called activity note demo and for the root layout we're going to select a constraint layout there we go and that's what we'll start with here okay so what we need to do here is we need to add this thing called a nav host fragment and we could add that manually but there's actually a way to do it really quickly in the design editor so in the palette here just on the side there's the containers menu here and in the containers menu you're going to find down below this thing called nav host fragment so what you'll want to do is just click and drag this nav host fragment we can center it doesn't really especially matter here and it's going to give you a list of navigation graphs to select from of course select nav graph and as you can see here it's done most of the work for us we're just going to hop into the text editor so for the layout width we're going to say match parent same thing for the layout height and there's a couple other things we can just remove the absolute layout editor here so we're specifying the navigation graph that we built um we have this thing set as the default nav host so this is kind of like a default configuration which will work kind of easier and then also when we see this android name attribute this actually refers to the particular class name of whatever fragment so in this case just note that nav host fragment is not something that we are going to actually create we're going to use the default implementation and this is basically how we point to it up here now in this application we of course call this thing fragment i can't type fragment nav but yeah this is basically all the configuration we need to do and then what you can do is just go ahead and delete this file or keep it if you like okay so the next thing we need to do is we need to have a nav controller which generally speaking will be an activity so what we're going to do is in the note package of our main package here just open that up and so the file will be rebuilding it won't take long is note activity and again what we'll do is just right click on note go to new kotlin or java class whichever you prefer go to note active type note activity demo and don't worry about actually creating a proper activity and adding it to the manifest okay so what we'll do next is we'll just type class note activity demo and then that thing is going to extend app compat activity like so give it a constructor and the particular function that we're going to need to add in here is we'll need to override oncreate so usually it'll auto complete for us here let's see let's go with this option here okay so what we basically need to do here is we need a nav controller object which fortunately is super easy to correct or to create and what we'll basically do is when we need to actually perform these navigation operations we'll be basically getting a hook to this nav controller through the library so anyways what you need to do is go ahead and add private late init var nav and that's going to be of type nav controller like so then we need to create this nav controller so we'll say nav equals navigation dot find nav controller and what we'll do is we'll pass this for the activity and then it also requires a layout res id which is the nav host fragment and so the nav post fragment is basically what what we sort of swap the views in and out of so in that case that thing is called r dot id dot fragment nav like so so it's complaining that i need to import r but i'm just not going to worry about that if i hop over to note activity as you can see that's actually all we need to do and this was one part of setting this thing up that was actually like really quick and painless so now that we've got that done we can actually take a look at how to actually use this library in action okay so i'm going to open up a note list view and we'll look at some different ways to actually use this library to navigate to different destinations so i'm going to hit control n note list view and we'll just look at two particular situations here so in the first case we have a situation where we're basically just navigating to a particular destination without any arguments so there's actually a lot of different options we have as we can see for navigation so basically how this tool pretty much works is at least when we're calling it from a fragment here we have this find nav controller function so what happens is we call find nav controller and that's of course going to through the framework grab this thing we have here in the activity and then we can perform navigate operations among other things to jump to different destinations so this is almost kind of equivalent to like saying start activity except we're not working with activities here so i just want to bring your attention so if i click within the parentheses of this navigate function here and hit control p i just want you to notice that there are a lot of different options for what you can pass here so in a really simple case we basically just pass it the id of a particular destination so we have r dot id login view if i hop into the nav graph here just notice that if we go to this activity uh the id of this destination is login view so that's where that's coming from so that's kind of the first case now what about when we actually want to pass arguments type safe arguments to a particular destination and let me tell you this is one of the things that i actually quite like about this library and probably the main reason why i'm actually doing this video to be honest is the safe arguments feature here so when you want to navigate with arguments to a particular feature so in this case we want to go to the note detail view and here and we need to pass some kind of id to it so when we're creating a new note so when the user hits the create new this is like a floating action button and they want to create a new note then we pass just an empty note id and just understand that on the other side node note detail fragment and its uh view model is going to be aware that this is a new note so that's just in case you're wondering why we're passing that now what we need to do when we actually want to jump to a particular destination with arguments is we need to use this note list view directions dot action note list view to note detail view where the hell did that come from obviously we didn't write that so this is kind of one of the main points of this library is that the work you do in the xml will generate some functions like this that you can use to perform these different navigation operations so obviously in the simple case we can just call navigate in this case we need to use these note this note listviewdirections object and where this function came from and this uh or sorry where this class came from and this function of the class came from is based on some generated code from our xml configuration here so with that in mind you may need to build your project in order to actually create these things because i'm pretty sure they're made at compile time so in this case once we've created our direction and we've given it the particular action and the arguments that are required of that action and all of this has been generated for us then we pass that direction object to our nav controller and then that's how we actually get to the other uh fragment with the arguments okay so the last thing we'll do is we'll look at how to get the arguments out of our receiving destination which in this case is of course a fragment so i'm going to scroll down to the viewmodel.handlevent function here that's within onstart and so basically what goes on is uh we have this note detail view args object which is of course generated for us then we call dot from bundle and we supply the arguments property of this fragment and then where does dot note id come from so this is actually the name of the arguments that we defined in the nav graph as you can see here and in this case once we grab those arguments we just pass them to the view model in the form of a sealed event class and then the application figures out what to do from there and in this video i'm going to be talking to you about using fragments as views in model view view model architecture and we'll also look at how to use kotlin synthetic properties to eliminate boilerplate ui code and refer directly to xml views now how this is going to work is in this video we will write the fragment and then of course in the next video we will write the view model which our fragment currently talks to before we get to coding the fragment i just wanted to talk about model view view model architecture for a moment so as discussed in the second video in this series and you should probably go and watch that if you haven't and you're curious about this particular pattern there's a couple really subtle ways to do it differently which don't actually break the pattern entirely so i won't be going into great detail on this but basically what i'm saying here is the style of view model and view that we're going to be writing today is basically such that it allows the view to be very simple and easy to write and easy to test at the expense of moving a lot of the presentation logic of the view into the view model it'll basically simplify construction of the view but the key point here is the more details or the more presentation logic we include about a specific view in a view model the less reusable the view model becomes so what i'm saying here is if you have a view model which you plan to use for a variety of different views you're going to want to take the other approach that i discussed not the one where you have lots of details about the view in the actual view model just so there's no confusion about what i just said there let's have a quick look at two different view models in this project so the one we'll be writing today or sorry the one that our fragment that we write today we'll be talking to and the one we'll write in the next video is the user view model so the thing about this view model is in keeping with the pattern it does not directly reference any particular view however it does have like i said before specific details about a particular view so we see fields in here like sign in status text auth button text satellite drawable so as you can see this view model is going to work really well with a particular view but it's not necessarily going to be something that we can reuse with a whole bunch of different views when i open up note view model i basically you will pretty much not see any specific details about a particular view within reason so we're not going to see these show error state type functions we are going to see things like note was deleted note was updated and we'll see that we do actually publish a note object to whatever observable is or sorry whatever observer is listening but the thing about this is by taking this approach of having more reusable view models we're now relying on the fragment or the view to basically handle this presentation logic okay so if you would like to follow along with this tutorial and i do suggest you do if you're going to watch it then check out the description box down below you'll find a link to the open source code repository and you can either clone or download it anyways what we'll be looking at first is how to configure kotlin synthetic properties in gradle so the first thing you need to make sure is that you have the kotlin gradle plugin installed this one here sorry my word wrap is going to screw it up so if you check marked the box that your project is supposed to be a kotlin project in android studio most likely you won't actually have to add this in manually it should be there if you've configured a kotlin project in a more recent version of android studio but i just want to point this out in case there's any confusion secondly one thing you probably will need to add is go ahead and open up the app level build gradle file and this is true for whatever module you might want to use the kotlin synthetic properties in you're just going to want to apply this particular plugin here kotlin android extensions apply plugin and that will allow you to use kotlin synthetic properties so the view class that we'll be writing today is called login view and i just want to make one more final note here uh there are two functions in it so in particular i'm talking about start sign and flow and on activity result and we're actually not going to be coding out those two functions and the reason why is that i'm going to go over those when i talk about implementing firebase with google sign in provider so we won't be coding these two functions here in this video but like i say we'll get to that eventually okay so what i would like you to do to get started here is you can either make a new file with a slightly different name for login view because that's what we'll be rebuilding or what you can do is you can just select everything under the package declaration here just scroll down and have a good delete and that will be our starting point for today's tutorial all right so the first thing we'll be doing is we'll write out the class declaration so go ahead and type class login view extends fragment like so just line that up a little better and of course we will have to import the appropriate library so in my case i'm using the android x library so go ahead and pick that so the next thing we'll need to do is we want to add a reference to our view model and we'll have to use a late in it var for that also in general since i don't want anything else kind of messing around with this particular reference we're going to make it private private basically just means that we can only see it in this particular class all right so when we're working with fragments we need to tell the fragment which layout to inflate now if you're using data binding there's a slightly different process for this but what we're going to do today is we are going to override the on create view function like so and uh really appreciate that autocomplete there all right so go ahead and select everything after this return statement here and delete that so what we're going to do instead is we are going to inflate a specific layout so we're going to take the past in inflator and we're going to say inflator dot inflate and the resource we're going to give it is we're going to point to the fragments layout file so we're going to type r dot layout dot fragment login now it's going to be complaining because it wants to import r so you can go ahead and do that i just hit alt enter there to import it and that's satisfied that particular problem and then we need to give the container so this is where the view will be inflated into then we're going to type false for attach to root now this particular option falls for attached to root can be a little bit confusing for people but just understand that most of the time you want to leave it false and it will still actually appropriately add our fragment to the activities view hierarchy so don't worry about it anyways what we'll do next is we'll begin writing out our onstart function so again i'm going to type override fun on start like so and so what we need to do at this point is uh we're going to already start to refer to a couple different views in the xml layout from our onstart function here so what we need to do is we need to set up our synthetic functions now luckily this is like seriously one of the easiest things to do ever once you've added the library as we discussed before so all you need to do is just go up to your import statements here so what we're going to write is we're going to type import kotlin x dot android dot synthetic dot main dot fragment login dot asterisk so in case you're curious the asterisk is basically saying whatever is a for lack of a better term uh member of fragment login then we want to import all of those things so effectively what that's going to do is if i open up a fragment login here which is the actual view oh that took a while to load so basically what's going to happen is we can now refer explicitly to these particular view ids we don't need to do any fine view by id stuff all we need to do is just add in the appropriate layout and we're good to go okay so what we're going to do now is we are going to assign our view model now we'll type the code out here by hand but i'm actually going to be covering how to actually set the dependency injection and view model provider stuff up in a different video so if you're curious about how to do this in more detail i will eventually get to that covering a lot of stuff in this tutorial so what we can do is we're going to type view model of course referring to our reference above then we're going to say equals view model providers with an s of and then for this particular thing let's just go ahead and import that so it stops screaming at me um we're going to type this passing in our fragment again i'm not going to go into detail about this we're just going to type this out all right and then we'll type login injector which is a custom written dependency injection class which extends android via model so when we do that we need to type require activity this might be a new function for some people around here i'll get into that when i talk about this particular code in the other tutorial but this is kind of a handy little function that's been added somewhat recently and then we're going to refer to the that's going to get our activity and then we get the application and then once that happens there's one function in this particular class login injector which is provide user view model factory like so now we're not totally done yet because uh we've configured that aspect and now what we need to do is we might need to type dot get on our view model providers and then we're going to pass the specific view model that we require here so we're going to type user view model which is the view model that we will be talking to and we need to kind of refer to the class file here so what we're going to do is we're going to type double colon class dot java like so this is one of the things about kotlin the uh the um when you need to reference a particular java class the syntax for it is kinda wacky but whatever it works so uh that's all we need to do to assign our view model our first order of business now is going to be starting the background animation so if i briefly look at the layout that we're writing the fragment for or vice versa you understand what i mean it has a background which is like a space background basically and in the application it actually kind of animates if you're wondering how i did that i did cover vector drawables and animations in a particular video in this series i'm sure you're tired of hearing that but yeah go and watch that video if you want to figure out how to do that in detail so we're going to need to cast it as an animation drawable so type brackets first and then what we'll type is root fragment oops i can't fragment root fragment there we go holy crap that was pathetic and then so what we need to do is we want to get a hook to the background of this layout the space loop drawable here so what we can do is we're going to type root fragment login so we're referring specifically to this layout and then we're going to type dot background which is going to return a normal drawable now this the thing we have in this drawable is actually an animation list so what we can do is we're going to type as sorry animation drawable is what i meant animation drawable okay and then what we're going to do is we're going to type dot start with fade so immediately you're going to be wondering ryan what the hell is start with fade so it's actually just an extension function that i wrote in this project so i'm going to hit ctrl shift n and we'll type android and then there's a file called android extensions in the common package and you'll notice it has this particular function here start with fade so all it does is instead of having to repeatedly write this code out i've just pulled that code out and put it in an extension function which just means that i can just type start with fade and have instead of having to type this crap here so there's no magic this well there's the magic of kotlin extension functions which i really like but there's nothing too crazy going on here so the next thing we'll do is we will set up our click listeners and kind of bind them to the view model appropriately so since there's a couple of lines in that function or there's a number of things we need to do in order to set that up we're going to create a helper function so we're just going to call this thing set up oops set up click listeners i've got my keyboard in an awkward position and it's just ruining my typing skills my apologies set up click click listeners like so and then i'm just going to click on that hit alt enter create function and that's going to build it down there and then this is what we'll do next so like i said before now that we have kotlin synthetic properties set up we can just refer directly to the xml ids so the first one we're going to assign is the auth button so that's going to be this button in particular here the thing that currently says sign out but what it says changes frequently so we're going to type btn underscore auth attempt let it autocomplete dot set on click listener and we're going to give it a lambda expression here and so what we want to do when this on click listener fires it's going to basically call the code in our lambda that's how this kind of works in that event we want to type view model dot handle event so this is basically like a generic function which you'll see in all of my view models and how they work let me just pull the code up really quickly here type base view model so we'll go into more detail about this in the next video but just so you understand what's going on here we have this abstract function handle event and it takes some particular type so let's have a quick look at the view model itself that we're going to be working with that's again going to be user view model and just notice that it extends base view model and the generic type which i pass for each given view model is some particular kind of sealed class which represents different events i know this is a lot but just understand that what this login event thing does is it basically just represents different events which could possibly propagate from a particular view or a set of views so i just wanted to show you the code really quickly so you know what's going on here anyways back to our view so uh we're going to call our viewmodel.handle event function and what we're going to pass to that is login event dot on auth button click so this is basically our way of telling the uh user view model hey someone just clicked the auth button so you need to do something so that's not the only thing we need to assign here we're we're also going to basically make it so that if the user hits the back button then it's going to start the list activity so what i'm going to do is i'm going to type imb toolbar back is what it's called dot set on click listener there we go again lambda that pardon my language and then what we're going to do is we're going to type start list activity so this is actually a function we will code so i'm just going to hit alt enter create function start list activity down below so we're going to use kotlin single expression syntax so we're going to type require activity again dot start activity and in our start activity block we're just going to go ahead and create an intent so we're going to say intent and then in this intent we're going to type activity which is uh basically the activity for this particular fragment then we're going to type where we want to get to which is note activity and then we'll do our handy reference to java class syntax like so and that'll need to be imported okay so with that when someone hits the back button they're going to be sent to the note activity now some of you may be wondering hey i thought you were using navigation in this particular library well actually because of limitations which i discussed in the video where i covered the navigation library we do use the navigation library but not in this particular feature of the application and the reason is because it doesn't play nice with on activity result okay so we're almost done with our setup click listeners function there's just one more thing we need to do we need to intercept on back pressed and the reason for that is just because of the awkward integration with the navigation library which is not really my fault so we're going to say require activity and then we're going to type that dot add on back pressed callback i can't talk today for some reason so uh we're going to have to monkey around with this a little bit so we're going to basically put some parentheses here around our lambda we will still need the lambda expression so for the first parameter we're going to type view lifecycle owner and that's a property of our fragment here so if you're wondering where that's coming from that's where it's coming from and then we need to create an on back pressed callback from our lambda so we're going to type on back pressed callback actually autocompleted this time that was handy and then what we'll do inside of this on back pressed callback is uh we're going to type start list activity and this thing's complaining because this function must return a boolean and the boolean that we'll be returning is true so the reason why we return true here is because we're basically telling the operas operating system hey don't worry about handling that back click event we've got it covered don't do your thing anyways let's move on here so the next thing we'll do is we're going to write our basically another helper function called observe view model and what this particular function is going to do is we are going to observe some view models so i'm just going to hit alt enter create function down below so basically what we're going to be doing here is we want our view to pretty much attach to if i can find it here pretty much every publicly visible observable that our user view model possesses so basically what that's going to look like is we're going to be typing view model so the first one we'll do is sign in status text dot observe so we're going to pass view lifecycle owner which is a property of this fragment so it knows to pay attention to that particular life cycle and then we're going to create an observer lambda function and so again this is basically just what do we do when this particular observable publishes data so how do we handle the data and this is where this particular style of view model is really quite handy because basically all we do is we just bind it directly to whatever gets passed in so in this case i'll type up here that if you don't understand how lambda syntax works just understand that whatever gets passed in here is inferred to be this variable called it so for the first one i'll actually give it a different name than it we're just going to call this text and then i'm going to hit the arrow thingy here and then we're going to type um we're going to leave it like that and that's going to assign the name text instead of just using it i'm just doing this so hopefully you kind of understand what's going on so this particular field that we're working with here basically dictates what is displayed in this text view down here i know that's hard to see but this uh basically login status display down here so what we can do is we can refer to that particular view so lbl login status display and we're going to get its text property and we're going to assign that to text so for the rest of them we're going to use the it syntax but i just wanted to demonstrate that here in case anyone's confused about that i did do a video about that what what does it mean in kotlin so you can go and check that out if you like so what we'll do is we'll type out another uh observable here so we're going to type viewmodel.off button text so this is going to be the text for this button here that currently says sign out and it's the same process here so we're going to type observe give it the view life cycle owner give it a hook to our fragments life cycle and then we're going to give it another observer and in that observer so now we're referring to btn auth attempt then we're going to say dot text equals it so the rest of this observe view model function is just a whole bunch more livedata.observe functions so there's nothing really new there and i don't think there's actually any point in us typing that code out together what i'm going to suggest is if you'd like to practice maybe try implementing the rest of this function yourself and what you need to do is basically you just need to write one of these statements one of these observed statements for basically everything you see here now just one important thing to note these two live data observables here as opposed to well actually this one does affect the user interface but this one in particular is actually just a way to communicate back to the view based on what happens in a particular auth state so we're going to learn a little bit more about that in the next video where we actually write out this view model but yeah that's basically all i wanted to cover in this particular tutorial and you're watching video number seven of my android 2019 tutorial playlist so in this video we're going to be looking at wiring up the view model and in the previous video number six basically uh we'll be writing the view model that we hooked our fragment up to so if you're curious about how to actually write the fragment that this particular view model is going to publish events to or data too then you want to go back and watch that video first now once again before i proceed if you haven't already watched video number two where i go into detail about the model view view model architecture on android you might want to watch that first and the reason why is it's important you understand that there's a couple different ways to do uh the interaction between the fragment and the view model or the view in the view model in general and the approach we're going to be taking today is basically good in a situation where you don't need to reuse your view model and you would prefer to have a fairly simple view which doesn't have a whole lot of logic so basically like i explained in detail in that video what we'll be doing today is we'll write a view model which basically allows us to pull pretty much almost all of the presentation logic of the fragment the view out of the view and the good thing about this approach is that we can still maintain the model view view model pattern uh by communicating with the fragment only through live data objects so like i said in the previous video you can also use data binding but today we're just going to be using live data to communicate between the via model and the fragment all right so before we proceed you may want to grab the repository or the code that we'll be working with today link down in the description box below and you're going to want to either clone or download that particular project and pull it up in android studio or whatever is your preferred ide anyways before we get to the specific view model that we'll be writing today i wanted to show you the abstract class called base view model which the v model that we'll be writing extends so we're not actually going to write this class out but what i wanted to do is basically just talk about it really briefly and what it does for us so there's a couple different options for extending the functionality of existing sources in kotlin and when we want to really object oriented solution one of the best ways to do that is with an abstract class so the purpose of this base view model class is basically anything that is going to be common to basically every view model in this application i want to include that in the abstract class so if you'd like a detailed explanation of this kind of thing i do go into a detail about all kinds of different things including how to achieve similar behavior with extension functions in my kotlin course link in the description box down below so do consider checking that out anyways what we're looking at here is our base view model class basically is going to be containing a coroutine context object and it extends of course view model from architecture components and then it also extends coroutine scope so the reason why i wanted to bring this up is it's important you understand that this is how or where we're going to kind of launch our co routines from now i'm not actually going to go into detail on core routines in this particular video i will go into more detail in another video in this series but just understand that uh when we look at a particular view model so for example we have our coroutine scope set setup in this class and then we have our routine context down here and just notice it's going to be basically placed on the ui context dispatchers.uh main thread and then we have our job tracker object which allows for cancellation uh functionality so when i open up a particular view model which basically that's not a view model good job ryan when i open up a particular view model which extends our base view model just under understand that every time we're making this launch builder here it's going to be an extension on our root coroutine scope so anyways i'm not going to go into more detail on that in this video but i will talk about that in detail in another video and i just wanted to mention it here in case you're wondering why is the launch thing all yellow here uh that basically means that it's an extension on our view model so one other thing i would like to mention so the thing about working with this view model is obviously our live data objects have to be publicly visible but since we're not returning live data objects from the back end we have to work with mutable live data so one suggestion from al warren who's been a really awesome contributor to the wyze slack channel he just mentioned that one of the ways you can kind of get around this issue of having a publicly visible mutable live data object is to basically make the live data field which is publicly visible or the live data reference rather you basically make the actual data the actual mutable live data object as what you would maybe call an implicit backing field in technical language but basically what we're talking about here is this thing here the error state which is the mutable object and we'll see a couple different examples of this we can kind of hide those behind hide them the mutable live data reference behind a immutable live data publicly visible reference so basically what i'm saying here is if you want to improve your encapsulation then do consider taking this particular approach here all right so the class we'll be writing today is user view model so there's kind of two ways you can do this so i'm assuming you've downloaded or cloned the repository or you can just watch if you like but you can either basically just uh delete everything in here except for the package statement up top or you can just create a new file maybe call it login view model and build them kind of side by side whichever you prefer today what i'm going to do is i'm going to just actually select everything here and delete it now before i do that i just want to mention very briefly one thing we're not going to code today in this particular view model is the on sign in result function now the reason for that is that i'm going to be covering that in the part of this tutorial where we discuss using firebase and google sign in provider anyways with that being said i'm just going to delete everything there and maybe i'll leave this comment up top just for the fun of things and we can get started building our view model so the first thing we'll do is we'll build out our class declaration so we're going to type class login view model actually sorry user view model probably should have picked a better name for it so we've got a login view model and this thing is going to extend our base view model class now when we extend the base view model if i just hop back to it really quickly we have this function here abstract fun handle event and then we also have what's known as a generic type so basically what this is all about is that uh t is going to be some kind of sealed class which represents different events which can propagate from the user interface so we won't write that particular class but i'll just uh show you what it is in this particular case so it's going to be a login event class let me actually just pull that sealed class up so you know what's going on so we've got login event and uh so yeah as you can see just a pretty runofthemill uh sealed class here now one of the things to mention is that we in some cases will be returning this login result class here so that's just basically like a data wrapper essentially so it just maintains a request code and a user token so this is the stuff which will be dealing with in the firebase video but again since we're kind of using it in this particular tutorial i just wanted to briefly mention what it is so we've got a not too many different events here just the three so there's on off button click on start and on google sign in result and these are all events if i open up uh so this is going to be fragment login so that's basically all the events for this particular layout here back to our user view model all right so we have our login event class and because we have that one type in here we do need to supply a particular type for our ceo class so that one is going to be a login result like so and then we need our constructor our initializer i think it's actually called and uh that's not all though so i'm just going to give our curly brackets here so base view model is expecting a coroutine context object so what we're going to do is we're going to basically pass in a reference here called ui context which is going to extend coroutine context and so that's going to get passed into our view model here so in our base view model here that's going to get passed in so during testing we would basically want to mock or fake this particular object and return dispatchers dot unconfined but when the application is actually deployed then this is going to be basically running on the main thread or rather our coroutine scope will be scoped to the main thread anyways back to our user view model all right so we've got our ui context object so what we need to do is we don't actually want to hold on to this thing in our actual view model we just want to pass that thing to the super class here the base view model class so i'm just going to type ui context and that should satisfy that particular error and now it's going to scream at us because we need to implement our handle event function so i'm going to click on that hit alt enter and then implement members handle event and there we have our handle event class with the appropriate sealed class accompanying it all right now there's one more thing we need to do with our constructor so the way that we actually get data basically in and out of this particular view model is through a repository again i will go into more detail on this in its own particular video in this series but what we're going to do is we're going to type val repo and that's going to be of type i user repository all right so we'll actually get to coding our handle event function a little bit later what i wanted to start with here is the various view model objects or sorry the various mutable live data objects that we'll need to be working with so uh let me write one out here and then we'll talk about how this kind of works so the first one we're going to write is the actual data model which this particular view model uh holds on to and we are going to make that one private because i don't want that one to be uh tampered with whatsoever except for within this particular viewmodel class so we're going to type private val user state and that's going to equal mutable live data and the type is going to be user so if you're not familiar with live data so basically how this works is it's going to pretty much wrap some kind of object it could be a string in this case it's the user data model i'll just open that up really quickly here and it's just like a really simple data class which has a uid and a name so this mutable live data is going to basically wrap that object it's complaining because i need to add that and then that's how we'll actually kind of persist the data in this view model now some of you might be wondering what's the difference between mutable live data what's and live data and when should you use them so i would basically put it like this live data is essentially an immutable class so basically what that means is that you can't change a live data object sort of within the class that's holding it so what you can do is let's say hypothetically we were actually working with a uh user data model which was coming in from a back end tool like say room so the important thing to know here is if we were returning a live data object from the backend then you would want to make this live data but in this particular case since we're returning an object just the user object which isn't a live data object that means we need to make our live data mutable so this basically means as you'll see in a moment that we can actually from within this class change the particular value that our mutable live data object wraps okay so we've made our actual data model wrapped by a mutable live data object and then what we need to do is we basically need to write out a couple different more live data objects with the goal of basically covering all of the different widgets and control operations control logic which our view will need to implement or or listen to essentially okay so what this particular thing is going to look like is we're going to type internal val off oops auth attempt so the reason why we're using internal is i basically want these things to be visible by anything within this particular module so for example our fragments but just for better encapsulation we're making it uh invisible outside of any outside of any other context so anyways we've got internal val auth attempt and then that's going to equal uh mutable live data again now for the type here we're going to use unit so why exactly would i use unit this is very similar to like void in java not exactly the same but quite similar in fact it does get mapped to void in uh when it's decompiled into java anyways how this thing basically works is i suggest using unit when you want to trigger some kind of event but you don't actually care about any particular value being passed into that event so what i think i'll do is i'll just show you really quickly what this looks like in the view so if i look at auth attempt here just notice that we're not actually returning any kind of value there is kind of an it which is of type unit that will get passed in here but in this particular case all we want to do is we just want to call a particular function uh when this particular mutable live data is changed so we're changing it and triggering the function but we're not actually changing it to a particular value anyways what i'll do next is i'm just going to hit control just put my mouse right there and then i'm going to hit ctrl d which will copy the line and then we're going to have a second control logic observable here so this is going to be called start animation and again that's just going to return unit same idea all right so we have our two control logic fields here or observables or whatever the hell you want to call them and in case there's any confusion here the reason why we're doing this is we need some way to call back to the view so in this way we can call back to it indirectly anyways we need a couple more mutable live data objects so in this particular style of building view models we basically want a live data object to represent every item in the uh layout that we're dealing with here so i'm just gonna again open up let's do ctrl shift n and let's see fragment login so what i'm saying here is we basically the way i actually built this thing is i said okay for every item in this layout every widget which changes we need a mutable live data object to basically represent the value that it will have so in this particular case we have this animation drawable here we have this text view which basically just displays the current login status and then we have this off button down here which is how we trigger auth events and this thing's text will change as well so it follows that we'll need a mutable live data object for each of these things so uh what we'll do is uh so i'm just going to type ui binding here because that's basically what we're doing and then we're gonna again use internal val sign in status text so that'll be for our sign in status text view and that's gonna be a mutable live data object and it's going to be of type string perfect now since even the animation drawable we're going to be giving it a url to a particular resource all of these things are going to be strings so again i'm just going to hit ctrl d twice like so and we're just going to update the names here so the first one is going to be off button text and by the way pick good names for these things like don't don't do short ugly names that leave people guessing about what they mean then we have the satellite drawable like so i can actually probably pick a better name for that one too to be honest but that's okay good enough all right so we have our live data objects and then what we'll do next is we'll get started kind of working with our handle event function here all right so what we'll do next is we will code our handle event function and that way you'll get to see our sealed class in action how it actually works so what we're going to do so there's a couple different things going on here what i'm going to do is i'm going to stub out the presentation logic functions and then we'll kind of implement those towards the end here but we can actually get started with them so we're just going to type show loading state and i'm going to hit alt enter create function show loading state and i'm actually just going to leave this to to do function here this is actually quite a handy function because if we do end up calling this particular function when we've forgotten to implement it then we will actually get a an error popping up which is actually what we want we want to know if this thing has been implemented or not before we ship the application so anyways we're actually going to as i say we're going to implement these functions a little bit later what we'll do now is so this is kind of the the main point of using a sealed class is we can represent a number of different finite states that the sealed class can represent and that can represent different events in the front end or back end of an application so i use sealed classes all of the time and if you're not familiar with them you probably should be if you're right in kotlin so uh what we're going to do is we're going to use a when matcher so we're saying when event which is what is passed in here then we'll give it some curly brackets and then this is where we list out our different cases so this is quite like a switch statement in java and csharp and those sorts of things so we're going to type is login event dot onstart so we're basically just going to make a function for each of these objects here and the data class as well and then we do an arrow sign thingy and then what we're going to do is we're going to type get user so we'll need to code this function out and what i'd like to do first is i'm just going to hit alt enter again create function get user and then we'll just finish off this particular handle event function before we get to that so we have two other cases so again i'm just going to hit ctrl d just speed things up a little bit this one's going to be on off button click and in that case we're going to type on off button click and again click on that hit alt enter create function cool and then for our last event here we have on google sign in result so in this particular case we're going to type in the on sign in result and then how do we actually get data out of our sealed class here so what we can do in this particular case is we type onsign in result and then by saying this is clause here this actually will cast our event to the on google sign in result if it does happen to be that particular class how we get our data out of that is we say event dot result which returns our login result object here okay and that's the property right there and then again we'll just hit alt enter create function now this is the function that we're not going to be coding out today so i'll just make a note here not coding this one today but in a later video where we talk about firebase and coroutines and stuff like that all right so that is our handle event function and then what we'll do next is let's go ahead and get started with our get user function here so for get user we are going to be talking to the repository object up here repo and let me just open that up really quickly i note repository sorry this is i user repository and just notice that these things basically they're all suspend functions so we're getting into coroutines land so in order to actually call these suspend functions we need to basically use uh some kind of coroutine builder generally speaking in this particular case since we have configured our base view model to be our root coroutine scope and our user view model extends that and i do recommend this i do recommend this approach for co routines uh we need to basically make this function into a launch builder so what we're going to do is we're going to type equals launch like so now it's important to note if you do not configure uh the appropriate coroutine scope just notice that this thing has this this protein scope thing right here if you do not configure that properly things aren't necessarily going to work the same way you're not necessarily going to be constrained to the appropriate con coroutine scope and i do not recommend you use globalscope.launch so what we're going to do it's actually really simple the way i build applications so we're just going to type val result which is going to be uh we won't specify the type here we're going to say val result equals repo dot get current user like so so if you're wondering what the type is here we're returning this result wrapper so this is a result wrapper that i've written myself there's a couple different libraries and stuff like that you can use i'll just open it up really quickly result and it just basically represents a value so like a success case and then it represents an error so like an error case big surprise there and then the way that we actually use it is with this handy build function so anyways that's what we're going to be returning but more specifically it's going to return either an exception or a nullable user object so why does it have both exception and then a nullable user well the reason for this is that we might end up checking our firebase auth for the current user and there's no current user so in that case we would return null this isn't necessarily an error case maybe the user just hasn't logged in yet so i'm trying to be a little bit more specific if there's an actual error occurring then i want that to basically be a different path that the event stream takes so anyways what we're going to do is we're going to hop back to user view model so how i like to use these result wrappers is again we're going to use a when when matcher so when result is oops not os result dot value like so then in that particular case uh we have a block going on here so there's a couple things we need to do here if we actually get a user object from our repo the first thing we want to do whether it's null or not is we want to say user state dot value so this is the value of our user state object here and this is how mutable live data mutable live data works so we can say user state dot value equals result dot value so what we're doing is we're taking the value out of our result obviously and then we're just assigning it to our mutable live data object so that fixes up our uh the the state of the view model here but of course we're still going to need to update everything else appropriately so in particular we need to update our ui binding so how we're going to do that is we're going to basically represent the user interface with a couple of different finite sort of states so what we'll do is we're going to write out all of those one after another i'm just going to actually stub them out first off so what we're going to do is we're going to hit enter again so the first thing i want to know is is this thing a null value which again isn't necessarily an error case and if it's a null value that means the user is currently signed out so we're going to type show signed out state like so then we're just again going to hit alt enter stub that function out and then we'll add an else case so we're going to say else show signed in state there we go just stub that bad boy out awesome so the only other thing we need to do here is we need to handle our error case so we're going to say is result dot error if that's the case then we want to show error state cool all right there we go and as you can see here we have all of our different ui state functions coded out okay so we're still not ready to implement these particular functions yet what we'll do first is we'll implement our on off button click function so basically what this is going to look like is we're going to type if user state dot value which is our live mutable live data object equals equals null which means that the user is not logged in then we want to call auth attempt dot value equals unit so what that's going to do is it's going to trigger the auth attempt observable in our login view here what that's going to do is that's going to call the start signin flow function down below here and this basically prepares the application to open up basically a new sort of activity using on activity result and what's going to happen is the user can basically choose to sign in with their google account and then once that process is ready then that result will be propagated to on activity result when the activity returns so anyways going back to the view model that's what we're going to trigger here so if user state value is null the user is currently logged out and they have pressed this particular button here except it would say sign in for example and that starts our sign in process now if the user else if the user value is not null then that means the user is currently logged in and they want to basically log out so in that case we're going to call sign out user and let's just code that function out so once again in order to actually sign the user out we need to talk to the uh repository object which means once again we're going to be dealing with our suspend functions so we can go ahead and make that into a launch coroutine builder like so just get rid of that there and so what this thing is going to look like is very similar to get user we're going to type val result equals repo dot sign out current user and then we're going to use our when matcher so when result is his result dot value do something so in this particular case what we're going to do is we're going to type user state dot value equals null so in this case we're not actually returning a value we just want to know if the user was successfully signed out or not if they were successfully signed out then we just want to make sure that the view model reflects that so we type user state dot value equals null and then we're going to again call our show signed out state function cool then we'll handle our error case is result dot error and then again we're just going to call show error state as you can see there so that's it for the different control logic functions that we're going to be coding out today there is of course the on google signin result but as i said several times we're going to cover that in a different video the last thing we need to do is we need to actually code out our different states here so i'm actually going to select all of this hit control x and i'm going to bring it up top to just below our view model objects here and then we get started all right it's time to code out our presentation logic functions now before we do that i just want to share really quickly i have this file in the common package called constants.kt so what we have here are a whole bunch of const val references so these are compile time constants which means that they're very efficient now if you need to localize your application for uh different localizations then probably you would want to go with strings.xml in this particular case this is me just being super lazy and efficient and just typing out different strings which ultimately will be rendered on our uh ui here uh just in an easily accessible file so what we'll do is uh instead of sort of hard coding these different values we're gonna refer to each appropriate constant and that'll just as you'll see in a moment make our presentation logic a little bit easier to write and a little bit harder to screw up so the first thing we'll do is we'll work with our error state here so in this particular case we're going to say sign oops sign in status text dot value so again we're updating the value of our live data object so the first one is going to be login error and then the next one so pretty much how this is going to work is i'm just going to hit ctrl d twice and we're going to update these values this one's going to be off button text dot value and so when there's an error we want the user to be able to sign in again so that one's going to be sign in and then for the uh next one we have the satellite drawable which is like the animation right here so if there's an error then we want to basically show antenna empty so that's a url to a particular drawable it's actually this one here the empty antenna animation here all right so once we have that figured out and let me just double check to make sure i didn't screw anything up ah looks okay good enough for now uh goodknow anyways uh so i'm gonna hit ctrl c and i'm just gonna paste this into each of these functions since this won't change too much again this is the kind of work that you really need to test because when you're doing this kind of copy paste crap you almost always screw something up all right so show signed in state is what we'll be working with next so when the user is signed in we want the sign in status to say signed in we want our off button to basically say sign out and then for our antenna drawable we want it to say antenna full which is basically this drawable here except with the wavy things on top just deploy the application if you want to see what it looks like okay so we've got our state here so show signed in state signed in sign out antenna full that's looking good next we'll go to show signed out state so it's basically going to mirror this one here so for show signed out state we're going to say signed out up here and this one is going to say show signed in state so this one's going to say sign in that's correct and then this one's going to be antenna empty that's actually correct it's quite similar to our error state as you can see all right so for show loading state it's actually going to be much simpler so we're just going to type sign in status text and we're going to set that one to loading oops kind of need an equal sign in there okay and then all we're going to do is we're going to call our start animation function here value equals unit so uh earlier on um you may have noticed in the view if you watched it previously what we ended up doing is we actually set the animation drawable in the view so the reason why we're doing that and not actually uh updating the particular drawable in this case is if we hop into login view notice that i actually specified explicitly that before we animate our drawable it must be assigned to our antenna loop drawable so the reason for this is that antenna loop is actually like the only drawable which is actually an animation list and i don't want to have a situation where i'm say for example assigning just a regular svg drawable and then somehow accidentally i forgot to change that to the actual animation drawable and then we are starting an animation drawable which isn't actually an animation drawable so basically what we're saying here is this is a little place where i actually did include a little bit of presentation logic in the view but this is for the sake of avoiding problems with shared mutable state so the very first tutorial i ever made at least on the topic of android on youtube was for the recyclerview way back in 2016. now back then there was a couple things about it which made it kind of tricky to set up for people so that's kind of what inspired me to try and make a video on it well i'll be basically teaching the same api today but luckily there are a couple improvements to it which will allow us to do a couple of things so for stars the recycler view we'll be building today is going to be the adapter at least is going to be decoupled from the fragment which is kind of important it's going to handle click events super easily as we'll see we don't have to have like seven different interfaces going on we'll actually handle click events just by using a mutable live data object and then finally our recycler view that we're going to build here we're going to use a particular class called list adapter which is like kind of a specialized adapter and what it's going to allow us to do is it'll basically remove our need to have to call functions like notify dataset changed notify item range change notify item inserted there's basically if you're not familiar in earlier recyclerview api implementations you had to call these different methods on the adapter based on what happened in your recycler view and it could actually get pretty annoying and complicated so what we'll do is we'll basically set up a bit of a boilerplate class called a diff util and dot item callback i believe it's called we'll see it in a minute but basically what this thing's going to allow us to do is it'll basically remove the need to call all those different functions and instead we'll just be calling one function and then we'll let this diff util our list adapter and a couple other things which we'll go into in the video handle all of those updates for us so it's going to be way simpler and best of all this particular implementation is going to figure out the or calculate the changes that need to be made to the recycler view on a background thread so no more blocking the main thread now since this is tutorial number eight and i've already covered a whole bunch of topics such as writing a view model writing a fragment model view view model architecture in general constraint layout all those different things what we're going to do is there's certain parts of this tutorial that we're not going to go into much detail in however i will show you all of the different steps necessary to actually set up the recyclerview what we won't be doing is we won't code out the whole fragment which displays the recyclerview and for the layouts that we'll be using in the recyclerview i'll show them to you and mention anything that's important but we're not going to build them on camera if you want to learn how to do that i have a whole tutorial on constraint layout which will help you figure that kind of thing out now before you proceed if you want to actually follow along with the tutorial in real time you're going to want to either clone or download the repository link in the description box down below now this could end up being a fairly long video so i'll make sure i include timestamps in the description box down below if you want a detailed idea of the topics and when we cover them in this video the first file that we'll be looking at is called fragmentnote list so this is the layout which actually contains the recyclerview so as i say i'm not going to go into too much detail here but here's a preview of the layout you can't actually see the recyclerview here but this is basically what it would look like if there are no items in the recycler view so i'm just going to open up the text editor here and we'll just look at this particular xml view so the first thing i want to bring your attention to is we have this color transparent black background so what i wanted to do here is instead of just setting the alpha of the which alpha means opacity or the degree to which something is transparent um instead of just setting that directly on the recycler view and kind of blurring things i just wanted to make sure that the background of the recyclerview basically made the elements in it a little more viewable a little more visible but you could still see the space background behind it so the way that i achieved that effect is i basically just set the background of the recyclerview to color transparent black and if i open up colors.xml that's basically just the color black with a hex value of 52 for the opacity so in the sense this is like setting the alpha except only for the background image so the second thing to point out here is that i've specified a linear layout manager in the xml so i used to do this in the java or kotlin code but i actually find it simpler to just do it declaratively in the xml in this particular case and notice that i'm using a linear layout manager depending on what kind of layout manager you use that will kind of dictate how your recyclerview behaves and how it kind of arranges the different items within it final thing to note here is that i've specified the default visibility of this particular view to be invisible and as i explained before that's because when there's no items retrieved from the database then i basically just want the recyclerview to be entirely invisible all right so the next file we'll be looking at is itemnote.xml so again i'm just going to talk about some general things but we're not going to actually code this particular view out so uh the first thing i wanted to mention is that both the primary graphic and the little icon down here are vector drawable resources so i have a tutorial on that and you can go and watch video number three in this series if you're curious about how to set these up but just to explain really quickly how they work uh basically they will scale to pretty much any screen size within reason and they won't lose quality or anything like that and the best part about that is that all of that happens through one single drawable resource so we don't need to specify resources for different screen sizes with vector drawables now looking at some of the more specific details here i just want you to note a couple of things so the way that i arrived at the general dimensions margins padding and those sorts of things is i basically went to the material design guidelines website and pretty much copied what they did now i do align things a little bit differently than what they suggest and so what i recommend is if you want to figure out how to align these things appropriately go check out what their guidelines are start from there and then tweak things a little bit in order to get the effect that you prefer so there's one last thing that i want to mention about this file if i scroll down to our primary text view here i just want you to notice that i've specified single line equal to true and then i've specified ellipsis dot end so what exactly is a lip size dot end this is kind of important if the text in your recycler view may end up being longer than the screen what ellipse size means is it's just whenever the text kind of cuts off it's just going to add a dot dot dot or ellipses as they're known and that's just going to make our recycler view look a little bit prettier in the event that the text is too long for the screen okay so we will end up coding the adapter by hand but there's one little boilerplate class here which is necessary to write before our list adapter and basically what it is is it's a diffutil dot item callback object so don't let all these scary names confuse you all this little class here does is it basically takes in some kind of datum model so let me open up note so note is basically the conceptual data which each item in our recycler view will represent so whatever data model you're trying to display so it could be like a user it could be an exercise it could be a note for example you're basically going to want to create a diff util dot item callback object which basically includes that particular data model as a generic type here so what is that going to do all it's going to do is it's going to allow you to to have some way if your data models have a unique identifier which they probably should of figuring out if an item at a given position has changed or not so if that's not super clear i think once i dive into the source code of the list adapter you'll probably understand how it kind of works all you need to understand here is that if you want to set this thing up properly whatever data model you have needs to have some kind of unique identifier in this case i've chosen the creation date of when the user basically creates the new node to be its unique identifier and then at some point as we'll see later on some internal class is basically going to use our callback object here in order to determine what uh items in the new list are different from the old list type of thing okay so in a moment we're actually going to basically delete this entire class and then rebuild it this is our adapter for our recyclerview but before we do that i want to take you through a bit of the source code of the list adapter class so as we'll see in a moment this thing is actually a sub class of recyclerview.adapter but it's integrated with a note or not a note in particular but some kind of diff util dot item callback and so as we'll see in a moment we that's why we needed to create that particular thing first and what i'd like to do is i'll take you through some of the internals of this class so that you can actually understand what's going on here so what i'm going to do now is i'm going to hit ctrl n and then i'm going to delete that because that's totally in my way and what i'm going to type is list adapter now up in this check box here you can see we have this include nonproject items so i'm going to click that and i want you to notice that all of a sudden we have a whole bunch of different options that have popped up so the one we're actually going to look at from the library the recyclerview library is list adapter here okay so what's going on here so all of a sudden we're in java land because this is a java class but what i'll do is i'll just kind of explain what's going on here so the first thing i want to point out here is that this list adapter class as i said before extends recyclerview.adapter so it's capable of behaving as a recyclerview adapter now the most important thing you need to unders understand with this particular class is that it has this async list differ member here called mdiffer now there's two constructors we can use to create one of these list adapters and the one we use accepts our diffutil dot item callback object that's important because it's going to basically create a new mdiffer member partly out of the callback that we supply so in a moment we'll actually see how this diff callback actually saves us time and effort but there's a couple other things in this class that i wanted to point out so as i mentioned before how we used to have to deal with our recyclerview adapter when the underlying data set that it's looking at changed is we had to call all these different functions like notify item inserted notify item range removed and all kinds of things like that so this was really annoying and caused a lot of problems for different developers and also the thing about using notify dataset changed is that it was a very inefficient function so anyways what we're going to do is as we'll see in a moment this list adapter when we want to actually update the contents of the adapter all we have to do is we just call this submit list function down here and we provide a list which contains whatever data model that we're working with so what i want to point out here is that when this function is called it's going to call the same function on our mdiffer object and then it's going to pass the list in what we'll do next is we'll look at the async list differ source and then we'll kind of see what goes on inside of there okay so there's one more source class that we're going to look at and understand i i'm just trying to give you an idea of how this thing works under the hood so i'm going to hit control n twice and then we're going to look up async list differ here so this is a pretty complicated class all i want you to want you to understand here is that this async list differ class has a main thread executor object here and what that's going to do is it's going to allow it to call back to the main thread and then we'll see it also is capable of doing work on a background thread this is important because if you're making a huge update to a recyclerview that could potentially be a longrunning operation so this is part of the magic of using this particular setup with listadapter and async list differ is that it's going to allow us to figure these updates out on the background thread appropriately and you don't actually even need to know what's going on here i'm basically just taking you through the source code as an extra step so we have our main thread executor and the only other thing i want to show you uh in this particular object here is i want to scroll down to the submit list function and just remember submit list is what we're calling on our list adapter and then that's going to get called on our mdiffer member okay so if we go down to submit list here we'll see the first function here accepts a list and then the next one is basically going to call the uh it's going to call an overloaded version of this function down here submit list and this is actually where the magic happens now the thing you i just want to point out to you is if i scroll down i i know this is a really horrendously uh huge function here but if i scroll down here just understand at a certain point we're going to say mconfig don't worry about what that is it's basically going to get a background thread executor and this is how it's going to actually calculate the difference between the old list and the new list and do that work on the background thread for us now importantly one little detail if you're wondering how it actually gets a hold of the note diffutile callback that we created understand that it's going to get a hook to that class through this m config object here which we actually created up in the list adapter somewhere here and we have a little builder class there and so it's going to get a hook to the diff util callback that you wrote and then from there it's going to ask it to compare the different items and that's ultimately why we needed to create our diff util callback once all of this is done it's going to dispatch this result to the main thread okay so now that we've had a look at the internals of the list adapter class that we'll be working with and hopefully that was interesting to you uh if you enjoyed going through the source code then please let me know down in the description box below and i'll try and do that kind of thing in the future so anyways at this point we're going to rebuild our note list adapter class and what we're going to do is just go ahead and open it up and we're just going to select everything in here except the import statement at the top and we're just going to delete it like so all right so you might be wondering at this point ryan how exactly is that making things easier for us that seems kind of complicated well the good news is that the complexity in the classes that we just went through is going to result in less complexity in the classes that we're going to be writing momentarily so in order to actually write out our adapters constructor we need to create our view holder object first so we'll start with that so this class is going to be called class note oops can't type note view holder it's going to have one property here which is going to be called root and it's going to be of type view and we'll see what happens in a moment with that and then it's going to have it's going to extend recycler view oops that's not what i wanted recyclerview dot view holder like so and what we'll do is it's going to complain because it's expecting this thing to accept a view so that's where we'll pass in this root view object here and so that will become the item view property of the view holder and just take note of that because we'll use it later on so the purpose of this class is it's basically kind of like a bridge between our note data model or whatever data model you'll be using and our item note layout so it's kind of like a virtual representation of the layout and so in our particular layout we really only need to represent the in this case the creation date and also the contents of the note in the actual layout so it follows that we just need to include two different uh references here so the first one is going to be called var content for the contents of the note it's going to be a text view and it's going to equal root dot lbl message so again don't forget root is referring to this thing here and then i'm just going to select at the click at the end of here and i'm going to hit ctrl d and this next one is also a text view it's going to be called date and it's going to point to root dot lbl date and time so just a really quick aside here about the note view holder if you're wondering where the name recyclerview actually comes from or what it refers to it basically means that as the user is scrolling through their list of items in the recycler view the recyclerview adapter is going to recycle the viewholder objects instead of creating a viewholder object for every item in the recycler view so minor point here but it's just kind of important to understand that that's where we actually get the efficiency of the recycler view and why it's called as such okay so now that we've got our view holder set up we can actually write the class declaration for our adapter so what that's going to look like is we're going to type class note list adapter i'm going to leave the constructor empty for a moment but we will put something in there and then this this class here is going to extend list adapter and it's going to basically accept a couple of different uh types here so what we need to do here is if you want to figure out what this particular what a given class needs in android studio for constructors or types like this generic types we can hit control p and it's actually going to kind of give us some kind of idea so in the case of t this actually refers to our data model so in this case i'm going to type note and then for the second one we have some kind of view holder object and that's going to end up being our note view holder and that's why we needed to create that thing first so in here i'm going to type note list adapter dot note view holder now it's still complaining because as you can see here we're referring to something which is supposed to be within note list adapter so i'm just going to throw down some curly brackets here and then we're going to move that note view holder object into the adapter like so so there's obviously a couple things we need to fix here so go ahead and click on the red highlighted note list adapter here and what i'm going to do is i'm going to hit alt enter and then we can click on implement members or hit enter and make sure you select both of these and then hit ok and so these are the functions that you basically need to implement in order for this thing to work properly notice how there's a couple fewer functions than compared to a normal recyclerview adapter and that's because some of those functions are actually handled inside this list adapter class so we'll get to implementing those in a moment there's another thing we need to deal with so our list adapter is showing up red and if i click inside the parentheses here and hit ctrl p it's going to say that it's expecting some kind of diffutil dot item callback object so all we need to do in this case is i'm just going to type note diff util callback and then we'll add brackets at the end of it and that's going to actually create an instance of the note diffutile callback object so in my older tutorials the way that i handled click events was basically to either nest the adapter inside of the fragment or activity which it was supposed to call back to or by holding reference to whatever class it was trying to call back to as an interface so we're gonna do neither of those and take an option which is a little bit more decoupled and i think a little bit safer so what we're going to do instead is we're going to use a mutable live data object to call back to the fragment so what we'll do is we're going to type val event and it's going to be of type mutable live data and the type is going to be a sealed class which is note list event so if you're wondering exactly what this is and how mutable live data work go and check out the particular part of the tutorial where i actually discuss these topics just really really quickly note list event is a sealed class which represents different events which can occur in the front end and mutable live data is basically something that can be observed but this mutable word means that we can change its value and the value is what's basically wrapped up here whenever we want to and when we change it if our fragment for example happens to be listening to this mutable live data object then it will know when a particular event happens and what the details are so in order to complete this we're just going to have to actually create this thing so we'll say equals mutable live data and we'll give it our constructor so the first function that we'll implement is oncreateviewholder so uh beyond what the name implies here basically what this particular function does is this is where we actually inflate the layout which our recyclerview will use so what we're going to do is we're just going to mess around a little bit here so we're going to say val inflator equals layout inflator dot from and so we're going to use this parent object here which is a view group so from parent dot context and that's going to get a hold of a context object now this is really important whenever you're messing with context you need to be careful about memory leaks and there's a particular step we're going to go over in the fragment which is going to prevent this particular adapter from leaking this is kind of a problem with adapters is we have this ugly situation where it's a class that needs to have access to things like layout inflators and the view hierarchy but it might be somewhat detached from the life cycle of say the fragment so like i say we'll see a specific step we need to follow in the fragment in order to make sure that this isn't an issue for memory leaks anyways once we have our layout inflator object what we'll do next is we're going to type return note view holder like so and inside of this note view holder object which expects a root view this is where we'll actually do our inflation so we're going to say inflator dot inflate and so in here we're going to provide the actual item note layout which is the layout of each item in the recycler view r.layout.item note and then we're going to give it parent which was passed in up here and then we're also going to provide we're going to say false for attach to root okay so some of you might be wondering what exactly is this attached to root and why is it false if we leave it false does that mean that our views our view holders are going to be magically floating around the user interface and unbound to anything the reason why we're passing false in here is because we do not actually we don't write the code to attach this particular view to the view hierarchy so basically what that means is that it's going to inflate this r.layout.itemnote view it's going to get some layout parameters from this parent object and if i hit control p notice this thing is called root and so just understand that everything is going to work fine when would you want to use attach to root true that would be if you are writing some particular class which is responsible for attaching a view to the hierarchy in this case this occurs internally so we can just leave it false and we don't have to worry about it all right so what we're going to do next is we're going to write out our onbindviewholder function so the first thing we'll do is we want to basically get a hold of the note item at a given position and position is provided here so what we'll do is we'll call getitem which is a function from the adapter and then we'll pass in position then we're going to say dot let so basically what's going to happen here is we're saying okay get this thing and then in this block of code as soon as you get that thing i want to do something with it so in this case just to make things a little bit more legible instead of using the it reference which is a little bit confusing to some people i'm just going to type note so we're going to give a name to the thing that is returned by this function and then it kind of pops up up in here then we need to add an arrow thingy here so what we're actually going to do is once we get our note object here we need to bind it to the viewholder object which was passed in so what we're going to do is we're going to type holder dot content for the first one and remember that's just what we defined down here holder.content.txt because it's a text view equals note dot contents i'm going to hit control d and for this one we're going to say holder.date.txt equals note dot creation date and then what we'll do after that is we're going to add a click listener to the entire sort of root layout of the view holder object so we're going to say holder dot item view dot set on click listener and we're just going to use a lambda in this case again so what's going to happen is when this on click listener is fired whatever we write in here is going to be executed and so what we're going to do in that case is we're going to publish an event to anything which is listening and the way we're going to do that is we're going to use our event mutable live data property up here so what we want to do there is we're going to type event dot value to get the value of the mutable live data object then we're going to set that value to a particular kind of event in this case the event will be note list event dot on note item click and then that thing requires a position which will be the position that is passed in in on bind view holder now i'm sure some of you are wondering what this class looks like so i'll pull it up really quickly so note list event and just understand it has a couple different events basically any event which can occur in the note list feature of the application and the one we used is on note item click and as you can see here it accepts a position as a property which is what we pass into it so that's actually it for our adapter object so what we'll do to finish this video off is i'll take you through the fragment which holds the recyclerview and interacts with the adapter now we're not going to code everything out because that would take a needlessly long time and i've already explained how to code up fragments in a previous video but what i will do is take you through specific steps which you probably should take to avoid things like memory leaks and to make sure that everything gets set up properly okay so i've opened up note list view now as you can see here we have a reference to the adapter in the fragment i do recommend taking that route and not putting a reference to the adapter in something like a view model the reason why is that you don't really want to be putting classes which have a reference to like layout inflator and context and the view hierarchy in something like view model so in this case like i say we're talking to it through the fragment here now this is a really important step here you can see i've overridden on destroy view in the fragment so what was happening is that after i got this thing all set up i was getting a very strange memory leak and i figured that out by using the tool leak canary a very awesome tool so i was trying to figure out what was going on here and after a bit of googling i figured out that in certain cases and again this is just the feature a feature of the fact that our adapter is tightly coupled to the view hierarchy and context and layout inflator and all that stuff if you do not set the adapter property of the recycler view and that's what this thing is here to null then chances are you may get a memory leak i think it partly depends on how you have everything set up here but in this particular case if we want to have our adapter sort of separate from the fragment i did need to include this detail here otherwise i got a memory leak now some of you may be wondering and i went over this in the fragment tutorial in this series but the way that we're able to just directly refer to these xml views like so is by using kotlin synthetic properties up here so go check the fragment tutorial out if you want an idea of how to do that it basically completely eliminates fine view by id which is really handy anyways the only uh function well there's two functions we're going to look at next so one of them is going to be setup adapter here and so this is just a helper function that i've created so that we don't have just one giant onstart function and when i scroll down to it this is what we have here so what we end up doing is we create a new instance of our note list adapter and we assign it to our adapter reference the next thing that we do is we get a hook to the event property remember that's our mutable live data object and then we observe it so that when a click event happens in the adapter in the recyclerview it's going to pop up here now since our fragment has referenced the viewmodel as well what we'll do is through this lambda function here that's where we will pass the particular event and remember that contains the position of the item that was clicked we passed that into the view model and then let the view model figure out what to do from there now the last thing that we do after we get that set up is we assign our recyclerview its property its adapter property to the adapter we just created and now for the moment you've all been waiting for how do we actually get our data into this particular recyclerview adapter and recyclerview so if i scroll down to the observe viewmodel function and just note that i'm calling that after i set the adapter up so just for people watching this make sure you kind of don't mix these steps up here we're setting it up first and then we're asking the viewmodel for the data so if i scroll down to the particular observable which is note list so that's of course our list of notes we observe it and then when we receive a new note list all we have to call is adapter dot submit list now don't worry about this function here this is just like ui animation boilerplate stuff this is seriously all we need to do to provide a new list to our adapter and anytime we change the underlying list it's going to pop up in here we're going to call adapter.submit list the diffutil is going to figure out what to do from there and then we are set no more notified data set change notify item inserted or confusion with creating a new list of data or all those kinds of things because for anyone who worked with recyclerview before it was actually kind of difficult and confusing how to like for example update an entire list or change part of it or things like that so all of that work that we did earlier did actually ultimately make our adapter simpler to work with and in this video i'm going to talk about integrating firebase auth and google signin provider in your android applications so in order to set up firebase authentication with google signin provider we will need to perform the following steps we'll create and configure firebase for an android project we'll set up a shawling certificate in android studio for debug builds we'll download the google services.json file after all the configuration is done we'll have a quick look at what we need in our project level and module level build gradle files and once that's all complete we will implement firebase off and google sign in provider in a small little android application and i will show you where to get the source in a moment now before proceeding i will need you to have an account set up with firebase so go ahead and do that if you haven't already so assuming you have an android app which you want to connect to firebase the easiest way to integrate it in recent versions of android studio is to select tools firebase authentication and then click connect to firebase if this process worked for you it should have created a new android project in firebase if it doesn't i suggest you enter the firebase console and create a new android based project manually next click the add firebase authentication to your app button this will add in some gradle dependencies to make things a little bit easier for you for the next step we will set up authentication in firebase go ahead and open up the firebase console and click on the authentication page next click sign in method in the following tutorial where we actually implement code for firebase auth we just use google sign in provider for your first try this you might want to just stick with email password authentication before we can do much else we need to configure a shell one certificate for our application this is just a unique identifier which we will add to our firebase project's configuration to get the debug certificate which android studio generates for us simply build your project at least once open the gradle tab in android studio and try either project name tasks android signing report or if that doesn't show up try app tasks android signing report in the run console locate your sha1 certificate and copy it back in the firebase console navigate to settings towards the bottom of the general tab you should see a card which holds your app id and allows you to download your google services json file on that card click add fingerprint and paste in the debug certificate now there's something very important i need to mention i'm going to show you how to set this up using a debug sha1 certificate which android studio automatically creates for you so this will allow you to test debug versions of your application but just understand that when you upload your application to google play if you sign that application with a different sha1 certificate which you really should do then you're going to need to add that certificate back into firebase as well and also if you're like me and you use app signing by google play you're going to want to go into the play console open release management and then app signing and you're going to want to paste the public sha1 certificate fingerprint in the console into firebase as well now that we have our certificate set up it's time to download our google services json file this file contains keys and configurations which will allow our client app to work with firebase and google sign in now if you downloaded this file before adding your shawlwind certificate you will need to download it again alright now that we have all that configuration done it's time to see how we actually implement firebase off and google signin provider in the application this will require properly configuring gradle implementing start signin flow and on activity result which are functions in the front end and implementing firebase auth in the back end of the application now i will only be writing out a couple functions in an entire application so please check the description box for the source code for the entire application i also build this application out in many different segments in this whole tutorial series so consider checking out the other videos if you want to know how i set up the view model the rest of the view and things like that before proceeding please double check that in your project level build gradle file you have the google repository present in the all project script within the build script and also that you have a dependency to google services in the build script as well in your module level build gradle file you'll want to have at least firebase core firebase auth and play services auth if you wish to use google signin in this app i chose to build a custom login ui and if you want to learn how to do that please watch part 4 of this tutorial series where i demonstrate how to build a custom material design login ui using constraint layout alright we need to write a couple of functions in the view so the first one is start sign in flow start sign and flow will start an external activity which will display the google signin user interface this will briefly pause our application and open up an external application now important point here r.string.defaultwebclient.id is not something that you actually write yourself and add to your strings xml file this is something which is generated dynamically from your googleservices.json file in older versions of google sign in and firebase you did have to add this in yourself but at this point there's just less configuration you have to do for google sign in dot get client if you're writing this in an activity you can just type this since this particular login view happens to be a fragment instead we'll just type in require activity like i said before we're going to be actually starting a different application so that's why we're creating an intent here and whether or not the user signs in the result will still get passed into on activity result once the user finishes the google signin user interface a quick point here rc sign in is just some unique integer key let me just show you it really quick yeah it's literally just leat so rc sign in which stands for request code sign in is going to get passed into on activity result if you are working in an application which uses on activity result for a couple different things then you're going to want to actually check to see if rc sign in equals leet in this case in this application we're only working with google sign in so i don't expect it to be called in any other case so basically what we're writing here is this is just a bunch of boilerplate code to see if the user signed in properly and also to see if we were able to get a user token from their google account what will happen is if we successfully get a user token we will end up passing that to the back end of the application and that's how we'll kind of connect both google signin and also firebase together but yeah this is pretty typical boilerplate code now google sign in dot get signed in account from intent returns a task object and our task object can throw an exception so we'll just need to make sure that we're handling that somehow since this is a demo application we'll just print it out to the console the last thing we'll do is we'll actually inform the view model that onactivityresult has been called here i'm using a sealed class to kind of model that particular ui event and i'm also creating this login result object let me show you what login result looks like it's actually just a simple data class as you can see it holds the request code and the user token which could be null all right now that our view is wired up the next thing we'll write is our implementation of firebase auth and google sign in provider in the back end now there are a couple different ways to write this code depending on what tools you use for concurrency since this is a kotlin app and i want the back end to be very decoupled from the front end we will manage concurrency and callbacks using coroutines so our first function here is called sign in google user this function takes in the id token we collected when the user successfully signs in with their google account this function is used to create a new user and to log in a user which already exists assuming they're using google signin as i explained in my kotlin course an easy way to move a longrunning operation into a background thread in a suspend function is to use the with context dispatchers.io coroutine builder to wrap the function body my general goal with coroutines is to write code in direct style which is basically a word for no callbacks this makes code more legible and helps to avoid callback health so the first thing we'll do is we will request a credential from google auth provider then we're going to try and give that credential to firebase off so firebaseauth.sign in with credential returns a task object which we can add an oncomplete listener to in order to keep my goal of writing code in direct style we will create an extension function which will wrap the callbacks using the suspend coroutine builder so we're not actually going to write it out but i'll just walk you through it really quickly so we're going to be using await task completable what that basically means is we're going to await the task and we want to know if it completes or not but we don't actually care about returning any particular value in order to create this function we simply take in a task as a parameter and then we use the suspend coroutine builder so the way that this works is the continuation object is how we actually call back to the call site of the function which will be using our extension function here so what we do is uh we just add an oncomplete listener to our task object and we check to see if it's successful or not if it's successful we just resume the execution of the call cite function now i'm returning unit here because it doesn't actually matter what value i return and if it fails we call resume with exception let's see how that works back at the call site so what we'll do is we'll add a try catch block to wrap that particular function call now if it just resumes then like i said before it will just synchronously jump to the next line after await task completable in this case we will create a result wrapper result.build to signify that we just want to return the function successfully if we get an exception we will catch that exception and throw it also in our result wrapper all right so we only have two other functions to write out here so signing a user out is very easy at least in this particular application all i do is i just call off dot sign out now what i'll do is i'll just add that particular call into a result wrapper if it succeeds it will return unit which is basically a signal that things happen successfully but we don't care about any particular return value next we have get current user when the user opens the login screen the first thing the app does is request the current user from this particular backend function now it's important to understand that i've initialized firebase ahead of time in this class by calling firebaseauth.getinstance generally speaking you will want to initialize firebase ahead of time instead of calling it just before you call for example auth.currentuser and the reason for that is if you call off.currentuser before firebase is properly initialized then it will basically just return null to you no matter what happens that's even if the user is actually signed in so if off.user does equal null then we will actually just return null in the result wrapper we will return a user object now again this is basically just a plain domain model which will hold on to the uid and the display name of a user if they happen to have one now the truth here is that i don't actually use the uid or the display name for anything so i could actually just return unit here as well and that would function perfectly fine for this application so that's all you need to set up firebase auth and google sign in provider in this video i'm going to show you how to put together a room database using kotlin coroutines here's a quick overview of what we'll be doing in this tutorial first we will build a room entity which is kind of like a bridge between sql and kotlin or java then we will build a data access object interface which is how we will actually get the data in and out of our room database then we will look at our room database class and a bit of information on threading and concurrency and finally we will see how to perform crud operations on the database using coroutines code operations stands for create read update and delete just a quick reminder that as usual the source code for this example will be in the description box so let's get started entities in room are essentially a bridge between a java or in this case kotlin data model and the schema of an sql database in simpler terms an sql database is basically a spreadsheet and each property of our entity will represent a cell in that spreadsheet so to set up an entity in room what you want to do is you'll want to start with a basic data model like i have here so what we'll need to do to set up this data model for room is we'll need to add a bunch of annotations to it above the class declaration you will want to add the entity annotation this annotation accepts quite a few different arguments depending on what kind of configurations you want or you can leave it blank for defaults this annotation accepts quite a few different arguments depending on what configurations you want or you can leave it blank and it will just use the defaults table name and indices shown in blue here are what are known as kotlin default arguments table name basically states that i want the name of the database table to quite specifically be notes if you were to leave that blank then room would simply use the name of your entity class by default as for indices here i'm basically saying that i want this particular value creation date to be indexed and we'll actually see where that comes from in a moment but what the indexing does is it basically just makes it more efficient to look up these particular room note objects by this particular value creation date every room entity needs to have at least one primary key you can also create a primary key out of multiple different properties using a composite primary key but we won't worry about that here what this annotation does is it basically tells room that this is the actual value which we want to use to distinguish between the different objects in our database in essence we are saying that this is the unique identifier for each room note object now in case you're wondering creation date is actually created in the front end of the application and it's essentially just the system time at which the note object was created at and then translated into a legible date format another optional annotation is the column info annotation basically what it allows me to do is specify a different name for each column in the database and this is really just convention sql doesn't typically use camel case like in java or kotlin but you don't really need to do this if you don't want to one final note here if you've read the documentation then you're probably aware that room can auto generate and auto increment primary keys we don't do that in this particular tutorial but i just wanted to mention that that is a possibility it does have some consequences though when it comes to updating rows in the database which i'll talk about later next we have our data access object or dao now essentially what this is is it's just an interface with a bunch more annotations which we'll look at in a moment this dao object will allow us to give our room database a bunch of functions which we can call on it to manipulate our data basically what it'll do once we set up all of the annotations is it'll handle most of the work of writing really ugly sql queries if that's not something you're interested in now there's an important point here many people use live data with room and that is acceptable since i'm a big fan of clean architecture i don't actually like to be passing live data objects through my domain layer so instead of using live data objects for concurrency we are going to be using coroutines thankfully in recent versions of room it basically works out of the box all we need to do is just add the suspend coroutine keyword and this will actually make it super easy for us to get the data in and out of the room database without blocking the main threat anyways the first annotation that we'll need is at the top of the interface declaration just at dao for our first function we will use the query annotation so basically how this works is the particular things we put within this query annotation will be translated into proper sql this basically just makes it so that it's easier for us to read and write the particular queries this first statement here select is pretty selfexplanatory but when it's followed by this asterisk it basically means select all from is also quite selfexplanatory and just remember notes is what i called the actual database so basically what we're saying here is get everything from the note database now when we want to get a note by id basically what we're saying here is select any note from the note database where the creation date which is a particular column in the database matches this creation date string which we pass into this function so notice how in this particular case we have this colon followed by the name of the argument that we give to the function this is how we actually pass that string data into the sql statement delete is much simpler all we do is we just add in this delete annotation we pass in the room note object and room will sort out the rest of the details for inserter update i'm doing something a little bit more complicated now remember how i said earlier that room is capable of auto ids dynamically for you since we are not doing that that's actually going to allow us to use this kind of upsert functionality here so how this basically works is we pass in a room note object into the room database and room will search to see if there's any note which exists in the database that matches the one we passed in here if it does happen to find one where the creation date matches then we are telling it explicitly using the on conflict default argument to replace that particular note object so effectively what we have here is both an update and a create new entry in the database at the same time now this works because creation date does not change whenever we update the particular note object again if you're using dynamically generated ids you have to be a little bit more careful about that before we move on to writing the database it's worth mentioning that room will generate an implementation of our dao class in the build folder of your android project you don't need to look at it but for those of you who are curious about how room works under the hood it might be interesting in particular notice how it does have a reference to a room database object and also it does override the functions in our interface such as insert or update note delete note and so forth in the case of get notes as you can see here it does a lot of tedious work for us so that is kind of the magic of room next we come to the room database class now this class is basically just a bunch of boilerplate and i would not advise you to write this out by hand just copy and paste it and change what you need in my case i copied and pasted this originally from android sunflower which is from the google samples repositories anyways there's only a few things to mention here notice how we are referencing our room note class also for some reason we change the structure of our database schema we will want to increment the version by 1 or something like that and also notice that we have a function which returns our note dao object as we'll see in a moment we actually create the room note database object and then we request this room note dao from it and that's how we'll actually make calls to the database as for this companion object it's basically just a really powerful singleton initializer and it ensures that we never have more than one instance of our database in memory for those curious the volatile annotation ensures that no matter what thread tries to access the instance it will always get a current instance not something that's cached and therefore out of date also this synchronized block here is kind of interesting so this is a lock which is a concept you'll be familiar with if you've studied operating systems basically what this means is that whenever a thread of the application enters this particular code block it essentially locks it off so that no other threads can access it at the same time it will go about doing its business building the database or retrieving it if necessary and this essentially doubly ensures that this thing does not get created more than once now if you're just here to use a room database this kind of concurrency stuff is not really that important to you so if it didn't make sense don't worry about it i just thought it was worth mentioning one final point here just like our dow you can actually look up the implementation of your abstract database class in the build folder if you want to see how it works the code is really ugly but i always encourage people to actually look at the source code of these things to better learn how they work so before i show you how we manipulate the room database i just want to show you how i actually create it each feature of this class has its very own injector which is a very simple dependency injection container written by hand so how we actually do things here is we will create an instance of our room database which requires context but we don't actually want to pass a reference to the database itself rather we will call dot room note dao to get an instance to the data access object in this app i use a repository which handles both online and offline calls to different data sources essentially how this works is we just check to see if there is an active user if there is an active user then we will of course perform our operations on a remote firestore database if no user exists then we just write to our local room note database so this reference local refers to our dow so working with the dow is super easy again we're using cortines so note that these are suspend functions anyways all we do is we just call whatever function we want on the dao so get local notes we call local.getnotes and it's a similar situation for the other functions we have here now you may be wondering why i'm returning unit here in these result wrappers just note that for the case of deletes and insert or updates i don't actually care about returning a particular value so to satisfy the signature of these result wrappers i just return unit also note that in my result wrapper if an exception is thrown it will be gobbled up by the result wrapper so that's basically how i handle errors at the same time the only other thing we need to look at here which i've added as kind of a custom addition is i have a bunch of extension functions and properties to map to and from note objects and room note objects let's have a quick look at those so in this project i have a big file called dataextensions.kt and i put in a whole bunch of different extension functions and extension properties so this is pretty typical mapping stuff the reason why i do this is i don't want all of the different room dependencies to be passing through my domain layer so basically before i write to the database or retrieve data from the database i just make sure that i'm mapping to and from some kind of plain note object as you can see this is why i choose not to use live data i want to try and keep things as clean as possible and in this video i'm going to show you how to manage a firestore cloud database quickly and easily using kotlin coroutines before proceeding please create a new firebase project for android let's enable firestore through android studio to do this you can go to tools firebase scroll down to the bottom of the assistant tab there you'll see firestore click on that click read and write documents from cloud firestore and click add cloud firestore to your app if necessary click connect your app to firebase then click add cloud firestore to your app which will add the appropriate gradle dependency to your build gradle file next we will hop into the firebase console and set up firestore we'll start it in test mode which does not have any access restrictions on reads and writes but obviously you want to avoid doing that for production builds once that process is done we're ready to go firestore is schemeless so we can start adding data without needing to configure things further as discussed in a previous tutorial number 10 where we built a room database this application uses a repository to hide the details of the end from the front end how it works is that we first check firebase auth to see if a user is in in this get active user function and depending on what that result is we either make our operations on the local room database or we perform operations on the firestore remote database also note that i have created a specific data model for firestore notes the only difference here is that i store just the user id in the firestore node whereas in the other node object it stores a nested user object this makes it easy to serialize and deserialize the data and also keeps references to firestore out of my repository interface finally as usual i encourage you to check out the source code in the description box as this is an open source application let's take a look at the functions we will be implementing for firestore get remote notes will get all notes by a particular user get remote note we'll get a particular note by a particular user delete remote node is pretty selfexplanatory and update remote note will be used to both create and update notes which already exist now like i discussed in part 9 of this tutorial i've created some quick and easy coroutine extension functions which wrap the calls to firebase as you can see here please watch the tutorial for a detailed explanation all of our calls to firestore and that's what this remote reference is here we'll start with this collection function which accepts a collection path argument of type string instead of having rows and columns which represent different items in a database firestore has documents to represent individual items or models grouped into collections so while it's important to remember that firestore is not an sql database this collection path is similar to the name of a table in a database if you happen to be familiar likewise each document is in some sense similar to a row or entry in a database table this app only has one collection and it's just called notes as we'll see with all of these different functions here we start everything by retrieving a collection and then we'll add some other functions to start manipulating it this call to the document function will either retrieve or create a reference to a document based on the path we give it now in this case the document path is a combination of the date at which the note was created down to the second combined with the uid of the firebase user this set function which accepts an arbitrary data model is how we actually populate our newly created document with the appropriate data so in other words what we're basically saying here is grab a reference to the notes collection create a document with this particular key or name or path and set the data at that path to be equal to the note which we passed in converted into a firebase note object in any case all we do is call this function here and if it succeeds properly we will return unit which basically just means hey this thing was successful and if an error gets thrown in away test completable then our catch block here will gobble it up and we'll know that something went wrong delete is really easy we just do exactly what we did before except instead of saying dot set we just call dot delete the process for retrieving a specific node is also similar in this case we call the same thing except in this case we will call get at the end of our change document request now this will return a task object which possesses a document snapshot so what we do is we call this to object function to turn it into a firebase so what we do is we call this two object function here which accepts some kind of data model in this case firebase note which is what i used to upload originally with and if we can successfully retrieve that i just turn it back into a plain old note object and then it's good to go forget remote notes which will return all notes for a given user again we request a particular collection and then we use this where equal to function which accepts the name of the field in firebase and then we just pass in the user id of the currently logged in user and then we call this get function now this particular task object will of course hold a list of document snapshots so what we end up doing is i pass it into this function here result to note list and it just returns everything as a result wrapper containing a list of notes that's just a basic mapping operation going on here so that's actually all we need to do to set up firestore it is ready to go and out of the box it actually works both online and offline which is pretty handy in this tutorial i'm going to show you how to set up dependency injection in a very simple modular way which does not require you to use a dependency injection framework this handwritten dependency injection implementation or build logic as i like to call it is suitable for small to medium scale applications if you are building a very large scale application then writing this code can be very tedious in which case i do recommend using dagger 2. dependency injection in simple english really just means giving an object its dependencies in the application we've been building our viewmodel classes talk to repository interfaces to perform i o operations on the data these repository interfaces can therefore be said to be dependencies of the viewmodel classes again the key difference here is that if the view model builds its own dependency as you can see on the right example here this is not dependency injection as i have said time and time again likely the most important concept in good software design is separation of concerns dependency injection is a form of separation of concerns except that instead of separating things like user interface code logic and data we are separating things which use dependencies from things which create dependencies as martin fowler summarizes it very well dependency injection is about separating configuration from use the way which i separate objects that build repositories from the objects which use repositories in this project is by writing an injector class for each feature of the application this class extends androidview model which is a subclass of view model designed to hold onto an instance of the application context the idea is simple for each dependency that i require i will write the code necessary to build that dependency and provide a public function which can be called for another class to get a hold of that dependency in this case we will be providing dependencies for a view model so we actually end up giving the repository to a view model factory object which we'll look at next note list view model factory is in some sense also an application of separating configuration from use this is the class i give the repository to and then it in turn gives that repository and the appropriate coroutine dispatcher to note list view model the only other piece of this puzzle is the place where we actually make our calls to our di implementation which in this case is within the onstart function of a fragment view model provider which is how we actually get a hold of our view models accepts a view model provider factory object as a second parameter which i showed you moments ago so all we do is we create an instance of the note list injector give it context so that it can build room and then invoke its function to return a factory there are many other approaches to separating configuration from use such as using the service locator pattern which i also use quite frequently the approach i showed you today hopefully gave you a way to start applying dependency injection without spending weeks configuring dagger 2. we've all been there and yeah it sucks
