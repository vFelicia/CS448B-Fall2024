With timestamps:

00:00 - instead of a boring portfolio why not
00:02 - make a game in this tutorial JS Legend
00:05 - Dev will show you how to use JavaScript
00:08 - and Kaboom JS to create an interactive
00:11 - developer portfolio hi everyone welcome
00:14 - to this new video today we will be
00:16 - building a 2d portfolio project so it's
00:19 - a 2d developer portfolio but as a 2d
00:22 - game and without waiting much further
00:25 - let's jump right into it so this is what
00:27 - we're going to build you can move around
00:30 - a house and then as you approach objects
00:33 - you can have a text box that tells you a
00:35 - bit more about uh yourself here I've
00:39 - selected some text for example here
00:41 - there's my CS degree this is my CS
00:43 - degree I hanged it on the wall because
00:45 - I'm proud of it and then if you move
00:47 - around you go here you have a place to
00:51 - have your resume can click if you click
00:54 - on that it will open a link with your
00:58 - resume hosted here for example this is
01:00 - just a template so this is how this is
01:03 - this is the idea behind a project here
01:06 - you have a bit of text so it's an
01:09 - original way of making a software
01:12 - developer portfolio uh I've seen a
01:15 - couple where it was in 3D but nobody
01:18 - seems to have made uh in 2D actually
01:21 - there there were some so I thought I
01:23 - would just teach you how to do it what's
01:25 - interesting here is that we're going to
01:27 - build this project with JavaScript and
01:29 - the Kaboom J Library so Kaboom JS is a
01:33 - library for making games in JavaScript
01:35 - it's very easy and intuitive but also
01:38 - for all that is the text here the text
01:40 - box the the text here as well this is
01:43 - all HTML and CSS uh here because the
01:46 - reason is that for this project
01:48 - everything should be uh interactable
01:51 - with the mouse or the touchcreen so if I
01:55 - open the dev tools and go to the mobile
01:58 - view and then here you should be able to
02:01 - move around and the text therefore
02:03 - should be responsive so here example you
02:07 - have a
02:09 - text and that's it you can close so for
02:13 - this to be achievable for the game to
02:14 - work on all aspect ratios it was
02:17 - important for me to make the UI portion
02:19 - of this project in HTML and
02:22 - CSS so let's jump right into project but
02:25 - before we do that I just want to mention
02:28 - a few things so if if you're interested
02:30 - in having written tutorials you can go
02:33 - to my substack the link will be in the
02:35 - description below where you can have
02:37 - written content that explains uh
02:40 - specific Concepts so on YouTube I make
02:43 - ful length project tutorials and
02:46 - sometimes you just want to know how to
02:47 - do one specific thing so the substack
02:50 - here my newsletter is for that so here
02:52 - for example for this project it's going
02:54 - to be relevant to know how to implement
02:55 - 2D uh topown controls uh for a mobile
02:59 - web game so here we go you have videos
03:02 - here that just showcase the results
03:04 - another thing I want to mention is just
03:06 - to uh showcase my uh buy me a coffee
03:09 - page so if you want to support the
03:11 - channel you can uh buy the the uh
03:14 - support with $5 a month and with this
03:17 - tier and you get access to this tutorial
03:20 - you're currently watching and all the
03:22 - future tutorials in advance so Early
03:24 - Access you you also get early access to
03:27 - the um do the source code and some
03:31 - progress updates as I do them so if
03:34 - you're interested in supporting the
03:35 - channel so I can focus more on making
03:38 - tutorials feel free to contribute here
03:41 - you can also just leave a a normal tip
03:44 - if you want all right so let's jump
03:46 - right into the project so I'm going to
03:48 - use for this project vs code uh it's the
03:51 - editor I use mostly for everything and
03:54 - here we're going to need a few things so
03:57 - let's start our project so I assume that
03:59 - you know how to use vs code at the basic
04:02 - level so you have it installed on your
04:04 - computer you also have it um you have no
04:08 - JS installed also which is going to be
04:10 - important for this tutorial because
04:12 - we're going to use vit vit is a bundler
04:14 - that allows you to um write your
04:17 - JavaScript in a more convenient way so
04:20 - we could use script tags as we did in a
04:25 - lot of the previous tutorials but with v
04:28 - you get uh uh you can install your
04:30 - dependencies by typing in npm install
04:34 - and it's it's just more convenient in a
04:36 - certain sense and you will also get Auto
04:39 - completion and U Snippets code Snippets
04:42 - from Kaboom from the Kaboom J library
04:44 - that tells you this is a this feature
04:47 - what it does which is something you
04:48 - don't get if you just use a script tag
04:52 - but feel free to follow using only a
04:54 - script tag if you want uh previous the
04:57 - setup sections of previous tutorials are
04:59 - going to teach you how uh so yeah I'm
05:02 - just going in this specific tutorial I'm
05:04 - not going to spend a lot of time on this
05:06 - so the first thing we're going to do do
05:08 - is to type
05:11 - npm create V at
05:15 - latest and then dot because we want to
05:18 - create the project within the same
05:19 - folder we're currently here in so here
05:22 - it's 2D portfolio so I hit
05:26 - enter and then we should have something
05:29 - appear need to install the following
05:31 - package
05:33 - yep and then here it's going to ask you
05:36 - to select the framework we're going to
05:37 - go with vanilla vanilla
05:40 - JavaScript and it's going to add a bunch
05:42 - of stuff so for now just do npm install
05:48 - Kaboom so it's going to install the
05:50 - Kaboom Jaz Library oops I I hit the
05:53 - wrong thing but hit
05:54 - enter is it going to work okay all right
05:57 - so it's going to install the project and
06:00 - then in your package.json you can see
06:02 - are your dependencies so here we have a
06:05 - kaboom all right now the rest of the
06:09 - project um we're going to need to set a
06:12 - few things up so the first thing we're
06:15 - going to set up is I'm going to remove a
06:17 - lot of the boiler plate you see here I'm
06:20 - going to remove main Jess I'm going to
06:23 - remove counter J I'm also going to
06:25 - remove this and with then v s G I think
06:30 - it's not needed as well so this this
06:34 - this remove and of and also the style at
06:38 - CSS we're not going to need need it for
06:40 - this project so
06:44 - delete okay now once we have this let's
06:46 - create a few folders we going to need
06:48 - the source folder SRC this is where
06:51 - we're going to write our
06:53 - code um our JavaScript code we also
06:56 - going to need the public folder I did
06:59 - deleted it by accident I wanted to just
07:01 - delete it was what was in the public
07:04 - folder and we're going to create at the
07:08 - root of the project a
07:11 - v
07:12 - config.js file this is going to be
07:16 - useful for a specific reason we want to
07:19 - be able to export so the way a bundler
07:22 - works it it compiles your JavaScript so
07:25 - the nodejs JavaScript that you write and
07:28 - the JavaScript that runs in the the
07:30 - browser is not necessarily this exact
07:32 - same thing so this bundler basically
07:35 - transpile or compiles your JavaScript to
07:38 - a JavaScript version or um it's a bit
07:42 - hard to explain to a version of
07:44 - JavaScript not not a version to
07:46 - JavaScript that can run in the browser
07:48 - as it is so
07:51 - y now the reason for this is that um a
07:55 - lot of features were not supported in
07:58 - the past in the browser version of
08:01 - JavaScript while in nodejs you could
08:03 - have things like convenient things like
08:05 - using import statements but now import
08:07 - statements are actually available in
08:10 - JavaScript in the browser so that's how
08:12 - I've been doing the various projects
08:14 - you've seen on the channel if you're
08:16 - familiar in the past in the past
08:19 - tutorials so in the V.C config.js we
08:23 - need to specify uh certain things so not
08:26 - uh just want to clarify again that not
08:28 - only does a bond lert transpile your
08:30 - code your JavaScript code so it can run
08:32 - in the browser it also do optimizations
08:35 - minification so that your your code is
08:38 - really Compact and takes the least
08:39 - amount of space all right so here I'm
08:42 - going to do
08:43 - export default and then Define config
08:48 - this is coming from vit so it's going to
08:50 - import it from vit
08:52 - here and then within we're going to have
08:57 - to specify the base
08:59 - so the base here when we run the npm Run
09:04 - build command which is used to do the
09:07 - transpiling and gives us the actual
09:10 - code gives us the actual code that is
09:13 - going to be used um that you actually
09:16 - put on your server or on h. to have your
09:21 - we website up we need this base thing
09:25 - otherwise it's not going to be able to
09:27 - find the assets for examp example the
09:29 - Sprites with used we use with Kaboom
09:32 - Jazz the second thing we need to specify
09:35 - is the build and here the minification
09:38 - we're going to use something called
09:39 - turer instead of the default es build so
09:43 - the reason for this is due to caboom
09:45 - there is a bug with the way Kaboom is
09:47 - made that if you just use the default
09:51 - it's going to give you code that doesn't
09:53 - work the the the actual output will not
09:56 - no longer work so that's why we need to
09:59 - install this alternative called
10:02 - turer which is going to make our code
10:04 - turer so smaller minified so once this
10:08 - is I should have installed it as a
10:10 - dependency so
10:12 - npm d-d for
10:15 - dependency
10:18 - install um turer I think that's the
10:21 - command or if it's not that it's going
10:22 - to be the
10:24 - reverse all right now if I look at the
10:26 - package.json you can see that I A Dev
10:29 - dependency we have added turer okay we
10:32 - have everything we need so now I'm going
10:35 - to create a main.js file and in the
10:38 - index.html we're going to have to do a
10:40 - couple of things so I'm just going to
10:43 - remove that so the first thing we
10:46 - need is to create a style tag within the
10:51 - body this is where we're going to write
10:53 - our CSS now you could have decided to
10:55 - use an external uh CSS file but but
10:59 - because this project is not really CSS
11:02 - heavy it isn't really that
11:04 - necessary the second thing we need to uh
11:07 - modify is here the script tag that
11:09 - Imports the main.js file we need to
11:12 - actually modify the path to be Source
11:15 - like
11:16 - that because we we have created this
11:19 - Source folder in which is our main.js
11:25 - file okay now in the div we actually can
11:30 - work this out later but be um actually
11:34 - never mind here we're going to create
11:36 - our
11:37 - canvas that we're going to give the
11:39 - control of it to
11:41 - Kaboom so I'm going to call it game the
11:45 - ID is going to be game and here we're
11:47 - going to have a
11:48 - div that is going to have the ID of UI
11:52 - I'm not sure if I'm going to use this
11:53 - later on I might just remove this ID
11:55 - which just is going to contain
11:56 - everything that is the UI so the text
11:58 - box and text all right now that we have
12:02 - this in our source folder I'm going to
12:06 - create a file this file is going to be
12:09 - called Kaboom context. JS so CTX to
12:13 - abbreviate
12:14 - it and this is where we're going to set
12:18 - up Kaboom so I'm going to use import
12:21 - Kaboom from Kaboom this is possible
12:23 - because we have installed Kaboom
12:25 - JS and you can see that there is a
12:28 - difference in the way native JavaScript
12:31 - that works in the browser deals with
12:33 - Imports and how this nodejs version of
12:35 - JavaScript works so if we were to use
12:40 - the native
12:43 - JavaScript in the browser with modules
12:46 - you have to add the JS for the file
12:50 - extension you want to import but this is
12:51 - not needed when you're using a tool like
12:55 - vit okay so here I'm going to create our
12:59 - canvas um or Kaboom context which is
13:03 - going to be
13:04 - unique and through that object this K
13:08 - we're going to call all the functions we
13:09 - need so we're going to pass this around
13:10 - in our project I think this allows us to
13:13 - have cleaner code as we as the project
13:16 - grows instead of having to instead of
13:19 - importing Kaboom globally where every
13:21 - all functions can be called directly
13:23 - from anywhere so this is a pattern I
13:26 - recommend that you use for your Kaboom
13:28 - Jazz prod projects so in when you create
13:31 - a the Kaboom context you need to pass a
13:35 - few params actually don't need to pass
13:37 - any params by default but if we want to
13:39 - achieve the thing I I said about not
13:42 - making it Global you have to pass in the
13:44 - global property and set it to
13:46 - false then here this is going to be
13:49 - relevant for the fact that we want our
13:51 - project to work on moob mobile as well
13:54 - so we want to have the touch to Mouse
13:56 - property which again is from kaboom and
13:59 - set it to true it's going to translate
14:01 - all touch events uh on the phone to
14:06 - click events so that you can basically
14:08 - write your code with the mouse in mind
14:11 - but it's going to work just just as well
14:13 - with mobile and then finally we can have
14:16 - the canvas property where we're just
14:18 - going to give to Kaboom the canvas
14:21 - element and the way we're going to do
14:23 - that is by using document get element by
14:26 - ID and here we give it the game ID if
14:31 - you remember in
14:32 - index.html we gave to this canvas the ID
14:35 - of game so we're just telling Kaboom
14:38 - here take the the element take control
14:40 - of it and do whatever you want whatever
14:42 - you
14:43 - need okay so now that we have this
14:46 - everything is
14:48 - fine and in
14:51 - main.js we can start writing our code
14:54 - but you know before doing any of that
14:56 - let's create all the other files we're
14:58 - going to need so constant. JS it's going
15:02 - to contain as the name suggests
15:05 - constants which is also going to con
15:07 - take contain the specific dialogues and
15:10 - the scaling constants Etc and then
15:14 - finally we need the
15:19 - utils file which is going to contain a
15:22 - few functions that just to make our code
15:25 - look nicer so in this this project it
15:27 - should not take too much too long
15:30 - compared to my previous
15:31 - projects so yeah you don't if you could
15:34 - have made everything in just M.S if you
15:37 - want it all right so now in the public
15:40 - folder is actually where we're going to
15:42 - store our assets what I need you to
15:46 - store is the font monogram. ttf you're
15:49 - going to find this in the link in the
15:52 - description of this video if you're an
15:55 - early member of the yeah if you if
15:59 - you're watching this in Early Access you
16:01 - should have also a link I'm either going
16:04 - to drop it in the post or in the actual
16:07 - video so you should uh it should be
16:11 - obvious where to get it and now we're
16:14 - also going to need the Sprite sheet that
16:16 - we're going to use for this project this
16:18 - is the the Sprite sheet uh the link is
16:20 - in the description as uh as with the
16:24 - text and then uh finally we're going to
16:28 - use an external program called tiled to
16:30 - draw our Maps but for now let's just
16:32 - keep keep those two things and then in
16:37 - main.js let's actually start writing our
16:39 - code so I'm going to import K uh the the
16:44 - the context from
16:47 - Kaboom and here the first thing we're
16:49 - going to do is use the load Sprite
16:52 - function it's a function that allows us
16:54 - to load a an image as a Sprite and then
16:57 - we can specify a bunch of frames so here
17:01 - I'm giving it the name of sprite sheet
17:04 - and the second param should be the path
17:06 - where to find it and it's going to be
17:08 - Sprite
17:10 - sheet.png now the reason this is just SL
17:14 - spray.png PNG despite the fact that it's
17:17 - in the public folder so normally you
17:20 - would think that it would be do slash
17:22 - and then public SL spreadsheet the way V
17:26 - works is that you can assume that
17:29 - everything that is in the public folder
17:31 - can be directly accessed uh like that so
17:34 - this is something specific to V now the
17:36 - third Pam is going to contain a bunch of
17:40 - properties that tells Kaboom how to
17:41 - slice the image into various frames the
17:45 - first two properties is is the slice X
17:47 - so how many frames are on the xaxis here
17:52 - 39 how did I come up with this number I
17:55 - just counted I just counted the number
17:57 - of frames the the the number of frames
17:59 - here you could do that with tiled as
18:01 - well uh to give you the the
18:05 - number um and then this is something you
18:07 - should know so for example each of those
18:10 - is in is a a each frame in this image is
18:13 - a 16 by 16
18:16 - tile and that means you can know roughly
18:20 - like if you take the the length of the
18:22 - image which is here
18:26 - 624 and then you divide it by 16 you're
18:29 - going to get the number of tiles of
18:32 - frames that are going to be on the
18:33 - x-axis so you can manually calculate it
18:36 - with math all right slice Y is going to
18:40 - again describe the number of frames
18:43 - there are in the Y AIS the same logic
18:45 - can be used to calculate it so knowing
18:49 - that every frame is 16 by 16 this is the
18:52 - way this Sprite sheet is designed you
18:54 - can just take uh look at the height of
18:57 - the image the properties or or here in
19:00 - vs code on the bottom right corner and
19:04 - you divide that number by 16 and you get
19:07 - the number of
19:09 - frames all right
19:12 - now here comes an interesting part it's
19:14 - called the anims
19:16 - property and here it's where you define
19:19 - you hook up specific names to specific
19:23 - animations so here the idle
19:26 - down animation for our character it's
19:29 - just going to be one frame and it's
19:31 - going to be frame number
19:33 - 536 now how did I discover this it's by
19:37 - using a program called til this program
19:40 - is called tiled and I think it's
19:42 - actually a good time to
19:45 - um create our Maps basically create our
19:49 - map and while setting things up we going
19:52 - to see how I figured out but just to be
19:55 - quick you click here on the frame
19:59 - you want and then you get the ID so the
20:01 - number of that frame now let's assume
20:04 - you don't have any knowledge of til so
20:07 - install til by using the link in the
20:10 - description once you have it you should
20:12 - have this editor let's assume you have a
20:15 - new project so I'm just going to create
20:16 - a new map and then let's
20:20 - um I don't remember the dimensions I
20:23 - I've used but don't touch anything here
20:25 - except specify the width as 16 pixel the
20:28 - height the height as 16 pixel as well as
20:31 - for the map size make it fixed and then
20:34 - take these numbers by
20:35 - default all right we have the the map
20:38 - here now another thing you can do
20:41 - because if you're using til on a wide
20:44 - monitor for example things might not be
20:47 - clear so you go to edit preferences and
20:51 - then in
20:52 - interface uh actually it's in theme you
20:55 - you you check use custom interface font
20:58 - and then you can select a specific font
21:00 - and then increase the font size this is
21:03 - useful for for you to be able to clearly
21:06 - read
21:07 - things once you have this in the map you
21:12 - can go to I think it was map properties
21:15 - actually maybe not World um okay in
21:22 - view
21:24 - snapping no snapping for this project uh
21:27 - if you clicked on snapping snap to Grid
21:30 - it's going to make sure that everything
21:31 - fits into a grid uh pattern uh I think
21:35 - for tiles it's in Grid uh pattern
21:39 - regardless but if for the collisions box
21:42 - we're going to draw we want to find more
21:44 - fine grain controls so that's why I dis
21:47 - activated it for this
21:50 - project okay now add a new tile set to
21:53 - the right okay now browse where you've
21:56 - put the the Sprite sheet in your project
22:00 - and Link it here so this is it so for
22:03 - the the path should be here and then
22:06 - this is specific to me so for you if
22:09 - depends on where you put it the actual
22:11 - project and then just don't touch
22:14 - anything the tile width and tile height
22:16 - should be 16 by 16 pixels and then hit
22:20 - okay and now you have the the
22:23 - spreadsheet so a good thing right now is
22:25 - would be to save the map so go to the
22:28 - the file save as and then name it map.
22:32 - Json and put it in the public folder of
22:34 - your project all right so you can see
22:36 - that I've named it map. Json this is the
22:39 - name I want you to to use and it's going
22:42 - to basically create a Json file in your
22:44 - public folder so if I minimize this and
22:47 - go here you can see that we have map.
22:51 - Json this is important because this is
22:53 - how we're going to know where to draw
22:54 - the
22:55 - hitboxes and where to draw certain
22:57 - things so if I go back to tiled for now
23:01 - we only care about knowing how I figured
23:03 - out the
23:05 - 936 so here it is 936 comes from the end
23:10 - as you click on the various other tiles
23:12 - you can see the various numbers that
23:14 - this is how you can know which frame is
23:16 - which okay now I'm not going to copy
23:21 - paste H I'm not going to write the code
23:23 - for this all the animations we're going
23:25 - to use by hand it's going to take too
23:26 - much time so I'm just going to copy and
23:29 - paste it
23:30 - here so here we have the idle down
23:33 - animation which is just one frame with
23:35 - the walk down the walk down animations
23:37 - so how do you specify animations with
23:39 - more than one frame in Kaboom JZ you use
23:42 - this uh an object you pass in an object
23:45 - with the from property which is the
23:46 - starting frame the two property which is
23:49 - the finishing frame and whatever or not
23:51 - you want to Loop this is not mandatory
23:54 - because by default looping is false but
23:56 - we want the animation to Loop always and
23:58 - we decide when to stop it and when you
24:02 - cancel it and then the speed is the
24:05 - frame rate so here eight frames per
24:07 - second for this so we have four frames
24:10 - in this
24:11 - animation so a speed of eight is what
24:14 - looked good so if I go back to title
24:17 - again you can see one two 3 and four
24:20 - this is how you know this is how I knew
24:22 - it was for animations uh for frames
24:25 - sorry and then here it's the same thing
24:28 - but with the various uh different
24:31 - directions so here for the side sideways
24:34 - we only need to have one of them I think
24:37 - we're using the the right one by default
24:40 - yep and we we're just going to flip it
24:43 - over when we need to make the character
24:46 - look
24:47 - left all right so now that that this is
24:50 - done I think we can just start uh
24:54 - drawing the map so I'm going to open
24:56 - tile again now
24:59 - here I really want to have the same
25:02 - thing but um yeah this is always a diff
25:05 - difficult part of the project where I
25:07 - just want to copy um the map layout
25:10 - instead of doing it manually but just to
25:12 - teach you so what what I'm going to do
25:15 - is I'm going to teach you how to make a
25:18 - water down like very simple version of
25:20 - this map and then you just take my map.
25:22 - Json file here and you use it uh so the
25:27 - the map Json file that I used in the
25:30 - project in the actual project is going
25:32 - to be in the description and this is
25:35 - just a u tutorial version that you can
25:38 - just swap out so this is this is just to
25:41 - teach you how to use til so once this is
25:44 - done I'm just going to use the actual
25:46 - real map. Json instead of writing the
25:49 - code as if anyway all right you get the
25:51 - point so just to teach you uh the way
25:54 - you draw things so let's
25:57 - have okay the way layers works so I'm
25:59 - just going to this is just a small crash
26:01 - course on titled how to draw maps and
26:04 - yeah so by default you have things
26:07 - called tile layers so tile layers are
26:10 - layers that contain tiles that you can
26:13 - draw there's another type of layer
26:15 - called the object layer which contains
26:17 - Collision boxes or spawn points which is
26:20 - basically needed to to know where to set
26:23 - where the collisions are Etc so let's
26:27 - let's say we have this first layer
26:28 - called
26:30 - Ground so you decide on the name and
26:33 - depending on the name the the result in
26:35 - Json file that you save is going to
26:38 - contain those those names so you can
26:40 - know which layer is which so
26:43 - here let's say I draw the ground like
26:47 - that so I drew a couple of tiles
26:50 - everything looks great now if you want
26:53 - you click on this button to add a new
26:55 - layer let's say I add another layer and
26:58 - I'm I'm just going to call it
27:00 - plants or uh
27:03 - props and then I can draw on top of it
27:06 - like
27:09 - that and that's basically it that's how
27:13 - you draw a map in kabo uh not kabo in
27:15 - tile now when you want to to add
27:18 - collisions what you do is you create an
27:20 - object layer call it for example
27:23 - boundaries and then here at the top you
27:25 - can have access to those shapes and then
27:28 - here for example a square let's say I
27:30 - want the player not to be able to escape
27:33 - outside the
27:35 - um the this little square so I can do
27:39 - here and then draw a grid like that here
27:42 - it's often better to have the snapping
27:46 - set to snap the grid if I do
27:50 - that it's going to be very easy to make
27:52 - perfect Pixel Perfect uh collisions uh
27:56 - yeah boundaries
27:59 - but now if I go back to here snapping
28:03 - and no snapping and I want to draw for
28:06 - example for this tree this specific
28:09 - shape and then this specific shape so
28:13 - you have more fine grain control and now
28:16 - this doesn't do anything on its own it's
28:19 - it's just for you to know that hey
28:21 - there's this layer called Boundaries and
28:23 - it's going to be an object layer and
28:24 - this is what and when you're using an
28:27 - object layer each object you create in
28:30 - that layer is going to have the XY
28:33 - coordinates and the width and its height
28:35 - so you can know what to draw what to
28:37 - where to draw the hit boxes when you're
28:39 - working in Kaboom or in JavaScript you
28:42 - don't you don't have to use Kaboom to
28:43 - use tile by the way now the other thing
28:48 - I want to uh talk about and it doesn't
28:51 - have to be a separate layer but let's
28:53 - say we create a separate layer and I'm
28:56 - going to call it spawn point
29:00 - uh not not spawn point what is this name
29:04 - anyway spawn
29:05 - point and then here you can use this pin
29:09 - and when you place it it's going to
29:11 - basically create a coordinate that you
29:13 - can use as a way to know where to spawn
29:15 - the player for example or NPCs or mobs
29:18 - Etc so this is how til works so once you
29:22 - you're ready with this you just save it
29:24 - now another thing I want to uh showcase
29:27 - is that this is not enough
29:29 - uh what we want so this is something
29:31 - specific to Kaboom so usually by default
29:34 - it's better to draw normally in a in
29:36 - JavaScript or in any like programming
29:39 - language it's better like it should be
29:41 - more efficient to draw the frames tile
29:44 - by tile instead of like having a an
29:47 - image that contains all the tiles but in
29:49 - Kaboom chz it's different in the sense
29:51 - that it is more performant and easier to
29:55 - maintain if you just go to your child
29:58 - editor and do export as an image so what
30:02 - this is going to do it's going to
30:05 - combine all of your tiles here as a
30:07 - single image so if I and only include
30:10 - visible layers so before doing any
30:13 - anything like that you need to make the
30:14 - spawn point and the object and the B
30:17 - boundaries layer invisible otherwise
30:19 - it's going to appear in your project and
30:22 - then you
30:23 - save and then you go to file export as
30:26 - image and then you export only include
30:29 - the the visible layer you don't touch
30:31 - any of that thing uh those things and
30:33 - then
30:35 - export now here if I go in my code edor
30:38 - you're going to notice you're going to
30:40 - understand so map you see all the image
30:42 - is baked as a single one so so here we
30:46 - go now this would be inefficient or less
30:50 - efficient in other um other libraries
30:54 - Etc but with Kaboom because it when you
30:58 - create new tiles you create new game
30:59 - objects it can be uh because game
31:02 - objects in kabon Jaz you create things
31:05 - called game objects which are are your
31:07 - usually your player your tiles anything
31:10 - and when you do that it is performant
31:12 - intensive because every game object has
31:14 - a few components those components do
31:16 - speci do some Stuff Etc so a way to get
31:20 - around that not have to do this or pay
31:22 - the the performance tax that comes with
31:24 - it there are many ways you can adopt the
31:27 - simplest one is just to bake your image
31:29 - uh to take your tiles and just combine
31:33 - them into a single PNG and just draw
31:35 - that as is now the tiled export is still
31:38 - useful because in tiled you're going to
31:40 - have this map. Json and then for layers
31:43 - that aren't tiles you get the object
31:45 - layer and the position of the hit boxes
31:47 - which is still valuable information
31:50 - you're going to need to draw the the
31:53 - headit boxes in your
31:54 - map otherwise the other option would be
31:57 - to use the on draw function in Kaboom JS
32:00 - to draw the tile specifically without
32:02 - having to create a new game object and
32:05 - but it's just more complicated for for
32:08 - it it's a better alternative but it's
32:12 - just more complicated and for this
32:13 - project I just opted with just taking a
32:16 - single
32:16 - image using a single image yeah okay I
32:19 - think I've teach uh I've taught you any
32:22 - uh everything important related to how
32:25 - to draw things in kab in tiled and Etc
32:28 - now what we're going to do is I'm going
32:31 - to swap the files here I have the map.
32:35 - Json map.png with the actual Maps so you
32:40 - can see actually one thing I realize now
32:43 - is never mind we you still need the
32:46 - Sprite sheet.png because it contains our
32:48 - character and the characters are
32:50 - character sprites are directly pulled uh
32:53 - from that image from Kaboom uh from that
32:56 - image are pulled the Sprite character so
32:59 - Kaboom still needs that but for the map
33:03 - for the all the other ties so you could
33:04 - theoretically remove everything else and
33:07 - just keep that and it would have been
33:09 - more efficient considering that when
33:11 - you're making a web game going you have
33:13 - to see how much uh data you're you're
33:16 - you're sending but those image are
33:18 - already very small
33:21 - anyway because it's pixel art okay so
33:24 - I'm going to swap my images uh my map
33:29 - and my Json file with the one I
33:33 - originally
33:35 - used and now if I go and look at the
33:38 - map. PNG you can see like the exact same
33:40 - map and if you look at the map. Json you
33:42 - can see the various tiles so let's take
33:46 - some time to explore how uh tiled what
33:51 - the map. Json what the tile export is
33:54 - contains so the things that are the
33:57 - thing that is very important is the
33:59 - layers property so til exports with a
34:02 - bunch of properties Mo most of which are
34:05 - useless uh for our purposes but the one
34:09 - that is useful is the layers property so
34:12 - if the layer is a tile layer it's going
34:14 - to contain the data property and it's an
34:18 - array containing the frame number that
34:23 - needs to be displayed zero is the
34:26 - absence of a frame
34:29 - for object layers though it's different
34:32 - they don't have the the data uh property
34:35 - what they have instead is the objects
34:37 - property which is an array containing
34:40 - every object that you've draw that
34:43 - you've drawn in this layer so the most
34:47 - important stuff is the X and Y
34:49 - coordinates and the width and the height
34:51 - of that object so this is useful for the
34:54 - boundaries all right so we have our map.
34:57 - Json everything is fine now let's load
35:00 - our um oh just one thing I want to to
35:03 - mention as well if you want to add to a
35:07 - boundary so this is often something you
35:09 - want to do you click here to uh to
35:14 - select an
35:15 - existing uh object when you are on the
35:19 - object layer this this little icon
35:22 - ignore this message for now and then you
35:25 - can modify the width and height Etc
35:28 - but you can also here in the properties
35:30 - tab add a name let's say I want this
35:32 - boundary to be to have a specific name
35:36 - let's say
35:37 - wall and when the player hits this H
35:40 - hits this we're going to know that hey
35:42 - it was a wall so you can use the name
35:46 - the data you pass here in Kaboom Jaz to
35:48 - know what the player is colliding with
35:51 - so now I'm just going to close this it's
35:53 - no longer necessary I'm just going to
35:54 - discard it and go back to my original so
35:57 - so here is a bunch
35:59 - of uh objects that I've named uh
36:04 - specifically like CS degree PC sofa
36:07 - table player TV exit Etc and for each of
36:11 - those we're going to have a different
36:13 - dialogue
36:16 - appear okay so let's go back to main and
36:21 - in
36:21 - main we're going to what going to do
36:24 - next is to
36:26 - import
36:28 - the actual map Sprite Which is a single
36:32 - PNG image now that we have baked it into
36:36 - a PNG instead of drawing every tile
36:39 - separately and then for the background
36:42 - the way you can set the background in
36:44 - cabun is using the set background
36:46 - function if you use this though you need
36:49 - to pass in a color and the way you can
36:51 - pass colors either via RGB or you can
36:54 - use the color class and the from heex
36:58 - method to specify a hexa decimal value
37:01 - the heximal value going to use for this
37:03 - project is 300 11
37:08 - 047 and now if I run the project so
37:12 - let's run it going to open up the
37:16 - terminal type in npm run Dev and then
37:21 - once you do
37:23 - that you can have click on Local Host
37:27 - and you should have your canvas so here
37:32 - we haven't done anything yet and things
37:34 - aren't looking great so we're going to
37:37 - have to change the the width uh of the
37:41 - div containing the canvas so that it
37:43 - takes the full
37:45 - screen so you know what let's do
37:48 - this um before actually writing the code
37:51 - Etc so let's go back to our
37:56 - index.html and in style tag going to add
37:59 - a couple of style styles so for the um
38:04 - for the app
38:06 - div so here take the ID and then we're
38:11 - going to
38:13 - specify a font a width of
38:17 - 100% so it takes the full width of the
38:21 - page a height
38:23 - of 100% as
38:25 - well 10% 100
38:28 - %. and then overflow hidden so that
38:32 - scroll bars do not appear ever we don't
38:34 - want scroll bar to appear in this
38:37 - project how you look at the result you
38:39 - can see that the canvas takes the whole
38:43 - Space okay
38:45 - now let's go back to main.js and then
38:49 - create our first scene which is going to
38:51 - contain or all of a code for that
38:53 - specific scene I just want to make sure
38:55 - that um for this project because we
38:57 - don't have multiple different scenes it
39:00 - isn't needed to create a scene but I
39:02 - just want to show you how it's done in
39:04 - Kaboom JZ so to create a
39:07 - scene so to create a scene you use the
39:11 - k. scene function you give it a name I'm
39:17 - going to call it Main and then what
39:19 - comes after is a function which is going
39:22 - to be the code that is going to run for
39:24 - that scene so here is where you you draw
39:28 - um you write your logic for that scene
39:31 - but before do doing any of that you need
39:33 - to specify using the
39:36 - K.O function what is the default scene
39:39 - so by default the game starts it goes to
39:43 - to the entrypoint main.js it loads the
39:45 - various assets set the background color
39:48 - defines the scene and then go to that
39:50 - main
39:52 - scene now here this function we passed
39:56 - here is going to we're going to need to
39:58 - have it as an async function the reason
40:00 - for that is because we're going to need
40:04 - to get the map. Json data and for that
40:07 - we're going to use a fetch call so const
40:10 - map data is going to be a constant I'm
40:13 - going to name to basically get the the
40:17 - map. Json data we need in our JavaScript
40:20 - project so here I'm going to use await
40:23 - await fetch which is a default web
40:25 - browser API I'm going to to explain
40:27 - everything in an
40:31 - instant and then here.
40:33 - Json so here in one line first we await
40:37 - the fetch function because it is
40:39 - asynchronous that means that uh if you
40:42 - were to not use await then your code the
40:45 - rest of the code would continue to
40:47 - execute so let's say I have some logic
40:49 - here it would continue to run uh while
40:53 - fetch is still ongoing we don't want
40:55 - that we want to load the map data and
40:58 - not move not move the rest of the code
41:01 - here un until it's done that's why we
41:04 - await it so basically waiting it and
41:06 - then once we do that we also need to
41:08 - convert it into a Json uh object and for
41:13 - that we need to use the Json function
41:16 - which is also as synchronous Json method
41:19 - which is also asynchronous that's why we
41:21 - need also to await so that we don't move
41:24 - uh to the next line of code before it's
41:28 - done so once map data is done and ready
41:32 - we move on to the next things so here
41:35 - I'm just going to create another
41:36 - constant called layers and I'm going to
41:38 - extract from map data the layers
41:40 - property so if we look at the map. Json
41:45 - file you can see that the properties
41:48 - that one of them was layers and this is
41:50 - really what we care about that's why we
41:53 - only we create a constant just this is
41:55 - just for it to look cleaner you don't
41:57 - have to you didn't have to create a
41:58 - constant to get it but
42:02 - yeah and then here we're going to create
42:05 - our first game object which is going to
42:07 - be our map so in kabon Jaz a game object
42:11 - can be basically
42:12 - everything uh players props Etc uh what
42:17 - what is a game object exactly it's um
42:20 - it's an object that contains different
42:22 - components those components can be POS
42:25 - positions area a body or a specific
42:29 - Sprite and the way Kaboom works is that
42:32 - by passing in an array of components you
42:35 - specify behaviors for your your uh game
42:38 - objects so it's a basically an entity
42:41 - component system I
42:43 - think so how do you how do you create a
42:45 - game object there are many ways uh
42:47 - actually two the first one is the make
42:50 - function which allows you to create the
42:52 - game object but not display it on the
42:54 - screen the add function adds it to the
42:57 - scene so either you have a choice either
42:59 - you make it and then later on you have
43:01 - to call the k. add function and pass in
43:04 - the game object like that or you use the
43:07 - add function from the get-go and pass in
43:09 - your array of components here so for the
43:13 - map what components are we going to need
43:15 - we're going to need to uh this the
43:19 - Sprite component to display the the
43:21 - Sprite the actual map the way we do this
43:24 - is simply by using the Sprite component
43:26 - which is offered by Kaboom and passing
43:28 - it the key for the Sprite you want to
43:30 - display we specified the key in the load
43:33 - Sprite function for the Sprite uh for
43:36 - the image map.png that's why that's how
43:39 - Kaboom is able to know in
43:42 - advance where what to display actually
43:46 - now the next component we're going to
43:48 - add is the positional
43:50 - component and it specifies the position
43:53 - that the game object will have on the
43:55 - screen when it is displayed and here it
43:58 - is
44:00 - zero well it's not necessarily only when
44:03 - it is displayed just the position that
44:05 - you could have regardless if it's if it
44:09 - is displayed or not and then if you use
44:11 - the add function then it's going to to
44:13 - draw it in that spe in that specific
44:17 - place and then finally we're going to
44:20 - need the scale component and we want to
44:24 - scale up our map because it it's pixel
44:27 - art it's small and we want it to be a
44:30 - bigger so a good practice I'm going to
44:33 - do is in the constant. JS I'm going to
44:36 - create a constant exportable constant
44:39 - I'm going to call it scale factor and
44:42 - I'm going to set it to four so we want
44:43 - to increase it four times and then in
44:46 - main.js I'm just going to use that scale
44:49 - factor constant and call it so it should
44:52 - automatically
44:54 - import the scale factor constant in case
44:57 - it doesn't add this at the top of your
45:01 - file all right now the next game object
45:04 - we're going to create is the actual
45:06 - player and for that I'm going to create
45:09 - a constant I'm going to call it player
45:12 - I'm again going going to use the make
45:15 - function
45:16 - here and the Sprites we're going to pass
45:19 - is the Sprite sheet
45:22 - itself but with a default animation this
45:26 - is something you can do when you have
45:28 - imported a a Sprite that has many frames
45:31 - so a Sprite sheet you have access to
45:34 - this second pram where you can specify a
45:37 - default
45:38 - animation and here it's going to be idle
45:42 - down now the
45:46 - second so the second component we're
45:49 - going to need is the area component this
45:52 - creates a hitbox for our player
45:56 - automatically
45:58 - and within you can add so uh it's not
46:02 - very visible so I'm just going to format
46:04 - this myself and then explain so the k.
46:08 - area component allows you to create a
46:11 - hitbox automatically for your player for
46:14 - your game object but you can specify
46:17 - things within by passing in an object
46:19 - with the following properties you can
46:21 - specify which collisions you want this
46:24 - game object so the player game object to
46:25 - ignore and I want to actually this is
46:29 - not necessary we don't need
46:31 - that this because in the in the project
46:34 - I I did it a different way uh initially
46:38 - but then then I found a better way which
46:40 - doesn't require to really need that at
46:44 - all but what we do need is to specify a
46:46 - shape so by default it creates a shape
46:49 - that is roughly the shape of your Sprite
46:53 - but sometimes you want really to control
46:56 - the shape of your hitbox exactly and the
46:59 - way you do that is by passing in an
47:02 - object with a shape property and then
47:04 - use for example k. rect which is going
47:07 - to create a
47:08 - rectangle and then the first param is
47:10 - the position which is the vector two my
47:13 - Vector 2 is X and Y coordinates and you
47:16 - can specify here the vector 2 is going
47:18 - to be
47:19 - 03 so we want the hitbox to be drawn
47:23 - from the origin and then plus three on
47:26 - the xaxis
47:27 - from the origin of the player itself so
47:30 - the area is going to be slightly placed
47:32 - slightly differently than the Sprite
47:34 - itself so that um the head the hbox I is
47:39 - positioned properly and for example the
47:41 - the player doesn't look like they're
47:43 - sinking in a platform or something like
47:46 - that so this is something you have to
47:48 - play with yourself to determine which um
47:53 - which values are the best and now the
47:56 - second and third third params are the
47:58 - width and height of that uh hitbox I'm
48:01 - going to go with 101 it says on purpose
48:04 - smaller than the player Sprite Which
48:06 - should be 16 by
48:08 - 16 now k. body make sure uh is another
48:13 - component that actually makes our player
48:16 - a tangible physics object that is can be
48:19 - collided
48:21 - with and yeah that's basically it it's
48:24 - done automatically by kaboom
48:27 - now we can also use the anchor component
48:30 - to draw the player from the center
48:34 - instead of from the top left corner so
48:36 - this um the way things are drawn by
48:39 - default is that the X and Y coordinates
48:42 - are actually the coordinates of the T
48:44 - top left corner of the object you want
48:46 - to draw if you don't want that you want
48:48 - the X coord X and Y coordinates
48:50 - correspond to the origin you do uh you
48:53 - use the K do uh k. an anchor and then
48:57 - specify which so from the center now
49:01 - it's not the X and Y coordinates that
49:03 - are in the wrong position it's the the
49:04 - where the image is drawn from so that's
49:07 - something so for
49:09 - example uh yeah so the player instead of
49:12 - being drawn from the top left corner
49:16 - where the top left corner of that image
49:18 - will be the x and y coordinate of that
49:20 - player it's going to be the center drawn
49:23 - from the center so feel free to try and
49:26 - change the values or just try without
49:28 - and and then hit F the F1 key to open to
49:31 - the debug mode in KJS and then you can
49:34 - see the
49:36 - difference all right now we need a k
49:39 - position component uh we aren't going to
49:41 - specify a specific position now we're
49:43 - going to do this later when we're
49:45 - getting the data from our map we going
49:47 - to use this spawn point so here if I go
49:49 - back to tiled you can see I created a
49:51 - layer in the original called uh spawn
49:54 - points and it's just this little pin
49:56 - with the name player which determines
49:59 - where to spawn so if I click on it here
50:02 - you can see I've decided on this name I
50:05 - just wrote it here and then it's going
50:07 - to give us the X and Y coordinates so so
50:09 - we're going to know where to place the
50:14 - player all right uh another thing we
50:16 - need to do is to scale the Sprite for
50:19 - the player because for now it's going to
50:20 - be small it's going to be a 16 by 16 and
50:22 - we want it to be at least the same let
50:25 - scale the same as the map so that
50:28 - everything looks
50:30 - right and then finally well not finally
50:35 - but we have what comes next is in Kaboom
50:38 - JS if you want to hold properties for
50:41 - that game object you can pass in in your
50:44 - array of components a an object and then
50:48 - do put whatever properties you want and
50:51 - then they're going to be accessible
50:53 - directly by doing for example player.
50:55 - speed if I create this speed property
50:57 - here and I'm going to put it to
51:01 - 250 I'm also going to create a direction
51:04 - property is going to be useful to know
51:06 - which animation to play by default it is
51:09 - down and then is in
51:13 - dialogue uh property which is initially
51:16 - is false so what why we want this is
51:19 - that when the player is a is in dialogue
51:22 - that means that the text box is
51:24 - displaying text we don't we want to
51:25 - prevent the from being able to move or
51:28 - do anything except read the text and
51:30 - click on the close
51:34 - button all right uh the last thing we're
51:36 - going to add to that game object is the
51:38 - player uh tag so the way actually I'm
51:42 - not sure it's going to actually be
51:44 - useful for this project but I'm just
51:45 - going to add it for now it's when you
51:47 - want to check for collisions if you give
51:50 - a tag to your game object you can then
51:52 - use the on Collide function to know okay
51:55 - this collided with that a tag and that
51:58 - means to run this type of logic so it's
52:02 - a way to identify your game
52:05 - object all right so if I look at the
52:09 - result nothing yet of course because we
52:11 - haven't put anything now that we have
52:13 - the player Etc let's write the logic for
52:16 - actually displaying the boundaries and
52:18 - then as we write this we're going to
52:21 - write everything else we
52:23 - need okay so so here we need a for Loop
52:28 - which is going to iterate through the
52:30 - various layers we had
52:34 - here and then depending on the layer so
52:38 - if the layer do
52:43 - name equal
52:45 - equal
52:48 - boundaries so if we are on the
52:50 - boundaries layer how do I know this it's
52:53 - by looking at the map. Json export and
52:57 - then here you can have for each layer
53:00 - you have a name key the name key this is
53:02 - how you know which name a layer has if
53:06 - they have
53:07 - any all right so if I go back to
53:10 - main I have the layer name equal equal
53:14 - boundaries and then if I we going to
53:19 - need a for Loop which is going to
53:21 - iterate through all the boundaries of
53:25 - layer do objects remember that when
53:29 - you're dealing with an object layer
53:31 - which is the case for the
53:33 - boundaries they have access to the
53:35 - objects property which is an array
53:37 - containing all the objects in that layer
53:40 - and the objects in that layer are just
53:41 - objects with x y and width and height
53:44 - properties as
53:45 - well and now here we use the map object
53:49 - and then we add another game object to
53:52 - it so we can have child game objects by
53:54 - taking an existing game object and using
53:56 - the add function method on it so what
53:59 - I'm going to do here is I'm just going
54:01 - to copy and paste it it's going to be
54:03 - faster and then I'm going to talk over
54:04 - the
54:07 - code so we have an area component with a
54:11 - specific shaped shapes that corresponds
54:13 - to the width and height of the boundary
54:15 - itself this comes from tiled and from
54:18 - the tiled export in map. Json you see
54:20 - each object has a width and a height uh
54:24 - this uh maybe we created this
54:27 - needlessly because the width is zero and
54:29 - the okay never mind anyway so you have
54:32 - your objects from
54:34 - here and then I specify the spe specific
54:40 - shape we want which is a rectangle and
54:42 - you can do this by calling the wct
54:45 - making a new instance of the W
54:48 - class and then here you have as the
54:53 - first param the the coordinates of that
54:56 - hitbox relative to the game object we're
54:58 - creating we're just going to pass in an
55:00 - empty Vector that means we want the
55:02 - rectangle here to be at the same
55:05 - position as the overall game
55:07 - object so yeah the child game object
55:11 - because it's different then the there's
55:13 - the position of the game object itself
55:15 - and then there's the position of the the
55:19 - hitbox so the area for that game object
55:21 - and here by setting the vector two to
55:24 - being zero that means we have the ex
55:26 - exact same uh game object uh game
55:29 - position sorry and then finally we add
55:32 - the body tag this is important so that
55:34 - we can add the is static property what
55:37 - it does it it basically makes sure that
55:41 - the only way uh that means that the
55:44 - player will not be able to pass over it
55:47 - so it's going to be really stuck and
55:49 - that's uh yeah it's going to be U how do
55:53 - I say the player will not be able to
55:55 - overlap and this is how you do walls in
55:57 - kabon jazz and then finally we pass in
55:59 - the name of the object which was defined
56:02 - in in the tile export this uh gives us
56:07 - the tag it's going to act as the tag of
56:09 - the game object is how we're going to be
56:11 - able to identify what the game object is
56:13 - what the boundary
56:15 - is and this is going to come in handy
56:17 - later on because we're going to be able
56:19 - to know what to do when the player
56:21 - collides with it now that we have
56:23 - this right below
56:27 - if the boundary name of that specific uh
56:33 - boundary that we just created in
56:35 - kabj so this we're just taking the name
56:38 - out of the tile expert because we want
56:39 - to do something different so if uh we
56:42 - want to actually here set the on
56:45 - collision events so if the player we
56:48 - have the on Collide method on the player
56:50 - because we use the area component when
56:53 - creating the
56:55 - player
56:57 - we're going to do
57:00 - boundary. name so the first param of the
57:02 - uncollided method is the tag of the
57:06 - second game object you want to check
57:07 - collisions with we want to check the
57:09 - collisions of the player with this game
57:12 - object with the following tag which is
57:14 - boundary.
57:16 - name and then here we have a function
57:19 - that that is going to run as the second
57:21 - param
57:24 - when yeah so it's going to run when
57:26 - there is a when the Collision
57:28 - occurs and here we're going to set the
57:32 - player property is in dialogue to being
57:35 - false uh true actually so that we're
57:37 - going to later on be able to prevent the
57:40 - player from moving while the text box is
57:43 - being
57:44 - displayed and then here we're going to
57:48 - write a this is actually where we're
57:50 - going to write the
57:52 - dialogue display the dialogue sorry so
57:55 - is dialogue is here it's from here and
57:59 - then now if I go
58:01 - to so let's put it to do here to
58:06 - do and let's go to ut. JS and in there
58:10 - we're going to create a new function
58:13 - that is going to take care of displaying
58:15 - the dialogue so export function display
58:21 - dialogue and then the first par is going
58:23 - to be the text and on display and is
58:27 - going to be a method we're going to
58:30 - pass
58:33 - whoops a function sorry that that is
58:36 - going to run when the text is finished
58:38 - displayed so we need two things we need
58:41 - to get the
58:45 - dialogue UI which is basically the
58:48 - textbox container so I'm going to do
58:50 - document. getet element by ID and then
58:54 - text box text box box
58:58 - container all right once this is
59:01 - done uh let me look if I we have it
59:03 - actually the markup for it we don't so
59:06 - let's go first create the markup for it
59:08 - in h in
59:10 - HTML so
59:12 - here we're going to have first of all
59:16 - inside of the div the UI div we're going
59:18 - to have a P
59:21 - tag that P tag is going to have the
59:23 - class of
59:25 - note we're going to later on create the
59:28 - CSS for it and basically it's just an
59:30 - instruction to tap and click around to
59:36 - move now that we have that I'm going to
59:40 - create a div within and this is going to
59:42 - be our actual dialogue UI so I'm going
59:44 - to give it an ID of
59:48 - textbox
59:50 - container and then the Styles here we're
59:54 - going to actually this is not a really
59:56 - good practice to do if you are in uh
60:00 - making a website but I'm going to use
60:02 - the style tag here for a specific thing
60:04 - for the
60:05 - display setting the display to being
60:08 - none you could have just created an ID
60:11 - here um a selector here but I'm going to
60:15 - because I'm going to change this through
60:18 - JavaScript I'm going to use this but
60:21 - actually I think you could just use a I
60:23 - think class list or something like that
60:25 - to so I create a class and then I remove
60:29 - it but you know for for this project I'm
60:33 - just not going to bother with that okay
60:36 - so now I'm going to create another div
60:39 - from
60:40 - within this div is going to
60:45 - whoops so let me do this uh maybe I
60:48 - should increase the font size a bit more
60:51 - Yep so the div
60:54 - here is going
60:57 - to have the class of
61:01 - button actually text box it's going to
61:04 - actually be the text box
61:07 - itself and from within I'm going to have
61:09 - a P tag that is going to contain the
61:10 - text and I'm going to give it the ID of
61:14 - dialogue and then for the going to have
61:17 - a class for it as well which is going to
61:19 - be UI
61:21 - text and later on I'm going to fill
61:23 - those
61:24 - in right below we're going to have
61:26 - another
61:29 - div and then a
61:34 - button the div is going to have a class
61:36 - of button container this is so we can
61:39 - create a container where the button is
61:41 - always going to be on the right side of
61:42 - the screen I'm going to give an ID to
61:45 - this button to being the close button
61:47 - when the player wants to close the text
61:50 - the text box I'm going to give it the
61:52 - class of UI close button
61:56 - now let's write the dcss for it as
62:00 - well since we're here I'm going to load
62:03 - our
62:04 - font font so in kabj you can load the
62:07 - font if you want to display it via
62:09 - canvas but because we're displaying via
62:12 - HTML the text I'm just going to use the
62:15 - CSS for it so font family monogram
62:18 - that's the name of the font and then the
62:20 - source for the font is URL and then it's
62:24 - monogram.
62:26 - ttf and now it should be able to find it
62:29 - out here in the public
62:32 - folder okay now the body tag let's style
62:36 - the body tag as
62:37 - well this is just going to set the font
62:42 - family for all of the body tag to being
62:45 - to using monogram or as a fallback
62:48 - you're just going to use monospace so
62:50 - mono space is a font that should be
62:52 - already in your
62:53 - browser by default the font size by
62:56 - default is going to be two two REM so
63:00 - two REM one REM is basically the the
63:03 - size of the font uh of your browser said
63:07 - by default in at the root so usually it
63:10 - says 16 pixels and then you can decide
63:13 - you can zoom in and zoom out in your
63:14 - browser control so it takes the so here
63:17 - it takes the the the font size and
63:19 - multiplies by two so two times the font
63:22 - of your
63:23 - browser so that it will adapt
63:26 - it going it's going to be responsive by
63:28 - default and then here I'm going to do
63:32 - overflow hidden so here instead of
63:35 - having overflow hidden here I'm just
63:36 - going to put it in the body so that the
63:38 - scroll bars don't
63:40 - appear and then in however in the app
63:43 - selector all of this is going to have a
63:46 - position of relative this is so we can
63:49 - position it precisely with X left and by
63:53 - specifying the left and the top left
63:56 - and the right and bottom Etc so that we
63:59 - can it's going to how how do I say it
64:03 - it's going to leave the document flow
64:06 - and we're going to have much more Gran
64:07 - granular control of where to put it it's
64:10 - like if you would put an element on the
64:12 - canvas you really control the X and Y
64:14 - position of that uh element you put in
64:17 - the canvas so this is basically a way to
64:19 - achieve the same thing in Kaboom JS uh
64:23 - in CSS
64:24 - sorry now let's
64:27 - add for
64:29 - our wait a minute we have the text box I
64:33 - don't think this is I made a mistake
64:37 - this should be an ID and not a class and
64:40 - now below
64:44 - here we're going to have the class of
64:48 - text box uh the ID sorry of text box the
64:50 - selector for it and here by precise by
64:54 - uh specifying position absolute this is
64:57 - where you actually get the full control
64:59 - of where to put it by using the left
65:02 - property uh I'm going to put 10% the
65:05 - right at 10% as well so it's going to
65:10 - look
65:12 - good I'm going to put the bottom at two
65:15 - view height so it takes the view height
65:18 - and then it's it's a measure a
65:20 - measurement relative to the view height
65:22 - so it it's going to adapt regardless of
65:24 - the um
65:26 - of the the screen of the
65:30 - user the minimum
65:33 - height we're going to need is 10 view
65:36 - height this is what looked good this is
65:38 - for the text box you're going to see an
65:39 - instant when we'll see the result the
65:42 - background so this is the color of the
65:44 - text box let's put it
65:47 - white the okay so we have the background
65:50 - the Border radius I'm just going to put
65:52 - three pixels it doesn't
65:54 - matter
65:57 - the outline style is going to be black
66:01 - or
66:01 - solid is it the color
66:05 - solid the padding is going to be one ram
66:09 - as I explained Ram is based on the font
66:11 - size of your
66:14 - browser and it makes it responsive
66:19 - basically and
66:21 - then what do I need display Flex we're
66:25 - going to create cre a flex container now
66:27 - this is some CSS knowledge I would I
66:29 - assume that you have it you have this
66:31 - knowledge already if you don't read up
66:33 - on Flex containers there are plenty of
66:36 - great articles and posts online
66:38 - explaining
66:40 - everything so we're going to have
66:42 - display flex and then a flex direction
66:45 - of column so so the children of our Flex
66:48 - container are going to be positioned in
66:50 - the column we're going to set the flex
66:53 - wrap to being to wrapping so that when
66:56 - there's no space it moves on to the next
66:59 - row we're going to justify the content
67:02 - to being Flex
67:05 - start this is so that um the text
67:10 - within the uh the text box starts at the
67:14 - top left
67:17 - corner uh align items as well I'm going
67:20 - to do Flex
67:22 - start um I think I'm I always mess up
67:26 - the justify content and align items one
67:31 - if is for the the
67:34 - axis for which the the content is
67:37 - flowing and the other one is for the
67:39 - cross AIS so for both of those case we
67:41 - want it to do start at Flex start which
67:44 - means it's a top left top left
67:48 - and and uh yes so it's top left
67:53 - basically and then play with the those
67:55 - values as you you're going to see how
67:58 - they are
68:00 - affected then word spacing word
68:05 - spacing is going to be 0.2 remm this
68:08 - what looked good so word spacing is
68:11 - self-explanatory so the the words
68:13 - appearing in the text box and then here
68:16 - we're going to have a little drop shadow
68:18 - so we're going to have a
68:20 - filter and then a drop
68:23 - shadow with the following
68:28 - arguments um REM and then a color RGB so
68:33 - this is
68:34 - really took straight from the mdn
68:38 - documentation with just a bit of
68:40 - tweaking in terms of
68:42 - colors yeah I don't really know maybe
68:45 - there's some explanations
68:48 - here yeah you have uh drop shadow
68:53 - here so here it is explained the where
68:57 - are the pams where are
69:00 - they um it does it explain okay okay
69:04 - it's in French by the way anyway you're
69:07 - going to figure it out uh by just
69:10 - looking at the docs mdn docs type in
69:12 - drop shadow CSS you going to
69:16 - understand all
69:18 - right now the UI
69:21 - text class going to have a margin of
69:24 - zero
69:26 - and then user select none this is
69:29 - important so that the player cannot
69:31 - select the text and have highlight it
69:34 - like that usually you don't do that in a
69:39 - game and then
69:41 - finally you have uh actually there's
69:45 - two there's a couple of
69:49 - selector to Define so UI close
69:54 - button I'm just just going to
69:56 - copy what what's left it's not much and
69:59 - I'm going to go over
70:01 - it
70:03 - so UI close button uses this font family
70:08 - uh for some reason you need to specify
70:10 - this otherwise it uses it doesn't use
70:12 - the font and I'm not sure why border
70:15 - style none border radius three pixels
70:17 - some padding and then it it should it
70:21 - should inherit the font size actually
70:23 - maybe you could do inher par it here as
70:26 - well and should
70:27 - work and then button container it's
70:30 - going to align itself at the end of the
70:33 - text box so that the the buttons always
70:36 - going to be appear appear at the top
70:38 - right corner and then the note is going
70:40 - to be again position absolute is going
70:42 - to be at the top left corner so left and
70:44 - then top one VH display Flex Flex
70:47 - Direction column Etc and then this is
70:50 - the color of the text it's going to be
70:52 - have that color yeah I save everything
70:56 - look at the result you can see that here
70:59 - you have tap click around to move here
71:02 - it doesn't matter if you can select or
71:04 - not but for the text box we don't want
71:07 - you to be able to select text actually
71:09 - you know what let's also put it as user
71:14 - select none just to make sure that it
71:17 - looks like a
71:21 - game and that's it uh if I now try to
71:24 - select I can not you see all right now
71:27 - we have this we can simply go back to
71:30 - our .js and write the rest of the logic
71:33 - we had here so we
71:38 - need the following so I'm just going to
71:41 - copy and paste that
71:43 - here so we get the text box container we
71:47 - get the dialogue so the dialogue is
71:49 - actually the P tag here where we
71:52 - actually put the dialogue in and then
71:55 - what what we're going to do is we're
71:57 - going to set the the display so
72:01 - initially remember in our markup I said
72:03 - I put style display none this is to make
72:07 - all of this Invisible by default when we
72:10 - want to show the dialogue we can use the
72:13 - style attribute here and set the display
72:15 - to being block and this is going to make
72:18 - the the textbox container
72:21 - visible so which by extension means that
72:25 - the dialogue box is going to appear and
72:27 - the text is going to be
72:29 - visible now we're going to implement
72:32 - text
72:33 - scrolling and this is very simple in
72:35 - HTML you this is the code for it so I
72:39 - created an index which I set to zero and
72:42 - then the current text is going to
72:44 - contain the text we're going to add to
72:46 - the element the the the inner HTML here
72:50 - of the dialogue box now inner HTML is
72:53 - not really recommended to use because
72:55 - you can be victim of cross site
72:58 - scripting so here in this our particular
73:02 - case it doesn't matter because we're not
73:04 - accepting user input input so it should
73:07 - be safe to not to use in our HTML and
73:11 - it's kind of required because when we
73:14 - want to have our dialogue box you're
73:15 - going to have sometimes the text that
73:17 - appears with links to your GitHub or
73:20 - things like that as attributes Stag and
73:23 - if we were to use inner text for for
73:25 - example then those uh attributes that we
73:28 - pass the the yeah the links are not
73:31 - going to be rendered as links and will
73:33 - not be
73:34 - clickable so here we use the set
73:37 - interval function in JavaScript this is
73:39 - something that is basic like vanilla
73:42 - JavaScript and every 5 Seconds uh it's
73:45 - going to run this the the function here
73:48 - we put a reference to that interval uh
73:51 - that set interval event so that we can
73:53 - cancel it clear the interval when we're
73:56 - done with it and then as long as the
73:58 - index is inferior to the text. length so
74:01 - text. length is the text that we pass
74:03 - here then we take our current text we
74:07 - append the specific character at that
74:10 - specific index of the text and then we
74:12 - put it all in the inner inner
74:17 - HTML and uh yep and then we do index
74:21 - Plus+ and then we skip this until
74:25 - this the condition is no longer true and
74:27 - then we clear and that's basically it
74:30 - now we need to write the logic to
74:33 - um have the onclose button so the when
74:36 - the button needs to be closed to do
74:39 - something like that I'm going to put
74:40 - this outside but still in the display
74:44 - dialogue
74:45 - function if I paste you have we get the
74:49 - close button by using a simple get
74:52 - element by ID and then
74:55 - I create this function called on close
74:57 - button click it's going to call the on
74:59 - display and function this is a useful
75:03 - because we in this function going to set
75:06 - the player uh is in dialogue attribute
75:10 - to being false without having to pass
75:12 - the player to this method this function
75:15 - so this a handy way of using an out
75:18 - passing a function from the outside that
75:20 - does has access to player the player
75:22 - object so that we don't have to add a
75:25 - third param here and it doesn't make
75:27 - sense really why would you need the
75:29 - player to display the dialogue so that
75:32 - makes a much more sense and it's much
75:34 - more extensible for example if you want
75:36 - to do other behaviors when the display
75:39 - is over
75:41 - and and then here the dialogue UI
75:44 - install display we put it back to none
75:45 - so that the dialogue section of the UI
75:48 - is going to be invisible we set the
75:50 - inner HTML back to being empty empty
75:53 - this you could have used inner text it
75:55 - doesn't matter and then we clear the
75:57 - interval if it's not yet the case and
76:00 - then we close we remove the event
76:02 - listener because we're going to add it
76:04 - so we remove the function itself within
76:06 - the function so it's
76:08 - recursive so here we have at the end we
76:13 - create the event listener when the when
76:15 - there is a click and then it runs this
76:18 - and then it removes itself as the event
76:22 - listener so so that's it
76:25 - now if we go back to
76:29 - main.js we can here in the to-do
76:33 - section
76:34 - have player um not player call the
76:39 - display dialogue functions going to
76:41 - import it automatically actually it
76:43 - should automatically import it from the
76:46 - utils file and then
76:49 - here I'm going to pass the dialog data
76:55 - so here for now let's put test or to-do
76:59 - that's our text that we're going to
77:02 - display and then here we're going to
77:06 - have a
77:09 - function and this
77:11 - function actually just its role is just
77:15 - to set the player is in
77:17 - dialogue to being false so that the
77:21 - player can move
77:23 - again
77:25 - and yeah so look at the code
77:29 - here and that's
77:32 - it so if I think I have it I Collapse
77:41 - this and then if however so we should
77:45 - probably put a continue at the end so
77:49 - here after all of this we continue that
77:53 - means we skip to the next situation
77:54 - ation of the for
77:57 - Loop and then
78:00 - here if the
78:02 - layer oops the layer.
78:05 - name is the spawn
78:09 - points well the spawn points layer which
78:12 - is where the the the player
78:15 - spawns we're just going to have
78:20 - four con entity of layer. objects
78:24 - there's just one entity but I'm writing
78:26 - the code to be generalizable so that if
78:29 - you decide to put more than one entity
78:31 - in the tille export it's going to still
78:33 - work and then so if entity.
78:37 - name
78:39 - is equal equal to the player so this is
78:43 - going to be the player so that's this is
78:46 - the
78:47 - name I'm going to put player. position
78:50 - because I added the positional component
78:53 - when created creating the player game
78:56 - object despite having set it up to
78:59 - nothing I can access the attribute
79:02 - position and set it manually after
79:04 - having created the game object and here
79:06 - I'm going to use a vector 2 which is
79:08 - just the x and y coordinate and the
79:10 - position we're going to use though it's
79:12 - going to be very specific it's going to
79:14 - be whoops not what I wanted to
79:19 - yeah so we're going to take the position
79:21 - of the x coordinate of the map you do
79:24 - this by accessing the pause property and
79:26 - then the x coordinate and then I'm going
79:28 - to add the entity dox which it tells us
79:31 - where to place the player and we
79:32 - multiply this by the scale factor
79:34 - because remember we we're basically
79:36 - multiplying everything by four so that
79:38 - everything is nicely visible and big
79:40 - enough same logic for the
79:43 - y-coordinate and then finally here we
79:45 - use the add function in Kaboom to add
79:48 - the player game object we created in the
79:51 - scene and then here you can continue or
79:54 - doesn't matter because we only have like
79:57 - two layers or anyway so now that we have
80:00 - all of this it's time to I'm going just
80:04 - going to collapse all this section we're
80:05 - done with
80:08 - it and then here I'm going to um I think
80:12 - that's uh let right just some code to
80:16 - make the camera follow the player so by
80:18 - default in cabun you have the camera
80:20 - object already created you can call the
80:23 - gam cam pause so the camer system
80:26 - already exists you can just control it
80:27 - so I'm going to take the player world
80:30 - position the reason we using World
80:33 - position
80:34 - instead um actually doesn't matter
80:38 - really because we haven't created the
80:40 - player as a child object so so if you're
80:43 - using if you're creating a game object
80:45 - as part of a child of another game
80:48 - object you use World position to convert
80:51 - the its position to being the position
80:53 - of the in the actual canvas and not
80:55 - relative to the
80:57 - parent so here I'm going to use player.
81:01 - pause.
81:03 - x and then player. doy plus an offset of
81:08 - 100 so this campuse is going to set the
81:11 - camera position to being this in the x
81:13 - coordinate and this in the
81:15 - y-coordinate now if I look at the
81:18 - result okay I have the character but uh
81:22 - the map is not appearing I'm wondering
81:26 - why actually why is the map not
81:28 - appearing is it doing everything
81:32 - right
81:34 - um wait a minute so if I go back to the
81:38 - top where we created the map we have
81:41 - okay I haven't added it to the to the
81:44 - canvas but you know what because we're
81:46 - doesn't matter let's use add instead to
81:49 - immediately add it to the the
81:52 - canvas and here we go
81:55 - the map is displayed if I press F1 you
81:57 - can see all the the collisions and for
81:59 - the specific objects you're going to
82:01 - have TV sofa table PC resume project
82:07 - exit
82:08 - Etc now the player cannot move so let's
82:12 - fix
82:14 - that and then uh also we're going to
82:16 - need to add some other stuff like uh
82:18 - setting the camera scale so depending on
82:21 - if the player is using a small screen or
82:23 - a big screen we want to make the the
82:26 - camera zoom a bit or not to
82:32 - compensate so here um so let's actually
82:36 - write the logic for moving the player so
82:40 - I'm going to use the k. on Mouse down so
82:43 - because this is a very simple project
82:46 - compared to other tutorials I made I'm
82:49 - not going to write those methods inside
82:52 - of the player let's just use the on and
82:54 - take the the player game
82:57 - object directly here and yep so when on
83:03 - Mouse down is an event in Kaboom JS
83:07 - it takes in a function and it will pass
83:09 - to it the mouse button that is currently
83:13 - being pressed on mobile it's just going
83:15 - to consider a tap basically and then
83:18 - here if the mouse button is not equal to
83:24 - the left M Mouse click or the player is
83:29 - in dialogue then we return early that
83:33 - means we do nothing we don't
83:36 - move and this makes sense because we
83:38 - don't want to allow the player to move
83:41 - when a right click is pressed instead of
83:43 - the a left click because if they press
83:45 - both at the same time they're going to
83:46 - move twice as fast it doesn't really
83:49 - matter because it's not a game we're
83:50 - building really but just so you know and
83:54 - here if the player is in dialogue of
83:56 - course we don't want to allow the player
83:58 - move to move while they are in dialogue
84:00 - we want them to focus on the
84:02 - dialogue
84:05 - okay now for movement we're going to
84:09 - need the following snippet of
84:12 - code so let me just
84:21 - okay so that's all there is to it when
84:23 - it comes to mov
84:24 - we need the world Mouse position that
84:27 - means because we're using the camera the
84:30 - mouse position is going to be really um
84:34 - according to the canvas and not
84:36 - according to the world the world can be
84:38 - much bigger than the canvas because the
84:41 - world is much more than what is visible
84:44 - by the camera and when you drag around
84:48 - this uh what happens is that if you use
84:50 - the k. Mouse pause the mouse position
84:53 - directly
84:54 - you're going to at some point get stuck
84:56 - I wrote a Blog Post article on my
84:59 - substack link is in the description so
85:02 - feel free to read read it to get a
85:04 - better understanding and by the way
85:06 - subscribe to my sub if you want uh for
85:10 - more like written content yep so the
85:14 - only thing we need now to move the
85:15 - player is to use the move to function
85:18 - that is available on the player because
85:20 - we have the I think the area component
85:22 - the body component I think because
85:24 - because of the body component so some
85:26 - certain methods in Kaboom JS are only
85:27 - accessible once you have added certain
85:30 - components when creating that game
85:32 - object so the first param is which what
85:35 - is the target position you want and we
85:37 - want the world Mouse position so we want
85:39 - the player to move towards this at the
85:42 - specific speed and here we just get the
85:44 - speed from the player which we defined
85:47 - here all right now if I look at the
85:50 - result we should be able to
85:52 - move and here we go and then you can see
85:55 - we Collide and then Todo there's nothing
85:57 - that appears and then Todo again Todo we
86:03 - haven't written the content but that's
86:05 - almost all there is to it you know the
86:07 - next step is really to code the
86:11 - direction various directions so make the
86:15 - player face different direction scaling
86:17 - the camera according to the the device
86:20 - being used the the resolution otherwise
86:22 - sometimes it's too big and becomes too
86:26 - big and actually putting the content
86:29 - inside of those text box and that should
86:32 - be it so now let's actually write the
86:35 - logic for scaling the camera and then
86:38 - we'll write the logic for the directions
86:41 - and then we'll add a text hopefully that
86:43 - order so here for the camera scaling I'm
86:47 - just going to in the .js we're going to
86:50 - create another function right below
86:54 - export
86:56 - function set cam scale and then here we
87:00 - just pass the context so we can know we
87:03 - can compute how much we need to scale so
87:06 - here I'm going to create a constant I'm
87:09 - going to call it resize
87:11 - factor and it's going to have access to
87:14 - the width of the canvas you can have
87:16 - access to the width of the canvas by
87:17 - calling the width method on the Kaboom
87:21 - context and the height um
87:24 - as well and then we have this division
87:27 - to get a factor and then if the resize
87:30 - factor is inferior to one that means we
87:35 - will simply set the cam
87:38 - scale cam scale this is a kaboom method
87:42 - to being just one uh you can also do two
87:45 - VC one which is just going to set it to
87:48 - one uh otherwise an lse statement you
87:52 - could either have an lse statement or if
87:54 - if you want to be fancy you can and more
87:56 - clear you can have an early
88:00 - return and then here right below you can
88:03 - have k. cam SC
88:05 - scale cam scale and then k. Vector 2 and
88:11 - we increase the scaling so we Zoom by
88:13 - 1.5 in both X and Y uh Transformations
88:17 - so 1.5 all right so now we have this I'm
88:22 - going to go back to main and and where
88:24 - we're going to call it is we're going to
88:26 - call this function first in in two
88:29 - occasions the first one at the beginning
88:32 - we just do set cam scale and then
88:36 - K and also every time we resize the
88:40 - cvas so you can know when this happens
88:44 - by using the on resize Kaboom uh
88:48 - method which takes in a function that
88:51 - that is going to run when this occurs
88:54 - and then you just can call the set cam
88:57 - scale and then pass in the context
89:01 - here so let's look at the
89:04 - result so here you can see everything is
89:07 - much better and then as you decrease the
89:13 - thing it's uh smaller I think or is it
89:17 - that's uh let's take an iPhone SE and
89:21 - then let's uh yeah it seems to
89:26 - relatively work maybe I'm not sure let's
89:32 - gradually yeah all right yeah so it's it
89:34 - does yeah it does change okay sounds
89:39 - good now what we need is to basically
89:44 - display the correct animations and
89:45 - Sprite depending on the direction so
89:48 - what I'm going to do to be able to know
89:50 - when the player should be facing left or
89:52 - right or any of those uh angles is to
89:57 - first store the mouse
89:59 - angle which is just going to be the
90:03 - angle between the player so you can do
90:06 - that by using the angle method of the
90:09 - position of the vector of the position
90:13 - of the player so player. pause. angle
90:15 - gives you this and then you can pass in
90:18 - the world Mouse position and it's going
90:21 - to be give you the angle between and
90:23 - with that
90:24 - I'm going to first specify a lower
90:27 - bound which is going to be
90:30 - 50 and a um upper
90:34 - bound which is going to
90:37 - be um 125 going to see in an instant why
90:42 - we need this and then we have our if
90:44 - statement so here I'm just going to copy
90:47 - and paste and talk over it so first
90:49 - condition if the mouse angle is superior
90:52 - to the lower bound and inferior to the
90:55 - upper bound and the current animation
90:57 - isn't walk up then we will play the walk
91:01 - up animation and set the player
91:02 - direction to be up if I look at the
91:05 - result it's when the mouse is here
91:07 - imagine that you had a circle and then
91:11 - here if your mouse is within a certain
91:15 - range actually for now you're not going
91:17 - to see the difference so let's say my
91:19 - mouse the angle here and here so you're
91:21 - on the circle as long as my my mouse is
91:24 - still within those position the up
91:27 - animation is still going going to play
91:30 - however if my mouse exceeds for example
91:33 - here we shouldn't now this is not very
91:35 - clear for now but let's add the
91:37 - conditions and then you'll
91:40 - see so now what comes next is the for
91:43 - the down animation so it's it's the same
91:48 - thing with negatives instead so now if I
91:51 - run and look at the result if my mouse
91:55 - is here and I click Mouse down the up
91:57 - animation is going to play if I my mouse
92:00 - is here the down animation is going to
92:02 - play now if I do
92:04 - whoops okay let's whoops okay let's say
92:08 - I'm I'm here so if I do this and then I
92:11 - change you see it dynamically change as
92:14 - long as I hold the mouse because now the
92:17 - the mouse position is within those upper
92:19 - and lower bounds of the this imaginary
92:22 - circle in terms of angle
92:25 - so
92:26 - now I'm just going to add the two other
92:31 - conditions this is for the left and
92:34 - right then
92:36 - here right
92:38 - below so for the
92:40 - right it's we take the absolute value of
92:44 - the mouse angle and as long as it's
92:46 - superior to the upper bound we flip the
92:50 - player X to being
92:52 - false this the flip X X is useful
92:55 - because we only have one animation for
92:57 - the walking it's called walk side and by
92:59 - default it faces to the right that means
93:02 - that if the player was flipped uh mainly
93:05 - because of the other animations where we
93:06 - do flip so for the left side then we put
93:09 - it back to false so that the the player
93:11 - looks at the correct direction and then
93:13 - here the same thing but with flip X
93:16 - being true instead and uh as long as the
93:21 - mouse angle is inferior to the lower B
93:23 - down the absolute value so we don't care
93:26 - about whether or not it's negative or
93:28 - positive Etc so this is so it works on
93:30 - both sides of the circle the imaginary
93:33 - Circle so now if I look at the result
93:36 - you
93:37 - see and you can have directional
93:41 - movement like that now you see that the
93:44 - animations of the the player never stops
93:46 - right uh the way to go about that is to
93:49 - use the uh on Mouse release method in
93:54 - Kaboom JZ I'm going to paste it right
93:57 - below so here let's a let me collapse
94:00 - everything
94:01 - here and yeah on Mouse release if the
94:05 - direction is down we put idle down if
94:08 - the direction is up we put idled up and
94:11 - if uh it's neither then we put the idle
94:14 - side and because we flipped we fli the
94:17 - player uh it's going to point towards
94:20 - the correct direction by default we
94:22 - don't need to do anything so if I look
94:24 - here I do
94:27 - this here you go
94:31 - then like that and then I hold I release
94:35 - sorry I release the mouse and then the
94:38 - player
94:39 - stops and uh basic that's basically it
94:42 - now the only thing is really the content
94:44 - here and what we're going to do here for
94:48 - that is I'm going to go back to where we
94:51 - I think it was here when instead of
94:54 - having to do we're going to hold the
94:56 - content of our dialogue inside of an a
95:01 - constant I'm going to just call a dialog
95:04 - data uh let me just look it up so I'm
95:06 - going to copy and paste it and just
95:07 - explain to you the the how how it works
95:12 - and then you don't have to use the same
95:13 - text so here you have a dialogue data
95:17 - object with keys that corresponds to the
95:20 - tag of the boundary so for the PC you
95:23 - have this text and then you can see me
95:25 - using the a tag here to have links Etc
95:30 - as if it were
95:31 - HTML and now here in main.js instead of
95:34 - doing this what you do is just you you
95:38 - get the dialog data constant from the
95:41 - constant file so it should import it
95:43 - automatically otherwise do it manually
95:46 - here here it is and then here you just
95:49 - pass in the boundary name to corre uh
95:52 - select the correct text to
95:55 - display and that's basically it the
95:57 - project is done if I go here and I go
96:01 - here if you want to exit J Legends
96:02 - portfolio just close the the tab and
96:05 - then here that's my TV I've been
96:07 - watching Tech YouTubers a lot recently
96:09 - the primagen Theo pirate software milky
96:13 - Etc and then here that's my sofa I like
96:16 - to relax and Etc and then you get the
96:19 - point so if I open up the um
96:24 - the uh debug mode you can see when there
96:27 - is the PC key here those are the name of
96:30 - the various boundaries and this is how
96:31 - we we use them them to as keys for our
96:34 - dialogue data so here for example this
96:38 - is my Dex my desk on it is my resume
96:40 - check it out and then it's a link with
96:42 - an a tag so here if I go here the a tag
96:46 - where is it uh constant you can see uh
96:49 - the link to my resume Etc so this is
96:53 - your free don't don't just copy what I
96:56 - wrote here write your own
96:58 - dialogues to tailor it to your uh your
97:02 - yourself basically and that's basically
97:05 - it thanks for watching this tutorial
97:07 - hope it was uh something that you you
97:10 - like to to learn about and uh yeah
97:13 - thanks for watching feel free to
97:14 - subscribe for more content related to
97:16 - game development uh specifically
97:18 - JavaScript or web related game
97:21 - development but hopefully not only maybe
97:23 - I'll try try to do other types of uh
97:25 - development uh or with other Stacks so
97:30 - maybe making games with Lua or some
97:32 - stuff like that in the future so yeah
97:34 - feel free to subscribe and share this
97:36 - video if you found found it useful all
97:38 - right thanks for watching bye

Cleaned transcript:

instead of a boring portfolio why not make a game in this tutorial JS Legend Dev will show you how to use JavaScript and Kaboom JS to create an interactive developer portfolio hi everyone welcome to this new video today we will be building a 2d portfolio project so it's a 2d developer portfolio but as a 2d game and without waiting much further let's jump right into it so this is what we're going to build you can move around a house and then as you approach objects you can have a text box that tells you a bit more about uh yourself here I've selected some text for example here there's my CS degree this is my CS degree I hanged it on the wall because I'm proud of it and then if you move around you go here you have a place to have your resume can click if you click on that it will open a link with your resume hosted here for example this is just a template so this is how this is this is the idea behind a project here you have a bit of text so it's an original way of making a software developer portfolio uh I've seen a couple where it was in 3D but nobody seems to have made uh in 2D actually there there were some so I thought I would just teach you how to do it what's interesting here is that we're going to build this project with JavaScript and the Kaboom J Library so Kaboom JS is a library for making games in JavaScript it's very easy and intuitive but also for all that is the text here the text box the the text here as well this is all HTML and CSS uh here because the reason is that for this project everything should be uh interactable with the mouse or the touchcreen so if I open the dev tools and go to the mobile view and then here you should be able to move around and the text therefore should be responsive so here example you have a text and that's it you can close so for this to be achievable for the game to work on all aspect ratios it was important for me to make the UI portion of this project in HTML and CSS so let's jump right into project but before we do that I just want to mention a few things so if if you're interested in having written tutorials you can go to my substack the link will be in the description below where you can have written content that explains uh specific Concepts so on YouTube I make ful length project tutorials and sometimes you just want to know how to do one specific thing so the substack here my newsletter is for that so here for example for this project it's going to be relevant to know how to implement 2D uh topown controls uh for a mobile web game so here we go you have videos here that just showcase the results another thing I want to mention is just to uh showcase my uh buy me a coffee page so if you want to support the channel you can uh buy the the uh support with $5 a month and with this tier and you get access to this tutorial you're currently watching and all the future tutorials in advance so Early Access you you also get early access to the um do the source code and some progress updates as I do them so if you're interested in supporting the channel so I can focus more on making tutorials feel free to contribute here you can also just leave a a normal tip if you want all right so let's jump right into the project so I'm going to use for this project vs code uh it's the editor I use mostly for everything and here we're going to need a few things so let's start our project so I assume that you know how to use vs code at the basic level so you have it installed on your computer you also have it um you have no JS installed also which is going to be important for this tutorial because we're going to use vit vit is a bundler that allows you to um write your JavaScript in a more convenient way so we could use script tags as we did in a lot of the previous tutorials but with v you get uh uh you can install your dependencies by typing in npm install and it's it's just more convenient in a certain sense and you will also get Auto completion and U Snippets code Snippets from Kaboom from the Kaboom J library that tells you this is a this feature what it does which is something you don't get if you just use a script tag but feel free to follow using only a script tag if you want uh previous the setup sections of previous tutorials are going to teach you how uh so yeah I'm just going in this specific tutorial I'm not going to spend a lot of time on this so the first thing we're going to do do is to type npm create V at latest and then dot because we want to create the project within the same folder we're currently here in so here it's 2D portfolio so I hit enter and then we should have something appear need to install the following package yep and then here it's going to ask you to select the framework we're going to go with vanilla vanilla JavaScript and it's going to add a bunch of stuff so for now just do npm install Kaboom so it's going to install the Kaboom Jaz Library oops I I hit the wrong thing but hit enter is it going to work okay all right so it's going to install the project and then in your package.json you can see are your dependencies so here we have a kaboom all right now the rest of the project um we're going to need to set a few things up so the first thing we're going to set up is I'm going to remove a lot of the boiler plate you see here I'm going to remove main Jess I'm going to remove counter J I'm also going to remove this and with then v s G I think it's not needed as well so this this this remove and of and also the style at CSS we're not going to need need it for this project so delete okay now once we have this let's create a few folders we going to need the source folder SRC this is where we're going to write our code um our JavaScript code we also going to need the public folder I did deleted it by accident I wanted to just delete it was what was in the public folder and we're going to create at the root of the project a v config.js file this is going to be useful for a specific reason we want to be able to export so the way a bundler works it it compiles your JavaScript so the nodejs JavaScript that you write and the JavaScript that runs in the the browser is not necessarily this exact same thing so this bundler basically transpile or compiles your JavaScript to a JavaScript version or um it's a bit hard to explain to a version of JavaScript not not a version to JavaScript that can run in the browser as it is so y now the reason for this is that um a lot of features were not supported in the past in the browser version of JavaScript while in nodejs you could have things like convenient things like using import statements but now import statements are actually available in JavaScript in the browser so that's how I've been doing the various projects you've seen on the channel if you're familiar in the past in the past tutorials so in the V.C config.js we need to specify uh certain things so not uh just want to clarify again that not only does a bond lert transpile your code your JavaScript code so it can run in the browser it also do optimizations minification so that your your code is really Compact and takes the least amount of space all right so here I'm going to do export default and then Define config this is coming from vit so it's going to import it from vit here and then within we're going to have to specify the base so the base here when we run the npm Run build command which is used to do the transpiling and gives us the actual code gives us the actual code that is going to be used um that you actually put on your server or on h. to have your we website up we need this base thing otherwise it's not going to be able to find the assets for examp example the Sprites with used we use with Kaboom Jazz the second thing we need to specify is the build and here the minification we're going to use something called turer instead of the default es build so the reason for this is due to caboom there is a bug with the way Kaboom is made that if you just use the default it's going to give you code that doesn't work the the the actual output will not no longer work so that's why we need to install this alternative called turer which is going to make our code turer so smaller minified so once this is I should have installed it as a dependency so npm dd for dependency install um turer I think that's the command or if it's not that it's going to be the reverse all right now if I look at the package.json you can see that I A Dev dependency we have added turer okay we have everything we need so now I'm going to create a main.js file and in the index.html we're going to have to do a couple of things so I'm just going to remove that so the first thing we need is to create a style tag within the body this is where we're going to write our CSS now you could have decided to use an external uh CSS file but but because this project is not really CSS heavy it isn't really that necessary the second thing we need to uh modify is here the script tag that Imports the main.js file we need to actually modify the path to be Source like that because we we have created this Source folder in which is our main.js file okay now in the div we actually can work this out later but be um actually never mind here we're going to create our canvas that we're going to give the control of it to Kaboom so I'm going to call it game the ID is going to be game and here we're going to have a div that is going to have the ID of UI I'm not sure if I'm going to use this later on I might just remove this ID which just is going to contain everything that is the UI so the text box and text all right now that we have this in our source folder I'm going to create a file this file is going to be called Kaboom context. JS so CTX to abbreviate it and this is where we're going to set up Kaboom so I'm going to use import Kaboom from Kaboom this is possible because we have installed Kaboom JS and you can see that there is a difference in the way native JavaScript that works in the browser deals with Imports and how this nodejs version of JavaScript works so if we were to use the native JavaScript in the browser with modules you have to add the JS for the file extension you want to import but this is not needed when you're using a tool like vit okay so here I'm going to create our canvas um or Kaboom context which is going to be unique and through that object this K we're going to call all the functions we need so we're going to pass this around in our project I think this allows us to have cleaner code as we as the project grows instead of having to instead of importing Kaboom globally where every all functions can be called directly from anywhere so this is a pattern I recommend that you use for your Kaboom Jazz prod projects so in when you create a the Kaboom context you need to pass a few params actually don't need to pass any params by default but if we want to achieve the thing I I said about not making it Global you have to pass in the global property and set it to false then here this is going to be relevant for the fact that we want our project to work on moob mobile as well so we want to have the touch to Mouse property which again is from kaboom and set it to true it's going to translate all touch events uh on the phone to click events so that you can basically write your code with the mouse in mind but it's going to work just just as well with mobile and then finally we can have the canvas property where we're just going to give to Kaboom the canvas element and the way we're going to do that is by using document get element by ID and here we give it the game ID if you remember in index.html we gave to this canvas the ID of game so we're just telling Kaboom here take the the element take control of it and do whatever you want whatever you need okay so now that we have this everything is fine and in main.js we can start writing our code but you know before doing any of that let's create all the other files we're going to need so constant. JS it's going to contain as the name suggests constants which is also going to con take contain the specific dialogues and the scaling constants Etc and then finally we need the utils file which is going to contain a few functions that just to make our code look nicer so in this this project it should not take too much too long compared to my previous projects so yeah you don't if you could have made everything in just M.S if you want it all right so now in the public folder is actually where we're going to store our assets what I need you to store is the font monogram. ttf you're going to find this in the link in the description of this video if you're an early member of the yeah if you if you're watching this in Early Access you should have also a link I'm either going to drop it in the post or in the actual video so you should uh it should be obvious where to get it and now we're also going to need the Sprite sheet that we're going to use for this project this is the the Sprite sheet uh the link is in the description as uh as with the text and then uh finally we're going to use an external program called tiled to draw our Maps but for now let's just keep keep those two things and then in main.js let's actually start writing our code so I'm going to import K uh the the the context from Kaboom and here the first thing we're going to do is use the load Sprite function it's a function that allows us to load a an image as a Sprite and then we can specify a bunch of frames so here I'm giving it the name of sprite sheet and the second param should be the path where to find it and it's going to be Sprite sheet.png now the reason this is just SL spray.png PNG despite the fact that it's in the public folder so normally you would think that it would be do slash and then public SL spreadsheet the way V works is that you can assume that everything that is in the public folder can be directly accessed uh like that so this is something specific to V now the third Pam is going to contain a bunch of properties that tells Kaboom how to slice the image into various frames the first two properties is is the slice X so how many frames are on the xaxis here 39 how did I come up with this number I just counted I just counted the number of frames the the the number of frames here you could do that with tiled as well uh to give you the the number um and then this is something you should know so for example each of those is in is a a each frame in this image is a 16 by 16 tile and that means you can know roughly like if you take the the length of the image which is here 624 and then you divide it by 16 you're going to get the number of tiles of frames that are going to be on the xaxis so you can manually calculate it with math all right slice Y is going to again describe the number of frames there are in the Y AIS the same logic can be used to calculate it so knowing that every frame is 16 by 16 this is the way this Sprite sheet is designed you can just take uh look at the height of the image the properties or or here in vs code on the bottom right corner and you divide that number by 16 and you get the number of frames all right now here comes an interesting part it's called the anims property and here it's where you define you hook up specific names to specific animations so here the idle down animation for our character it's just going to be one frame and it's going to be frame number 536 now how did I discover this it's by using a program called til this program is called tiled and I think it's actually a good time to um create our Maps basically create our map and while setting things up we going to see how I figured out but just to be quick you click here on the frame you want and then you get the ID so the number of that frame now let's assume you don't have any knowledge of til so install til by using the link in the description once you have it you should have this editor let's assume you have a new project so I'm just going to create a new map and then let's um I don't remember the dimensions I I've used but don't touch anything here except specify the width as 16 pixel the height the height as 16 pixel as well as for the map size make it fixed and then take these numbers by default all right we have the the map here now another thing you can do because if you're using til on a wide monitor for example things might not be clear so you go to edit preferences and then in interface uh actually it's in theme you you you check use custom interface font and then you can select a specific font and then increase the font size this is useful for for you to be able to clearly read things once you have this in the map you can go to I think it was map properties actually maybe not World um okay in view snapping no snapping for this project uh if you clicked on snapping snap to Grid it's going to make sure that everything fits into a grid uh pattern uh I think for tiles it's in Grid uh pattern regardless but if for the collisions box we're going to draw we want to find more fine grain controls so that's why I dis activated it for this project okay now add a new tile set to the right okay now browse where you've put the the Sprite sheet in your project and Link it here so this is it so for the the path should be here and then this is specific to me so for you if depends on where you put it the actual project and then just don't touch anything the tile width and tile height should be 16 by 16 pixels and then hit okay and now you have the the spreadsheet so a good thing right now is would be to save the map so go to the the file save as and then name it map. Json and put it in the public folder of your project all right so you can see that I've named it map. Json this is the name I want you to to use and it's going to basically create a Json file in your public folder so if I minimize this and go here you can see that we have map. Json this is important because this is how we're going to know where to draw the hitboxes and where to draw certain things so if I go back to tiled for now we only care about knowing how I figured out the 936 so here it is 936 comes from the end as you click on the various other tiles you can see the various numbers that this is how you can know which frame is which okay now I'm not going to copy paste H I'm not going to write the code for this all the animations we're going to use by hand it's going to take too much time so I'm just going to copy and paste it here so here we have the idle down animation which is just one frame with the walk down the walk down animations so how do you specify animations with more than one frame in Kaboom JZ you use this uh an object you pass in an object with the from property which is the starting frame the two property which is the finishing frame and whatever or not you want to Loop this is not mandatory because by default looping is false but we want the animation to Loop always and we decide when to stop it and when you cancel it and then the speed is the frame rate so here eight frames per second for this so we have four frames in this animation so a speed of eight is what looked good so if I go back to title again you can see one two 3 and four this is how you know this is how I knew it was for animations uh for frames sorry and then here it's the same thing but with the various uh different directions so here for the side sideways we only need to have one of them I think we're using the the right one by default yep and we we're just going to flip it over when we need to make the character look left all right so now that that this is done I think we can just start uh drawing the map so I'm going to open tile again now here I really want to have the same thing but um yeah this is always a diff difficult part of the project where I just want to copy um the map layout instead of doing it manually but just to teach you so what what I'm going to do is I'm going to teach you how to make a water down like very simple version of this map and then you just take my map. Json file here and you use it uh so the the map Json file that I used in the project in the actual project is going to be in the description and this is just a u tutorial version that you can just swap out so this is this is just to teach you how to use til so once this is done I'm just going to use the actual real map. Json instead of writing the code as if anyway all right you get the point so just to teach you uh the way you draw things so let's have okay the way layers works so I'm just going to this is just a small crash course on titled how to draw maps and yeah so by default you have things called tile layers so tile layers are layers that contain tiles that you can draw there's another type of layer called the object layer which contains Collision boxes or spawn points which is basically needed to to know where to set where the collisions are Etc so let's let's say we have this first layer called Ground so you decide on the name and depending on the name the the result in Json file that you save is going to contain those those names so you can know which layer is which so here let's say I draw the ground like that so I drew a couple of tiles everything looks great now if you want you click on this button to add a new layer let's say I add another layer and I'm I'm just going to call it plants or uh props and then I can draw on top of it like that and that's basically it that's how you draw a map in kabo uh not kabo in tile now when you want to to add collisions what you do is you create an object layer call it for example boundaries and then here at the top you can have access to those shapes and then here for example a square let's say I want the player not to be able to escape outside the um the this little square so I can do here and then draw a grid like that here it's often better to have the snapping set to snap the grid if I do that it's going to be very easy to make perfect Pixel Perfect uh collisions uh yeah boundaries but now if I go back to here snapping and no snapping and I want to draw for example for this tree this specific shape and then this specific shape so you have more fine grain control and now this doesn't do anything on its own it's it's just for you to know that hey there's this layer called Boundaries and it's going to be an object layer and this is what and when you're using an object layer each object you create in that layer is going to have the XY coordinates and the width and its height so you can know what to draw what to where to draw the hit boxes when you're working in Kaboom or in JavaScript you don't you don't have to use Kaboom to use tile by the way now the other thing I want to uh talk about and it doesn't have to be a separate layer but let's say we create a separate layer and I'm going to call it spawn point uh not not spawn point what is this name anyway spawn point and then here you can use this pin and when you place it it's going to basically create a coordinate that you can use as a way to know where to spawn the player for example or NPCs or mobs Etc so this is how til works so once you you're ready with this you just save it now another thing I want to uh showcase is that this is not enough uh what we want so this is something specific to Kaboom so usually by default it's better to draw normally in a in JavaScript or in any like programming language it's better like it should be more efficient to draw the frames tile by tile instead of like having a an image that contains all the tiles but in Kaboom chz it's different in the sense that it is more performant and easier to maintain if you just go to your child editor and do export as an image so what this is going to do it's going to combine all of your tiles here as a single image so if I and only include visible layers so before doing any anything like that you need to make the spawn point and the object and the B boundaries layer invisible otherwise it's going to appear in your project and then you save and then you go to file export as image and then you export only include the the visible layer you don't touch any of that thing uh those things and then export now here if I go in my code edor you're going to notice you're going to understand so map you see all the image is baked as a single one so so here we go now this would be inefficient or less efficient in other um other libraries Etc but with Kaboom because it when you create new tiles you create new game objects it can be uh because game objects in kabon Jaz you create things called game objects which are are your usually your player your tiles anything and when you do that it is performant intensive because every game object has a few components those components do speci do some Stuff Etc so a way to get around that not have to do this or pay the the performance tax that comes with it there are many ways you can adopt the simplest one is just to bake your image uh to take your tiles and just combine them into a single PNG and just draw that as is now the tiled export is still useful because in tiled you're going to have this map. Json and then for layers that aren't tiles you get the object layer and the position of the hit boxes which is still valuable information you're going to need to draw the the headit boxes in your map otherwise the other option would be to use the on draw function in Kaboom JS to draw the tile specifically without having to create a new game object and but it's just more complicated for for it it's a better alternative but it's just more complicated and for this project I just opted with just taking a single image using a single image yeah okay I think I've teach uh I've taught you any uh everything important related to how to draw things in kab in tiled and Etc now what we're going to do is I'm going to swap the files here I have the map. Json map.png with the actual Maps so you can see actually one thing I realize now is never mind we you still need the Sprite sheet.png because it contains our character and the characters are character sprites are directly pulled uh from that image from Kaboom uh from that image are pulled the Sprite character so Kaboom still needs that but for the map for the all the other ties so you could theoretically remove everything else and just keep that and it would have been more efficient considering that when you're making a web game going you have to see how much uh data you're you're you're sending but those image are already very small anyway because it's pixel art okay so I'm going to swap my images uh my map and my Json file with the one I originally used and now if I go and look at the map. PNG you can see like the exact same map and if you look at the map. Json you can see the various tiles so let's take some time to explore how uh tiled what the map. Json what the tile export is contains so the things that are the thing that is very important is the layers property so til exports with a bunch of properties Mo most of which are useless uh for our purposes but the one that is useful is the layers property so if the layer is a tile layer it's going to contain the data property and it's an array containing the frame number that needs to be displayed zero is the absence of a frame for object layers though it's different they don't have the the data uh property what they have instead is the objects property which is an array containing every object that you've draw that you've drawn in this layer so the most important stuff is the X and Y coordinates and the width and the height of that object so this is useful for the boundaries all right so we have our map. Json everything is fine now let's load our um oh just one thing I want to to mention as well if you want to add to a boundary so this is often something you want to do you click here to uh to select an existing uh object when you are on the object layer this this little icon ignore this message for now and then you can modify the width and height Etc but you can also here in the properties tab add a name let's say I want this boundary to be to have a specific name let's say wall and when the player hits this H hits this we're going to know that hey it was a wall so you can use the name the data you pass here in Kaboom Jaz to know what the player is colliding with so now I'm just going to close this it's no longer necessary I'm just going to discard it and go back to my original so so here is a bunch of uh objects that I've named uh specifically like CS degree PC sofa table player TV exit Etc and for each of those we're going to have a different dialogue appear okay so let's go back to main and in main we're going to what going to do next is to import the actual map Sprite Which is a single PNG image now that we have baked it into a PNG instead of drawing every tile separately and then for the background the way you can set the background in cabun is using the set background function if you use this though you need to pass in a color and the way you can pass colors either via RGB or you can use the color class and the from heex method to specify a hexa decimal value the heximal value going to use for this project is 300 11 047 and now if I run the project so let's run it going to open up the terminal type in npm run Dev and then once you do that you can have click on Local Host and you should have your canvas so here we haven't done anything yet and things aren't looking great so we're going to have to change the the width uh of the div containing the canvas so that it takes the full screen so you know what let's do this um before actually writing the code Etc so let's go back to our index.html and in style tag going to add a couple of style styles so for the um for the app div so here take the ID and then we're going to specify a font a width of 100% so it takes the full width of the page a height of 100% as well 10% 100 %. and then overflow hidden so that scroll bars do not appear ever we don't want scroll bar to appear in this project how you look at the result you can see that the canvas takes the whole Space okay now let's go back to main.js and then create our first scene which is going to contain or all of a code for that specific scene I just want to make sure that um for this project because we don't have multiple different scenes it isn't needed to create a scene but I just want to show you how it's done in Kaboom JZ so to create a scene so to create a scene you use the k. scene function you give it a name I'm going to call it Main and then what comes after is a function which is going to be the code that is going to run for that scene so here is where you you draw um you write your logic for that scene but before do doing any of that you need to specify using the K.O function what is the default scene so by default the game starts it goes to to the entrypoint main.js it loads the various assets set the background color defines the scene and then go to that main scene now here this function we passed here is going to we're going to need to have it as an async function the reason for that is because we're going to need to get the map. Json data and for that we're going to use a fetch call so const map data is going to be a constant I'm going to name to basically get the the map. Json data we need in our JavaScript project so here I'm going to use await await fetch which is a default web browser API I'm going to to explain everything in an instant and then here. Json so here in one line first we await the fetch function because it is asynchronous that means that uh if you were to not use await then your code the rest of the code would continue to execute so let's say I have some logic here it would continue to run uh while fetch is still ongoing we don't want that we want to load the map data and not move not move the rest of the code here un until it's done that's why we await it so basically waiting it and then once we do that we also need to convert it into a Json uh object and for that we need to use the Json function which is also as synchronous Json method which is also asynchronous that's why we need also to await so that we don't move uh to the next line of code before it's done so once map data is done and ready we move on to the next things so here I'm just going to create another constant called layers and I'm going to extract from map data the layers property so if we look at the map. Json file you can see that the properties that one of them was layers and this is really what we care about that's why we only we create a constant just this is just for it to look cleaner you don't have to you didn't have to create a constant to get it but yeah and then here we're going to create our first game object which is going to be our map so in kabon Jaz a game object can be basically everything uh players props Etc uh what what is a game object exactly it's um it's an object that contains different components those components can be POS positions area a body or a specific Sprite and the way Kaboom works is that by passing in an array of components you specify behaviors for your your uh game objects so it's a basically an entity component system I think so how do you how do you create a game object there are many ways uh actually two the first one is the make function which allows you to create the game object but not display it on the screen the add function adds it to the scene so either you have a choice either you make it and then later on you have to call the k. add function and pass in the game object like that or you use the add function from the getgo and pass in your array of components here so for the map what components are we going to need we're going to need to uh this the Sprite component to display the the Sprite the actual map the way we do this is simply by using the Sprite component which is offered by Kaboom and passing it the key for the Sprite you want to display we specified the key in the load Sprite function for the Sprite uh for the image map.png that's why that's how Kaboom is able to know in advance where what to display actually now the next component we're going to add is the positional component and it specifies the position that the game object will have on the screen when it is displayed and here it is zero well it's not necessarily only when it is displayed just the position that you could have regardless if it's if it is displayed or not and then if you use the add function then it's going to to draw it in that spe in that specific place and then finally we're going to need the scale component and we want to scale up our map because it it's pixel art it's small and we want it to be a bigger so a good practice I'm going to do is in the constant. JS I'm going to create a constant exportable constant I'm going to call it scale factor and I'm going to set it to four so we want to increase it four times and then in main.js I'm just going to use that scale factor constant and call it so it should automatically import the scale factor constant in case it doesn't add this at the top of your file all right now the next game object we're going to create is the actual player and for that I'm going to create a constant I'm going to call it player I'm again going going to use the make function here and the Sprites we're going to pass is the Sprite sheet itself but with a default animation this is something you can do when you have imported a a Sprite that has many frames so a Sprite sheet you have access to this second pram where you can specify a default animation and here it's going to be idle down now the second so the second component we're going to need is the area component this creates a hitbox for our player automatically and within you can add so uh it's not very visible so I'm just going to format this myself and then explain so the k. area component allows you to create a hitbox automatically for your player for your game object but you can specify things within by passing in an object with the following properties you can specify which collisions you want this game object so the player game object to ignore and I want to actually this is not necessary we don't need that this because in the in the project I I did it a different way uh initially but then then I found a better way which doesn't require to really need that at all but what we do need is to specify a shape so by default it creates a shape that is roughly the shape of your Sprite but sometimes you want really to control the shape of your hitbox exactly and the way you do that is by passing in an object with a shape property and then use for example k. rect which is going to create a rectangle and then the first param is the position which is the vector two my Vector 2 is X and Y coordinates and you can specify here the vector 2 is going to be 03 so we want the hitbox to be drawn from the origin and then plus three on the xaxis from the origin of the player itself so the area is going to be slightly placed slightly differently than the Sprite itself so that um the head the hbox I is positioned properly and for example the the player doesn't look like they're sinking in a platform or something like that so this is something you have to play with yourself to determine which um which values are the best and now the second and third third params are the width and height of that uh hitbox I'm going to go with 101 it says on purpose smaller than the player Sprite Which should be 16 by 16 now k. body make sure uh is another component that actually makes our player a tangible physics object that is can be collided with and yeah that's basically it it's done automatically by kaboom now we can also use the anchor component to draw the player from the center instead of from the top left corner so this um the way things are drawn by default is that the X and Y coordinates are actually the coordinates of the T top left corner of the object you want to draw if you don't want that you want the X coord X and Y coordinates correspond to the origin you do uh you use the K do uh k. an anchor and then specify which so from the center now it's not the X and Y coordinates that are in the wrong position it's the the where the image is drawn from so that's something so for example uh yeah so the player instead of being drawn from the top left corner where the top left corner of that image will be the x and y coordinate of that player it's going to be the center drawn from the center so feel free to try and change the values or just try without and and then hit F the F1 key to open to the debug mode in KJS and then you can see the difference all right now we need a k position component uh we aren't going to specify a specific position now we're going to do this later when we're getting the data from our map we going to use this spawn point so here if I go back to tiled you can see I created a layer in the original called uh spawn points and it's just this little pin with the name player which determines where to spawn so if I click on it here you can see I've decided on this name I just wrote it here and then it's going to give us the X and Y coordinates so so we're going to know where to place the player all right uh another thing we need to do is to scale the Sprite for the player because for now it's going to be small it's going to be a 16 by 16 and we want it to be at least the same let scale the same as the map so that everything looks right and then finally well not finally but we have what comes next is in Kaboom JS if you want to hold properties for that game object you can pass in in your array of components a an object and then do put whatever properties you want and then they're going to be accessible directly by doing for example player. speed if I create this speed property here and I'm going to put it to 250 I'm also going to create a direction property is going to be useful to know which animation to play by default it is down and then is in dialogue uh property which is initially is false so what why we want this is that when the player is a is in dialogue that means that the text box is displaying text we don't we want to prevent the from being able to move or do anything except read the text and click on the close button all right uh the last thing we're going to add to that game object is the player uh tag so the way actually I'm not sure it's going to actually be useful for this project but I'm just going to add it for now it's when you want to check for collisions if you give a tag to your game object you can then use the on Collide function to know okay this collided with that a tag and that means to run this type of logic so it's a way to identify your game object all right so if I look at the result nothing yet of course because we haven't put anything now that we have the player Etc let's write the logic for actually displaying the boundaries and then as we write this we're going to write everything else we need okay so so here we need a for Loop which is going to iterate through the various layers we had here and then depending on the layer so if the layer do name equal equal boundaries so if we are on the boundaries layer how do I know this it's by looking at the map. Json export and then here you can have for each layer you have a name key the name key this is how you know which name a layer has if they have any all right so if I go back to main I have the layer name equal equal boundaries and then if I we going to need a for Loop which is going to iterate through all the boundaries of layer do objects remember that when you're dealing with an object layer which is the case for the boundaries they have access to the objects property which is an array containing all the objects in that layer and the objects in that layer are just objects with x y and width and height properties as well and now here we use the map object and then we add another game object to it so we can have child game objects by taking an existing game object and using the add function method on it so what I'm going to do here is I'm just going to copy and paste it it's going to be faster and then I'm going to talk over the code so we have an area component with a specific shaped shapes that corresponds to the width and height of the boundary itself this comes from tiled and from the tiled export in map. Json you see each object has a width and a height uh this uh maybe we created this needlessly because the width is zero and the okay never mind anyway so you have your objects from here and then I specify the spe specific shape we want which is a rectangle and you can do this by calling the wct making a new instance of the W class and then here you have as the first param the the coordinates of that hitbox relative to the game object we're creating we're just going to pass in an empty Vector that means we want the rectangle here to be at the same position as the overall game object so yeah the child game object because it's different then the there's the position of the game object itself and then there's the position of the the hitbox so the area for that game object and here by setting the vector two to being zero that means we have the ex exact same uh game object uh game position sorry and then finally we add the body tag this is important so that we can add the is static property what it does it it basically makes sure that the only way uh that means that the player will not be able to pass over it so it's going to be really stuck and that's uh yeah it's going to be U how do I say the player will not be able to overlap and this is how you do walls in kabon jazz and then finally we pass in the name of the object which was defined in in the tile export this uh gives us the tag it's going to act as the tag of the game object is how we're going to be able to identify what the game object is what the boundary is and this is going to come in handy later on because we're going to be able to know what to do when the player collides with it now that we have this right below if the boundary name of that specific uh boundary that we just created in kabj so this we're just taking the name out of the tile expert because we want to do something different so if uh we want to actually here set the on collision events so if the player we have the on Collide method on the player because we use the area component when creating the player we're going to do boundary. name so the first param of the uncollided method is the tag of the second game object you want to check collisions with we want to check the collisions of the player with this game object with the following tag which is boundary. name and then here we have a function that that is going to run as the second param when yeah so it's going to run when there is a when the Collision occurs and here we're going to set the player property is in dialogue to being false uh true actually so that we're going to later on be able to prevent the player from moving while the text box is being displayed and then here we're going to write a this is actually where we're going to write the dialogue display the dialogue sorry so is dialogue is here it's from here and then now if I go to so let's put it to do here to do and let's go to ut. JS and in there we're going to create a new function that is going to take care of displaying the dialogue so export function display dialogue and then the first par is going to be the text and on display and is going to be a method we're going to pass whoops a function sorry that that is going to run when the text is finished displayed so we need two things we need to get the dialogue UI which is basically the textbox container so I'm going to do document. getet element by ID and then text box text box box container all right once this is done uh let me look if I we have it actually the markup for it we don't so let's go first create the markup for it in h in HTML so here we're going to have first of all inside of the div the UI div we're going to have a P tag that P tag is going to have the class of note we're going to later on create the CSS for it and basically it's just an instruction to tap and click around to move now that we have that I'm going to create a div within and this is going to be our actual dialogue UI so I'm going to give it an ID of textbox container and then the Styles here we're going to actually this is not a really good practice to do if you are in uh making a website but I'm going to use the style tag here for a specific thing for the display setting the display to being none you could have just created an ID here um a selector here but I'm going to because I'm going to change this through JavaScript I'm going to use this but actually I think you could just use a I think class list or something like that to so I create a class and then I remove it but you know for for this project I'm just not going to bother with that okay so now I'm going to create another div from within this div is going to whoops so let me do this uh maybe I should increase the font size a bit more Yep so the div here is going to have the class of button actually text box it's going to actually be the text box itself and from within I'm going to have a P tag that is going to contain the text and I'm going to give it the ID of dialogue and then for the going to have a class for it as well which is going to be UI text and later on I'm going to fill those in right below we're going to have another div and then a button the div is going to have a class of button container this is so we can create a container where the button is always going to be on the right side of the screen I'm going to give an ID to this button to being the close button when the player wants to close the text the text box I'm going to give it the class of UI close button now let's write the dcss for it as well since we're here I'm going to load our font font so in kabj you can load the font if you want to display it via canvas but because we're displaying via HTML the text I'm just going to use the CSS for it so font family monogram that's the name of the font and then the source for the font is URL and then it's monogram. ttf and now it should be able to find it out here in the public folder okay now the body tag let's style the body tag as well this is just going to set the font family for all of the body tag to being to using monogram or as a fallback you're just going to use monospace so mono space is a font that should be already in your browser by default the font size by default is going to be two two REM so two REM one REM is basically the the size of the font uh of your browser said by default in at the root so usually it says 16 pixels and then you can decide you can zoom in and zoom out in your browser control so it takes the so here it takes the the the font size and multiplies by two so two times the font of your browser so that it will adapt it going it's going to be responsive by default and then here I'm going to do overflow hidden so here instead of having overflow hidden here I'm just going to put it in the body so that the scroll bars don't appear and then in however in the app selector all of this is going to have a position of relative this is so we can position it precisely with X left and by specifying the left and the top left and the right and bottom Etc so that we can it's going to how how do I say it it's going to leave the document flow and we're going to have much more Gran granular control of where to put it it's like if you would put an element on the canvas you really control the X and Y position of that uh element you put in the canvas so this is basically a way to achieve the same thing in Kaboom JS uh in CSS sorry now let's add for our wait a minute we have the text box I don't think this is I made a mistake this should be an ID and not a class and now below here we're going to have the class of text box uh the ID sorry of text box the selector for it and here by precise by uh specifying position absolute this is where you actually get the full control of where to put it by using the left property uh I'm going to put 10% the right at 10% as well so it's going to look good I'm going to put the bottom at two view height so it takes the view height and then it's it's a measure a measurement relative to the view height so it it's going to adapt regardless of the um of the the screen of the user the minimum height we're going to need is 10 view height this is what looked good this is for the text box you're going to see an instant when we'll see the result the background so this is the color of the text box let's put it white the okay so we have the background the Border radius I'm just going to put three pixels it doesn't matter the outline style is going to be black or solid is it the color solid the padding is going to be one ram as I explained Ram is based on the font size of your browser and it makes it responsive basically and then what do I need display Flex we're going to create cre a flex container now this is some CSS knowledge I would I assume that you have it you have this knowledge already if you don't read up on Flex containers there are plenty of great articles and posts online explaining everything so we're going to have display flex and then a flex direction of column so so the children of our Flex container are going to be positioned in the column we're going to set the flex wrap to being to wrapping so that when there's no space it moves on to the next row we're going to justify the content to being Flex start this is so that um the text within the uh the text box starts at the top left corner uh align items as well I'm going to do Flex start um I think I'm I always mess up the justify content and align items one if is for the the axis for which the the content is flowing and the other one is for the cross AIS so for both of those case we want it to do start at Flex start which means it's a top left top left and and uh yes so it's top left basically and then play with the those values as you you're going to see how they are affected then word spacing word spacing is going to be 0.2 remm this what looked good so word spacing is selfexplanatory so the the words appearing in the text box and then here we're going to have a little drop shadow so we're going to have a filter and then a drop shadow with the following arguments um REM and then a color RGB so this is really took straight from the mdn documentation with just a bit of tweaking in terms of colors yeah I don't really know maybe there's some explanations here yeah you have uh drop shadow here so here it is explained the where are the pams where are they um it does it explain okay okay it's in French by the way anyway you're going to figure it out uh by just looking at the docs mdn docs type in drop shadow CSS you going to understand all right now the UI text class going to have a margin of zero and then user select none this is important so that the player cannot select the text and have highlight it like that usually you don't do that in a game and then finally you have uh actually there's two there's a couple of selector to Define so UI close button I'm just just going to copy what what's left it's not much and I'm going to go over it so UI close button uses this font family uh for some reason you need to specify this otherwise it uses it doesn't use the font and I'm not sure why border style none border radius three pixels some padding and then it it should it should inherit the font size actually maybe you could do inher par it here as well and should work and then button container it's going to align itself at the end of the text box so that the the buttons always going to be appear appear at the top right corner and then the note is going to be again position absolute is going to be at the top left corner so left and then top one VH display Flex Flex Direction column Etc and then this is the color of the text it's going to be have that color yeah I save everything look at the result you can see that here you have tap click around to move here it doesn't matter if you can select or not but for the text box we don't want you to be able to select text actually you know what let's also put it as user select none just to make sure that it looks like a game and that's it uh if I now try to select I can not you see all right now we have this we can simply go back to our .js and write the rest of the logic we had here so we need the following so I'm just going to copy and paste that here so we get the text box container we get the dialogue so the dialogue is actually the P tag here where we actually put the dialogue in and then what what we're going to do is we're going to set the the display so initially remember in our markup I said I put style display none this is to make all of this Invisible by default when we want to show the dialogue we can use the style attribute here and set the display to being block and this is going to make the the textbox container visible so which by extension means that the dialogue box is going to appear and the text is going to be visible now we're going to implement text scrolling and this is very simple in HTML you this is the code for it so I created an index which I set to zero and then the current text is going to contain the text we're going to add to the element the the the inner HTML here of the dialogue box now inner HTML is not really recommended to use because you can be victim of cross site scripting so here in this our particular case it doesn't matter because we're not accepting user input input so it should be safe to not to use in our HTML and it's kind of required because when we want to have our dialogue box you're going to have sometimes the text that appears with links to your GitHub or things like that as attributes Stag and if we were to use inner text for for example then those uh attributes that we pass the the yeah the links are not going to be rendered as links and will not be clickable so here we use the set interval function in JavaScript this is something that is basic like vanilla JavaScript and every 5 Seconds uh it's going to run this the the function here we put a reference to that interval uh that set interval event so that we can cancel it clear the interval when we're done with it and then as long as the index is inferior to the text. length so text. length is the text that we pass here then we take our current text we append the specific character at that specific index of the text and then we put it all in the inner inner HTML and uh yep and then we do index Plus+ and then we skip this until this the condition is no longer true and then we clear and that's basically it now we need to write the logic to um have the onclose button so the when the button needs to be closed to do something like that I'm going to put this outside but still in the display dialogue function if I paste you have we get the close button by using a simple get element by ID and then I create this function called on close button click it's going to call the on display and function this is a useful because we in this function going to set the player uh is in dialogue attribute to being false without having to pass the player to this method this function so this a handy way of using an out passing a function from the outside that does has access to player the player object so that we don't have to add a third param here and it doesn't make sense really why would you need the player to display the dialogue so that makes a much more sense and it's much more extensible for example if you want to do other behaviors when the display is over and and then here the dialogue UI install display we put it back to none so that the dialogue section of the UI is going to be invisible we set the inner HTML back to being empty empty this you could have used inner text it doesn't matter and then we clear the interval if it's not yet the case and then we close we remove the event listener because we're going to add it so we remove the function itself within the function so it's recursive so here we have at the end we create the event listener when the when there is a click and then it runs this and then it removes itself as the event listener so so that's it now if we go back to main.js we can here in the todo section have player um not player call the display dialogue functions going to import it automatically actually it should automatically import it from the utils file and then here I'm going to pass the dialog data so here for now let's put test or todo that's our text that we're going to display and then here we're going to have a function and this function actually just its role is just to set the player is in dialogue to being false so that the player can move again and yeah so look at the code here and that's it so if I think I have it I Collapse this and then if however so we should probably put a continue at the end so here after all of this we continue that means we skip to the next situation ation of the for Loop and then here if the layer oops the layer. name is the spawn points well the spawn points layer which is where the the the player spawns we're just going to have four con entity of layer. objects there's just one entity but I'm writing the code to be generalizable so that if you decide to put more than one entity in the tille export it's going to still work and then so if entity. name is equal equal to the player so this is going to be the player so that's this is the name I'm going to put player. position because I added the positional component when created creating the player game object despite having set it up to nothing I can access the attribute position and set it manually after having created the game object and here I'm going to use a vector 2 which is just the x and y coordinate and the position we're going to use though it's going to be very specific it's going to be whoops not what I wanted to yeah so we're going to take the position of the x coordinate of the map you do this by accessing the pause property and then the x coordinate and then I'm going to add the entity dox which it tells us where to place the player and we multiply this by the scale factor because remember we we're basically multiplying everything by four so that everything is nicely visible and big enough same logic for the ycoordinate and then finally here we use the add function in Kaboom to add the player game object we created in the scene and then here you can continue or doesn't matter because we only have like two layers or anyway so now that we have all of this it's time to I'm going just going to collapse all this section we're done with it and then here I'm going to um I think that's uh let right just some code to make the camera follow the player so by default in cabun you have the camera object already created you can call the gam cam pause so the camer system already exists you can just control it so I'm going to take the player world position the reason we using World position instead um actually doesn't matter really because we haven't created the player as a child object so so if you're using if you're creating a game object as part of a child of another game object you use World position to convert the its position to being the position of the in the actual canvas and not relative to the parent so here I'm going to use player. pause. x and then player. doy plus an offset of 100 so this campuse is going to set the camera position to being this in the x coordinate and this in the ycoordinate now if I look at the result okay I have the character but uh the map is not appearing I'm wondering why actually why is the map not appearing is it doing everything right um wait a minute so if I go back to the top where we created the map we have okay I haven't added it to the to the canvas but you know what because we're doesn't matter let's use add instead to immediately add it to the the canvas and here we go the map is displayed if I press F1 you can see all the the collisions and for the specific objects you're going to have TV sofa table PC resume project exit Etc now the player cannot move so let's fix that and then uh also we're going to need to add some other stuff like uh setting the camera scale so depending on if the player is using a small screen or a big screen we want to make the the camera zoom a bit or not to compensate so here um so let's actually write the logic for moving the player so I'm going to use the k. on Mouse down so because this is a very simple project compared to other tutorials I made I'm not going to write those methods inside of the player let's just use the on and take the the player game object directly here and yep so when on Mouse down is an event in Kaboom JS it takes in a function and it will pass to it the mouse button that is currently being pressed on mobile it's just going to consider a tap basically and then here if the mouse button is not equal to the left M Mouse click or the player is in dialogue then we return early that means we do nothing we don't move and this makes sense because we don't want to allow the player to move when a right click is pressed instead of the a left click because if they press both at the same time they're going to move twice as fast it doesn't really matter because it's not a game we're building really but just so you know and here if the player is in dialogue of course we don't want to allow the player move to move while they are in dialogue we want them to focus on the dialogue okay now for movement we're going to need the following snippet of code so let me just okay so that's all there is to it when it comes to mov we need the world Mouse position that means because we're using the camera the mouse position is going to be really um according to the canvas and not according to the world the world can be much bigger than the canvas because the world is much more than what is visible by the camera and when you drag around this uh what happens is that if you use the k. Mouse pause the mouse position directly you're going to at some point get stuck I wrote a Blog Post article on my substack link is in the description so feel free to read read it to get a better understanding and by the way subscribe to my sub if you want uh for more like written content yep so the only thing we need now to move the player is to use the move to function that is available on the player because we have the I think the area component the body component I think because because of the body component so some certain methods in Kaboom JS are only accessible once you have added certain components when creating that game object so the first param is which what is the target position you want and we want the world Mouse position so we want the player to move towards this at the specific speed and here we just get the speed from the player which we defined here all right now if I look at the result we should be able to move and here we go and then you can see we Collide and then Todo there's nothing that appears and then Todo again Todo we haven't written the content but that's almost all there is to it you know the next step is really to code the direction various directions so make the player face different direction scaling the camera according to the the device being used the the resolution otherwise sometimes it's too big and becomes too big and actually putting the content inside of those text box and that should be it so now let's actually write the logic for scaling the camera and then we'll write the logic for the directions and then we'll add a text hopefully that order so here for the camera scaling I'm just going to in the .js we're going to create another function right below export function set cam scale and then here we just pass the context so we can know we can compute how much we need to scale so here I'm going to create a constant I'm going to call it resize factor and it's going to have access to the width of the canvas you can have access to the width of the canvas by calling the width method on the Kaboom context and the height um as well and then we have this division to get a factor and then if the resize factor is inferior to one that means we will simply set the cam scale cam scale this is a kaboom method to being just one uh you can also do two VC one which is just going to set it to one uh otherwise an lse statement you could either have an lse statement or if if you want to be fancy you can and more clear you can have an early return and then here right below you can have k. cam SC scale cam scale and then k. Vector 2 and we increase the scaling so we Zoom by 1.5 in both X and Y uh Transformations so 1.5 all right so now we have this I'm going to go back to main and and where we're going to call it is we're going to call this function first in in two occasions the first one at the beginning we just do set cam scale and then K and also every time we resize the cvas so you can know when this happens by using the on resize Kaboom uh method which takes in a function that that is going to run when this occurs and then you just can call the set cam scale and then pass in the context here so let's look at the result so here you can see everything is much better and then as you decrease the thing it's uh smaller I think or is it that's uh let's take an iPhone SE and then let's uh yeah it seems to relatively work maybe I'm not sure let's gradually yeah all right yeah so it's it does yeah it does change okay sounds good now what we need is to basically display the correct animations and Sprite depending on the direction so what I'm going to do to be able to know when the player should be facing left or right or any of those uh angles is to first store the mouse angle which is just going to be the angle between the player so you can do that by using the angle method of the position of the vector of the position of the player so player. pause. angle gives you this and then you can pass in the world Mouse position and it's going to be give you the angle between and with that I'm going to first specify a lower bound which is going to be 50 and a um upper bound which is going to be um 125 going to see in an instant why we need this and then we have our if statement so here I'm just going to copy and paste and talk over it so first condition if the mouse angle is superior to the lower bound and inferior to the upper bound and the current animation isn't walk up then we will play the walk up animation and set the player direction to be up if I look at the result it's when the mouse is here imagine that you had a circle and then here if your mouse is within a certain range actually for now you're not going to see the difference so let's say my mouse the angle here and here so you're on the circle as long as my my mouse is still within those position the up animation is still going going to play however if my mouse exceeds for example here we shouldn't now this is not very clear for now but let's add the conditions and then you'll see so now what comes next is the for the down animation so it's it's the same thing with negatives instead so now if I run and look at the result if my mouse is here and I click Mouse down the up animation is going to play if I my mouse is here the down animation is going to play now if I do whoops okay let's whoops okay let's say I'm I'm here so if I do this and then I change you see it dynamically change as long as I hold the mouse because now the the mouse position is within those upper and lower bounds of the this imaginary circle in terms of angle so now I'm just going to add the two other conditions this is for the left and right then here right below so for the right it's we take the absolute value of the mouse angle and as long as it's superior to the upper bound we flip the player X to being false this the flip X X is useful because we only have one animation for the walking it's called walk side and by default it faces to the right that means that if the player was flipped uh mainly because of the other animations where we do flip so for the left side then we put it back to false so that the the player looks at the correct direction and then here the same thing but with flip X being true instead and uh as long as the mouse angle is inferior to the lower B down the absolute value so we don't care about whether or not it's negative or positive Etc so this is so it works on both sides of the circle the imaginary Circle so now if I look at the result you see and you can have directional movement like that now you see that the animations of the the player never stops right uh the way to go about that is to use the uh on Mouse release method in Kaboom JZ I'm going to paste it right below so here let's a let me collapse everything here and yeah on Mouse release if the direction is down we put idle down if the direction is up we put idled up and if uh it's neither then we put the idle side and because we flipped we fli the player uh it's going to point towards the correct direction by default we don't need to do anything so if I look here I do this here you go then like that and then I hold I release sorry I release the mouse and then the player stops and uh basic that's basically it now the only thing is really the content here and what we're going to do here for that is I'm going to go back to where we I think it was here when instead of having to do we're going to hold the content of our dialogue inside of an a constant I'm going to just call a dialog data uh let me just look it up so I'm going to copy and paste it and just explain to you the the how how it works and then you don't have to use the same text so here you have a dialogue data object with keys that corresponds to the tag of the boundary so for the PC you have this text and then you can see me using the a tag here to have links Etc as if it were HTML and now here in main.js instead of doing this what you do is just you you get the dialog data constant from the constant file so it should import it automatically otherwise do it manually here here it is and then here you just pass in the boundary name to corre uh select the correct text to display and that's basically it the project is done if I go here and I go here if you want to exit J Legends portfolio just close the the tab and then here that's my TV I've been watching Tech YouTubers a lot recently the primagen Theo pirate software milky Etc and then here that's my sofa I like to relax and Etc and then you get the point so if I open up the um the uh debug mode you can see when there is the PC key here those are the name of the various boundaries and this is how we we use them them to as keys for our dialogue data so here for example this is my Dex my desk on it is my resume check it out and then it's a link with an a tag so here if I go here the a tag where is it uh constant you can see uh the link to my resume Etc so this is your free don't don't just copy what I wrote here write your own dialogues to tailor it to your uh your yourself basically and that's basically it thanks for watching this tutorial hope it was uh something that you you like to to learn about and uh yeah thanks for watching feel free to subscribe for more content related to game development uh specifically JavaScript or web related game development but hopefully not only maybe I'll try try to do other types of uh development uh or with other Stacks so maybe making games with Lua or some stuff like that in the future so yeah feel free to subscribe and share this video if you found found it useful all right thanks for watching bye
