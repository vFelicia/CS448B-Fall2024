With timestamps:

00:00 - this guide to building rest apis on NEX
00:02 - js14 goes beyond simple Crut operations
00:05 - teaching how to create multiple mongodb
00:07 - models like users categories posts and
00:10 - comments while also covering how to
00:13 - protect API routes you'll get hands-on
00:16 - experience in setting up schemas
00:18 - building robust apis and implementing
00:21 - Advanced features such as logging
00:23 - middleware and deployment in this course
00:26 - um jam will help you enhance your nextjs
00:29 - and rest API development skills hello
00:31 - everyone my name is Om I'm a senior
00:33 - software developer I'm building web
00:35 - applications for over 8 years now many
00:38 - people use nextjs for their frontend
00:40 - interactive applications but in this
00:42 - video I'm going to teach you how we can
00:44 - build complete backend and build rest
00:46 - apis using nextjs 14 using App directory
00:49 - structure so these are the topics I will
00:51 - be covering in this tutorial first of
00:53 - all I'll will be creating a new NEX js14
00:55 - project from scratch after that I will
00:57 - be explaining you guys what are the
00:59 - different fold ERS and file structure
01:01 - recommended by nextjs in order to create
01:03 - apis in our project after that I'll show
01:06 - you how we can connect to the database
01:08 - in this case I will be using mongodb
01:11 - after that I will be creating different
01:13 - models for adding relationship between
01:15 - users blogs and the categories and all
01:18 - the relationship happening between these
01:20 - models for example a category belongs to
01:23 - one user a Blog belongs to a category as
01:26 - well as users and more relationship
01:28 - between these models and this point is
01:30 - going to take a lot of time because we
01:32 - will be creating all the apis and adding
01:34 - error handling in our apis after that I
01:38 - will show you how we can add filtering
01:40 - searching pagination and all of
01:42 - different these things for blogs if you
01:44 - want to add these features in your front
01:46 - end application using these apis after
01:49 - that I will show you how we can protect
01:50 - our apis using beer token it means from
01:53 - the client side when you will be
01:54 - accessing these apis if you don't pass
01:57 - any beer token then it will throw an on
01:59 - a authorized error then I'll talk about
02:02 - middle wees how we can add logging or
02:04 - error handling before any execution of
02:06 - the apis finally I will show you how we
02:09 - can deploy over complete backend in
02:11 - nextjs 14 on versal so during the
02:13 - development of the apis in this tutorial
02:16 - I'll keep on testing all of these apis
02:18 - on Postman in Postman we can create
02:21 - collections folders and then the
02:22 - requests for the get post patch delete
02:25 - and put and I'm going to explain you how
02:27 - we can use Postman in order to test the
02:29 - apis by adding different URLs adding
02:32 - authorization headers how we can add
02:34 - different body data over here and test
02:37 - that out so before starting I just want
02:39 - to tell you guys that I have my personal
02:42 - YouTube channel as well where I create
02:45 - videos on multiple technologies that
02:47 - includes react angular node Express
02:50 - mongodb prompt engineering Docker cicd
02:53 - git GitHub typescript and all these
02:56 - different topics and if I go to the
02:58 - playlist mainly I create videos on
03:00 - nextjs so this video is mainly for the
03:03 - back end if you want to learn about
03:05 - front end in nextjs then I have created
03:07 - all the videos on different topics for
03:09 - you guys in order to become a good NEX
03:11 - gs14 developer so you can check the link
03:14 - of my channel in the description of this
03:16 - video and I would really appreciate if
03:19 - you can subscribe my channel as well so
03:22 - let's get started by creating a new next
03:24 - js14 project I've opened up vs code with
03:27 - an empty folder inside it and and now
03:30 - first of all we need to verify if we
03:32 - have the latest varion of node and npm
03:35 - installed in our system once we have
03:37 - verified I'm going to write a command
03:40 - npx create next app at latest dot I will
03:46 - hit enter dot means that I don't want to
03:48 - create a new folder inside my existing
03:51 - open folder in our vs code so I'm going
03:54 - to go with the typescript es lent
03:56 - Tailwind CSS Source directory no app
03:59 - router yes no for customized default so
04:03 - most of these options are related to
04:05 - front end but I'm going to be focusing
04:07 - on backend side only so our project is
04:09 - created I'm going to clear the terminal
04:12 - out so let's see what we have here this
04:14 - is our main folder app and it includes
04:17 - all the files and the folders for our
04:20 - apis for our frontend routes since I'll
04:23 - be focusing on backend side only so
04:25 - let's talk about the folders and file
04:27 - structure for the back end so inside the
04:29 - app Direct first of all we need to
04:31 - create a new folder API and everything
04:33 - we will be creating on the backand side
04:36 - should be added within this API folder
04:38 - and inside this API folder we need to
04:40 - create another folder let's call it
04:42 - users and the name of this folder will
04:45 - become the part of the URL for this API
04:48 - means that in Local Host we are running
04:50 - the application it becomes Local Host
04:53 - colum 3000 SL API SL users and it will
04:57 - become an API if we create a file file
05:00 - called route. TS inside it we cannot
05:02 - change the name of this file it is
05:04 - predefined by nextjs and inside this
05:07 - route. TS I'm going to show you by
05:09 - creating a simplest API so let's create
05:12 - export const get this is going to be a
05:15 - get request we cannot change its name
05:17 - and let's return some message from
05:20 - inside so I'm going to return new next
05:24 - response from next server and this is my
05:30 - first API okay so let's save this file
05:35 - and I'm going to run my project by
05:36 - running npm run Dev and it will run on
05:39 - URL Local Host colon 3000 now I'm going
05:43 - to open up browser and Trigger Local
05:46 - Host column 3000 SL API SL users and
05:50 - this get request should be automatically
05:52 - triggered get request can be tested on
05:54 - the browser because in get request we
05:56 - are not passing any kind of data to it
05:59 - so in the browser you can see that I
06:01 - have triggered Local Host column 3000
06:04 - API users and this is the response it
06:06 - has returned so it means that our API is
06:09 - working fine now in order to organize
06:12 - our apis in nextjs nextjs recommend us
06:16 - few folder structure techniques so let's
06:18 - say in our applications we have
06:21 - authentication and users apis and we
06:24 - have the dashboard apis that can include
06:26 - the settings all the analytics all the
06:29 - lists of data that we need to show so if
06:31 - we create all the different folders
06:33 - directly in the API that it can become
06:35 - messy I want to organize the folder
06:38 - structure but I don't want that folder
06:40 - structure to be a part of the API URL so
06:43 - I can do that so inside the API folder I
06:46 - can create a new folder let's say all
06:48 - the authentication related apis it can
06:51 - be the login sign up users reset
06:54 - password forget password should be added
06:57 - within this Au folder now I'm going to
06:59 - move this users folder inside this o
07:02 - folder you will be thinking that this o
07:05 - folder now will become the part of the
07:07 - URL but that's not the case this is for
07:10 - only organizational purpose if I go on
07:13 - the browser and refresh this URL you
07:15 - will see that this API is still working
07:17 - without adding the Au so if we add
07:20 - parentheses around any folder that gets
07:23 - excluded from the URLs on the back end
07:26 - as well as if we create the routes on
07:28 - the front end in next xjs now I'll come
07:31 - back to this file when I will need to
07:33 - create all the get post patch and delete
07:36 - request for the users along with the
07:38 - error handling and curing data from the
07:40 - database before this I want to connect
07:42 - my project with the database for that
07:44 - I'll be using mongodb which I can set
07:47 - locally in my system but I will be using
07:49 - a cloud mongodb provider from the
07:52 - Atlas so you need to open up cloud.
07:54 - mongod db.com and sign up with your
07:57 - email ID after that once you sign up and
08:00 - sign in you need to create a new
08:03 - organization I think that it is going to
08:05 - autogenerate the first organization if
08:07 - it doesn't you can go to the view all
08:09 - organization and create a new
08:11 - organization first of all within the
08:13 - organization it will show you all the
08:15 - different projects if you are new to
08:17 - this it won't show anything so these are
08:19 - all the projects I've already created
08:21 - I'm going to create a new project for
08:24 - over rest API in xs14 so I'm going to
08:27 - click on the new project button and here
08:29 - I can name
08:31 - next4 let's call it mongod
08:34 - DB rest API so this is the name I've
08:38 - given to it you can name anything all
08:40 - right so we should not add actually this
08:43 - is optional I'm going to click on next
08:46 - and uh I'm going to leave it as project
08:48 - owner and click on create project so
08:51 - it's going to take some time and uh I
08:53 - myself want to use this API so that's
08:55 - why I didn't add any email Above So now
08:59 - this project have been created and
09:00 - inside this project I need to create a
09:03 - new cluster so by default it's going to
09:06 - give me these options uh 0.08 per hour
09:10 - dollars I'm going to go with the free
09:12 - because this is just for testing once
09:14 - you want to deploy your project on
09:16 - production then you might want to choose
09:18 - any of these options which you can
09:20 - change later on as well I'm going to
09:23 - leave this default name cluster zero I'm
09:25 - going to check AWS I'm going to select
09:28 - the nearest r region uh where I'm
09:30 - sitting currently so I'm going to go and
09:33 - create deployment so it is I've clicked
09:36 - on that it's going to take some time and
09:38 - create the cluster for me so this is the
09:40 - model that it has opened first of all it
09:43 - has given me this username and this
09:45 - password I can generate a new password I
09:47 - need to copy this password over here
09:50 - which I would need later on when I will
09:52 - be adding it in my project so let's copy
09:55 - it and paste it somewhere I've just
09:56 - opened up a new tab and pasted it over
09:58 - here and uh let's go choose a connection
10:01 - method actually so set up your account
10:04 - so I'm going to click on the create
10:06 - database users first of all and then I'm
10:08 - going to click on choose a connection
10:10 - method so these are all the connection
10:12 - method has given to it so I'm going to
10:13 - click on this driver and uh first of all
10:17 - we need to install this package npm
10:19 - install mongod DP let's stop the project
10:21 - and hit enter by adding this command and
10:24 - now this is the URL that we need from
10:27 - here let's click on this icon and it is
10:30 - going to gets copied and in our project
10:33 - I'm going to create a new file and I'm
10:35 - going to name it EnV and let's name it
10:40 -  dbor urri equals to and this is
10:45 - where I will be pasting that URL which I
10:48 - have just copied okay and after that I'm
10:52 - going to go and I'm going to copy this
10:54 - password which I saved actually it
10:56 - already added over here earlier here it
10:59 - was not already added which we had to
11:01 - manually add from here all right so here
11:05 - we have this uh retry wres through W
11:09 - majority app name cluster for now we
11:12 - don't need this app name cluster I will
11:14 - be modifying it in my DB connection code
11:18 - okay so let's remove that and let's save
11:20 - this file let's close it and for now we
11:23 - don't need to care about this page for
11:26 - now let's click on the done and let's
11:28 - click on the
11:30 - database and first of all I'm going to
11:33 - go into the network and here currently
11:36 - my current IP is uh added over here
11:39 - means that the API the data that is
11:42 - added in this database can be accessed
11:45 - from my network only I want it to be
11:48 - accessed from anywhere in the word so I
11:50 - can click on ADD IP address allow access
11:53 - from anywhere so it's going to add 0.0.0
11:56 - from here and I can click on confirm So
11:59 - currently it is pending and after few
12:02 - seconds it's going to be active so it
12:04 - means that everyone from around the
12:06 - world can access over apis if you want
12:08 - to do that on the production you can do
12:11 - that so I've just done it uh on this DB
12:13 - and you can see that it is active I can
12:15 - click on the database and uh I can go to
12:18 - the browse collection and currently it
12:21 - won't show anything because we don't
12:22 - have any data and I will come back to
12:25 - this page once we have the data we will
12:27 - be performing different crowd ations in
12:29 - our project so first of all in this
12:32 - project I'm going to create a new folder
12:34 - and this is going to be called lib and
12:37 - inside this lib I'm going to create a
12:39 - new file let's call it db. TS and inside
12:43 - this file I'm going to execute the
12:47 - Mongo's Connection in order to connect
12:49 - my project on that mongodb database and
12:52 - the URL is I have already added in EnV
12:55 - so let's open up the db. TS first of all
12:58 - I need to import mongus and I need to
13:00 - install the
13:01 - mongus in the terminal I'm going to
13:04 - write a command npm install mongus hit
13:07 - enter so this is going to get installed
13:09 - once it's getting installed I can import
13:12 - that from mongus okay so let's get that
13:16 - URL from that EnV file so I'm going to
13:19 - write mongod dbor URI equals to process.
13:24 - EnV mongodb URI so this is what I've got
13:28 - after that I'm going to write a function
13:31 - con connect
13:33 - async this URL and then I'm going to
13:36 - check if the connection was already
13:38 - connected then uh we would don't want to
13:41 - connect it again so this is just for
13:42 - error handling so I'm going to get
13:46 - connection state from
13:50 -  do connection do ready State okay
13:55 - and then I can check if the connection
14:00 - state is equals to 1 it means that it
14:05 - was already connected I'm using tab 9 a
14:09 - assistant extension in my VSS code so
14:11 - sometimes it suggest me uh the code when
14:14 - it sees uh then I have to hit Tab Key on
14:18 - my keyboard and then it gets selected so
14:20 - this is what happens just now and after
14:22 - that uh I can actually add the
14:25 - connection State equals to two so this
14:26 - is the tab 9 a assistant which is
14:28 - recommending and this is right I can hit
14:30 - tab so now I can go
14:34 - console.log connecting dot dot dot okay
14:38 - and then return after that if any of
14:42 - these conditions get failed it means
14:44 - that we need to connect to our database
14:47 - so I can use mongos do connect and then
14:50 -  URI and exclamation mark and the
14:54 - reason it is showing this error that it
14:56 - kind it kind of uh uh thinking that it
14:59 - may be undefined but we know that it
15:01 - cannot be undefined we have added it in
15:03 - our project so I can add exclamation
15:06 - mark after that okay so after this I can
15:10 - add this object and let's add the DB
15:13 - name and uh let's add next 14 rest API
15:18 - this is the DB name I've added and this
15:21 - is the buffer command I'm going to give
15:23 - it value true okay uh we can add console
15:29 - do log connected and uh for the try I
15:33 - need to add the cat block as well in
15:35 - case there comes any error so console.
15:39 - log error let's show the error over here
15:44 - and uh throw the error as well so throw
15:47 - new error and then the error all right
15:51 - um I can actually pass the error and
15:54 - like this okay so it is giving us few uh
15:59 - types scripting so for now I'm going to
16:01 - add this data type any over here okay so
16:05 - that's pretty much it for this
16:07 - particular file and one last thing
16:09 - because we will need to access this
16:11 - connect function in uh our uh API files
16:15 - so I need to export it from here so
16:17 - export default connect all right so for
16:20 - this DB uh that's pretty much it let's
16:23 - close all of these files and I'm going
16:25 - to create a new folder inside this live
16:27 - and I'm going to create create models
16:29 - for users category blog and I'm going to
16:32 - add the relationship between these so
16:35 - hit enter and inside it first of all I'm
16:37 - going to create a new file and I need to
16:41 - create the users model first of all so
16:44 - mongus provide us built-in functions for
16:47 - creating the schema like which
16:48 - properties the users can have like the
16:51 - email username first name last name
16:53 - password full number address so I'm
16:56 - going to go with the minimal data
16:58 - because once you understand how things
17:00 - are going then you can add the more data
17:03 - as you want okay so I can add import and
17:07 - then let's add the
17:09 - schema
17:11 - model models and this is going to be the
17:14 - from
17:17 -  okay let's create the user schema
17:22 - and for creating the schema I can use
17:24 - that schema class which I have imported
17:27 - above and inside it I can add an object
17:31 - so let's add an email and email is going
17:34 - to be of type string required true and
17:38 - email should be
17:41 - unique okay after this I need to add the
17:46 - username which I can
17:48 - add so this is going to be type string
17:50 - required true unique true and uh make
17:54 - sure you install the tab 9 AI assistant
17:57 - uh it really helps sometimes okay this
17:59 - is what recommending me so after that it
18:01 - is automatically suggesting whether I
18:03 - might want to add the password and yes I
18:06 - want to add the password so this is why
18:08 - it is suggesting me this so password is
18:11 - like this okay and after this I'm going
18:14 - to add another object so whenever this
18:17 - new user gets created or updated I want
18:20 - to create the created ad and updated at
18:23 - time stamps automatically created in my
18:26 - database so time stamps equals to true
18:28 - and make sure you add this after that
18:31 - I'm going to add the con user equals to
18:34 - the models do user or
18:39 - model and then I'm going to add the user
18:42 - comma and then the user schema and after
18:45 - that let's export this user because this
18:47 - user we will be needing in our API
18:50 - route. TS file including the db. TS uh
18:53 - in order to cury the data from the
18:55 - database whether we want to store the
18:57 - data in the database for
18:59 - post patch or the delete or we want to
19:01 - get the data from the database so I'll
19:04 - come back to this folder I'll be
19:05 - creating more uh models uh like the
19:08 - category or the blogs to add the
19:10 - relationship between this user schema
19:12 - but first of all let's create the apis
19:14 - to create a new user in the database uh
19:17 - to update the user to delete the user
19:20 - and to get the users from the database
19:22 - so let's open up this route. DS file now
19:26 - now I'm going to modify this get request
19:28 - to fetch all the users exist in the
19:30 - database although there are no users in
19:32 - the database because we haven't created
19:34 - any yet and we haven't either created
19:37 - the post request in this file which is
19:39 - going to be responsible for creating a
19:41 - new user so first of all let's modify
19:43 - this get API for the users I'm going to
19:47 - add a tri block and inside it I'm going
19:50 - to write a wait and I'm going to call
19:52 - the connect function so before any
19:55 - operation that we perform to the
19:57 - database then we need to call The
19:59 - Connect function that we have created in
20:01 - db. TS file so I'm going to import it
20:04 - from /lib sdb this is the path of the
20:08 - db. DS file and after that I can
20:12 - actually use users a wait and then I'm
20:16 - going to write user this is the name of
20:18 - the model which we have created and this
20:20 - is going to be imported from at lib
20:23 - models and then the user and if I write
20:26 - dot you will see that all of these
20:28 - different functions are pre-built
20:30 - provided by mongos and we can use any of
20:32 - these functions find means return all of
20:35 - the users data exist in the database
20:37 - find by ID find by ID and delete find by
20:41 - ID and update so I'm going to go and
20:44 - select the find it is going to return me
20:46 - all the users although uh there are no
20:48 - users but we are going to verify and
20:51 - this connect function is working
20:52 - perfectly fine and the connection to our
20:55 - database is working pretty fine so after
20:58 - that I'm going to return a response
21:00 - return new next response and then I'm
21:04 - going to add json. stringify users and I
21:07 - can also pass the status as well let's
21:10 - call it 200 okay and after that in our
21:14 - else not else actually the catch block
21:17 - error and inside the catch block I can
21:21 - return any kind of error as we want okay
21:25 - and for the await I need to write async
21:27 - over here and this error is going to
21:29 - gets invisible now so I'm going to add
21:33 - error in fetching
21:37 - users and I'm going to add
21:41 - plus error. message and uh lastly I'm
21:46 - going to add the 500 status code this
21:50 - error is showing some kind of message so
21:53 - I'm going to add any data type over here
21:56 - so after making some changes in the back
21:58 - of nextjs I try to rerun the project so
22:01 - npm run Dev in the terminal so it is
22:03 - getting started now I'm going to
22:05 - re-trigger this route Local Host colon
22:08 - SL uh 3000 API SL user so let's go over
22:12 - here and let's refresh this particular
22:16 - URL okay so Local Host colum 3000 API
22:19 - users and this is going to gets
22:22 - triggered and I'm going to go inside
22:24 - this DB and I'm going to click on this
22:26 - refresh button so let's see if it
22:29 - creates yes this DB name gets created
22:31 - next 14 rest API and along with that it
22:35 - has created this users model although it
22:37 - contains nothing and this was expected
22:39 - but we have verified that our DB
22:42 - connection is successful and the name of
22:44 - the DB with the name users is also
22:47 - successful so it got this users name
22:50 - from this users. DS file from here by
22:53 - adding s after that and if I go to the
22:55 - db. TS you will see this connected
22:57 - string is visible
22:58 - this is because of the console ninja
23:00 - extension which I have installed in vs
23:02 - code now let's open up the route. TS I'm
23:05 - going to close these two files and uh
23:08 - before creating the post request for
23:10 - creating a new user Let's test this get
23:14 - API in our Postman so you need to
23:16 - download the postman you can also use
23:18 - the postman on the browser or you can
23:21 - download it in your system I've
23:23 - downloaded it I've already signed up
23:25 - with my account uh and here on the left
23:28 - side we can see there's a collection
23:30 - environment and the history so you need
23:32 - to go to the collection and you can
23:34 - create a new collection from here if I
23:36 - click on the blank connection uh then
23:39 - this folder is going to gets created
23:40 - inside it we can rightclick and add a
23:44 - new folder which I've already added you
23:46 - need to add a new folder with the name
23:48 - users okay and inside the users you need
23:51 - to click on the add request once you
23:54 - click on the add request uh a random
23:57 - request is going to get generated within
23:59 - that folder okay let me zoom in yeah so
24:02 - now this is the first get request which
24:05 - I've already added and uh here you you
24:08 - can change the name of this get request
24:10 - and from this drop- down you need to
24:12 - select the get okay and after that you
24:15 - need to write the URL of the API that
24:17 - needs to be triggered so this is the
24:19 - same URL which we have triggered in our
24:22 - browser and now let's try to trigger
24:26 - this API in post man so I'm going to
24:28 - click on the send and here you can see
24:31 - that it has created this empty array and
24:34 - it means that over DB is working and
24:37 - connection is successful and these are
24:40 - some default headers you don't need to
24:42 - care about that okay so now I'm going to
24:46 - go and I'm going to add a post request
24:50 - so before that actually nextjs what
24:52 - happens is we use third party services
24:54 - for authentication of the users for
24:56 - login sign up it can be the cler
24:58 - authentication next o Au zero kind
25:01 - authentication uh and that gives us all
25:04 - the information of the session of the
25:06 - loged in user the signed up users but in
25:09 - sometime some cases we need to add the
25:13 - same user data in our own database as
25:15 - well because of the relationship within
25:17 - other models in our application so I've
25:21 - already created the videos on all of
25:23 - these different topics on my personal
25:25 - Channel you can check that out and the
25:27 - reason I'm creating the APS for the
25:28 - users in order to create the users
25:32 - instance from the clerk from the next o
25:34 - from the kind or o zero in our own
25:37 - database as well by triggering some kind
25:39 - of apis all right I hope that you have
25:41 - got some point um now let's go ahead and
25:44 - create the post API in our project now
25:47 - so it is suggesting me whether I want to
25:49 - write this yes I want to write this and
25:53 - let me change the name of it to request
25:55 - and this is going to be of type request
25:58 - okay okay and inside it let's add the
26:01 - tri block and the catch block this is
26:04 - required in every case actually okay so
26:07 - now in the tri block first of all what
26:09 - we need to do in the post request we
26:12 - need to get the data of the user okay
26:14 - and the data of the users can be get
26:17 - from the body in our Postman if I show
26:20 - you over here post user and this is the
26:22 - body and from here I will be passing
26:25 - this email username and password data
26:27 - which is added in our model over here
26:30 - and the same data I will be passing from
26:32 - this Postman okay so in order to receive
26:36 - this data in our post request we can
26:39 - have const body equals to await and then
26:43 - the request do Json and this is going to
26:47 - get the data from the body and after
26:49 - that I'm going to Simply connect to the
26:50 - database so if the connection is already
26:53 - established I've already made a check uh
26:55 - over here that it was already connected
26:57 - so we you don't need to care about that
26:59 - it's going to take time to for the
27:01 - reconnection to the database so uh
27:03 - triggering this connect again in each
27:06 - request uh is not going to cause any
27:08 - problem in terms of performance okay so
27:11 - now we need to create an instance for
27:13 - the users the tab9 AI assistant
27:15 - extension is suggesting me few things so
27:18 - I think this is right but I'm going to
27:20 - explain it step by step to you guys so
27:23 - con new
27:25 - user equals to new user and this is
27:30 - going to take the body okay now I'm
27:33 - going to write
27:35 - await new user Dove okay now this is
27:39 - going to connect to the database
27:41 - creating an instance of the new user
27:43 - with the data we have passed from the
27:45 - client side and this is going to save it
27:47 - in the database and once it is going to
27:50 - gets saved I'm going to return a success
27:53 - response to the client currently our
27:55 - client is either a browser or uh any
27:58 - front end application it can be our
28:00 - current nextjs application as well but
28:02 - we are calling our client as a postman
28:05 - because whoever is calling the API is
28:08 - considered as a client okay so now new
28:12 - next
28:15 - response and uh this is going to give us
28:19 - json.
28:23 - stringify let's add
28:25 - message user is created created and
28:29 - after that let's pass the new user data
28:32 - which is created uh this is uh actually
28:36 - this is the user I I had to call it new
28:43 - user all right and let's add the status
28:47 - as well so over here status is going to
28:50 - be the 200 okay let's add some error
28:54 - handling in the catch block so it is
28:56 - suggesting me something let's click on
28:59 - the tab and uh this is going to return
29:01 - error in creating user along with the
29:04 - error message and status is going to be
29:07 - the 500 so it is fine so I'm going to
29:10 - save the file and I'm going to go in the
29:13 - postman and here I can actually right
29:18 - click add request and this is going to
29:20 - get generated you need to change the
29:22 - name of it select post from here and now
29:26 - I can add SL API slash users okay the
29:31 - same API is going to be responsible for
29:33 - the Post request and the only difference
29:36 - is this method which is the post okay
29:39 - default headers this is the body and uh
29:42 - let's go with the same email username
29:45 - and the password so let's click Send all
29:48 - right so it has returned message user is
29:50 - created along with the user data okay
29:53 - and in order to verify whether this user
29:55 - is created in the database or not I'm
29:57 - going to to go in this and I'm going to
30:00 - refresh this page so let's see if the
30:03 - user is visible in the database or not
30:05 - so it's loading yes so our data for this
30:07 - user is created along with this
30:09 - underscore ID this is the unique ID
30:11 - automatically gets created by the
30:13 - mongodb and email username and password
30:16 - and created at uh this is the time stamp
30:19 - uh because we added this time stamp
30:22 - equal to true in our model so it means
30:25 - that our post request for the user is
30:28 - working pretty fine I'm going to go
30:30 - ahead and I'm going to add uh API for
30:33 - the patch for updating the user let's
30:35 - say user is already added in the
30:37 - database and we want to modify its
30:40 - username or we can modify its uh
30:43 - password okay or any other details the
30:46 - phone number uh so I'm going to go and
30:48 - create a new patch
30:50 - request so this is going to be the
30:54 - export con patch equals to async and
31:00 - this is going to be the request of type
31:04 - request let's add an arrow function okay
31:07 - let's add the try and catch block first
31:10 - of all so we remember that uh we need
31:14 - to check for errors okay so inside the
31:18 - tri block what we need to do we need to
31:21 - get the user ID which we want to update
31:24 - and the new data with which we want to
31:27 - update that user so there are two things
31:29 - okay so I'm going to get the data which
31:32 - needs to be updated from the body just
31:35 - like I've got from
31:38 - here okay and also I'm going to get the
31:41 - user ID directly from the body as well
31:44 - although I can get the user ID from the
31:46 - perams from the URLs but I'm going to
31:48 - get the new user name and the user ID
31:52 - directly from the body so in the tri
31:54 - block I can get the body from the await
31:58 - request. Json Let's uh why it got here
32:02 - let's remove it okay so after that I'm
32:05 - going to get the user ID which I'm going
32:08 - to be passing as a body from my Postman
32:11 - from client and then you
32:14 - username okay so here I'm going to get
32:19 - it from the body so a wait connect again
32:22 - connect to the database before
32:23 - performing anything and I'm going to add
32:26 - some error handling there might be a
32:28 - chance that from the client whoever is
32:30 - building the front end might not pass
32:32 - the user ID they might not pass the
32:35 - username so we need to throw an error we
32:37 - cannot proceed if the um the user ID is
32:40 - not found U or user ID is invalid okay
32:44 - and in order to check the validation of
32:47 - this user ID that uh the that is
32:49 - automatically generated by the mongodb
32:52 - there is a way up so I'm going to go at
32:54 - the top and I can add con
32:58 - object ID equals to the uh
33:02 - require and this is going to be the from
33:07 -  dot types doob ID now I'm going to
33:12 - use this object ID to check whether the
33:14 - ID of the user which is being passed
33:16 - from the client is uh in correct format
33:19 - or not okay so let's come over here and
33:23 - uh now first of all I'm going to check
33:25 - if user ID or new user name does not
33:30 - exist okay if it does not exist then I'm
33:33 - going to throw an error uh return a
33:35 - response that invalid uh request I'm
33:38 - going to change the message so this is
33:41 - going to be the ID or new
33:44 - username uh not found any message that
33:47 - you want to add okay status is going to
33:50 - be 400 after this I'm going to check the
33:52 - validation of the ID so I'm going to add
33:56 - the types
34:00 - doob ID dot uh is valid and this is
34:07 - going to receive the user ID which we
34:09 - have received from the body So currently
34:12 - it is saying that types not found so we
34:14 - can add the types over here so this is
34:17 - going to be the types from
34:19 - mongos and now you can see that the
34:21 - error is gone and inside it if user ID
34:24 - is not valid we can actually return uh
34:28 - the similar kind of message as above so
34:31 - I'm simply going to copy this error
34:33 - message and invalid user ID so invalid
34:37 - user ID this is the message I have added
34:40 - so once both of these conditions get
34:43 - false it means that the user ID and
34:44 - username exists and the user ID is a
34:48 - valid user ID then I'm going to proceed
34:51 - and find the user that if user should be
34:54 - existing in the database because user
34:56 - there might be a chance user is not
34:57 - existing in the database so
35:00 - update user equals to await user and I'm
35:05 - going to first check find
35:09 - one and update so it's going to first
35:12 - find whether it exist in the database if
35:15 - it find that then it's going to update
35:17 - that with the following data so I'm
35:20 - going to give
35:23 - it these details okay so underscore I ID
35:28 - and this is going to first find with
35:30 - this ID I'm going to give it
35:33 - new object ID and then the user ID all
35:38 - right and after that I'm going to pass
35:40 - the new username and new equals to True
35:44 - okay and this means that uh whenever the
35:46 - new user gets updated it needs to return
35:49 - the updated user rather than the old
35:51 - user which was stored previously okay so
35:56 - once that is done
35:58 - I'm going to check whether the user got
36:00 - updated or not there might be a chance
36:03 - that it return some kind of error okay
36:06 - so if it returns some kind of error uh
36:09 - then I'm going to uh uh show some kind
36:14 - of message that there might be a chance
36:15 - user not found in the database so let's
36:19 - uh return user actually this is what tab
36:23 - 9 a assistant suggested so let me see
36:26 - return new next response message user is
36:29 - updated user updated status 200 that is
36:33 - fine but before that I'm also going to
36:36 - return new next response and this is
36:40 - going to be the Json let's change the
36:44 - status I'm going to change it to 400 and
36:48 - for the message I'm not going to return
36:50 - the user for the message I'm going to
36:54 - say user not found
36:58 - in the
37:03 - database okay and this is going to
37:06 - return if updated
37:11 - user have some kind of error and this
37:15 - variable is this one okay so now we are
37:18 - good to go with this API I'm going to go
37:21 - into the catch block and I'm going to
37:23 - return some kind of error message error
37:25 - in updating user error do message status
37:28 - is going to be the 500 okay so I've
37:33 - updated that let's save this file and uh
37:37 - let's go and verify what is the username
37:40 - so it is the you new user double2 I'm
37:42 - going to remove the double two and
37:44 - update that let's go into the
37:46 - postman create a new request change the
37:49 - name to update user select patch from
37:52 - here add the same URL because URL is not
37:55 - changing because URL depends upon the
37:58 - folder structure which we have added
38:00 - okay and uh then I'm going to click on
38:03 - the body and you can see that we need to
38:05 - pass user ID which we want to update and
38:09 - user ID needs to be existing in the
38:11 - database currently this is the user ID
38:13 - this at the end it is Fe So currently I
38:17 - don't have Fe so let's first verify if
38:19 - the user ID is correct or not I'm going
38:21 - to click on send so you can see that it
38:24 - has returned me a message that user not
38:26 - found in the database because this ID
38:28 - does not exist in the database this is
38:30 - what I have returned over here okay and
38:34 - these are the two things which we I'm
38:35 - getting from the body and let me copy
38:38 - this user
38:40 - ID and I'm going to paste this user ID
38:42 - over here okay and uh
38:47 - let's new user let's add it like new
38:51 - user only okay the ID is correct and
38:54 - this is the new user now it should be
38:56 - able to patch the username let's click
38:59 - on send and user is updated and uh it
39:02 - has returned this response and this is
39:03 - the response which is being returned
39:06 - from here user is updated let's verify
39:10 - it over here you can see new user
39:12 - double2 let's refresh and see if it gets
39:16 - updated or not so I've refreshed and uh
39:21 - yes so it is updated and username equals
39:23 - to the new user now finally for this
39:27 - part particular API I'm going to add a
39:29 - delete request so let's go down and
39:32 - create a delete API by the way I
39:35 - remember some people have some issues
39:37 - like uh they wanted to write something
39:40 - over here in the body but after
39:42 - selecting the body you need to go and
39:44 - select the raw and from this drop down
39:47 - you need to select the Json and after
39:48 - that you can add the Json object from
39:51 - here all right so let's come back over
39:53 - here and let's add the delete request so
39:56 - it is suggesting me this so I'm going to
39:57 - go with that the tabe 9 AIA assistant is
40:01 - an awesome extension of vs code and
40:03 - let's again add the try and the catch
40:06 - block just like we've been adding
40:09 - above like this okay so inside the try
40:13 - block so in this delete case uh earlier
40:16 - in the patch case I was fetching the
40:18 - user ID in the body let me show you how
40:20 - we can fetch the data as a param as a
40:23 - search param from the URL okay let me
40:26 - show you what you mean mean by that if I
40:27 - go to the delete you can see this is the
40:30 - user ID which I'm passing by adding the
40:33 - question mark user ID equals to the user
40:35 - ID and uh this is how I'm passing from
40:38 - here so let's come over here in order to
40:41 - get that I can use
40:44 - const let's add the search params equals
40:47 - to new
40:50 - URL and then the request. URL okay and
40:56 - let's add the cost user ID equals to the
40:58 - search param user ID so this is how we
41:01 - will receive the user ID from the URL so
41:04 - once we do that we need to validate if
41:07 - the user ID is valid or not actually
41:11 - user ID exists or not okay so we can do
41:16 - that let me copy this one the same thing
41:22 - okay so let's copy if and I'm going to
41:26 - paste this over here here let's remove
41:28 - the username we don't need that and now
41:30 - this is going to verify if user ID is
41:32 - actually being passed from that uh
41:34 - client or a postman to this API or not
41:37 - because without this user ID we won't be
41:39 - able to know which user we want to
41:42 - delete okay and after that we need to
41:44 - verify if user ID is valid or not so tab
41:48 - 9 AI assistant is suggesting Me by going
41:52 - through our patch request so this is
41:54 - what it is suggesting invalid user ID
41:57 - and and I think this is fine so types
41:59 - object is valid user ID so all of these
42:02 - error handlings are very essential to
42:04 - avoid any kind of uh problem in our
42:07 - backend so I'm going to go with this and
42:10 - after this if condition I'm going to
42:13 - connect with the
42:15 - database okay so once the connection is
42:19 - established I'm going to find and delete
42:22 - with the ID which is being received from
42:25 - that URL so I'm going to uh write
42:30 - cost deleted user equals to await
42:35 - user. find by
42:38 - ID and delete okay and inside 8 I'm
42:44 - going to pass new types doob ID and then
42:49 - the user ID so this is something which
42:51 - I've have done so now I need to check uh
42:54 - if there is no error because of this and
42:57 - and uh I'm going to return the response
43:00 - so I'm going to verify if there is no
43:05 - error uh if there is uh error in it then
43:08 - I'm going to user not found in the
43:10 - database all right so I have selected
43:13 - this I think this is fine and finally
43:17 - I'm going to return the response that
43:18 - user is deleted successfully and tab 9
43:21 - aist and is suggesting me this return
43:23 - new uh response string ify user is
43:26 - deleted and then uh returning the user
43:32 - here okay so let's select that I hope
43:36 - there won't be any error the tab 9 a
43:38 - assistant is not going to give you a
43:40 - correct result always so you need to be
43:42 - careful uh while selecting its code
43:45 - which it is recommending okay and uh
43:48 - inside this catch I'm going to uh return
43:52 - the response error in deleting
43:55 - user okay okay so this has been done
43:59 - let's go into the postman click uh
44:01 - create a new request select delete from
44:03 - here and always try to let's first cut
44:10 - this uh this one and now let's try to
44:13 - trigger that send now it is returning me
44:16 - a message ID or new username not found
44:19 - actually I need to change it ID not
44:22 - found
44:25 - only all right so this has to be the
44:28 - message yes and now let's try to add
44:31 - this one this is not correct user ID but
44:33 - let's try that user not found in the
44:36 - database with this ID so ID is incorrect
44:39 - let's try to get the user and let's copy
44:42 - the user ID from here which is the
44:44 - correct which exists in the database now
44:47 - I'm going to pass this particular ID and
44:50 - I'm going to click on send and user is
44:53 - deleted this is the user which got
44:55 - deleted this is fine and I'm going to
44:57 - first verify by triggering this get
44:59 - request whether it returns a response
45:01 - and it did not return a response so I'm
45:05 - going to uh refresh this and I'm going
45:08 - to verify whether uh it got empty or not
45:12 - so guys there is no result it means that
45:14 - user got deleted successfully from the
45:17 - database which is perfectly fine now we
45:21 - are done with this user API I'm going to
45:24 - create new models for the category first
45:26 - of all and I'm going to add a
45:27 - relationship so that uh user uh should
45:30 - be able to create a category and
45:32 - category should belong to one user so
45:35 - this is the relationship I'm going to be
45:37 - creating okay so let's close this route.
45:40 - TS and inside this models I'm going to
45:42 - create a new file and this is going to
45:44 - be the category. TS all right so inside
45:48 - this category. TS I'm going to be
45:51 - importing schema model models from
45:57 - go
46:00 - const category schema equals to new
46:06 - schema and inside it I'm going to write
46:09 - the title type string and this is going
46:13 - to be the required property and after
46:16 - this model I'm going to add the time
46:19 - stamps equals to true and uh let me come
46:22 - back to this part user after that so
46:27 - after this I'm going to add the category
46:30 - models. category so this is fine
46:34 - whatever suggested by tab 9 and I'm
46:37 - going to export default category okay
46:39 - now I'm going to add a relationship
46:41 - between category and the user so
46:44 - whenever new category gets created I
46:46 - want to store the reference of user that
46:49 - this user created this category okay so
46:53 - I will be passing the user ID and the
46:56 - title while creating a new category from
46:58 - the client or you can say a postman so
47:00 - in order to add a reference I can pass
47:03 - the type column and I can use the
47:06 - schema do types doob ID and I can pass
47:12 - the
47:13 - ref this is going to be the user okay so
47:17 - this is going to add the reference to
47:19 - the user model and the name of this user
47:22 - is refering to this model user Okay so I
47:27 - have created this model now let's close
47:29 - that and inside this API I have this Au
47:32 - and for these categories and the blogs
47:35 - let's say uh on the front end side user
47:37 - have to login first and then user goes
47:39 - to the dashboard and in the dashboard uh
47:42 - user sees all the list of the blogs and
47:45 - the categories so I'm going to organize
47:47 - my apis in a way and I'm going to call
47:50 - uh the after logged in page as a
47:53 - dashboard you can call it anything you
47:55 - want so inside the AP I'm going to
47:57 - create another folder and I'm going to
47:59 - name it again whenever I add parenthesis
48:02 - around the folder name this is not going
48:03 - to be a part of the API route structure
48:06 - so inside this dashboard uh I'm going to
48:10 - add a few routes uh for the categories
48:14 - and the category ID so inside this I'm
48:18 - going to add a new folder so let's
48:22 - add
48:24 - categories and inside the category I'm
48:27 - going to add the
48:29 - route. TS file okay so in this file I'm
48:34 - going to create uh two requests get and
48:37 - post for the patch I'm going to show you
48:39 - how we can create the dynamic API route
48:42 - uh to get the data from that URL for
48:45 - particular ID in order to delete or
48:48 - patch the category uh using an ID of the
48:51 - category okay so now at the top just
48:53 - like I imported uh all of these things
48:57 - at the top so I'm going to import these
49:00 - uh as well in this file as well so
49:05 - connect user uh and then the next
49:08 - response and then the types uh we need
49:13 - user and we need category as well so I'm
49:15 - going to import
49:17 - category and the reason we need user
49:20 - because we want to verify the user ID uh
49:23 - which is being passed uh while creating
49:25 - a new category okay so let's create
49:28 - export const get equals to async and
49:32 - then let's add the request of type uh
49:37 - request Arrow function and inside it
49:40 - just like earlier I'm going to add try
49:44 - catch
49:47 - block all right so inside the try I'm
49:50 - first going to get the user ID from the
49:53 - URL so let's add that so let's copy it
49:57 - from this delete request which we have
50:00 - added so these two lines I'm going to
50:03 - copy and I'm going to paste it over here
50:06 - so this is going to give me the user ID
50:08 - which is being passed from the URL so
50:11 - now I'm going to check if the user ID
50:13 - exists um and I can uh check the user ID
50:17 - is valid or not directly in the same
50:18 - condition as well so I can add the not
50:21 - user
50:23 - ID uh or
50:26 - types doob ID do is valid user ID so
50:33 - if both of these conditions gets true uh
50:38 - then I'm going to Simply return a
50:39 - response that uh invalid or missing user
50:44 - ID so I'm selecting this suggestion from
50:46 - tab 9 a assistant extension and I'm
50:49 - going to invalid or missing user ID and
50:53 - this is the message I have given to it
50:56 - okay so after after this if condition
50:58 - I'm going to connect to the database and
51:00 - I'm going to uh actually get that uh
51:07 - user uh which is being passed so I'm
51:10 - going to
51:11 - add
51:13 - con
51:14 - user equals to await user. find by
51:23 - ID and then user ID
51:29 - okay and so you might be thinking that
51:31 - why I am applying some queries for the
51:33 - user uh because I want category API or
51:38 - any kind of category to be seen by that
51:41 - user who created that category this API
51:44 - should not be called from by any user uh
51:48 - uh who and for those user who have not
51:50 - created this category so if this user ID
51:54 - is exists in the database then I'm going
51:57 - to uh fetch that uh category from the DB
52:01 - so if no
52:06 - user then I'm simply going to return a
52:09 - response so let's select that and this
52:13 - is going to be user not found in the
52:15 - database let's go with that and now I'm
52:18 - going to find the category with the user
52:21 - ID so uh let's go user C categories
52:27 - await category find and uh let's select
52:31 - that but rather than adding directly
52:33 - user ID I'm going to write new types do
52:37 - object ID and then the user
52:40 - ID okay I need to end it with the
52:43 - parenthesis so this is where I'm passing
52:46 - the user ID uh matching the user ID
52:49 - which is stored in the database against
52:52 - this category uh so user ID which is
52:54 - being passed from the client and user ID
52:57 - which is stored in the database so this
52:59 - is where I'm checking if both are
53:01 - matching then it means that uh the
53:03 - category is being fetched by that that
53:06 - user who created that okay so now
53:08 - stringify categories status 200 this is
53:12 - going to return us all those uh maybe
53:14 - categories yeah um all those categories
53:18 - okay so
53:20 - um
53:22 - now I'm going to show some error message
53:25 - error in Fetch
53:27 - categories all right so let's save this
53:30 - and let's go and uh create a new folder
53:34 - inside your collection and inside this
53:36 - folder I'm going to go into the this uh
53:39 - category get categories and we don't
53:42 - need to add anything in the body so here
53:44 - this is where I'm adding this uh API
53:46 - category user ID so let's try and see
53:49 - what happens so user not found in the
53:51 - database let me see if user exists in
53:53 - the database or not so there is no user
53:55 - exist let me me first um create a new
53:58 - user um by the previous details which we
54:01 - had so send and new user is created new
54:04 - user should be fetched and this is the
54:07 - ID of the user go to the get categories
54:10 - let's pass the correct user ID okay so
54:14 - now let's send and now user ID exists in
54:17 - the database but there are no categories
54:20 - now uh it means that we are uh getting
54:24 - the correct response now we need to
54:26 - create an API posts for creating a new
54:28 - category directly over here so in order
54:31 - to create a new category again we need
54:33 - to pass the user ID so I'm going to uh
54:36 - write export const post and inside it
54:40 - I'm simply going to add uh that let me
54:44 - copy it from the top so
54:47 - try and paste it like this okay error
54:54 - in Crea
54:59 - category okay so inside the tri block
55:02 - I'm simply going to copy these two lines
55:05 - because I will be getting the ID from
55:08 - that URL so let's add that and below
55:12 - this I'm also going to get the data for
55:16 - the category which is going to be uh the
55:19 - title of the category okay so this is
55:24 - going to be the cost
55:27 - title equals
55:29 - to await
55:32 - request uh
55:35 - dot
55:37 - Json okay so this is how I've got that
55:41 - and U now I need to check if the user ID
55:45 - exist and user ID is valid or not so I'm
55:48 - going to go up and I can use the same if
55:52 - condition so let's add that
55:57 - and below this if condition I'm going to
56:01 - write the connect up till now you might
56:03 - have understood uh the whole process
56:06 - which I'm following but there are new
56:07 - things coming up uh during this video so
56:09 - stay tuned and keep watching and now I'm
56:12 - going to write const
56:14 - user
56:16 - await user. find by ID so here I'm
56:19 - checking if the user ID exists in the
56:22 - database and if not then I'm going to to
56:26 - show some error message over here just
56:29 - like uh this tab 9 as is suggesting so
56:32 - if no user ID exist then user not found
56:36 - and after that I can create a new
56:38 - category so this is suggesting me uh new
56:40 - category along with the title plus the
56:43 - user ID which is being passed from the
56:44 - URL so I'm going to select that this is
56:47 - almost
56:49 - fine okay uh once that is done let's
56:53 - select that await new category. save
56:55 - this is going to to create a new
56:56 - category along with the user ID which is
56:59 - being passed from the client side when
57:00 - we build a front-end application we take
57:03 - care about uh all the U IDs and
57:05 - automatically we don't need to manually
57:07 - copy paste like I'm doing over here so
57:09 - this is just for elaboration purpose
57:11 - okay so this is the save and now I'm
57:14 - going to return a response that a user
57:17 - is uh successfully created so actually
57:21 - category is created okay so let's save
57:26 - this file let's go let's go to the Post
57:29 - category and I'm going to write the
57:31 - title and the user ID should be added
57:34 - from here but let's go with the wrong
57:36 - user ID let's click on send user not
57:39 - found yes and now let's copy the correct
57:41 - user which exist in the
57:43 - database so usually in front end
57:45 - application user ID is always correct
57:48 - with which we have logged in um so U
57:51 - this is automatically handled so now I'm
57:53 - going to paste the correct user ID let's
57:56 - send and now categories created with the
57:58 - title category one along with the user
58:01 - along with the category ID along with
58:04 - created ad and updated ad for this
58:06 - category now let's go and get the
58:09 - categories from that DB let's click on
58:12 - send and this is the one category which
58:14 - is stored in the database let's go and
58:17 - verify it from here let's refresh over
58:20 -  Atlas and it should create another
58:24 - model within the database and you can
58:26 - can see it has created this model
58:28 - categories and inside it it should have
58:31 - this category one title its own ID and
58:35 - the ID of the user which it belongs to
58:38 - the user who created this category and
58:41 - the created at an updated that uh for
58:43 - this particular category now I'm not
58:46 - going to create the patch or delete
58:48 - request directly in this particular file
58:50 - instead I'm going to create a dynamic
58:52 - route means I'm going to uh pass the ID
58:57 - of the category directly after slash not
59:00 - the question mark it won't be a cury
59:02 - param like this it will be a dynamic
59:05 - part of the URL but this value is going
59:07 - to be dynamic this is not going to be
59:09 - fixed okay so if I directly create a
59:13 - folder it will be a part of the URL then
59:15 - how can I create a folder with that is
59:18 - going to accept the dynamic value so the
59:21 - way we can add it is like within the
59:24 - categories we need to create a new
59:26 - folder and this has to be within the
59:28 - square brackets and I can name anything
59:32 - inside it okay now this is going to
59:35 - receive a dynamic value and this is
59:36 - going to be a part of URL and inside it
59:39 - I'm going to create the same file name
59:42 - route. TS and inside this file I'm going
59:45 - to create a patch and the delete request
59:47 - for the category so first of all let's
59:50 - import the required packages so I'm
59:52 - simply going to copy these things from
59:55 - the previous previous file and let's add
59:58 - it over here and now let's write export
60:03 - const
60:05 - patch equals to
60:09 - async
60:11 - request arrow and like this let me
60:14 - change it to request completely and
60:17 - inside it again as always it's always a
60:21 - good practice to write error blocks
60:26 - okay and error in fetching error in
60:31 - updating category okay so now in the try
60:36 - I'm going to get the body the data which
60:41 - needs to be updated so it is going to be
60:43 - the only title because uh the title is
60:46 - the only property exists in the category
60:50 - model okay even if there are more uh
60:52 - properties still we can decide how many
60:54 - properties we want to update
60:56 - now I can fetch the title from the body
61:00 - okay now for updating a new category we
61:03 - need to check that uh which category
61:06 - needs to be updated for that we need to
61:08 - receive the ID of the category and I'm
61:10 - not going to pass the ID of the category
61:12 - in the body and neither I'm going to
61:14 - pass it as a cury param as a search
61:17 - param and instead I'm going to receive
61:19 - it as a dynamic value from the URL okay
61:22 - so in order to do that next CHS give us
61:25 - a way so I can add the context column
61:29 - params any and using these params I can
61:33 - fetch that so category ID equals to
61:38 - context params do category so now I've
61:41 - got the category ID from the
61:44 - URL after that uh I simply uh so for
61:50 - updating there are three things the
61:52 - category ID the data I want to update
61:55 - and I need to get the idea of the user
61:59 - that who is actually trying to update
62:01 - that particular category okay so just
62:04 - like I got uh it in the previous patch I
62:09 - can receive the user ID from the uh
62:12 - search param from the URL like this uh
62:16 - update this is the dynamic value for the
62:19 - category and this is the user ID
62:21 - everything after question mark is become
62:24 - the search cury parm
62:26 - and if if it's not after the question
62:29 - mark then it becomes a value for the URL
62:32 - so here below it I need to validate a
62:35 - lot of things here first of all I need
62:37 - to validate the category ID if it exists
62:40 - and the category ID is valid then I need
62:43 - to verify if a user ID exists and it is
62:47 - valid so first of all it is suggesting
62:49 - me this so if user ID is not found and
62:52 - user ID is not valid then I'm simply
62:55 - going going to return a response that
62:57 - invalid or missing user ID just like
63:00 - I've been doing earlier and after that
63:04 - um I need to check if the category ID is
63:06 - valid or not so for that I'm simply
63:09 - going to add an if condition uh let me
63:12 - copy this if and I'm going to copy the
63:15 - category
63:16 - ID paste it over
63:20 - here and inside it I'm simply going to
63:23 - return a response that invalid or
63:26 - missing category after that let's
63:30 - connect to the database and now let's
63:32 - verify if the category with this ID
63:35 - exist in the database and uh user with
63:39 - this ID exist in the database both of
63:41 - these things are important so let's
63:44 - select this find user by ID if it exists
63:47 - in the database if it does not exist in
63:50 - the database I'm going to check and
63:52 - return a response that the user not
63:54 - found okay
63:56 - and after that uh if category um I'm I
64:01 - can check if category exists in the
64:03 - database category. find by ID uh and uh
64:09 - but not with this I'm going to write
64:12 - another condition so I can write the
64:17 - category a wait category dot find one so
64:22 - find one and inside it I'm going to pass
64:26 - underscore ID category ID because the ID
64:29 - of existing model its own model starts
64:32 - with underscore in the mongodb database
64:35 - and then the user
64:38 - ID okay so here I'm checking that the
64:42 - category which is stored in the database
64:45 - I'm checking this ID and I'm checking
64:47 - this user ID as well that the user ID
64:49 - which is being passed from the client
64:50 - the postman is matching with the ID of
64:53 - the category user value which is exist
64:57 - in the database so now I'm going to show
65:01 - the error message that if category does
65:04 - not exist with this user ID and the
65:08 - category ID then I'm simply going to
65:10 - return a response that the category not
65:14 - found
65:16 - okay so that is fine now next let's see
65:23 - what we have to do now we need to find
65:27 - by ID and then the update we can do that
65:30 - so uh we we already find that above but
65:33 - we can simply uh create that as well but
65:35 - it's always a good practice to keep on
65:38 - checking for error handling so updated
65:41 - category equals to uh a
65:46 - weight
65:48 - category dot find by ID and
65:54 - update okay and and inside
65:58 - it uh let's bring it down inside it I'm
66:02 - going to pass category ID title and new
66:05 - true which is fine this whatever it is
66:07 - recommending us so let's hit enter and
66:13 - now I'm going to Simply return a
66:15 - response category is updated with this
66:17 - category okay and uh for the error error
66:21 - is fine so let's save it let's verify
66:25 - that so this is the category now uh
66:29 - cancel and in this Postman this is the
66:33 - API which I'm going to test this has to
66:35 - be the category ID let me go and send it
66:38 - with the wrong things so user not found
66:40 - this is the first error showing so let's
66:42 - first uh give it a true user ID which is
66:45 - stored in its database so this is the
66:47 - user ID let's put it over here we can
66:51 - also update these query params by going
66:53 - to the params this is the user I'm going
66:56 - to update that okay so now let's send
66:59 - category not found it found user user
67:02 - because we are checking user first in
67:04 - our API that's why it return users first
67:07 - then the category not found with this ID
67:10 - so let's copy this ID and see that we
67:13 - have this name category
67:15 - one and uh let's put the category this
67:19 - is not a cury param that's why it is not
67:21 - showing over here this is a part of the
67:24 - URL okay uh we have updated that and in
67:27 - the body raw Json this is going to be
67:31 - the category one updated and now uh this
67:35 - has to be updated let's send and now
67:37 - category one is updated let's go and
67:41 - fetch all the
67:43 - categories and it has this name category
67:46 - one updated and if we check on the
67:49 - database this title should be updated
67:52 - I'm going to click on this refresh and
67:54 - it should be updated over here as well
67:57 - and yes it is updated which is perfectly
68:00 - working fine and uh let me quickly tell
68:03 - you that uh this name the params do
68:07 - category is referring to the folder name
68:09 - within the square brackets okay and this
68:12 - is uh the purpose of the name naming the
68:16 - Within These square brackets uh
68:18 - otherwise we will not be able to fetch
68:20 - the data from the URL uh but uh square
68:23 - brackets means it will be dynamic value
68:26 - the category text inside it is used to
68:29 - fetch the that Dynamic value using this
68:31 - context. par. category so we are done
68:35 - with this patch finally uh for this
68:37 - particular category I'm going to create
68:40 - a delete request as well for delete I'm
68:42 - also going to receive the param for from
68:45 - the context and request is over here so
68:49 - in this delete request I can actually
68:51 - copy and paste a lot of code blocks for
68:54 - the validations so here first of all I
68:57 - can copy this line that is going to give
68:59 - me the category
69:02 - ID and then I can actually uh within the
69:06 - tri block um I can actually uh we don't
69:11 - need to get the body because for delion
69:13 - we only need the ID okay so now I can
69:18 - copy
69:20 - this let's add it over here but within
69:23 - the tri block
69:26 - okay let's add the catch block quickly
69:29 - so error any and this is going to be the
69:33 - catch block error in deleting the
69:35 - category which is perfectly fine and uh
69:38 - below this we can copy these two
69:41 - validation Logic for the user ID and uh
69:46 - for uh the category ID if these are
69:49 - valid and these are uh existing and
69:52 - being passed from that client Okay so so
69:55 - let's paste that after it and after that
69:59 - I can connect to the
70:02 - database so we can actually uh check the
70:07 - ID if it exists in the database so we
70:09 - are checking if the user who created
70:11 - this category is actually deleting this
70:14 - category okay and this is the check we
70:16 - are performing here so now we can check
70:20 - uh before that we can check if the user
70:22 - ID exists in the database or not so if
70:25 - user ID does not exist in the database
70:28 - we are simply going to return a response
70:30 - that user not found okay and after that
70:33 - uh we can uh show if the category find
70:37 - one and it is going through all the file
70:39 - and it is suggesting us this things this
70:41 - is why I like tab 9 as assistant
70:44 - extension so let's select that uh find
70:46 - one category ID user ID so uh if we have
70:52 - the category exist in the database with
70:54 - this ID which is being passed and it has
70:57 - this user ID which is also matching the
70:59 - user ID which is being passed from our
71:02 - client the postman okay so after that we
71:05 - can verify if the category is not found
71:09 - uh then we can simply return a message
71:13 - uh this
71:15 - one
71:16 - okay so we can modify this message
71:19 - category not found or does not belong to
71:23 - the user okay okay who created that all
71:27 - right so now I can actually go ahead and
71:30 - delete this category if everything is
71:31 - going well uh then uh we can we can uh
71:36 - check if uh go ahead and check this if
71:39 - the if it's correctly deleted uh but I
71:43 - can actually directly
71:45 - write
71:47 - category do find by ID and delete and
71:52 - within this I can pass the category ID
71:55 - not the whole
71:58 - thing like this okay and uh we can
72:02 - receive it in our variable but um I
72:05 - don't think that is required uh because
72:09 - if there is any error over here it will
72:11 - be received over here yeah and now I can
72:16 - simply return a success response that
72:18 - category is deleted okay so let's go
72:22 - into the postman let's go into the
72:24 - delete
72:26 - category and uh this is the these are
72:28 - the wrong details which I've already
72:30 - added so user not found from the update
72:34 - params let's give the correct user ID
72:37 - delete category user ID let's select
72:40 - category not phone or does not belongs
72:42 - to user so let's get the category ID
72:46 - from
72:47 - here delete um and uh let's add it over
72:53 - here let's send
72:55 - and category is deleted let's try to
72:58 - fetch the category no category found and
73:01 - I'm going to quickly create the category
73:03 - because we have verified that let's send
73:05 - it and this is the category ID which we
73:09 - have
73:10 - got back and I'm quickly going to update
73:14 - that for later on purpose okay yeah so
73:18 - this is updated this one is updated and
73:21 - I'm going to close all of these four
73:24 - requests now okay so we are done with
73:28 - this category apis now we need to create
73:31 - a blogs API that is going to have a
73:33 - little bit more relationship uh blogs
73:36 - can belongs to a category as well as it
73:38 - will belongs to a user who created blog
73:41 - and later on we can filter out the blogs
73:44 - based upon the category as well while
73:46 - getting the blogs back uh on the client
73:48 - side okay so before writing the apis
73:52 - again we need to create a new file and
73:53 - I'm going to write
73:55 - log. TS okay and inside it just like
74:00 - with other models I can import and I can
74:04 - write schema model
74:08 - models
74:10 - from
74:11 - mongos okay let's add the con
74:16 - blog schema equals to
74:19 - new
74:22 - schema and here let's add title for the
74:25 - blog this is going to be the string
74:27 - required this is going to be the content
74:30 - rather than content I'm going to write
74:32 - the description this is going to be the
74:33 - type I'm not going to make it
74:36 - required and then this is going to have
74:39 - uh a relationship with the user schema.
74:41 - types and object and then this is going
74:44 - to have a relationship with the category
74:46 - okay so category type schema types and
74:51 - this is going to be the category name
74:53 - which is going to be coming from this
74:55 - one the category okay so let's try to
74:59 - add an object and here I can add the
75:02 - time stamps and after this let's add
75:06 - blog models. blog or model. blog schema
75:10 - which is fine and this is going to give
75:12 - me uh this
75:15 - export default
75:17 - blog so we are done with creating schema
75:20 - for the blog and Bas based upon these
75:23 - relationships uh we are going to
75:25 - modifying some ques because we have two
75:27 - relationships now for the blogs so let's
75:29 - close these files and here uh we have
75:33 - these categories I'm going to create a
75:35 - new folder within the dashboard okay so
75:38 - this is going to be the
75:41 - blogs all right so inside this blogs I'm
75:45 - going to create a route. TS file for get
75:49 - and post requests route. TS so let's
75:55 - import all of those uh required things
75:59 - uh which we've been importing in the
76:02 - previous files I'm simply going to
76:03 - adding those lines next response connect
76:06 - and this is the blog and users and the
76:09 - category so we will be needing these
76:12 - users and the categories uh for the
76:14 - validation purpose in this blogs API
76:17 - okay so now let's go ahead and write the
76:20 - get API request for this blogs so let's
76:23 - write export
76:25 - and the get I don't need this context in
76:29 - this case this is the arrow function
76:33 - starting off with try catch as
76:36 - always so like
76:40 - this okay so now I'm going to get uh the
76:45 - search parms first of
76:48 - all this is going to be from the URL so
76:53 - search
76:56 - params new url
77:00 - request. url okay and uh I'll also keep
77:05 - opening that route for this category and
77:10 - U let's actually for
77:14 - this and I need to get these two lines
77:18 - which I have been adding so this one for
77:22 - the user ID
77:25 - over
77:27 - here and then I need to have the
77:30 - category
77:31 - ID right and then I need to check if
77:35 - user ID exists and it is
77:38 - valid if it is not then I'm simply going
77:42 - to return a
77:46 - response
77:49 - return actually let's copy it from here
77:56 - user
77:57 - ID and let's paste it and just like this
78:00 - user ID I also need to check if the
78:02 - category ID is valid and is being added
78:06 - from the client so once these two
78:09 - condition are added I'm going to await
78:14 - connect to the
78:15 - database and uh let's find the user ID
78:20 - and then I'm going to check just like
78:22 - I've been doing previously if user ID is
78:26 - not existing in the database then I'm
78:29 - not going to let it to fetch the blogs
78:33 - because I only want the blogs to be
78:35 - fetched by the user who is uh who is
78:38 - existing and who have created those
78:41 - particular blogs okay so now I'm going
78:45 - to check if the uh category
78:49 - ID uh actually exist in the database or
78:53 - not so for that uh I've already checked
78:57 - if the category ID exists or not so I'm
79:00 - going to check if the category
79:03 - ID
79:05 - actually exist in the DB if not then I'm
79:09 - going to
79:11 - Simply return a
79:13 - response so category not found if the
79:16 - category is not found okay so after that
79:20 - um I need to fetch all the blogs based
79:24 - upon the user ID and the category ID but
79:27 - I'm not going to directly write find or
79:29 - find all later on I will be modifying
79:32 - this API to add the pagination add some
79:35 - sorting mechanism some search so from
79:38 - front end if user want to fetch the
79:40 - datab based upon the keywords search
79:42 - user want to sort the data based upon
79:44 - ascending descending or adding the
79:46 - pagination logic uh like which page and
79:49 - how many items user wants to fetch or uh
79:53 - the start date and date the range for
79:56 - the blocks based upon the time stamps
79:58 - which are stored for the blogs so for
80:00 - considering that I'm going to change the
80:03 - logic of fetching the data so filter of
80:06 - type any equals to and I'm going to
80:08 - write user uh new type user ID and
80:12 - category new type category
80:15 - ID okay uh there seems some kind of
80:18 - error so actually I don't need two
80:20 - things so now using this filter I can
80:24 - actually fetch all the blogs so await
80:26 - blog find filter uh all the blogs uh
80:30 - based upon this user and this category
80:33 - will be returned now I can simply return
80:37 - uh to the client that these are all the
80:40 - blogs with the status code
80:43 - 200 okay um so I think that is it later
80:49 - on I'll come back to this API when I
80:51 - need to add some filtering altering and
80:53 - all these uh options so let's go over
80:56 - here these are all the get blogs and
80:59 - here just ignore these rest of things
81:01 - I've just disabled that I've added user
81:03 - ID click on send so user not
81:07 - found let's go uh let's try to add all
81:10 - the users let's copy this user
81:13 - ID let's give the correct user ID send
81:18 - category not found let's get the
81:23 - categories category
81:25 - get blogs and uh this is the category ID
81:29 - which is automatically added in these
81:31 - URLs okay so and you can see that this
81:35 - is the API SL blogs this was the API SL
81:38 - categories so this is these are the
81:40 - things um I've added so if I add it here
81:44 - you can see that it is returning blogs
81:46 - with an empty array because there is no
81:48 - blog existing in the database yet but uh
81:51 - if it is returning the empty array it
81:53 - means that our API is is working fine um
81:57 - and here I'll come back to this so I'm
82:00 - simply going to add to-do over here uh
82:03 - which is going to help me search out
82:06 - that um I need to come back to this line
82:08 - of code to add some more logic so now
82:11 - let's quickly add uh the post requests
82:15 - okay in this route so
82:18 - con export const post and I don't need
82:24 - this Con context
82:26 - here I would need it uh in my patch or
82:30 - our delete request for that again I'll
82:32 - be creating the dynamic route for this
82:34 - API just like I did it for the category
82:37 - okay so now for the post I will need
82:40 - this URL and I would need those uh user
82:44 - ID and uh the category ID as well within
82:47 - the tri block
82:49 - so now and for posting I would also need
82:54 - uh the body the data which needs to be
82:57 - added in the database for the blog it
82:59 - can it can be the title and the
83:01 - description okay uh but let's put all of
83:05 - these things within the try catch block
83:08 - for error handling okay so let's add
83:13 - error
83:15 - any like this and inside this error in
83:18 - fetching blogs okay so after this I need
83:22 - to fetch the body equals to await
83:26 - request.
83:28 - Json and then I can fet the title and
83:31 - then the
83:34 - description okay from the body now I
83:38 - need to check if user ID exist just like
83:41 - above so let me copy all of these things
83:43 - so this these two things and this one as
83:47 - well actually I would need this one the
83:51 - user not
83:52 - found uh and and then I would need this
83:55 - one as
83:58 - well okay so let's copy all of these
84:03 - things from
84:07 - here and I'm going to come here and I'm
84:10 - going to paste it okay so all of these
84:14 - validations if user exists if category
84:17 - exists uh and category found in the
84:20 - database and category user found in the
84:22 - database so all of these error handlings
84:25 - are required because we want to create a
84:27 - blog against a category and against a
84:30 - user if any of these are missing then we
84:32 - won't be able to create a blog because
84:35 - uh blogs must have to be created by a
84:38 - user and blog must have a category this
84:40 - is the Restriction we are applying but
84:42 - it's up to you you can modify it um a
84:45 - Blog can have uh no category as well but
84:48 - uh I'm modifying it in a way that it
84:50 - must have a category
84:52 - Okay so now uh we need to create a blog
84:57 - and yeah so let's close it like this and
85:01 - inside it I'm going to add the title I'm
85:05 - going to add the
85:08 - description I'm going to pass the user
85:10 - ID and the category ID which is passed
85:13 - from uh the URL from the client okay and
85:18 - once we have created a new instance for
85:20 - the blog I'm going to write await new
85:23 - blog
85:25 - save and after that I can add blog is
85:29 - created blog and then the new blog okay
85:33 - so our API is completed I hope it's
85:37 - going to
85:38 - work let's come here let's go and post a
85:42 - blog so first blog first blog
85:46 - description Let's see we have in this
85:48 - param we have the user ID and these user
85:51 - IDs are old I know that it's going to
85:54 - give me the error so user not found this
85:56 - is what I expected so in the get blogs
85:59 - let's copy the user ID from here post it
86:03 - over here and let's copy the category ID
86:06 - from here so both of these IDs for the
86:08 - category and user are existing in the
86:10 - database which I know okay so now so
86:14 - let's send now the blog is created with
86:18 - this title and the description along
86:20 - with this relationship with the user and
86:23 - the category and we can verify it over
86:25 - here by refreshing it and it is going to
86:28 - actually uh add the blogs model over
86:32 - here in the database as well and it has
86:34 - this title description its own ID and
86:38 - the ID of user which it who created this
86:41 - blog and the category which it belongs
86:43 - to okay and the created ad and the
86:45 - updated ad for this blog and these are
86:47 - going to help us sorting um and based on
86:51 - ascending or descending or based upon
86:54 - the range okay so we are done with this
87:00 - blogs uh one and I'm going to create the
87:02 - dynamic folder now just like I did it
87:05 - for the uh category so I'm going to
87:08 - create a blog within the square bracket
87:11 - and I'm going to create route. TS file
87:14 - so inside it I'm going to import
87:17 - everything which be I've been doing uh
87:19 - in this file so let's copy it let's
87:23 - paste it
87:24 - okay so now let's create a get request
87:28 - so in this particular uh route. file uh
87:33 - so on the front end application there
87:35 - can be a page for getting the data for a
87:37 - single blog okay and uh the blog ID can
87:41 - be existing as a dynamic uh param a
87:44 - dynamic value in the URL so that's why
87:47 - I'm creating the get single blog API in
87:51 - this particular Dynamic route. TS file
87:54 - for again for getting a single blog we
87:57 - need to check if user ID exists category
88:00 - exists uh and also the blog ID exist
88:03 - which will be fetched from the uh URL
88:06 - okay and then if all of these conditions
88:08 - are validated then based upon the user
88:10 - ID category ID I'm going to return the
88:13 - blog so export const get and then the
88:17 - context and yes I would need the context
88:19 - because this is the dynamic route so
88:22 - params callon and
88:25 - any okay and the arrow function and now
88:29 - con blog ID equals to the
88:33 - context. params do blog okay so let's
88:38 - add the tri block so let's add the tri
88:42 - block and also the catch block for the
88:46 - error and uh let's give it type any
88:52 - [Music]
88:55 - and this is going to return us the error
88:58 - fetching a Blog this is going to be a
89:01 - single blog okay so inside this try I'm
89:05 - going to get the search parms let me go
89:09 - over here and fetch everything yes so
89:12 - request. URL I'm need user ID and the
89:14 - category ID from that
89:17 - URL let's put it over here and after
89:20 - that I need to validate the category ID
89:23 - and the user
89:24 - ID let's copy it from
89:28 - there and I would also need the blog ID
89:32 - verification that this is being passed
89:35 - from the client side or not
89:37 - okay so let's copy this let's add so
89:42 - let's add the blog ID blog ID and then
89:47 - the blog ID over here as well okay and
89:51 - after that as always let's write connect
89:56 - and then um I need to check if user
90:00 - exists in the database and category
90:02 - exist in the database or not so again I
90:05 - can go
90:06 - over there and I can copy these two
90:11 - blocks of
90:15 - code all right so this is going to check
90:19 - the existence of user ID and the
90:21 - category ID in the database now I'm
90:24 - going to return a single blog so let's
90:28 - write con blog equals to A weit Blog
90:33 - this is going to be the model and Dot
90:37 - find
90:38 - one okay and this is going to take the
90:42 - blog ID equals to this underscore ID
90:45 - user user ID um and like this let's
90:48 - remove the couple of things category and
90:51 - then the category actually we don't need
90:54 - directly like this I can remove it all
90:57 - right so once we fetch that uh we can
91:02 - actually check if there is blog exist in
91:06 - the database with this ID or not so I
91:08 - can simply write if no blog exist then I
91:12 - can simply return a response that blog
91:15 - not found okay and uh once if there is
91:19 - no error then I can simply return one
91:23 - blog
91:25 - okay so I'm done with this API let's go
91:29 - over here let's go into get single blog
91:32 - and uh let's copy the user
91:36 - ID over
91:39 - here and let's copy the category ID I
91:42 - know with these uh user ID and the
91:45 - category ID I created that blog okay and
91:49 - uh this has to be the blog ID currently
91:52 - I don't think this is correct but let's
91:54 - try that out so let's
91:57 - send and blog not found actually user
91:59 - was found category was found but the
92:02 - blog was not found okay so
92:07 - here uh let's get all the blogs and yes
92:11 - these are the blogs let's copy the ID of
92:14 - this blog So currently it is returning
92:16 - the array of all the blogs but from here
92:19 - I'm only returning uh one block okay so
92:22 - here let's add add it as a dynamic URL
92:25 - the ID of the blog which exists in the
92:28 - in the database so on the front end side
92:31 - we have the list of all the blogs which
92:32 - we have already fetched from here by
92:35 - calling this API and whenever from front
92:37 - and side we will be navigating to the
92:39 - particular blog detail page we should
92:41 - have the URL U containing that blog ID
92:45 - or maybe in the local storage or maybe
92:47 - in the local state management system and
92:50 - for that we can fetch the current blog
92:52 - ID and pass it to to this API okay uh
92:56 - and then let's send and now you can see
92:59 - that this is the single blog which is
93:01 - returned from the database so our single
93:06 - fetch API get API for fetching a single
93:09 - blog is working fine now in this file
93:12 - just like I created the uh patch and
93:15 - delete requests I need to create that
93:19 - over here so let's quickly create the
93:21 - patch request first of all so I'm going
93:24 - to first of all copy this first
93:30 - line all right so rather than get I'm
93:34 - going to add the
93:36 - posts
93:38 - okay so inside the post uh just like
93:43 - above I can actually copy this catch
93:47 - block let's try
93:51 - that paste it over here so
93:57 - error creating uh actually not the post
94:01 - this is the
94:03 - patch okay error
94:06 - updating
94:08 - blog okay so inside this just like I've
94:12 - got the blog ID from here I can add it
94:15 - over here and inside the tri block uh I
94:20 - need to get uh the title and description
94:22 - the updated title and description which
94:24 - I want to be updated uh so I can click
94:29 - on the
94:30 - try and uh we can get the user
94:37 - ID from
94:39 - here and let's put that in and before
94:44 - that I need uh to have the search param
94:48 - okay search param and the title and the
94:52 - description from the body okay in this
94:55 - case for updating the blog we don't need
94:57 - the category it's just that the uh the
95:01 - user have permission to update the blog
95:04 - okay so after that uh we need to check
95:07 - if the uh blog ID exists or
95:12 - not uh which is being passed from the
95:14 - client side then we are simply going to
95:16 - return a message invalid or uh Missing
95:21 - user ID and also for just like this we
95:24 - can add a check for the blog ID as well
95:27 - we don't have the category here so we
95:29 - don't need that so just like this we can
95:32 - add the blog ID condition
95:35 - here okay so this has been added now
95:39 - let's write the
95:41 - await and after await we can add the
95:45 - check for the users and the blog just
95:47 - like above so let's copy these two
95:52 - things I'm going to modify the category
95:54 - block with the with the blog and uh this
95:59 - has to be the
96:04 - blog so
96:07 - blog dot find
96:12 - one and this is going to be the
96:16 - underscore ID blog ID and the user is
96:21 - going to be the
96:25 - user
96:27 - ID and I'm going to add the blog so blog
96:31 - not found this is the error message I
96:33 - will be returning to the
96:36 - client all right so after that we need
96:41 - to actually update it so we first need
96:43 - to uh check if uh with the ID and then
96:48 - we can actually check it updated
96:51 - blog await and then blog do find
96:57 - by ID and
97:00 - update and then inside it uh I can pass
97:04 - blog ID title description and then the
97:07 - new
97:09 - true okay once that is done and now we
97:13 - are simply going to return a success
97:16 - response with a Blog updated like this
97:21 - okay so let's save the file let's go to
97:24 - the updated blog let's go to the params
97:28 - we need to pass the user ID the correct
97:30 - user ID so I'm going to copy the correct
97:33 - user ID which is existing in the
97:34 - database from here user
97:37 - ID it is added over here automatically
97:40 - and we need to pass the correct ID for
97:44 - the blog which we want to
97:49 - update all right so this has been
97:52 - updated now let's let's go to the
97:55 - body blog one updated blog one
97:57 - description updated and if I go over
98:00 - here you can see that first blog first
98:02 - blog description I want to modify it so
98:05 - let's click on the send and now it has
98:08 - returned me blog updated let's see if it
98:10 - is updated in the database let's refresh
98:13 - and the title and description of it
98:16 - should be updated and yes you can see
98:18 - that the title and description have this
98:20 - updated keyword at the end all right so
98:24 - quickly I'm going to add a delete
98:27 - request and for delete request we need
98:30 - the same kind of stuff uh the
98:32 - validations and all of these things so
98:35 - I'm simply going to be adding it one by
98:38 - one I don't want to waste your time so
98:40 - this is the
98:41 - line which I've added and now inside it
98:45 - I'm going to add uh this
98:48 - one params blog and here inside the try
98:53 - catch let me add the tri
98:56 - block and also the catch
99:01 - [Music]
99:04 - block and it is going to return error in
99:07 - deleting the blog and inside the triy
99:09 - block we can get the search param from
99:12 - the URL like this and after that we can
99:17 - actually uh check if user ID or the blog
99:21 - ID exists uh which is coming from the
99:24 - client exist in the URL or in the body
99:28 - okay uh in this uh you both are in the
99:31 - URL actually all right so after that
99:34 - let's again do the
99:37 - connection and let's again to uh check
99:41 - for the user and then the blog just like
99:44 - we have done above so let's go over here
99:47 - let's copy these two blocks of
99:51 - code let's go down
99:53 - after disconnect I'm going to paste
99:56 - these two
99:58 - things and once that is done I can
100:00 - simply uh run this command await blog
100:04 - find by ID and then the
100:06 - delete okay and then I can actually
100:10 - return a response that the blog is
100:13 - deleted successfully with the 200 status
100:17 - code all right so that is done let's go
100:20 - over here let's click on the delete we
100:23 - need to pass the current blog ID over
100:25 - here the correct
100:28 - one the blogs blog
100:32 - ID this
100:34 - one and the user ID user ID exists here
100:40 - so I'm simply going to add the user ID
100:43 - over here and let's try to send this out
100:46 - so blog is deleted let's verify it from
100:49 - the
100:50 - database okay so no results so blog is
100:53 - successfully deleted okay uh So
100:56 - currently there is no blog found I'm
100:58 - going quickly going to add a new blog
101:00 - over here because I'm going to modify
101:04 - this
101:05 - particular get blogs API uh with
101:09 - different kinds of conditions different
101:11 - kinds of
101:13 - logical uh things like filtering
101:15 - pagination sorting and all of these
101:17 - things so I've opened up this main
101:20 - route. TS file because uh the multiple
101:23 - blogs will be fetched on the main
101:26 - homepage where you want to see all the
101:28 - blogs list okay so this API is returning
101:32 - multiple blocks because we are fetching
101:35 - it using the find okay uh so this is
101:39 - where all the filtering all the
101:41 - searching and all the pagination is
101:43 - going to work so that's why I've chosen
101:45 - this particular API to perform all of
101:47 - these operations so let's go ahead and
101:50 - per and show you that how we can add all
101:52 - of the these things so first of all I'm
101:55 - going to add let's say search
101:58 - functionality or a search keyword all
102:01 - right so let's say on the UI you have a
102:04 - search bar and when you write something
102:05 - on the search bar you want to fetch all
102:08 - those blogs uh which have that keyword
102:13 - uh exist anywhere in the title of any
102:16 - blog if there are five blogs then if
102:19 - title matches in two blogs only two
102:21 - blogs should be returned so let's first
102:24 - fetch it from the client side from the
102:27 - postman just like we are getting it uh
102:30 - the category ID and the user ID so I'm
102:33 - going to write keyword actually Search
102:38 - keywords for the variable equals to
102:42 - search param and the value which is
102:45 - going to be passed uh the key is going
102:47 - to be the keywords from the client side
102:50 - and also for error handling uh for any
102:54 - kind of types scripting we can also add
102:55 - as string for this keyword because the
102:58 - keyword is going to be of typ string
103:01 - from the client the postman okay so once
103:05 - we are receiving this search keyword uh
103:08 - we added this filter object over here
103:11 - which we can keep on modifying before
103:13 - finding the blog okay so for modifying
103:16 - the filters let's first verify if search
103:19 - keyword actually exists okay and and
103:23 - then if filter Dot and mongus actually
103:27 - provide a lot of buil-in functions for
103:30 - aggregation for checking and or uh and
103:33 - all of these things so I want to check
103:36 - this keyword in the title and then in
103:38 - the description as well okay so in order
103:41 - to do that I can write this dollar sign
103:45 - or uh actually it should be an
103:49 - array okay and then there has to be this
103:52 - object so so title this is going to be
103:56 - receiving the
104:00 - Rex and then the Search keywords and
104:03 - after that I need to pass the
104:06 - options and this is going to be
104:11 - I okay and then we need to have it for
104:15 - the
104:17 - [Music]
104:20 - description colum and then the reject
104:23 - and then this option I so this or means
104:26 - that the search keyword should exist
104:28 - either in title or in description and uh
104:32 - this is how it is uh checking it and
104:35 - option I means that it is case sensitive
104:37 - irrespective of case whether it found it
104:40 - in the lower case or the upper case it
104:42 - should still return us the response okay
104:45 - so now that's it we need to add for the
104:47 - search keyword in the title and the
104:49 - description for the blogs I'm going to
104:51 - go over here and these are all the get
104:53 - blocks I'm going to enable this keyword
104:56 - okay now it should be added in the URL
104:58 - you know the keywords and then the first
105:01 - all right so now let's try to get that
105:04 - and now error fetching blocks cannot use
105:07 - reix with string so there seems some
105:10 - kind of error if string filter or array
105:16 - and then the title actually Rex it has
105:18 - to be the Rex not Rex okay
105:23 - let's save it and let's send and now you
105:26 - can see that it has returned us this
105:28 - first block because the first keyword
105:31 - was existing in both title and the
105:34 - description so or means that either in
105:36 - both or in one okay if I try to change
105:39 - it something like AB c d in the keywords
105:42 - now this keyword is not found in both in
105:44 - first and the uh title and the
105:47 - description so let's send this out and
105:50 - you can see that blogs are empty because
105:52 - this key word does not exist so on the
105:54 - front end this is how we can perform the
105:56 - search operation and get the data from
105:59 - that API okay you can create a new blogs
106:02 - and you can test that out in fact let's
106:04 - go over here and let's add the second
106:07 - blog and the second blog description
106:11 - let's send that out and let's get all
106:14 - the
106:15 - blogs uh ABC is not found anywhere uh so
106:20 - let's add the second let's send and the
106:23 - second is found which is newly created
106:26 - which we have just done it okay so now
106:29 - let's move further and here let's get
106:33 - more values we are going to get uh this
106:37 - thing let's remove it it's not always
106:40 - required so now search params doget
106:44 - start
106:46 - date and then start
106:49 - date and then con and date
106:54 - date and then end date okay so now if we
106:59 - have a calendar on the front end and we
107:02 - want to find all the blogs based upon
107:05 - the uh start date uh or end date or a
107:09 - range between start date and end date
107:12 - like return me a Blog which was created
107:14 - between 2023 and 2024 or uh give me all
107:19 - the blogs before uh 202 22 okay or any
107:24 - date or even we can pass the month day
107:27 - and the year as well okay so if we pass
107:31 - one it is going to be a starting value
107:33 - and it's going to return all the blogs
107:34 - starting this value up to the end date
107:37 - okay uh up to the date which is current
107:39 - date today okay so now let's go over
107:42 - here and we can modify this filter just
107:45 - like we have done
107:46 - it and for modifying this let's first
107:49 - verify
107:50 - if start date and end date both exist it
107:56 - means we need to check the range uh we
107:59 - need to return the blocks between this
108:01 - so we can have filter do created
108:08 - at and then this and then mongus provide
108:13 - GTE so let's let's select the tab 9 a
108:16 - assist g means that greater than equals
108:19 - to LTE means that less than equals to so
108:22 - start date so return all the blogs U
108:26 - which are greater than and equal to the
108:28 - start date and less than and equals to
108:32 - the end date all right and I'm going to
108:35 - write else if if start date
108:43 - exists then what happens okay and end it
108:46 - does not exist we don't need to check if
108:48 - end it does not exist because if both
108:50 - exist it will be triggered okay
108:52 - otherwise
108:53 - uh this would not be triggered uh so now
108:56 - I can write greater than equals to only
109:00 - return all the blogs which are greater
109:01 - than equals to up to the current date
109:04 - today okay of the recent date now lse
109:10 - if if end date exists only then we are
109:14 - going to filter with lower than less
109:17 - than equals to the end date now this
109:20 - will automatically be appending and we
109:21 - don't need to modify ify this we just
109:23 - are modifying this filter okay let's
109:26 - remove this
109:27 - to-do and now uh let's enable this end
109:32 - date now so end date means that uh
109:35 - before this date all the blogs should be
109:38 - returned I'm going to remove this
109:39 - keyword let's remove this
109:42 - keyword let's send so you can see that
109:45 - the two blogs are returned uh because uh
109:49 - all these blogs were created before this
109:51 - date this is why I've added this end
109:53 - date all right and if I write change the
109:57 - year let's say 2022 I hope that it's
109:59 - going to return empty array because
110:01 - before this dat there was no blog
110:03 - created so let's hit send yes so there
110:05 - was no blog so let's uh for
110:08 - our testing purpose let's add
110:12 - 2025 all right so now this is how it is
110:15 - returning the response what's next uh I
110:19 - want to let's say that you can also pass
110:21 - a sending a sending keyword uh from the
110:25 - URL from the client side uh which you
110:28 - can test yourself but in order to append
110:30 - this filter let me quickly show you how
110:32 - you can uh update that uh this is one
110:35 - small assignment if you are practicing
110:37 - with me during this tutorial uh you can
110:41 - also add uh dot sort and then I can
110:46 - write the
110:47 - created at colon and here I can pass as
110:55 - c not to sorted but
110:59 - sort
111:00 - okay um what happened here actually I
111:04 - need to remove
111:09 - this and you can fetch this value from
111:13 - the search param and put it over here
111:15 - whether it is DSC or ASC and based upon
111:18 - this we can sort this data out okay uh
111:23 - this is something you can do and try
111:25 - yourself now I'm going to add the
111:27 - pagination so how pagination works we
111:29 - have multiple pages one page page two
111:32 - page three and then we have the limit
111:34 - that how many items needs to be visible
111:36 - on a particular page so uh we need to
111:40 - find a formula so first of all I can
111:42 - receive couple of things from the client
111:45 - so I can write the page equals to the
111:48 - search param and then the
111:50 - page um if there is no page returned
111:55 - from the client side then I'm going to
111:58 - set the by default page as one and then
112:01 - the limit has to be 10 okay limit means
112:04 - how many blogs needs to be
112:06 - visible now let's save this file and
112:11 - here let's go
112:14 - down before actually triggering this I'm
112:17 - going to uh actually create a formula
112:22 - for the the skip skip is a built-in
112:25 - function provided by mongus that's why
112:27 - we need to calculate that so skip means
112:30 - that on a particular page how many blogs
112:33 - needs to be skipped so let's say there
112:35 - are 10 blogs on the first page on the
112:38 - second blog the blog will be visible
112:41 - from 11 to 20 on the third page the blog
112:45 - will be visible from 21 to 30 and
112:48 - similar on 11th page blogs number will
112:51 - be visible from 1 to 110 okay so the
112:55 - formula is Page minus one multi by
113:02 - limit okay so it is giving some kind of
113:07 - error so let's see uh right hand
113:09 - architecture must be of type any so for
113:14 - that I'm going to go up so this is
113:17 - giving us a string so I can actually
113:20 - write par and and wrap it
113:26 - around like
113:29 - this okay so it seems it is giving some
113:35 - kind of error let's go
113:39 - down okay so there is no error uh but
113:43 - let me hover over it argument of type
113:45 - string now is is not assignable to it so
113:48 - I can add any to it and any to it and
113:54 - then we have this search ps.
113:57 - getet page
113:59 - actually I'm going to add it like
114:03 - this and remove it from there okay so
114:07 - now the error is gone and we are not
114:11 - getting any error over here so if page
114:13 - is two then 2 - 1 = to 1 then 1 * 10 =
114:20 - to 10 okay so skip means that uh skip
114:25 - first 10 blocks and start fetching the
114:28 - blocks after this skip value means after
114:31 - 10 so for page two the blocks from 11
114:35 - will be returned so if page is let's say
114:37 - three then 3 - 1 2 2 * by limit which is
114:41 - 10 10 * 2 = to 20 and the skip first 20
114:46 - blogs and start returning the blogs from
114:50 - 21 so the 21 1 to 30 blogs will be
114:54 - returned for page number three so this
114:55 - is the formula now how to apply it over
114:58 - here so now I can write a page and the
115:02 - limit property over here uh actually the
115:06 - limit and the skip okay so first of all
115:09 - skip has to be Skip and then the limit
115:11 - has to be the limit okay so this is
115:15 - automatically going to work I don't have
115:18 - so many blogs so I cannot test that uh I
115:21 - don't want to waste your time so if you
115:23 - have a lot of blogs you have created
115:25 - that you can test that out but if I pass
115:27 - page one limit one if I don't pass it
115:30 - still it is going to take the default
115:32 - values the one and the 10 okay but if I
115:34 - want to modify this I can modify it from
115:37 - the front end U like his like this okay
115:41 - so let's send okay it is going to return
115:43 - the same response because I'm at the
115:45 - page one and the 10 if I change it to
115:48 - page two it should return empty array
115:50 - because on page two the block number
115:52 - from 11 to 20 should be returned so we
115:55 - don't have that much blogs so let's test
115:57 - that out and yes on page two there are
116:00 - no blogs uh that's why it has returned
116:03 - empty array so let's skip it one so
116:06 - let's send this out all right so there
116:09 - are more filtering options provided by
116:11 -  you can check out the
116:13 - documentation of and if you want
116:15 - to learn more about the filtering
116:17 - options and all of these things uh then
116:21 - yeah you can go to the docs and uh on my
116:24 - personal Channel I've created a long
116:25 - tutorials on node Express mongodb where
116:27 - I've talked about all the aggregations
116:29 - as well for filtering the data out from
116:32 - the database using mongus Okay so let's
116:35 - save it now next thing we are done with
116:38 - uh all of these apis now I want to talk
116:41 - about middle Wares how we can protect
116:43 - over back end how we can add the middle
116:45 - Wares for logging for intermediate error
116:48 - handling for our apis so let's talk
116:51 - about that we don't need to do anything
116:53 - in these files next thing I'm going to
116:55 - create a new folders but before that
116:58 - let's create a file which is recommended
117:01 - by which is given by next yes we cannot
117:03 - change its name and middleware file runs
117:06 - before every request on the front and
117:08 - side before every route on the back end
117:10 - before every API requests okay so this
117:13 - is something we can utilize to uh add
117:17 - further middle Wares in order for
117:19 - logging error error handling um or other
117:23 - uh API protection rules so I can start
117:25 - off writing by importing this next
117:29 - response from next server and uh after
117:34 - that I can
117:35 - export con
117:38 - config equals to and I can add the
117:42 - matcher that uh it should match and
117:46 - trigger in all the files exist
117:50 - inside the this API folder okay and uh
117:55 - after that I can write export default
118:00 - function
118:02 - middleware
118:04 - request
118:08 - request okay and inside it I can simply
118:11 - return next
118:14 - response do next for now okay and if I
118:18 - go ahead and try this out get users
118:22 - and it's still working and that is fine
118:24 - because I've not added any checks inside
118:27 - it so before that let's go ahead and
118:30 - create a new folder over here and that
118:32 - is going to be the middle Wares actually
118:36 - this is the file I have to create middle
118:41 - Wares uh this has been created I'm going
118:44 - to delete that and now let's create a
118:47 - folder middle bears and inside it I'm
118:51 - going to to create another folder API
118:53 - this is just for organizational purpose
118:55 - because I want to separate out the
118:57 - middleware Logics for the apis and if
119:01 - later on I need to add front end I can
119:04 - add a client folder inside middleware
119:06 - folder so now inside the API I'm going
119:08 - to create Au middleware and I can name
119:12 - anything o
119:14 - middleware
119:17 - dots okay so o middleware is going to be
119:21 - checking that if the beerer token from
119:23 - the client side from the postman is
119:26 - passed or not if it is not passed then
119:29 - I'm going to throw an unauthorized error
119:31 - for all of these apis and I'm going to
119:33 - show you the different checks that we
119:35 - can have like the for users I can keep
119:38 - it public and for categories and the
119:40 - blogs I can keep it protected until and
119:43 - unless the beerer token is not passed
119:45 - there are a lot of token types like if I
119:48 - go to this uh drop- down O type and you
119:51 - can see that this is the be token basic
119:53 - o JWT o o uh in nextjs usually when we
119:57 - use the third party services like the
120:00 - next o aujs or the clerk authentication
120:03 - kind authentication Au zero uh they
120:06 - provide session ID client ID and using
120:09 - that we can process our middleware to
120:12 - protect our apis as well as frontend
120:15 - routes in every my video of clerk
120:18 - authentication o zero kind O next o
120:21 - which I've have created on my personal
120:22 - Channel I have shown that how we can
120:25 - protect our API routes uh using their
120:29 - provided method using the cler provided
120:31 - method next or provided method and other
120:35 - services provided method so but this
120:37 - video here in this function I'm going to
120:41 - have a simple logic that in case you are
120:44 - not using third party Services still you
120:46 - want to protect your routes based upon
120:49 - the beerer token or any other token TP
120:52 - type or simple Boolean value you can do
120:54 - that how you can do that in the
120:56 - middleware file so this is uh what I
121:00 - want to add here so now uh let's first
121:03 - of all add cost this is not a real beer
121:07 - token I'm not creating any uh login sign
121:10 - up pages on the front end or the client
121:12 - side but this is going to be I'm I'm
121:14 - mimicking the behavior of the real be
121:17 - token if it exists real or false you can
121:21 - check that out out uh uh then we need to
121:24 - protect our routes if it does not exist
121:27 - uh we are going to uh U not allowed user
121:31 - to access these API so now let's say
121:34 - let's create this utility function first
121:36 - of all so this is the token any Arrow
121:40 - function and inside it let's give it
121:44 - valid token you can validate it based
121:48 - upon your own rules which you are using
121:50 - you can use JWT verification encrypt
121:52 - bcrypt whatever you want and I'm just
121:55 - checking that it is already valid but it
121:57 - should exist actually coming from the
121:59 - client side now I can check if uh not
122:04 - valid token
122:06 - or token does not exist then I'm simply
122:09 - going to return false if uh it is not
122:13 - validated or the token does not exists
122:17 - then I'm simply going to return false
122:19 - otherwise return true okay
122:22 - so now I have this function
122:27 - Au
122:28 - middleware request and then the
122:32 - response let's use only
122:35 - request a return type any and here I can
122:39 - write token equals to request. headers
122:45 - doget and from the client side whenever
122:47 - we pass these kinds of beer token let's
122:51 - say I can add over here this property
122:53 - will be added over here authorization
122:55 - beerer like
122:57 - this okay uh so from the client side we
123:00 - use exos or fetch and in the headers on
123:03 - the client side we can actually pass
123:05 - these values So currently let's remove
123:08 - it and now I can get the beer token from
123:13 - the authorization property and uh this
123:17 - is going to be the beerer and then space
123:19 - then actual token so I can split that
123:22 - out so
123:24 - split with an empty space and the second
123:27 - value from that splitted array okay and
123:31 - then I'm going to return is valid colum
123:37 - validate
123:39 - token uh this is going to be the
123:42 - validate this is what I'm going to be
123:44 - using so valid it and I'm going to pass
123:47 - the token
123:52 - okay this has to be an object
123:55 - actually like this okay so this is will
123:58 - be triggered by this file which I'm just
124:01 - going to import and when this is going
124:03 - to be triggered this is going to get the
124:06 - authorization beer token by splitting
124:08 - that out as a second value and this is
124:12 - token is going to be passed to this
124:14 - utility function and this is going to
124:15 - validate if it's true or false or token
124:18 - exists or not based upon that it is
124:20 - returning true or false now let's use
124:23 - this o middleware in our middleware dots
124:26 - file so let's first of all import that
124:29 - instead direct we can directly use that
124:31 - it will be automatically imported above
124:34 - okay so now let's use
124:37 - const Au result equals to AU middleware
124:43 - from middleware you can see there is
124:45 - automatically imported and then I can
124:48 - pass request to it okay
124:52 - this is the request I have passed to it
124:54 - and from this request it is going to
124:56 - fetch out the headers once it is going
124:59 - to be passed that function is going to
125:02 - return me is valid whether it's true or
125:04 - false now I can actually check if Au
125:10 - result
125:13 - dot is
125:17 - valid then I'm going to return the
125:20 - response new next response stringify
125:25 - unauthorized if it is not is valid means
125:28 - if it returns false then it is not it is
125:30 - going to return us unauthorized
125:33 - otherwise it is going to give me access
125:35 - to all the apis and along with this I
125:38 - can also pass up and and checks as well
125:42 - let's say request.
125:45 - URL uh this has to be the request. URL
125:49 - do includes
125:51 - and then slash API slash
125:55 - [Music]
125:57 - blogs okay so uh actually this is
126:01 - request all right so it means that this
126:04 - has to if it is invalid or this is blogs
126:10 - then I'm going to return unauthorized so
126:12 - I'm always
126:14 - unauthorized uh I'm I'm making a check
126:17 - that uh this token is applicable only
126:21 - with
126:22 - blogs okay and this validation is not
126:26 - applicable with the uh other apis like
126:29 - the categories or the users so for now
126:32 - let's go over here let's try to fetch
126:34 - the users you can see that I'm able to
126:37 - fetch the users because this validation
126:40 - for un authorization is only being
126:42 - applicable on this blogs okay if I go to
126:45 - the blogs and try to fetch the blogs now
126:47 - you can see that this middleware
126:49 - executes before every API request that
126:53 - is going to happen all the API request
126:55 - Within These blocks because I've added
126:57 - the checks for the blocks for now I'm
127:00 - just going to show you that uh this is
127:01 - how you can add checks you can U add the
127:05 - blogs slash something like that you can
127:07 - be specific which API should be added
127:10 - along with this BR token validation so
127:13 - for now I'm just going to remove this
127:15 - thing so now it is applicable for all
127:17 - the API request irrespective whether
127:20 - it's user whether it's categories or the
127:22 - blogs okay now if I go to the get user
127:25 - send and now it is unauthorized now how
127:28 - to make it authorized uh let's pass this
127:31 - beer token in the headers then it's
127:34 - going to return me true okay so let's go
127:38 - and select the beerer token from here
127:41 - and I'm going to use
127:43 - beerer and then this is not a real token
127:46 - I'm just mimicking the behavior usually
127:48 - be token is a combination of uh you know
127:52 - uh this this kind of thing now I've
127:56 - passed this brra token now let's send
127:58 - now you can see that I'm able to fetch
128:00 - the value because I'm passing the beer
128:02 - token for for posts as well for update
128:05 - for get categories let's try to get the
128:07 - categories unauthorized let's pass the
128:10 - beerer
128:13 - token like this now I'm able to get the
128:17 - categories from the database okay now
128:20 - this middle Weare is running before
128:22 - every API request this is what I'm
128:24 - trying to explain you guys now let's say
128:27 - that I want to add multiple middlewares
128:28 - for logging I want to log some
128:30 - information in my
128:32 - database that which API request uh was
128:35 - triggered and what was the method type
128:37 - for that API okay so uh now let's go and
128:44 - in the API folder and I'm going to
128:46 - actually not the folder the file and I'm
128:49 - going to add log
128:52 - middleware dods okay and in this
128:55 - particular middleware I'm simply going
128:57 - to export function
129:01 - log
129:04 - middleware request of
129:07 - type request okay and this is going to
129:10 - Simply return the response column
129:15 - request uh request. method append it
129:21 - with with
129:24 - request dot URL okay this is the simple
129:29 - logging and we can modify this logging
129:32 - operations by our own data all these
129:35 - things and now let's log the information
129:38 - uh before every API request that is
129:40 - going to be triggered let's come inside
129:43 - this and I want this loging information
129:46 - for only blogs API and just like I have
129:48 - added this condition I can add this
129:51 - condition for uh logging the information
129:53 - for only blogs API so for that I can
129:56 - actually add uh request do url. includes
130:02 - SL API blogs so it is only going to work
130:06 - with this blog API if you want you can
130:08 - remove this condition as well so now
130:11 - const log
130:14 - result equals to log middleware this has
130:18 - been imported and let's pass the request
130:20 - to it and now I can simply log the
130:24 - result by uh log result. response all
130:30 - right so let's save it now uh let's
130:34 - trigger that out uh this is only going
130:37 - to work for blogs so let's get the blogs
130:40 - let's send unauthorized let's add the
130:43 - beerer token and let's add the value
130:47 - send now I'm able to fetch the blocks
130:50 - let's go over here and now you can see
130:56 - that this is the URL got triggered this
130:59 - is what it printed this is the method
131:02 - type this is the URL it printed uh and
131:07 - we can add more information and this is
131:09 - the uh this is the thing that it has
131:11 - printed actually I think this is the one
131:14 - okay yeah uh so and we can modify this
131:19 - one and uh let's
131:21 - pend yes to it okay and see which URL is
131:26 - this let's hit send and let's come here
131:31 - and yes this is the URL and we have this
131:33 - yes appended after that uh so this is
131:37 - how it is working and we can add as much
131:40 - middleware as we want and if you want to
131:43 - remove this you can remove it and add
131:45 - some more conditions as well and our
131:48 - routing is protected over apis are
131:51 - protect protected um and over logging
131:54 - middleware is working fine so we are
131:56 - done with creating apis now it's time to
131:59 - deploy over nextjs application with this
132:01 - whole back back end of the rest API on
132:05 - the versal so let's go ahead but before
132:07 - that I'm going to first verify if there
132:10 - are no issues in my code because versal
132:13 - run this command npm run build so before
132:16 - deploying that I'm going to verify that
132:18 - if there is no error here then there
132:20 - won't be any error on the versal usually
132:22 - there is no error on versal uh but let's
132:25 - verify that so it's currently building
132:28 - that till now if you have learned
132:30 - something new if you have liked my
132:32 - tutorial uh I would request you guys to
132:34 - check my YouTube channel from the
132:36 - description of this video and do
132:38 - subscribe my channel as well so I think
132:41 - there is no error yes there is no error
132:44 - now I'm going to open up the GitHub and
132:46 - I'm going to deploy my application on
132:49 - versal so first of all let's go ahead on
132:52 - the GitHub and create a new repository
132:55 - and I'm going to give it a name next 14
132:58 - rest
133:00 - apis uh yes and uh I'm going to leave it
133:04 - public because you will get the link of
133:06 - this repository from the description of
133:08 - this video and uh do give it a star guys
133:12 - so let's not add read me let's leave it
133:15 - by default let's click on the create
133:17 - repository so it's going to gets created
133:20 - and first of of all I'm going to open up
133:23 - this G ignore and I'm going to add EnV
133:27 - file over here I don't want to put EnV
133:31 - here uh I will manually be adding this
133:34 - uh mongod DB URL in my versal
133:38 - environment okay so now let's add
133:42 - get status these are all the changes and
133:47 - uh I'm going to write git add Dot
133:51 - after that I need to commit that out so
133:53 - let's copy this commit command let's add
133:56 - over here and this is committed and I'm
133:59 - going to copy all of these three
134:01 - commands at once so I'm going to add it
134:03 - over
134:05 - here and let's hit enter so this is
134:09 - pushed let's
134:11 - restart okay the page is reloaded and
134:15 - these are all the changes I have just
134:17 - pushed okay and uh there is no EnV file
134:21 - this is perfectly fine now I'm going to
134:23 - open up versal decom and uh I'm going to
134:28 - add a new
134:31 - project and these are the all the uh
134:35 - repositories which I have added in my
134:37 - account I've already added my account
134:39 - inversal uh so now let's go and import
134:43 - this particular repository and before
134:46 - clicking on deploy let's go to the
134:47 - environment variable and I'm going to
134:49 - open up EnV let's let's copy everything
134:52 - from here and I'm going to paste it
134:55 - directly here all right
134:57 - so now uh let's click on deploy okay so
135:04 - it's going to take some time in order to
135:06 - deploy that so let's wait for it all
135:08 - right guys so our project is deployed
135:10 - you can see congratulation and it is
135:12 - showing the default UI on the front end
135:14 - this is the default UI when we create a
135:16 - new nexj project although I did not
135:18 - touch the front end part of next JS so
135:21 - but still it is showing the default UI
135:23 - from the homepage I'm going to go and
135:26 - continue to the dashboard and it is
135:28 - going to give me the URL where our app
135:30 - is deployed this is the URL okay I'm
135:33 - going to open this up and our app is
135:35 - deployed now let's copy this base URL
135:38 - earlier we were using Local Host 3000
135:41 - and currently we have this one and I'm
135:43 - going to add it rather than Local Host
135:46 - 3000 okay and let's try to trigger this
135:51 - currently it's showing unauthorized uh
135:53 - it means apis are working that's why it
135:55 - is showing unauthorized but uh we need
135:58 - to pass the beerer token so let's go and
136:02 - uh let's get all the
136:05 - blogs okay so but I'm going to replace
136:09 - Local Host 3000 with the deployed
136:12 - instance that we have the next 14 rest
136:15 - API and now let's see because the
136:18 - database is same still it should return
136:20 - on the same data which was returning on
136:23 - the Local Host so let's hit
136:25 - enter it is taking some time because it
136:28 - is a deployed instance so let's see and
136:30 - now guys you can see that it has
136:32 - returned me this data with this deployed
136:36 - URL so our deployment is working and we
136:38 - are passing BR token earlier um on the
136:42 - browser we had this unauthorized let's
136:44 - try to get the users as well because we
136:46 - are passing the beer as well so I'm
136:49 - going to replace the base URL with the
136:51 - deployed version okay and let's hit send
136:55 - and now you can see that it is not
136:57 - throwing unauthorized error in fact it
136:59 - is giving us this URL the the the data
137:03 - in the Json all right guys so I hope
137:06 - that you have learned something new from
137:08 - this video if you have liked my video
137:10 - let me know in the comments of this
137:12 - video and again guys do check out my
137:15 - YouTube channel as well for more videos
137:17 - on nextjs so hopefully I will try to
137:20 - create more videos on free code camp and
137:22 - I would like to thank free code camp for
137:24 - giving me the opportunity to create a
137:26 - tutorial for this channel so guys thank
137:29 - you so much for watching see you

Cleaned transcript:

this guide to building rest apis on NEX js14 goes beyond simple Crut operations teaching how to create multiple mongodb models like users categories posts and comments while also covering how to protect API routes you'll get handson experience in setting up schemas building robust apis and implementing Advanced features such as logging middleware and deployment in this course um jam will help you enhance your nextjs and rest API development skills hello everyone my name is Om I'm a senior software developer I'm building web applications for over 8 years now many people use nextjs for their frontend interactive applications but in this video I'm going to teach you how we can build complete backend and build rest apis using nextjs 14 using App directory structure so these are the topics I will be covering in this tutorial first of all I'll will be creating a new NEX js14 project from scratch after that I will be explaining you guys what are the different fold ERS and file structure recommended by nextjs in order to create apis in our project after that I'll show you how we can connect to the database in this case I will be using mongodb after that I will be creating different models for adding relationship between users blogs and the categories and all the relationship happening between these models for example a category belongs to one user a Blog belongs to a category as well as users and more relationship between these models and this point is going to take a lot of time because we will be creating all the apis and adding error handling in our apis after that I will show you how we can add filtering searching pagination and all of different these things for blogs if you want to add these features in your front end application using these apis after that I will show you how we can protect our apis using beer token it means from the client side when you will be accessing these apis if you don't pass any beer token then it will throw an on a authorized error then I'll talk about middle wees how we can add logging or error handling before any execution of the apis finally I will show you how we can deploy over complete backend in nextjs 14 on versal so during the development of the apis in this tutorial I'll keep on testing all of these apis on Postman in Postman we can create collections folders and then the requests for the get post patch delete and put and I'm going to explain you how we can use Postman in order to test the apis by adding different URLs adding authorization headers how we can add different body data over here and test that out so before starting I just want to tell you guys that I have my personal YouTube channel as well where I create videos on multiple technologies that includes react angular node Express mongodb prompt engineering Docker cicd git GitHub typescript and all these different topics and if I go to the playlist mainly I create videos on nextjs so this video is mainly for the back end if you want to learn about front end in nextjs then I have created all the videos on different topics for you guys in order to become a good NEX gs14 developer so you can check the link of my channel in the description of this video and I would really appreciate if you can subscribe my channel as well so let's get started by creating a new next js14 project I've opened up vs code with an empty folder inside it and and now first of all we need to verify if we have the latest varion of node and npm installed in our system once we have verified I'm going to write a command npx create next app at latest dot I will hit enter dot means that I don't want to create a new folder inside my existing open folder in our vs code so I'm going to go with the typescript es lent Tailwind CSS Source directory no app router yes no for customized default so most of these options are related to front end but I'm going to be focusing on backend side only so our project is created I'm going to clear the terminal out so let's see what we have here this is our main folder app and it includes all the files and the folders for our apis for our frontend routes since I'll be focusing on backend side only so let's talk about the folders and file structure for the back end so inside the app Direct first of all we need to create a new folder API and everything we will be creating on the backand side should be added within this API folder and inside this API folder we need to create another folder let's call it users and the name of this folder will become the part of the URL for this API means that in Local Host we are running the application it becomes Local Host colum 3000 SL API SL users and it will become an API if we create a file file called route. TS inside it we cannot change the name of this file it is predefined by nextjs and inside this route. TS I'm going to show you by creating a simplest API so let's create export const get this is going to be a get request we cannot change its name and let's return some message from inside so I'm going to return new next response from next server and this is my first API okay so let's save this file and I'm going to run my project by running npm run Dev and it will run on URL Local Host colon 3000 now I'm going to open up browser and Trigger Local Host column 3000 SL API SL users and this get request should be automatically triggered get request can be tested on the browser because in get request we are not passing any kind of data to it so in the browser you can see that I have triggered Local Host column 3000 API users and this is the response it has returned so it means that our API is working fine now in order to organize our apis in nextjs nextjs recommend us few folder structure techniques so let's say in our applications we have authentication and users apis and we have the dashboard apis that can include the settings all the analytics all the lists of data that we need to show so if we create all the different folders directly in the API that it can become messy I want to organize the folder structure but I don't want that folder structure to be a part of the API URL so I can do that so inside the API folder I can create a new folder let's say all the authentication related apis it can be the login sign up users reset password forget password should be added within this Au folder now I'm going to move this users folder inside this o folder you will be thinking that this o folder now will become the part of the URL but that's not the case this is for only organizational purpose if I go on the browser and refresh this URL you will see that this API is still working without adding the Au so if we add parentheses around any folder that gets excluded from the URLs on the back end as well as if we create the routes on the front end in next xjs now I'll come back to this file when I will need to create all the get post patch and delete request for the users along with the error handling and curing data from the database before this I want to connect my project with the database for that I'll be using mongodb which I can set locally in my system but I will be using a cloud mongodb provider from the Atlas so you need to open up cloud. mongod db.com and sign up with your email ID after that once you sign up and sign in you need to create a new organization I think that it is going to autogenerate the first organization if it doesn't you can go to the view all organization and create a new organization first of all within the organization it will show you all the different projects if you are new to this it won't show anything so these are all the projects I've already created I'm going to create a new project for over rest API in xs14 so I'm going to click on the new project button and here I can name next4 let's call it mongod DB rest API so this is the name I've given to it you can name anything all right so we should not add actually this is optional I'm going to click on next and uh I'm going to leave it as project owner and click on create project so it's going to take some time and uh I myself want to use this API so that's why I didn't add any email Above So now this project have been created and inside this project I need to create a new cluster so by default it's going to give me these options uh 0.08 per hour dollars I'm going to go with the free because this is just for testing once you want to deploy your project on production then you might want to choose any of these options which you can change later on as well I'm going to leave this default name cluster zero I'm going to check AWS I'm going to select the nearest r region uh where I'm sitting currently so I'm going to go and create deployment so it is I've clicked on that it's going to take some time and create the cluster for me so this is the model that it has opened first of all it has given me this username and this password I can generate a new password I need to copy this password over here which I would need later on when I will be adding it in my project so let's copy it and paste it somewhere I've just opened up a new tab and pasted it over here and uh let's go choose a connection method actually so set up your account so I'm going to click on the create database users first of all and then I'm going to click on choose a connection method so these are all the connection method has given to it so I'm going to click on this driver and uh first of all we need to install this package npm install mongod DP let's stop the project and hit enter by adding this command and now this is the URL that we need from here let's click on this icon and it is going to gets copied and in our project I'm going to create a new file and I'm going to name it EnV and let's name it dbor urri equals to and this is where I will be pasting that URL which I have just copied okay and after that I'm going to go and I'm going to copy this password which I saved actually it already added over here earlier here it was not already added which we had to manually add from here all right so here we have this uh retry wres through W majority app name cluster for now we don't need this app name cluster I will be modifying it in my DB connection code okay so let's remove that and let's save this file let's close it and for now we don't need to care about this page for now let's click on the done and let's click on the database and first of all I'm going to go into the network and here currently my current IP is uh added over here means that the API the data that is added in this database can be accessed from my network only I want it to be accessed from anywhere in the word so I can click on ADD IP address allow access from anywhere so it's going to add 0.0.0 from here and I can click on confirm So currently it is pending and after few seconds it's going to be active so it means that everyone from around the world can access over apis if you want to do that on the production you can do that so I've just done it uh on this DB and you can see that it is active I can click on the database and uh I can go to the browse collection and currently it won't show anything because we don't have any data and I will come back to this page once we have the data we will be performing different crowd ations in our project so first of all in this project I'm going to create a new folder and this is going to be called lib and inside this lib I'm going to create a new file let's call it db. TS and inside this file I'm going to execute the Mongo's Connection in order to connect my project on that mongodb database and the URL is I have already added in EnV so let's open up the db. TS first of all I need to import mongus and I need to install the mongus in the terminal I'm going to write a command npm install mongus hit enter so this is going to get installed once it's getting installed I can import that from mongus okay so let's get that URL from that EnV file so I'm going to write mongod dbor URI equals to process. EnV mongodb URI so this is what I've got after that I'm going to write a function con connect async this URL and then I'm going to check if the connection was already connected then uh we would don't want to connect it again so this is just for error handling so I'm going to get connection state from do connection do ready State okay and then I can check if the connection state is equals to 1 it means that it was already connected I'm using tab 9 a assistant extension in my VSS code so sometimes it suggest me uh the code when it sees uh then I have to hit Tab Key on my keyboard and then it gets selected so this is what happens just now and after that uh I can actually add the connection State equals to two so this is the tab 9 a assistant which is recommending and this is right I can hit tab so now I can go console.log connecting dot dot dot okay and then return after that if any of these conditions get failed it means that we need to connect to our database so I can use mongos do connect and then URI and exclamation mark and the reason it is showing this error that it kind it kind of uh uh thinking that it may be undefined but we know that it cannot be undefined we have added it in our project so I can add exclamation mark after that okay so after this I can add this object and let's add the DB name and uh let's add next 14 rest API this is the DB name I've added and this is the buffer command I'm going to give it value true okay uh we can add console do log connected and uh for the try I need to add the cat block as well in case there comes any error so console. log error let's show the error over here and uh throw the error as well so throw new error and then the error all right um I can actually pass the error and like this okay so it is giving us few uh types scripting so for now I'm going to add this data type any over here okay so that's pretty much it for this particular file and one last thing because we will need to access this connect function in uh our uh API files so I need to export it from here so export default connect all right so for this DB uh that's pretty much it let's close all of these files and I'm going to create a new folder inside this live and I'm going to create create models for users category blog and I'm going to add the relationship between these so hit enter and inside it first of all I'm going to create a new file and I need to create the users model first of all so mongus provide us builtin functions for creating the schema like which properties the users can have like the email username first name last name password full number address so I'm going to go with the minimal data because once you understand how things are going then you can add the more data as you want okay so I can add import and then let's add the schema model models and this is going to be the from okay let's create the user schema and for creating the schema I can use that schema class which I have imported above and inside it I can add an object so let's add an email and email is going to be of type string required true and email should be unique okay after this I need to add the username which I can add so this is going to be type string required true unique true and uh make sure you install the tab 9 AI assistant uh it really helps sometimes okay this is what recommending me so after that it is automatically suggesting whether I might want to add the password and yes I want to add the password so this is why it is suggesting me this so password is like this okay and after this I'm going to add another object so whenever this new user gets created or updated I want to create the created ad and updated at time stamps automatically created in my database so time stamps equals to true and make sure you add this after that I'm going to add the con user equals to the models do user or model and then I'm going to add the user comma and then the user schema and after that let's export this user because this user we will be needing in our API route. TS file including the db. TS uh in order to cury the data from the database whether we want to store the data in the database for post patch or the delete or we want to get the data from the database so I'll come back to this folder I'll be creating more uh models uh like the category or the blogs to add the relationship between this user schema but first of all let's create the apis to create a new user in the database uh to update the user to delete the user and to get the users from the database so let's open up this route. DS file now now I'm going to modify this get request to fetch all the users exist in the database although there are no users in the database because we haven't created any yet and we haven't either created the post request in this file which is going to be responsible for creating a new user so first of all let's modify this get API for the users I'm going to add a tri block and inside it I'm going to write a wait and I'm going to call the connect function so before any operation that we perform to the database then we need to call The Connect function that we have created in db. TS file so I'm going to import it from /lib sdb this is the path of the db. DS file and after that I can actually use users a wait and then I'm going to write user this is the name of the model which we have created and this is going to be imported from at lib models and then the user and if I write dot you will see that all of these different functions are prebuilt provided by mongos and we can use any of these functions find means return all of the users data exist in the database find by ID find by ID and delete find by ID and update so I'm going to go and select the find it is going to return me all the users although uh there are no users but we are going to verify and this connect function is working perfectly fine and the connection to our database is working pretty fine so after that I'm going to return a response return new next response and then I'm going to add json. stringify users and I can also pass the status as well let's call it 200 okay and after that in our else not else actually the catch block error and inside the catch block I can return any kind of error as we want okay and for the await I need to write async over here and this error is going to gets invisible now so I'm going to add error in fetching users and I'm going to add plus error. message and uh lastly I'm going to add the 500 status code this error is showing some kind of message so I'm going to add any data type over here so after making some changes in the back of nextjs I try to rerun the project so npm run Dev in the terminal so it is getting started now I'm going to retrigger this route Local Host colon SL uh 3000 API SL user so let's go over here and let's refresh this particular URL okay so Local Host colum 3000 API users and this is going to gets triggered and I'm going to go inside this DB and I'm going to click on this refresh button so let's see if it creates yes this DB name gets created next 14 rest API and along with that it has created this users model although it contains nothing and this was expected but we have verified that our DB connection is successful and the name of the DB with the name users is also successful so it got this users name from this users. DS file from here by adding s after that and if I go to the db. TS you will see this connected string is visible this is because of the console ninja extension which I have installed in vs code now let's open up the route. TS I'm going to close these two files and uh before creating the post request for creating a new user Let's test this get API in our Postman so you need to download the postman you can also use the postman on the browser or you can download it in your system I've downloaded it I've already signed up with my account uh and here on the left side we can see there's a collection environment and the history so you need to go to the collection and you can create a new collection from here if I click on the blank connection uh then this folder is going to gets created inside it we can rightclick and add a new folder which I've already added you need to add a new folder with the name users okay and inside the users you need to click on the add request once you click on the add request uh a random request is going to get generated within that folder okay let me zoom in yeah so now this is the first get request which I've already added and uh here you you can change the name of this get request and from this drop down you need to select the get okay and after that you need to write the URL of the API that needs to be triggered so this is the same URL which we have triggered in our browser and now let's try to trigger this API in post man so I'm going to click on the send and here you can see that it has created this empty array and it means that over DB is working and connection is successful and these are some default headers you don't need to care about that okay so now I'm going to go and I'm going to add a post request so before that actually nextjs what happens is we use third party services for authentication of the users for login sign up it can be the cler authentication next o Au zero kind authentication uh and that gives us all the information of the session of the loged in user the signed up users but in sometime some cases we need to add the same user data in our own database as well because of the relationship within other models in our application so I've already created the videos on all of these different topics on my personal Channel you can check that out and the reason I'm creating the APS for the users in order to create the users instance from the clerk from the next o from the kind or o zero in our own database as well by triggering some kind of apis all right I hope that you have got some point um now let's go ahead and create the post API in our project now so it is suggesting me whether I want to write this yes I want to write this and let me change the name of it to request and this is going to be of type request okay okay and inside it let's add the tri block and the catch block this is required in every case actually okay so now in the tri block first of all what we need to do in the post request we need to get the data of the user okay and the data of the users can be get from the body in our Postman if I show you over here post user and this is the body and from here I will be passing this email username and password data which is added in our model over here and the same data I will be passing from this Postman okay so in order to receive this data in our post request we can have const body equals to await and then the request do Json and this is going to get the data from the body and after that I'm going to Simply connect to the database so if the connection is already established I've already made a check uh over here that it was already connected so we you don't need to care about that it's going to take time to for the reconnection to the database so uh triggering this connect again in each request uh is not going to cause any problem in terms of performance okay so now we need to create an instance for the users the tab9 AI assistant extension is suggesting me few things so I think this is right but I'm going to explain it step by step to you guys so con new user equals to new user and this is going to take the body okay now I'm going to write await new user Dove okay now this is going to connect to the database creating an instance of the new user with the data we have passed from the client side and this is going to save it in the database and once it is going to gets saved I'm going to return a success response to the client currently our client is either a browser or uh any front end application it can be our current nextjs application as well but we are calling our client as a postman because whoever is calling the API is considered as a client okay so now new next response and uh this is going to give us json. stringify let's add message user is created created and after that let's pass the new user data which is created uh this is uh actually this is the user I I had to call it new user all right and let's add the status as well so over here status is going to be the 200 okay let's add some error handling in the catch block so it is suggesting me something let's click on the tab and uh this is going to return error in creating user along with the error message and status is going to be the 500 so it is fine so I'm going to save the file and I'm going to go in the postman and here I can actually right click add request and this is going to get generated you need to change the name of it select post from here and now I can add SL API slash users okay the same API is going to be responsible for the Post request and the only difference is this method which is the post okay default headers this is the body and uh let's go with the same email username and the password so let's click Send all right so it has returned message user is created along with the user data okay and in order to verify whether this user is created in the database or not I'm going to to go in this and I'm going to refresh this page so let's see if the user is visible in the database or not so it's loading yes so our data for this user is created along with this underscore ID this is the unique ID automatically gets created by the mongodb and email username and password and created at uh this is the time stamp uh because we added this time stamp equal to true in our model so it means that our post request for the user is working pretty fine I'm going to go ahead and I'm going to add uh API for the patch for updating the user let's say user is already added in the database and we want to modify its username or we can modify its uh password okay or any other details the phone number uh so I'm going to go and create a new patch request so this is going to be the export con patch equals to async and this is going to be the request of type request let's add an arrow function okay let's add the try and catch block first of all so we remember that uh we need to check for errors okay so inside the tri block what we need to do we need to get the user ID which we want to update and the new data with which we want to update that user so there are two things okay so I'm going to get the data which needs to be updated from the body just like I've got from here okay and also I'm going to get the user ID directly from the body as well although I can get the user ID from the perams from the URLs but I'm going to get the new user name and the user ID directly from the body so in the tri block I can get the body from the await request. Json Let's uh why it got here let's remove it okay so after that I'm going to get the user ID which I'm going to be passing as a body from my Postman from client and then you username okay so here I'm going to get it from the body so a wait connect again connect to the database before performing anything and I'm going to add some error handling there might be a chance that from the client whoever is building the front end might not pass the user ID they might not pass the username so we need to throw an error we cannot proceed if the um the user ID is not found U or user ID is invalid okay and in order to check the validation of this user ID that uh the that is automatically generated by the mongodb there is a way up so I'm going to go at the top and I can add con object ID equals to the uh require and this is going to be the from dot types doob ID now I'm going to use this object ID to check whether the ID of the user which is being passed from the client is uh in correct format or not okay so let's come over here and uh now first of all I'm going to check if user ID or new user name does not exist okay if it does not exist then I'm going to throw an error uh return a response that invalid uh request I'm going to change the message so this is going to be the ID or new username uh not found any message that you want to add okay status is going to be 400 after this I'm going to check the validation of the ID so I'm going to add the types doob ID dot uh is valid and this is going to receive the user ID which we have received from the body So currently it is saying that types not found so we can add the types over here so this is going to be the types from mongos and now you can see that the error is gone and inside it if user ID is not valid we can actually return uh the similar kind of message as above so I'm simply going to copy this error message and invalid user ID so invalid user ID this is the message I have added so once both of these conditions get false it means that the user ID and username exists and the user ID is a valid user ID then I'm going to proceed and find the user that if user should be existing in the database because user there might be a chance user is not existing in the database so update user equals to await user and I'm going to first check find one and update so it's going to first find whether it exist in the database if it find that then it's going to update that with the following data so I'm going to give it these details okay so underscore I ID and this is going to first find with this ID I'm going to give it new object ID and then the user ID all right and after that I'm going to pass the new username and new equals to True okay and this means that uh whenever the new user gets updated it needs to return the updated user rather than the old user which was stored previously okay so once that is done I'm going to check whether the user got updated or not there might be a chance that it return some kind of error okay so if it returns some kind of error uh then I'm going to uh uh show some kind of message that there might be a chance user not found in the database so let's uh return user actually this is what tab 9 a assistant suggested so let me see return new next response message user is updated user updated status 200 that is fine but before that I'm also going to return new next response and this is going to be the Json let's change the status I'm going to change it to 400 and for the message I'm not going to return the user for the message I'm going to say user not found in the database okay and this is going to return if updated user have some kind of error and this variable is this one okay so now we are good to go with this API I'm going to go into the catch block and I'm going to return some kind of error message error in updating user error do message status is going to be the 500 okay so I've updated that let's save this file and uh let's go and verify what is the username so it is the you new user double2 I'm going to remove the double two and update that let's go into the postman create a new request change the name to update user select patch from here add the same URL because URL is not changing because URL depends upon the folder structure which we have added okay and uh then I'm going to click on the body and you can see that we need to pass user ID which we want to update and user ID needs to be existing in the database currently this is the user ID this at the end it is Fe So currently I don't have Fe so let's first verify if the user ID is correct or not I'm going to click on send so you can see that it has returned me a message that user not found in the database because this ID does not exist in the database this is what I have returned over here okay and these are the two things which we I'm getting from the body and let me copy this user ID and I'm going to paste this user ID over here okay and uh let's new user let's add it like new user only okay the ID is correct and this is the new user now it should be able to patch the username let's click on send and user is updated and uh it has returned this response and this is the response which is being returned from here user is updated let's verify it over here you can see new user double2 let's refresh and see if it gets updated or not so I've refreshed and uh yes so it is updated and username equals to the new user now finally for this part particular API I'm going to add a delete request so let's go down and create a delete API by the way I remember some people have some issues like uh they wanted to write something over here in the body but after selecting the body you need to go and select the raw and from this drop down you need to select the Json and after that you can add the Json object from here all right so let's come back over here and let's add the delete request so it is suggesting me this so I'm going to go with that the tabe 9 AIA assistant is an awesome extension of vs code and let's again add the try and the catch block just like we've been adding above like this okay so inside the try block so in this delete case uh earlier in the patch case I was fetching the user ID in the body let me show you how we can fetch the data as a param as a search param from the URL okay let me show you what you mean mean by that if I go to the delete you can see this is the user ID which I'm passing by adding the question mark user ID equals to the user ID and uh this is how I'm passing from here so let's come over here in order to get that I can use const let's add the search params equals to new URL and then the request. URL okay and let's add the cost user ID equals to the search param user ID so this is how we will receive the user ID from the URL so once we do that we need to validate if the user ID is valid or not actually user ID exists or not okay so we can do that let me copy this one the same thing okay so let's copy if and I'm going to paste this over here here let's remove the username we don't need that and now this is going to verify if user ID is actually being passed from that uh client or a postman to this API or not because without this user ID we won't be able to know which user we want to delete okay and after that we need to verify if user ID is valid or not so tab 9 AI assistant is suggesting Me by going through our patch request so this is what it is suggesting invalid user ID and and I think this is fine so types object is valid user ID so all of these error handlings are very essential to avoid any kind of uh problem in our backend so I'm going to go with this and after this if condition I'm going to connect with the database okay so once the connection is established I'm going to find and delete with the ID which is being received from that URL so I'm going to uh write cost deleted user equals to await user. find by ID and delete okay and inside 8 I'm going to pass new types doob ID and then the user ID so this is something which I've have done so now I need to check uh if there is no error because of this and and uh I'm going to return the response so I'm going to verify if there is no error uh if there is uh error in it then I'm going to user not found in the database all right so I have selected this I think this is fine and finally I'm going to return the response that user is deleted successfully and tab 9 aist and is suggesting me this return new uh response string ify user is deleted and then uh returning the user here okay so let's select that I hope there won't be any error the tab 9 a assistant is not going to give you a correct result always so you need to be careful uh while selecting its code which it is recommending okay and uh inside this catch I'm going to uh return the response error in deleting user okay okay so this has been done let's go into the postman click uh create a new request select delete from here and always try to let's first cut this uh this one and now let's try to trigger that send now it is returning me a message ID or new username not found actually I need to change it ID not found only all right so this has to be the message yes and now let's try to add this one this is not correct user ID but let's try that user not found in the database with this ID so ID is incorrect let's try to get the user and let's copy the user ID from here which is the correct which exists in the database now I'm going to pass this particular ID and I'm going to click on send and user is deleted this is the user which got deleted this is fine and I'm going to first verify by triggering this get request whether it returns a response and it did not return a response so I'm going to uh refresh this and I'm going to verify whether uh it got empty or not so guys there is no result it means that user got deleted successfully from the database which is perfectly fine now we are done with this user API I'm going to create new models for the category first of all and I'm going to add a relationship so that uh user uh should be able to create a category and category should belong to one user so this is the relationship I'm going to be creating okay so let's close this route. TS and inside this models I'm going to create a new file and this is going to be the category. TS all right so inside this category. TS I'm going to be importing schema model models from go const category schema equals to new schema and inside it I'm going to write the title type string and this is going to be the required property and after this model I'm going to add the time stamps equals to true and uh let me come back to this part user after that so after this I'm going to add the category models. category so this is fine whatever suggested by tab 9 and I'm going to export default category okay now I'm going to add a relationship between category and the user so whenever new category gets created I want to store the reference of user that this user created this category okay so I will be passing the user ID and the title while creating a new category from the client or you can say a postman so in order to add a reference I can pass the type column and I can use the schema do types doob ID and I can pass the ref this is going to be the user okay so this is going to add the reference to the user model and the name of this user is refering to this model user Okay so I have created this model now let's close that and inside this API I have this Au and for these categories and the blogs let's say uh on the front end side user have to login first and then user goes to the dashboard and in the dashboard uh user sees all the list of the blogs and the categories so I'm going to organize my apis in a way and I'm going to call uh the after logged in page as a dashboard you can call it anything you want so inside the AP I'm going to create another folder and I'm going to name it again whenever I add parenthesis around the folder name this is not going to be a part of the API route structure so inside this dashboard uh I'm going to add a few routes uh for the categories and the category ID so inside this I'm going to add a new folder so let's add categories and inside the category I'm going to add the route. TS file okay so in this file I'm going to create uh two requests get and post for the patch I'm going to show you how we can create the dynamic API route uh to get the data from that URL for particular ID in order to delete or patch the category uh using an ID of the category okay so now at the top just like I imported uh all of these things at the top so I'm going to import these uh as well in this file as well so connect user uh and then the next response and then the types uh we need user and we need category as well so I'm going to import category and the reason we need user because we want to verify the user ID uh which is being passed uh while creating a new category okay so let's create export const get equals to async and then let's add the request of type uh request Arrow function and inside it just like earlier I'm going to add try catch block all right so inside the try I'm first going to get the user ID from the URL so let's add that so let's copy it from this delete request which we have added so these two lines I'm going to copy and I'm going to paste it over here so this is going to give me the user ID which is being passed from the URL so now I'm going to check if the user ID exists um and I can uh check the user ID is valid or not directly in the same condition as well so I can add the not user ID uh or types doob ID do is valid user ID so if both of these conditions gets true uh then I'm going to Simply return a response that uh invalid or missing user ID so I'm selecting this suggestion from tab 9 a assistant extension and I'm going to invalid or missing user ID and this is the message I have given to it okay so after after this if condition I'm going to connect to the database and I'm going to uh actually get that uh user uh which is being passed so I'm going to add con user equals to await user. find by ID and then user ID okay and so you might be thinking that why I am applying some queries for the user uh because I want category API or any kind of category to be seen by that user who created that category this API should not be called from by any user uh uh who and for those user who have not created this category so if this user ID is exists in the database then I'm going to uh fetch that uh category from the DB so if no user then I'm simply going to return a response so let's select that and this is going to be user not found in the database let's go with that and now I'm going to find the category with the user ID so uh let's go user C categories await category find and uh let's select that but rather than adding directly user ID I'm going to write new types do object ID and then the user ID okay I need to end it with the parenthesis so this is where I'm passing the user ID uh matching the user ID which is stored in the database against this category uh so user ID which is being passed from the client and user ID which is stored in the database so this is where I'm checking if both are matching then it means that uh the category is being fetched by that that user who created that okay so now stringify categories status 200 this is going to return us all those uh maybe categories yeah um all those categories okay so um now I'm going to show some error message error in Fetch categories all right so let's save this and let's go and uh create a new folder inside your collection and inside this folder I'm going to go into the this uh category get categories and we don't need to add anything in the body so here this is where I'm adding this uh API category user ID so let's try and see what happens so user not found in the database let me see if user exists in the database or not so there is no user exist let me me first um create a new user um by the previous details which we had so send and new user is created new user should be fetched and this is the ID of the user go to the get categories let's pass the correct user ID okay so now let's send and now user ID exists in the database but there are no categories now uh it means that we are uh getting the correct response now we need to create an API posts for creating a new category directly over here so in order to create a new category again we need to pass the user ID so I'm going to uh write export const post and inside it I'm simply going to add uh that let me copy it from the top so try and paste it like this okay error in Crea category okay so inside the tri block I'm simply going to copy these two lines because I will be getting the ID from that URL so let's add that and below this I'm also going to get the data for the category which is going to be uh the title of the category okay so this is going to be the cost title equals to await request uh dot Json okay so this is how I've got that and U now I need to check if the user ID exist and user ID is valid or not so I'm going to go up and I can use the same if condition so let's add that and below this if condition I'm going to write the connect up till now you might have understood uh the whole process which I'm following but there are new things coming up uh during this video so stay tuned and keep watching and now I'm going to write const user await user. find by ID so here I'm checking if the user ID exists in the database and if not then I'm going to to show some error message over here just like uh this tab 9 as is suggesting so if no user ID exist then user not found and after that I can create a new category so this is suggesting me uh new category along with the title plus the user ID which is being passed from the URL so I'm going to select that this is almost fine okay uh once that is done let's select that await new category. save this is going to to create a new category along with the user ID which is being passed from the client side when we build a frontend application we take care about uh all the U IDs and automatically we don't need to manually copy paste like I'm doing over here so this is just for elaboration purpose okay so this is the save and now I'm going to return a response that a user is uh successfully created so actually category is created okay so let's save this file let's go let's go to the Post category and I'm going to write the title and the user ID should be added from here but let's go with the wrong user ID let's click on send user not found yes and now let's copy the correct user which exist in the database so usually in front end application user ID is always correct with which we have logged in um so U this is automatically handled so now I'm going to paste the correct user ID let's send and now categories created with the title category one along with the user along with the category ID along with created ad and updated ad for this category now let's go and get the categories from that DB let's click on send and this is the one category which is stored in the database let's go and verify it from here let's refresh over Atlas and it should create another model within the database and you can can see it has created this model categories and inside it it should have this category one title its own ID and the ID of the user which it belongs to the user who created this category and the created at an updated that uh for this particular category now I'm not going to create the patch or delete request directly in this particular file instead I'm going to create a dynamic route means I'm going to uh pass the ID of the category directly after slash not the question mark it won't be a cury param like this it will be a dynamic part of the URL but this value is going to be dynamic this is not going to be fixed okay so if I directly create a folder it will be a part of the URL then how can I create a folder with that is going to accept the dynamic value so the way we can add it is like within the categories we need to create a new folder and this has to be within the square brackets and I can name anything inside it okay now this is going to receive a dynamic value and this is going to be a part of URL and inside it I'm going to create the same file name route. TS and inside this file I'm going to create a patch and the delete request for the category so first of all let's import the required packages so I'm simply going to copy these things from the previous previous file and let's add it over here and now let's write export const patch equals to async request arrow and like this let me change it to request completely and inside it again as always it's always a good practice to write error blocks okay and error in fetching error in updating category okay so now in the try I'm going to get the body the data which needs to be updated so it is going to be the only title because uh the title is the only property exists in the category model okay even if there are more uh properties still we can decide how many properties we want to update now I can fetch the title from the body okay now for updating a new category we need to check that uh which category needs to be updated for that we need to receive the ID of the category and I'm not going to pass the ID of the category in the body and neither I'm going to pass it as a cury param as a search param and instead I'm going to receive it as a dynamic value from the URL okay so in order to do that next CHS give us a way so I can add the context column params any and using these params I can fetch that so category ID equals to context params do category so now I've got the category ID from the URL after that uh I simply uh so for updating there are three things the category ID the data I want to update and I need to get the idea of the user that who is actually trying to update that particular category okay so just like I got uh it in the previous patch I can receive the user ID from the uh search param from the URL like this uh update this is the dynamic value for the category and this is the user ID everything after question mark is become the search cury parm and if if it's not after the question mark then it becomes a value for the URL so here below it I need to validate a lot of things here first of all I need to validate the category ID if it exists and the category ID is valid then I need to verify if a user ID exists and it is valid so first of all it is suggesting me this so if user ID is not found and user ID is not valid then I'm simply going going to return a response that invalid or missing user ID just like I've been doing earlier and after that um I need to check if the category ID is valid or not so for that I'm simply going to add an if condition uh let me copy this if and I'm going to copy the category ID paste it over here and inside it I'm simply going to return a response that invalid or missing category after that let's connect to the database and now let's verify if the category with this ID exist in the database and uh user with this ID exist in the database both of these things are important so let's select this find user by ID if it exists in the database if it does not exist in the database I'm going to check and return a response that the user not found okay and after that uh if category um I'm I can check if category exists in the database category. find by ID uh and uh but not with this I'm going to write another condition so I can write the category a wait category dot find one so find one and inside it I'm going to pass underscore ID category ID because the ID of existing model its own model starts with underscore in the mongodb database and then the user ID okay so here I'm checking that the category which is stored in the database I'm checking this ID and I'm checking this user ID as well that the user ID which is being passed from the client the postman is matching with the ID of the category user value which is exist in the database so now I'm going to show the error message that if category does not exist with this user ID and the category ID then I'm simply going to return a response that the category not found okay so that is fine now next let's see what we have to do now we need to find by ID and then the update we can do that so uh we we already find that above but we can simply uh create that as well but it's always a good practice to keep on checking for error handling so updated category equals to uh a weight category dot find by ID and update okay and and inside it uh let's bring it down inside it I'm going to pass category ID title and new true which is fine this whatever it is recommending us so let's hit enter and now I'm going to Simply return a response category is updated with this category okay and uh for the error error is fine so let's save it let's verify that so this is the category now uh cancel and in this Postman this is the API which I'm going to test this has to be the category ID let me go and send it with the wrong things so user not found this is the first error showing so let's first uh give it a true user ID which is stored in its database so this is the user ID let's put it over here we can also update these query params by going to the params this is the user I'm going to update that okay so now let's send category not found it found user user because we are checking user first in our API that's why it return users first then the category not found with this ID so let's copy this ID and see that we have this name category one and uh let's put the category this is not a cury param that's why it is not showing over here this is a part of the URL okay uh we have updated that and in the body raw Json this is going to be the category one updated and now uh this has to be updated let's send and now category one is updated let's go and fetch all the categories and it has this name category one updated and if we check on the database this title should be updated I'm going to click on this refresh and it should be updated over here as well and yes it is updated which is perfectly working fine and uh let me quickly tell you that uh this name the params do category is referring to the folder name within the square brackets okay and this is uh the purpose of the name naming the Within These square brackets uh otherwise we will not be able to fetch the data from the URL uh but uh square brackets means it will be dynamic value the category text inside it is used to fetch the that Dynamic value using this context. par. category so we are done with this patch finally uh for this particular category I'm going to create a delete request as well for delete I'm also going to receive the param for from the context and request is over here so in this delete request I can actually copy and paste a lot of code blocks for the validations so here first of all I can copy this line that is going to give me the category ID and then I can actually uh within the tri block um I can actually uh we don't need to get the body because for delion we only need the ID okay so now I can copy this let's add it over here but within the tri block okay let's add the catch block quickly so error any and this is going to be the catch block error in deleting the category which is perfectly fine and uh below this we can copy these two validation Logic for the user ID and uh for uh the category ID if these are valid and these are uh existing and being passed from that client Okay so so let's paste that after it and after that I can connect to the database so we can actually uh check the ID if it exists in the database so we are checking if the user who created this category is actually deleting this category okay and this is the check we are performing here so now we can check uh before that we can check if the user ID exists in the database or not so if user ID does not exist in the database we are simply going to return a response that user not found okay and after that uh we can uh show if the category find one and it is going through all the file and it is suggesting us this things this is why I like tab 9 as assistant extension so let's select that uh find one category ID user ID so uh if we have the category exist in the database with this ID which is being passed and it has this user ID which is also matching the user ID which is being passed from our client the postman okay so after that we can verify if the category is not found uh then we can simply return a message uh this one okay so we can modify this message category not found or does not belong to the user okay okay who created that all right so now I can actually go ahead and delete this category if everything is going well uh then uh we can we can uh check if uh go ahead and check this if the if it's correctly deleted uh but I can actually directly write category do find by ID and delete and within this I can pass the category ID not the whole thing like this okay and uh we can receive it in our variable but um I don't think that is required uh because if there is any error over here it will be received over here yeah and now I can simply return a success response that category is deleted okay so let's go into the postman let's go into the delete category and uh this is the these are the wrong details which I've already added so user not found from the update params let's give the correct user ID delete category user ID let's select category not phone or does not belongs to user so let's get the category ID from here delete um and uh let's add it over here let's send and category is deleted let's try to fetch the category no category found and I'm going to quickly create the category because we have verified that let's send it and this is the category ID which we have got back and I'm quickly going to update that for later on purpose okay yeah so this is updated this one is updated and I'm going to close all of these four requests now okay so we are done with this category apis now we need to create a blogs API that is going to have a little bit more relationship uh blogs can belongs to a category as well as it will belongs to a user who created blog and later on we can filter out the blogs based upon the category as well while getting the blogs back uh on the client side okay so before writing the apis again we need to create a new file and I'm going to write log. TS okay and inside it just like with other models I can import and I can write schema model models from mongos okay let's add the con blog schema equals to new schema and here let's add title for the blog this is going to be the string required this is going to be the content rather than content I'm going to write the description this is going to be the type I'm not going to make it required and then this is going to have uh a relationship with the user schema. types and object and then this is going to have a relationship with the category okay so category type schema types and this is going to be the category name which is going to be coming from this one the category okay so let's try to add an object and here I can add the time stamps and after this let's add blog models. blog or model. blog schema which is fine and this is going to give me uh this export default blog so we are done with creating schema for the blog and Bas based upon these relationships uh we are going to modifying some ques because we have two relationships now for the blogs so let's close these files and here uh we have these categories I'm going to create a new folder within the dashboard okay so this is going to be the blogs all right so inside this blogs I'm going to create a route. TS file for get and post requests route. TS so let's import all of those uh required things uh which we've been importing in the previous files I'm simply going to adding those lines next response connect and this is the blog and users and the category so we will be needing these users and the categories uh for the validation purpose in this blogs API okay so now let's go ahead and write the get API request for this blogs so let's write export and the get I don't need this context in this case this is the arrow function starting off with try catch as always so like this okay so now I'm going to get uh the search parms first of all this is going to be from the URL so search params new url request. url okay and uh I'll also keep opening that route for this category and U let's actually for this and I need to get these two lines which I have been adding so this one for the user ID over here and then I need to have the category ID right and then I need to check if user ID exists and it is valid if it is not then I'm simply going to return a response return actually let's copy it from here user ID and let's paste it and just like this user ID I also need to check if the category ID is valid and is being added from the client so once these two condition are added I'm going to await connect to the database and uh let's find the user ID and then I'm going to check just like I've been doing previously if user ID is not existing in the database then I'm not going to let it to fetch the blogs because I only want the blogs to be fetched by the user who is uh who is existing and who have created those particular blogs okay so now I'm going to check if the uh category ID uh actually exist in the database or not so for that uh I've already checked if the category ID exists or not so I'm going to check if the category ID actually exist in the DB if not then I'm going to Simply return a response so category not found if the category is not found okay so after that um I need to fetch all the blogs based upon the user ID and the category ID but I'm not going to directly write find or find all later on I will be modifying this API to add the pagination add some sorting mechanism some search so from front end if user want to fetch the datab based upon the keywords search user want to sort the data based upon ascending descending or adding the pagination logic uh like which page and how many items user wants to fetch or uh the start date and date the range for the blocks based upon the time stamps which are stored for the blogs so for considering that I'm going to change the logic of fetching the data so filter of type any equals to and I'm going to write user uh new type user ID and category new type category ID okay uh there seems some kind of error so actually I don't need two things so now using this filter I can actually fetch all the blogs so await blog find filter uh all the blogs uh based upon this user and this category will be returned now I can simply return uh to the client that these are all the blogs with the status code 200 okay um so I think that is it later on I'll come back to this API when I need to add some filtering altering and all these uh options so let's go over here these are all the get blogs and here just ignore these rest of things I've just disabled that I've added user ID click on send so user not found let's go uh let's try to add all the users let's copy this user ID let's give the correct user ID send category not found let's get the categories category get blogs and uh this is the category ID which is automatically added in these URLs okay so and you can see that this is the API SL blogs this was the API SL categories so this is these are the things um I've added so if I add it here you can see that it is returning blogs with an empty array because there is no blog existing in the database yet but uh if it is returning the empty array it means that our API is is working fine um and here I'll come back to this so I'm simply going to add todo over here uh which is going to help me search out that um I need to come back to this line of code to add some more logic so now let's quickly add uh the post requests okay in this route so con export const post and I don't need this Con context here I would need it uh in my patch or our delete request for that again I'll be creating the dynamic route for this API just like I did it for the category okay so now for the post I will need this URL and I would need those uh user ID and uh the category ID as well within the tri block so now and for posting I would also need uh the body the data which needs to be added in the database for the blog it can it can be the title and the description okay uh but let's put all of these things within the try catch block for error handling okay so let's add error any like this and inside this error in fetching blogs okay so after this I need to fetch the body equals to await request. Json and then I can fet the title and then the description okay from the body now I need to check if user ID exist just like above so let me copy all of these things so this these two things and this one as well actually I would need this one the user not found uh and and then I would need this one as well okay so let's copy all of these things from here and I'm going to come here and I'm going to paste it okay so all of these validations if user exists if category exists uh and category found in the database and category user found in the database so all of these error handlings are required because we want to create a blog against a category and against a user if any of these are missing then we won't be able to create a blog because uh blogs must have to be created by a user and blog must have a category this is the Restriction we are applying but it's up to you you can modify it um a Blog can have uh no category as well but uh I'm modifying it in a way that it must have a category Okay so now uh we need to create a blog and yeah so let's close it like this and inside it I'm going to add the title I'm going to add the description I'm going to pass the user ID and the category ID which is passed from uh the URL from the client okay and once we have created a new instance for the blog I'm going to write await new blog save and after that I can add blog is created blog and then the new blog okay so our API is completed I hope it's going to work let's come here let's go and post a blog so first blog first blog description Let's see we have in this param we have the user ID and these user IDs are old I know that it's going to give me the error so user not found this is what I expected so in the get blogs let's copy the user ID from here post it over here and let's copy the category ID from here so both of these IDs for the category and user are existing in the database which I know okay so now so let's send now the blog is created with this title and the description along with this relationship with the user and the category and we can verify it over here by refreshing it and it is going to actually uh add the blogs model over here in the database as well and it has this title description its own ID and the ID of user which it who created this blog and the category which it belongs to okay and the created ad and the updated ad for this blog and these are going to help us sorting um and based on ascending or descending or based upon the range okay so we are done with this blogs uh one and I'm going to create the dynamic folder now just like I did it for the uh category so I'm going to create a blog within the square bracket and I'm going to create route. TS file so inside it I'm going to import everything which be I've been doing uh in this file so let's copy it let's paste it okay so now let's create a get request so in this particular uh route. file uh so on the front end application there can be a page for getting the data for a single blog okay and uh the blog ID can be existing as a dynamic uh param a dynamic value in the URL so that's why I'm creating the get single blog API in this particular Dynamic route. TS file for again for getting a single blog we need to check if user ID exists category exists uh and also the blog ID exist which will be fetched from the uh URL okay and then if all of these conditions are validated then based upon the user ID category ID I'm going to return the blog so export const get and then the context and yes I would need the context because this is the dynamic route so params callon and any okay and the arrow function and now con blog ID equals to the context. params do blog okay so let's add the tri block so let's add the tri block and also the catch block for the error and uh let's give it type any and this is going to return us the error fetching a Blog this is going to be a single blog okay so inside this try I'm going to get the search parms let me go over here and fetch everything yes so request. URL I'm need user ID and the category ID from that URL let's put it over here and after that I need to validate the category ID and the user ID let's copy it from there and I would also need the blog ID verification that this is being passed from the client side or not okay so let's copy this let's add so let's add the blog ID blog ID and then the blog ID over here as well okay and after that as always let's write connect and then um I need to check if user exists in the database and category exist in the database or not so again I can go over there and I can copy these two blocks of code all right so this is going to check the existence of user ID and the category ID in the database now I'm going to return a single blog so let's write con blog equals to A weit Blog this is going to be the model and Dot find one okay and this is going to take the blog ID equals to this underscore ID user user ID um and like this let's remove the couple of things category and then the category actually we don't need directly like this I can remove it all right so once we fetch that uh we can actually check if there is blog exist in the database with this ID or not so I can simply write if no blog exist then I can simply return a response that blog not found okay and uh once if there is no error then I can simply return one blog okay so I'm done with this API let's go over here let's go into get single blog and uh let's copy the user ID over here and let's copy the category ID I know with these uh user ID and the category ID I created that blog okay and uh this has to be the blog ID currently I don't think this is correct but let's try that out so let's send and blog not found actually user was found category was found but the blog was not found okay so here uh let's get all the blogs and yes these are the blogs let's copy the ID of this blog So currently it is returning the array of all the blogs but from here I'm only returning uh one block okay so here let's add add it as a dynamic URL the ID of the blog which exists in the in the database so on the front end side we have the list of all the blogs which we have already fetched from here by calling this API and whenever from front and side we will be navigating to the particular blog detail page we should have the URL U containing that blog ID or maybe in the local storage or maybe in the local state management system and for that we can fetch the current blog ID and pass it to to this API okay uh and then let's send and now you can see that this is the single blog which is returned from the database so our single fetch API get API for fetching a single blog is working fine now in this file just like I created the uh patch and delete requests I need to create that over here so let's quickly create the patch request first of all so I'm going to first of all copy this first line all right so rather than get I'm going to add the posts okay so inside the post uh just like above I can actually copy this catch block let's try that paste it over here so error creating uh actually not the post this is the patch okay error updating blog okay so inside this just like I've got the blog ID from here I can add it over here and inside the tri block uh I need to get uh the title and description the updated title and description which I want to be updated uh so I can click on the try and uh we can get the user ID from here and let's put that in and before that I need uh to have the search param okay search param and the title and the description from the body okay in this case for updating the blog we don't need the category it's just that the uh the user have permission to update the blog okay so after that uh we need to check if the uh blog ID exists or not uh which is being passed from the client side then we are simply going to return a message invalid or uh Missing user ID and also for just like this we can add a check for the blog ID as well we don't have the category here so we don't need that so just like this we can add the blog ID condition here okay so this has been added now let's write the await and after await we can add the check for the users and the blog just like above so let's copy these two things I'm going to modify the category block with the with the blog and uh this has to be the blog so blog dot find one and this is going to be the underscore ID blog ID and the user is going to be the user ID and I'm going to add the blog so blog not found this is the error message I will be returning to the client all right so after that we need to actually update it so we first need to uh check if uh with the ID and then we can actually check it updated blog await and then blog do find by ID and update and then inside it uh I can pass blog ID title description and then the new true okay once that is done and now we are simply going to return a success response with a Blog updated like this okay so let's save the file let's go to the updated blog let's go to the params we need to pass the user ID the correct user ID so I'm going to copy the correct user ID which is existing in the database from here user ID it is added over here automatically and we need to pass the correct ID for the blog which we want to update all right so this has been updated now let's let's go to the body blog one updated blog one description updated and if I go over here you can see that first blog first blog description I want to modify it so let's click on the send and now it has returned me blog updated let's see if it is updated in the database let's refresh and the title and description of it should be updated and yes you can see that the title and description have this updated keyword at the end all right so quickly I'm going to add a delete request and for delete request we need the same kind of stuff uh the validations and all of these things so I'm simply going to be adding it one by one I don't want to waste your time so this is the line which I've added and now inside it I'm going to add uh this one params blog and here inside the try catch let me add the tri block and also the catch block and it is going to return error in deleting the blog and inside the triy block we can get the search param from the URL like this and after that we can actually uh check if user ID or the blog ID exists uh which is coming from the client exist in the URL or in the body okay uh in this uh you both are in the URL actually all right so after that let's again do the connection and let's again to uh check for the user and then the blog just like we have done above so let's go over here let's copy these two blocks of code let's go down after disconnect I'm going to paste these two things and once that is done I can simply uh run this command await blog find by ID and then the delete okay and then I can actually return a response that the blog is deleted successfully with the 200 status code all right so that is done let's go over here let's click on the delete we need to pass the current blog ID over here the correct one the blogs blog ID this one and the user ID user ID exists here so I'm simply going to add the user ID over here and let's try to send this out so blog is deleted let's verify it from the database okay so no results so blog is successfully deleted okay uh So currently there is no blog found I'm going quickly going to add a new blog over here because I'm going to modify this particular get blogs API uh with different kinds of conditions different kinds of logical uh things like filtering pagination sorting and all of these things so I've opened up this main route. TS file because uh the multiple blogs will be fetched on the main homepage where you want to see all the blogs list okay so this API is returning multiple blocks because we are fetching it using the find okay uh so this is where all the filtering all the searching and all the pagination is going to work so that's why I've chosen this particular API to perform all of these operations so let's go ahead and per and show you that how we can add all of the these things so first of all I'm going to add let's say search functionality or a search keyword all right so let's say on the UI you have a search bar and when you write something on the search bar you want to fetch all those blogs uh which have that keyword uh exist anywhere in the title of any blog if there are five blogs then if title matches in two blogs only two blogs should be returned so let's first fetch it from the client side from the postman just like we are getting it uh the category ID and the user ID so I'm going to write keyword actually Search keywords for the variable equals to search param and the value which is going to be passed uh the key is going to be the keywords from the client side and also for error handling uh for any kind of types scripting we can also add as string for this keyword because the keyword is going to be of typ string from the client the postman okay so once we are receiving this search keyword uh we added this filter object over here which we can keep on modifying before finding the blog okay so for modifying the filters let's first verify if search keyword actually exists okay and and then if filter Dot and mongus actually provide a lot of builin functions for aggregation for checking and or uh and all of these things so I want to check this keyword in the title and then in the description as well okay so in order to do that I can write this dollar sign or uh actually it should be an array okay and then there has to be this object so so title this is going to be receiving the Rex and then the Search keywords and after that I need to pass the options and this is going to be I okay and then we need to have it for the description colum and then the reject and then this option I so this or means that the search keyword should exist either in title or in description and uh this is how it is uh checking it and option I means that it is case sensitive irrespective of case whether it found it in the lower case or the upper case it should still return us the response okay so now that's it we need to add for the search keyword in the title and the description for the blogs I'm going to go over here and these are all the get blocks I'm going to enable this keyword okay now it should be added in the URL you know the keywords and then the first all right so now let's try to get that and now error fetching blocks cannot use reix with string so there seems some kind of error if string filter or array and then the title actually Rex it has to be the Rex not Rex okay let's save it and let's send and now you can see that it has returned us this first block because the first keyword was existing in both title and the description so or means that either in both or in one okay if I try to change it something like AB c d in the keywords now this keyword is not found in both in first and the uh title and the description so let's send this out and you can see that blogs are empty because this key word does not exist so on the front end this is how we can perform the search operation and get the data from that API okay you can create a new blogs and you can test that out in fact let's go over here and let's add the second blog and the second blog description let's send that out and let's get all the blogs uh ABC is not found anywhere uh so let's add the second let's send and the second is found which is newly created which we have just done it okay so now let's move further and here let's get more values we are going to get uh this thing let's remove it it's not always required so now search params doget start date and then start date and then con and date date and then end date okay so now if we have a calendar on the front end and we want to find all the blogs based upon the uh start date uh or end date or a range between start date and end date like return me a Blog which was created between 2023 and 2024 or uh give me all the blogs before uh 202 22 okay or any date or even we can pass the month day and the year as well okay so if we pass one it is going to be a starting value and it's going to return all the blogs starting this value up to the end date okay uh up to the date which is current date today okay so now let's go over here and we can modify this filter just like we have done it and for modifying this let's first verify if start date and end date both exist it means we need to check the range uh we need to return the blocks between this so we can have filter do created at and then this and then mongus provide GTE so let's let's select the tab 9 a assist g means that greater than equals to LTE means that less than equals to so start date so return all the blogs U which are greater than and equal to the start date and less than and equals to the end date all right and I'm going to write else if if start date exists then what happens okay and end it does not exist we don't need to check if end it does not exist because if both exist it will be triggered okay otherwise uh this would not be triggered uh so now I can write greater than equals to only return all the blogs which are greater than equals to up to the current date today okay of the recent date now lse if if end date exists only then we are going to filter with lower than less than equals to the end date now this will automatically be appending and we don't need to modify ify this we just are modifying this filter okay let's remove this todo and now uh let's enable this end date now so end date means that uh before this date all the blogs should be returned I'm going to remove this keyword let's remove this keyword let's send so you can see that the two blogs are returned uh because uh all these blogs were created before this date this is why I've added this end date all right and if I write change the year let's say 2022 I hope that it's going to return empty array because before this dat there was no blog created so let's hit send yes so there was no blog so let's uh for our testing purpose let's add 2025 all right so now this is how it is returning the response what's next uh I want to let's say that you can also pass a sending a sending keyword uh from the URL from the client side uh which you can test yourself but in order to append this filter let me quickly show you how you can uh update that uh this is one small assignment if you are practicing with me during this tutorial uh you can also add uh dot sort and then I can write the created at colon and here I can pass as c not to sorted but sort okay um what happened here actually I need to remove this and you can fetch this value from the search param and put it over here whether it is DSC or ASC and based upon this we can sort this data out okay uh this is something you can do and try yourself now I'm going to add the pagination so how pagination works we have multiple pages one page page two page three and then we have the limit that how many items needs to be visible on a particular page so uh we need to find a formula so first of all I can receive couple of things from the client so I can write the page equals to the search param and then the page um if there is no page returned from the client side then I'm going to set the by default page as one and then the limit has to be 10 okay limit means how many blogs needs to be visible now let's save this file and here let's go down before actually triggering this I'm going to uh actually create a formula for the the skip skip is a builtin function provided by mongus that's why we need to calculate that so skip means that on a particular page how many blogs needs to be skipped so let's say there are 10 blogs on the first page on the second blog the blog will be visible from 11 to 20 on the third page the blog will be visible from 21 to 30 and similar on 11th page blogs number will be visible from 1 to 110 okay so the formula is Page minus one multi by limit okay so it is giving some kind of error so let's see uh right hand architecture must be of type any so for that I'm going to go up so this is giving us a string so I can actually write par and and wrap it around like this okay so it seems it is giving some kind of error let's go down okay so there is no error uh but let me hover over it argument of type string now is is not assignable to it so I can add any to it and any to it and then we have this search ps. getet page actually I'm going to add it like this and remove it from there okay so now the error is gone and we are not getting any error over here so if page is two then 2 1 = to 1 then 1 * 10 = to 10 okay so skip means that uh skip first 10 blocks and start fetching the blocks after this skip value means after 10 so for page two the blocks from 11 will be returned so if page is let's say three then 3 1 2 2 * by limit which is 10 10 * 2 = to 20 and the skip first 20 blogs and start returning the blogs from 21 so the 21 1 to 30 blogs will be returned for page number three so this is the formula now how to apply it over here so now I can write a page and the limit property over here uh actually the limit and the skip okay so first of all skip has to be Skip and then the limit has to be the limit okay so this is automatically going to work I don't have so many blogs so I cannot test that uh I don't want to waste your time so if you have a lot of blogs you have created that you can test that out but if I pass page one limit one if I don't pass it still it is going to take the default values the one and the 10 okay but if I want to modify this I can modify it from the front end U like his like this okay so let's send okay it is going to return the same response because I'm at the page one and the 10 if I change it to page two it should return empty array because on page two the block number from 11 to 20 should be returned so we don't have that much blogs so let's test that out and yes on page two there are no blogs uh that's why it has returned empty array so let's skip it one so let's send this out all right so there are more filtering options provided by you can check out the documentation of and if you want to learn more about the filtering options and all of these things uh then yeah you can go to the docs and uh on my personal Channel I've created a long tutorials on node Express mongodb where I've talked about all the aggregations as well for filtering the data out from the database using mongus Okay so let's save it now next thing we are done with uh all of these apis now I want to talk about middle Wares how we can protect over back end how we can add the middle Wares for logging for intermediate error handling for our apis so let's talk about that we don't need to do anything in these files next thing I'm going to create a new folders but before that let's create a file which is recommended by which is given by next yes we cannot change its name and middleware file runs before every request on the front and side before every route on the back end before every API requests okay so this is something we can utilize to uh add further middle Wares in order for logging error error handling um or other uh API protection rules so I can start off writing by importing this next response from next server and uh after that I can export con config equals to and I can add the matcher that uh it should match and trigger in all the files exist inside the this API folder okay and uh after that I can write export default function middleware request request okay and inside it I can simply return next response do next for now okay and if I go ahead and try this out get users and it's still working and that is fine because I've not added any checks inside it so before that let's go ahead and create a new folder over here and that is going to be the middle Wares actually this is the file I have to create middle Wares uh this has been created I'm going to delete that and now let's create a folder middle bears and inside it I'm going to to create another folder API this is just for organizational purpose because I want to separate out the middleware Logics for the apis and if later on I need to add front end I can add a client folder inside middleware folder so now inside the API I'm going to create Au middleware and I can name anything o middleware dots okay so o middleware is going to be checking that if the beerer token from the client side from the postman is passed or not if it is not passed then I'm going to throw an unauthorized error for all of these apis and I'm going to show you the different checks that we can have like the for users I can keep it public and for categories and the blogs I can keep it protected until and unless the beerer token is not passed there are a lot of token types like if I go to this uh drop down O type and you can see that this is the be token basic o JWT o o uh in nextjs usually when we use the third party services like the next o aujs or the clerk authentication kind authentication Au zero uh they provide session ID client ID and using that we can process our middleware to protect our apis as well as frontend routes in every my video of clerk authentication o zero kind O next o which I've have created on my personal Channel I have shown that how we can protect our API routes uh using their provided method using the cler provided method next or provided method and other services provided method so but this video here in this function I'm going to have a simple logic that in case you are not using third party Services still you want to protect your routes based upon the beerer token or any other token TP type or simple Boolean value you can do that how you can do that in the middleware file so this is uh what I want to add here so now uh let's first of all add cost this is not a real beer token I'm not creating any uh login sign up pages on the front end or the client side but this is going to be I'm I'm mimicking the behavior of the real be token if it exists real or false you can check that out out uh uh then we need to protect our routes if it does not exist uh we are going to uh U not allowed user to access these API so now let's say let's create this utility function first of all so this is the token any Arrow function and inside it let's give it valid token you can validate it based upon your own rules which you are using you can use JWT verification encrypt bcrypt whatever you want and I'm just checking that it is already valid but it should exist actually coming from the client side now I can check if uh not valid token or token does not exist then I'm simply going to return false if uh it is not validated or the token does not exists then I'm simply going to return false otherwise return true okay so now I have this function Au middleware request and then the response let's use only request a return type any and here I can write token equals to request. headers doget and from the client side whenever we pass these kinds of beer token let's say I can add over here this property will be added over here authorization beerer like this okay uh so from the client side we use exos or fetch and in the headers on the client side we can actually pass these values So currently let's remove it and now I can get the beer token from the authorization property and uh this is going to be the beerer and then space then actual token so I can split that out so split with an empty space and the second value from that splitted array okay and then I'm going to return is valid colum validate token uh this is going to be the validate this is what I'm going to be using so valid it and I'm going to pass the token okay this has to be an object actually like this okay so this is will be triggered by this file which I'm just going to import and when this is going to be triggered this is going to get the authorization beer token by splitting that out as a second value and this is token is going to be passed to this utility function and this is going to validate if it's true or false or token exists or not based upon that it is returning true or false now let's use this o middleware in our middleware dots file so let's first of all import that instead direct we can directly use that it will be automatically imported above okay so now let's use const Au result equals to AU middleware from middleware you can see there is automatically imported and then I can pass request to it okay this is the request I have passed to it and from this request it is going to fetch out the headers once it is going to be passed that function is going to return me is valid whether it's true or false now I can actually check if Au result dot is valid then I'm going to return the response new next response stringify unauthorized if it is not is valid means if it returns false then it is not it is going to return us unauthorized otherwise it is going to give me access to all the apis and along with this I can also pass up and and checks as well let's say request. URL uh this has to be the request. URL do includes and then slash API slash blogs okay so uh actually this is request all right so it means that this has to if it is invalid or this is blogs then I'm going to return unauthorized so I'm always unauthorized uh I'm I'm making a check that uh this token is applicable only with blogs okay and this validation is not applicable with the uh other apis like the categories or the users so for now let's go over here let's try to fetch the users you can see that I'm able to fetch the users because this validation for un authorization is only being applicable on this blogs okay if I go to the blogs and try to fetch the blogs now you can see that this middleware executes before every API request that is going to happen all the API request Within These blocks because I've added the checks for the blocks for now I'm just going to show you that uh this is how you can add checks you can U add the blogs slash something like that you can be specific which API should be added along with this BR token validation so for now I'm just going to remove this thing so now it is applicable for all the API request irrespective whether it's user whether it's categories or the blogs okay now if I go to the get user send and now it is unauthorized now how to make it authorized uh let's pass this beer token in the headers then it's going to return me true okay so let's go and select the beerer token from here and I'm going to use beerer and then this is not a real token I'm just mimicking the behavior usually be token is a combination of uh you know uh this this kind of thing now I've passed this brra token now let's send now you can see that I'm able to fetch the value because I'm passing the beer token for for posts as well for update for get categories let's try to get the categories unauthorized let's pass the beerer token like this now I'm able to get the categories from the database okay now this middle Weare is running before every API request this is what I'm trying to explain you guys now let's say that I want to add multiple middlewares for logging I want to log some information in my database that which API request uh was triggered and what was the method type for that API okay so uh now let's go and in the API folder and I'm going to actually not the folder the file and I'm going to add log middleware dods okay and in this particular middleware I'm simply going to export function log middleware request of type request okay and this is going to Simply return the response column request uh request. method append it with with request dot URL okay this is the simple logging and we can modify this logging operations by our own data all these things and now let's log the information uh before every API request that is going to be triggered let's come inside this and I want this loging information for only blogs API and just like I have added this condition I can add this condition for uh logging the information for only blogs API so for that I can actually add uh request do url. includes SL API blogs so it is only going to work with this blog API if you want you can remove this condition as well so now const log result equals to log middleware this has been imported and let's pass the request to it and now I can simply log the result by uh log result. response all right so let's save it now uh let's trigger that out uh this is only going to work for blogs so let's get the blogs let's send unauthorized let's add the beerer token and let's add the value send now I'm able to fetch the blocks let's go over here and now you can see that this is the URL got triggered this is what it printed this is the method type this is the URL it printed uh and we can add more information and this is the uh this is the thing that it has printed actually I think this is the one okay yeah uh so and we can modify this one and uh let's pend yes to it okay and see which URL is this let's hit send and let's come here and yes this is the URL and we have this yes appended after that uh so this is how it is working and we can add as much middleware as we want and if you want to remove this you can remove it and add some more conditions as well and our routing is protected over apis are protect protected um and over logging middleware is working fine so we are done with creating apis now it's time to deploy over nextjs application with this whole back back end of the rest API on the versal so let's go ahead but before that I'm going to first verify if there are no issues in my code because versal run this command npm run build so before deploying that I'm going to verify that if there is no error here then there won't be any error on the versal usually there is no error on versal uh but let's verify that so it's currently building that till now if you have learned something new if you have liked my tutorial uh I would request you guys to check my YouTube channel from the description of this video and do subscribe my channel as well so I think there is no error yes there is no error now I'm going to open up the GitHub and I'm going to deploy my application on versal so first of all let's go ahead on the GitHub and create a new repository and I'm going to give it a name next 14 rest apis uh yes and uh I'm going to leave it public because you will get the link of this repository from the description of this video and uh do give it a star guys so let's not add read me let's leave it by default let's click on the create repository so it's going to gets created and first of of all I'm going to open up this G ignore and I'm going to add EnV file over here I don't want to put EnV here uh I will manually be adding this uh mongod DB URL in my versal environment okay so now let's add get status these are all the changes and uh I'm going to write git add Dot after that I need to commit that out so let's copy this commit command let's add over here and this is committed and I'm going to copy all of these three commands at once so I'm going to add it over here and let's hit enter so this is pushed let's restart okay the page is reloaded and these are all the changes I have just pushed okay and uh there is no EnV file this is perfectly fine now I'm going to open up versal decom and uh I'm going to add a new project and these are the all the uh repositories which I have added in my account I've already added my account inversal uh so now let's go and import this particular repository and before clicking on deploy let's go to the environment variable and I'm going to open up EnV let's let's copy everything from here and I'm going to paste it directly here all right so now uh let's click on deploy okay so it's going to take some time in order to deploy that so let's wait for it all right guys so our project is deployed you can see congratulation and it is showing the default UI on the front end this is the default UI when we create a new nexj project although I did not touch the front end part of next JS so but still it is showing the default UI from the homepage I'm going to go and continue to the dashboard and it is going to give me the URL where our app is deployed this is the URL okay I'm going to open this up and our app is deployed now let's copy this base URL earlier we were using Local Host 3000 and currently we have this one and I'm going to add it rather than Local Host 3000 okay and let's try to trigger this currently it's showing unauthorized uh it means apis are working that's why it is showing unauthorized but uh we need to pass the beerer token so let's go and uh let's get all the blogs okay so but I'm going to replace Local Host 3000 with the deployed instance that we have the next 14 rest API and now let's see because the database is same still it should return on the same data which was returning on the Local Host so let's hit enter it is taking some time because it is a deployed instance so let's see and now guys you can see that it has returned me this data with this deployed URL so our deployment is working and we are passing BR token earlier um on the browser we had this unauthorized let's try to get the users as well because we are passing the beer as well so I'm going to replace the base URL with the deployed version okay and let's hit send and now you can see that it is not throwing unauthorized error in fact it is giving us this URL the the the data in the Json all right guys so I hope that you have learned something new from this video if you have liked my video let me know in the comments of this video and again guys do check out my YouTube channel as well for more videos on nextjs so hopefully I will try to create more videos on free code camp and I would like to thank free code camp for giving me the opportunity to create a tutorial for this channel so guys thank you so much for watching see you
