With timestamps:

00:00 - this eight hour course will teach you
00:01 - the fundamentals of node.js and express
00:04 - so you can start creating backend and
00:07 - full stack web apps using javascript
00:10 - this course was created by john smilga
00:13 - john has created a bunch of courses
00:16 - including many of the more popular
00:18 - courses on the freecodecamp youtube
00:19 - channel
00:20 - john's teaching is very hands-on so you
00:23 - will create a bunch of projects while
00:25 - you're learning what's up everybody this
00:27 - is john from coding addict and welcome
00:30 - to node and express tutorial video where
00:34 - we'll cover fundamental building blocks
00:36 - of node and express js framework now
00:40 - since i want everyone to be on the same
00:42 - page we'll start the series with node
00:45 - and express fundamentals and gradually
00:47 - move to more complex topics we will
00:50 - build complex rest api with express.js
00:53 - as well as full-blown mern application
00:57 - in this comprehensive node.js course
00:59 - you'll not only learn fundamentals of
01:01 - node but also many related technologies
01:05 - like express.js framework mongodb
01:08 - as well as mongoose the main goal of the
01:11 - course is to show you how to build
01:13 - modern fast and scalable server-side web
01:16 - applications with node
01:18 - like in all my other courses to solidify
01:21 - our knowledge we'll build a bunch of
01:23 - cool apps and go through the steps of
01:26 - deployment as well
01:28 - lastly let me just say this if you're
01:30 - like me and you enjoy learning new tech
01:33 - by building projects
01:34 - instead of going through the slides you
01:37 - will enjoy this course
01:38 - all right and let's start by answering
01:40 - the most obvious question first what is
01:42 - node.js
01:44 - and even though there are plenty of good
01:45 - answers out there the one that i like
01:47 - the most is this one
01:49 - node.js is an environment to run
01:51 - javascript
01:53 - outside of the browser
01:54 - node.js was created in 2009 and it's
01:58 - built on top of chrome's v8 javascript
02:01 - engine
02:02 - as you probably are aware of every
02:04 - browser has an engine a tool that
02:07 - compiles our code down to machine code
02:10 - and chrome uses one by the name of v8 in
02:14 - extremely simple terms the creator of
02:17 - node ryan dahl ripped out the v8 engine
02:21 - and build node on top of it since the
02:23 - moment it was created node has evolved
02:26 - tremendously
02:27 - and while there are many things to like
02:29 - about node i particularly enjoy large
02:32 - community around node since that
02:35 - tremendously saves time on feature
02:37 - development as well as the fact that
02:39 - with the help of node it's never been
02:42 - easier to build full stack apps since
02:44 - both front end and backend are
02:46 - essentially built in the same language
02:49 - and you guessed it that language is our
02:52 - beloved javascript as far as course
02:55 - requirements go
02:56 - there are not that many
02:58 - my expectation is that you are familiar
03:00 - with basic html elements simple css
03:05 - rules and have general understanding of
03:08 - javascript especially es6 callbacks
03:12 - promises and a sync await
03:15 - since this is a node course
03:17 - and i already have tremendous amount of
03:19 - node content to cover i'm not going to
03:22 - spend too much time on javascript
03:25 - language fundamentals
03:27 - while you can still follow along with
03:29 - the course without knowing basics
03:31 - it's crucial if you want to understand
03:34 - how stuff works behind the scenes
03:36 - as a side note if you need to brush up
03:39 - on the javascript fundamentals i have a
03:42 - youtube channel called coding addict
03:44 - where i post a bunch of cool javascript
03:47 - related content
03:48 - specifically you might be interested in
03:51 - js nuggets playlist where i cover a
03:53 - bunch of useful es6 features as well as
03:57 - asynchronous javascript topics so if you
04:00 - need to jog your memory on javascript
04:02 - fundamentals i suggest going to youtube
04:05 - look for the channel by the name of
04:07 - coding addict and then more specifically
04:10 - the playlist by the name of javascript
04:13 - nuggets when it comes to course
04:15 - structure it goes something like this
04:18 - in first section we'll get familiar with
04:21 - node.js
04:22 - as well as my dev setup
04:24 - in the second section we're going to
04:26 - install node.js and quickly cover some
04:29 - general differences between browser.js
04:31 - and node.js
04:33 - then we'll spend some time on node.js
04:35 - fundamentals in section 3 and after that
04:39 - we'll learn what is express.js in
04:42 - section number four
04:43 - and once we're done with node and
04:46 - express fundamentals so once we're done
04:48 - with pleasantries
04:50 - then we're after the races where
04:52 - effectively in every section after that
04:54 - we will build a bunch of cool node.js
04:57 - apps all right and before we install
05:00 - node let's quickly cover some major
05:02 - differences between browser javascript
05:05 - and node.js so essentially how node.js
05:08 - apps are different from the browser
05:10 - javascript apps
05:12 - and let's start with the biggest one
05:14 - when working on node.js app you have no
05:17 - access let me repeat no access to
05:20 - browser apis
05:22 - since well they don't simply exist in
05:25 - node there is no browser so there's no
05:27 - dom there's no geo location no fetch and
05:31 - all the other cool browser goodies you
05:34 - see unlike browser apps that are
05:36 - interactive for example user clicks the
05:39 - button or toggles the nav and that sort
05:41 - of thing
05:42 - with node we build server side apps
05:46 - and i know it's hard to picture that
05:48 - right now but
05:49 - our node apps will only consist of pure
05:53 - logic without the graphical interface on
05:56 - that note you know how in browser apps
05:59 - we use a bunch of cool things available
06:02 - on the window object
06:04 - yeah sorry to break it to you but that's
06:06 - also not available in node
06:09 - so at no point in the course we'll write
06:12 - document.queryselector
06:14 - all right
06:15 - and once we have covered things that
06:17 - node.js does not have let's switch gears
06:20 - and see some of the goodies that node
06:22 - has to offer for example unlike browser
06:26 - we can access file system
06:28 - info about our operating system respond
06:31 - to network quests just to name a few
06:34 - also another major benefit of node is
06:37 - the fact that it's based on versions
06:40 - so unlike browser apps which depend on
06:42 - the user's browser
06:45 - our node app depends only on node.js
06:48 - version it was built in
06:49 - so in other words if we build a browser
06:53 - app
06:53 - and if our user's browser does not
06:56 - support a specific feature
06:59 - it is our responsibility to fix it
07:01 - otherwise our app might have bugs
07:04 - correct but when we're done building our
07:07 - node app there's no rule that we have to
07:09 - upgrade to a newer node.js version
07:12 - and possibly break our app
07:15 - we simply can keep running our node app
07:17 - in the version it was built in and
07:20 - without any worries go on about our day
07:23 - lastly unlike browsers where modules are
07:25 - optional
07:26 - in node.js you have access to modules by
07:28 - default and it's hard to imagine a node
07:32 - app where you're not going to use them
07:35 - as a quick side note under the hood
07:37 - nodejs uses common js library for the
07:40 - modules and while the general idea is
07:42 - exactly the same as for the es6 modules
07:45 - that we use in the browser syntax is a
07:49 - bit different
07:50 - as far as the install it's as
07:51 - straightforward as it gets
07:54 - just navigate to nodejs.org pick a lts
07:57 - version
07:58 - answer yes to all the questions
08:01 - and if you don't get some weird bugs
08:04 - congrats you have installed node
08:06 - in order to check if everything went
08:08 - correct just type node
08:10 - version in your terminal
08:12 - and you should see the version number if
08:14 - you don't you'll have to troubleshoot
08:17 - the error now as much as i would like to
08:19 - help
08:20 - when it comes to install it's impossible
08:23 - for me to troubleshoot your local setup
08:26 - so when it comes to troubleshooting
08:28 - install errors i strongly suggest using
08:31 - your favorite search engine instead
08:34 - typically within a matter of minutes
08:36 - you'll see a bunch of useful solutions
08:38 - to your exact problem
08:41 - lastly let's also talk about versions as
08:43 - you can see at the time of the recording
08:45 - i have two options
08:46 - 14 lts
08:48 - or 15 current one
08:50 - if you read the note docs you'll see
08:51 - that for production apps they always
08:54 - suggest using lts which stands for long
08:58 - term support and therefore i will also
09:01 - suggest the same but as far as tutorial
09:03 - i don't think you'll have any issues if
09:06 - you use the current version instead now
09:08 - also since you're watching this in the
09:10 - future your version number most likely
09:13 - is going to be greater than 14 basically
09:16 - greater than mine i definitely suggest
09:19 - installing the lts option
09:21 - that's offered to you instead of
09:23 - downgrading to my version and if you're
09:25 - stressing about content being out of
09:27 - date
09:28 - let me assure you that everything we
09:30 - cover in the course will work perfectly
09:32 - fine with your current note version
09:36 - and eventually if some bugs do creep in
09:40 - i will definitely update the course
09:42 - content so long story short just install
09:45 - your current lts version whatever it is
09:48 - and you'll be in good shape so in my
09:51 - case it is 14
09:53 - i have two big buttons and of course
09:55 - since i would want to go with lts i'll
09:58 - click on left one
10:00 - then notice we are getting the download
10:03 - package and now i just need to go to my
10:05 - downloads
10:07 - and then crack it open
10:09 - and then like i said we just need to
10:11 - answer yes to all the questions so we go
10:14 - with continue
10:15 - continue
10:16 - and yep i would agree
10:18 - and again we just install and then we'll
10:21 - be prompted for our passport
10:24 - and once we add that one we should be in
10:28 - good shape and then like i said once the
10:30 - install is complete
10:32 - and yep we'll move this sucker to the
10:34 - trash then if we go to our terminal and
10:38 - if i massively zoom in
10:40 - and if i type node
10:42 - version
10:44 - there it is i should have my version
10:46 - number which in my case of course is 14.
10:49 - if you also can see the node version in
10:52 - your terminal you are in good shape and
10:54 - you can continue
10:56 - with the videos
10:57 - if not
10:58 - please troubleshoot it because otherwise
11:01 - everything we're about to do next is not
11:04 - going to work since you haven't
11:06 - installed node
11:07 - on your computer
11:09 - install is complete hopefully we all
11:11 - have node on our machines now what
11:14 - what do we do
11:16 - for contrast with vanilla.js it was
11:18 - somewhat easy right we create index.html
11:21 - jam our javascript code whichever way we
11:24 - prefer and browser does the rest it
11:27 - evaluates our javascript code but
11:30 - what about node how do we get node to
11:33 - evaluate our code
11:35 - and effectively we have two options
11:37 - a repl which stands for read eval print
11:42 - loop and cli executable which just means
11:45 - running our app code in node if i have
11:49 - to be perfectly honest reply is for
11:51 - playing around and cli is essentially
11:54 - for everything else in fact this is
11:56 - going to be the first and most likely
11:58 - the only time we'll use a rebel in this
12:01 - course and after that cli is going to be
12:05 - our best friend how do we spin up the
12:07 - rebel well
12:09 - we go to terminal and in terminal we
12:12 - simply type
12:13 - node and then no arguments nothing we
12:16 - just press return or enter however you
12:19 - would like to call the button and that's
12:21 - it now notice we have this little angle
12:24 - bracket that just means that we are in
12:27 - the rebel and once we are in a rebel we
12:30 - can do reply things what would be a
12:32 - first ripley thing we can do well we can
12:34 - simply type our name so cons
12:37 - and the name is equal to john
12:40 - and there it is of course now i can
12:42 - access name and my name is john
12:46 - as you can see
12:48 - you're not going to write anything
12:49 - serious in here and if you have written
12:52 - any vanilla javascript apps you know
12:54 - that of course we can also do the same
12:56 - thing in a browser console
12:59 - so we can also evaluate some code there
13:01 - but of course we're not going to write
13:03 - anything serious in a browser's console
13:06 - so the same thing is for reple yes we
13:08 - can come here we can play around but
13:10 - when it comes to serious applications of
13:12 - course you'll pick a cli executable
13:16 - instead and in order to close the repo
13:18 - we simply go with control and c
13:22 - and as you can see we have suggestion
13:24 - that we need to press it again and now
13:25 - of course we're out of the rebel not bad
13:29 - that bad we now know how the ripple
13:31 - works
13:32 - but what about a more serious node
13:36 - application
13:37 - how do we get node to evaluate our code
13:41 - well we would need to start by creating
13:44 - a project right so back on my desktop
13:48 - i'm going to create a new folder
13:50 - and surprise surprise i will call this
13:52 - tutorial why well because we'll do
13:54 - tutorial things
13:56 - and i'm going to say tutorial now of
13:59 - course if you want you can add node but
14:01 - i'm just going to leave it as a tutorial
14:04 - and then of course we'll have to use our
14:06 - text error in my case like i already
14:09 - previously mentioned i'm using visual
14:11 - studio code
14:12 - and my preferred method is just drag and
14:15 - drop
14:16 - and then instead of the folder what i
14:18 - would want is to create a new file and
14:21 - this is the case where you can literally
14:24 - name it whatever you would want and in
14:26 - my case i'm going to go with app and js
14:30 - and in this app.js okay now we want to
14:33 - write some more serious node program and
14:37 - the program is going to be following
14:38 - where there is a const so there's a
14:41 - variable by the name of amount and as a
14:43 - side note i'll make this bigger and i'll
14:46 - probably bump up the font size just so
14:48 - we can see a bit clearer
14:51 - so we're gonna go with const and not
14:53 - also close the sidebar hopefully you see
14:56 - that i have the file by the name of
14:58 - app.js
14:59 - and like i previously mentioned we're
15:01 - going to have a variable by the name of
15:02 - amount and it's going to be equal to 12
15:06 - and now let's set up a if condition
15:08 - where if amount is less than 10 then we
15:11 - simply cancel log small number and
15:14 - otherwise we'll just say that the number
15:16 - e is large so we go with if
15:19 - and we're looking for amount
15:22 - is less than 10 and if that is the case
15:25 - we go with console log and we'll just
15:27 - say
15:28 - small
15:29 - number
15:30 - and otherwise if it is of course equal
15:33 - or bigger than 10 then we go with
15:35 - console log and we say
15:38 - large
15:39 - number
15:40 - and at the end of the day we just write
15:43 - console log hey it's my first note up as
15:46 - you can see an extremely complicated
15:49 - functionality and in this case i'm just
15:51 - going to set up the template strings so
15:53 - you understand that of course we can use
15:55 - them here as well i'll say hey it's my
15:59 - first
16:01 - node app and if you want of course you
16:03 - can jam the hello world there somewhere
16:05 - as well since that is the traditional
16:07 - approach with the first program
16:09 - and then in order to execute this code
16:12 - we effectively have two options i can
16:16 - navigate back to my terminal
16:19 - and i can zoom in like so and of course
16:22 - now i'm in a root so i would need to
16:24 - navigate to the desktop and probably the
16:28 - fastest way is just typing cd and drag
16:31 - and drop
16:32 - my folder here okay so now as you can
16:35 - see i'm in the tutorial and in order to
16:40 - execute my code i just need to type node
16:44 - and then app.js now keep in mind that
16:48 - technically i could have done that from
16:51 - the root
16:52 - we just need to provide the full path
16:54 - where i go to users blah blah blah and
16:56 - then tutorial and of course the file
16:58 - name is app.js and let me bump up the
17:01 - font size even more and the moment we
17:03 - run it check it out we have large number
17:07 - and hey it's my first note app now if
17:10 - you don't believe me
17:12 - we can go back and we for example can
17:14 - say that the number is nine
17:17 - and of course again we would need to run
17:19 - the code
17:20 - and we're gonna go with node and then
17:23 - app js beautiful we have small number
17:27 - and we still have our hey it's my first
17:30 - node up again the whole point of this
17:33 - line here is just to showcase that not
17:36 - only we can use quotation marks but also
17:39 - we can use the template string as well
17:42 - so that's one option but if you're
17:45 - familiar with vs code you know that it
17:48 - has this cool feature of integrated
17:51 - terminal where effectively we have our
17:53 - terminal
17:54 - but
17:55 - it is right away pointing to our folder
17:58 - so we don't need to do this whole dance
18:00 - where we navigate to the folder and then
18:03 - run the app we simply can open this up
18:05 - and the shortcut is control and tilde
18:09 - and also keep in mind that of course you
18:11 - can navigate through the tabs the
18:14 - problem is that i always forget where it
18:17 - is and effectively we need to go to view
18:20 - and then you're looking for this
18:22 - terminal command here
18:24 - as you can see this would be a shortcut
18:27 - and tilde and in here we have nice
18:29 - suggestion that we already located in
18:32 - tutorial folder and what do we need to
18:35 - do well again we just go with
18:37 - node
18:38 - app.js why well because that is my file
18:42 - name so for the remainder of the course
18:44 - i'll use the integrated terminal that
18:47 - comes with this code just understand
18:49 - that both of them effectively do the
18:51 - same thing and there it is now i run
18:54 - node app.js because that of course is
18:57 - the file name and i have small number
18:59 - and hey it's my first node app and
19:03 - that's how we can evaluate a more
19:06 - serious code using node as i note if at
19:10 - any point during the course you need to
19:12 - compare your code to mine just navigate
19:15 - to website
19:17 - johnsmilk.com and the website is
19:20 - johnsmega.com and then either in the
19:23 - project page or in the homepage you'll
19:26 - find node express tutorial project so in
19:30 - the homepage you'll find it in the
19:31 - latest project so just keep on scrolling
19:34 - but if it's not here it's definitely
19:36 - going to be in the projects page and you
19:38 - can even filter it in order to save some
19:40 - time so look for node in here like i
19:43 - said the project name is node express
19:46 - tutorial and not any of these links
19:50 - will get you to the repo and at this
19:53 - point you can either clone it 4k
19:55 - or just simply download and you're
19:57 - looking for this node tutorial and in
20:00 - here you'll find
20:02 - all the folders as well as the files now
20:05 - keep in mind that eventually when we
20:08 - start working on express
20:11 - we'll have to get this repo anyway
20:14 - because i'll use it for starters since i
20:17 - have prepared some assets for you some
20:20 - assets that we're going to use in our
20:22 - examples so this is really up to you if
20:24 - you want you can get it right now just
20:26 - keep in mind that you'll have to get it
20:28 - later anyway and once we have executed
20:31 - our first code in node
20:34 - let's quickly cover the concept of
20:37 - globals
20:38 - or global variables in node
20:41 - and the emphasis is on the word quickly
20:44 - yes there are more global variables
20:47 - available but the idea
20:49 - is not to spend half an hour in slide
20:51 - bill instead i would want to give you a
20:53 - general idea
20:55 - and as we progress with the course don't
20:57 - worry
20:58 - we will implement them
20:59 - and that way you can right away see them
21:01 - in action not just some random general
21:05 - description
21:06 - and before we continue let me just
21:08 - mention
21:09 - that throughout the tutorial
21:11 - the code from the previous video
21:14 - i'm going to save in a file so for
21:17 - example remember our first
21:19 - complex app
21:21 - with a mount and all that
21:23 - so what i did
21:24 - i created a file name by the one
21:27 - hyphen intro js and then i just copy and
21:31 - paste it this is what i'm gonna do
21:33 - throughout the no tutorial part of the
21:36 - course so that way you can always have
21:39 - access to the code and if you ever need
21:42 - to you can jog your memory now if you
21:43 - don't want to use my one if you're
21:45 - adding your own comments and all that
21:48 - i would also suggest doing that where
21:50 - essentially just create a file just dump
21:52 - it and then that way you are slowly
21:55 - progressing on the course and if you
21:57 - ever need to go back and refresh your
21:59 - memory you always have that option and
22:02 - keep in mind that
22:04 - if you would want to run this file you
22:06 - simply go with node and then whatever
22:09 - the file name right so in my case that
22:11 - would be one
22:12 - dash intro
22:14 - js again i'm going to keep on numbering
22:16 - them because i'm just annoying that way
22:19 - but you don't have to that is really up
22:22 - to you so back to the globals
22:26 - when we work in vanilla.js applications
22:29 - we know a
22:30 - very cool thing is the fact that we have
22:33 - access to the window object and the
22:35 - reason why it's so cool because in the
22:37 - window object we can get a bunch of
22:40 - useful things right so for example we
22:43 - can get a query selector so i can select
22:46 - a node
22:46 - i can get built-in fetch
22:49 - and hopefully you get the gist
22:51 - now i don't want to rain on your parade
22:54 - but
22:54 - you know there's no window
22:57 - why well because there's no browser so
22:59 - there's no window object so if you'll
23:01 - try to access window
23:03 - node will spit back the error and most
23:05 - likely your app will crash
23:08 - now there are some globals of course
23:11 - there is this concept of global
23:13 - variables and essentially what global
23:16 - variables means that
23:17 - anywhere in your application you can
23:19 - access them so no matter how complex my
23:22 - application gets
23:23 - how nested it gets or whatever
23:26 - i'll always have access to those
23:29 - variables and again let me repeat these
23:32 - are just some of the variables of course
23:34 - there's more and i'm not going to spend
23:36 - hours and hours talking about them i
23:39 - simply want to give you a general idea
23:41 - and then like i said we'll start using
23:43 - them and you'll see them in action and
23:46 - in my opinion
23:47 - that's just going to make it way clearer
23:50 - about what in fact they're doing and
23:54 - some of the useful ones we have their
23:56 - name so that would be underscore
23:58 - underscore their name
24:00 - just going to give us path to current
24:01 - directory then we have also underscore
24:04 - underscore filename which as you can see
24:06 - is going to give us a file name then we
24:08 - have require which is a function to use
24:11 - modules
24:12 - as well as the module that would be info
24:14 - about the current module now these two
24:17 - will literally cover them
24:19 - in the upcoming videos because our next
24:22 - big topic is going to be modules
24:25 - so for time being
24:27 - just remember that we have require and
24:29 - module and you'll see them in action in
24:32 - no time and then we have a very very
24:35 - very useful one and that one is a
24:38 - process and why it's so useful because
24:41 - it gives us a info about the environment
24:45 - where the program
24:46 - is executed because we need to keep in
24:49 - mind when it comes to a node app
24:52 - at the moment yeah we're executing that
24:55 - on our machines
24:57 - but
24:57 - when you deploy for example your api so
25:00 - for example your server right where is
25:02 - it sitting it is sitting on digital
25:05 - ocean or herald core or whatever so that
25:08 - of course is already a different
25:09 - environment
25:11 - and of course based on that environment
25:13 - you can
25:14 - make a bunch of decisions in your
25:17 - application
25:18 - again
25:19 - if you'll take a look at the process
25:20 - right now it's just going to be a
25:22 - giant object
25:24 - of gibberish data but trust me as we're
25:27 - progressing we the course
25:29 - will find a bunch of useful properties
25:32 - that we'll implement in our application
25:35 - now any of them you can simply console
25:38 - log and you'll get that useful data so
25:40 - you can just run console log and then
25:43 - for example their name again i'm not
25:45 - going to cancel log all of them probably
25:47 - the biggest one is going to be the
25:48 - process like i said you'll get a bunch
25:50 - of properties that at the moment
25:53 - will look like a gibberish and i simply
25:56 - need to save and of course then we go
25:58 - with
25:59 - node and app.js we run that and there it
26:02 - is now of course this gives me the path
26:05 - so
26:06 - if you're interested of course you can
26:08 - console log rest of them
26:10 - as well
26:11 - but
26:12 - in my case i'm going to stop
26:15 - with their name now also very quickly
26:19 - yes you have access to the console
26:21 - so as you can see in order to cancel log
26:23 - we have to use the console so that is
26:25 - also something that is available
26:27 - globally then just like
26:29 - in the event ljs we have set interval as
26:33 - well as set timeout so you can run these
26:36 - ones and i'm not going to run both of
26:38 - them but i'll show you set interval very
26:41 - quickly just so you don't think that i'm
26:43 - cheating
26:44 - and the way it's going to look like of
26:45 - course we have our callback function and
26:47 - then i'll say that my interval is going
26:50 - to run every second and i must type
26:53 - hello world otherwise
26:55 - well what kind of tutorial is this and
26:58 - again we simply go back to node and then
27:02 - app js and as you can see now
27:06 - after every second i have hello world in
27:09 - console and in order to stop it remember
27:11 - the command was ctrl and c
27:15 - and before we move on and start talking
27:17 - about the
27:18 - modules let me also mention something
27:21 - else
27:22 - where essentially we don't need to type
27:25 - node and then app.js you can simply
27:29 - write
27:30 - node and then app however throughout the
27:33 - course i'll probably keep on typing js
27:36 - just because i'm annoying that would be
27:38 - the first thing now the second thing and
27:41 - this is not a node thing this is
27:42 - actually a terminal
27:44 - if you don't want to type it you can
27:46 - simply go back to the previous command
27:48 - and in order to do that you need to
27:50 - press on arrow key up and check it out
27:53 - the moment you press notice that was my
27:56 - previous command
27:57 - and then i have one before that so in my
27:59 - case that is node and then app.js again
28:03 - you don't need to add that just
28:05 - extension but probably i will
28:08 - and then you just go back to the
28:10 - previous command and then press and
28:12 - again you just execute that command and
28:16 - of course if you want to clear the
28:17 - console again this is not a node thing
28:19 - this is a terminal i just type clear and
28:22 - lastly
28:23 - to answer the question that's probably
28:26 - bugging you the most we always have to
28:28 - just type node and then the file name
28:30 - because as we're going to be testing a
28:32 - special in tutorial it will probably get
28:34 - annoying and the answer is yes
28:37 - but only for now
28:40 - once we learn about npm
28:41 - the external packages which at the
28:43 - moment i fully understand doesn't make
28:46 - any sense at all then there's command
28:48 - that effectively will restart our
28:52 - application so we'll have to install
28:54 - some
28:55 - third-party module some external library
28:58 - and that will do the job of restarting
29:01 - the application for now yes all
29:03 - throughout tutorial up until the point
29:05 - where we cover that external library and
29:08 - external libraries in general yes we'll
29:11 - have to type node and then whatever is
29:13 - the file
29:14 - i know it's a little bit annoying but i
29:17 - just don't want to skip ahead i want to
29:19 - get us there with a full information of
29:23 - what is happening so with this in place
29:26 - with clear understanding of the
29:29 - global variables in node now let's move
29:33 - on to our next topic which is going to
29:35 - be modules in node beautiful
29:39 - and once we understand the globals in
29:41 - node now let's talk about the modules
29:44 - and first let's return to this command
29:48 - notice we have here
29:50 - node and then app.js
29:54 - probably the question
29:56 - that you have
29:57 - is well does that mean that all my
30:00 - application
30:01 - needs to be in this one file
30:04 - and the answer again is yes and no
30:07 - yes you'll execute one file
30:09 - but you'll split your code in modules
30:13 - otherwise that would be literally insane
30:15 - to jam all your code in one file
30:20 - and effectively i'll just show you with
30:22 - an extremely complex app and of course
30:24 - extremely complex is in the air quotes
30:27 - right now
30:28 - and you'll see why we'd want to use the
30:30 - modules in the first place so in the
30:32 - next video i'll give you official intro
30:35 - with a bunch of gibberish and all that
30:37 - but for time being let's just build
30:39 - super complex
30:41 - app and then see why i would want to use
30:44 - those modules
30:45 - in the first place and if you have any
30:48 - familiarity with es6 modules if you have
30:51 - worked with them in vanilla.js or in
30:54 - react.js you're already in good shape
30:56 - the syntax is going to be tiny bit
30:58 - different because you know it uses
31:00 - common js but the general idea is
31:03 - exactly the same
31:04 - and we start with a simple function by
31:07 - the name of
31:09 - say hi you guessed it and then this
31:11 - function is going to be looking for the
31:13 - name parameter and then inside of the
31:15 - function what do we do
31:17 - we simply cancel log and we say hello
31:20 - there
31:21 - and then whatever is the name of the
31:23 - dude or the gal that is being passed in
31:26 - as a parameter and of course we can
31:28 - invoke it and i can say say hi and then
31:31 - pass in susan for example
31:33 - and in order to make this interesting
31:35 - i'll set up some variables as well so
31:38 - i'm going to say const john is equal to
31:40 - john
31:41 - and you guessed it
31:43 - since there's a john there also has to
31:44 - be a peter and hopefully you get the
31:47 - gist so imagine we would have a bunch of
31:49 - names and then we have probably more
31:52 - functions than this one but for time
31:54 - being this is just going to be say hi we
31:56 - copy and paste we invoke this function i
31:59 - guess three times one for johnny boy
32:02 - one poor peter
32:05 - and then the first one we already have
32:06 - for susan and what do we do we run node
32:09 - app or app.js we run that and there it
32:13 - is now of course in our concert we can
32:15 - clearly see hello there susan blah blah
32:17 - blah now wouldn't it make sense if the
32:20 - names would be separate as well as this
32:23 - function or the future functions that
32:26 - we're going to create would be in
32:28 - separate files
32:30 - and then we can access them all
32:32 - throughout the application
32:34 - and
32:35 - that way of course we would have smaller
32:38 - files and more structure to our
32:40 - application and that is exactly what the
32:43 - modules allow us to do
32:45 - and that's why we'll move on and start
32:48 - talking about the modules in the next
32:49 - video
32:50 - beautiful
32:51 - and once we understand the main problem
32:54 - with this code where again the moment
32:57 - code is technically still tiny but as
33:00 - you can see it is getting bigger and
33:02 - more annoying with every line now let's
33:05 - talk about the modules and i guess let
33:08 - me just give you the
33:10 - main idea first and then we'll talk
33:13 - about the implementations and
33:16 - all that good stuff so first of all what
33:18 - are the modules again if you're familiar
33:20 - with es6 modules you already have the
33:23 - idea but essentially that is
33:25 - encapsulated code
33:27 - and the key here is that we're only
33:30 - sharing what we want
33:32 - so we're only sharing minimum how would
33:35 - that look like in real life well i can
33:37 - go here with secret
33:40 - and then i can type here super
33:43 - secret and then since this variable
33:46 - is in this file
33:48 - as we can see you can access anywhere
33:51 - okay so by mistake i can just access it
33:53 - i can override it now of course you can
33:55 - make an argument that i mean it is made
33:58 - with cons but hopefully you get the gist
34:00 - this is available to me everywhere in
34:03 - this file so once we set up the module
34:06 - you'll see what are the differences now
34:10 - node uses common js library under the
34:13 - hood that's what makes it happen
34:17 - and then every file in node is a module
34:20 - again let me repeat every file in node
34:24 - is a module so those super powers
34:27 - that we will cover in just a few seconds
34:30 - we have them by default we don't need to
34:32 - do anything we don't need to go to the
34:33 - store and buy some javascript code no we
34:36 - just get them by default
34:38 - and the way the modules work well we
34:41 - simply need to create a new file right
34:44 - and i'll right away
34:45 - set up the names here because of course
34:48 - eventually this code will be sitting in
34:51 - the file name by the three hyphen and
34:54 - then the module basics or whatever but
34:57 - the names as well as the function well
35:00 - it's going to be in a separate file so
35:02 - what i'm trying to say is that in a root
35:05 - of course there's no folders or nothing
35:07 - so everything is rude i'm going to go
35:09 - with four again i'm doing that because
35:11 - eventually this is going to be three
35:13 - hyphen modules something i'm gonna go
35:16 - with maybe names or you can type first
35:18 - module whatever you would want and i'm
35:21 - just gonna go with names.js
35:24 - okay awesome and then i'll take these
35:27 - three
35:28 - variables
35:29 - from my app.js and i'll copy and paste
35:32 - in the names and then also what i would
35:34 - want is to set up one more file and of
35:38 - course this one will be
35:40 - five
35:41 - and
35:42 - i don't know we can say second module
35:45 - or so i'll say here utils
35:49 - something generic so we set that up
35:52 - and now of course what i would want is
35:55 - to grab this function
35:57 - from the mgs and copy and paste in the
36:01 - utils and now sixty four thousand dollar
36:04 - question
36:06 - is this app gonna work
36:07 - or is it gonna break and of course the
36:09 - answer is it's gonna break because we
36:11 - have no access right now to say hi
36:14 - or to john or peter so
36:18 - why don't we
36:19 - go to the names and console log
36:21 - something and as i said yes you can
36:23 - console log this in the app.js it is a
36:26 - file so by default it is a module but
36:29 - since we'll do most of our work in the
36:32 - names and new tools first why don't we
36:34 - go to names and that way we can also see
36:36 - how we can run the file just by using
36:40 - node and what i would want to console
36:42 - log is the global by the name of module
36:46 - so in the names
36:48 - go below or above the variables doesn't
36:50 - really matter
36:51 - and go with console.log and then module
36:54 - and remember to run node and then
36:57 - whatever is the file name so in my case
36:59 - it is four dash and then names
37:02 - js you run this
37:04 - and you'll notice something pretty
37:07 - pretty cool
37:08 - where we have the object
37:10 - and in that object we have quite a few
37:12 - properties now the one that i'm
37:14 - interested in the most
37:16 - is this exports one
37:18 - and it tells me that this export is an
37:21 - object
37:22 - and the way the common js syntax works
37:26 - whatever i'm going to dump
37:28 - in that export i'm going to be able to
37:31 - access anywhere in the application
37:34 - so that's the key
37:36 - remember we're only sharing the minimum
37:39 - so it's up to us
37:42 - to
37:43 - set those values in that export object
37:47 - we decide what goes in there previously
37:49 - remember
37:50 - secret was accessible
37:52 - everywhere in my app.js
37:54 - now in the names i can be hey you know
37:57 - what john and peter yeah
37:59 - i'm sharing them anywhere in application
38:01 - we can access that but the secret
38:03 - variable no this is just going to be
38:05 - local so i'm going to add here i guess
38:09 - the
38:10 - comment by the name of local and that
38:12 - way at least we understand so this is
38:14 - going to be i mean i'm not going to use
38:16 - global
38:17 - but i'm just going to say that
38:19 - share so we're sharing this with rest of
38:23 - our application and then if i know that
38:25 - this is a object
38:27 - and it is sitting in the module how does
38:30 - that work well we go with module
38:34 - then it is an object so we go with
38:37 - export
38:38 - and we have multiple ways how we can set
38:41 - this up but the most basic one will
38:43 - simply say that yep it is an object and
38:46 - inside of that object there's going to
38:48 - be two properties john
38:50 - and peter now i can probably already
38:53 - guess that we're using a es6 syntax
38:56 - since the key name is exactly the same
38:58 - as the value well we can simply pass it
39:01 - right so we have john and peter so now
39:03 - what happens in the app.js we can access
39:07 - them so i can go back and this is the
39:09 - case where we'll need to run that
39:11 - require remember in the globals we
39:14 - talked about this function
39:15 - so in order to share them we need to
39:18 - use
39:19 - module.exports and essentially i'm
39:22 - setting up the object like so where i go
39:25 - with whatever values i would like to
39:27 - share now in order to access them
39:30 - i need to go with require
39:33 - and
39:34 - i can assign it to a variable or i can
39:36 - simply require now in our case we will
39:38 - assign it to the variable and i'll use
39:41 - the same type of syntax where i'm going
39:43 - to go with names just so we can
39:45 - console.log that
39:46 - and this is going to be equal to require
39:50 - so that's my function and as a parameter
39:53 - we need to pass in where the module is
39:57 - located
39:58 - so where is this data coming from
40:01 - and always always always always
40:04 - you will be setting up your module you
40:06 - have to start with dot now sometimes
40:09 - your modules will be two levels up i
40:11 - don't know three levels up whatever then
40:13 - of course you'll start with dot dot but
40:16 - you'll always start with this one dot
40:18 - because there's also going to be a third
40:21 - party modules and there's going to be
40:22 - built-in modules in node and then we'll
40:25 - use just these quotation marks again
40:28 - super super important every time you
40:30 - create your own module you'll have to
40:32 - start with dot and then forward slash so
40:34 - essentially you're giving a path now in
40:36 - our case what is the path well i'm
40:38 - looking for the names right so i set up
40:41 - here the path and then if i cancel out
40:44 - the names
40:45 - i should see something pretty pretty
40:47 - cool where i go with names
40:50 - and there it is now i'm going to run
40:52 - node and then app js now keep in mind
40:56 - we're not running names anymore we go
40:58 - with node and app.js now of course still
41:02 - complains that we have no access to hi
41:05 - let me comment this one out so let's say
41:07 - node and app.js
41:10 - and check it out now of course we have
41:12 - the object
41:14 - with john john and peter and peter
41:17 - and we explicitly said what we would
41:20 - want to export so we go with exports and
41:23 - that way
41:24 - no one has access to the secret one so
41:26 - this secret one is only for this file
41:30 - and of course we can do the same thing
41:32 - in the utils as well right so we have
41:35 - the say hi
41:37 - and we go with module and export
41:40 - and i can just simply set it equal to
41:42 - now the reason why i was setting this up
41:44 - as a object because i had multiple
41:46 - things at john and peter and don't worry
41:49 - in the next video i'll show you
41:50 - alternative syntax how you can also set
41:53 - this up but in this case i have object
41:56 - and then of course i'm setting these
41:57 - properties and i said note this is just
42:00 - my preferred way of
42:02 - actually using the exports again there's
42:05 - multiple ways how we can do that and i
42:07 - will cover the other ways in next video
42:10 - but this is just my preferred method
42:12 - that's why i right away set my exports
42:15 - equal to an object and then pass these
42:17 - two properties and in utils since i only
42:20 - have one thing i'm just gonna go with
42:23 - say hi that's it i'm saying
42:25 - that i'm gonna be exporting my function
42:28 - so say say hi like so and once i have
42:32 - exported my function
42:34 - now of course i need to go back to the
42:36 - app.js
42:37 - import my function the same name
42:41 - and i'm going to go with say
42:43 - say hi
42:45 - and that one is going to be coming from
42:47 - the different file of course so we go
42:49 - with five
42:50 - and then utils
42:52 - and notice here how we don't need to
42:54 - pass in the js if it is ajs file we just
42:58 - simply omit the extension as long as the
43:00 - file name of course matches
43:02 - and then
43:03 - i can remove now if you want you can
43:05 - cancel log but i already know that i'm
43:08 - gonna have the function over there i'll
43:10 - uncomment my say hi
43:12 - so now of course there's going to be no
43:14 - error and let's make a clear console and
43:16 - again we run
43:17 - the node and then app js and there it is
43:21 - now of course we have a different error
43:24 - where it says well john is not defined
43:26 - all right but i know that
43:29 - john is sitting in the names right so
43:31 - here we have multiple flavors either
43:35 - you can destructure it
43:37 - so instead of going with names i can go
43:41 - john and peter that is definitely one
43:44 - option or
43:45 - i can go with property names right so i
43:47 - can say
43:48 - names and then john
43:51 - and then the second one is names and
43:55 - peter names and peter and now hopefully
43:58 - everything works otherwise you're
44:01 - probably thinking that i'm just messing
44:03 - with you there it is now we have hello
44:05 - there susan john and peter
44:08 - and effectively what we did we separated
44:11 - our concerns again the main idea is that
44:14 - every file by default is a module and
44:17 - then when it comes to a modules we are
44:20 - in charge what we are sharing and in
44:23 - order to
44:25 - export or make it something available
44:28 - from this module we go with module
44:30 - exports
44:31 - and then we just set up the
44:34 - functionality whether this is going to
44:36 - be a object that we're exporting or
44:39 - we're simply exporting as a function
44:42 - so we set this equal to
44:44 - to the exports and if you're familiar
44:47 - with es6 modules
44:49 - as you can see this is very familiar to
44:52 - the export
44:55 - default and then whatever you're
44:57 - exporting as default whether that is a
44:59 - function whether that is a react
45:00 - component or whatever notice i'm
45:03 - exporting as default so of course
45:05 - when i'm importing this
45:08 - in this case app.js well i already know
45:11 - that this is a function so i can name
45:13 - this whatever i would want and the same
45:15 - goes here
45:16 - since i'm exporting this as object i can
45:19 - call this shaken bait as long as i
45:22 - access it later of course i'll be able
45:24 - to access the property as long as the
45:26 - name
45:27 - matches to whatever i set up over here
45:32 - so let me save this and now of course we
45:35 - can talk about our next topic
45:38 - all right so far we know two flavors
45:41 - one
45:42 - if we want to export one value
45:44 - we just set module export
45:47 - equal to that value and then of course
45:50 - wherever we want to use it we just
45:52 - import it
45:53 - set it equal to some kind of variable
45:55 - and of course
45:57 - once we use that variable we have access
46:00 - to that value
46:02 - and the second flavor is if we have
46:04 - multiple values
46:05 - then we simply set module exports equal
46:09 - to an object and then in that object we
46:12 - set up the properties however there's
46:15 - also another way how we can do that
46:17 - and essentially it is called
46:20 - export as you go
46:22 - and the way it looks like
46:24 - first i'm gonna set up a new file and
46:28 - i'll call this six and i'll call this
46:30 - alternative
46:32 - flavor now again naming is really up to
46:35 - you since that is the hardest thing in
46:38 - programming
46:39 - and then i'm going to come up with one
46:43 - array and i'm going to call this items
46:45 - and that will be equal to item one
46:47 - and item number two
46:50 - and then i'll set up a object and i'll
46:52 - say const person is equal
46:56 - to a object and there surprise surprise
46:59 - we'll go with name property and set it
47:01 - equal to bob
47:03 - and i'm purposely adding multiple data
47:05 - types
47:05 - just so you don't think that we can only
47:08 - export variables or functions
47:12 - and in here we have two options
47:15 - either
47:16 - where we are setting up the
47:18 - value in this case items i simply go
47:21 - with
47:21 - module exports and then whatever is the
47:25 - name and of course in this case i'm
47:26 - going to keep the items but notice the
47:28 - syntax where instead of going with const
47:31 - items i right away go with
47:34 - module.exports
47:35 - or if you are a true rebel you can do
47:37 - something like this module exports set
47:41 - up the property for example
47:43 - single
47:44 - person and set it equal to your person
47:48 - object why we are able to do that
47:50 - because if you remember in the previous
47:52 - video when we console logged
47:54 - module exports it was an object right so
47:57 - what are we doing here we're setting up
47:59 - a property on that object and set it
48:02 - equal to an array
48:04 - and here i set up another property and
48:07 - just set it equal to a person keep in
48:09 - mind of course i can still write simply
48:12 - module exports and then the person
48:15 - but since you might
48:17 - sometimes see this type of syntax as
48:19 - well i wanted to cover that and now of
48:22 - course we save alternative flavor.js
48:26 - and you're probably not going to be
48:27 - surprised that if we navigate to app.js
48:30 - and in this case i will call this data
48:33 - because i'm getting a object and on that
48:35 - object i have two properties and i need
48:37 - to come up with some kind of name now as
48:39 - always this name is really up to you
48:43 - you can call it shake and bake you can
48:46 - call it uncle bobby whatever you want in
48:49 - my case i'm gonna go with generic data
48:52 - we go with require again we're looking
48:54 - for the file by the name of alternative
48:57 - flavor
48:58 - and
48:59 - in this case i'm not gonna do anything
49:01 - with it apart from console logging and
49:04 - if i navigate back to my integrated
49:06 - terminal and run
49:08 - the node app.js
49:11 - there it is of course now i have the
49:13 - items as well as the single person
49:16 - now please keep in mind one thing
49:18 - where this syntax
49:21 - whether the first line or line number
49:24 - six
49:25 - at the end of the day is exactly the
49:27 - same like we're doing over here yes the
49:30 - syntax is a bit different but at the end
49:32 - of the day you just make these values
49:35 - available somewhere else in your code
49:39 - now just because i prefer this type of
49:41 - syntax most likely throughout the course
49:44 - you'll see this approach but
49:47 - if you prefer this one instead
49:49 - be my guest at the end of the day it is
49:52 - your application and you are the one who
49:54 - is going to be maintaining it and before
49:56 - we move on to built in modules as well
50:00 - as third-party modules let me throw you
50:03 - a mind grenade
50:05 - and i'm going to start by removing this
50:07 - console log
50:08 - in the app js like so and i'm going to
50:12 - create a new file with the same exact
50:15 - name a mine grenade as always
50:18 - if you would like to call this
50:19 - differently
50:20 - that's totally your option
50:23 - and i'm going to go with mine grenade
50:26 - like so and js and in this file i'll
50:30 - create some basic functionality and by
50:32 - the way let me save app.js so let's go
50:34 - with const
50:36 - num1
50:37 - is equal to 5 and then const num 2
50:42 - is equal to 10. of course there has to
50:44 - be a function that adds these values as
50:47 - always with every tutorial so go with
50:50 - add values just for the sake of it i'm
50:52 - just going to go with good old function
50:54 - keyword and the old setup meaning
50:57 - not the arrow function syntax and simply
51:01 - here we'll go with template string the
51:04 - sum is colon
51:06 - and then of course let's go for template
51:09 - literal and we'll say num1 plus
51:12 - num2
51:13 - and
51:14 - instead of setting up the exports i'll
51:17 - simply invoke
51:19 - add values
51:21 - and now i'll throw you that migrate that
51:24 - i was talking about where in the app.js
51:28 - i'm not going to assign it to anything
51:30 - i'll simply write require
51:33 - and then we'll go with my grenade and
51:36 - now let me comment out these three
51:39 - since at the moment they will just over
51:41 - populate the console and again let's run
51:44 - node and app.js and once we're on our
51:47 - code we can clearly see in the console
51:49 - something pretty interesting where we
51:51 - have a log of the sum is 15.
51:55 - so what's happening over here
51:57 - well
51:58 - when we are setting up everything if we
52:01 - have a function inside of the module
52:04 - that we invoke yes that code will run
52:07 - even though we didn't assign it to a
52:09 - variable as you can see clearly here and
52:12 - we didn't invoke that variable
52:15 - and before we go any further let me
52:17 - mention three things
52:18 - first
52:20 - it's not unique you can also do that in
52:22 - es6 modules
52:23 - and if you took my vanilla javascript
52:25 - course you know that we use that
52:26 - functionality number two yes throughout
52:29 - the course here and there we will use
52:31 - this particular setup now it's going to
52:33 - be with third party modules and of
52:35 - course once we get there i will remind
52:38 - you about this setup so that's how it
52:41 - works and third
52:43 - i wouldn't suggest losing your sleep
52:46 - over it
52:47 - just please remember that when you
52:49 - import a module you actually invoke it
52:52 - and this is really going into weeds but
52:55 - the reason why that happens is because
52:58 - this code is not just exported on its
53:01 - own
53:02 - when the node exports this it actually
53:05 - wraps it in the function so that's why
53:08 - when you're required yeah you do invoke
53:10 - the code if
53:11 - you have some kind of function that
53:14 - actually is executed here keep that in
53:16 - mind not talking about exporting
53:18 - something i'm talking about executing
53:21 - function here and there and of course in
53:23 - this case you need to use the
53:24 - imagination that we'll do something way
53:27 - more useful than this at this point
53:29 - you're looking at it okay i could have
53:30 - just set up that function in app.js and
53:33 - you're 100 correct this is the place
53:36 - where you definitely need to use your
53:38 - imagination where of course the
53:40 - functionality we'll use it for is going
53:41 - to be way more complex but the idea is
53:44 - going to be similar where we'll just
53:47 - require some kind of module and behind
53:49 - the scenes that module will do a bunch
53:52 - of cool stuff okay that was fun we
53:55 - created our first module and in the
53:57 - process covered the general module
53:59 - syntax and use cases as well
54:02 - now what
54:03 - well as helpful as our say hi function
54:07 - is
54:08 - some very smart people created way more
54:11 - useful modules than that
54:14 - and the good news is that we can start
54:15 - using them right away
54:17 - so what i'm trying to say here is that
54:20 - node has bunch of built-in modules
54:23 - that we can use freely in our apps
54:26 - in the following videos we're going to
54:28 - cover following modules os module so
54:31 - operating system module path module file
54:34 - system module as well as http module to
54:38 - set up our http server and before we
54:41 - continue let me just say this
54:43 - i purposely cover only a few major
54:45 - modules
54:46 - and more specifically only a few
54:48 - properties and methods provided by those
54:51 - modules
54:52 - you see the list of built-in modules in
54:55 - node is quite big
54:57 - and the amount of properties and methods
55:00 - each module has
55:02 - combined is of course even bigger
55:05 - and as a result we could easily spend
55:07 - the remainder of the course on just that
55:10 - but is that really beneficial and of
55:12 - course the answer is no
55:14 - instead let's cover the general setup
55:16 - first
55:17 - and later as we progress with the course
55:20 - implement some modules as we go
55:24 - now if you're interested in more
55:26 - properties and
55:27 - methods built and modules have just
55:30 - navigate to the docs and go nuts so if
55:34 - at any point you would want to find out
55:36 - more about specific property or method
55:39 - or the built-in module in general just
55:43 - navigate to nodejs.org
55:46 - and then look for the docs
55:49 - and again in my case
55:51 - the version the long term support
55:54 - version is 14
55:57 - so i'm gonna click here but as you can
55:59 - see we also have an option of going to
56:02 - the older versions as well so as you can
56:05 - see i can get the docs for the older
56:08 - versions as well
56:09 - but i'm just going to stick with my
56:11 - version
56:12 - and then be prepared to go nuts
56:15 - if you enjoy docs
56:17 - then you have yourself a big old party
56:20 - where of course you can look for modules
56:22 - and then each module has the properties
56:26 - as well as the methods so of course you
56:29 - can get a
56:30 - extremely detailed information on the
56:34 - properties as well as the methods here
56:36 - in the docs
56:38 - all right and once we have covered the
56:40 - general existence of built-in modules
56:43 - now let's take a look at few of them
56:45 - and i'm going to start by creating that
56:47 - file that i promised a few videos ago
56:50 - remember when i was setting up the
56:52 - modules i said that eventually there is
56:54 - going to be a file by the name of 3n
56:56 - modules and this one i would want to do
56:58 - it together
56:59 - just so you don't think that i'm not
57:02 - fulfilling my promises so we're going to
57:04 - go with module and then i guess
57:07 - modules.js
57:10 - i'll grab that i currently have in the
57:12 - address it's pretty much everything
57:15 - and we copy and paste and in this case i
57:17 - also uncommented these say hi again this
57:21 - all stays for your reference and you'll
57:23 - have access to it if you navigate to the
57:26 - github repo
57:28 - so grab everything in app.js i'll
57:30 - actually cut it out since we'll start
57:31 - from scratch and copy and paste now of
57:33 - course all this code is sitting in the
57:35 - modules and just keep in mind that of
57:37 - course we're still referencing the names
57:39 - utils alternative flavor as well as my
57:42 - favorite the mind grenade
57:44 - and back in app.js
57:47 - now let's start by taking a look at the
57:49 - os module
57:51 - and os module we built in module
57:54 - provides many useful properties and
57:55 - methods for interacting with operating
57:59 - system as well as the server
58:01 - and the general setup
58:03 - for the built-in modules or even the
58:06 - external ones that we're going to cover
58:08 - a bit later
58:09 - is going to be similar
58:11 - where we're going to go with some kind
58:12 - of variable
58:14 - and in this case i'm going to call this
58:15 - os for operating system then we're going
58:18 - to go with require
58:20 - and then in the require we'll have to
58:22 - pass in the name
58:24 - so since this is a built-in module of
58:26 - course we don't need to install anything
58:28 - just remember it later when we work with
58:30 - external ones yes we'll have to install
58:33 - that module first in this case it is a
58:35 - built-in so we just go with os but again
58:38 - let me stress something we're not doing
58:41 - dot and then forward slash no we just go
58:44 - with os so that way node knows all right
58:46 - so you're looking for the built-in
58:48 - module and
58:50 - once we set this up
58:53 - then we have multiple options
58:55 - either you can access those methods by
58:58 - just running this variable
59:00 - so it would look something like this
59:02 - where i go with os and notice
59:04 - the moment i press dot
59:06 - i have all these options so these are
59:09 - the
59:09 - methods and properties that i can use or
59:13 - if we know that we want a specific one
59:15 - you can simply destructure it here and
59:17 - of course throughout the course i'll use
59:20 - multiple setups just so you understand
59:22 - that both of them effectively do the
59:24 - same thing so here i have access to all
59:27 - the methods and properties that this
59:30 - module provides and of course now we can
59:32 - go crazy for example i could get a
59:34 - useful info about the current user which
59:37 - of course is me so say info about
59:41 - current and
59:43 - user and you know what as a side note
59:46 - i'll save here and i'll close all the
59:48 - files it's just a bit annoying that i
59:50 - have all those tabs open
59:52 - back in the app.js
59:54 - once i have a comment of course now i
59:56 - would want to assign it to a
59:58 - user and we'll simply go with os since
60:01 - that is the name of my variable and then
60:04 - method that i'm looking for is userinfo
60:07 - i don't need to pass anything i simply
60:09 - invoke it and of course since i would
60:11 - want to see the result i simply go to
60:12 - console log and then i'm looking for the
60:15 - user and you can probably already guess
60:17 - that we'll just run
60:19 - node app.js and there it is now of
60:22 - course i have a info about the user
60:25 - which is me so this would be a home
60:28 - directory this is going to be the
60:30 - default shell and all kinds of useful
60:32 - stuff
60:33 - then i want to show you how we can get
60:36 - the uptime of the system so effectively
60:40 - how long the computer has been running
60:42 - in seconds and i'll just add a comment
60:46 - method
60:47 - returns
60:49 - the system
60:50 - system
60:52 - up time up time
60:54 - in seconds
60:56 - and
60:57 - the way i'm going to run that i'll right
60:59 - away set up the console log
61:01 - just so you understand that of course we
61:03 - have multiple options how we can invoke
61:06 - those methods
61:07 - you don't always have to assign to some
61:09 - kind of variable now i'll leave this one
61:12 - in here
61:12 - so i'll leave the console log and then
61:15 - user
61:16 - and let's say right above or you know
61:18 - what let's do it this way so leave the
61:20 - console log where the user is and then
61:23 - let's go with another one we'll go with
61:25 - console.log in this case i'm going to go
61:26 - with template string and we'll say the
61:29 - system
61:30 - system uptime yes and then let's use a
61:35 - interpolation of course and the method
61:37 - that i'm looking for
61:38 - is uptime so again i go with my variable
61:41 - name and i know i've said this before
61:42 - but i just want to stress this point
61:44 - just so we all are on the same page and
61:47 - in this case i'm going to go with os and
61:49 - then the method name is uptime
61:52 - and then let's just add seconds and
61:55 - again same deal back in the integrated
61:58 - terminal run node and then app.js and
62:01 - there it is now of course not only i
62:03 - have the info i also have the system
62:07 - uptime and what's interesting this
62:09 - actually is 100 seconds meaning if i'll
62:13 - run this notice that you'd expect that
62:16 - this would probably stop at 60 right
62:19 - since we have 60 seconds in a minute but
62:21 - no actually this one goes to a hundred
62:25 - and then i'm just gonna set up a object
62:26 - where i'll show you a few more methods
62:29 - and then we'll move on to a next module
62:32 - because again the point is not to cover
62:34 - each and every method the point is just
62:36 - to give you a general idea how the
62:39 - modules the built-in modules would work
62:42 - in node so clear my terminal and then
62:46 - i'll create a object i'll call this
62:48 - current
62:49 - and then os
62:51 - and then in this object i'll set up
62:53 - properties and i'll set them equal to
62:55 - the method
62:56 - that actually returns that value from my
62:59 - os module so go with name and os and
63:03 - this is going to be equal to a type
63:04 - method then i can get the release
63:07 - and this one will be equal to os and
63:10 - then
63:11 - release again we invoke it then we'll
63:13 - look for total memory and free memory
63:17 - total
63:18 - and mem
63:19 - and of course i'll go with os and then
63:22 - total mam as you can see somewhat
63:25 - predictable and then we're gonna go with
63:27 - free memory
63:28 - and it's not going to be surprised if
63:30 - we're just going to go with free memory
63:33 - here let's save that one and lastly
63:35 - let's just cancel log it
63:37 - and we should
63:38 - get a bunch of info about our current
63:42 - operating system again we're going to go
63:44 - with node and then app.js
63:47 - and not only have the user information
63:49 - not only i know
63:51 - how long the system has been up
63:54 - in seconds i can also get some useful
63:56 - data about my operating system and again
63:59 - we're just scratching the surface of
64:01 - course there's more methods and
64:03 - properties but hopefully you have a
64:05 - clear understanding how powerful these
64:08 - built-in modules are in node.js since
64:12 - the node we can interact with the file
64:14 - system something we couldn't do when we
64:17 - used our javascript in a browser another
64:20 - useful module is a path module which
64:23 - allows us to interact with file paths
64:26 - easily
64:27 - and i'm going to remove all my code in
64:30 - the app.js because behind the scenes i
64:33 - created a file by the name of
64:35 - 8 os
64:37 - and module and of course copy and pasted
64:40 - the contents from the previous video
64:43 - that's why in app.js i'll remove
64:44 - everything and the setup is going to be
64:47 - exactly the same we come up with some
64:48 - kind of name now most likely it's going
64:50 - to be path
64:52 - and then we pass in the module we would
64:54 - want to get and in this case of course
64:56 - it is a path module
64:58 - and then let's just start with a very
65:01 - useful property
65:02 - a separator property that returns a
65:06 - platform specific separator so if i go
65:10 - straight up with console.log and then
65:12 - path
65:13 - sep this is going to return my platform
65:16 - specific separator so if i write node
65:20 - mjs
65:21 - there it is and of course i have forward
65:23 - slash now if you're using different
65:24 - platform for you the value might be
65:27 - different after that let's take a look
65:29 - at the path dot join so the join method
65:32 - which joins a sequence of path segments
65:36 - using that platform specific separator
65:39 - as the limiter and second thing it does
65:42 - it returns a normalized resulting path
65:46 - and in order to show you an example i'll
65:48 - create a new folder so not a new file
65:50 - but a new folder i'll zoom in and i'll
65:53 - say content and inside of this content
65:56 - folder i'll create another one and i'll
65:59 - simply call this generic subfolder and
66:01 - in this subfolder i'll say a test
66:05 - and text file and instead of the text
66:08 - file i mean
66:09 - you can place something you can omit it
66:12 - doesn't really matter i'll just say text
66:14 - and then txt and once we save it back in
66:19 - the app js now i want to use that path
66:22 - dot join method so i'll say const and
66:25 - then file path is equal to path dot join
66:29 - and then we need to pass in those values
66:32 - as strings so for example since i'm
66:35 - looking for the content folder
66:37 - i'll simply say forward slash and then
66:40 - content then i know that inside of the
66:43 - content folder i have the subfolder
66:46 - that's another folder and then
66:48 - eventually there's going to be a test
66:51 - txt so we go with test and then dot txt
66:55 - we save the sucker and then if we'll
66:58 - cancel log the file path we should
67:01 - see the whole path and there it is now
67:03 - of course it is normalized and we get it
67:06 - as a value so we have content subfolder
67:09 - test
67:10 - and txt so if i start adding some type
67:14 - of forward slashes meaning trailing
67:16 - slashes then of course they will be
67:18 - removed we still get the normalized path
67:22 - and we can also get the base name so for
67:25 - example i create this file path but i
67:28 - only would want the last portion of it
67:32 - how can i access it well
67:34 - the method name is base name
67:36 - so we're gonna go with const and base
67:40 - and path dot base name and we just pass
67:44 - in that file path and now if we cancel
67:47 - log the base
67:48 - we should see the text again these are
67:51 - just summaries if you want just a
67:52 - directory of course you can imagine that
67:55 - there is a method that returns that as
67:58 - well but since i don't want to cover
68:00 - each and every method that's why i will
68:02 - skip that one and there it is now of
68:04 - course not only i see my normalized path
68:07 - but i also see the test txt which is my
68:11 - base and the last method that i would
68:13 - want to showcase is path.resolve
68:16 - and why it's so cool because it returns
68:18 - an absolute path
68:19 - and once in a while in our applications
68:21 - we need to provide that absolute path
68:23 - that's why of course we'll have to use
68:25 - that method
68:27 - and when it comes to path.resolve it
68:29 - accepts a sequence of paths or path
68:32 - segments and resolves it into an
68:35 - absolute path so below the base i'm
68:38 - going to go with cons and then
68:40 - absolute and that one is equal to path
68:43 - and we're looking for dot resolve
68:46 - and here remember when we talked about
68:48 - the globals one of the first globals i
68:50 - covered was underscore underscored their
68:53 - name so this is going to point to this
68:56 - directory where the app.js is located
68:59 - and once we're here then of course we
69:01 - just need to provide rest of the values
69:04 - in my case that is content
69:06 - then i'm looking for
69:08 - sub
69:09 - folder and then eventually i would want
69:12 - to get to the test dxd i would want to
69:15 - get this absolute path and then once i
69:18 - set up the value of course
69:20 - if i go with my console.log and if i
69:23 - provide
69:24 - absolute
69:26 - once i run node and objects
69:29 - you can probably guess that in the
69:32 - console i'll have my absolute path
69:34 - to the test txt and if you're wondering
69:37 - why we would ever want that well
69:39 - remember our application
69:42 - is going to run in different
69:45 - environments right
69:46 - so of course the path to some kind of
69:49 - resource is going to be different in my
69:51 - computer in my local machine than for
69:55 - example in heroku
69:57 - hopefully it is clear and now of course
69:59 - we can take a look at the next useful
70:02 - built-in module
70:04 - nice now we know how we can work with
70:07 - path module and like i mentioned in the
70:09 - previous video we also have an option of
70:12 - interacting with a file system
70:15 - so
70:16 - what i would want right now is first
70:18 - create a new file i'll call this nine
70:21 - and we'll say path
70:23 - and
70:24 - module like so js i'll grab everything
70:27 - that i have in the address
70:30 - copy and paste
70:32 - and once we have this one out of the way
70:34 - i'll just remove
70:36 - and keep the app.js clean for now
70:39 - as well as clear the console
70:42 - and yes we have an option of interacting
70:44 - with the file system and the module the
70:47 - name of the module is fs
70:50 - now essentially there are two flavors
70:53 - when it comes to file module we can do
70:55 - it asynchronously non-blocking or we can
70:58 - do it synchronously which is going to be
71:00 - blocking but
71:02 - for time being we'll just cover both of
71:05 - the setups
71:06 - and then later in the course
71:09 - we'll cover what are the differences and
71:12 - why you should prefer one over the other
71:14 - one for now just think of them as
71:17 - different methods but eventually yes
71:20 - we'll talk about it the whole structure
71:22 - of the node
71:23 - and why would you want to use the
71:25 - non-blocking code instead
71:28 - as well as different approaches when it
71:30 - comes to callback functions different
71:32 - solutions
71:33 - and for now i just want to show you both
71:36 - methods essentially four methods
71:38 - and then we'll just move on to the next
71:40 - topic
71:41 - and in order to set this up in this case
71:44 - i'm just going to structure right away
71:45 - the methods that i'm looking for and in
71:47 - the first video we'll take a look at the
71:49 - synchronous ones so that's why i'll
71:51 - destructure
71:52 - read file and sync and that is coming
71:55 - from require and then the module name is
71:59 - fs
72:00 - again please keep in mind it would be
72:02 - the same thing
72:04 - if i were to
72:06 - go like this fs and then fs and whatever
72:10 - the name
72:11 - i was going with read file sync and of
72:13 - course i have access to it i'm just
72:15 - showing you a different way how we can
72:17 - access those methods we just destructure
72:20 - them out of the fs module and then the
72:23 - second one will be write file sync
72:27 - write file sync
72:28 - and then once i have the structured both
72:30 - of them
72:31 - then i'm going to set up two variables
72:34 - so first we'll read two files
72:36 - we haven't created those files yet but
72:38 - in a second we will and then eventually
72:41 - we'll create a new file with write file
72:44 - sync so i would want you to go to the
72:46 - content folder if you haven't created
72:48 - then i suggest creating one
72:50 - and
72:51 - i mean i'll keep the subfolder just
72:53 - because
72:54 - i believe the path module is still using
72:57 - it but in a content i'll create a new
73:00 - file so not in the subfolder but
73:02 - actually in the content i'll say
73:06 - first first and then txt
73:09 - so this by the way sets it up in the
73:11 - content so let me move it up or i'm
73:13 - sorry this sets it up in a subfolder i
73:15 - believe
73:16 - and it tells me do i want to move yes i
73:18 - would like to move and now i have the
73:21 - content
73:22 - that has the first txt
73:24 - and then i have the subfolder with
73:25 - test.dxt of course if you want you can
73:27 - place it in a subfolder that's really up
73:29 - to you but in my case i would want them
73:32 - simply in a content so i'll go the
73:35 - second one txt and as far as the values
73:38 - i'll say hello
73:40 - this is first
73:42 - first text file
73:45 - and then of course we can copy and paste
73:47 - the value and just change it around to
73:49 - the second file so in the second txt
73:53 - we'll say second text file
73:56 - and once we have both of the text files
73:58 - now let's take a look at how we can read
74:00 - from the file system
74:02 - and since we have read file sync we know
74:06 - it is a method and in that method we
74:08 - need to provide two parameters we need
74:11 - to provide a path to that specific file
74:14 - as well as well what is the encoding so
74:18 - the node knows how to decode the file
74:20 - and generally you'll go with utf-8
74:24 - and we'll first go with first that's my
74:27 - variable we'll go with
74:29 - read file sync
74:31 - my method name and like i said we
74:33 - provide a path we go to the content
74:36 - and then inside of the content there's
74:37 - going to be a first
74:40 - txt and then as far as the encoding the
74:43 - default one will be utf-8 but if you
74:47 - want to be a bit specific just set up
74:49 - the second parameter and notice these
74:52 - are all your options and just go with ut
74:55 - effect okay
74:57 - and then once we have everything in
74:59 - place of course we can copy and paste
75:00 - this is going to be the value for the
75:02 - second one
75:03 - and we just need to change the file name
75:05 - of course
75:06 - so we have the second one and now in a
75:09 - console log
75:10 - we should see both of the text so if i
75:13 - go with console.log first
75:16 - and then second
75:19 - i should have one long text and let's go
75:22 - with node and app.js and there it is i
75:24 - have hello this is a first text file and
75:28 - i also have hello this is the second
75:30 - text file
75:31 - and once i have both of them why don't
75:33 - we create a new file
75:35 - and the method for that is write file
75:38 - sync
75:39 - and the way it works again we provide
75:42 - two values two arguments one is gonna be
75:45 - the file name and if the file is not
75:47 - there
75:48 - then of course node will create that
75:50 - file and you'll see that in a second and
75:52 - the second one is the value that we
75:55 - would want to pass and i'm going to go
75:56 - with write file sync
75:59 - write file sync and like i said first is
76:01 - going to be a path so you can call this
76:04 - third you can call this result whatever
76:06 - you would want in my case i'm going to
76:08 - go with forward slash content
76:10 - and then we're looking for result
76:13 - and then sync and this is going to be
76:16 - txt and then as far as the value if you
76:18 - want you can simply pass hello world and
76:20 - test it in my case i'm going to make it
76:22 - a bit more interesting where we'll set
76:24 - up a template string we'll say here is
76:27 - the result
76:29 - and why don't we use the interpolation
76:31 - we'll say first and second
76:34 - so we'll have first value and then the
76:37 - second value and you know what when we
76:39 - add here colon as well so let's say
76:42 - first
76:43 - and then let's place a comma
76:45 - and then we're gonna go with second
76:48 - again
76:49 - if the file is not there
76:51 - then of course
76:52 - node will create one and if the file is
76:55 - already there node by default
76:58 - will overwrite all the values that are
77:01 - in the file and i'll show you that in a
77:03 - second so i'm going to go here with node
77:05 - and app.js and check it out now i have
77:09 - result
77:11 - sync txt
77:12 - and then inside there i have here is the
77:14 - result hello this is first text file and
77:18 - also have hello this is second text file
77:21 - and just to showcase that if there are
77:22 - some values they will be overwritten by
77:25 - node
77:26 - well if i go with simple hello world and
77:29 - then i run node.js again i have my new
77:34 - result now if you just want to upend to
77:37 - the file
77:38 - well we need to pass in one more
77:40 - argument notice i have the first one i
77:42 - have the value that i would like to set
77:45 - up in a file and the third one is an
77:47 - object basically an options object and
77:50 - here the property name is flag and if
77:53 - you'll set this flag equal to a
77:56 - then node will append this and the
77:59 - easiest way for me to show you that is
78:02 - run node.js and now we should have two
78:05 - results so we have here is the result
78:08 - and notice how we're starting a new line
78:10 - why well because by default we are
78:13 - overriding everything and then when we
78:16 - add that flag then of course we create a
78:18 - new value so these are two very useful
78:21 - methods that we can use with node to
78:23 - read files as well as create ones from
78:26 - the scratch
78:27 - beautiful and once we have looked at the
78:30 - synchronous approach like promised i
78:32 - also would want to show you the
78:34 - asynchronous and as always let's start
78:37 - by creating a new file again in my case
78:39 - that is going to be 10 hyphen and then
78:42 - i'm going to go with fa
78:44 - sync and js
78:46 - and of course i'll grab everything in
78:48 - the app.js and then just copy and paste
78:51 - and then back in the app.js i would want
78:54 - to change these names so i'm not looking
78:56 - anymore for the read file sync i'm
78:59 - actually looking for a method by the
79:01 - name of read file so this is going to be
79:03 - the asynchronous one and the same goes
79:06 - with writefile now of course we can
79:08 - remove all this code as well
79:12 - and the way the synchronous method works
79:15 - we need to provide a callback and if
79:17 - you're familiar with callback
79:18 - essentially what it means is that we run
79:22 - that callback when we're done
79:25 - so
79:26 - when whatever functionality we're doing
79:29 - is complete
79:30 - then we run that callback just like we
79:33 - normally would do with add event
79:35 - listener on a button remember we go with
79:37 - add event listener we add whatever the
79:40 - event
79:40 - of course with the button that would be
79:42 - a click event and then pass in the
79:44 - callback function and that callback
79:46 - function will run every time we click on
79:48 - a button so this is the same thing where
79:52 - we have the read file function
79:55 - and we can simply use it since of course
79:57 - we have the structured then we need to
79:59 - provide a path so again we go with
80:02 - forward slash content and then the file
80:05 - name is first txt and this is where we
80:08 - provide that second argument and that is
80:12 - going to be a callback mission now in
80:14 - that callback function we pass into more
80:16 - arguments first one is going to be error
80:19 - if there is one as well as the result
80:22 - and then inside of the body first i
80:24 - would want to check if there is an error
80:26 - and then i can just return null as well
80:29 - as maybe console.log so we go with if
80:32 - error and then we'll say return
80:35 - null or simply return whatever you'd
80:37 - want and if you want you of course can
80:39 - cancel log the error as well like so and
80:43 - then if everything is correct well then
80:46 - of course i'll have access to my data
80:49 - which of course has the name the
80:51 - parameter name of result and since i
80:54 - would simply want to console log the
80:56 - result i'm going to go with console.log
80:58 - and the result but of course keep in
81:00 - mind that this is where you would set up
81:04 - the functionality so let's go back and
81:06 - we're going to go with node app.js
81:09 - and in this case something really
81:11 - interesting where we don't get the text
81:15 - right so we're getting this buffer so
81:18 - this is what's going to happen where if
81:20 - we don't provide that utf coding then of
81:23 - course we'll get the buffer now where do
81:25 - we add this encoding value well right
81:28 - here in between in between the content
81:31 - as well as the path so let's just go
81:34 - with string and we're looking for the
81:37 - utf so let's say utf-8
81:40 - and we'll save that one and let's run it
81:42 - one more time and of course i have node
81:45 - app.js and then hello this is the first
81:49 - text file
81:50 - and now the million dollar question
81:52 - well how we can set up the same
81:54 - functionality
81:56 - check it out we have read file read file
81:59 - and then we simply create a new file
82:02 - with both of these values so if you're
82:04 - familiar with callbacks
82:07 - you know that of course we would need to
82:09 - set up that functionality
82:10 - inside of this callback where i'm
82:13 - getting this result
82:14 - otherwise there's going to be an error
82:16 - because the only way for me to access
82:18 - this result
82:19 - if i'm setting this as a callback is of
82:22 - course inside of this function and this
82:25 - is what i was saying before where yes
82:28 - eventually i'll show you a different
82:30 - approach because inevitably we'll set up
82:33 - a callback help and you'll see that in a
82:36 - second so what i would want to do right
82:38 - now when i get back
82:40 - my first text file well now of course i
82:43 - would want to assign it to some kind of
82:44 - variable
82:45 - and then i would want to read that
82:47 - second file right and then eventually
82:50 - once i read the second file then of
82:52 - course i would want to create that new
82:54 - file
82:54 - and the way it's going to look like
82:57 - i'm going to go with const and i'll say
82:59 - first
83:00 - and you can name it first text i'm just
83:02 - going to know it first and this will be
83:04 - equal to my result okay awesome and then
83:07 - right after that result again i'm going
83:09 - to go with read file
83:12 - and then the same thing
83:14 - we provide a path so we go with content
83:17 - and then in this case of course we're
83:18 - looking for second and then txt then we
83:22 - need to provide the encoding so node
83:25 - knows how to decode that and we go with
83:28 - utf-8 and then of course we need to
83:30 - provide our callback again same deal we
83:33 - go with error
83:34 - and result and in order to speed this up
83:37 - i will copy and paste so just grab
83:40 - everything starting with if and ending
83:42 - with the result copy and paste again
83:45 - this is the case where we're checking
83:47 - for the error first if there is an error
83:50 - we cancel log it and if everything is
83:52 - successful we assign this one to the
83:54 - second one and then eventually now i
83:57 - would want to set up my right file so
83:59 - again it is a function
84:01 - we need to provide that value and we
84:04 - already have result sync txt that's why
84:07 - i'll create a new one and i'll call this
84:09 - result and async so again we're looking
84:12 - for the content then we go with the
84:14 - filename which is going to be result and
84:17 - a sync
84:19 - and txt of course since there is no file
84:23 - node will create that for us i'll right
84:25 - away set up my data now if you want of
84:28 - course you can copy and paste this
84:30 - functionality this is totally up to you
84:32 - where basically we use two of them and
84:34 - in my case this is exactly what i'm
84:36 - going to do in order to speed this up if
84:38 - you want to create something from
84:39 - scratch of course that is also an option
84:42 - and i'm just going to copy and paste
84:44 - that's my template string and again if
84:46 - you want to add this flag
84:48 - you can definitely do so in my case i'm
84:51 - just going to omit that so here's the
84:53 - result i have
84:55 - first and second
84:56 - and the reason why i have access to them
84:58 - because of course i'm looking
85:01 - in the outside scope of this callback
85:04 - function and then again we have a
85:07 - callback function in the right file i
85:10 - know there's tons of callback functions
85:12 - that's why we'll have to set up a better
85:14 - setup when we're handling these
85:16 - callbacks but we'll do that a little bit
85:18 - later so for now let's just add a
85:21 - comment here where we have first
85:23 - parameter second parameter and then
85:25 - third parameter and of course this is
85:27 - going to be again our callback where we
85:29 - have error
85:30 - and result
85:32 - and then inside of this callback finally
85:36 - we can take a look at the value and of
85:38 - course the value will be in this result
85:40 - now of course we're creating the file
85:42 - and all that but hopefully you get the
85:44 - gist that if you'd be doing something
85:46 - where you're looking for this result of
85:48 - course it would be over here so again
85:51 - let's check for error quickly if there
85:53 - is an error then of course i would want
85:55 - to return
85:56 - as well as console log the error
85:59 - just in case and if everything is
86:01 - correct let me just console log the
86:04 - result so save it here
86:06 - and
86:07 - two things we need to watch out for
86:09 - maybe there's an error and second one we
86:12 - should create a new file by the name
86:14 - result and then async txt let me clear
86:17 - the console and we're going to run node
86:21 - app.js and i do get an error and error
86:24 - simply tells me that i did not add the
86:27 - dot in front of the content so i would
86:30 - need to go back to write file and just
86:33 - add that and once we add the dot we are
86:36 - going to be in good place where i'll
86:39 - clear the console and i'll run one more
86:41 - time node app.js and then the result
86:45 - will be undefined okay that's fine like
86:48 - i said in this case we're not expecting
86:50 - anything back but what's really cool
86:53 - that in the result async we should have
86:56 - our text here is the result hello this
86:58 - is first text and then the second text
87:01 - so hopefully it is clear
87:03 - this is how we would use the async
87:06 - pattern so let me zoom out right now
87:08 - here and you'll see this
87:10 - famous callback hell and in the next
87:13 - video i would want to give you a
87:16 - brief description of what are the
87:19 - differences between the asynchronous
87:21 - approach or non-blocking approach and
87:24 - the blocking one the synchronous one as
87:27 - well as what are the alternatives to
87:30 - this callback l all right and just to
87:32 - give you an early taste of the
87:34 - differences between the asynchronous or
87:38 - non-blocking and synchronous which is a
87:41 - blocking code why don't we set up few
87:44 - console logs now before we do that i
87:46 - will create a new file
87:48 - and i'll say 11 here and by the way i
87:51 - definitely need to zoom in
87:52 - just so you don't think that i'm
87:54 - cheating fs
87:55 - and async js
87:58 - and let's go to the address we'll select
88:01 - everything and copy and paste and of
88:05 - course in next video we'll set up
88:07 - different module in this appdress so for
88:10 - time being i can just remove it
88:13 - and then like i promised we'll set up
88:15 - some console logs so why don't we go
88:16 - back to fs and by the way during this
88:20 - video i'll zoom out because i definitely
88:22 - wanna go back to this
88:25 - evil evil callback hell that we're
88:28 - getting from nesting callback within the
88:31 - callback and as far as fa sync
88:34 - let me zoom in
88:36 - and why don't we set up a console log in
88:39 - few places
88:41 - let's say before we're accessing the
88:43 - file
88:44 - so i'm gonna go with log and we'll say
88:46 - start
88:48 - then we're gonna go with write file sync
88:51 - and then right after that we're gonna
88:53 - say i'm done with the task and then
88:55 - inside there let's write done with this
88:58 - task copy and paste
89:01 - and we're gonna go with starting the
89:04 - next one
89:05 - starting
89:06 - the next one
89:08 - meaning the next task
89:10 - so that should do it and of course i
89:12 - need to go with clear so clear my
89:16 - console and i'm gonna go to node and
89:19 - then the file name is 10
89:21 - iphone and then fs and we're looking for
89:25 - sync
89:26 - i run it and notice something
89:28 - interesting where i have the start
89:31 - so that is going to be before i read the
89:33 - files and only then once i'm done
89:37 - writing that file
89:38 - i have done with this task and starting
89:41 - a next one
89:42 - and what we need to imagine that of
89:45 - course this task
89:47 - of getting those files as well as the
89:49 - second one of setting up that file well
89:53 - it might be very time consuming right
89:55 - and imagine that if we have even 10
89:59 - users and they're all the time using our
90:00 - application
90:01 - and if for example this one user does
90:06 - this one task or both of them
90:09 - and they take really long time what
90:10 - means that
90:12 - node is not going to be able to serve
90:14 - other users and trust me it is at the
90:16 - end of the really really big deal and
90:19 - notice how javascript is reading this
90:21 - code synchronously
90:23 - it just goes line by line so we start
90:25 - with this task then we read these files
90:28 - and then we write the result and again
90:31 - if this is something that takes really
90:33 - long time then pretty much your
90:35 - application is down
90:37 - so no other user can do anything with
90:39 - that application because one of the
90:40 - users is for example reading these two
90:43 - files and then writing one again this is
90:46 - a very simple example but you need to
90:49 - picture that of course there's going to
90:51 - be tasks that take longer time
90:54 - and as an alternative let's take a look
90:56 - at the async approach
90:58 - so here again we'll set up some simple
91:01 - console logs and again we'll cover this
91:02 - in a bigger detail a bit later for time
91:05 - being let's just set up console logs and
91:07 - you'll see the biggest difference
91:09 - where i'm gonna go with log
91:12 - and let's say start so i'm gonna do that
91:14 - before i read this file
91:16 - and then i would want to go inside of
91:19 - the right file
91:21 - the last one and instead of console
91:23 - logging result which of course is
91:25 - undefined since in this case we are not
91:28 - getting anything back now i want to go
91:30 - with done
91:32 - with this
91:34 - task and then right after my first read
91:38 - file i'm going to go with log
91:41 - and starting
91:42 - next task
91:44 - hopefully you're able to follow along
91:46 - again before the read file inside of the
91:48 - right file and then right after the
91:51 - first read file because of course the
91:54 - other ones are nested inside of this
91:56 - callback and then if we go to node and
91:59 - if we just change it around to 11
92:03 - and then fa and i believe it was async
92:07 - and if we run it
92:08 - notice something cool
92:10 - where i have my start
92:13 - and then i right away have this starting
92:15 - next task
92:16 - and eventually i have this done with
92:19 - this task so what this means
92:22 - is that since we have this asynchronous
92:25 - approach the moment we start this task
92:28 - we just offload
92:29 - we just offload this task and we
92:32 - continue with our code so that way when
92:35 - user number one for example comes here
92:38 - and wants to get this functionality
92:41 - yeah sure here node just offload this
92:44 - task and then your application can keep
92:47 - on serving other users again
92:50 - it seems a bit trivial at the moment
92:52 - because we have a basic approach but
92:54 - hopefully you get an idea where in one
92:57 - case we have everything happening line
92:59 - by line so only when we're done with the
93:01 - task we're starting a next one
93:04 - and with this approach we start a task
93:07 - and we just offload that task and then
93:09 - we start a next task right away and
93:12 - eventually yes we have done with this
93:15 - task in the console as well
93:18 - now as far as the implementation as far
93:20 - as the callbacks
93:22 - yes this is a bit messy right notice how
93:24 - we only want to accomplish few tasks and
93:28 - it's already somewhat off a pain now
93:31 - alternatives are using promises
93:34 - as well as async await now again
93:37 - hopefully you understand that when we
93:39 - talk about reading the file as well as
93:42 - the writing or file
93:43 - i use this as an example of some kind of
93:47 - task that would take a long time now for
93:50 - the remainder of the course mostly it's
93:52 - going to be reading from the database
93:54 - writing to the database and that sort of
93:57 - thing but this is a very good
94:00 - illustration of how some tasks would
94:02 - take some time so of course we would
94:04 - need to use a callback and as far as the
94:07 - callbacks yes you can use them but the
94:09 - code is going to get messy somewhat
94:12 - quickly that's why a bit later in the
94:14 - course we'll take a look at the
94:15 - alternatives which are promises
94:18 - and a sync await and i have to tell you
94:21 - honestly for the remainder of the course
94:23 - we'll use async await because in my
94:26 - opinion it is just easier to work with
94:30 - excellent and up next we have http
94:32 - module
94:33 - but before we continue let me just
94:35 - mention that i purposely won't spend too
94:38 - much time on explaining every single
94:41 - http method we're going to use in great
94:45 - detail and here's why
94:47 - you see starting from next section
94:50 - all of our work meaning code in some
94:53 - shape or form
94:54 - will revolve around server setup
94:57 - aka http module so that point of course
95:02 - i will cover every last bit of syntax in
95:05 - great detail
95:06 - at this point though i think it's just a
95:08 - waste of our time so if you're confused
95:11 - about something http related
95:14 - don't sweat it we will return to that
95:16 - subject shortly and cover it in far
95:19 - greater detail
95:21 - now if you're wondering
95:22 - why we bother with http module at this
95:25 - point at all
95:27 - since we're going to use it later anyway
95:30 - you see with the help of http module
95:33 - i believe i can show you some core
95:35 - features of node in action
95:37 - and give you somewhat of a
95:39 - visual representation of them otherwise
95:42 - i would have to base everything on
95:44 - slides and i don't think it's the best
95:46 - approach
95:47 - so long story short
95:49 - if you're iffy about something http
95:52 - related
95:53 - just please be patient and i'll answer
95:56 - all your questions
95:58 - in the next course section
96:00 - nice i think we've got a good initial
96:03 - understanding of how the
96:05 - file system module works in node and
96:08 - hopefully i did not lose too many of you
96:11 - so hopefully there are still some
96:12 - students left in the course because i
96:14 - fully understand that seeing this for
96:16 - the first time
96:17 - is probably a bit overwhelming
96:21 - and what i would want to do next is
96:23 - cover the last initial module the
96:26 - built-in module and that is going to be
96:28 - the http module which is going to allow
96:31 - us to
96:33 - set up a web server now please keep in
96:36 - mind one thing we'll just cover the
96:38 - basics because the large part of this
96:40 - course is going to be creating your own
96:43 - server and setting up the api now
96:46 - granted we will use an abstraction on
96:49 - top of the http module and that is going
96:52 - to be the package by the name of express
96:55 - but the whole point is going to be
96:56 - exactly the same that's why again we're
96:58 - not going to cover everything
97:00 - in greatest detail at the moment because
97:03 - i don't see the point of repeating
97:05 - myself
97:06 - and now i want to go back to objects
97:09 - i'll zoom back in
97:11 - just so you can see better what is
97:13 - happening by the way let me check my
97:15 - zoom level so i'm going with settings
97:18 - and i think that should do it my zoom
97:21 - level is two at the moment and then back
97:24 - in the app.js
97:25 - let's grab the http module and we'll
97:28 - assign it to some kind of variable as
97:30 - always
97:31 - let's go with require and we're looking
97:33 - for http that's the module name and the
97:37 - method we would want to use is create
97:39 - server again we'll assign this to some
97:41 - kind of variable and in this case the
97:42 - variable name will be server then we go
97:45 - with http
97:46 - create server and this create server
97:49 - method is looking for the callback and
97:52 - in that callback function
97:54 - we have two parameters and both of those
97:57 - parameters are objects and since they're
98:00 - parameters you can call it whatever you
98:02 - would want but a common practice is
98:05 - calling them rec and res now this first
98:08 - parameter represents the incoming
98:11 - request so imagine a client is
98:14 - requesting from the web browser your
98:16 - webpage so you'll have information about
98:20 - the method and all kinds of useful stuff
98:23 - in that request object and the response
98:26 - is what we're sending back
98:28 - now we're not done of course we'll set
98:30 - up more code here but before we do
98:32 - anything we also would need to
98:34 - specifically say what port our server is
98:37 - going to be listening to and that's why
98:38 - we'll go with server
98:40 - and listen so that's another method and
98:44 - again this is arbitrary but i'm gonna go
98:46 - with 5000. again
98:49 - if this looks like a lot of gibberish
98:51 - where we have the request response as
98:54 - well as the ports don't worry
98:56 - later in the course i'll cover that in
98:58 - more detail as well as show you some
99:01 - useful slides and all that good stuff
99:04 - and as far as the response well
99:07 - we have few methods we have write so we
99:10 - go with arrest and again this is the
99:12 - object and notice here how i'm not using
99:15 - the rack yet so i'm not checking for
99:17 - anything i'm just concerned about my
99:19 - response and the method name is right
99:22 - and inside the right we just come up
99:24 - with some kind of text and i'll say
99:26 - welcome
99:28 - to
99:29 - our homepage
99:32 - homepage and once we have sent back the
99:34 - response i also would wanna end my
99:37 - request so i'm gonna go with res.end
99:41 - and once we're done setting up the code
99:42 - inside of the callback function now of
99:45 - course i would want to open up my
99:46 - terminal
99:47 - clear everything and we would need to
99:50 - spin the sucker up and of course the way
99:52 - we do that is node and then objects
99:55 - since that is the file name make sure
99:57 - that you save it though so before i run
100:00 - i'll save it and then notice something
100:02 - interesting notice how we're not exiting
100:05 - so previously every time we ran the file
100:09 - every time we ran node and then whatever
100:11 - the file name we exited from the file
100:14 - right so node was done executing the
100:16 - code and we just moved on now in this
100:19 - case since we have a web server what do
100:22 - web servers do
100:24 - they keep on listening for requests and
100:26 - actually you want your server to always
100:29 - be up and of course if i go to my web
100:32 - browser
100:33 - and then
100:35 - i'll make this bigger
100:36 - and if we go with localhost
100:38 - and of course in this case we have 5000
100:42 - there it is we have welcome to our
100:45 - homepage so now of course we have
100:48 - effectively created our first website
100:51 - now granted it's very basic but at least
100:54 - we have something on screen
100:57 - and before we discuss the external
100:59 - modules
101:00 - and actually set up a module that nicely
101:03 - watches our code and does the restarts
101:06 - for us
101:07 - i also want to showcase what we have in
101:10 - the request object now this is going to
101:12 - be a giant object
101:14 - so i'm not going to cover
101:16 - each and every property however i would
101:19 - want to showcase a property that gets us
101:22 - the url and what would be the url well
101:24 - that would be an address and if you're
101:27 - worked with reactor or dom you know that
101:30 - for example for the homepage we used
101:32 - forward slash and then if the client
101:35 - wants to go to for example about page he
101:38 - or she would enter forward slash and
101:40 - then the about now in our case notice
101:42 - how we're still serving the same content
101:45 - so just to give you a quick introduction
101:49 - of the request object as well as set up
101:52 - a bit more realistic application we're
101:54 - going to go with the request now again
101:56 - if you want you can log it so we're
101:59 - going to go here with request and you'll
102:01 - see that it is a giant object now since
102:04 - we made some changes we do need to stop
102:06 - it and then we'll go with node object
102:08 - but notice how we're not right away
102:10 - console logging the request object why
102:13 - well because server
102:15 - is waiting for those requests so we need
102:18 - to go back to our browser and then
102:20 - refresh and then of course once we
102:22 - navigate back like i said this is going
102:24 - to be a
102:25 - giant object which bunch of useful info
102:29 - now what we're looking for
102:31 - is the url property because that url
102:34 - property is going to tell us well what
102:36 - address client is requesting so what
102:40 - endpoint the client is requesting and
102:42 - like i said for the home page the common
102:45 - practice is using simple forward slash
102:48 - so in here we can set up the if
102:50 - statement where i say if request url is
102:53 - equal to the home page then of course
102:56 - this is what i would like to send back
102:58 - and just to speed this up i can tell you
103:01 - that we can cheat a little bit where we
103:03 - can just place everything in the end
103:06 - and in my case i'll just cut out my
103:08 - string so we have res dot end so now we
103:11 - simply send the text
103:13 - and now of course i also would want to
103:15 - check for the about or contact or
103:18 - whatever so in here let's go with if
103:21 - and then request
103:23 - and url and if that one is equal to
103:26 - about
103:27 - about then of course i can send
103:29 - different text and as far as the text
103:31 - i'm just going to say here is
103:33 - our short
103:35 - history and then lastly well what
103:37 - happens if the user is trying to access
103:40 - a resource that doesn't exist
103:43 - on our server
103:44 - so we'll have the about page we'll have
103:46 - the home page what about if the user is
103:48 - asking for a contact page that we don't
103:51 - have well here we'll simply set up a
103:53 - default response we'll say res that end
103:57 - and just to make it interesting i'll set
103:59 - up the template string and i'll show you
104:01 - that if we really want to we can also
104:03 - pass indirectly html and i'll say oops
104:08 - an explanation point i'll close my html
104:12 - again please understand this is just a
104:13 - basic scenario of course that's not how
104:16 - we'll be setting up our apis or nothing
104:18 - like that but just to give you a quick
104:21 - intro
104:22 - we'll do it quick and dirty where
104:24 - there's going to be a paragraph and
104:26 - we'll say we can't
104:28 - seem to find the page
104:31 - that you're looking for page
104:33 - you are looking for
104:35 - looking for and at the very end i would
104:37 - want to set up a link
104:39 - that allows the user to navigate back so
104:43 - go with href and i'll say forward slash
104:45 - which just means home page and we're
104:48 - gonna go back home
104:49 - let's close our link let's save that one
104:53 - so at the moment of course we have the
104:55 - about and by the way
104:58 - almost forgot
104:59 - yes we do need to stop the server and we
105:02 - need to go with node and then app.js
105:05 - refresh one more time there it is notice
105:08 - how we don't have the about we can't
105:10 - seem to have the page you're looking for
105:12 - and that is actually a bit interesting
105:14 - because it should be available right and
105:16 - of course the reason is because i messed
105:18 - up on the url property my bad let me do
105:21 - this one more time
105:23 - and we'll stop the server here
105:25 - again let's run node app.js and now we
105:29 - should have here's our short history
105:31 - that's our about page then we have the
105:34 - homepage and of course you already
105:35 - familiar with our error page so if i'll
105:38 - go with error or any kind of resource
105:41 - that doesn't exist
105:42 - then of course we'll get the error page
105:44 - and of course we can bravely navigate
105:46 - back home and we go back to our home
105:49 - page that should do it for the quick
105:51 - intro of base modules
105:53 - and now of course we are ready to move
105:55 - on to our next topic all right at this
105:59 - point we're familiar with two types of
106:01 - modules
106:02 - our own
106:03 - as well as the nodes built-in ones
106:06 - but
106:07 - just like in any good infomercial
106:10 - i'll say but wait there's more
106:14 - we also have access to the world's
106:16 - biggest code store
106:18 - and before you seriously start
106:20 - questioning my mental state
106:23 - imagine this scenario
106:24 - you're building an app
106:26 - and of course as any good app it needs
106:29 - to have a slider
106:30 - just for funsies
106:32 - now at this point you generally have two
106:34 - options
106:36 - build it from the scratch yourself
106:38 - or search on google and copy paste
106:41 - someone else's solution
106:44 - well have no issues with either of these
106:46 - options keep in mind that someone
106:49 - somewhere
106:50 - has struggled with the same issue the
106:54 - need for the slider
106:56 - and there's a good chance that that
106:57 - person
106:59 - was kind enough to build it
107:01 - and share
107:02 - the whole project with us
107:05 - so our only job
107:07 - is to go through the docs
107:09 - and with the help of one command
107:11 - just add it to our project
107:14 - we can do that because when we install
107:16 - node
107:17 - we automatically also install npm
107:21 - or node package manager
107:24 - and npm enables us to do three things
107:28 - reuse our own code
107:30 - in other projects
107:32 - use code written by other developers
107:35 - and lastly share our own solutions
107:38 - with other developers as well
107:40 - the npm project is hosted at
107:45 - npmjs.com again the site is
107:48 - npm.js
107:50 - and here you can find everything
107:53 - starting with useful utility functions
107:56 - to full-blown frameworks and libraries
107:59 - and as an example if you're familiar
108:01 - with react you know that react has the
108:04 - create react app package
108:06 - and of course it is hosted on the npm
108:11 - a typical node project
108:14 - will have more than few npm packages
108:16 - installed as dependencies
108:19 - and before we install some cool packages
108:22 - let's talk about naming
108:24 - npm calls the reusable code a package
108:28 - and a package essentially is a folder
108:30 - that contains a javascript code
108:33 - now another names you'll hear
108:35 - are modules
108:37 - and dependencies and honestly at this
108:40 - point
108:40 - all three are used interchangeably when
108:44 - talking about shareable javascript code
108:46 - so don't be surprised if during the
108:48 - course i call them any of these names
108:50 - package dependency or module at the end
108:53 - of the day they all mean the same thing
108:55 - lastly let me just mention two things
108:57 - first
108:58 - there is no quality control in npm
109:01 - registry
109:02 - anyone can publish anything
109:05 - so it's up to you to sniff out the empty
109:08 - and useless packages and yes there are
109:10 - quite a few of those ones out there as
109:13 - well a good indication of the security
109:16 - and usefulness of package is the amount
109:19 - of weekly download if the number is high
109:23 - meaning if it's popular it's a good
109:25 - chance that it's a battle tested and
109:27 - ready to go
109:28 - and that brings me to my second point
109:31 - remember the slider example we discussed
109:33 - in the beginning of the video
109:35 - when it comes to npm packages there's a
109:37 - good chance that if there is a bug
109:41 - someone else has already fixed it
109:43 - and as a result it's already fixed in
109:46 - the package
109:47 - or
109:48 - there's a working solution
109:50 - all right
109:51 - so that you did for intro let's start
109:54 - using node package manager
109:56 - in our own project and as a side note if
109:59 - you want to search for some packages
110:01 - just visit
110:03 - npmjs.com
110:06 - and then for example if you're looking
110:08 - for the bootstrap you'll find the
110:10 - package
110:11 - and of course you can click on any of
110:13 - them
110:14 - this will bring you to the docs as well
110:17 - as weekly downloads and rest of the
110:20 - stuff once we're familiar with node
110:22 - package manager let's see how we can
110:24 - start using it in our own project
110:26 - and the good news is that it's much
110:28 - simpler than you would expect you see
110:31 - when we install node we also install npm
110:34 - and because of that we have access to
110:37 - npm global command
110:39 - and you can check the npm version by
110:41 - running npm
110:43 - version in your terminal just keep in
110:46 - mind that the version most likely won't
110:48 - be the same as your node version and
110:51 - that is totally okay so you can either
110:54 - do that in the terminal
110:56 - or of course in the integrated terminal
110:59 - and you can simply type npm and then
111:01 - hyphen hyphen version i believe you can
111:03 - also check by hyphen hyphen v and there
111:06 - it is of course now we have the version
111:10 - for our node package manager and then we
111:13 - have two flavors we can install package
111:16 - as a local dependency and that just
111:19 - means that we'll only use that package
111:22 - in this particular project that we're
111:24 - working on and the command for that one
111:27 - would be npm
111:29 - install or i for short and then whatever
111:32 - is the package name so whether that is
111:34 - bootstrap low dash express or whatever
111:37 - or we can install dependency as a global
111:41 - dependency and that just means that we
111:43 - can use it in any project and the
111:46 - command for that one would be again npm
111:48 - i or install whichever method you prefer
111:52 - and then hyphen g so this is going to be
111:55 - the flag and then again the package name
111:58 - now when you install something globally
112:00 - most likely on a mac they will ask you
112:03 - for the sudo so you'll have to provide
112:05 - the credentials that's why you'll run
112:08 - sudo
112:09 - npm
112:10 - install and then hyphen g and again
112:13 - package name
112:14 - as far as which one you'll use more
112:16 - often that definitely will be a local
112:19 - dependency flavor
112:20 - because even though yes you can install
112:23 - packages globally with arrival of npx
112:27 - there's actually less and less need for
112:31 - setting up something globally that's why
112:34 - we'll focus on local dependencies first
112:36 - how to set it up in our project and then
112:39 - in a few videos when we talk about npx
112:42 - i'll cover why there's less need for
112:46 - setting up something globally now
112:48 - there's one more thing that we would
112:50 - need to set up in our project as far as
112:52 - dependencies so i know i know you're
112:54 - eager to start installing the packages
112:58 - but
112:59 - let's just wait a little bit and next
113:01 - video we'll add that extra thing that
113:04 - we're missing right now and then we'll
113:06 - be in good shape and then we'll start
113:08 - installing every package under the sun
113:11 - excellent we now know that we have
113:14 - access to the npm global command we now
113:16 - know that in order to install the local
113:19 - package we will need to run npm i
113:22 - and the package name so what are we
113:24 - missing well we're missing file by the
113:27 - name of package.json
113:30 - and essentially you can think of it as a
113:32 - manifest file that stores important
113:35 - information about our project
113:38 - and there are three ways how you can
113:40 - create package.json first is the manual
113:43 - approach where you just create a
113:45 - package.json in the root and please do
113:48 - that in the root if that's something
113:50 - that eventually you decide doing
113:53 - and then of course you would need to
113:54 - create each property or
113:58 - there are two
113:59 - ways how we can automate this and the
114:01 - first one is running npm init
114:04 - and in there they'll just step by step
114:07 - ask you the questions and if you want to
114:09 - skip it you can just press enter
114:11 - and the another way the third way is
114:14 - running npm init with a y flag and then
114:18 - everything is set up as default so i'm
114:21 - not going to show you the manual
114:22 - approach it's just too time consuming
114:25 - and we'll right away go with npm in it
114:28 - first i'll show you the step by step
114:30 - approach and then of course i'll show
114:32 - you how everything is set up by default
114:35 - using the y flag so go to your terminal
114:37 - and just type npm in it and there it is
114:41 - of course now they tell you that there's
114:43 - going to be a walkthrough of creating a
114:46 - package.json file and the first one is
114:49 - the package name and by default of
114:50 - course it is going to use the folder
114:53 - name now keep in mind that if you
114:55 - eventually want to publish this package
114:58 - then the name has to be unique so you
115:01 - need to make sure that
115:02 - nowhere in the npm
115:05 - you can see the package with the same
115:08 - name and i'm just gonna go with tutorial
115:10 - as far as version we'll talk about
115:12 - versions shortly so i'll just skip this
115:15 - one as far as description whatever again
115:18 - is just the default now as far as the
115:20 - entry point eventually will change it
115:22 - but for now it's good enough we're going
115:24 - to go with one intro js and then the
115:27 - test command as well as git repository
115:30 - and keywords and author and license and
115:32 - we simply say yes and we are in good
115:35 - shape so now of course we have the
115:37 - package json file with name version
115:40 - description as well as the main property
115:42 - and of course the scripts author and the
115:45 - license now i'll remove it
115:48 - i'll say delete and i'll show you that
115:50 - of course you can skip all those
115:52 - questions by simply typing npm
115:55 - in it and why
115:57 - and as you can guess
115:59 - yes of course you can come here later
116:02 - and then just change these values that's
116:04 - why it's definitely faster to just type
116:07 - npm
116:09 - in it and then the y flag
116:11 - so why do we need this package.json well
116:15 - because if i would want to install the
116:17 - package the local package
116:19 - now of course this package is going to
116:22 - be stored as a dependency and to show
116:25 - you that let's just go with npm and you
116:27 - know what
116:28 - let me clear the console first so we're
116:30 - going to go with npm
116:32 - i
116:33 - and then we're going to go with the
116:35 - package name lowdash and if you're not
116:37 - familiar with lodash it's just a utility
116:40 - library and i'm just specifically using
116:43 - for installation purposes there's no
116:45 - real reason to have low dash for our own
116:49 - project but it's just something pretty
116:51 - interesting that i would want to
116:52 - showcase that's why we're using lodash
116:55 - and we run it and notice how we
116:57 - installed the package and check it out
117:00 - now in the package.json we have
117:02 - dependencies property and it's an object
117:05 - and inside of that object we have a
117:08 - package by the name of lowdash now i'll
117:12 - show you
117:13 - in this video or maybe in the next one
117:16 - why it's so important to have this
117:18 - package.json
117:19 - but another thing that i would want to
117:21 - showcase once we can see that we have
117:24 - dependencies property if you go in your
117:27 - visual studio code
117:29 - and if you click on refresh explorer
117:32 - what you'll also notice
117:34 - is this node modules folder and in that
117:37 - node modules folder this is where all
117:40 - the dependencies
117:42 - are stored
117:43 - so if you don't have that folder already
117:46 - and pm creates it so in our case of
117:49 - course we didn't have any dependencies
117:51 - so when we install that first dependency
117:53 - npm creates that folder and this is
117:56 - where you'll find the dependencies now
117:59 - notice something interesting where for
118:01 - the low dash
118:02 - we only have one folder right so we have
118:05 - only one dependency
118:07 - but when we need to keep in mind that of
118:09 - course there's going to be some packages
118:12 - that have other dependencies
118:15 - and that's why i first installed lodash
118:17 - just to showcase that yes once you
118:19 - install dependency of course it is going
118:21 - to be in node modules but if you'll try
118:24 - to install a package that is bigger that
118:27 - uses other dependencies you'll notice
118:30 - something pretty cool where if i clear
118:33 - my terminal and if i'm gonna run npm i
118:36 - and then bootstrap again you can use any
118:39 - other package you'd want this is just to
118:41 - showcase how the packages work we won't
118:45 - use the bootstrap in this project so
118:47 - once i install and once i refresh
118:51 - check it out not only i have low dash
118:54 - not only i have bootstrap which i
118:55 - installed but since bootstrap is using
118:58 - jquery as well as the proper js now
119:01 - these are installed as dependencies and
119:04 - if you take a look at the dependencies
119:06 - property now of course we have the
119:08 - bootstrap as well and again
119:11 - the whole point of this video is to
119:13 - showcase why we need package.json
119:16 - so we need it because we need to provide
119:18 - information about our project and inside
119:22 - there
119:23 - a very important property is the
119:25 - dependencies one because in there we'll
119:28 - just store the dependencies which our
119:31 - project is using and then some packages
119:34 - are actually going to use
119:36 - more dependencies and they will be
119:38 - automatically installed as well in our
119:41 - case that was bootstrap and
119:44 - just to give you a taste of the package
119:48 - why don't we just navigate to app
119:51 - and i'm going to do that below the
119:53 - comments of course you probably would
119:55 - need to clean the file and as a side
119:57 - note the last module the http i saved in
120:00 - file by the name of 12 http
120:03 - and back in the app.js in order to start
120:06 - using
120:08 - the module
120:09 - in our case i guess i'm gonna go with
120:11 - low dash
120:12 - first i would need to set up the
120:14 - variable and common convention is
120:17 - calling the variable like so and we'll
120:19 - set it equal to require and now of
120:22 - course we have access to the low dash
120:25 - now this is the difference between
120:27 - node packages
120:28 - like for example the http
120:31 - or the file module or whatever and the
120:35 - ones that you install the external ones
120:38 - the external ones you always have to
120:40 - install first
120:41 - if you won't install the dependency well
120:44 - node won't be able to find it so in our
120:46 - case we did install the dependency the
120:49 - lowdash so now of course i can just
120:51 - assign it to the variable and since
120:53 - lowdash is utility library why don't we
120:56 - test out one of their methods and i'm
120:59 - just going to go with items and i'll
121:01 - create an array of arrays so items is
121:04 - going to be an array however
121:06 - the items are going to be arrays itself
121:09 - so two and three
121:12 - and then we're gonna go with four
121:14 - and low dash has this method the flat
121:17 - and deep method that effectively will
121:20 - just spit this back as a flat array
121:24 - and the way we set it up we just go with
121:27 - const and i'll call this
121:29 - new items and then since we have access
121:32 - to everything
121:34 - in this variable now i can simply go
121:37 - with underscore here dot and then flat
121:42 - and deep so flatten deep and then we'll
121:44 - pass in the items and now if we console
121:47 - log
121:48 - new items and if i go to my terminal and
121:52 - just type node app.js and by the way i
121:55 - need to save it
121:56 - so let me go back i'll say node app.js
122:00 - and once we run check it out in a
122:02 - console i can see of course the one two
122:05 - three four so lowdash has the method by
122:08 - the name of flattendeep we have access
122:11 - to it because we install it as
122:12 - dependency and now of course i can start
122:15 - using it now we're not gonna use
122:18 - bootstrap in this project because that
122:20 - would be too time-consuming bootstrap
122:23 - was just used so you can see that some
122:26 - dependencies will have
122:28 - more packages so once we install one
122:31 - dependency there's actually going to be
122:32 - more dependencies and hopefully you have
122:34 - a clear understanding of how you would
122:36 - set up package.json how we would install
122:39 - the package and next video i would want
122:41 - to showcase why having package.json
122:44 - is so crucial and so beneficial
122:48 - when we are starting to share our
122:51 - project with other developers
122:54 - awesome we have package.json we
122:57 - installed few dependencies
122:59 - and now i want to cover
123:01 - why having package.json is so crucial
123:04 - when we start sharing our project with
123:07 - other developers and for this example
123:10 - i'm going to use github as well as few
123:13 - basic git commands and my assumption is
123:16 - that since this is somewhat of a
123:18 - advanced course you're already familiar
123:20 - with git and github and you have the
123:23 - account if you don't please stop the
123:25 - video create the account
123:26 - and just use your favorite search engine
123:29 - to learn about the basics of setting up
123:32 - the github repository as well as basic
123:35 - git commands so
123:37 - our task is to push this up to the up
123:41 - and now million dollar question are we
123:44 - just pushing
123:45 - everything up including the mode modules
123:48 - which
123:49 - for the most projects is going to be
123:51 - somewhat big
123:52 - i believe i just checked in our case it
123:55 - was like nine megabytes but trust me it
123:58 - always gets way bigger than that
124:01 - or
124:02 - we would just want to send the code and
124:04 - you can probably already guess that
124:06 - since i'm implying that the size is too
124:09 - big that we'll have to push this up to
124:12 - the github without the node modules and
124:16 - we'll start by creating a dummy repo on
124:19 - a github
124:20 - so let me open up a new window
124:22 - i'm going to go with github
124:24 - and i'll just create a temp repo
124:27 - and then i'm just going to create a repo
124:29 - and i'm looking for these three commands
124:32 - essentially i would want to get that url
124:36 - the remote url so i know where to push
124:39 - it and then inside of the repo before we
124:42 - set it up as github repo first i would
124:45 - want to go with new file and we'll
124:48 - create a git ignored because of course
124:50 - what i would want is to place
124:52 - the node modules
124:54 - in a git ignore file because that way
124:56 - they will be ignored by my source
124:59 - control and i won't be pushing up this
125:02 - giant folder to the github because
125:05 - you'll see in a second that there is no
125:07 - need for it so we're going to go with
125:09 - forward slash and then node modules and
125:11 - if you're not familiar with git ignored
125:13 - it's just a file
125:15 - that specifies which files are going to
125:17 - be ignored by the source control and in
125:20 - our case as you can see i'm placing node
125:23 - modules inside there then i'll clear my
125:25 - console and i'll just initialize this as
125:29 - an empty git repo and then we'll add
125:32 - everything so git add git commit
125:35 - we'll just say first commit
125:39 - first commit and then i'll copy and
125:41 - paste those three commands in order to
125:43 - set up that url
125:46 - the remote url and once i have this in
125:50 - place
125:50 - should be able to go back to my github
125:53 - and there it is this is my repo
125:56 - now probably your next question is okay
125:59 - so we pushed it up to the github
126:02 - but i can clearly see that in my app.js
126:05 - well technically i'm using the load as
126:08 - dependency right
126:10 - but we didn't push up the node modules
126:12 - folder so how the person who is going to
126:15 - get this repo will be able to run the
126:18 - code in the app.js
126:19 - since there's no node modules and you
126:22 - told us previously that we can only run
126:25 - it if the dependency is there well let's
126:28 - check it out i'm going to go with clone
126:30 - option so i'll just get the
126:32 - url i'll navigate back here
126:36 - and i'll do that in messed up again it
126:38 - doesn't really matter
126:40 - we're just going to go with desktop and
126:41 - then git clone
126:43 - now i copy and paste the url i'll open
126:47 - up a
126:48 - new instance of my text error copy and
126:52 - paste and this is where the magic
126:54 - happens
126:55 - if we have package json we simply need
126:59 - to run
127:00 - npm
127:01 - install
127:02 - and what is going to happen
127:04 - the npm
127:06 - will check
127:07 - for dependencies that we have in the
127:09 - package.json and automatically set up
127:13 - that node modules folder so if i go here
127:17 - first of all i can see that there has
127:19 - been some changes that is already good
127:21 - news that just means that
127:23 - i have my node modules and if i refresh
127:26 - check it out so now of course i have my
127:29 - node modules folder and if you have been
127:33 - using react applications you're probably
127:35 - already familiar with this one where
127:37 - again
127:38 - when you are setting up the code
127:41 - you're not sharing the node modules
127:43 - folder and i can showcase that by taking
127:46 - a look at my react projects and that's
127:48 - not what i wanted i didn't want to look
127:50 - at my awesome picture what i wanted is
127:53 - react
127:54 - and then let's go with project
127:57 - and you'll see that in that repo
128:00 - we have bunch and bunch of folders and
128:03 - each folder has two more folders final
128:06 - and setup and now check it out
128:08 - none of them have the node models
128:10 - because imagine the size
128:12 - of this sucker if i would push
128:14 - for every project for every folder the
128:18 - node modules instead i have package json
128:22 - so when you get the repo when you clone
128:25 - the repo or download or whatever
128:27 - then of course you get the package json
128:30 - and in here
128:32 - these are the dependencies and you just
128:34 - run npm install and they are being
128:37 - installed okay hopefully it is clear
128:39 - that why it is so crucial to have the
128:41 - package.json because we can just share
128:43 - the code without dragging the massive
128:46 - node modules folder with us
128:49 - we can simply just provide what packages
128:52 - our project is using
128:54 - and then once we get the repo then we
128:58 - just run npm install that is the command
129:01 - and then npm will install all the
129:03 - packages that are in the dependencies
129:06 - awesome we're familiar with
129:09 - npm we're familiar with package.json
129:12 - now let's finally install the dependency
129:15 - that we'll use for the remainder of the
129:17 - course and that is no other than the
129:20 - node one and of course if you want to
129:23 - get more info you can visit the npm and
129:26 - you can search for the package but as
129:28 - far as the general setup
129:30 - is just to watch our files
129:33 - and then restart our app for us so that
129:36 - way we don't have to each and every time
129:39 - type node and then whatever the file
129:42 - name
129:43 - and we can install it as a simple
129:46 - dependency that is definitely an option
129:48 - but since i also would want to cover
129:51 - depth dependencies we'll install that as
129:53 - a depth dependency and the command for
129:56 - dev dependencies is following where we
129:58 - go with npm and then i or install
130:02 - whatever and then we go with nodemon so
130:05 - that is the package name and then you
130:07 - can either do hyphen d
130:10 - so that just signals that that is a that
130:12 - dependency or you'll see this save and
130:16 - dev so again whichever method you choose
130:20 - that is really up to you but just
130:23 - remember that both of them will save it
130:25 - as a dev dependency so let's install it
130:27 - and then i'll talk about it why we would
130:30 - want to set up as a div dependency and
130:32 - the reason for that is because if we
130:34 - think about it do we really need nodemon
130:37 - in production
130:39 - and the answer is no when we push it up
130:40 - to digitalocean or heroku or whatever
130:44 - we'll of course use something more
130:45 - serious than nodemon to restart our
130:48 - application
130:49 - pm2 comes to mind but while we're
130:52 - developing yeah that is an option
130:54 - so in this case we'll add right away
130:57 - nodemon to the dev dependencies now what
131:00 - else what kind of packages we would add
131:02 - to dev dependencies
131:04 - for example testing packages for example
131:07 - linting for example formatting and that
131:10 - sort of thing again nothing stops you
131:11 - from jamming this in dependencies
131:14 - but
131:15 - if you think about it it makes way more
131:18 - sense if we add this as dev dependency
131:20 - so we use it while we are creating the
131:23 - app but then once it's in production
131:26 - then we just share the dependencies that
131:28 - actually the app is using
131:31 - not the ones that we used while we
131:33 - developed the app hopefully that is
131:35 - clear
131:36 - and once we have the package we're
131:38 - almost there now we just need to
131:40 - understand how the scripts
131:42 - work in a package.json and at the moment
131:45 - as you can see we have the test one we
131:47 - won't use that one and inside of the
131:49 - script object we just set up the
131:52 - commands and as a side note
131:55 - we can set up the command right now even
131:56 - without the node mod for example i could
131:59 - go with start and that command will be
132:02 - equal to npm
132:05 - and or i'm sorry node and then for
132:08 - example app.js so that is my command and
132:11 - once i save my package.json instead of
132:14 - running this node app.js i can simply
132:17 - run npm and start and there it is as you
132:21 - can see
132:22 - same functionality i run app.js and i
132:26 - get back the array as well as the hello
132:28 - world again we still exit the
132:30 - application so it's not like we're out
132:32 - of the woods but i'm just showcasing
132:34 - that yes we can set up the commands and
132:37 - then in the command we just provide a
132:39 - value and in this case of course it is
132:41 - node and app.js
132:44 - now for some commands you can simply
132:46 - type npm start as you can see but for
132:49 - some of them you'll have to provide the
132:52 - full value and that is going to be npm
132:55 - run and nor to showcase that i'm going
132:57 - to go with dev and that one will be
132:59 - equal and here we're gonna go with a
133:02 - node
133:03 - mod and then app.js so instead of
133:06 - running node
133:08 - like we're doing in the start now i'm
133:10 - setting up a dev command and in order to
133:13 - run this one i'll have to go with
133:15 - run and then whatever here's the command
133:17 - name again some of them you'll be able
133:19 - to use the shortcut where you go with
133:21 - start and some of them you'll have to go
133:23 - the full route with npm run and then
133:26 - whatever is the command and as a side
133:28 - note yes you can still run npm run start
133:31 - and this is also going to invoke the
133:33 - command but
133:35 - in our case we have dev and in here i
133:38 - have
133:38 - nodemon
133:40 - and then app js
133:42 - so let's try it out let's say first the
133:45 - package json and you should notice
133:47 - something pretty cool where if i go with
133:50 - npm
133:51 - run and dev
133:53 - now i'm spinning up the node one
133:56 - and it tells me that nodemon is watching
133:59 - my application
134:01 - and since i know that of course we can
134:03 - test it out where i'm gonna go with
134:06 - console.log
134:07 - and then instead of the hello world
134:09 - which i have after new items i'm gonna
134:12 - go with hello people and you should see
134:14 - something interesting where once i
134:17 - change the text yep nodemon restarts
134:21 - my app and now of course my value is
134:23 - hello people awesome so now i don't have
134:27 - to type every time the node and then
134:30 - whatever file name nodemon automatically
134:34 - just restarts my app and i simply set it
134:37 - up as a script now if you want to change
134:41 - this around if you don't want to run npm
134:43 - around dev you can simply say nodemon
134:46 - and then app.js and just remove the dev1
134:49 - completely and a side note again if you
134:52 - have worked with react project you are
134:55 - familiar with the setup because for
134:57 - react again we run npm start and then
134:59 - there's a value that spins up the whole
135:03 - react dev server where we can see our
135:05 - application not bad not bad well we're
135:08 - still on a roll let's cover how we can
135:10 - uninstall the package as well and as a
135:13 - side note if you want to stop the
135:16 - nodemon just press again ctrl and c
135:19 - and notice how we're of course stopping
135:22 - the nodemon and again if we want to spin
135:25 - up we'll just go with npm start and as
135:29 - far as
135:30 - uninstalling the package we have the
135:32 - command for that and the name is
135:34 - uninstall so i'll stop the nodemon and
135:38 - in the terminal i'll type npm
135:41 - uninstall and then of course the package
135:43 - name which in my case is going to be a
135:46 - bootstrap now this is one of the
135:49 - approaches how we can do that and
135:50 - there's also a nuclear approach now why
135:53 - i'm calling this a nuclear approach
135:55 - because that way we remove the whole
135:57 - node modules folder and don't worry
136:00 - once you run the npm install then of
136:02 - course you set everything back up from
136:05 - the scratch as well as you would remove
136:06 - this package like json and don't worry i
136:09 - will cover the package.json file a bit
136:13 - later
136:14 - and the way that is going to look like
136:16 - well we can first clear the terminal
136:18 - i'll install the bootstrap from the
136:20 - scratch again so say bootstrap here and
136:23 - by the way
136:24 - probably need to add npm i
136:27 - and now again as you can see i have it
136:29 - as my dependency and then like i said
136:32 - the nuclear approach is removing the
136:34 - node modules yep
136:36 - and then removing the package log
136:40 - and then just running npm install now of
136:44 - course in the package.json if i want to
136:46 - remove the bootstrap for example in this
136:48 - case i can simply remove it from my
136:50 - dependencies so i just remove it in the
136:53 - package.json then clear everything
136:56 - and then we go with npm and then install
136:59 - and now we'll get from the scratch the
137:02 - node modules
137:04 - since we're the ones who removed it
137:06 - and also we'll get that package hyphen
137:09 - lock json now i'm showing you that
137:12 - nuclear approach because if you have
137:14 - used gatsby you know that cats be
137:16 - somewhat notorious for sometimes just
137:19 - being a little bit annoying where you do
137:22 - need to remove the cache folder you do
137:24 - need to remove the node modules as well
137:27 - as package lock and then once you start
137:29 - up everything from scratch
137:31 - then
137:32 - as a magic the gatsby app starts working
137:35 - and check it out if we take a look at
137:37 - the node modules now yes there's a bunch
137:39 - of modules that nodemon is using right
137:43 - but there's no bootstrap and i can
137:45 - clearly see that because there's nothing
137:48 - under the letter of b so we can clearly
137:50 - see that we removed bootstrap from our
137:53 - dependencies
137:55 - all right and now let's take a look at
137:56 - how we can install package globally and
138:00 - what would be some of the use cases and
138:03 - first let's start with command let's jog
138:06 - our memory command was npm install and
138:08 - then dash g
138:10 - and the package name and in mac they
138:13 - might ask you for permissions so you'll
138:15 - have to start with sudo and then again
138:17 - same spiel npm install blah blah blah
138:20 - and first i want to showcase that i
138:23 - haven't installed
138:24 - nodemon globally
138:26 - and the easiest way for me to showcase
138:29 - that is by running nodemon and app js so
138:34 - we'll try to install
138:36 - nodeman package globally why well
138:38 - because then i can use nodemon in any of
138:41 - my projects at the moment i have it as a
138:44 - local package and of course i can spin
138:46 - it up by running npm start but let's
138:49 - imagine scenario where i have i don't
138:51 - know 20 nodal applications and i'm
138:53 - constantly working on node applications
138:56 - so to make my life easier i will install
138:59 - node 1 globally and then i won't get
139:02 - this error because at the moment you can
139:04 - see command not found normal all right
139:06 - so how do we do that well we can install
139:09 - it
139:10 - in our terminal or we can do it in the
139:13 - integrated thermal it doesn't really
139:14 - matter when it comes to global packages
139:16 - you can install it from anywhere so in
139:19 - my case i'm just going to navigate back
139:20 - to my terminal just so you don't think
139:22 - that i'm cheating
139:24 - and i'll zoom in and we'll simply run
139:27 - and by the way i need to start with sudo
139:29 - and then npm install
139:32 - and hyphen g and of course we're looking
139:34 - for nodemon so now of course
139:37 - i'm prompted
139:38 - to enter my password and once i enter my
139:41 - password
139:42 - of course i'm going to install nodemon
139:45 - globally and now
139:47 - in any of my projects i can simply go
139:51 - with command of nodemon and then
139:53 - whatever
139:54 - is the file name now
139:57 - to show you some of the use cases if you
140:00 - work with gatsby you know that they have
140:02 - the global gatsby cli tool and that was
140:06 - one of the reasons why you installed
140:08 - something globally is because well you
140:10 - used one of the frameworks for example
140:13 - react or gatsby in this case and then of
140:16 - course in order to set up the gatsby
140:17 - project or
140:19 - react project you needed to install this
140:21 - globally now things have changed though
140:24 - with arrival of npx and i'll talk about
140:27 - the npx at the end of the video but
140:30 - notice if you navigate to your react
140:32 - docs and if you look for create react
140:35 - app which again
140:37 - was something that you needed to install
140:39 - globally
140:40 - now they suggest this npx route where
140:44 - essentially you go with npx and then
140:46 - again whatever is the command name for
140:48 - example for create react app that would
140:51 - be create react app for strappy the
140:54 - headless cms that would be create
140:56 - strappy app and hopefully you get the
140:58 - gist where for every resource that of
141:01 - course would be different and with that
141:04 - command you don't have to install that
141:06 - tool globally
141:08 - for example again in our case we're
141:09 - installing nodemon but normally prior to
141:12 - npx you would install this create react
141:15 - app globally and then you can spin up
141:18 - those react projects now i'm going to go
141:20 - back to my terminal as you can see i was
141:22 - successful so what's going to happen if
141:25 - i go back to my project and if i run
141:28 - nodemon and app.js since i have
141:30 - installed that package globally
141:33 - there it is i spin up my app.js and if
141:36 - you don't believe me i can change it
141:38 - back to hello world and i have no issues
141:41 - hello world and there it is now of
141:44 - course i have hello world e in the
141:47 - console so hopefully it is clear that
141:49 - yes we can install packages globally and
141:53 - yes one of the biggest use cases was
141:56 - working with some type of front-end
141:58 - library
141:59 - but with an arrival of npx
142:02 - things have shifted where now those
142:04 - libraries suggest using the npx route
142:08 - instead as far as my personal preference
142:12 - since i'm recording a lot of courses and
142:14 - since some of the global packages
142:16 - usually introduce some kind of bugs
142:19 - to the students now not for all the
142:21 - students but there's always this one
142:23 - student who just has a lot of issues
142:26 - with the global package
142:28 - personally i avoid them as much as
142:30 - possible so i always either use the mpx
142:33 - or i just set it up as a local
142:36 - dependency again it's not a rule you can
142:38 - do whatever you would want but i'm just
142:40 - telling you what is my preferred option
142:43 - as far as what is npx it stands for
142:46 - execute and official name is the package
142:50 - runner it is a feature that was
142:52 - introduced in npm
142:55 - 5.2
142:57 - and again the main idea is following
142:59 - where you can run that cli tool for
143:02 - example in this case create react app
143:05 - without installing these globally so as
143:08 - long as you have npm with a version of
143:10 - 5.2 or greater instead of doing this
143:14 - whole spiel of setting up the cli tool
143:17 - globally you just go with npx and then
143:20 - whatever here is the tool name and of
143:21 - course the last one is the folder name
143:25 - as far as the package log json
143:27 - why do we need it well if we take a look
143:30 - at our dependencies we can see that they
143:33 - have versions
143:34 - and if you remember
143:36 - some of the dependencies have
143:38 - dependencies on their own and of course
143:41 - we need to keep in mind that those
143:43 - dependencies have versions as well
143:47 - and for example the person who gets your
143:50 - project you probably want them to have
143:53 - the same exact setup because keep in
143:55 - mind
143:56 - as these versions change
143:58 - well so does some of the functionality
144:01 - correct so for example you set up to
144:04 - your whole project you use some kind of
144:06 - dependency that uses some other package
144:10 - and that version changes not for example
144:12 - for the bootstrap but for the jquery and
144:15 - then pretty much your project
144:18 - is obsolete meaning
144:20 - it might get some bugs because the
144:23 - version of the jquery changed so that's
144:26 - why you have this package.json
144:28 - and in there you have those specific
144:31 - versions for all the packages
144:34 - not only for dependencies but also for
144:37 - the packages
144:38 - that the dependency is using now as far
144:43 - as this version we have three values and
144:45 - you can think of it as a contract
144:48 - between us
144:50 - the people who are using the package and
144:52 - the person who is creating and first
144:55 - number is a major change so when this
144:58 - changes that means that there are some
145:00 - breaking changes now the second one is a
145:03 - minor one so that means that it is
145:06 - backward compatible so for example if
145:08 - this changes to 18
145:10 - i shouldn't expect any breaking changes
145:12 - and the last one is just a patch for the
145:15 - bug fix so that's also something to keep
145:17 - in mind when you decide to publish your
145:20 - own package that of course that's why we
145:23 - have here this version now lastly i
145:26 - would just want to mention that if
145:28 - you're interested in more info about the
145:31 - package.json i would suggest this
145:33 - resource
145:34 - so i simply went with package.json then
145:37 - keep on scrolling keep on scrolling and
145:39 - you're looking for i guess this blog
145:41 - post right so the name is the basics of
145:45 - package.json and in here you literally
145:48 - find everything explained to the
145:51 - smallest detail whether that is a name
145:54 - version and rest of the fields that you
145:56 - can find in a package.json beautiful we
146:00 - now know how to utilize npm and for
146:03 - starters as a result for the remainder
146:05 - of the course instead of frantically
146:07 - typing
146:08 - node.js in a terminal we'll simply spin
146:12 - up nodemon and it will watch for the
146:14 - changes and restart the app for us
146:17 - now what before we move on to creating
146:19 - servers with express.js there are a few
146:21 - important node topics i would like to
146:23 - cover first and those topics are
146:26 - following event loop async patterns in
146:28 - node.js events emitter and streams in
146:32 - node.js while these topics are extremely
146:34 - important please keep in mind that our
146:36 - goal is to only understand the general
146:39 - ideas behind these concepts
146:41 - and i only introduce them so you have an
146:44 - overall understanding of how things work
146:46 - in node.js before we build our first
146:49 - node.js app
146:51 - if you're not satisfied with my
146:52 - explanations or simply want to do more
146:54 - research by yourself just type any of
146:56 - these terms in your favorite search
146:58 - engine and i can guarantee you'll find
147:00 - plenty of useful resources within a
147:02 - matter of seconds
147:04 - like blog posts youtube videos and
147:06 - conference talks with that said it's my
147:09 - strong opinion that it might be easier
147:11 - to understand those concepts more deeply
147:14 - so not just a general understanding but
147:16 - understanding them more deeply once you
147:18 - have one or few working node apps under
147:22 - your developer's belt let me also
147:24 - mention that in order not to waste your
147:26 - time with time consuming setup
147:28 - in few upcoming videos i will run some
147:31 - pre-built code
147:33 - let me be very clear though i'm only
147:35 - going to do that in a few videos
147:37 - and for the remainder of the course we
147:39 - will type out everything together
147:42 - all right
147:43 - and let's kick things off by discussing
147:45 - the event loop
147:47 - now event loop in node.js is one of
147:49 - those topics where i could spend the
147:51 - entire course discussing it and it still
147:54 - wouldn't be enough so let's try to avoid
147:57 - that and instead just understand the
148:00 - journal concepts
148:01 - while there are tons of useful event
148:03 - loop explanations out there the one that
148:05 - i probably like the most
148:07 - is this one
148:08 - the event loop is what allows node.js
148:12 - to perform non-blocking i o so input and
148:16 - output operations despite the fact that
148:19 - javascript is single threaded by
148:22 - offloading operations to the system
148:24 - kernel whenever possible
148:27 - and as you can see i'm reading straight
148:30 - from the node docs
148:32 - now don't beat yourself up if this
148:35 - sounds like a lot of gibberish there's a
148:37 - reason why one can dedicate the entire
148:40 - course just for event loop it is a
148:43 - pretty complex topic but
148:46 - one word i do want you to remember
148:48 - is this offloading and you'll see why in
148:51 - a second also don't worry i have
148:53 - prepared more examples as well as some
148:56 - slides to get my point across but just
148:59 - in case you're not happy with my
149:01 - examples
149:02 - or you just want to explore the note
149:05 - event loop in greater detail here are a
149:07 - few external resources i find
149:10 - particularly useful
149:12 - when it comes to blog posts
149:14 - just go to your favorite search engine
149:16 - and type node.js
149:18 - event loop
149:19 - and the one that i find really useful is
149:22 - this one
149:23 - and the resource is nodejs and not.org
149:27 - but it is dot dev
149:29 - and then follow the link and here they
149:33 - cover event loop
149:35 - in great detail with a lot of cool
149:38 - examples and pictures and slides and all
149:41 - that good stuff and when it comes to
149:44 - videos i would suggest going to youtube
149:47 - and then just type event loop and the
149:49 - first video that's going to pop up is
149:52 - going to be the event loop bot in
149:54 - browser javascript
149:56 - and i'll talk about it in a second
149:58 - and the nodejs specific event loop video
150:02 - is this one i believe it's 15 minutes
150:05 - long and you can see the name over here
150:08 - so this is a very very useful video
150:11 - where the speaker covers a lot of useful
150:15 - details about node.js loop in great
150:19 - detail and the reason why i'm suggesting
150:21 - the first one as well
150:23 - well
150:24 - what is the language that we use
150:26 - in node
150:28 - that of course is javascript right and
150:30 - even though there's some differences
150:31 - between the event loop
150:33 - the one that we use in the browser and
150:35 - the one that is in the node.js
150:38 - if you understand the concepts behind
150:41 - the event loop that we use in a browser
150:43 - trust me you're already halfway there to
150:47 - understanding how the no js event loop
150:51 - works since it's such an important topic
150:53 - like promised i have prepared some of my
150:56 - own resources as well we'll start with
150:59 - the slides and move on to the closed
151:01 - examples in next video
151:03 - as a side note i made all the course
151:06 - slides available on course api.com again
151:10 - their website name is coors
151:12 - api.com and once you click on the slides
151:15 - link
151:16 - you'll see all the slides
151:19 - and i would want to start our discussion
151:21 - by taking a look at what it means that
151:24 - javascript is synchronous and single
151:27 - threaded and effectively it's just a
151:29 - fancy way of saying that just repeat
151:32 - everything line by line
151:34 - so for example if i have console log
151:36 - with first task
151:38 - then i have a for loop that takes some
151:40 - time in this case two seconds but that
151:43 - could be 10 seconds that could be 20 or
151:45 - whatever and then i have another console
151:47 - log of next task
151:49 - javascript will just start reading
151:52 - everything and it will read it line by
151:54 - line and if this takes a long time it
151:58 - will only run the next test once it's
152:02 - done performing this time consuming one
152:05 - so hopefully that is clear that
152:07 - javascript just reads everything line by
152:10 - line
152:11 - and now let's take a look at our second
152:13 - slide and in here we can see the
152:16 - solution
152:18 - if we would want to offload something to
152:21 - the browser so when we're building
152:24 - browser javascript apps we have this
152:26 - option
152:27 - of offloading to the browser now of
152:29 - course it doesn't mean that we can
152:31 - offload the for loop that's not going to
152:33 - work this effectively is still going to
152:36 - be the blocking code but browser nicely
152:39 - provides the api
152:41 - where we can offload those tasks to the
152:44 - browser and only when the task is done
152:48 - then we execute the callback and
152:51 - probably the example we have done the
152:52 - most is the fetch essentially when we
152:55 - make the network request but we can also
152:58 - do that for example with a set timeout
153:01 - so i still have console.log with first
153:04 - task but then even though my set timeout
153:07 - function
153:08 - has the second argument of zero so
153:11 - essentially i have set timeout function
153:14 - i provide the callback function that's
153:16 - going to be executed in certain amount
153:18 - of time
153:18 - even if this is zero meaning you would
153:21 - expect this one to run right away it
153:25 - only runs after the next task so once
153:30 - javascript is done executing the
153:32 - immediate code
153:34 - only then it executes the callback so in
153:37 - this case we have the set timeout the
153:39 - api that is provided from the browser
153:42 - and we just said that we would want to
153:44 - execute that e in zero seconds so
153:47 - effectively there is no wait time
153:49 - however javascript will first execute
153:52 - this code and only then will execute the
153:55 - callback so that way we can offload
153:58 - those time consuming operations to the
154:02 - browser again it doesn't mean that we
154:04 - can offload for loops it means that
154:06 - browser does provide some apis
154:09 - where we don't have to write the
154:11 - blocking code now let me be very clear
154:13 - though when i say we cannot offload for
154:16 - loops
154:17 - what i mean is that we can still
154:20 - write blocking code in javascript
154:23 - but the browser does provide some nice
154:26 - apis where we can offload those time
154:30 - consuming tasks
154:32 - and that brings us to our
154:35 - main friend the nodejs event loop again
154:39 - before i go over the example let me
154:41 - stress something event loop is somewhat
154:44 - complex and this is just to give you a
154:47 - general understanding
154:49 - so let's imagine this scenario i have an
154:51 - app and just like any cool app
154:54 - i have subscribers or users or however
154:57 - you would want to call them and in this
154:59 - case since my app is so so popular i
155:02 - have eight of them
155:04 - and what do the users do well they're
155:07 - probably being annoying and they're
155:09 - requesting something from the
155:11 - application and as the requests are
155:14 - coming in
155:15 - the event loop is responsible for
155:19 - avoiding this type of scenario
155:22 - so let's imagine this i have all these
155:24 - users the requests are coming in
155:27 - but larry the little
155:29 - decides that
155:31 - in his request there's going to be
155:33 - some kind of time consuming i don't know
155:36 - database crawl or something like that so
155:38 - effectively he's requesting something
155:40 - and behind the scenes in my code that
155:42 - means that i need to perform something
155:44 - that takes a long time
155:47 - so
155:48 - in this case
155:49 - the event loop just registers the
155:52 - callback so it registers what needs to
155:55 - be done when the task is complete
155:58 - because if the event loop wouldn't do
156:00 - that then we would have this scenario
156:03 - where the requests are coming in
156:05 - and because larry is requesting
156:08 - something that takes a long time the
156:10 - rest of the users would have to wait and
156:13 - essentially it's not that the actual
156:15 - operation takes a long time it's just
156:18 - the fact that we're wasting our time
156:20 - on waiting for that operation to be done
156:24 - and only then we can serve the other
156:27 - users but what the event loop does it
156:31 - registers the callback and only when the
156:33 - operation is complete it executes it now
156:37 - keep in mind that again we're not
156:39 - executing this right away
156:42 - when we can effectively it's the same
156:44 - scenario where we run our immediate code
156:47 - first
156:49 - and only then when we have the time we
156:52 - execute the callback so for example in
156:54 - this scenario if i would have hundred
156:56 - console logs
156:57 - after the next task
156:59 - i would run them first and only then the
157:02 - second task would appear here regardless
157:05 - of what is the time set in here because
157:09 - again we're running our immediate tasks
157:11 - first and only then we run the callbacks
157:14 - so the same thing happens here
157:16 - where the requests are coming in let's
157:18 - say that the operation is complete we
157:21 - first registered the callback operation
157:23 - is complete and instead of executing
157:25 - that callback right away
157:28 - it effectively gets put at the end of
157:31 - the line and then when there is no
157:34 - immediate code to run then we execute
157:36 - the callback hopefully that is clear
157:39 - event loop is our best friend because
157:42 - with the help of event loop we can
157:44 - offload some time consuming operations
157:47 - and effectively just keep all our users
157:50 - happy all right and once we have looked
157:52 - at the event loop in theory
157:55 - to hammer this home let's also take a
157:57 - look at some code examples where we can
158:00 - see event loop in action
158:03 - as a side note all code examples are
158:06 - located in the event loop example
158:08 - directory so if you need to take a look
158:11 - just grab the repo and you can find it
158:13 - there and you should be familiar with
158:16 - our first example
158:18 - since it's a async version of read file
158:23 - method
158:24 - so we import read file from the
158:26 - fs module and then we have console.log
158:29 - started our task first
158:32 - then we have
158:33 - read file method where we pass the path
158:36 - we pass the encoding and then of course
158:39 - we have the callback
158:41 - and then in the callback i cancel logged
158:43 - first result and then of course i have
158:45 - completed the first task
158:47 - and then right after the read file
158:50 - i have starting next task
158:53 - and something really interesting in a
158:55 - console i can see that
158:56 - we first cancel logged started the first
158:59 - task
159:00 - then i right away have
159:02 - starting the next task and then of
159:04 - course once i'm done once i get back my
159:07 - result then of course i have hello this
159:10 - is first text file and of course
159:12 - completed first task and again the
159:15 - reason why is this happening because
159:17 - read file
159:18 - is a synchronous
159:20 - and we already know that
159:22 - event loop will offload this in this
159:25 - case to a file system
159:27 - so we start reading the file
159:29 - notice like okay run this line of code
159:32 - then offload this one and only when i
159:35 - get back to the result
159:37 - then
159:38 - run the callback so
159:40 - when the file system responds with error
159:43 - or the data
159:45 - then we invoke this one all right so we
159:47 - offload this task and we just keep on
159:49 - reading the code that's why we have
159:52 - started the first task starting the next
159:54 - one so right away go to the next test
159:56 - and this one this asynchronous one well
159:59 - we're just offloading
160:01 - and then once the response comes back
160:03 - whether it's an error whether it's a
160:05 - success only then we invoke the callback
160:08 - hopefully that is clear now as far as
160:11 - this comment
160:13 - i only added this one because we need to
160:16 - keep in mind that of course i'm just
160:18 - grabbing this code from the file
160:21 - but the file is sitting in the folder
160:24 - so if you were to run
160:27 - nodemon and then directly the filename
160:30 - which is of course going to be in the
160:31 - event loop the path won't match so this
160:34 - path only matches because of course i
160:36 - have app.js but if you'll try to run
160:40 - this code directly in this file that's
160:43 - why it's not going to match and you need
160:44 - to go one level up now my assumption is
160:48 - that you're running it the same as me
160:51 - and you're running that with npm start
160:54 - that's why i kept the path
160:56 - matching to the one in the app.js now
160:59 - our next example so let me clear my
161:02 - app.js i can close the read file as well
161:04 - as package.json and then the next one is
161:07 - set timeout so select here everything
161:10 - and copy and paste in my fgs i'll
161:13 - restart and then i have two console logs
161:17 - and the third one is e in a set timeout
161:20 - and this is pretty typical example for
161:23 - javascript loop as well if you have
161:25 - taken javascript courses which again i
161:27 - assume you have since you're watching
161:29 - the note one you probably remember this
161:32 - example where i got you here is
161:34 - following yeah i have the
161:35 - console log
161:37 - first and i have the second and third
161:40 - and you think that since set timeout is
161:42 - set to zero
161:44 - so since we're saying yeah call this
161:46 - callback function but actually wait only
161:49 - zero seconds you'd think
161:51 - that the order would be first second and
161:54 - third right well wrong because we have
161:58 - first third and second
162:00 - why well because set timeout is
162:02 - asynchronous correct and what happens
162:05 - with asynchronous well they get
162:07 - offloaded so in this case we run first
162:10 - third
162:11 - and then the second
162:13 - because this one gets offloaded again
162:16 - this one goes to the back of the line
162:18 - and only when we're done
162:20 - with our immediate code pretty much with
162:23 - our synchronous code only then we invoke
162:27 - that callback all right now i also added
162:30 - these comments here where i have started
162:32 - operating system process and then
162:35 - completed and exited the operating
162:38 - system process and the reason why i'm
162:40 - showing you that because in next two
162:42 - examples we'll do something a little bit
162:45 - different so now i would want to go to
162:47 - set interval
162:49 - and by the way it's going to be a bit
162:51 - clearer if we run here node and then
162:54 - app.js so let me stop this and i'll go
162:57 - with node and objects and you'll notice
162:59 - that we started the operating system
163:02 - process and then the moment we're done
163:04 - with the code that's it we exit now if
163:08 - we'll take a look at the set interval
163:10 - you'll notice something really
163:12 - interesting where if i go with node and
163:16 - app.js notice something interesting and
163:18 - by the way of course i didn't copy and
163:19 - paste so go to the third example
163:22 - and then just remove all this code and
163:26 - copy and paste so that's my third
163:27 - example and in here i have the set
163:30 - interval now again yes we'll have to run
163:32 - few times node app.js
163:34 - and now check it out
163:36 - so what i see here is
163:38 - i will run first
163:40 - so that's my console log
163:42 - and then i have the set interval
163:44 - and notice how we're not exiting the
163:46 - process here
163:47 - so we start the process similarly to the
163:50 - second example
163:52 - but if in the second example we actually
163:55 - exited because we completed all our
163:57 - tasks
163:58 - in this case we're not doing that why
164:00 - well because set interval is
164:02 - asynchronous
164:04 - now the difference between the set
164:06 - timeout and set interval is the fact
164:08 - that set interval
164:10 - runs in those increments in this case of
164:12 - course it is those two seconds so every
164:16 - two seconds the
164:18 - event loop
164:20 - is just gonna invoke that callback now
164:23 - that's why we're not exiting
164:25 - that's why we're still in the process
164:27 - and we can only exit the process if we
164:30 - kill it so that would be control and c
164:34 - or there's some unexpected error
164:36 - otherwise it will always stay alive now
164:39 - again keep in mind one thing where
164:42 - notice i will run first
164:45 - was first why well because again this is
164:48 - asynchronous and i know i've said this
164:50 - before 20 000 times but again this is
164:53 - probably the core building block of no
164:55 - the fact that
164:56 - every time we have some asynchronous
164:58 - action it's just going to be offloaded
165:00 - and then when it's time we invoke the
165:04 - callback and our last example is a
165:06 - server and again i just wanted to
165:09 - showcase how the process stays alive
165:13 - so i'll take all the code
165:15 - and copy and paste in app.js
165:19 - now i'll stop this one so stop the
165:22 - process and then we'll clear the console
165:24 - and again
165:25 - just to showcase how the process stays
165:27 - live i'm going to go with node and
165:29 - app.js and i'm doing that so you're not
165:32 - confused with nodemon and then check it
165:35 - out so we have server listening on port
165:38 - 5000
165:40 - and then every time the request comes in
165:44 - well we invoke this callback and in our
165:47 - callback we're simply cancel logging
165:49 - request event and then we send back the
165:52 - hello world so now if i were to go to a
165:56 - localhost 5000 there it is
165:59 - i have the response of hello world and
166:02 - in a console i'll see this request event
166:05 - and check it out how again this process
166:08 - stays alive
166:09 - why well because listen is asynchronous
166:13 - and the moment we set it up now event
166:16 - loop
166:17 - is just waiting for those requests to
166:19 - come in
166:20 - and then once they come in then of
166:23 - course we run our callback now please
166:26 - don't confuse this callback with what
166:29 - we're responding
166:31 - our request i went so this callback is
166:34 - just when we're setting up the server
166:36 - because in here we can have the success
166:38 - over there so in our case as you can see
166:40 - everything went great we have server
166:42 - listening on port 5000 but of course
166:45 - there also
166:46 - might be an error and this one of course
166:50 - just responds to that request event but
166:53 - the whole point is with server.listen we
166:57 - just say hey event loop just keep
167:00 - listening
167:01 - for those incoming requests and the
167:03 - moments show up
167:04 - then respond to them appropriately
167:07 - hopefully it is clear and of course we
167:10 - can move on to our next topic all right
167:12 - and up next i want to talk about
167:14 - asynchronous patterns in node.js
167:18 - so if we remember
167:21 - when we were setting up the file system
167:24 - module
167:24 - we covered how we have two flavors we
167:27 - have the synchronous one and the
167:30 - asynchronous one
167:31 - and while asynchronous one is great
167:34 - since we're not blocking the event loop
167:37 - the problem is that if we're using this
167:39 - callback approach
167:41 - well it gets messy pretty quickly right
167:44 - because we're nesting one callback
167:46 - inside of the other one so now in the
167:49 - following videos i would want to show
167:51 - you the alternative that we'll use
167:53 - throughout the course
167:54 - and why in my opinion it is much cleaner
167:58 - syntax and that's why of course we'll
168:00 - use it and first what i would want is
168:03 - just to kill everything here and i'll
168:05 - start with the nodemon
168:07 - since
168:08 - i'm done showing you the event loop and
168:10 - we're just going to go with npm start
168:13 - right that was the proper one and now
168:16 - i'll delete everything that i currently
168:18 - have not here sorry so i'll leave this
168:21 - one the async one i would want to remove
168:23 - everything in the app.js
168:25 - and now i just want to quickly show you
168:28 - the code that would block that event
168:31 - loop again this is going to be the video
168:33 - where
168:34 - if you don't want to
168:35 - code along you don't have to you can
168:37 - just sit back and relax
168:39 - and effectively you'll be in good shape
168:43 - and again we'll set up the server like i
168:45 - mentioned before already 20 000 times
168:48 - don't worry about specific commands
168:50 - we have rest of the course where we'll
168:53 - be building servers so trust me you'll
168:55 - get sick of it so go with http
168:59 - and require
169:01 - and of course we're looking for http
169:02 - module
169:03 - and then remember the methods create
169:06 - server and listen
169:07 - so we go with const and we create the
169:09 - server
169:10 - that is http
169:12 - and create server we pass in callback a
169:15 - callback takes two objects request
169:18 - object and response object so again
169:20 - essentially request object is what is
169:22 - coming in and response object just
169:25 - represents what we're sending out what
169:28 - essentially we are responding and then i
169:30 - would want to listen on a port again so
169:32 - i run server.listen and then i'll pass
169:35 - in the port of 5000 and then of course
169:38 - we have that callback once the server is
169:41 - ready and in here we can just go with
169:43 - console.log
169:44 - and we'll simply say
169:46 - server is listening on port
169:49 - 5000 server is
169:52 - is listening or just listening
169:55 - listening
169:57 - on port and then of course in my case
170:00 - port is 5000
170:02 - let's set that up so we should have this
170:05 - listening on port 5000 and then of
170:07 - course in my callback function i would
170:10 - want to check 40 urls because i want to
170:13 - show you how even if we try to get a
170:16 - different resource we're still blocked
170:19 - by other user
170:20 - if he or she is requesting some kind of
170:23 - resource where we have the blocking code
170:26 - and don't worry if this sounds like
170:28 - gibberish you'll see what i mean in a
170:30 - second so remember on the request object
170:33 - we could check for the url
170:35 - so effectively you could check what is
170:38 - the resource that the user is requesting
170:40 - so for example home page would be
170:42 - forward slash and then the about page
170:45 - would be forward slash and about and
170:47 - that is sitting in the property by the
170:49 - name of request and url so request is
170:53 - the object and then url is the property
170:56 - so again we'll do a quick and dirty way
170:58 - we'll just say request url is equal to a
171:03 - forward slash that means it's a homepage
171:05 - and then we just need to go with a
171:07 - res.end
171:09 - and then we'll say home page again later
171:12 - we'll have way more sophisticated
171:14 - approach but for now this will do
171:16 - and then we're checking for the about
171:19 - page
171:20 - okay
171:21 - awesome so this is going to be an about
171:23 - page and then
171:25 - if there's a page that doesn't match
171:28 - any of the resources
171:29 - then of course i'll just send back
171:32 - i don't know error page i'm not going to
171:34 - set up the whole link nothing like that
171:37 - all right we save it and then this
171:40 - should send back about page awesome and
171:43 - then of course in home page i can just
171:46 - respond with the homepage so life is
171:48 - beautiful users can come here and as a
171:51 - side note multiple users i'm
171:53 - representing with these tabs so imagine
171:56 - these are my users and life is beautiful
171:59 - we are requesting resources and we're
172:02 - just going on about our day now the
172:04 - problem is going to be if i go to about
172:08 - and if i set up some kind of blocking
172:10 - code now what would be a blocking code
172:13 - well that could be
172:14 - a nested for loop
172:16 - so i'm just going to go with blocking
172:18 - code and then i'll add some exclamation
172:20 - points and let's simply set up a for
172:23 - loop let's say i
172:26 - is equal
172:27 - to zero
172:29 - and then let's say i is less than
172:32 - thousand
172:33 - and yep i plus plus so
172:36 - every iteration will increase by one
172:38 - however
172:40 - i'll set it up as a nested portal so
172:42 - copy and paste and i'll just change
172:44 - these values
172:46 - to j
172:48 - so j here and j here
172:51 - and then let's just cancel log
172:54 - and we'll say j and i again doesn't
172:57 - really matter what we type there just
172:59 - say i
173:00 - and j
173:02 - now known dialogue question what do you
173:04 - think is gonna happen
173:06 - so if the user navigates to about i mean
173:10 - we can kind of see that this will take
173:12 - some time
173:14 - right
173:14 - now you would expect though that
173:17 - only the user who navigates here
173:20 - gets blocked
173:21 - and
173:22 - you'd be wrong because we'll also block
173:26 - the other suckers who are just trying to
173:28 - get to the homepage so let me navigate
173:30 - here
173:31 - and check this out so i run this one and
173:33 - notice how we're loading now the same
173:35 - thing happens here now and here
173:38 - okay and only when we're done here
173:41 - then these two can get the resource
173:44 - again
173:45 - now of course if i go
173:46 - to
173:47 - my project i can see that in the console
173:51 - i have all these values right because i
173:53 - have this blocking code i have the
173:55 - synchronous code that just takes a long
173:58 - time and this is just a representation
174:02 - of why
174:04 - we prefer this asynchronous
174:06 - now yes at the moment this is messy and
174:08 - don't worry in the next videos we'll fix
174:10 - it but this hopefully gives you an idea
174:13 - why you should always strive setting up
174:15 - your code asynchronously
174:18 - because what we've learned in the
174:20 - previous videos
174:21 - if we do that
174:22 - then those tasks
174:24 - are offloaded and then only when the
174:28 - data is back only when it's ready
174:31 - then we invoke it and that way we're not
174:34 - blocking the other users hopefully it is
174:36 - clear and now of course let's take a
174:38 - look at some other patterns we can use
174:40 - so we still get the benefits so we're
174:43 - not blocking that event loop
174:46 - but
174:47 - we also have a cleaner code
174:49 - where we don't have this nested callback
174:53 - mess all right and once we have covered
174:56 - why it's so important to use the
174:58 - asynchronous approach
175:00 - now of course let's clean up our f a a
175:04 - sync
175:05 - so instead of using these nested
175:06 - callbacks let's see a nicer pattern and
175:10 - as i say note if you want to see the
175:12 - code
175:13 - that we wrote in a previous video and
175:16 - the one we are about to write then the
175:19 - files are located in two async patterns
175:23 - folder so i'll close everything for now
175:26 - and then back in app.js
175:29 - i can remove it like i said if you want
175:30 - to access that code it is sitting in the
175:33 - two async patterns folder and we'll
175:37 - simply start by recreating the
175:39 - read file setup where i'm gonna go with
175:42 - const and i'm right away accessing that
175:45 - from the file system module and i'll set
175:48 - it equal to require of course and then
175:51 - file system all right that's awesome we
175:53 - know that it is asynchronous so we need
175:56 - to set it up with three parameters we go
175:59 - with read
176:01 - file and then we would want to pass in
176:04 - path first so again since i'm in app.js
176:06 - i'm going to be looking for the content
176:08 - and then forward slash and then first
176:11 - txt the file we already created before
176:13 - then we have encoding so comma and then
176:16 - again we're going to go with utf-8 and
176:18 - then last one is going to be that
176:20 - callback where the first value is the
176:23 - error and then the second one is the
176:26 - data that we're getting back okay
176:28 - awesome so once the file system responds
176:32 - then of course we invoke this callback
176:34 - and inside of that callback we have our
176:36 - logic so if there's going to be an error
176:39 - for time being
176:41 - i will just return like so
176:44 - and then if i have the data i'll set it
176:46 - up as else so say here console log
176:50 - and data of course
176:52 - and we shouldn't be surprised
176:54 - if we've seen a console hello this is a
176:57 - first text file because we already
176:58 - covered the setup right so we're passing
177:01 - the path we pass in the encoding and
177:04 - then we set up the callback now the
177:07 - problem starts if we would want to
177:09 - perform
177:10 - multiple actions if i want to read two
177:13 - files and then for example write one
177:16 - correct so what would be a better
177:18 - solution well a better solution
177:20 - would be turning this into a promise and
177:23 - then eventually we'll set up async await
177:26 - now please keep in mind that the only
177:28 - reason why i will type out the promise
177:30 - stuff is because i would want you to
177:33 - understand what is happening behind the
177:35 - scenes but don't worry throughout the
177:37 - course we'll just stick with a sync and
177:40 - a weight syntax and essentially you
177:43 - won't have to worry about what is
177:45 - happening behind the scenes but the
177:46 - first example yes i want you to
177:48 - understand everything in detail so what
177:51 - we could do is create a new function
177:54 - and we can just say const and then
177:57 - i'll call this get text now this get
177:59 - text will take a path
178:01 - since i want to read two files and then
178:04 - eventually write one as well just like
178:06 - we did here and of course the goal here
178:08 - is to showcase how we can make the code
178:11 - in the file fs async at least that's how
178:14 - i called my file much cleaner and more
178:17 - readable so again we pass in the path
178:19 - and then what i would want to return
178:22 - from this function is a promise so we go
178:25 - with return
178:26 - new promise and then in the promise
178:30 - object we need to pass in is another
178:33 - callback function so we pass in the
178:35 - callback function and in here we pass in
178:37 - two more functions one for resolve and
178:40 - then one for reject and then once i have
178:43 - set up both of these parameters now of
178:45 - course what i would want is to move the
178:48 - read file
178:49 - and place it inside of the promised one
178:53 - okay so once we place it here first of
178:56 - all notice here how i'm passing in the
178:58 - path so of course i can change this one
179:00 - around so i can say path and then the
179:03 - encoding stays the same
179:05 - as well as the callback however inside
179:07 - of the callback once i have access to
179:10 - resolve and reject what i could simply
179:13 - say that if there is an error
179:15 - i will spit back the error so say reject
179:18 - an error and if everything goes great
179:21 - now of course let's go with resolve and
179:24 - then we'll pass in the data and once we
179:26 - have this setup what's really cool that
179:29 - now i can invoke get text and this is
179:32 - going to return a promise and then of
179:35 - course we can chain that then and catch
179:38 - so below the get text i can go with get
179:41 - text and of course we're looking for the
179:43 - path so we still would need to use dot
179:45 - and then forward slash and then content
179:47 - of course and first txt so that's the
179:50 - path and then like i said
179:53 - we are returning a promise so we can
179:56 - chain that then
179:57 - and of course here i can have the result
180:00 - and i'll just cancel log it for now
180:03 - or result and then i can also chain that
180:06 - catch and here i'm passing in the error
180:09 - so again we can't log it
180:11 - and we simply would want to see the
180:13 - error i save it and beautiful
180:16 - again in a console i have hello this is
180:19 - first text file so i know that it worked
180:22 - and also if i change the path
180:24 - so if i make my path incorrect we should
180:27 - see in the console the error
180:30 - where of course node cannot find file so
180:33 - if that works now of course we can take
180:35 - a look at how we can make it even
180:37 - cleaner by setting up async 08 and once
180:41 - we have our initial setup once we have
180:44 - turned this into a promise
180:47 - technically we're not out of the woods
180:50 - because if i would want to perform again
180:53 - two file reads and then eventually write
180:56 - the file as well and if i would want to
180:58 - do all of that asynchronously it's still
181:01 - going to be paying just by using the
181:03 - promises so what would be a solution
181:06 - well since we're returning a promise if
181:08 - i use async await
181:11 - i can wait till promise is settled
181:15 - and then decide what i would want to do
181:17 - and the way we set that one up is by
181:20 - creating a new function now please keep
181:23 - one thing in mind where
181:25 - eventually throughout the course
181:28 - those functions that i'm about to set up
181:31 - are going to be provided to us
181:32 - so we'll just attach that async to the
181:36 - callback functions that already provided
181:38 - us by the libraries okay but in this
181:41 - example i'll have to create one from the
181:43 - scratch and again the whole point here
181:45 - is because i would want to create a
181:46 - function a start function that i'm going
181:49 - to set up as a synchronous function and
181:52 - i would want to attach a weight
181:54 - so i would only respond once the promise
181:57 - is settled so in here i go const start
182:01 - and that's my function but i need to set
182:03 - it up right away as async because i
182:05 - would want to use my await keyword
182:08 - correct and then we simply go with const
182:11 - and i know that of course i'm looking
182:13 - for the first file
182:14 - and i'll just say first and that one is
182:17 - equal to
182:18 - get text and basically i want to pass in
182:21 - the same thing here now i do need to
182:24 - place this one in quotation marks so my
182:26 - bad i messed it up a little bit okay i
182:28 - passed it in and that should do it
182:31 - now of course what i'm missing here is a
182:33 - weight so i had this await and now only
182:36 - once the promise is resolved
182:39 - then i'll get my response so what i
182:42 - could do here
182:43 - is just comment these two or you know
182:46 - what this one i cannot comment out yet
182:48 - don't worry we will eventually
182:51 - this one i can comment out and then
182:52 - maybe
182:53 - move this below
182:55 - okay so you don't think that i'm running
182:57 - this code and since i have my function
182:59 - now of course i would need to invoke it
183:02 - so invoke start
183:04 - and check it out now of course i don't
183:07 - have the error which is a good sign i
183:09 - guess
183:10 - and then we'll simply go with log and
183:12 - none first
183:14 - and notice the difference
183:16 - where previously when we were setting up
183:18 - the callbacks we had to nest everything
183:20 - now i'm waiting for this promise to be
183:22 - resolved and only once it's resolved
183:25 - then of course i can do something with
183:27 - the value now every time we have this
183:29 - async await approach what we would want
183:32 - is to wrap this e in the try catch block
183:35 - so if something goes wrong then we have
183:38 - at least a little bit of control over it
183:41 - so i'll set up try catch block and then
183:44 - i'll set up my first await and
183:46 - eventually we'll add here more
183:49 - and then in the error i'll simply go
183:52 - with console.log and we'll console log
183:54 - the error and let's just save that one
183:57 - so now we have nice try and catch block
184:00 - and by the way sorry i deleted it we'll
184:03 - still take a look at the first one and
184:05 - then if we change the path
184:07 - then of course we'll get an error okay
184:09 - so that's good now i have my start
184:12 - function it is the synchronous i'm
184:14 - waiting for the promises to resolve
184:16 - they're all wrapped in try catch block
184:19 - so what's next well if you remember in
184:22 - here
184:23 - what were the actions that we were doing
184:27 - well we read two files correct and then
184:30 - we wrote one okay so let's try that one
184:33 - with this new approach where essentially
184:35 - i have first so just copy and paste and
184:38 - then i'll look for the second file
184:41 - remember
184:42 - we should have that in the content so
184:44 - this is going to be the second one
184:47 - second over here and then i would want
184:50 - to write the file now of course
184:52 - you could say well the problem here is
184:54 - going to be that i'll have to
184:57 - write a new wrapping function to set it
185:00 - up as a promise because
185:02 - yes we can of course read the file but
185:05 - functionality for the write file again
185:07 - we would need to wrap it
185:09 - don't worry there's a way how we can get
185:11 - this actually out of the node
185:14 - first i just want to showcase how much
185:16 - cleaner this already is
185:18 - where i can just wait for first
185:21 - second like so and now notice in the
185:23 - console hello this is the first text and
185:25 - hello this is the second file again i
185:28 - fully understand that you're looking at
185:30 - this wrapper function and you're like
185:32 - well this definitely doesn't look that
185:35 - much cleaner than this one don't worry
185:37 - there's a way for us to get those
185:40 - functions
185:41 - in a way that they're already returning
185:44 - a promise what i would want you to focus
185:47 - on
185:47 - is this code what i would want you to
185:50 - understand that this definitely
185:52 - is much cleaner than what we have here
185:55 - we read the file and then we set up
185:58 - another nested callback
186:00 - and another nested callback and
186:02 - hopefully you get the gist
186:04 - waiting for these promises to resolve is
186:07 - definitely a cleaner and more readable
186:11 - approach all right so this works we have
186:14 - our start function it is asynchronous
186:16 - we're waiting for prompts to resolve and
186:18 - we can see that it is already much
186:21 - cleaner
186:22 - how we can set up this code
186:24 - without the wrapping function
186:27 - well what's really cool that in node
186:29 - there is a module by the name of util
186:33 - and we just go here const and we'll
186:35 - assign it to a variable and we'll just
186:38 - be looking for require of course
186:41 - since we would want to import the module
186:43 - and again the name is util
186:46 - and then instead of this module we have
186:48 - a method by the name of promisify
186:51 - and with the use of this function we can
186:54 - take our read file which of course was
186:57 - looking for the callback and turn it
186:59 - into the function that returns a promise
187:02 - and again this is over simplified
187:05 - version what is happening there but
187:06 - hopefully you understand that as a
187:08 - result we'll get again this promise back
187:12 - now the way we'll set that up of course
187:14 - we have read file here already so i
187:16 - cannot use the same name that's why i'll
187:18 - go with read
187:20 - file and we'll call this promise and
187:23 - that one is equal to util that is of
187:26 - course my module dot and then notice the
187:28 - function promisify and then we pass in
187:31 - that read file function so now i have my
187:34 - promise one so now what i could do
187:37 - is first of all comment this out and
187:39 - move it down
187:40 - again so it stays for your reference
187:44 - but
187:45 - it doesn't compromise my view
187:48 - and of course now i have the error
187:50 - because
187:51 - well get text is not defined that's fine
187:54 - don't worry and i'll copy and paste and
187:57 - since i also want to write a new file
188:00 - i will get from the file system one
188:04 - the right file function and then i'll do
188:07 - the same thing
188:08 - where in this case it's going to be
188:10 - called
188:11 - write file promise
188:13 - and then we pass in write file
188:16 - and of course now instead of calling
188:18 - get text what i'm gonna do is go with
188:22 - right file or i'm sorry in this case
188:24 - we're going for read file promise and
188:27 - then keep in mind one thing where this
188:30 - is not a get text one so we're still
188:32 - looking for the path
188:34 - as well as the encoding that's well copy
188:37 - and paste and then second argument we
188:39 - pass in is the encoding and again our
188:43 - functionality shouldn't change where i
188:45 - should see in console the results from
188:49 - the first txt now of course i want to do
188:52 - the same thing with the second one so
188:55 - have read file promise second txt
188:58 - again we have to pass in the encoding
189:01 - otherwise we'll get the buffer back
189:04 - so copy this and paste and again if we
189:07 - cancel log it there it is we have hello
189:10 - this is first text file and this is the
189:12 - second one and since in the line 4 we
189:15 - passed in
189:16 - write file into promisify of course what
189:20 - we could also do is right away write the
189:23 - file so i can go with await and i'm
189:25 - simply not assigning this to a variable
189:28 - because well i'm getting back on the
189:31 - finder as far as data and i'm just going
189:33 - to go with await
189:35 - write file promise and the same spiel we
189:39 - pass in first the path and in this case
189:42 - of course if the file is not there
189:44 - node will create one
189:46 - and the name will be result and i'll
189:49 - just call this mine
189:51 - grenade and then txt and then the second
189:54 - one is data so for that one i'll set up
189:57 - my template string and i'll just say
189:59 - this is
190:01 - awesome
190:02 - awesome
190:03 - and then let's set up the colon and then
190:06 - we'll access both
190:07 - first
190:08 - as well as the second one so we'll
190:11 - interpolate both of them
190:14 - second
190:15 - and then once we save
190:17 - if we take a look at the content there
190:19 - it is now we have the mind grenade one
190:22 - correct now there's probably one where i
190:24 - was testing yep there's one where i was
190:27 - testing so i'll remove this one but if i
190:29 - take a look at dtxd1 then of course i'll
190:32 - have this is awesome hello this is first
190:35 - text file and then i have the second one
190:38 - now what's even more cool
190:41 - that technically we can even skip this
190:43 - part as well again
190:45 - i'll leave this one for your reference
190:47 - but
190:48 - if you go to require
190:52 - and then you require of course file
190:54 - system module but if you add dot
190:56 - promises
190:58 - what do you think is going to return
190:59 - well effectively the same thing so now
191:02 - of course i just need to change the name
191:04 - from read file promise and write file
191:07 - promise back to read file and write file
191:10 - since those are the two functions that
191:13 - i'm importing and that will right away
191:15 - return promises and again we save and
191:18 - remember that by default we're just
191:20 - overwriting stuff
191:22 - so if i were to go
191:25 - and add a third argument my options one
191:28 - and if i'm just going to say
191:30 - flag and i'll set it equal to upend once
191:34 - we save well now we have this is awesome
191:37 - repeat it one more time again just to
191:39 - showcase that our functionality still
191:42 - works
191:43 - i fully understand that there was a
191:45 - little detour
191:46 - where we created our own wrapper
191:49 - function
191:50 - and then we covered how we would consume
191:54 - promises but hopefully this helps you
191:57 - understand that this approach is
191:59 - definitely way better
192:01 - so it is more readable it is more
192:04 - easier to wrap your head around and
192:07 - that's why for the remainder of the
192:08 - course we'll stick with this one
192:11 - again
192:12 - some things will be provided
192:14 - to us by default so libraries will
192:17 - provide the functions that return
192:19 - promises will right away have the
192:20 - callback functions that we'll just set
192:22 - up as async and hopefully you get the
192:25 - gist so a lot of things will be given to
192:27 - us but the core functionality won't
192:30 - change where instead of using callbacks
192:33 - and nesting them inside of the other
192:35 - callbacks and nesting more and more and
192:38 - more
192:39 - we'll set up everything with async await
192:42 - because the syntax is cleaner and way
192:47 - easier to read
192:48 - excellent once we have covered async
192:50 - patterns we're going to use throughout
192:52 - the course now let's talk about events
192:55 - in node.js
192:56 - when working on browser javascript apps
192:59 - a big part of our work
193:02 - is to handle events for example
193:05 - user clicks a button
193:07 - and of course in our program we handle
193:10 - that user hovers over the link
193:13 - and again same deal in our program we
193:16 - are handling that and hopefully you get
193:18 - the gist essentially as our program
193:21 - executes at least in part it is
193:24 - controlled by events
193:26 - of course depending on a program but
193:28 - it's safe to say that in browser app
193:30 - those events are mostly external
193:34 - now that style of programming is
193:35 - actually called event driven programming
193:38 - and effectively it's just that a style
193:41 - in which the flow of the program
193:43 - is at least in part determined by the
193:46 - events that occur
193:48 - as the program executes
193:50 - now it's easier to imagine that of
193:52 - course
193:54 - when you have a gui right the graphical
193:56 - interface
193:57 - just like the button and links example i
194:00 - just mentioned
194:01 - but what about server side
194:03 - is it also possible and of course the
194:06 - answer is yes in fact event driven
194:08 - programming is used heavily in node.js
194:11 - and in the following videos we'll see
194:13 - some of the examples of it
194:15 - and basically the idea is following we
194:17 - listen for specific events
194:19 - and register functions that will execute
194:22 - in response to those events
194:24 - so once our event takes place callback
194:27 - function fires just like in our
194:30 - imaginary button example
194:32 - now before we continue let me stress
194:34 - something our first examples are going
194:35 - to be basic and
194:37 - even somewhat silly
194:39 - but don't let that fool you
194:41 - many built-in modules in node.js do use
194:44 - events under the hood and therefore
194:46 - making events and event driven
194:48 - programming a big part of nodejs all
194:52 - right and once we have covered general
194:54 - concepts behind events as well as
194:56 - event-driven programming now let's set
194:59 - up our own events in node and the way we
195:02 - do that we come up with a variable and
195:05 - typically this name is event
195:07 - emitter because what we're getting back
195:10 - is the class
195:11 - and we require the events module so
195:15 - require events module and we assign it
195:17 - to a variable which essentially is a
195:19 - class
195:20 - and again a common practice is calling
195:23 - this event emitter and at this point you
195:26 - have two options if you want to create
195:27 - something custom
195:29 - you'll need to
195:30 - extend the class
195:32 - or if you simply want to
195:35 - emit an event
195:36 - as well as listen for it then you can
195:39 - just create the instance so go with the
195:40 - second route we'll go with const and
195:43 - then whatever name you would want in my
195:45 - case i'm just going to call this custom
195:47 - emitter like so and i'll assign it to
195:50 - new
195:51 - emitter so event emitter or however you
195:55 - call this variable and we just need to
195:57 - invoke it so now we have the instance of
196:00 - our class so essentially we have the
196:02 - object now there are many methods in
196:05 - this object however two that we're
196:08 - interested the most are on
196:10 - and emit
196:12 - so on we'll listen for specific amend
196:15 - and then emit of course will emit that
196:18 - event
196:19 - and the way we set it up we go with
196:21 - custom mirror or whatever name you used
196:24 - and then we go with on
196:26 - and at the very basic setup in the on
196:29 - method we just pass in the string
196:31 - where we say the name of the event now
196:35 - in my case i'll name my one response and
196:38 - then of course once i have subscribed to
196:40 - it i also would want to pass in the
196:42 - callback function so essentially when
196:44 - this event takes place
196:47 - well then i would want to do something
196:49 - and in my case i'll just go with
196:51 - console.log and we'll simply say data
196:54 - received or i'll place this one in the
196:57 - template strings and you'll see in a
196:58 - second why so we'll go with data
197:01 - received
197:02 - and then eventually there's going to be
197:04 - some more data and of course once we
197:06 - have subscribed to this specific event
197:09 - now i would want to admit it and the way
197:12 - we do that we just go with custom
197:14 - emitter and of course the method is
197:17 - surprise surprise emit and of course at
197:20 - this point
197:21 - these strings need to match so if i'm
197:24 - emitting
197:25 - the response event
197:27 - and just say here response and what
197:30 - you'll see in the console is wherever
197:32 - you have in callback so of course in my
197:35 - case i have console log data received
197:37 - and then once i run it i have data
197:40 - received in console so that's the most
197:43 - basic setup when it comes to events
197:46 - again we create an instance from the
197:48 - class that we get back from the events
197:51 - module and then we have two methods we
197:54 - have on method as well as the emit
197:57 - method and then in the on method we pass
197:59 - in the string so that's going to be the
198:01 - name of the event as well as the
198:04 - callback function
198:05 - so once this event takes place
198:09 - then of course we would want to do
198:10 - something and in our case we'll just
198:12 - console.log data received and then once
198:16 - we have subscribed to this event then of
198:19 - course we need to emit it and the way we
198:22 - do that we just go with
198:23 - whatever the name is in my case custom
198:26 - emitter then emit method and then we
198:29 - pass in the same string that we're
198:32 - listening for
198:33 - in our case of course response and then
198:36 - the moment we do that
198:38 - we of course have whatever is in the
198:40 - callback function which in of course of
198:42 - course is just a simple log data
198:45 - received
198:46 - all right and once we have covered the
198:48 - basic setup now let me show you some
198:50 - things that
198:52 - i would want you to be aware of
198:54 - first
198:55 - we can have as many methods we would
198:57 - want so for example we have the same
199:00 - event we have here response correct and
199:03 - we are omitting it so nothing stops me
199:06 - here just copy and paste
199:09 - and listen for the same event
199:12 - which of course in our case is this
199:13 - response and then do some other logic in
199:17 - my callback again in my case it's just
199:19 - going to be simple
199:21 - different kinds of log so i'm going to
199:22 - say some
199:24 - other
199:24 - logic here and i'm not going to copy and
199:27 - paste
199:28 - the same function 20 000 times just to
199:31 - prove my point but hopefully understand
199:34 - that yes we can emit our event and then
199:37 - yes also we can have as many functions
199:40 - we would want here that our listening
199:43 - for that event and do some other logic
199:45 - so that's point number one point number
199:48 - two that i would like to make is the
199:50 - fact that
199:51 - this order matters
199:54 - so we first listen for event and then we
199:58 - emit it so for example if i will place
200:02 - my emit above the second function or
200:05 - above both of the functions which you'll
200:07 - notice
200:09 - that i have nothing in a console
200:11 - why well because i first emit the event
200:14 - and only then i listen for it
200:16 - as you can see that doesn't make sense
200:18 - so first we would want to listen for the
200:20 - event
200:21 - and only then we would admit it so in
200:24 - this case notice i don't have this some
200:26 - other logic goes in here because i
200:29 - listen for response and then i right
200:31 - away admit the response and then again i
200:33 - listen for the response but i already
200:36 - admitted the event correct so it doesn't
200:38 - make sense to listen for the event once
200:41 - it has been already emitted so that's
200:44 - the point number two
200:45 - and then thirdly our also on a showcase
200:48 - that we can pass the arguments when
200:50 - we're omitting the event so for example
200:53 - i go here with my emit i pass in the
200:56 - name which is of course response and
200:58 - then i can pass in more arguments for
201:01 - example here i'll go john and then the
201:04 - id number 34. so string and a number and
201:08 - then in my callback function
201:11 - i can access those arguments as
201:13 - parameters just like normal functions so
201:16 - in this case i'll call them name and id
201:19 - and simply in my console.log i'll say
201:22 - name
201:23 - and the second one will be with id
201:26 - and then whatever is that id
201:29 - now i'll add here data received
201:32 - user and then save it and it's no
201:34 - surprise that in the console i see data
201:36 - received user john with id34 now in the
201:40 - second function as you can see
201:42 - i wasn't looking for those arguments i
201:44 - just don't have access to the arguments
201:45 - because i don't have the parameters but
201:48 - it's not like everything broke just
201:50 - because in the event i passed in the
201:53 - arguments and lastly i would just want
201:55 - to reiterate the point that even though
201:57 - you might not write
201:59 - your own events events are a core
202:02 - building block of node and effectively
202:05 - as you're building and writing out the
202:08 - code for your node application you are
202:10 - using those events at the end of the day
202:13 - anyway because a lot of built-in modules
202:16 - rely on them and as a quick side note if
202:19 - you'd like to see the code that we wrote
202:22 - in previous two lectures you can just
202:25 - navigate to 13 event emitter and in
202:28 - order to show that i'll quickly set up a
202:31 - server
202:32 - and again the code for this one you can
202:35 - find at 14 and then request event so
202:39 - copy all the contents from the file
202:41 - and then just copy and paste
202:44 - and notice something interesting where
202:46 - again yes we're getting the http module
202:49 - and remember the setup that we have used
202:52 - so far where we go with http create
202:54 - server and then we pass in this callback
202:57 - function
202:58 - and then of course this callback
203:00 - function will be invoked every time
203:03 - someone visits our server so every time
203:07 - the request
203:08 - comes in now there's another way how we
203:11 - can set it up by using event emitter api
203:14 - so we still create a server we go with
203:17 - http and then create server function but
203:21 - instead of passing in the callback
203:22 - function like we did previously
203:25 - server has the method
203:27 - on
203:28 - does that ring a bell remember our
203:30 - previous example
203:32 - we had our own instance and
203:35 - it had the method of on correct so the
203:38 - same goes for server so server has the
203:40 - method on
203:42 - and we listen for
203:43 - request event and when that request
203:47 - comes in
203:48 - then of course again we have this
203:50 - callback function that handles it so
203:52 - behind the scenes
203:54 - server emits the request event and then
203:57 - of course we can listen for it we can
203:59 - subscribe to it listen for it or respond
204:02 - to it however you'd want to call it and
204:04 - the way we do that we go with server on
204:07 - and then this is a specific name
204:09 - because of course it emits that specific
204:13 - name behind the scene so make sure that
204:15 - it is a request and then the same spiel
204:18 - now how do i know that well if we go to
204:21 - node documentation and if we look for
204:24 - http we keep on scrolling keep on
204:26 - scrolling eventually we'll hit the
204:28 - server
204:29 - and
204:30 - over here i can see that it has a clash
204:33 - okay that's a good start and that what
204:35 - do you see here
204:36 - well i see the event right and what is
204:40 - the event well the name is request so
204:43 - that's how i know
204:44 - that my server the instance that i
204:46 - create has the ability to listen for
204:50 - request events and if you want to dig
204:52 - deeper you can just click on a server
204:55 - you notice that it extends the net
204:58 - server and if we keep on digging check
205:01 - it out so this one extends what it
205:04 - extends the event emitter so hopefully
205:08 - that makes it clear that even though you
205:11 - might not be setting up events on your
205:13 - own a bunch of built-in modules rely
205:17 - heavily
205:18 - on this concept of events all right and
205:22 - up next we have streams in node.js
205:25 - and at its simplest streams are used to
205:28 - read or write sequentially basically
205:31 - when we have to handle and manipulate
205:33 - streaming data for example continuous
205:36 - source or a big file streams come in
205:39 - real handy
205:40 - and now there are four different types
205:41 - of streams we have writable used to
205:45 - write data sequentially then we have
205:46 - readable used to read data sequentially
205:49 - duplex
205:50 - used to both read and write data
205:53 - sequentially and also transform where
205:55 - data can be modified when writing or
205:58 - reading just like with events many
206:00 - built-in modules in node implement
206:02 - streaming interface
206:04 - and what's also interesting streams
206:06 - extend event emitters class which simply
206:09 - means that we can use events like data
206:12 - and and on streams
206:14 - since streams are somewhat off an
206:16 - advanced topic in node i'll try to keep
206:19 - it short and sweet mostly by showing you
206:22 - examples of streams and hopefully that
206:24 - way you get the main idea without being
206:27 - overwhelmed
206:29 - all right and once we know the theory
206:30 - behind the streams now let's take a look
206:33 - at the practical example
206:34 - and a very good use case is using
206:38 - streams when we are reading files
206:40 - because we need to understand one thing
206:43 - where when we use the sync or
206:46 - asynchronous approach what happens we're
206:49 - reading the whole file and of course in
206:51 - our example we were setting this equal
206:54 - to a variable correct but if we have a
206:58 - big file
206:59 - well first of all you're just using all
207:01 - that memory and second
207:04 - as the file size gets bigger and bigger
207:06 - bigger eventually the variable is not
207:09 - going to be good enough you will get an
207:11 - error that
207:13 - i mean the size is too big and you
207:14 - cannot place everything in the string so
207:19 - what would be a solution one solution
207:21 - would be read stream option
207:24 - and the way we'll set this up
207:27 - i'm going to start app.js from scratch
207:30 - but if you take a look at the repo
207:34 - you'll notice this 15 create big file so
207:37 - previously when we were working with
207:39 - files i just had some small files right
207:43 - so i had the first txt blah blah blah
207:45 - result and whatever now before we set up
207:49 - the read stream i would want to create a
207:51 - big file again this is optional you
207:54 - don't have to do that but in my case in
207:56 - order to show you how the streams work
207:58 - yes i'll have to set up a big file and
208:02 - first i'll remove it because of course
208:04 - i already have it since i was testing it
208:07 - and now i'll stop my server and of
208:09 - course in my case i'll run 15 the create
208:12 - big file js
208:14 - if you want to set it on your own and if
208:16 - you don't want to use the repo you can
208:17 - just
208:18 - get the right file sync from the fs
208:21 - module and then notice i have the loop
208:24 - where i believe i have here 10 000
208:28 - and then every iteration i just write a
208:32 - big txt i of course i have the flag
208:35 - upend and then i'm just adding hello
208:37 - world and starting a new line so if i'll
208:41 - run node
208:42 - and then of course i'm going to go with
208:44 - my file name which is 15
208:46 - then hyphen
208:48 - create
208:49 - big
208:50 - file and js like so
208:54 - then in the content i should have this
208:57 - big file
208:58 - and once i have my big file i'll go back
209:01 - to app.js and i'll use my npm start
209:04 - since of course i have known mine in
209:06 - place and then let's go with cons now
209:10 - i'm not going to show you how the setup
209:12 - would look like with file sync or the
209:16 - asynchronous one again hopefully you
209:18 - understand that the setup would be
209:20 - exactly the same like we have in 10 and
209:23 - 11 where we had the fa sync and fa async
209:28 - and now of course let's just go with the
209:30 - stream option so the method name is
209:33 - create
209:34 - read
209:35 - stream and we require that from the fs
209:39 - module like so
209:41 - and then
209:42 - we create a new variable and in my case
209:45 - i'll call this stream and we invoke the
209:48 - create read stream and the only thing by
209:52 - default we need to pass in is the path
209:54 - so of course in my case i'm going to go
209:56 - with content and then forward slash and
209:58 - since i just created that text file the
210:00 - big one of course i'm going to go with
210:02 - big txt and now remember the good old
210:05 - friends events well
210:07 - once we create this instance we actually
210:10 - have access to them and the ones that
210:12 - we're going to use is going to be data
210:15 - and error so we can go with stream
210:19 - and then on and remember the event
210:22 - syntax and then the event that you would
210:25 - want to listen for is a data and then we
210:28 - have our callback function and again it
210:31 - is a parameter so we can call whatever
210:33 - we would want but in my case i'm going
210:34 - to go result and let's just console.log
210:38 - the result like so
210:40 - and what you'll notice
210:43 - is that we have
210:45 - 64 kilobytes here that's our first
210:47 - console log then we have another one 464
210:51 - kilobytes and the reason why i know that
210:53 - is because by default that's the size
210:56 - we're getting and then we're getting the
210:58 - reminder now just to prove my point i'm
211:01 - going to go to my folder
211:03 - and i'm going to look for my content
211:07 - and then in there if you take a look the
211:10 - big text file we created is
211:13 - 169 kilobytes so as you can see now
211:16 - we're reading data in chunks
211:19 - and by default that chunk is 64
211:22 - kilobytes
211:23 - and every time we cancel log
211:27 - we see that we have 64 64 and eventually
211:30 - we have the remainder so instead of
211:33 - reading everything and placing that in
211:36 - the variable we're doing that in chunks
211:39 - and as you can see we're using the event
211:42 - and the event is data and in order to
211:45 - hammer this home why don't we take a
211:46 - look at the docs
211:48 - so first i'm going to look for my file
211:50 - system
211:51 - and then let's look for
211:53 - our create read stream so we go here as
211:56 - we can see we have this class read
212:00 - stream and then on this class we have
212:02 - these three ones we have close open
212:05 - and ready and as a side note we'll use
212:08 - this one a little bit later as well the
212:10 - open one so keep an eye on this one and
212:13 - then as far as the read stream well as
212:16 - you can see it is created when we go
212:19 - with create read stream and invoke it
212:22 - right so i got the create read stream
212:25 - that's my function i just passed in the
212:28 - past and i invoked it and in turn
212:31 - that returns
212:33 - the read stream
212:35 - right then
212:36 - actual read stream extends from
212:40 - stream.readable so right away i have
212:42 - these events i have close open and ready
212:44 - and like i said we use this open a
212:46 - little bit later now since it is
212:49 - extending from the stream check it out
212:52 - now of course i have the data one all
212:54 - right so this is a chunk of data
212:57 - and as you can see every time we are
212:59 - getting that data
213:01 - we can do something with it now at the
213:02 - moment we're just going to logging it's
213:04 - very simple but eventually as you can
213:07 - already imagine we can do way more
213:10 - useful things than that beautiful once
213:13 - we understand the basics now let's take
213:15 - a look at some additional info like i
213:18 - said by default the size of the buffer
213:21 - is going to be 64 kilobytes however we
213:25 - can also control it and the way we do
213:27 - that is by passing in the object when
213:32 - we're setting up create read stream so
213:34 - first argument is going to be the path
213:36 - which again in my case is going to be
213:38 - that big text file that i created using
213:42 - my file using my for loop and then i can
213:46 - pass in the options object and in there
213:48 - the property that you're looking for the
213:50 - property that controls the size of the
213:53 - buffer
213:54 - has the name of high water mark so for
213:57 - example if i go with 90 000 here then of
214:01 - course you'll see that i'll have two
214:03 - console logs
214:04 - one for
214:06 - 90 kilobytes and the second one will be
214:08 - remainder again keep in mind that
214:11 - our file size is
214:13 - 169 kilobytes that's number one number
214:16 - two
214:17 - we can right away set up the encoding as
214:20 - well so i go with comma and then the
214:23 - property name is encoding and again
214:25 - we'll set it up equal to utf-8 like so
214:29 - and then you'll see in a console of
214:31 - course the hello world why well because
214:33 - that is the content coming from the file
214:36 - and lastly i also would want to mention
214:38 - that we have the error event as well so
214:42 - if i go with stream and then on and
214:46 - we're checking for the error and as
214:48 - always we can do something once that
214:50 - error happens so that's our callback
214:52 - function and in this case i'll just
214:54 - access the error property and i'll
214:56 - console.log the error so i'll say here
214:59 - error and the way we check that one out
215:02 - is by providing wrong path so in my case
215:04 - i'm just going to add two dots and then
215:07 - once i save check it out in a console
215:10 - i'll have the error where it tells me
215:13 - that no such file or directory
215:17 - all right and now let's take a look at
215:18 - the practical example when streams come
215:22 - in handy now again this is going to be
215:24 - one of those videos where you don't have
215:26 - to code along you can just sit back and
215:29 - relax and see how i struggle and first
215:33 - what i want is to make it even a bigger
215:36 - file so remember d15 create big file
215:39 - i believe i had 10 iterations right so
215:43 - i'm gonna add one more
215:45 - meaning i'll add one more zero i'll stop
215:48 - my server right now again this is
215:50 - optional you don't have to do that and
215:53 - i'll remove the big file
215:55 - like so
215:56 - and then i'll run one more time
215:59 - the file with node
216:01 - and then of course this file is going to
216:03 - be way bigger
216:05 - so let me navigate to my folder just to
216:07 - showcase that
216:08 - and i'm looking for content and now the
216:10 - big file is 1.8 megs
216:14 - now once i have the big file
216:16 - i'll go with npm
216:19 - start at the moment i just have the
216:20 - stream example but if you want to see
216:23 - the whole code just take a look at the
216:26 - file number 17 and notice again we're
216:28 - creating a http server and i'm just
216:31 - using the read file stick method i'm
216:33 - looking for big txt the encoding is
216:36 - utf-8 and then i just place my variable
216:40 - my text one into
216:42 - res dot and method and effectively i'm
216:47 - just sending my big text file
216:50 - and let me restart the server
216:53 - here so let me go with npm start right
216:57 - now so let me select everything from
216:59 - this file
217:00 - and copy and paste
217:03 - and now if we navigate to localhost
217:07 - 5000
217:09 - we should see a bunch of hello world
217:12 - now the problem with the setup is
217:14 - following where if i go to developer
217:17 - tools and if i take a look at the
217:19 - network and if i refresh
217:21 - yep
217:22 - this request was successful
217:25 - take a look at the size
217:26 - do you think
217:28 - it is the smartest thing to send these
217:30 - type of files over the wire and of
217:33 - course this is just going to make it
217:35 - very difficult to all your users because
217:38 - you're just sending large chunks of data
217:42 - effectively i'm sending the whole file
217:44 - and more specifically if i click check
217:47 - it out so i have the request url okay
217:49 - that is good the method is get
217:52 - now as you can see the content length
217:55 - is my 1.8 megs right
217:58 - and you'll see in a second that once we
218:01 - refactor this to read stream method
218:05 - that we're sending data in the chunks
218:07 - and again the best way to see that is by
218:10 - looking at the headers where at the
218:12 - moment i can see the content length and
218:14 - that one is at 1.8 megs but once we
218:18 - refactor that the setup is going to be
218:20 - different so at the moment i have this
218:23 - text i'm accessing that by read file
218:26 - sync so comment this out and let's set
218:28 - it up with our create read stream so
218:31 - i'll go with const and i'll call this
218:33 - file
218:34 - stream and this is going to be equal to
218:37 - fs and then create read stream now use
218:40 - the same address
218:42 - so use the same path
218:44 - and then i'll use the same encoding as
218:47 - well
218:48 - so let's go with utf-8 okay
218:51 - awesome and once we set up the stream
218:53 - remember we have access to
218:55 - to events
218:56 - file stream on
218:58 - and of course i'm going to be looking
219:00 - for the open
219:01 - and i'll have my callback function and
219:04 - we'll set that functionality up in a
219:06 - second and the second one of course is
219:08 - the error so go with file stream and
219:11 - then on and again we're looking for the
219:15 - event by the name of error and then in
219:17 - our callback function we can access the
219:19 - error and i'll simply pass it in in my
219:23 - response so if there is an error i'll
219:25 - just grab the error from my parameter
219:28 - and pass it in now as far as the open
219:31 - here instead of setting it equal to
219:34 - instead of going res dot end and then
219:36 - text file stream also have the pipe
219:40 - method so we can go to file stream and
219:43 - then pipe and what the pipe is doing it
219:46 - is pushing from the read stream into
219:49 - right stream so you can imagine that if
219:51 - we can read data in chunks we can also
219:55 - write data in chunks and what happens
219:58 - under the herd response object can be
220:00 - set up as a writable stream so we have
220:03 - our file stream so that's our read
220:05 - stream we have method of pipe so we're
220:08 - piping this into a writable stream and
220:11 - now of course i'll pass in my response
220:14 - object and if we go back to the browser
220:17 - and if we'll refresh
220:18 - now notice something interesting yeah
220:21 - still same request right to localhost
220:24 - 5000 still same size but
220:27 - if i take a look at the headers now i
220:30 - can see that my response headers are
220:34 - chunked so instead of sending our file
220:37 - back in one large instance we're sending
220:39 - it back in chunks awesome congrats on
220:43 - completing section number three
220:45 - node fundamentals and hopefully after
220:48 - watching the section you have a good
220:50 - general understanding of how node works
220:53 - and now that we're big shots let's apply
220:55 - that knowledge and build some servers
220:58 - shall we and we're going to start
221:00 - section 4 with the general info of how
221:03 - the web works more specifically how we
221:06 - exchange data on the web
221:08 - and we're going to do that with the help
221:10 - of few slides
221:12 - now if you're one of the people who's
221:14 - already reached a daily slide limit i
221:17 - hear you
221:18 - once we're done with these suckers i
221:20 - promise we'll mostly actually write code
221:22 - for the remainder of the course
221:25 - i do believe though that before we build
221:27 - an actual web server it's crucial for us
221:30 - to understand how it works under the
221:32 - hood and that way we'll have clear
221:34 - understanding of what tasks need to be
221:37 - done if something is iffy you can always
221:40 - go back to the slides you already know
221:42 - where they're located and also as we're
221:45 - going to be progressing with the course
221:48 - from time to time i will swing back to
221:50 - them when i'll need to emphasize a
221:52 - specific point
221:53 - with that said let's talk about how we
221:56 - exchange data
221:58 - on the web
221:59 - um it's safe to say that if you're
222:01 - watching this video
222:03 - you know how to use a web browser
222:06 - but under the hood the way it works
222:08 - every time we open up a browser
222:10 - and we type the url so the web address
222:13 - we're actually performing a request
222:17 - and we are performing a request to the
222:20 - server
222:21 - that is responsible
222:22 - serving those resources so for example
222:26 - when you look for cnn.com
222:28 - you're looking for a server that has
222:31 - those resources and then that server
222:34 - sends you back the response and the same
222:37 - works with youtube the same works with
222:39 - johnsmeld.com
222:41 - or whatever so you just pick a resource
222:44 - you say hey
222:45 - can i get this data and then server who
222:48 - is responsible for those resources just
222:51 - sends you back the response now that is
222:54 - done using http protocol and that's why
222:58 - these ones are called http messages
223:01 - so the user sends the http
223:04 - request message and then the server
223:08 - sends the http response message
223:11 - and that's how we exchange data on web
223:15 - and for the remainder of the course
223:17 - we'll be responsible for building
223:21 - such web server using node and more
223:24 - specifically express now i'll talk about
223:27 - it while we use express as well show you
223:30 - a few examples
223:31 - later on in a course but for now just
223:34 - remember that yes we'll use node but in
223:37 - order to make our lives easier we'll use
223:40 - the framework by the name of express js
223:44 - and lastly i would just want to mention
223:45 - that even though name server definitely
223:48 - sounds way cooler than the computer
223:51 - at the end of the day they're just
223:53 - computers whose job
223:56 - is to always make that resource
223:59 - available
224:00 - so yes those are computers and yes there
224:04 - are some differences for example
224:06 - they most likely don't have the
224:08 - graphical interface or the gui
224:11 - and also they're probably much bigger
224:13 - than your laptop but at the end of the
224:16 - day they are computers
224:18 - whose job
224:20 - is to always make sure that that
224:22 - resource is available because imagine if
224:26 - you would have a server that only works
224:28 - from eight to five so if you go to your
224:31 - website at i don't know six o'clock at
224:34 - night you cannot access the resource
224:37 - probably that's not the service that you
224:39 - would pick so next time when someone
224:42 - asks you if it rains does the cloud
224:46 - still work you know what to answer
224:48 - because at the end of the day when we
224:49 - talk about cloud cloud is just a bunch
224:53 - of these servers bunch of these
224:54 - computers connected together beautiful
224:58 - and once we have a general understanding
225:00 - how data is exchanged on a web
225:03 - let's also cover how http messages are
225:06 - structured please keep in mind that
225:08 - since it's going to be a big part of our
225:11 - job
225:12 - we'll come back to this particular slide
225:14 - more than once so if you're if you're
225:16 - about something just please be patient
225:18 - and i'll answer all of your questions as
225:22 - we move along with the course with that
225:24 - said the general structure
225:26 - for both messages is similar they both
225:29 - have a start line
225:31 - they both have optional headers a blank
225:34 - line that indicates that all the meta
225:36 - info has been sent and effectively
225:39 - headers are that meta info as well as
225:43 - optional body and before we continue
225:45 - again let me stress something so request
225:49 - messages
225:50 - are what the user is sending so for
225:54 - example if you open up the browser to
225:57 - search the web or that could be your web
226:00 - application because remember with web
226:02 - applications we also can make http
226:05 - requests correct and then response
226:09 - is going to be our responsibility so
226:12 - we'll have to set up a proper server
226:15 - that sends a correct response
226:19 - and in general when we talk about the
226:21 - request
226:22 - message
226:23 - in start line there's going to be a
226:25 - method
226:26 - then the url as well as the http version
226:31 - now
226:32 - we are mostly going to be interested in
226:34 - these two things in the method as well
226:37 - as the url now there's going to be a
226:39 - separate slide about the methods as well
226:43 - and don't worry we'll cover that in a
226:45 - greater detail once we cover them with
226:48 - actual code examples so i'll come back
226:51 - to that slide just understand the
226:53 - general idea that when we talk about
226:55 - methods effectively we're communicating
226:58 - what we would want to do so for example
227:01 - if i want to get the resource i'm going
227:04 - to set it up as a get request now if i
227:08 - want to add the resource then of course
227:09 - this is going to be a post request and
227:12 - then of course you can read the rest now
227:15 - why i'm displaying here this get because
227:18 - that is the default request
227:20 - that the browser performs
227:22 - since when we open up the browser we
227:24 - want to get some kind of resource
227:27 - correct that's why we're performing a
227:29 - get request and the url is just the
227:33 - address and that could be for example
227:35 - johnsmilk.com or that could be i don't
227:38 - know espn forward slash basketball both
227:42 - of them are just a web addresses now
227:45 - headers
227:46 - is essentially optional
227:48 - where this is a meta information about
227:51 - our request and just to give you a
227:54 - general idea how the headers would look
227:55 - like they would look something like this
227:58 - so it is a key value pairs now don't
228:01 - freak out
228:02 - as you know when you search the web you
228:04 - don't need to add them manually and the
228:07 - same is going to be with our server a
228:10 - lot of it is going to be taken care of
228:12 - but yes some things we'll have to add
228:15 - on our own basically this is going to be
228:18 - information about our message
228:21 - and then we also have optional body
228:25 - so when the user is requesting something
228:28 - if you just want the resource there is
228:30 - nobody there's nothing basically what to
228:33 - send however if we would want to add a
228:36 - resource onto the server yes
228:39 - then you are expected to provide that
228:41 - data and it's also called payload so
228:45 - again i might use them interchangeably
228:47 - so that's the general structure of the
228:50 - request message
228:51 - we have the start line we have the
228:53 - headers that is the information about
228:56 - our message as well as the black line
228:58 - which just indicates that we're done
229:00 - with the meta information and optional
229:03 - body which we'll use from time to time
229:06 - and now of course we need to talk about
229:08 - the response message so response message
229:11 - is what we're going to be creating again
229:14 - most of it will be done for us but some
229:17 - parts yes we'll have to do it manually
229:20 - and it's going to be our responsibility
229:22 - so the start line
229:24 - has the http version which most likely
229:26 - is going to be 1.1
229:28 - then we have a status code and status
229:32 - text now when it comes to status code
229:36 - it just signals
229:38 - what is the result of the request so for
229:41 - example notice here this 200
229:43 - that means that request was successful
229:46 - so that's what we're sending back and
229:49 - yes there's quite a few of those codes
229:52 - and as we move along with the course of
229:54 - course we will cover them but please
229:56 - please please don't rush over to the
230:00 - search engine and start memorizing the
230:02 - status codes pretty much as we're going
230:04 - to be building the application i'll tell
230:06 - you which code means what and for
230:09 - example 400 means that there was some
230:12 - kind of request error
230:14 - so the user was trying to request some
230:18 - kind of research and with 400 there was
230:21 - a request error now for example the code
230:24 - 404 means that the resource is not found
230:28 - so when i'm sending back the message i'm
230:30 - like hey listen here's the status code
230:33 - for the message if you are successful
230:36 - here's 200 if there was an error for
230:38 - example you get a 400 if the
230:42 - request is unauthorized then you can get
230:44 - 401 and hopefully you get the gist and
230:47 - yes of course as we're progressing we
230:50 - will cover more status code then again
230:53 - we have the headers
230:55 - where basically we provide info
230:59 - about our message our response message
231:03 - and again like i said you won't have to
231:06 - type everything line by line but
231:08 - effectively it is a
231:10 - setup of key value pairs and the ones
231:13 - that i would like to mention are these
231:15 - ones notice this content type we have
231:17 - text html that is when we're sending
231:20 - back the html but also our second option
231:25 - is going to be sending back the data
231:28 - so hopefully you are aware that when
231:30 - you're building a web application when
231:31 - we communicate with api most of the time
231:34 - we're getting back the json data because
231:38 - over the web effectively we just send
231:40 - over the string so if for example i have
231:43 - some kind of array we transfer this into
231:47 - application json and i clearly indicate
231:50 - that in my headers where i say that no
231:52 - i'm not sending text and html i'm
231:55 - actually sending a application json and
231:58 - then that application who is requesting
232:00 - the web application knows that hey from
232:03 - the server i'm getting a content type
232:05 - which is application json so for example
232:08 - in that case i could send back here this
232:12 - array with bunch of these objects and
232:15 - just to give you a real-world taste why
232:19 - don't we do this
232:20 - open up a new browser tab and i'm simply
232:23 - going to course api because i think
232:25 - there's going to be less data so there's
232:27 - going to be less clutter so go to course
232:30 - api here and then you can either pick
232:33 - the slides or you can just look at the
232:35 - home page and if you inspect
232:38 - and if you look in the browser tab
232:40 - you'll find a network
232:42 - and very useful one is this one where we
232:45 - can just look for all the requests we
232:47 - refresh and then check it out so these
232:50 - are the requests
232:52 - that browser performed and i'll talk
232:54 - about it a bit later why there's also
232:56 - this style css in fact that's going to
232:59 - be one of our first examples but take a
233:01 - look at this one so i have this course
233:04 - api and then forward slash and if you
233:06 - remember when we were building our
233:08 - original server what i said that if we
233:11 - have this forward slash that just means
233:13 - home page so if we're just navigating to
233:16 - courseapi.com
233:17 - and
233:18 - that is our homepage we simply add this
233:21 - forward slash now of course in the
233:23 - browser that's automatically added but
233:25 - that's why when we're setting up the
233:26 - server one of the cases is going to be
233:28 - if the user navigates to the homepage
233:31 - then we simply look for forward slash so
233:34 - if for example you go to the slides
233:38 - you'll notice that uh in this case i
233:40 - would have to refresh notice here i have
233:43 - the course api
233:45 - forward slash slides so that is already
233:48 - a page in my website correct so i have
233:53 - the home page course api and then i have
233:55 - the slides page where i have the slides
233:58 - and if you take a look if you click on
234:01 - it notice all the useful data that we
234:05 - get over here so for example this is
234:07 - going to be our request url which is
234:10 - going to be again course api.com so that
234:12 - tells me well what the browser is trying
234:15 - to get
234:16 - then check it out the method why it's
234:18 - get because that is default in the
234:20 - browsers every time you open up the
234:22 - browser and search something then of
234:24 - course you'll be performing a get
234:25 - request now check out this one the
234:27 - status code it is 200 why because
234:30 - everything is successful because servers
234:33 - send back the data then we have this
234:35 - remote address and basically that is the
234:37 - ip address for my server as well as
234:40 - notice this colon 443
234:43 - and we'll come back to this one when we
234:45 - set up our own server because if you
234:47 - remember we were always setting up the
234:49 - 5000 so you're probably wondering well
234:51 - what is this 443 and don't worry again
234:54 - we'll cover that one once we set up our
234:57 - first server
234:59 - and then again we have response headers
235:02 - for example and we also have the request
235:05 - adders so as you can see using this
235:07 - network tab we can actually find a bunch
235:10 - of useful information now
235:13 - notice here in the second set of tabs i
235:17 - can see this response and preview so if
235:21 - you take a look at the preview
235:22 - this is going to be basically my site
235:25 - and also i can see the response so as
235:28 - you can see pretty much sending back the
235:30 - html
235:32 - so i'm sending back the website so you
235:34 - go into the browser you request a
235:37 - resource
235:38 - by default it is a get request
235:40 - and then in that body
235:42 - when the server sends it back
235:44 - this is what we get back so we get back
235:47 - the site so hopefully this gives you a
235:50 - clear understanding of how the http
235:53 - messages are structured and now let's
235:56 - dive into creating our own server
235:59 - awesome once we're done with the slides
236:02 - now let's start setting up our server
236:05 - and in order to follow along with the
236:07 - course you'll need to have a starter
236:10 - project and you can get it if you
236:12 - navigate to my site again the url is
236:16 - johnsmilk.com
236:17 - so navigate there in the project or in
236:20 - home page look for node express tutorial
236:24 - project in a home page is going to be
236:26 - at the bottom in latest project if you
236:29 - cannot find it there then look for all
236:32 - projects page or simply projects page
236:34 - then filter for node in order to save
236:37 - some time and then like i already
236:38 - previously mentioned any of these links
236:41 - will get you to the repo and then
236:44 - bravely get the repo in my case i'm
236:46 - going to clone it so i'll copy the url
236:49 - i'll bump up the sound size in my
236:52 - terminal navigate to the desktop
236:55 - get clone here
236:57 - and then i'm gonna get the repo and then
237:00 - once the project is on my machine
237:03 - i'm just gonna drag and drop and then
237:05 - the first thing that i would suggest
237:08 - doing is removing the remote url and you
237:12 - can simply do that by just wiping out
237:14 - the git folder so that way if you ever
237:17 - do decide you push this up to the github
237:20 - you won't have some dumb permission
237:21 - errors so i'm just going to open up the
237:24 - integrated terminal now in my case i'm
237:26 - not going to run the command but
237:29 - if you're on mac i suggest running rm
237:32 - then hyphen rf and then get now if you
237:36 - are on windows
237:38 - some students have just these two
237:40 - commands now i haven't tested them yet
237:42 - but some people have replied to
237:45 - my tweet that yes they do work and if
237:48 - you want to see the whole tweet just
237:49 - navigate to my twitter the handle is
237:52 - john underscore smilga and then as you
237:54 - can see here is the mac command and for
237:57 - windows i have these two so run this
238:00 - command and then in next video
238:02 - i'll give you a brief overview of the
238:05 - repo all right and before we get busy
238:09 - why don't i give you a brief overview of
238:12 - the ripple
238:14 - and if you take a look at the first
238:16 - project this should look very very
238:19 - familiar because essentially this is all
238:22 - the code we have written so far
238:25 - everything starting with our most basic
238:27 - application and then of course we also
238:30 - have our last one our http streams
238:34 - example so hopefully that is clear and
238:36 - if you ever need to jog your memory
238:39 - essentially this is just here for your
238:41 - reference
238:42 - and then from now on we'll work in a
238:44 - folder number two by the name of express
238:48 - tutorial
238:49 - and the idea is gonna be exactly the
238:51 - same where basically
238:53 - we build a bunch of examples and in the
238:56 - process we learned what is express and
238:59 - why we would prefer using express
239:01 - instead of straight up http module but
239:04 - again let me stress something where
239:06 - express is built
239:07 - on top of node and more specifically on
239:10 - top of http module so it's not like you
239:13 - can use express without node and in
239:17 - folder two
239:18 - the setup is following
239:20 - where there are gonna be some assets
239:22 - that i provided
239:24 - just so we can make more real world
239:27 - examples so hopefully that gives you a
239:29 - better idea how the express works and
239:33 - i'm not going to cover them right now
239:34 - for example methods public or navbar app
239:37 - once we get there i'll explain
239:39 - everything that's happening i think that
239:41 - it's going to be waste of our time if i
239:42 - do that right now however if you take a
239:45 - look at the final folder you'll
239:48 - basically see
239:49 - all our examples so the same spiel
239:52 - if you ever
239:54 - need to reference the code just navigate
239:56 - to the final look for the file name and
240:00 - then of course you'll find the code just
240:01 - keep in mind that in order to run
240:04 - this code you'll have to copy and paste
240:07 - and run it in the app.js why
240:10 - because in some cases there's going to
240:11 - be paths and since these files are
240:14 - located already in the final the paths
240:17 - won't match
240:18 - okay hopefully that one is clear as well
240:22 - and then we also should be familiar with
240:25 - these files
240:27 - as you can see i have package.json i
240:30 - have package.json lock and then app.js
240:33 - now of course app.js could be renamed
240:35 - server or whatever you would want but i
240:38 - already have in a package.json a script
240:40 - that spins up the nodemon and
240:43 - effectively we have successfully set up
240:45 - a node application so package.json is of
240:48 - course needed because we'll have some
240:50 - dependencies more specifically two one
240:53 - is going to be nodemod and the second
240:55 - one is going to be express
240:58 - and in order to of course keep track of
241:00 - those dependencies we have
241:02 - package.json and then if you notice i
241:06 - don't have the node modules here and of
241:08 - course the reason for that is because i
241:10 - don't want this repo to be massive and
241:13 - you can clearly see that in a git ignore
241:15 - where i have node modules included so
241:18 - when i was pushing this up to the github
241:20 - and of course
241:21 - i omitted the node modules since i added
241:24 - them in the git ignore and then in the
241:27 - package json like i said
241:29 - you'll find some dependencies and i'll
241:31 - talk about express once we get there the
241:33 - moment let's not worry about it the one
241:35 - that we should be familiar with is node
241:37 - one which is going to be watching our
241:39 - application and i have a script
241:42 - that sets up nodemon
241:45 - and passes in the amp.js so any changes
241:48 - in our project nodemon will be watching
241:50 - and restarting our application however
241:53 - we cannot do anything before we install
241:57 - all dependencies otherwise you'll just
241:59 - get an error so that's why the first
242:01 - thing that i would want you to do is
242:03 - navigate to the folder number two
242:07 - and the fastest way probably is just
242:08 - going to be cd and then take the
242:12 - project number two and drag and drop
242:14 - like so and then once you can see
242:17 - that you are in this folder
242:19 - so not in a root not in node express
242:22 - course but once you are actually in the
242:25 - folder number two before you do anything
242:27 - just run npm
242:29 - install first and then it's really up to
242:32 - you you can either wait for all the
242:34 - dependencies to be installed and then
242:36 - run npm start or you can simply chain it
242:39 - and say npm
242:41 - and once you run this one
242:44 - then of course you'll install
242:45 - dependencies and if you see in a
242:47 - terminal express tutorial that means
242:51 - that everything is correct and you can
242:53 - continue with the videos if you don't
242:56 - see that then please troubleshoot
242:58 - because none of the things that we're
242:59 - about to do next are going to make sense
243:01 - if you're not running the project number
243:04 - two with all the dependencies more
243:06 - specifically nodemon and express
243:10 - and lastly i just want to mention yes
243:12 - there's also this data.js and again this
243:15 - is one of the assets that i added that
243:17 - we're going to use a little bit later so
243:19 - if you see express tutorial in a console
243:22 - and the reason why it's there because
243:24 - that's the only line of code i have in
243:26 - my app.js that means that everything is
243:28 - correct and we can move on to our next
243:31 - topic and why don't we start
243:34 - the express tutorial part by setting up
243:37 - the server one more time with
243:40 - straight up http module
243:42 - and in a process let's struggle a little
243:44 - bit
243:45 - let's see why we would want to use
243:47 - express e in the first place
243:50 - so yes we'll build one more time server
243:54 - with http module however now of course
243:58 - we'll dive deep into the topics that we
244:01 - kind of skipped over before
244:03 - and in order to set up the server we
244:05 - know that we would need to require the
244:08 - module right so i'm going to come up
244:10 - with some kind of variable and in my
244:12 - case that is going to be http and of
244:14 - course the name is not required you can
244:16 - call this whatever you'd want but it is
244:18 - somewhat off a convention to call this
244:20 - hdp as far as the variable name then we
244:23 - go with require and we just go with http
244:27 - again keep in mind
244:29 - this comes built in node
244:31 - so you don't have to install it we
244:33 - didn't install when we ran npm installed
244:36 - in last video
244:38 - we installed two other dependencies but
244:40 - this one is built in so we don't have to
244:42 - do anything we just say require and it's
244:45 - always going to be available to us
244:47 - then we need to set up the server and
244:49 - again convention is calling the server
244:52 - but you can call this box bunny and in
244:54 - order to do that we go with http and
244:57 - then on this object we have a method by
245:00 - the name of create server now this
245:03 - method
245:04 - takes a callback which is going to be
245:06 - invoked every time the user
245:09 - hits our server and in this callback we
245:13 - have two parameters and again we can
245:15 - call them whatever we would want so
245:18 - again common convention is just shorten
245:21 - this up a little bit and call it request
245:24 - and res so rec and res and the first
245:27 - parameter references the request object
245:30 - and second one is the response object
245:33 - and at this point it should be clear why
245:36 - we have access to those two parameters
245:39 - because
245:40 - in the http cycle we have request
245:43 - message
245:44 - that is coming in every time user
245:47 - requests the resource and also we have
245:50 - the response message right so that's
245:52 - what we need to send out so that's why
245:54 - in this function
245:56 - that runs every time user hits the
245:58 - server
245:59 - we have access to rec
246:02 - and res
246:03 - so that way we can find info about the
246:06 - incoming request because it makes a
246:08 - total sense if we have access to that
246:10 - info
246:11 - i do want to know what is the method so
246:14 - what the user is trying to do i do want
246:16 - to know what resource the user is trying
246:19 - to get
246:20 - whether that is the contact page or
246:22 - about page and also i would want to know
246:25 - whether i'm getting some data
246:27 - whether user is trying to add something
246:31 - onto the server and as far as the
246:33 - response well in order to
246:36 - serve the data
246:37 - i need to be extremely specific about
246:41 - what i'm sending so i need to explain to
246:43 - the browser what is coming in hopefully
246:46 - that is clear and in here we can just go
246:49 - with log
246:50 - and we'll say user hit the
246:53 - server and then we return the object
246:56 - from this create server and on that
246:58 - object we have a method by the name of
247:01 - listen so in order for the server to
247:04 - work we need to invoke listen and we
247:06 - need to be a bit more specific and we
247:08 - need to say well what port are we
247:10 - listening for and you're probably
247:12 - wondering well what's up with this port
247:14 - what's up with this 5000 value
247:18 - and the best explanation i can give you
247:20 - is this one imagine scenario where you
247:23 - have some kind of issue with your bank
247:26 - what do you do or that could be a phone
247:28 - company it doesn't really matter but i'm
247:30 - just going to give you a bank example
247:32 - what do you do you call the customer
247:34 - service and what is the first question
247:36 - that they ask you
247:37 - they say
247:38 - please describe your issue
247:41 - so we may better assist with your call
247:44 - and what do they do they give you
247:45 - options right so they say if you want to
247:48 - increase your credit limit this is going
247:50 - to be option number one all the way to
247:52 - canceling the account which maybe is
247:54 - going to be option number eight so they
247:57 - don't just randomly assist you a person
248:00 - they say hey what is the issue
248:02 - and this is the person that can serve
248:05 - you the best so if you press 8
248:07 - you can assume that you're probably
248:08 - going to be speaking with someone who
248:10 - deals with that all the time
248:12 - and same goes here so if you go online
248:15 - and if you search for port this is just
248:18 - going to be a communication endpoint
248:21 - and we need to understand that for http
248:24 - traffic we have specific ports
248:28 - so for http we actually have port 80
248:32 - because there's other ports as well if
248:34 - you keep on scrolling here and by the
248:35 - way this is wikipedia example we have
248:38 - port 20 which is for
248:41 - file transfer protocol so this is going
248:43 - to be for data transfer then we have
248:45 - port 22
248:46 - for secure shell so http traffic
248:50 - is only one of the things
248:53 - that we set up on a server and once our
248:57 - application is in deployment we have
248:59 - specific ports for that we have 80
249:02 - that is going to be for just http and we
249:05 - also have 443 which is going to be 40
249:08 - secure communication that's why
249:10 - when you go to course api or any other
249:14 - website that uses https you'll notice
249:17 - that
249:18 - there is a ip address and then more
249:21 - specifically 443 and you can also think
249:24 - of this as a apartment building
249:27 - so every apartment building has the same
249:30 - exact address right but the apartments
249:33 - differ
249:34 - so the same works here so on that server
249:37 - if i want to access it using ssh so
249:40 - secure shell i'm going to use
249:43 - port 22 but then if for example
249:47 - i want to use http protocol and if i
249:50 - want to access resource that way then
249:52 - i'm going to use port 443 so once your
249:56 - server is already in production yes
249:59 - these ports are not random there are
250:01 - specific ports for specific things we
250:04 - would want to do again back to our bank
250:06 - example if i want to cancel the account
250:09 - then i'm always going to be directed to
250:10 - that person because i'm going to click
250:13 - option number eight if i want to
250:14 - increase the limit then of course i'm
250:16 - going to be directed to a different
250:19 - person now while we're in development
250:22 - this is really arbitrary
250:24 - i can go here with five thousand i can
250:26 - go here with three thousand eight
250:28 - thousand wherever you would want i
250:30 - believe the ports between zero and
250:33 - thousand twenty four
250:34 - are already taken so you shouldn't be
250:36 - using them but in local development
250:39 - again this is an arbitrary number and
250:41 - that's why you can use anything you
250:43 - would want
250:44 - and again the most common example create
250:47 - react app where we spin up the server on
250:51 - localhost 3000 then gatsby has i believe
250:55 - eight thousand and then netlify cli has
250:58 - 8080 and i can go on and on and on so in
251:01 - my case i just went with 5000 but if you
251:04 - don't like this number just use a
251:07 - different port but of course please
251:09 - remember the actual value for the port
251:12 - because you'll need it once you need to
251:14 - access now if you're wondering well what
251:17 - happens once we deploy our application
251:21 - just put the pin on that and once we get
251:24 - to deployment of course i'm going to
251:26 - cover how actually we set it up that we
251:29 - serve that traffic
251:31 - on the
251:32 - port 80 for example for http or 443 for
251:37 - https
251:38 - and now of course we can go and test it
251:41 - out so let me navigate to my browser
251:44 - and i'm just going to go with localhost
251:47 - and eight thousand and or i'm sorry i
251:50 - just said five thousand and for some
251:51 - reason i went to eight which is gonna be
251:53 - the gatsby one and you'll see this
251:56 - interesting spinner
251:58 - so what's happening over here well the
252:00 - thing is yeah the user hit the server as
252:04 - you can see user hit the server that is
252:07 - what i see in the terminal however
252:09 - remember
252:11 - we have the response right so we have
252:13 - access to the response object and now we
252:15 - need to send back some info to the
252:18 - browser otherwise the browser is like
252:20 - okay
252:20 - so i hit this resource but nothing is
252:23 - happening
252:24 - and there's a method that we always
252:26 - always need to include
252:28 - in our response and the method name is
252:31 - and and i right away went to node docs
252:33 - of course again if you want to navigate
252:35 - there yourself please do so but i
252:38 - already right away went for response dot
252:41 - end and as you can see this method
252:43 - signals to the server that all the
252:45 - response headers and body have been sent
252:48 - and as a side note we'll do the headers
252:49 - in the next video because this one is
252:51 - already getting quite long
252:53 - that server should consider this message
252:55 - complete the method response and
252:58 - must be called on each response
253:02 - so
253:02 - for the browser not to be confused we
253:05 - need to go with res that end so res dot
253:09 - and that is one of the methods that is
253:11 - available on this response object and
253:15 - here we can either pass the text or we
253:17 - can set up for example html and in this
253:21 - case i'm just going to say home page
253:23 - that's it i'll just pass in the string
253:25 - and if we were to go back to localhost
253:28 - 5000 there it is now we have our
253:32 - homepage response and we can clearly see
253:35 - that in our terminal because every time
253:37 - you refresh the browser you'll have this
253:40 - console log in a terminal user hit the
253:43 - service
253:44 - hopefully everything is clear again we
253:46 - have access to http module and that is
253:49 - built in node and we just set it up some
253:52 - kind of variable most common convention
253:54 - is calling this http then on there we
253:57 - have create server method that takes in
254:01 - the callback which is going to be
254:03 - invoked every time the user hits the
254:05 - server and as parameters we have a
254:08 - request
254:09 - and response object and common
254:11 - convention
254:12 - is just calling the american res now of
254:14 - course you can call this stockhold
254:16 - burrito if you want but again common
254:18 - convention is calling this iraq and res
254:21 - and the reason why we have access to
254:23 - those objects
254:24 - is because in the http cycle
254:27 - that's what happens we have a request
254:29 - message that is coming in where we can
254:32 - find a bunch of useful info about the
254:34 - request that is coming in and then of
254:37 - course we need to respond to the browser
254:40 - in a meaningful manner so that's why we
254:42 - also have the response object and in
254:46 - every response we should always have end
254:49 - which is going to signal that the
254:51 - communication is over and then we just
254:54 - need to set up the port and again in
254:57 - development we just come up with
254:58 - arbitrary numbers and in my case we go
255:01 - with 5000 and we pass in that port
255:04 - in the dot listen method which is
255:07 - available when we invoke create server
255:09 - because we get back the object hopefully
255:11 - the basics are clear and now we can
255:13 - start expanding on our knowledge all
255:16 - right we're done with the basics but
255:18 - there are two major issues with our
255:20 - current setup first of all we don't
255:22 - provide any info about the data that
255:26 - we're sending back
255:27 - so we don't have any metadata about the
255:30 - body that we're sending out so we're not
255:34 - providing any information we just go
255:36 - rest that end and then pass in the
255:38 - string so that's issue number one and
255:40 - then issue number two
255:43 - if i were to go
255:45 - to the local host 5000 and if i type
255:48 - about
255:49 - or if i type contact or whatever you'll
255:52 - see that of course we're sending back
255:54 - the same response each and every time so
255:57 - if we go with contact again this is
255:59 - going to be a home page so why don't we
256:01 - deal with issue number one first
256:04 - where we provide more info to the
256:07 - browser of what we're actually sending
256:10 - back
256:11 - and then in the next video we'll deal
256:13 - with the request
256:15 - and the way we provide more info we just
256:18 - need to add
256:20 - more methods now specifically one more
256:23 - method and that is going to be res dot
256:26 - write head
256:27 - and in there you can probably already
256:29 - guess that we're just providing headers
256:32 - so we're providing metadata about our
256:35 - response and we go here with res dot
256:38 - and then we go with right
256:41 - head so right head and then we need to
256:44 - provide a few things we start with a
256:47 - status code and i'll talk about the
256:49 - status code in a second and for time
256:51 - being i'll just pass in 200 which just
256:53 - means that the request was successful
256:56 - and then we pass in the headers
256:59 - and one of the most common headers is
257:02 - the content type
257:03 - so this is where i specifically say to
257:05 - the browser hey listen i'm sending back
257:07 - html or i'm sending back css so where
257:10 - i'm sending back the image so browser
257:12 - knows
257:13 - well what to do how to render that
257:16 - content and like i mentioned already
257:18 - previously this is done using key value
257:21 - pairs so we go with content type so
257:24 - that's the name of the header and then
257:26 - we pass in text
257:28 - and then if for example i want to pass
257:31 - in the html i go with text
257:34 - forward slash and then html and now of
257:37 - course in this case where i have the
257:39 - res.end i can set up the html so for
257:42 - example i could go with heading 1
257:46 - and i'll say
257:47 - homepage same deal home page now if you
257:51 - want you can keep it this way where you
257:54 - have res that end and you directly pass
257:57 - in the html however i like to use better
258:01 - this approach where i go with res dot
258:03 - write and we do the same thing we pass
258:06 - in essentially the body and i set up my
258:09 - html here in the right or any content
258:12 - that i'm sending back and then
258:14 - explicitly call res.n again if you want
258:17 - you can pass this heading 1 into the end
258:21 - just make sure that you have the end and
258:23 - you saw that in a docs where it says if
258:25 - data is specified in a similar effect to
258:28 - calling response.write and then we pass
258:30 - in the data followed by res.n but you
258:34 - always always need to call res.n so this
258:37 - is really up to you if you want you can
258:39 - pass this directly into res.n
258:41 - i like to write it a bit explicitly
258:44 - where i say res.right so that is my body
258:47 - and then i just end the communication by
258:50 - calling
258:51 - res.n and now of course
258:54 - if i go back to the browser again i'll
258:57 - still have the same issue where it's
258:59 - going to be displayed for every request
259:02 - meaning either contact page homepage or
259:05 - whatever but now i provide way more
259:08 - useful info to the browser where browser
259:10 - knows hey i'm getting back the html so
259:14 - i'll need to render html
259:16 - and this stuff matters so let me show
259:18 - you if i change the content type back
259:22 - for example to plain
259:24 - and if i save and if you refresh now
259:27 - notice this is now treated as a text
259:31 - it's not treated as html so whatever you
259:34 - set up over here in the content type yes
259:37 - it does matter now express takes care of
259:40 - that so we won't have to do that but i
259:42 - just want to let you know that if you
259:43 - will be setting up the headers yourself
259:46 - yes the stuff that you type here matters
259:48 - and as the note it is also called mime
259:50 - type or you can think of it as media
259:54 - type so whatever we're sending back and
259:58 - now let's go over the status codes as
260:00 - well as other options for mime types and
260:04 - this is where i would like to introduce
260:06 - an awesome resource for anything http
260:09 - related and that is going to be no other
260:11 - than the mozilla docs so if you go to
260:14 - http and status codes you'll see
260:18 - probably the first link is going to be
260:20 - to the mdn
260:21 - and as you can see http response status
260:23 - codes indicate whether specific http
260:26 - request has been successfully completed
260:30 - and like i mentioned before there are
260:32 - quite a few groups over here and there
260:34 - are quite a few codes but i would
260:36 - strongly discourage you from spending
260:38 - your weekend on memorizing the codes as
260:41 - we're going to be progressing with the
260:42 - course as we're going to be creating
260:45 - more complex applications of course
260:47 - we'll introduce more and more status
260:49 - codes but the main idea is following
260:51 - where
260:52 - when we send back the response
260:55 - i'm just saying is it successful
260:58 - maybe the resource wasn't available so
261:01 - then i sent back 404 or maybe there was
261:04 - a bad request that's why there's also
261:06 - option 400 and hopefully you get an idea
261:09 - where we are setting up that status code
261:12 - so the browser knows what is happening
261:15 - with the request was it successful
261:18 - was there an error maybe i don't know
261:21 - you're not authorized to access it and
261:23 - on and on and on and if you keep on
261:27 - scrolling notice so the 100 ones are
261:30 - going to be informational responses then
261:32 - for successful one we have 200
261:35 - so that probably is going to be the one
261:37 - that you'll use the most so that means
261:39 - that request has succeeded then we have
261:42 - 201 also something that we'll use
261:44 - throughout the course a lot and this one
261:47 - is
261:48 - once the post request is successful so
261:51 - if you add the resource successfully
261:52 - onto the server then you just send back
261:55 - to one
261:56 - we have 300s for redirect and then these
262:00 - are the ones that you probably don't
262:02 - want to get
262:03 - if you are surfing the web so 400 is for
262:07 - bad requests
262:08 - so for example you are requesting some
262:11 - kind of data or you're trying to do
262:12 - something on the server but you don't
262:14 - provide the info
262:16 - so i don't know i'm trying to add the
262:18 - user but i don't provide the username
262:21 - something along those lines then 401 is
262:24 - for unauthorized then 403 forbidden and
262:27 - 404 not found so in our case we'll set
262:30 - up a response if the user is trying to
262:33 - access the resource that does not exist
262:37 - so hopefully it is clear that is the
262:40 - status code again
262:42 - i wouldn't suggest memorizing it as we
262:45 - are moving along with the course of
262:47 - course we'll cover more status codes
262:49 - just understand the main idea
262:51 - where you attach that status code to let
262:54 - the browser know hey what's happening
262:56 - and it is very important that you use
263:00 - the correct status codes because
263:01 - we are in charge here nothing stops me
263:04 - from sending back the 404 here meaning
263:08 - the resource is not found
263:10 - and then when you
263:12 - navigate to the contact page for example
263:15 - here and if you inspect again the
263:18 - browser network tab you'll see this
263:20 - confusion info where 404
263:23 - is technically not found
263:25 - right but at the same time we are
263:28 - sending back the correct resource so yes
263:31 - whatever we type as far as the status
263:32 - code it does matter it's not just some
263:35 - random info and that just reflects what
263:38 - is happening with the request and then
263:42 - lastly let's talk about mime types same
263:44 - deal just go to your favorite search
263:46 - engine and just type mime
263:49 - and types and again i suggest using the
263:52 - mdn
263:53 - and these are just going to be media
263:55 - types so whatever we're sending back
263:58 - there's quite a few out there now again
264:01 - express takes care of that
264:03 - so we don't need to worry about it but
264:06 - if you ever need to set it up i don't
264:08 - suggest memorizing them
264:10 - the ones that you'll need to use
264:12 - you'll pretty much be able to google it
264:14 - right away you can also use the npm
264:16 - packages so no you don't need to go and
264:20 - memorize them again just remember the
264:23 - main idea where you're sending back
264:26 - something right and you need to describe
264:29 - to the browser well what are you sending
264:31 - back
264:32 - are you sending back the image are you
264:33 - sending back css are you sending back
264:36 - the html and as you saw in a previous
264:39 - example
264:40 - if you change that mime type if you
264:42 - change that content type header yes the
264:45 - browser will interpret that differently
264:48 - and once we successfully have set up
264:51 - more proper response now let's start
264:53 - dealing with the request object
264:57 - beautiful and with our basic headers in
265:00 - place now let's deal with the request
265:03 - object
265:04 - and like i already previously mentioned
265:06 - it's just a giant object and if of
265:09 - course we can slog it
265:11 - then we'll see it in a terminal so i'm
265:13 - going to go back to my localhost 5000
265:16 - and as i said note this is getting quite
265:19 - busy so i can just remove some of the
265:21 - tabs and if i just refresh the browser i
265:25 - should see in a terminal a giant object
265:29 - so what are we looking for
265:31 - well let's go back to our slide
265:34 - and remember the start line
265:36 - we had a method
265:38 - so that signals what the user is trying
265:40 - to do either get the resource post a
265:42 - resource or whatever and then we have
265:45 - the url
265:46 - now in order to save us a little bit of
265:47 - time i won't cover the methods with http
265:51 - we'll just deal with the url but we will
265:55 - cover of course methods once we hit the
265:58 - express for now i'm just going to assume
266:00 - that the only thing that the users are
266:03 - trying to do they just want to get the
266:05 - resources from our server so that's why
266:08 - we won't look for the method just keep
266:09 - in mind that yes of course those methods
266:12 - are available on this request object
266:15 - there is a property by the name of i
266:18 - believe it was just simply a method so
266:20 - if we cancel log
266:22 - and if i refresh notice here in a
266:25 - terminal it says get
266:28 - so the user is performing a get request
266:31 - so the user is trying to get the
266:34 - resource so that's one thing that we
266:36 - could take a look at and the other one
266:38 - is actually the url so let me uncomment
266:41 - this one and i'm looking for the url
266:44 - property
266:45 - and again i refresh and now in the
266:47 - console i should have this
266:49 - forward slash contact so that just means
266:52 - that the user is trying to access the
266:55 - resource by the name of contact and if
266:59 - of course the resource is there awesome
267:01 - we send something back if not then most
267:03 - likely would send back the 404 now if i
267:06 - delete that contact and if i simply go
267:08 - with 5000 notice i'm going to have the
267:11 - forward slash so again this just signals
267:14 - that we're getting the home page so
267:16 - forward slash is going to be the home
267:18 - page and then whatever other resource we
267:21 - would want we would have port slash and
267:23 - then the resource now sometimes those
267:25 - resources are going to be forward slash
267:27 - resource name and then another forward
267:29 - slash and another resource name and on
267:31 - and on and on you can really type here
267:34 - whatever you want so again i go with
267:36 - localhost about and then info and i
267:39 - don't know something john right so i can
267:41 - add that here and there it is now i'm
267:44 - requesting this resource and if it's not
267:47 - there we send back 404 if it's there
267:49 - then of course we send back the useful
267:52 - info
267:53 - so hopefully that is clear yes this will
267:55 - just mean that it is a homepage and
267:57 - whatever comes after the homepage well
268:00 - that's the resource that the user is
268:02 - trying to access and now of course we
268:04 - can set up the if statement whereas say
268:07 - yes if it is a home page please send
268:10 - back
268:11 - this html if it is about page then send
268:14 - something else and then if
268:17 - i cannot find that resource that you're
268:18 - looking for then we'll send back 404.
268:22 - now there's going to be a little bit of
268:23 - copy and pasting just so we can save a
268:26 - little bit of time we're just going to
268:28 - go with if and actually we can set this
268:30 - up as a property so let's go to const
268:32 - url is equal to request url and then
268:37 - we'll say if url is equal to forward
268:39 - slash what does that mean well that
268:41 - means that it is a homepage so let's
268:44 - grab these three lines of code
268:46 - and move them up and now of course i
268:49 - want to set up else if
268:51 - now i'll just set up one for the about
268:53 - page so if url is equal to about page
268:58 - then we'll do something else and if
269:01 - none of those match well then i'll just
269:04 - say
269:04 - else and i'll send back 404 now i will
269:09 - add some comments here
269:11 - just so
269:12 - we are clear on what is happening so
269:14 - this is going to be about page
269:16 - then this is going to be called
269:18 - home page
269:19 - home page
269:21 - and then we're going to have the 404 so
269:24 - resource not found
269:26 - so again in order to save us a little
269:28 - bit of time let's just copy and paste
269:30 - one and two and again content type will
269:33 - be exactly the same so that is going to
269:35 - be html because we'll send back the html
269:38 - i'll say about
269:40 - and i don't know page let's call that
269:43 - and then last one is going to be the 404
269:45 - so in here of course we're not going to
269:47 - send back 200. 200 is for successful
269:51 - request
269:52 - now of course i want to say hey listen
269:55 - the resource that you're trying to
269:56 - access well it doesn't exist on my
269:59 - server so here i go with 404 and again i
270:03 - go with the same content type text html
270:06 - and then let's just send back the
270:09 - heading 1 with page
270:12 - not found so save this one
270:15 - and now of course once i refresh check
270:17 - it out i get this page not found why
270:20 - well because there is no resource
270:21 - forward slash about info and john
270:24 - but if i go to just about
270:27 - there it is now of course i have my
270:29 - about page and then if i go back to the
270:32 - homepage of course i have heading 1 with
270:35 - a home page now we optionally if we want
270:39 - we can
270:40 - add the status text as well and in order
270:45 - to see that let's just go back to the
270:47 - node docs so this is going to be the
270:49 - http
270:50 - and of course i'm looking for right head
270:53 - and we have a right head here notice we
270:57 - have status code optionally we can pass
270:59 - in status message and then we have the
271:02 - headers so again let's go back to our
271:04 - slide
271:05 - this is the most important one status
271:07 - code and then the status text
271:10 - essentially is just going to be added in
271:12 - this case we don't need to do anything
271:14 - because again if we were to go back to
271:17 - the browser network tab
271:20 - and if we take a look at our localhost
271:23 - there is first of all this is forward
271:24 - slash that just means that we're going
271:26 - to the homepage and the status code is
271:29 - 200 and then we have this status text
271:32 - now again if i navigate to a page that
271:34 - doesn't exist for example john then of
271:37 - course i'm going to get the 404 so
271:40 - that's the status code and then the
271:42 - status text is not found
271:45 - so hopefully it is clear
271:47 - now we have a bit more
271:50 - meaningful server where we have
271:53 - multiple resources we have home page we
271:56 - have the about page
271:58 - and also we have the error page and with
272:00 - this in place now of course we can start
272:03 - working on more complex setup
272:06 - nice and with our most basic example in
272:09 - place now i'm going to start throwing
272:11 - mine grenades at you first of all i want
272:14 - to let you know that of course we're not
272:16 - limited to passing in the html directly
272:20 - into the dot right or that end meaning
272:25 - imagine if you would have to every time
272:28 - just set it up or your html in methods
272:31 - directly of course what we can do
272:33 - instead
272:34 - is set up the file
272:36 - then require the file using the file
272:38 - system and then just pass it in now keep
272:41 - in mind one thing though where we will
272:44 - be passing in the
272:45 - contents of the file not the file itself
272:49 - and that's very important we'll be
272:50 - passing in the contents of the file so
272:53 - that means we still need to use this
272:54 - content type just because we're going to
272:56 - be getting the data from the html file
272:59 - doesn't really mean anything
273:01 - yes it's nice it's going to make our
273:03 - lives easier if you want to set up a
273:06 - more meaningful web page but we still
273:08 - need to set up the content type now this
273:11 - is going to be a temporary file because
273:13 - in the next video we'll cover a more
273:18 - serious example and i already prepared
273:21 - all the files for you so this is where
273:23 - we'll really struggle and this is where
273:26 - i'll show you why we use the express but
273:29 - for now if you want to follow along
273:32 - just create a simple
273:34 - index html or about html doesn't really
273:36 - matter how you call the file
273:38 - in the folder again this is really
273:41 - optional i'm going to go with new file
273:43 - and i'm gonna call this index html and
273:46 - again the whole reason why i'm doing
273:48 - that because i wanna set up a more
273:50 - proper page and i don't wanna type
273:53 - everything here in the right or end i
273:56 - mean it's much more nicer here right so
273:58 - i'm just going to go with emma setup in
274:00 - visual studio code i get my basics and i
274:03 - can say
274:04 - home page home page
274:07 - and then i'm just going to go with a
274:08 - heading 4 of hello world again this is
274:11 - just a showcase that sky is the limit
274:14 - just like you normally would set up to
274:16 - html you can do exactly the same thing
274:19 - and then i'm going to go back to app.js
274:22 - and first of all i'm going to get the
274:24 - read file so i'm gonna go with const and
274:26 - then read file and sync and i'm gonna
274:29 - talk about why i'm using this thing in a
274:32 - second so don't freak out i know i
274:34 - mentioned before that we need to be
274:35 - mindful
274:36 - of the methods that we use
274:39 - that there is a difference between the
274:41 - blocking and non-blocking and i'm just
274:43 - going to go with fs over here
274:45 - and we need to come up with some kind of
274:48 - name and again in the next video there's
274:50 - going to be
274:51 - more data here so that's why i'll say
274:54 - get
274:55 - all files
274:56 - for time being in this video i'll just
274:58 - get one and i'm going to call this home
274:59 - page again
275:01 - call it whatever you would want you can
275:03 - call this bobby lee doesn't really
275:04 - matter it's just a variable and we're
275:06 - going to go with read file and sync and
275:09 - of course where's the file it is in the
275:11 - same folder so we go with relative path
275:14 - and i'm just going to call this index
275:15 - html now again we're getting the
275:18 - contents
275:19 - now
275:20 - why i'm using here they read file sync
275:23 - well there's two reasons first of all we
275:25 - need to keep in mind that we're not
275:27 - invoking this
275:29 - every time someone comes to the server
275:31 - please keep in mind that we require that
275:34 - file
275:35 - when we instantiate our server
275:38 - so basically that initial time
275:41 - when the server starts running so it's
275:43 - not like when the request comes in then
275:45 - again every time we're requesting the
275:47 - file yes of course if i were to place
275:51 - this in the if block yeah that's a
275:53 - different scenario meaning if i were to
275:55 - even place this in a create server again
275:57 - same scenario but not in here again
276:00 - we're just requesting this once that's
276:02 - the first reason why i went with that
276:04 - and second it's just an example so i
276:06 - want to make my life a little bit easier
276:08 - what i want to focus on is something
276:09 - else with this home page in place now of
276:12 - course what i would want is to go back
276:15 - to my if where i'm checking for the
276:17 - homepage and instead of going with
276:20 - res.right and then typing it out i'm
276:22 - just going to go with our content now
276:24 - again we're still keeping this one the
276:26 - text.html and i'll show you in a second
276:28 - what happens if we change it to a text
276:31 - plane and now we go with a homepage
276:34 - and now be prepared to be amazed because
276:37 - if i go to not john
276:39 - my resource of course doesn't exist
276:41 - there it is check it out we have home
276:43 - page as well as the hello world
276:46 - so we can start making some meaningful
276:49 - html pages and we can serve them with
276:53 - our awesome server and just to
276:56 - re-emphasize my point
276:58 - if we change this to a plane and save
277:01 - and refresh
277:02 - now of course we're getting a text so
277:05 - yes it is very important
277:07 - of what content type we are setting up
277:10 - so let's go back to html and now of
277:12 - course we are in good shape awesome we
277:15 - have our homepage and now of course i
277:18 - can go to index.html and go wild and
277:22 - crazy
277:23 - with my page setup
277:25 - not bad not bad now we know that we can
277:28 - access the contents of the file directly
277:31 - so of course we can set up proper pages
277:35 - but now let me throw you a mine grenade
277:39 - where we'll have to add way more code
277:42 - here
277:43 - if we want to really serve some
277:46 - meaningful web page
277:48 - and the example is going to be following
277:50 - if you navigate to navbar app so that's
277:53 - the folder you'll find index.html
277:56 - you'll find style css logo svg as well
277:59 - as browser hyphen app.js and i simply
278:02 - call this browser app file so you're not
278:04 - confused between the two so this is
278:07 - going to be for our server and this is
278:09 - our browser app and effectively this is
278:12 - a complete app that we set up i believe
278:16 - in my javascript course when we were
278:18 - building projects so effectively this is
278:21 - a little navbar with a toggle
278:24 - functionality and let me assure you
278:26 - something right from the get go the app
278:29 - works
278:30 - so if you get any issues along the way
278:33 - it's because the node is not working
278:35 - the app itself is going to work and i
278:37 - can simply showcase that if i go to
278:40 - navbar app and i'm going to copy that
278:41 - one and i'll place it
278:43 - on my desktop
278:46 - and then if you spin up the index html
278:49 - i can guarantee you that this is going
278:51 - to work there it is that's my
278:53 - application
278:55 - and i can make it smaller and there it
278:57 - is now i'm toggling again our goal is
278:59 - following
279:00 - i want to take this project index.html
279:05 - with style css logo as well as the
279:08 - javascript file
279:09 - so the html structure
279:11 - the
279:12 - styling the logo that you can see over
279:15 - here as well as the logic i want to take
279:17 - all of it and serve it on my server
279:20 - and i know that the app works so all
279:24 - that is good so let's see what struggles
279:27 - we're going to have along the way so
279:29 - here i have the home page right
279:31 - and instead of getting it from the
279:33 - index.html which by the way i'm going to
279:35 - delete because again this was just
279:36 - temporary now of course i would want to
279:38 - access this one
279:40 - from the navbar app that's the folder
279:43 - name right and then i'm looking for the
279:45 - index html and i simply just need to
279:47 - change my path where instead of getting
279:50 - it index html from the root which
279:53 - doesn't exist anymore i'm going to go to
279:55 - navbar hyphen app
279:58 - and then of course i still get the
280:00 - homepage
280:01 - and as you can see i'm still serving
280:04 - also the contents from that index.html
280:07 - the only thing i did
280:09 - is just change the path that's it
280:11 - and technically we should see exactly
280:14 - the same right
280:16 - but
280:17 - here's the kicker we navigate here and
280:19 - if i refresh
280:21 - what is happening
280:22 - i don't have the logo
280:24 - i don't have the button
280:26 - i mean i do have the button but it
280:28 - doesn't do anything and i can see only
280:31 - the structure
280:32 - and we have quite a few 404s here
280:36 - and actually to give you a good idea why
280:39 - is this happening
280:40 - i want to navigate back to our project
280:43 - and let's just console log
280:45 - the urls
280:47 - and i think this is going to give you a
280:49 - clear message why this is happening so
280:52 - let me go back and i'm just going to
280:54 - refresh one more time
280:56 - and check it out so we're requesting the
280:59 - homepage so that makes sense right so i
281:02 - come here i request the home page and i
281:04 - serve this html file
281:07 - from the navbar app
281:08 - and then i have three more requests
281:10 - i have one for styles one for browser
281:13 - and one for logo now why is that
281:15 - happening well because in my index html
281:19 - if you check it out
281:21 - of course i do reference the style css
281:23 - because i want to add the styling right
281:25 - i do reference the logo
281:27 - because the logo is right here in my
281:30 - folder
281:30 - and also of course i do have the one for
281:33 - the app right the one where i have my
281:36 - logic
281:37 - so this is what happens we send back
281:41 - the initial
281:42 - html content and the browser starts
281:45 - reading the content
281:46 - and every time we have basically a path
281:49 - to our server browser is like hey server
281:52 - give me this resource so give me style
281:54 - css give me logo svg as well as whatever
281:59 - we have here the browser app right so
282:01 - keep in mind that these ones are for
282:03 - icons
282:04 - and actually they are external so this
282:07 - one goes to phantasm that's a little bit
282:09 - different scenario yes the browser still
282:12 - performs this request but of course this
282:14 - is external resource
282:16 - now these ones are on our server but the
282:19 - problem is following
282:20 - are we handling these requests
282:23 - in our create server
282:25 - and of course the answer is no we handle
282:28 - forward slash we handle about and then
282:30 - for everything else we have this 404
282:34 - so to answer your question yes
282:37 - now manually we'll have to request
282:41 - all the files so lower svg style css as
282:45 - well as the browser app
282:47 - assign them to some kind of variable and
282:49 - set up these paths again this is just an
282:51 - example if you don't want to follow
282:53 - along if you just want to see how it's
282:56 - going to work
282:57 - just sit back and relax
282:59 - but in my case i'm going to request
283:02 - all these resources here
283:04 - and then set up more else if statements
283:08 - where if the browser wants to get the
283:10 - css then of course we'll search css if
283:13 - the browser wants to have logo then of
283:15 - course the browser is going to get local
283:18 - and again if you take a look here in the
283:20 - elements you'll again see exactly why
283:23 - because we have our html structure and
283:26 - then there it is we have style css so
283:29 - notice how browser is going to http
283:32 - localhost 5000 forward slash what well
283:35 - style css right well do we have that
283:38 - path and again the answer is no so let's
283:42 - do this way i'm going to copy and paste
283:44 - and i'm just going to come up with
283:45 - different names here i'm going to say
283:48 - home styles
283:50 - and then the third one i guess is going
283:52 - to be home image
283:54 - and then the fourth one will be home
283:56 - logic so that is going to be my app one
283:59 - then we'll have to change some files
284:01 - here as well so i'm looking for styles
284:04 - css i believe right
284:06 - that's the file name then i have logo
284:08 - svg
284:10 - that's where my logo is sitting so logo
284:14 - svg and then finally let's just delete
284:18 - this one as well and call this browser
284:21 - hyphen app
284:23 - and js so home styles home image and
284:26 - logic and like i said yes manually one
284:28 - by one we'll have to add all these
284:31 - resources so instead of about page
284:34 - i'll just call this styles and the value
284:36 - that i want to check for here is exactly
284:39 - the same like in my browser so they need
284:42 - to match so then of course the browser
284:44 - will get the contents
284:46 - of the css file in this example so i'm
284:49 - going to go with styles and then css
284:53 - now i do want to change right now the
284:55 - content type because am i sending back
284:57 - the html of course the answer is no
285:00 - we're sending back the css so we go text
285:02 - css now let me say this one more time
285:04 - please don't zero in on these mime types
285:08 - if you will ever need them you'll be
285:10 - able to find them within a matter of
285:13 - seconds just
285:14 - type along with me and we're going to be
285:17 - in good shape now as far as the right
285:20 - in our body so in our response that
285:23 - we're sending back are we going to send
285:25 - back html of course the answer is no now
285:27 - of course i want to send the styles
285:29 - right and the variable for that is home
285:32 - styles so that's where
285:34 - my content is for the styles css and
285:38 - once i save check it out
285:41 - now we are moving along in the right
285:43 - direction because i do have the styles
285:46 - so it looks already somewhat decent now
285:49 - the logo is still missing and there's no
285:52 - logic because i don't have the app.js or
285:55 - the logo svg but we are moving in the
285:59 - right direction so copy and paste and
286:02 - you can probably already guess that
286:04 - we'll just repeat over here we'll say if
286:07 - the url is equal to logo svg and i'll
286:10 - say
286:11 - image logo as far as the comment
286:14 - and we're just going to go with logo
286:16 - and 3g and as far as the mime type for
286:19 - this sucker it is image
286:22 - image forward slash svg and plus
286:26 - xml like so
286:29 - and let's go with home
286:31 - and i believe i named this home and
286:34 - image like so
286:36 - and then the last one of course
286:38 - is going to be our javascript so
286:40 - let's say here logic
286:42 - and the resource that i would want to
286:44 - provide is browser app
286:46 - js like so
286:49 - and then
286:50 - the content type is equal to text
286:54 - and then javascript
286:56 - and of course now i would want to send
286:59 - the home and logic
287:01 - so let's save this one
287:03 - and now if i go to my browser
287:06 - and if i refresh
287:08 - check it out now of course we have
287:10 - everything we have the logo as well as
287:14 - the proper functionality with browser
287:17 - app and notice how
287:19 - all our requests are 200 instead of 404
287:23 - where the previously browser wasn't able
287:26 - to find those resources and now of
287:27 - course we are providing them and if we
287:30 - want to test out the functionality there
287:32 - it is
287:33 - now i can just go here and notice how i
287:36 - can toggle the menu as well and now of
287:39 - course we'll switch gears and start
287:40 - working with express because hopefully
287:43 - it's clear that yes we can
287:46 - set up our server with just http module
287:50 - but imagine a scenario where you have a
287:54 - website with tons of resources
287:56 - and then of course you need to set up
287:58 - every single resource in this matter now
288:01 - i don't know about you
288:03 - but i would go nuts somewhat quickly
288:07 - all right and once we have struggled a
288:09 - bit
288:10 - now let's make our lives easier by
288:12 - getting to know express js
288:15 - express is a minimal and flexible
288:17 - node.js
288:19 - web app framework designed to make
288:21 - developing websites web apps and apis
288:25 - much faster and easier if i have to be
288:28 - honest it's almost unfair how easy and
288:31 - fast it is to spin up the api with the
288:34 - help of express
288:36 - and while it's not officially part of
288:38 - node meaning unlike http module express
288:41 - is not one of the built-in modules at
288:44 - this point in time express is pretty
288:46 - much a standard when creating web
288:48 - applications with node.js express has
288:52 - awesome documentation which we will
288:54 - reference from time to time and you can
288:57 - find the docs at expressjs.com
288:59 - again the site is expressjs.com
289:03 - and as far as the install you simply
289:04 - need to run the command of npm install
289:09 - and the package name is express
289:12 - now they do suggest this hyphen hyphen
289:15 - save flag
289:16 - and effectively the reason why they do
289:18 - that is because in the earlier node
289:21 - versions
289:22 - if you did not add this flag
289:25 - then package wasn't saved to the package
289:27 - json
289:28 - meaning when you push this up to the
289:30 - github the next person who was getting
289:32 - your project well he or she
289:34 - did not have the reference for the
289:36 - package so of course that caused the
289:38 - errors now currently that issue is fixed
289:42 - so this is just a good precaution
289:44 - but technically you shouldn't have any
289:46 - issues if you don't run the command
289:48 - again nothing bad is going to happen if
289:49 - you add this dash save but technically
289:53 - these days you can skip it so just grab
289:56 - the command like so
289:58 - and just navigate back to the project
290:00 - just keep in mind that of course i
290:02 - already installed the express
290:05 - for the express tutorial this is just
290:08 - for your own project if you want to
290:09 - install the express if you set up your
290:12 - own package.json and all that if you
290:14 - want to install the express just run
290:16 - this command now one thing that i would
290:18 - like to mention though is that i'm using
290:22 - version 4.17
290:24 - so maybe by the time you're watching
290:26 - this
290:27 - they already have a version 5. now at
290:30 - the moment version 5 is in alpha meaning
290:33 - they're still testing everything but
290:34 - maybe by the time you're watching this
290:36 - this is already stable now if that is
290:39 - the case when you run npm install on
290:42 - express of course you'll get the latest
290:45 - version so your version is not going to
290:48 - be this 4.17 now i wouldn't worry if
290:51 - it's for example four point i don't know
290:53 - 24 but if it's five there might be some
290:56 - breaking changes and at that point you
290:59 - have two options if that is the case if
291:01 - the version is already five then you can
291:04 - either
291:05 - reference the api docs for yourself
291:08 - meaning you can take a look at the
291:10 - methods and all that what the version
291:12 - five provides or
291:15 - if you want to use
291:16 - all the methods and properties that we
291:19 - use in tutorial simply install the same
291:22 - version how you can do that well
291:24 - you just need to go to npm install
291:27 - express so this stays the same and again
291:30 - you can remove it you can leave the dash
291:32 - dash save doesn't really matter and
291:34 - after express you go with add and four
291:38 - and then again i'm gonna go with the
291:39 - same one just keep in mind as long as
291:41 - you have four you're not gonna have any
291:43 - issues and then one so this is going to
291:46 - install express
291:48 - with this specific version hopefully
291:51 - everything is clear and now let's get to
291:53 - know express all right and once we have
291:56 - covered the express library basics now
291:59 - of course let's spin the sucker up and
292:01 - see how we can make a server
292:04 - way easier and with way less headache
292:08 - and i'm going to start by removing all
292:10 - the code in my app.js just keep in mind
292:14 - that if you ever need a reference
292:16 - go to the final one and then of course
292:19 - http basics is going to be where we set
292:21 - up the basic http server and then for
292:24 - example
292:26 - the http app example is going to be in
292:29 - the file number two
292:31 - and the way we work with express
292:33 - we start by setting up some kind of
292:36 - variable and of course we'll have to use
292:38 - the require so we go with require and
292:41 - then we're looking for express library
292:43 - again we can do that because we have
292:46 - installed the library
292:48 - but if you haven't then of course you'll
292:50 - get the error keep that in mind and then
292:52 - we go with const and then app is equal
292:55 - to express to whatever we imported and
292:58 - then we invoke it now
293:01 - if you're a bit iffy about this syntax
293:04 - just keep in mind that it is very
293:06 - similar to our previous example where we
293:09 - went with http
293:11 - then created the server and
293:14 - as a result we had our
293:17 - server instance correct so this is
293:19 - similar we're getting a function back
293:21 - from express and we just invoke it and
293:24 - we right away have our server instance
293:27 - with bunch of cool methods now what
293:30 - you'll also see
293:32 - on a web is something like this where
293:34 - since this is a function we can invoke
293:36 - it right away
293:37 - and then just call this one app
293:40 - again
293:41 - this is really your preference but
293:43 - mostly you'll see the first option where
293:46 - we first import the module and only then
293:50 - we invoke it
293:52 - so once we have this setup then of
293:54 - course we have a object with bunch of
293:57 - useful methods
293:59 - now the methods that we'll use the most
294:01 - are following amp.get and i'll just copy
294:04 - and paste here
294:05 - and i'll just change it around a little
294:07 - bit post
294:08 - and put
294:10 - as well as delete
294:13 - and also there's going to be all
294:16 - use
294:18 - and a listen now listen
294:21 - we already covered before in the http
294:24 - module and this one is pretty much the
294:26 - same where we just go with
294:28 - app.listen and then we just say what
294:31 - port we're going to be listening on so
294:33 - in this case of course this is going to
294:34 - be 5000 and then we pass in the callback
294:37 - function so when we instantiate that
294:40 - server we will run this function and a
294:43 - common convention is just setting up a
294:46 - console log where we say that yeah the
294:49 - server is listening on port such and
294:51 - such now for time being we're hard
294:53 - coding this value later i'll show you
294:55 - how we can make this one dynamic so for
294:58 - now i'll just say console log and then
295:00 - server
295:02 - is listening
295:04 - on port and then we go 5 000. so let's
295:09 - save this one and i'll run my npm start
295:12 - and i should see in a console server is
295:15 - running or listening on port 5000
295:18 - awesome so what about the other methods
295:22 - and the first four methods here just
295:25 - represent http verbs
295:27 - now if you remember
295:29 - when we talked about the http request
295:33 - and response messages
295:35 - well one of the things that we're
295:38 - looking for in the request message was
295:41 - the http verb
295:43 - and yes
295:44 - i set up some more meaningful examples
295:46 - where we'll see all of them in action
295:49 - for now just remember two things first
295:53 - this just represents
295:54 - what the user is trying to do
295:57 - whether read the data insert data update
296:00 - data or delete data
296:02 - and by default all browsers perform
296:05 - a get request
296:07 - so that's why we have here amp.get that
296:10 - post put and delete now all
296:13 - just works with all of them and we'll
296:16 - see that in a second when we set up the
296:18 - 404 page so essentially a response if we
296:22 - cannot find the resource on a server and
296:25 - app.use is responsible for middleware
296:28 - and since it's such a crucial part of
296:31 - express of course i prepared more
296:33 - examples on that where we cover
296:36 - everything from the scratch so for now
296:38 - just remember this is middleware but
296:41 - don't lose your sleep over it we'll
296:43 - cover it a little bit later in the
296:45 - course so we have app.listen beautiful
296:48 - we're listening on port 5000 but since i
296:51 - know that all the browsers are
296:52 - performing a get request i simply go
296:55 - with app dot get
296:58 - and then i need to specifically add two
297:00 - things a path so what resource the user
297:03 - is trying to access and it would make
297:06 - sense if we would start with root
297:08 - correct and then the second thing
297:10 - is the callback function so this
297:13 - callback function will be invoked every
297:16 - time
297:17 - user is performing a get request
297:21 - on our route so basically on our domain
297:25 - and then this callback function gets the
297:27 - same two arguments we go with request
297:31 - as well as the response so this is going
297:34 - to deal with incoming request message
297:36 - and then this is going to deal with our
297:39 - response and in express we go with res
297:43 - and then the method name is send so in
297:45 - here we can pass the string we can pass
297:47 - in the html and i'm just going to simply
297:50 - start with home
297:52 - and page so we save this one
297:55 - and now of course i'm going to navigate
297:56 - to my browser i'm going to say localhost
298:00 - and then 5000 and there it is now we
298:04 - should
298:04 - have homepage if you don't again please
298:07 - troubleshoot because otherwise it's not
298:09 - going to make sense
298:11 - what we are about to do next but if you
298:13 - see the home page you are in good shape
298:16 - so we're listening for get request on
298:19 - our route and then every time the user
298:23 - navigates to the root then of course we
298:26 - just send back the homepage now if you
298:28 - want you can of course go to log
298:30 - and user hit
298:32 - the resource or something like that
298:34 - doesn't really matter and then if you go
298:37 - back to the browser and if you refresh
298:39 - there it is we have user hit the
298:42 - resource awesome
298:43 - and just like in our previous example
298:46 - the basics one let's set up the about
298:49 - page as well as the 404
298:52 - so i'm going to go back to my app js
298:54 - and right above the app that listen i'm
298:57 - going to go with another app that get
299:00 - and in this case i'm looking for about
299:03 - so that's the resource and of course in
299:06 - here again we have rec and res
299:09 - and then as far as the response well
299:12 - i'll cheat a little bit and i'll just
299:13 - say res.send
299:15 - and we're going to go with about page
299:18 - and then of course i would want to
299:20 - handle the 404 as well
299:23 - so if the user
299:25 - comes to my server and tries to access a
299:28 - resource that doesn't exist well what am
299:30 - i going to send back
299:31 - and we can take a look at the default
299:33 - one so if i'm going to go with about i
299:36 - should
299:37 - see the about page but if i go with for
299:39 - example a contact page let's see what
299:43 - the express is doing and in this case i
299:45 - have cannot get the contact and if i
299:48 - inspect i can clearly see
299:50 - that in my network tab i have contact
299:54 - and this is a404 so that's going to be
299:57 - the default response now
299:59 - i can alter this of course and i can set
300:02 - up my own 404 response so i'm going to
300:05 - go with app and this is the case where
300:07 - i'm going to use all methods because
300:09 - again
300:10 - user can do multiple things on a server
300:13 - and i want to cover them all
300:15 - not just getting the resource or
300:17 - inserting the resource or whatever i
300:19 - want to cover them all so that's why i'm
300:22 - going to use my own method again this
300:24 - just handles all http verbs whether get
300:28 - post or whatever and again this method
300:31 - takes two arguments first one is going
300:34 - to be the path and the second one is
300:36 - going to be a callback function and as
300:38 - far as the path i can say all of them
300:41 - so whatever resource you're trying to
300:43 - access the response is going to be
300:45 - exactly the same if i cannot find the
300:47 - resource
300:48 - then i'll just send back this response
300:51 - so again i have a callback function rec
300:53 - and res in here and then we're going to
300:56 - go with res dot send and just like in
300:59 - our http example i'm gonna go with
301:02 - heading one
301:03 - and we'll say resource
301:06 - not found
301:07 - and let's close the heading one but of
301:10 - course i also would want to add the
301:12 - status right so that would make sense i
301:15 - don't want to send back 200. that would
301:17 - be very confusing
301:19 - so before we invoke send method i can
301:21 - also add status here and as you can see
301:25 - i can chain it so i have res not status
301:28 - so this is where i'll pass in my status
301:30 - code and then i go with send so in our
301:34 - not found example of course i would want
301:37 - to pass in the status code of 404 that
301:40 - is going to be more correct and the same
301:42 - goes here technically we can rely on
301:45 - express
301:46 - and it does a decent job of adding those
301:49 - status codes but a more common approach
301:52 - is explicitly setting up the status code
301:55 - so that way you have more control of
301:58 - what is sent back to the browser so in
302:00 - here i go with res and that send but
302:03 - before i set up that method
302:07 - i
302:07 - set up a status one first and i go with
302:10 - 200 so this just means that the request
302:13 - was successful so similarly i'll do that
302:16 - in the about where i go with status we
302:20 - pass in the 200 and then we set up a
302:23 - chained send so now if i go back to my
302:26 - browser and if i refresh now of course i
302:29 - have resource not found that is my
302:31 - heading 1 and i can clearly see my 404
302:35 - and if for example i'm looking for about
302:38 - there it is i have my about page as well
302:41 - as the homepage so if we go to localhost
302:44 - and 5000 that's going to be our route
302:47 - that is going to be our homepage all
302:50 - right and we're done with our basic
302:52 - example hopefully you can see that it is
302:55 - already way less code
302:57 - than just using the built-in http module
303:01 - and in the next example you'll see how
303:04 - express truly shines when it comes to
303:07 - setting up a server beautiful we're done
303:10 - with our basic example now let's tackle
303:13 - the big beast our navbar app
303:16 - and the setup for the following examples
303:20 - is really up to you if you're not a fan
303:23 - of retyping
303:25 - something you have already learned you
303:27 - don't have to do that you can just
303:29 - remove app.get
303:31 - all the way to app.all so basically
303:34 - leave the import as well as
303:36 - instantiation and
303:39 - listen as well however i am a fan
303:42 - of
303:43 - repeating something because that way
303:45 - whenever i need to create something from
303:48 - scratch i already have done it quite a
303:50 - few times so i don't have that blank
303:52 - page syndrome where you're like looking
303:54 - at the empty file and you don't know
303:56 - what to do so in my case i'm going to
303:58 - remove everything and we'll start from
304:00 - the scratch so const express is equal to
304:03 - require and of course we're looking for
304:05 - express
304:07 - and then i'm going to set up my app that
304:09 - is equal to express we invoke it and
304:11 - again we go with app.listen
304:14 - and we're going to go with 5000. now i'm
304:16 - not saying that i'm going to do that for
304:18 - every example
304:20 - but i'm just showcasing what is in my
304:22 - approach when i'm starting something new
304:26 - so when i'm learning something new yes i
304:27 - do like to retype some of the stuff
304:30 - quite a few times because
304:32 - that just makes sure that i remember it
304:34 - better and in here i'm going to go with
304:37 - server here's listening
304:40 - on port and we go with
304:43 - 5000 and then dot and in order to set
304:47 - everything up we're going to go with
304:49 - app.get so again i'm looking for the
304:52 - root and of course i would want to start
304:54 - with my index html correct that's the
304:57 - start
304:58 - and we go with app.get so we're
305:01 - listening for all the incoming requests
305:04 - that go to our route
305:05 - and of course we're specifically
305:07 - listening for get requests then we have
305:09 - our callback function rack and res
305:13 - and we'll set up the functionality in a
305:14 - second before we do anything let's also
305:17 - set up all
305:18 - and this is of course going to be for
305:20 - all the requests
305:21 - that will hit 404 so we're going to go
305:24 - with rack and res
305:26 - and here let's say res and then status
305:29 - so let's add here a 200 or i'm sorry
305:32 - four four my bad and then we're gonna go
305:36 - with send
305:37 - and instead of the send let's just go
305:39 - with the resource
305:41 - not found
305:42 - now when it comes to get
305:45 - in this case i would want to send the
305:46 - file more specifically i would want to
305:49 - send back the index.html
305:52 - and in order to do that i need to use
305:55 - send file method that comes with express
305:58 - now in there though i do need to provide
306:01 - a absolute path so we'll have to use one
306:04 - of the modules we covered before and
306:06 - that is going to be a path module so i
306:08 - go with const path is equal to require
306:13 - and i'm looking for path module again we
306:14 - don't have to install it comes
306:16 - preinstalled with node so we are in good
306:20 - shape and then where we have our
306:22 - callback function we go with res
306:25 - and send file method and here let's pass
306:29 - in path and then resolve so path dot
306:33 - resolve remember that was one of the
306:35 - methods we cover
306:36 - and effectively i would want to pass in
306:39 - the dirt name
306:40 - so this is going to be path to our
306:43 - directory because we do need to provide
306:45 - that absolute path and then of course
306:47 - we're looking for our index.html which
306:49 - is sitting in the navbar app so forward
306:52 - slash and then navbar
306:55 - hyphen app and then we have another
306:58 - forward slash index html now if i have
307:02 - to be perfectly honest in this case we
307:04 - can also use path dot join it doesn't
307:07 - really matter since their name provides
307:09 - that absolute path but just to be a bit
307:12 - explicit that we are providing
307:15 - absolute path i went with path dot
307:17 - resolve and then the their name and then
307:20 - whatever is the path to my index html
307:24 - and the moment we save it
307:26 - we'll have the same errors
307:28 - just like in the http module so i go to
307:31 - my localhost 5000 and i still have the
307:34 - same issues i still don't have style css
307:37 - there's no sign of browser app as well
307:40 - as the logo
307:41 - now in express though we don't have to
307:44 - do this whole song and dance
307:46 - like in http module
307:49 - in express i can simply go above all my
307:52 - app.gets and amp.alls and i can go with
307:56 - app
307:57 - dot use and this is going to be the case
307:59 - where i'll type out the code and then
308:02 - i'll explain everything that is
308:04 - happening and we'll pass in the express
308:07 - so
308:08 - this is what we're importing so this is
308:10 - not going to be our server instance
308:12 - instead we're going to go with express
308:15 - and then static that's the method and in
308:18 - here again we just need to provide a
308:20 - path now common name is setting this up
308:22 - as the folder by the name of public
308:25 - please keep in mind technically you
308:26 - don't have to do that you can just point
308:28 - to our navbar app but in my case i will
308:32 - do that i will set up here
308:34 - dot forward slash and i'll call this
308:37 - public so now of course what i need is
308:40 - to set up a folder by the name of public
308:43 - and then
308:44 - all my static resources all my static
308:47 - files i would want to transfer there now
308:49 - don't worry about it i'll cover in
308:51 - length
308:52 - what in a server land means static
308:54 - resources for now what i would want you
308:56 - to do is go back to our folder
309:01 - and that is going to be express tutorial
309:03 - and of course you can do that in visual
309:04 - studio code i just think that this is
309:06 - going to be a bit easier to see so i'm
309:09 - going to create a new folder again
309:11 - common convention is calling this public
309:13 - but you can call it whatever lobster it
309:16 - doesn't really matter and then in my
309:18 - case i'm just going to copy these files
309:20 - so take browser app take logo and take
309:24 - styles if you want you can move them
309:26 - just remember that the previous code is
309:28 - not going to work as far as the http
309:31 - module setup so i'm going to copy these
309:33 - ones
309:34 - and paste it here in my public so now of
309:38 - course i have browser app logo svg and
309:41 - style css
309:42 - so
309:43 - of course now i can zoom out and once i
309:48 - save
309:49 - check it out
309:50 - when we navigate to our route there it
309:54 - is this is our application and what's
309:57 - really cool all those resources are
310:01 - right away available so if i go to my
310:03 - localhost 5000 remember browser was
310:07 - looking for what well it was looking for
310:08 - example for style css if you go here
310:12 - there is a resource by the name of style
310:14 - css and of course in here i have all my
310:18 - css code and notice how
310:21 - we didn't have to set up the statuses we
310:24 - didn't have to set up the content types
310:27 - or any of that express takes care of it
310:30 - all now of course you probably at this
310:32 - point have more questions than answers
310:35 - so let me start clearing them up and
310:37 - first i'm just going to add a comment of
310:39 - setup
310:40 - static
310:41 - and middleware middleware
310:44 - and like i mentioned app.use is for
310:48 - setting up the middleware and we have
310:51 - more serious examples coming up
310:54 - so for time being please don't worry
310:56 - about this line okay so please don't
310:58 - worry about app.use what is express
311:00 - static that is essentially a built in
311:02 - middleware i will cover everything step
311:05 - by step
311:07 - in this video i would want you to
311:08 - understand what the term static asset
311:11 - means
311:11 - and it simply means
311:13 - that it is a file that server doesn't
311:16 - have to change it so instead of our http
311:20 - example where we created a path
311:23 - for every such resource
311:26 - and if i were to have i don't know 20
311:29 - 000 images
311:30 - i would have to repeat the same steps
311:33 - instead since this is a static asset
311:37 - meaning an asset where the server
311:40 - doesn't need to change it we simply
311:43 - place it in designated
311:45 - folder again the common name for those
311:47 - folders are public or static
311:51 - and then we just dump all those assets
311:54 - in there so if i were to have i don't
311:56 - know 20 000 extra images in here i can
312:00 - just dump them
312:02 - and express will take care of it all it
312:04 - will set up the paths it will set up the
312:07 - mime types it will set up the status
312:09 - codes and all of that good stuff so
312:12 - hopefully that is clear static assets
312:15 - are just files that server doesn't have
312:18 - to change and an example of a static
312:21 - asset is an image file here's the style
312:24 - file and also a javascript file and here
312:28 - comes the next question
312:30 - what is this guy with weird eastern
312:32 - european accent talking about
312:34 - because all my life i've been told
312:37 - that the javascript
312:39 - makes my apps dynamic
312:42 - it adds all the functionality
312:45 - so how come this is just another static
312:47 - asset
312:48 - and to answer your question yeah you're
312:51 - right javascript
312:52 - does make
312:54 - our apps dynamic however think about it
312:57 - this is a browser app so it makes
312:59 - dynamic on a browser
313:02 - as far as servers is concerned
313:04 - it is just a asset doesn't need to
313:06 - change
313:07 - now if you're wondering well how to set
313:09 - up something dynamic
313:11 - just please put the pin on that and
313:13 - we're going to cover that when we cover
313:15 - server-side rendering because there is
313:18 - such thing as template engines
313:20 - and the simplest way for me to explain
313:22 - that is imagine the scenario where you
313:26 - can actually log in
313:28 - or in other way just showcase whoever is
313:32 - visiting the site and then dynamically i
313:34 - would display for example name
313:37 - so if the peter logs in then i'm sending
313:40 - back the html with the text of hi peter
313:43 - now if the john logs in then of course
313:46 - i'm sending back the username with the
313:49 - value of john so hopefully you get the
313:51 - gist where in this case notice this is
313:54 - just
313:55 - same old index html that i'm sending
313:58 - back regardless of who is visiting the
314:00 - site but yes there's also an option of
314:03 - setting this dynamically where depending
314:06 - on who's visiting the site or what the
314:08 - user is trying to do i'm actually
314:10 - modifying my file before i'm sending it
314:14 - back so hopefully it is clear how much
314:17 - easier it is to work with express
314:20 - where if we have static assets we just
314:23 - set up designated folder and just dump
314:26 - them all in and static asset just means
314:29 - a file that server doesn't need to
314:31 - change
314:32 - and of course we can start working on
314:34 - our next example nice hopefully we are
314:38 - clear on static acids and before we
314:41 - cover more complex expressed topics i
314:45 - would want to throw a mine grenade at
314:47 - attribute
314:48 - and it goes something like this
314:50 - so if we put two and two together
314:54 - i talked about static assets in the
314:56 - previous video
314:58 - but if we're looking at the
315:00 - index.html
315:02 - isn't this a static asset as well
315:05 - and of course the answer is yes
315:08 - so instead of sending this file
315:10 - we can add it to static assets and we're
315:13 - going to be in good shape and if i have
315:16 - to be perfectly honest with you when it
315:19 - comes to
315:20 - send file
315:22 - if we're using it to send back for
315:24 - example index html
315:27 - actually we use other two methods
315:30 - instead so first i'll show you the first
315:33 - one where we just dump everything
315:35 - as far as the static assets so i'll just
315:38 - add index.html to all my static assets
315:41 - in the public
315:42 - and that will effectively do exactly the
315:45 - same like we're doing here with send
315:48 - file and the other one is going to be
315:50 - using templating engine so of course
315:52 - that one will cover when we go to server
315:55 - set rendering so i'm just trying to
315:57 - showcase that yes there is this option
315:59 - of send file and we might use it from
316:01 - time to time throughout the course but
316:04 - not for sending back index html files so
316:07 - first let me just say that the other
316:10 - option one of the two other options that
316:12 - we'll use the most throughout the course
316:14 - is just
316:15 - adding two
316:17 - static
316:19 - assets
316:20 - like so and then the second one is going
316:22 - to be server side rendering
316:24 - where basically we'll use template
316:26 - engine for that
316:27 - so in order to set everything up now of
316:30 - course i just need to take my index html
316:33 - and again if you want you can just move
316:34 - it
316:35 - or in my case i'm just going to copy and
316:38 - paste
316:39 - so again i'm going to go back to my
316:40 - folder
316:42 - i'll zoom in massively
316:44 - so you can see better so express
316:46 - tutorial
316:47 - there is my navbar app and i'll just
316:49 - take the index.html
316:51 - and i'll copy and paste and now it is in
316:53 - the public
316:54 - so what happens index.html
316:58 - is always going to be a root
317:00 - so
317:00 - when the user hits the server by default
317:04 - server will serve this index.html and
317:06 - since our index.html basically has all
317:09 - the paths to browser app to logo svg and
317:12 - all that
317:13 - we're going to be in good shape more
317:15 - effectively we don't even need to set up
317:18 - this send file option
317:20 - so now of course i can just save it and
317:23 - once i refresh notice how nothing
317:26 - changed i'm still serving my app
317:29 - so we're still in good shape and if you
317:32 - take a look at the network tab notice
317:35 - everything still works correctly i'm
317:37 - still getting all the css all the
317:41 - browser javascript functionality as well
317:44 - as the logo and to answer your question
317:47 - yes that is effectively how you can set
317:50 - up the simple sites you can simply just
317:53 - dump all your files in the public just
317:56 - make sure that you serve them up
317:58 - and that's it and you're in good shape
318:00 - now we still have the 404 but as far as
318:03 - just serving straight up sites with html
318:06 - css and javascript yes you can simply
318:09 - dump them into public you can simply set
318:11 - up the middleware and serve all the
318:14 - static assets and you're going to be in
318:17 - good shape beautiful we are successfully
318:20 - done with the initial express setup
318:22 - and ready to cover more complex express
318:25 - topics before we do that though
318:28 - there's something important i want to
318:30 - mention you see when it comes to express
318:33 - in most cases you'll use one of the two
318:35 - following options
318:36 - you'll use it to set up api
318:39 - or templates with server side rendering
318:42 - now since term api is probably one of
318:45 - the most overused terms in the community
318:48 - and in various scenarios it can mean
318:51 - different things let's start by
318:53 - understanding that in express
318:56 - or in http case
318:58 - when we talk about api we mean setting
319:01 - up an http interface
319:03 - to interact with our data
319:06 - now data is sent using json which stands
319:09 - for javascript object notation and in
319:13 - order to send back our response we're
319:15 - going to use
319:17 - res.json method which will do all the
319:20 - heavy lifting like for example setting
319:22 - up the proper content type and stringify
319:25 - our data
319:26 - the other flavor we have is server side
319:29 - rendering where we will set up templates
319:32 - and send back entire html and css and
319:36 - javascript ourselves
319:38 - and we're going to do that using
319:40 - res.render method
319:43 - now since i'm a big believer in actual
319:45 - examples over slides if you are a bit
319:48 - iffy on either of these flavors just
319:51 - hold on a bit and once we cover some
319:53 - examples i promise you it will all make
319:55 - sense
319:56 - now why am i telling you all of this you
319:59 - see when it comes to more complex
320:01 - express topics it only makes sense if we
320:04 - cover them properly using one of these
320:07 - flavors instead of just bunch of random
320:10 - examples
320:11 - and the option i picked is the api one
320:14 - so in the following examples we're going
320:17 - to construct api response using more
320:20 - advanced express setups the reason why i
320:23 - picked apr route is because i believe it
320:26 - lets us focus more on the actual express
320:30 - since templates by themselves add a bit
320:32 - more unnecessary overhead especially
320:34 - while we're just starting out with
320:36 - express with that said let me be very
320:38 - clear if you grasp the concepts with api
320:42 - so using the api flavor you'll have no
320:46 - problem implementing them with templates
320:48 - as well since for the most part express
320:51 - concept setup is exactly the same
320:54 - we'll cover server side rendering later
320:56 - in the course so you'll have to wait a
320:58 - bit for the actual example and since
321:00 - we're going to start with api let me
321:02 - just stress the main point one more time
321:05 - and how it looks like in a real world
321:07 - so like i said the main idea with apis
321:11 - is that our server provides data
321:14 - and what that means that any front-end
321:16 - app that wants to access it and use it
321:19 - can simply perform a http request
321:23 - and using our data set up the api and
321:26 - functionality how does that look like in
321:29 - a real world well if you navigate again
321:32 - back to course api and of course not the
321:35 - slides slides are just images but if you
321:39 - take a look at any of these examples
321:42 - you'll notice something interesting
321:44 - where we're sending back the json and
321:46 - you can clearly see that if you go again
321:49 - to your browser's network tab and here
321:53 - again let's refresh
321:55 - and you'll see that this is our response
321:58 - react tabs project so again the full url
322:01 - is course api.com and then react tabs
322:05 - project
322:07 - and if we take a closer look we can see
322:10 - that this is the response that we're
322:12 - sending so we're sending back a
322:15 - json data and i can clearly see that in
322:18 - my headers so in response headers as you
322:21 - can see content type is application json
322:25 - now where is this data used if you took
322:29 - either my react course or the vanilla
322:32 - javascript course you know that in the
322:35 - course
322:36 - we build quite a few projects where we
322:39 - practice data fetching either using
322:42 - vanilla jazz or react and in some
322:45 - examples we use external apis and in sum
322:49 - we use the apis that are here in the
322:52 - course api so for example with this
322:56 - react tabs project if you navigate to
322:59 - react project nutlify.app
323:02 - and keep on scrolling keep on scrolling
323:05 - you'll hit the tabs project and here
323:08 - this is the app that we build
323:11 - using the data so again on a server
323:14 - i set up my data i set up the api and i
323:18 - share the data so i create the http
323:21 - interface and then the frontend app just
323:24 - simply grabs this data and again if you
323:27 - want you can check it out here if you
323:29 - refresh
323:30 - notice this request request goes to
323:33 - course api react tabs project so we grab
323:37 - the data on a front end and then we set
323:40 - up the functionality as well as user
323:43 - interface hopefully this is clear from
323:45 - now on we are going to be responsible
323:48 - for sending back the data so now since
323:51 - we're setting up the server
323:53 - it's not going to be our responsibility
323:55 - to do something with it like we were
323:58 - doing on a front-end in this case we are
324:01 - responsible for setting up the responses
324:04 - so we're going to be setting up apis
324:06 - that our http interfaces to interact
324:09 - with our data
324:11 - not bad not bad i think we clearly
324:14 - covered our two options so one is
324:17 - sending back the json data and the
324:19 - second one is server set
324:21 - so why don't we start by covering the
324:23 - most basic
324:25 - json response
324:27 - and here's what i'm trying to mimic
324:30 - if you go to course api
324:33 - and then if you look for the tours
324:35 - project
324:36 - you'll hook the url of course and here
324:39 - you can see that we're getting back a
324:41 - json data it is an array and each object
324:45 - represents a tor and if you took my
324:48 - react course you know that we were
324:50 - practicing data fetching in react
324:52 - and effectively we hit this url
324:56 - and we got the data we got our json data
324:58 - back and then we built an app
325:01 - using that data
325:03 - but again the whole point here is
325:05 - following where it doesn't have to be
325:07 - react
325:09 - it can be
325:10 - vanilla javascript application it can be
325:13 - swelled framework it can be
325:15 - any setup where you're able to fetch
325:19 - that data
325:20 - so in here on the server we just share
325:23 - the json
325:24 - so in this case of course that is stores
325:27 - and then anywhere
325:29 - anyone who wants to access this data
325:32 - they can just access it and build
325:34 - something using that data and that's why
325:36 - it is so so powerful
325:40 - and
325:41 - essentially this is what we're going to
325:42 - do we're just going to send back first
325:44 - a most basic array and then we'll see
325:48 - how we can make this more dynamic please
325:50 - keep in mind two things first of course
325:53 - eventually we'll use database for that
325:56 - and of course i will mention that
325:57 - probably 20 000 times as we're building
326:00 - these examples
326:01 - and the second thing that i would like
326:03 - you to understand that when it comes to
326:06 - express basics so essentially how we set
326:09 - up the server
326:10 - it doesn't really matter
326:12 - whether we're using server side or
326:14 - whether we're using json again
326:16 - if we understand the principles we'll
326:18 - have no problem
326:20 - using any of those options so first what
326:23 - i would want is to navigate back to my
326:26 - project and again this is going to be
326:28 - the time where i do write everything
326:30 - from scratch but then starting with next
326:33 - example i'll just use some options that
326:37 - we already covered so for now
326:39 - yes i'll remove everything and again
326:41 - we'll set up express
326:43 - one last time so we're gonna go with
326:45 - express require
326:47 - and express okay awesome then const app
326:50 - is equal to require or i'm sorry not
326:52 - require we need to invoke the express
326:56 - like so and then let's go with
326:58 - app.listen
326:59 - port 5000
327:01 - and then let's call our callback
327:03 - function
327:04 - and then let's go again with console.log
327:07 - and server
327:08 - is listening
327:10 - on port
327:12 - on port and of course the port number is
327:16 - 5000. then again i want to set up
327:20 - app.get because that is the http method
327:23 - that all browsers perform by default so
327:26 - i'm going to go with app.get and i'm not
327:29 - going to go with specific path just keep
327:31 - in mind that you can and of course we'll
327:33 - do that later for example i can go here
327:35 - with api
327:36 - and then i don't know i can call this
327:38 - product or whatever for time being let's
327:41 - just make it simple and we'll just
327:43 - handle all the root requests so that way
327:45 - we can save a little bit of typing in
327:47 - the browser and again we have our
327:50 - function our callback function rack and
327:52 - res
327:53 - and as far as the response we're going
327:55 - to go with res
327:57 - and then the method name is json
328:01 - now
328:02 - we will go to the docs just so you
328:04 - understand where i'm getting this
328:06 - information from
328:07 - but before we do that let me just tell
328:10 - you that i might omit here and there the
328:13 - status one just so we can save a little
328:16 - bit of typing but don't worry once we go
328:18 - to some more serious examples of course
328:21 - we'll still use the statuses because in
328:24 - my opinion that is just a better
328:26 - approach where we actually have control
328:28 - over the status
328:30 - and as far as documentation if we go
328:33 - back to express documentation we're
328:34 - looking for api reference again we are
328:37 - using
328:38 - four point something so we are using
328:41 - version four so make sure you look for
328:44 - the same one and don't confuse with
328:46 - express json so this is going to be a
328:49 - middleware that we pass in effectively
328:51 - we're looking for response in a docs and
328:54 - then we're looking for this json option
328:57 - so res object as the json method and
329:02 - what happens we send back the json
329:05 - response and this method sends a
329:07 - response with correct content type that
329:10 - is a parameter converted to a json
329:13 - string using json stringify this
329:16 - parameter can be any json type including
329:19 - object array string and blah blah blah
329:22 - so hopefully you get the gist so the
329:24 - only thing we need to do is go back and
329:26 - for example i'll provide an array where
329:30 - there's going to be two objects and
329:32 - first one will be named john
329:35 - and the second one will be susan so
329:38 - another object
329:39 - and we'll say name
329:41 - is equal to susan and we have our most
329:45 - basic api
329:46 - so if i go back to my localhost 5000 and
329:50 - refresh
329:51 - there it is so now anywhere in the world
329:55 - i can access this data
329:57 - and build something using this data now
329:59 - there's tiny caveat when i say anywhere
330:02 - in the world there's still going to be
330:04 - at the moment a course error and i'll
330:07 - cover that once we actually cover
330:09 - middleware so again please please please
330:11 - please be patient we will get there
330:14 - but hopefully you get the gist where
330:17 - this serves our data and now we can just
330:20 - access that data and build
330:23 - the front-end app using this data now
330:26 - this default setup is nice
330:28 - but of course we can do something more
330:30 - meaningful
330:31 - where
330:32 - if you take a look at the folder you'll
330:35 - notice this data js now what is data.js
330:38 - it is simply a file with some arrays
330:43 - and the first array is going to be
330:45 - products and here as you can see i have
330:48 - objects and then each of these objects
330:50 - represents a
330:52 - single product and all the way in the
330:54 - bottom we're exporting both arrays we're
330:57 - exporting products
330:58 - as well as the people array that we're
331:00 - going to cover a bit later so now what i
331:03 - would want to do is import product array
331:07 - in my address
331:09 - and then instead of hard coding this
331:11 - value like so where i just pass in the
331:14 - array with two objects i'll just dump
331:17 - the whole products data so let's go with
331:20 - const we already know how to do that now
331:23 - since i'm exporting multiple things
331:24 - since i'm exporting an object i will be
331:28 - explicit of what i would want so i'm
331:30 - going to go with
331:31 - product
331:32 - and basically i'm destructing right away
331:34 - i'm going say product is equal to
331:37 - require and remember
331:39 - the file is data js like so
331:43 - and then instead of passing array
331:45 - directly i can simply go with product
331:49 - and what do you know when you navigate
331:52 - to the root there it is now we have more
331:55 - meaningful json response where actually
331:58 - this is a product data so on my front
332:02 - end i can grab it and i can build some
332:05 - kind of nice front end using this data
332:09 - now lastly before we go let me just
332:10 - showcase that of course there's going to
332:13 - be a content type set up correctly as
332:15 - well so if you go to network tab and
332:18 - again if you refresh localhost like so
332:21 - and take a look now of course what is
332:24 - the content type
332:26 - that is application json so now of
332:28 - course we're correctly getting our json
332:31 - data so hopefully you have a clear
332:34 - understanding how to sound json data so
332:38 - now of course let's make things a bit
332:39 - more interesting and cover some more
332:41 - advanced express topics nice once we're
332:44 - familiar with the most basic json setup
332:48 - now let's build a more meaningful api
332:52 - and in a process we'll cover
332:54 - route parameters as well as query string
332:58 - parameters and i would want to start in
333:01 - following way
333:02 - where essentially i'll leave all this
333:05 - code but when it comes to my route when
333:08 - it comes to my home bridge i'll
333:09 - essentially send back the heading 1
333:12 - with the link as well and that link will
333:16 - direct a user to a forward slash api and
333:20 - then product
333:21 - and then later we'll cover the params as
333:24 - well as the query string so let's start
333:27 - with sending back html instead so i'm
333:30 - not going with json one and i'm not
333:32 - gonna send back the file i'll go
333:34 - directly and i'll say send and here we
333:37 - have the string of course so i'm gonna
333:38 - go with heading one
333:40 - and then home
333:42 - page
333:43 - then i'll make sure that i close
333:46 - because i believe in one of the previous
333:47 - videos
333:48 - i believe it was the express
333:51 - basics
333:52 - i think i messed it up here notice i
333:54 - didn't add the closing one so now
333:57 - everything is correct and now i'm gonna
333:59 - go with my link
334:01 - then as far as the href i'm gonna direct
334:03 - a user to api
334:05 - and then forward slash
334:09 - and then of course
334:12 - i'll also set up a text here so products
334:15 - and i'll close my link so that should do
334:18 - it that is my home page and of course if
334:21 - i go to localhost 5000 there it is i
334:24 - have my homepage and once i click the
334:26 - link i navigate to api products now of
334:29 - course the moment i have the
334:32 - default response from the express
334:35 - meaning the default 404 response where
334:39 - the resource cannot be found and as i
334:42 - said note if you want to take a look
334:43 - what response do they send again go to
334:45 - the network this is going to be very
334:47 - very useful tab refresh and take a look
334:50 - at their response so notice the response
334:53 - that's the html that they send back so
334:57 - cannot get and then api products now we
335:00 - already know
335:01 - why there is this get the http verb
335:04 - because that's the method that the
335:06 - browser performs okay awesome so now of
335:08 - course our job
335:10 - is to set up a
335:12 - get request
335:14 - for this resource so we go with app.get
335:18 - and i specifically want to handle api
335:22 - and product so this one just looks a
335:24 - little bit
335:25 - more realistic so in here i go with api
335:28 - and products and keep in mind of course
335:31 - those values need to match otherwise
335:33 - you'll get that 404 again i have my
335:36 - callback function
335:37 - and now of course i would want to send
335:39 - back the product however in this case
335:41 - we'll make it a little bit different
335:43 - where previously
335:44 - notice the product we send back pretty
335:47 - much the whole thing right but
335:49 - a more realistic approach is following
335:52 - where when you're requesting a bunch of
335:55 - data so when you're requesting
335:57 - collection of the data you're not always
335:59 - returning everything for that one
336:02 - specific product and to give you a real
336:05 - world example again i'm gonna go back to
336:07 - my react projects and i'm simply using
336:09 - them because this gives you a visual
336:11 - representation during the course we
336:14 - built a e-commerce and then in the
336:17 - products page notice how we're fetching
336:19 - the products
336:21 - but you need to keep in mind one thing
336:23 - where we're only fetching about the
336:26 - product the title the price the image
336:29 - and i believe also the id and only when
336:32 - i go to that single product page
336:35 - this is where i get the rest of the data
336:37 - whether
336:38 - that is for example a stars the reviews
336:42 - the description
336:44 - the availability and all that stuff so
336:46 - what i'm trying to say is when you're
336:48 - requesting a collection
336:50 - of data there's going to be cases where
336:53 - i simply want to send back some minimal
336:56 - response so for example again that could
336:58 - be name image and the pricing scenario
337:01 - and only if i look for this specific
337:04 - product
337:05 - then i send back everything
337:08 - and in order to mimic that in our
337:10 - example
337:11 - in this response
337:13 - what i'm going to do is i'm just going
337:16 - to iterate over my product i'll use the
337:18 - map method and i'll just remove
337:22 - my description so when i'm sending back
337:25 - the product it's going to be without a
337:27 - description so again if we were to send
337:30 - back everything i would simply go with
337:32 - response json and then i pass in the
337:35 - product so again if we go here and if we
337:38 - refresh now everything is cool
337:40 - i'm getting my product on the api
337:43 - product route however
337:45 - i'm going to make it a bit more
337:47 - realistic and we're going to go with
337:48 - const
337:50 - new product is equal to
337:52 - product dot map so i'm mapping over and
337:55 - i'm creating a new array and i'll
337:57 - reference each item as a product and
338:00 - then as far as the return well first i
338:03 - want to structure the properties out of
338:06 - the product and the reason why i can
338:08 - access them is because those are the
338:11 - names that i used when i'm setting it up
338:13 - so id name image and all that and that
338:17 - is equal to the product again i'm just
338:19 - using simple javascript structuring and
338:22 - then as far as the return whatever i'm
338:24 - going to return
338:25 - from
338:26 - my function
338:27 - well that is going to be the new value
338:29 - so now i'm going to go with id name as
338:32 - well as the image and once i have this
338:34 - setup in place instead of returning
338:36 - product
338:37 - now of course i'm going to go with new
338:39 - products
338:41 - and if i go back to my browser there it
338:44 - is so now i'm getting a collection
338:47 - but i'm not sending
338:49 - everything that i know about this
338:52 - specific item so i'm being selective of
338:54 - what i'm sending back so yes
338:57 - there is a resource by the name of api
338:59 - product and we're sending back the array
339:02 - but we know that if
339:04 - the user
339:06 - wants to access that description he or
339:08 - she will have to look for a specific
339:10 - product and in the process we'll cover
339:13 - what are the url parameters all right so
339:17 - we're successfully sharing a list of
339:20 - items so now of course let's take a look
339:22 - at how we can provide
339:24 - info
339:25 - about that one specific product so for
339:28 - example if i navigate to
339:31 - product and then forward slash and one
339:34 - and then i'm going to get only the info
339:36 - about this first product because it has
339:39 - the id of one
339:41 - and
339:42 - not only i'll get
339:43 - these three properties but also get the
339:46 - description
339:48 - and our initial approach would go
339:50 - something like this
339:52 - where yes i see the product okay
339:54 - beautiful
339:55 - and we already know how to set up the
339:56 - route now since i'll delete it
339:59 - eventually anyway i'm just going to copy
340:01 - and paste so we can speed this up so i'm
340:03 - going to go with api products and then
340:05 - forward slash one
340:06 - that just means that i'm going to be
340:08 - looking for
340:09 - item number one in here
340:12 - and then instead of map we'll use the
340:15 - find method
340:16 - so i'm importing all my products and in
340:18 - order to get the single product
340:21 - i'm going to write the following code
340:23 - where we're going to go with const
340:25 - single
340:27 - product and don't worry we will reuse
340:29 - this code so
340:31 - it's not like we're just randomly typing
340:33 - something so let's go with products and
340:36 - then find now again
340:38 - i'll reference each product
340:40 - with a parameter of product
340:43 - in my callback function and then if the
340:45 - product id
340:47 - product id
340:49 - matches one
340:50 - because that is my route here
340:54 - then of course i'll return that single
340:56 - product so i'm going to say single
340:58 - product and technically this works
341:01 - so notice now of course i have only info
341:05 - about this one specific product and i
341:08 - have the description however it feels
341:10 - like using bazooka on a cockroach yeah
341:14 - it gets the job done but
341:16 - probably is an overkill
341:19 - because keep in mind at the moment we
341:21 - have
341:22 - only four products so yes
341:25 - if i really wanted to i could set up
341:28 - four routes
341:30 - but what if i have hundred two hundred
341:32 - three hundred
341:33 - well that's not gonna work and in
341:35 - express we have something called route
341:37 - parameters which essentially is going to
341:40 - be way better solution
341:42 - so instead of hard coding this 1 2 3 or
341:46 - whatever id we want we set up a route
341:50 - parameter and it's going to look
341:52 - something like this where i go with my
341:54 - route and then i have forward slash and
341:56 - then i go with colon
341:57 - and then
341:59 - whatever name out one so think of this
342:01 - as a placeholder so you can call this
342:04 - bobby lee you can call this chicken
342:06 - burrito in my case i'm gonna go with
342:09 - product
342:10 - and the id
342:12 - just to be explicit
342:14 - of what i'm expecting over here but
342:17 - again
342:18 - naming here is really up to you
342:21 - and what is more important is the fact
342:23 - how we can access it now if you want you
342:26 - can actually console log the request
342:28 - object again this is just going to be a
342:30 - giant object and for now i'm just going
342:32 - to leave this one the way it is
342:34 - so i'm still going to be returning a
342:37 - product number one and also let's look
342:40 - for
342:40 - request
342:42 - and then we're looking for the params
342:45 - property so let me count to lock this
342:47 - one and then again once i navigate back
342:50 - and if i refresh in the api products
342:54 - number one
342:55 - what you'll notice again this giant
342:57 - request object where we have bunch of
343:00 - useful properties and methods
343:02 - and of course i'm not going to cover all
343:04 - of them right now but similar to http of
343:07 - course in the express we also have
343:11 - access to bunch of useful things in that
343:14 - request object and one of them is the
343:17 - params so check it out now i have this
343:21 - product id and the value is one now
343:24 - please keep in mind one thing that
343:26 - whatever you're going to be setting up
343:28 - here in the url as that route parameter
343:33 - is always going to come back as a string
343:36 - and this is important in this case
343:38 - because if you take a look at our data
343:41 - the id is a number and of course we'll
343:44 - deal with that in a second
343:46 - and whatever we set up as far as our
343:50 - name
343:51 - is going to be right in here it's going
343:52 - to be in this request and then
343:55 - parameters object so now of course what
343:57 - i could do
343:58 - is i could just destructure it from the
344:01 - params
344:02 - and then use it in order to find that
344:05 - specific product so that way i don't
344:07 - have to hard code products number one
344:10 - product number two and on and on and on
344:13 - instead i just set up my route parameter
344:16 - and just come up with whatever name i
344:18 - would want
344:19 - just make sure that you add this colon
344:20 - here
344:21 - and then we'll access that value and get
344:24 - a specific product so i'll leave these
344:27 - two suckers for your reference
344:29 - just in case you would ever
344:31 - want to console log them and we'll
344:34 - simply go with const and the name is
344:36 - product id
344:38 - and that is equal to request
344:41 - that's my request object and params
344:44 - then i'm going to use this product id to
344:47 - get my product but remember
344:51 - it is a string we can clearly see that
344:54 - and in fact here in the array
344:57 - well the ids are numbers so if we'll
345:00 - just try to search it the way it is
345:02 - of course we won't be able to get our
345:04 - product so instead what we want is pass
345:07 - in the number
345:08 - and then product id now of course if
345:12 - your ids are set up as strings
345:15 - which is
345:16 - somewhat typical setup for the databases
345:19 - and all that
345:20 - as well as the headless cms is then of
345:22 - course you don't need to worry about it
345:23 - then you can just pass in the string and
345:26 - now of course i'm going to be able to
345:29 - get my one product so now if i go back
345:33 - and if i refresh
345:35 - everything still works and if i go to my
345:39 - url and start changing these values
345:41 - hopefully you can see that now of course
345:43 - i'm getting a different product now i'm
345:46 - getting product number two and i go to
345:48 - product number three and on and on and
345:50 - on so now with these few simple lines of
345:53 - code
345:54 - i can access any product in my array now
345:58 - of course there's also a case where we
346:00 - cannot find the product because keep in
346:03 - mind here i can type whatever i would
346:04 - want so i can go with products and then
346:07 - let's imagine that the user types abc
346:11 - now do we have a product with an id of
346:14 - abc
346:15 - of course the answer is no so what's
346:17 - happening over here now i don't get
346:19 - anything back right well i don't get
346:21 - anything back because if i go to log and
346:24 - then
346:25 - single product let's see what we're
346:28 - going to get back again let me refresh
346:30 - abc and this one is undefined so that's
346:33 - what we're sending back as a single
346:36 - product so what would be a solution well
346:39 - a solution is setting up a if statement
346:42 - here
346:43 - where i say get me the single product if
346:46 - you cannot find that single product if
346:48 - basically that product doesn't exist if
346:51 - the id
346:52 - that the user passed in does not make
346:55 - sense
346:56 - you cannot find the product with that id
346:58 - then return 404 so how's that going to
347:02 - look like well we can go here if and
347:05 - then single product so we set up a if
347:08 - condition and of course i'm going to go
347:10 - with if single product doesn't exist so
347:13 - i'm going to add exclamation point and
347:15 - of course this is going to be our case
347:17 - with undefined
347:18 - this will be true if it is undefined and
347:21 - then we just go with a return
347:23 - res and in this case i will add a status
347:26 - because that is extremely important that
347:28 - i go with 404 and then we go with send
347:32 - and product
347:34 - does not
347:35 - does not
347:37 - exist like so
347:39 - now if everything is correct then of
347:41 - course we go with res
347:43 - and json so in here i say return
347:46 - and res dot json so once i go right now
347:51 - to product and then abc
347:53 - there it is now of course i have proper
347:55 - 404
347:56 - product does not exist and if i again
347:59 - take a look at the tab
348:00 - and i have my abc now if i'm going to
348:04 - navigate to a route where i can find the
348:07 - product then of course i'm going to get
348:10 - my proper product response so whenever
348:13 - you think of route parameters think of
348:16 - them as placeholders where user provides
348:19 - a data and then using requests and
348:23 - params we can access that data and then
348:26 - set up some kind of logic
348:28 - and before we continue and cover query
348:30 - string parameters let me just mention
348:33 - that route parameters can get way more
348:36 - complex than this so for example imagine
348:39 - this scenario i can go with app.get
348:42 - again i need to come up with some kind
348:45 - of routes i'm going to go with api
348:48 - then products so i'm looking for
348:50 - specific products so i'm going to use a
348:52 - route parameter let's call this product
348:55 - id
348:56 - then i'm going to look for all the
348:58 - reviews and then maybe there's a review
349:02 - id
349:02 - so review
349:04 - and then id and now of course again i
349:06 - have rec and res like so and then i'm
349:10 - simply going to send back some kind of
349:12 - dummy data but i would want to console
349:15 - log the rec params just so you
349:18 - understand how everything works and now
349:20 - let me send
349:22 - res.send so res
349:24 - not send and i'm just going to say
349:26 - simple hello world let's save this one
349:31 - and again in the browser let's go here
349:33 - we have products again some kind of id
349:36 - whether that's abc whether that is a
349:39 - number in this case it doesn't really
349:41 - matter since you can see that there's
349:43 - not much functionality in there but we
349:46 - need to type in here reviews and then
349:48 - for example the review id would be i
349:51 - don't know abc so once i navigate here
349:54 - of course i'm going to get my hello
349:56 - world and then in the console notice how
349:59 - i'm accessing all of them so i have the
350:01 - product id as well as the review id so
350:05 - again they can get way more complex than
350:08 - just this simple approach and one more
350:12 - thing i would like to mention this
350:13 - reviews though is hard coded
350:16 - so if i go back i can change the abc and
350:20 - 4 however i would like but if i'll
350:23 - change
350:24 - from reviews to review
350:26 - i'm going to get a 404 why well because
350:30 - review is not a route parameter so
350:32 - that's not a placeholder
350:34 - so if
350:36 - this is incorrect then of course i get
350:38 - d404 hopefully that is clear and now
350:41 - let's talk about the query string
350:43 - parameters
350:44 - all right and once we're familiar with
350:46 - rot parameters let's talk about the
350:49 - query string parameters or they're also
350:51 - called url parameters
350:54 - and essentially that is a way for us to
350:57 - send small amounts of information to the
351:00 - server
351:01 - using the url
351:03 - now this information is usually used as
351:06 - parameters to for example query database
351:09 - or filter results and that's really up
351:11 - to the people who are setting up the
351:13 - server they decide what parameters are
351:16 - going to be accepted
351:18 - and what functionality will depend on
351:21 - those values and to give you a real
351:24 - world example let me go to my search
351:28 - engine and i'm just looking for hacker
351:30 - news algolia api
351:32 - so when you're working on a front-end
351:34 - app i'm not sure whether you worked with
351:36 - this api but that is a very cool api and
351:40 - essentially it's going to work as a good
351:43 - example of how we should be setting up
351:45 - the server and this is as a side note
351:47 - but
351:48 - notice the url here
351:51 - so they go with a domain which in our
351:54 - case is of course localhost 5000 but
351:57 - here it is actually a algolia domain so
352:00 - algolia.com
352:02 - forward slash api like i said that is a
352:05 - pretty common practice
352:07 - then a version number and then whatever
352:10 - list you're getting so in here it is
352:13 - items now check out this one
352:16 - doesn't that ring a bell
352:18 - of course that is a route parameter
352:20 - where they say yeah here's the list of
352:23 - items
352:24 - but if you want to be more specific
352:26 - please provide the id
352:29 - and then if you keep on scrolling you'll
352:31 - notice the same thing with the users
352:33 - again we have the main domain
352:36 - api version one users that's the list
352:40 - and then if you want to get a specific
352:42 - one then of course again there is a
352:44 - route parameter now this is just to
352:46 - showcase that i'm not randomly coming up
352:49 - with those things no that's how actually
352:52 - the servers work in real world and let's
352:56 - keep on scrolling and now we come to
352:58 - this interesting part
353:00 - where we can sort
353:01 - so
353:02 - we're getting the data from the algolia
353:05 - api
353:06 - but then in my app
353:08 - i can sort i can say hey you know what
353:11 - get me specific hacker news story or get
353:15 - me stories based on some kind of search
353:18 - term and hopefully you get the gist
353:20 - where instead of just grabbing the whole
353:22 - thing
353:23 - i can say you know what
353:25 - get me all the stories that match
353:28 - through so again we go with the url and
353:31 - this is really up to you how you set
353:32 - this up in their case they use search
353:35 - and then
353:36 - here we have this question mark
353:38 - and whatever is after this question mark
353:42 - is not technically part of this url
353:44 - meaning
353:45 - it's just a way for us to send that data
353:47 - to the server and then server decides
353:50 - what to do with this data
353:52 - so the url is still this one
353:54 - the one that ends with search and then
353:56 - we have a question mark and basically
353:59 - this is just a specific info
354:02 - about the data that i'm requesting so
354:05 - here the user adds a query parameter and
354:09 - then the value is full and then also has
354:13 - tags of story and that means that we're
354:15 - going to get all the stories matching
354:17 - full now what else you could set up here
354:19 - in a query string pretty much anything a
354:22 - pretty typical is going to be page for
354:24 - example if you have a list of things and
354:27 - i don't want to get 100 items at a time
354:30 - i can say you know what split it up in
354:32 - pages and get me initially page number
354:34 - one and then only if the user clicks on
354:37 - a button that fetches the page number
354:39 - two then i get the second page then for
354:42 - example in here they have hits per page
354:44 - so that is going to be how many items
354:46 - per page so again
354:48 - after that question mark if the setup is
354:51 - supported by the server
354:53 - then of course you can add those key
354:55 - value pairs and the way we add them as
354:58 - you can see is by using key value pairs
355:00 - so we have question mark and then we
355:03 - have a key
355:04 - which in this case is query and then the
355:06 - value now
355:08 - before we continue let me make something
355:10 - very very clear it's not like you can
355:12 - randomly search the web and just start
355:15 - adding these query string parameters and
355:18 - then expect
355:19 - that as a miracle you'll just get the
355:21 - data that you're looking for a as far as
355:24 - the keys
355:26 - they're designed on a server so if i'll
355:28 - set up a key of chocolate milkshake
355:30 - algolia api is going to be like i don't
355:33 - know what you're talking about and the
355:34 - same goes for the value so where i'm
355:36 - going with this now we are in charge of
355:39 - that server so it's up to us to handle
355:42 - those query string parameters
355:45 - and i'm going to go back to our project
355:47 - and i'll purposely set up a new route
355:50 - please keep in mind one thing where a
355:52 - pretty typical setup
355:54 - is adding this to the list
355:57 - so again we'll look for specific
356:00 - property on our request object and then
356:02 - if that property is provided then of
356:05 - course we return a more detailed
356:09 - response meaning there's maybe some
356:11 - filtering or something like that but if
356:12 - not then we'll send back all the
356:14 - products now i'll purposely set up a new
356:16 - route just so we don't jam all our code
356:20 - in this one route but then
356:23 - in the next video probably i'll show you
356:26 - how we can combine both routes so let's
356:28 - keep on scrolling so this is going to be
356:30 - our more complex
356:32 - params example and let's go with app.get
356:37 - and again
356:38 - the route is really up to you i'm going
356:40 - to go with api now in order to make it
356:42 - interesting i'm going to add that
356:43 - version 1 just like the api of algolia
356:47 - has it and then i'll say query now i
356:50 - don't need to add question marks nothing
356:52 - like that i just set up query that is my
356:55 - route and then i have my callback
356:56 - function rack and res
356:59 - now in this callback function in order
357:01 - to access those query string parameters
357:04 - i need to go with rec and query so let's
357:07 - go with console.log and we're going to
357:09 - look for
357:10 - request
357:11 - and not params sorry we're going to go
357:14 - with query over here and again let's go
357:17 - with simple hello world just so we can
357:19 - speed this up and then if i go to the
357:23 - local host
357:24 - and more specifically
357:26 - i'm going to look for
357:28 - localhost then 5000 then api then
357:33 - version number one
357:34 - and then query and then if i add this
357:37 - question mark i can add as many query
357:41 - string parameters as i would like so
357:43 - here i'm going to go with the name that
357:45 - will be equal to john
357:47 - then in order to combine them we just
357:50 - add this ampersand so we're going to go
357:52 - with name john and then id4 just keep in
357:55 - mind that you can add as many query
357:57 - string parameters as you'd want and then
358:00 - once i navigate there at the moment i'm
358:02 - just going to get the hello world
358:04 - so that's my default response from this
358:07 - url
358:08 - but in a terminal notice i have name
358:10 - john and id number four again this is a
358:13 - string and this is going to be important
358:16 - in a second but what this allows us to
358:19 - do is access those parameters and then
358:22 - based on them do some kind of
358:24 - functionality now first of all i would
358:25 - want to change this around a little bit
358:27 - where i'm not going to be looking for
358:28 - name or id i'm going to be looking for
358:31 - search query parameter as well as the
358:34 - limit so if the user wants to search for
358:37 - a specific product he or she needs to
358:39 - provide that search query parameter as
358:42 - well as limiting
358:44 - where the user can limit of how many
358:46 - products they are getting back so let me
358:49 - navigate back and just to showcase that
358:51 - so again instead of name i will zoom in
358:55 - we'll say search
358:57 - is equal and then whatever i would want
359:00 - so in this case i'm just going to go
359:01 - with a so effectively this will return
359:04 - all the products that start with a and
359:06 - then the second one is the what that was
359:10 - the limit right so i'm gonna say limit
359:13 - and
359:14 - for now let's just go with two of them
359:16 - so this will return two products
359:19 - i'll zoom out and again i have search
359:22 - and i have limit after you so now of
359:25 - course let's set up that functionality
359:27 - and we'll simply start by creating new
359:30 - instance of those products i'm gonna go
359:32 - with let and you'll see in a second why
359:34 - so say sorted
359:36 - product
359:37 - and in here we'll use the spread
359:39 - operator so we imported the product
359:42 - and now i'm just going to copy the
359:44 - values so this is going to be my new
359:46 - array and the reason why i'm using let
359:48 - because
359:49 - we will modify
359:51 - this value a bit now instead of just
359:54 - cancel logging the query i'll comment
359:56 - this out and we'll set it up as const
359:59 - and then again i'm looking for two
360:02 - specific keys i'm looking for the search
360:04 - and i'm looking for the limit so if the
360:06 - user doesn't provide them
360:08 - well then we'll send back all the
360:10 - product
360:11 - so we're gonna go
360:13 - with query
360:14 - like so so i can see the search and
360:17 - limit beautiful
360:18 - and now
360:19 - instead of just sending back hello world
360:21 - i'm going to check
360:23 - if
360:24 - the search
360:25 - is in my query string parameters then i
360:28 - would want to filter my product so i'm
360:30 - going to say if and then search like so
360:34 - and we're going to go with sorted
360:35 - products since i'm using let i can do
360:37 - that i'm going to go with sorted product
360:40 - and then filter method again
360:42 - straight up javascript again i'll call
360:45 - this a product
360:47 - like so and what i would want to return
360:50 - are the products that start with the
360:53 - value of my search term so here i can
360:57 - say return
360:58 - product
360:59 - and name so if the product name starts
361:02 - with now again this is straight up
361:04 - javascript
361:05 - and i'll pass in the search if that is
361:07 - the case that is going to be my value in
361:10 - stored product and i can right away
361:12 - check for the limit as well
361:14 - where i'm going to say if
361:16 - and then limit
361:18 - and if it exists
361:20 - so if the user has provided it again
361:22 - let's go with sort product
361:24 - and filter more and in this case i'm
361:27 - going to use the slice method where i'm
361:29 - just going to get specific items from
361:31 - the array so i'm going to start with 0
361:34 - and then remember we're getting a string
361:36 - so we need to go with number and then
361:38 - again we'll pass in the limit let's go
361:41 - here below both of them and let's just
361:44 - say res dot and then status and we're
361:47 - going to go with 200 like so and then a
361:51 - json response
361:52 - now when it comes to json response we're
361:56 - just gonna go with our sword product
361:58 - right so we go back
362:00 - and let me just showcase something where
362:02 - if
362:03 - none of the query string parameters are
362:05 - provided i'm gonna send back my whole
362:08 - data why well because i copied my
362:11 - products right both of them were false
362:14 - both of them were undefined
362:16 - and as a side note there is a error here
362:20 - cannot send headers and i'll talk about
362:22 - it actually in a second that is one of
362:24 - my
362:25 - next topics so let me just deal with
362:28 - this hello world by deleting it and
362:31 - we're going to be in good shape but i'll
362:33 - cover why we got this error and what
362:36 - gotchas you should be aware of so let me
362:38 - go back again
362:39 - let's see again we're getting all the
362:41 - products because the user did not
362:44 - provide
362:45 - that specific query string parameter so
362:48 - if we right now navigate to the url
362:51 - and i'm gonna start with a limit and if
362:53 - in the limit i'm gonna say that i'm only
362:55 - interested in two products
362:57 - check it out now of course my limit is
362:59 - two so i only have two products and if
363:02 - it's three then it's gonna be three and
363:04 - then four and hopefully you get the gist
363:07 - where whatever value i provide here in a
363:11 - limit well i have the functionality for
363:13 - it now keep in mind again name needs to
363:16 - match if this is going to be limi
363:18 - instead of limit again i'm just going to
363:20 - get back all the products regardless of
363:23 - what is my value and the same goes for
363:26 - the value of the query string parameter
363:29 - if this is limit but for example i
363:31 - decide to pass in abc
363:34 - nothing i get empty array why because my
363:37 - value wasn't what my functionality was
363:40 - looking for and similarly of course we
363:43 - can add the search option as well and
363:45 - i'm purposely showing them one by one so
363:47 - you don't get confused so let's say
363:50 - search
363:51 - and again the functionality is set up
363:53 - where you need to provide a starting
363:56 - character so in my case i'm looking only
363:58 - for the products that start with a and
364:01 - there it is i have two of them now if i
364:04 - want a limit i can just add and here
364:07 - and let's just type limit and i'm only
364:09 - going to be looking for one product and
364:11 - if i add this limit one
364:13 - there it is now i only get one product
364:17 - now there's also obviously going to be
364:18 - the case where we return empty array
364:22 - why well because
364:24 - i could go with search and look for the
364:27 - products of b
364:28 - and unfortunately when it comes to my
364:31 - product data i don't have products that
364:34 - start with b so we can handle that
364:37 - instead of sending back empty array i
364:39 - could check what is the length of my
364:42 - array and if for example it is less than
364:45 - one then i explicitly send back the
364:48 - response where i say yes the request was
364:51 - successful
364:53 - but i couldn't return any product so we
364:55 - can go with if and then sorted product
364:59 - if the length
365:00 - of this array
365:02 - is less than one
365:04 - if it is less than one then of course i
365:07 - can just go with res dot status now this
365:11 - is one gotcha where
365:12 - you're not sending back the 404 you're
365:15 - not saying the url doesn't exist or the
365:17 - resource doesn't exist
365:19 - in this case you're trying to
365:22 - filter the product but
365:24 - nothing came back so
365:27 - whatever query string parameters were
365:29 - provided they didn't yield any results
365:32 - so you're simply saying status and then
365:34 - you can go with send and we can go with
365:37 - no products
365:39 - products matched
365:41 - your
365:42 - search like so so we can go here and
365:45 - then if we refresh again with the same
365:47 - ones we have no product match your
365:50 - search so that is one option you can
365:51 - send back the string but
365:54 - a more common one is this one where i'm
365:57 - going to comment this out for your
365:58 - reference again and instead you go with
366:01 - return
366:02 - and you're going to go with res dot
366:05 - status and again we have this error in
366:08 - the
366:09 - server and again i'll talk about it in
366:12 - the next video why we have that one so
366:14 - we're going to go with res dot status
366:17 - and we pass in the 200 and instead we
366:20 - send back the json one and in that json
366:23 - again you can pass the string if you
366:25 - want but a more common approach is
366:28 - setting up the object where you
366:30 - explicitly say that the request was
366:33 - successful or a failure so you go with
366:36 - success and that is equal to true and
366:39 - then again you come up with whatever
366:41 - name you would want a generic one is
366:44 - data and then you send back the array
366:47 - again you are in charge here you can
366:49 - really do whatever you want i'm just
366:51 - showing you
366:52 - a pretty common
366:54 - approaches to the situation so again i'm
366:57 - looking for some kind of product
366:59 - using my query string parameter now
367:01 - unfortunately server can return
367:04 - any data meaning
367:06 - any product and then of course i just
367:09 - get this success true because the
367:11 - request was successful there was nothing
367:13 - wrong with my url however
367:16 - i'm just yielding a empty data so that's
367:20 - it i can just delete it and if i don't
367:23 - provide anything then i'm going to get
367:25 - all the products hopefully that is clear
367:27 - how the query string parameters work and
367:30 - now we can cover a few gotchas all right
367:33 - and two things that i would like to
367:35 - emphasize are following first
367:37 - remember those errors that we're getting
367:39 - in a server when we're setting up if
367:42 - conditions
367:43 - in javascript if we don't explicitly
367:47 - return
367:49 - then of course javascript just keeps
367:50 - reading the code correct so if i'm going
367:54 - to omit that return i'm actually going
367:56 - to get the server error where i send
367:59 - back one response and then javascript
368:02 - just keeps reading the code and then
368:04 - express is confused express is like hey
368:06 - wait a minute i already sent back the
368:08 - response so while you're sending another
368:10 - now keep in mind that it is happening in
368:13 - the same request so you cannot send
368:15 - basically two responses in the same
368:18 - request one after the another yeah of
368:21 - course you can send one based on the
368:23 - condition so for example if there are no
368:26 - products you send back one response
368:28 - and if you can yield some product then
368:30 - great then you send the second one but
368:32 - you cannot send both of them
368:35 - one after another in the same request
368:38 - and if you want to see that error again
368:40 - in action go to the query you'll add a
368:44 - question mark here
368:45 - and we're going to go with search and
368:48 - again it is equal to b for example that
368:51 - is my value that's the starting value
368:53 - that i'm looking for and once i do that
368:55 - notice yeah i'm getting back the success
368:58 - true and data but again i have this big
369:00 - fat error in my server and it says
369:04 - cannot set headers after they are sent
369:06 - to the client
369:08 - so we can have only one response per
369:11 - request
369:12 - and in order to avoid that we just go
369:14 - with return so always always when you're
369:16 - setting up the condition make sure that
369:18 - you go with return so that way we are
369:20 - returning from our callback function and
369:23 - one we set up over here and that way
369:25 - you'll avoid those errors now of course
369:28 - in this case there's no more code to
369:30 - read so
369:32 - yeah it is a better practice if you just
369:34 - put this return here but you won't get
369:36 - the error since again there's nothing
369:38 - after that and one more thing that i
369:40 - would like to mention
369:42 - normally you're not going to set up a
369:45 - separate one just for the query yeah
369:48 - there might be some cases maybe there's
369:50 - some apis who do that but normally again
369:53 - you can just add it to where you're
369:55 - getting a list
369:56 - so basically if
369:59 - there's a query beautiful you're maybe
370:01 - gonna sort that data you're gonna filter
370:04 - it you're gonna i don't know set up some
370:06 - pages or whatever and if
370:09 - no query string parameters are there
370:12 - then you send back the whole product and
370:15 - if you take a look
370:16 - pretty much nothing stops me here from
370:19 - just changing this to api and products
370:22 - and the functionality is going to work
370:24 - where if
370:26 - there are some query string parameters
370:28 - present beautiful
370:30 - notice how we're filtering
370:32 - our product if not then i always send
370:35 - back these products anyway and as you
370:38 - can see those are just copies of the
370:41 - products that are coming from my data js
370:44 - hopefully that is clear and now let's
370:46 - move on to our next topic
370:48 - nice and once we're familiar with route
370:51 - params and query string let's really
370:54 - kick things into gear and talk about
370:56 - middleware in express.js
370:58 - express middleware are functions that
371:01 - execute during the request to the server
371:05 - each middleware function has access to
371:07 - request and response objects
371:10 - and when it comes to functionality
371:12 - literally sky is the limit in order to
371:15 - hammer this home i have prepared quite a
371:17 - few examples where we cover middleware
371:19 - step by step since in my opinion actual
371:22 - code examples are far more helpful than
371:24 - text based explanations before we
371:27 - continue though let me just stress
371:28 - something middleware is literally
371:31 - everywhere in express
371:33 - you can even make an argument that
371:34 - express apps are nothing but a bunch of
371:37 - middleware functions stuffed together to
371:40 - make one nice express cake or dessert if
371:44 - you are in that sort of thing
371:46 - and since that is the case middleware is
371:48 - not one of those topics you can just
371:50 - skip or avoid
371:52 - it is at the heart and soul of express
371:54 - so please don't dismiss it with that
371:57 - said since you'll encounter it more than
371:59 - once if you struggle with it in the
372:01 - beginning don't panic the more examples
372:03 - you'll do the better you will understand
372:06 - it now let me start by cleaning out my
372:09 - app.js and this is going to be the case
372:12 - where i will leave
372:14 - the code at least some of the code from
372:17 - the previous lecture so let me delete
372:20 - all the middle part and i'm just going
372:22 - to leave express we are instantiating
372:25 - our app and we're listening on port 5000
372:29 - and let's just start by adding a comment
372:32 - here
372:33 - for your reference so there is a
372:35 - incoming request
372:36 - and so far we have been just sending
372:39 - responses right
372:40 - so what middleware does
372:43 - it sits in between
372:45 - hence the name so middle where over here
372:48 - and then we pass the response so the
372:52 - request comes in we'll do something so
372:56 - we'll have access to the both to the
372:57 - request and response we'll do some kind
372:59 - of functionality again the most basic
373:02 - you can just cancel log something
373:04 - and then we'll send out the response and
373:07 - again i know it probably looks confusing
373:10 - at the moment but trust me the more
373:12 - examples you'll do the better you'll
373:14 - understand
373:15 - and let's start by simple scenario where
373:18 - i have two routes i have the home route
373:21 - and i have the about route
373:23 - and in those routes i would just want to
373:26 - log
373:27 - the method that the user is using the
373:30 - url that the user is trying to access
373:33 - and for example a date
373:35 - and if you think that's silly there's
373:37 - actually npm packages that do that
373:38 - because
373:40 - as your express apps grow bigger and
373:43 - bigger it is very useful to see those
373:46 - incoming requests in that manner so
373:50 - let's start here by setting up add.get
373:52 - again this is going to be my home page
373:55 - and for time being i have my callback
373:57 - function i pass it in and i just go with
374:00 - the res dot send
374:02 - and i send back the home and i'll do the
374:05 - same thing here with my about
374:08 - so there's going to be two routes at the
374:10 - moment home and about unless it's just
374:13 - going to say about so i'll save it and
374:16 - it's not going to be surprised if i
374:18 - navigate to localhost 5000 if i refresh
374:21 - this is my home
374:23 - and this is my about again something we
374:25 - have covered already before now here's
374:29 - the kicker
374:30 - if i go with logger
374:32 - and if i set up that functionality in
374:36 - the route forward homepage i'll also
374:38 - have to do that in the about so let me
374:41 - showcase that so i have request object
374:44 - and in there i have method i have url
374:47 - and i'll simply set up the year because
374:48 - i don't want to deal with javascript
374:50 - types so let's go with method now that
374:52 - one was on request
374:54 - dot method property then we also have
374:57 - the url so url here and that is going to
375:00 - be a request url property
375:03 - like so and then like i said i'm going
375:05 - to go with const and i'll name this time
375:08 - but in order to make it easier i'm
375:10 - actually going to get a full year so i'm
375:12 - going to go with new date and i'll
375:14 - invoke it and i'll say get full year and
375:17 - invoke it as well
375:19 - and of course i'm sending back home yeah
375:22 - that is nice but before i do anything i
375:25 - would also want to
375:26 - cancel console.log all three of them so
375:28 - method url
375:30 - as well as the time like so so i save it
375:34 - and now every time
375:36 - user is gonna hit this resource of
375:38 - course i'll see that in a console log so
375:41 - there it is if i go back to my home page
375:45 - like so and if i refresh quite a few
375:48 - times
375:49 - there it is now in a console i can see
375:51 - that the method was get so the user was
375:54 - trying to get the resource and then the
375:57 - path was the homepage that's my url and
376:00 - then the year is 2021. okay awesome
376:04 - but here's the problem if i want to have
376:07 - the same functionality
376:09 - in about what do i need to do right now
376:12 - well again i need to copy and paste
376:14 - now if i have 15 routes does that sound
376:18 - like a reasonable approach of course the
376:20 - answer is no
376:22 - a better solution would be if we set up
376:24 - a function
376:26 - and in that function we have all this
376:28 - logic and then i can just attach it
376:31 - really nearly to all my routes and when
376:33 - i say well in italy it just just means
376:35 - that for some routes i maybe want to
376:37 - attach it and for some maybe i don't
376:40 - so here's the deal i can go above both
376:44 - of my routes and i can just simply say
376:47 - that there's going to be a function by
376:49 - the name of
376:51 - and for time being we're not going to
376:53 - look for any parameters but yes there
376:55 - will be there
376:57 - and then we just take
376:59 - all our i believe four lines of code
377:01 - right and we just cut it out and pass it
377:05 - here okay awesome and now of course
377:08 - where do we attach this function so we
377:11 - don't have to duplicate our code
377:13 - and the place is following where we have
377:15 - the path and then we have the callback
377:17 - function now in between them we can
377:20 - stuck a middleware so in this case as
377:23 - you can see i'm referencing the function
377:26 - please keep that in mind so i'm going to
377:27 - go with logger that's my middleware
377:30 - function
377:31 - but now there's the second question well
377:34 - in the logger i'm accessing request
377:38 - object right so
377:41 - how can i do that
377:42 - because at the moment i'm not passing it
377:44 - in well the good news is that express
377:48 - passes it in to our middleware function
377:51 - so in here i just set up the reference
377:53 - for my function and express will do that
377:56 - behind the scenes it will supply the rec
378:00 - res and also a next and you'll see in a
378:03 - second why we need this next function as
378:07 - well so again
378:09 - we don't have to do anything we just
378:10 - pass here the middleware express
378:12 - supplies them but of course it's our job
378:15 - to access them as parameters and then
378:18 - set up our logic so for them being i'm
378:21 - not going to do anything with next i
378:23 - will save
378:24 - and we should see something where in the
378:27 - console i'm still going to get my log
378:30 - but the problem is going to be in the
378:32 - browser so if i navigate back and if i
378:35 - refresh
378:36 - notice something where i have this
378:38 - spinner
378:40 - okay
378:41 - so what's happening here well i
378:43 - successfully logged
378:45 - but i didn't pass it on to the next
378:48 - middleware so here's the deal when you
378:50 - work with middleware you must must must
378:53 - must must pass it on to a next
378:56 - middleware unless you're terminating the
378:59 - whole cycle by sending back the response
379:01 - and don't worry there's going to be
379:02 - examples where we do that as well so for
379:05 - now just keep in mind that when you have
379:07 - a middleware
379:09 - where you set up some kind of logic
379:11 - unless you're sending back to response
379:13 - yourself for example since i have access
379:16 - to response i simply can go with res dot
379:20 - and send and again i'm going to come up
379:23 - with testing or whatever it doesn't
379:24 - really matter what we send back if we
379:27 - refresh notice it doesn't really matter
379:29 - if i try to access the home page since i
379:32 - have my middleware i'm actually sending
379:34 - back the testing and this is why the
379:36 - middleware is so so
379:38 - powerful because you can literally do
379:40 - whatever you want over here you can set
379:42 - up all kinds of cool logic
379:44 - and you have two options either you pass
379:47 - it on to the
379:49 - next middleware which in our case of
379:51 - course
379:52 - are going to be our methods our get
379:54 - methods or
379:56 - you simply terminate the whole cycle and
379:58 - you just say res dot send and i'm
380:00 - sending back my own data so let's not be
380:03 - brutal over here i will actually remove
380:07 - this line of code
380:08 - and if
380:09 - i want to pass it on to the next
380:13 - function meaning in our case that is
380:15 - going to be my method app.get i simply
380:18 - go with next and we have to invoke it
380:21 - again please keep that in mind there's
380:23 - going to be more functionality later in
380:25 - these middleware functions but you
380:27 - always always
380:28 - either you terminate
380:30 - so either you send back your own
380:32 - response or you pass it on to the next
380:35 - middleware that is very crucial so now
380:38 - if i go again to my homepage
380:40 - there it is i successfully navigate to
380:43 - my homepage i can clearly see that that
380:45 - is my response and i also successfully
380:48 - logged in my console
380:50 - the method the url as well as the full
380:53 - year and now of course instead of adding
380:56 - this logic line by line to every request
381:00 - simply can go and i say yep i would like
381:04 - to invoke the logger here as well so if
381:08 - we go to logo host 5000 and if we're
381:11 - brave enough and we navigate to about
381:14 - there it is now i have get request about
381:18 - url as well as the full year hopefully
381:22 - that gives you a good initial
381:24 - understanding how the middle works
381:27 - and now i can talk about more
381:29 - complicated topics beautiful we are
381:32 - familiar with the middleware we have our
381:35 - first middleware function
381:38 - but there are two issues with this
381:40 - current setup first
381:42 - our appdress is getting somewhat clunky
381:45 - because
381:46 - i mean we have this logger then we have
381:48 - the methods
381:49 - it's definitely nicer if we have this
381:52 - logger function in a separate file
381:55 - it's just going to keep our app.js lean
381:58 - and in turn it's just going to make it
382:00 - easier for us to navigate and
382:03 - essentially work with our application
382:06 - and the second issue what if i have 50
382:09 - more routes
382:11 - and i don't want to add this function
382:13 - manually to all of them
382:15 - wouldn't be nicer if there would be a
382:18 - method that essentially just adds my
382:20 - middleware function to any route and of
382:23 - course the answer is yes there is such a
382:26 - function in fact we used it a few videos
382:28 - ago now let's start though by moving
382:31 - this sucker into a separate file
382:35 - so i'm gonna go to my not navbar app
382:38 - sorry
382:39 - this is what happens when you have a
382:41 - bunch of
382:43 - projects open meaning a bunch of folders
382:45 - open let me go here where i have my
382:47 - app.js
382:49 - and i'm just going to
382:51 - create a new file
382:53 - and this is still going to create it in
382:54 - the final sorry so let me go here and
382:57 - i'll create a new file and i'll call
382:59 - this logger
383:01 - js now if you really want you can add
383:03 - the middleware there in name as well but
383:06 - in my case i'm just going to add
383:08 - the name of my function
383:10 - then i'll cut it out
383:12 - and what's really cool that we know how
383:14 - to export this right so we have cons
383:17 - logger and then we go with module
383:19 - exports and we'll just set it equal to
383:22 - our logger so now we have default export
383:25 - that's our logger so of course in the
383:28 - app js i simply need to go with const
383:30 - logger is equal
383:32 - and then i require it i go with logger
383:37 - and if i navigate to localhost 5000
383:41 - i still should see in a console my log
383:44 - and if you do then everything is correct
383:48 - so that's the first part
383:50 - now the second how can i apply this
383:52 - logger
383:53 - to all my routes
383:56 - so for example
383:58 - let me just copy and paste these ones
384:01 - and i'll say api
384:03 - and then
384:04 - product
384:06 - and then api
384:08 - and i don't know not about maybe items
384:12 - again doesn't really matter what you
384:13 - place here i'm gonna go with products
384:16 - as well as items
384:19 - again i can add them manually but the
384:22 - more routes i'm going to have
384:24 - well the bigger issue this is going to
384:27 - become right
384:28 - because for every route i need to
384:30 - manually add this logger so a better
384:33 - solution is this one
384:35 - where i select all of them i just remove
384:38 - them like so now of course if i go to
384:41 - any of these routes i'm not going to
384:42 - have anything in a console but
384:46 - there is a method by the name of app
384:48 - dot use and in that app.use
384:52 - this is what we do we pass in the
384:54 - middleware so we simply go with logger
384:58 - and once i save
385:00 - check it out now if i go to about for
385:04 - example or if i go to home
385:07 - or api
385:09 - and then products and hopefully you get
385:11 - an idea
385:13 - all the time you'll get this log in
385:16 - console why well because app.use
385:19 - will invoke this for any route now
385:23 - please do keep in mind two things first
385:26 - order matters here
385:27 - if i'm gonna place this below
385:30 - app.get
385:31 - and if i'm going to try to do that in a
385:34 - home page i'm not going to see anything
385:36 - in the console why well because i invoke
385:40 - my use only after get and express
385:44 - everything goes in order so if app get
385:48 - is before the used one the one that
385:51 - applies to all the routes then yes
385:54 - well first we'll hit the home route and
385:56 - then we'll send back home so there is no
385:58 - logger so that's why you'll see all the
386:01 - middleware functions all the app.uses at
386:04 - the top of the document
386:06 - so you'll have your middleware functions
386:08 - first and only then you'll have all your
386:12 - roth methods whether that's get post and
386:15 - you get an idea so that's the first
386:17 - thing that i would like to mention now
386:19 - the second thing that i would like to
386:20 - mention
386:21 - is the fact that we can add here a path
386:25 - so if i go to app.use that's my method
386:28 - and instead of providing only one
386:29 - argument which in my case is the logger
386:33 - i can set up a first one and that is
386:35 - going to be path and i just need to come
386:37 - up with a value now in my case i'm going
386:39 - to type api
386:41 - and you'll see e in a second why so if
386:44 - you save with an api you'll notice
386:46 - something interesting where this is
386:48 - going to be apply to both of them to the
386:52 - products as well as the items so here's
386:56 - the deal once you apply this path over
386:58 - here basically it's gonna apply to any
387:02 - route after this api so for example if i
387:05 - go with api and then some crazy one home
387:08 - about and then products all the time is
387:12 - going to keep on applying this
387:13 - middleware so that's something new right
387:15 - because previously we worked only with a
387:18 - specific route so forward slash or about
387:21 - or products here in this case so of
387:23 - course these are different now when we
387:26 - add this path to use then of course it's
387:29 - going to be applied pretty much to
387:31 - anything that comes after the path that
387:35 - you provide over here so in my case
387:36 - since i provided api and of course it's
387:39 - going to go for any path that's after
387:42 - that now if you want to find out more
387:44 - info about app.use i suggest navigating
387:48 - to docs again we're looking for api
387:50 - reference in our case that is four and
387:52 - if you take a look at the app.use
387:55 - mounts specified middleware function or
387:57 - functions and we're gonna cover that
388:00 - later as well at the specified path and
388:04 - middleware function is executed when the
388:05 - base of the request path matches so this
388:09 - is going to be our base
388:12 - and then whatever comes after will still
388:14 - invoke that middleware function and if
388:19 - you omit the path then it's just going
388:21 - to be applied to all of your requests so
388:26 - if i were to remove the path
388:29 - now it's going to be applied to home
388:31 - about api product
388:33 - as well as api items nice we're familiar
388:37 - with app.use
388:38 - and now i want to make our example even
388:41 - more interesting by adding another
388:43 - middleware function and in the process
388:46 - we'll take a look at how we can execute
388:48 - them in that use what is the syntax in
388:51 - order to add it as well as what is the
388:54 - execution order
388:56 - and let's start simply by creating a new
388:58 - file and i'm going to call this
389:01 - authorize
389:02 - authorize dot js again
389:06 - i'll zoom in just so you can see that is
389:09 - the file name and in here i'll just set
389:11 - up a function similarly to how we worked
389:14 - in the logger one so i'm going to go
389:16 - with const authorized
389:19 - or authorized it doesn't really matter
389:21 - now it's going to be a middleware
389:22 - function so of course i know that i'll
389:24 - have access to rec res
389:27 - as well as next and then in function
389:30 - body for time being i'll just invoke
389:33 - next and maybe i'll cancel log i'll say
389:36 - log and authorize
389:39 - like so okay let's save that one
389:41 - remember that we need to export it so
389:43 - module
389:44 - exports and that's equal to
389:47 - authorized awesome and then in the
389:50 - app.js i'll just copy and paste
389:53 - and i'll say
389:54 - authorize like so
389:56 - and of course the file name is also
389:58 - different it's not a logger so we can go
390:01 - with authorize
390:03 - and once i have this setup in place
390:05 - the way we execute
390:07 - multiple middleware functions in app.use
390:11 - we simply place them in the array so i'm
390:14 - gonna go with my logger first so logger
390:18 - and then we're gonna go with authorize
390:21 - and now once you navigate to a localhost
390:24 - 5000 again any of them in this case
390:27 - because notice there is no path
390:30 - first in a console i'll see this get and
390:33 - then authorize and that's something to
390:36 - keep in mind where they will be executed
390:39 - in the order so if we flip this one
390:42 - if i go with authorized first
390:45 - and then i go with logger then of course
390:48 - in the console i'll have the opposite
390:51 - order where i'm going to have authorized
390:53 - first and only then get so that's
390:56 - something to keep in mind now i'm going
390:58 - to go back to my previous setup the
391:00 - logger and then authorized and now let's
391:03 - take a look at how we can have the if
391:05 - condition in our middleware function now
391:08 - before we do anything let me just stress
391:10 - something very very important where this
391:13 - is just for demonstration purposes this
391:15 - is just an example and it's not how
391:18 - we're going to authorize
391:20 - users in our express applications i just
391:24 - don't want to overwhelm you from the get
391:25 - go so i'm just going to show you simple
391:28 - example using the query string but again
391:31 - this is not this is not how we
391:33 - authorized users in our express
391:36 - applications and with that said i'm
391:38 - going to navigate back to my
391:40 - authorized middleware and in here
391:44 - i'm just going to set up a query string
391:47 - so i'm going to say if the user
391:50 - provides a query string
391:52 - in my url then i'm good to go then i'll
391:57 - send back the resource that the user is
392:00 - requesting however if the user doesn't
392:03 - provide the user query so query string
392:06 - parameter in the url then i'll just send
392:09 - back 401 which just stands for
392:12 - unauthorized so let's start i'm going to
392:15 - go with const and i'm going to be
392:16 - looking for specific query string i'm
392:18 - going to be looking for the user my url
392:21 - parameter and of course we know that it
392:24 - is available in rec dot query like so
392:28 - and i'm going to say if the user exists
392:31 - so if it's there with any value it
392:33 - doesn't really matter which one or i
392:36 - don't know maybe if you want to make it
392:37 - more interesting let's go if the user
392:40 - equals john okay if that is the case
392:43 - then i'm going to go with rec.user
392:45 - and notice what i'm doing here
392:48 - i'm actually adding a property of user
392:51 - onto the rack object
392:53 - and i'll show you why it's so powerful
392:55 - so i'm going to go with recuser that one
392:58 - is equal to
393:00 - whatever i mean that could be a object
393:02 - for example and i'll say here name john
393:05 - again this is just for demonstration
393:07 - purposes and then id i don't know four
393:10 - or three or whatever so that's my user
393:13 - now i still need to call next if i won't
393:16 - do that then the whole setup is gonna go
393:19 - bananas so i'm gonna go with next here
393:21 - and now of course i just need to set up
393:24 - a response if
393:26 - the
393:27 - user or whoever is visiting
393:29 - doesn't provide the query string with a
393:33 - key of user and then value on john and
393:36 - in that case i'm going to go with my
393:38 - else and i'll say
393:40 - res
393:41 - and then let's add a status and the 401
393:45 - is going to be for unauthorized and
393:47 - let's just say send and simply let's
393:51 - try to spell this sucker
393:53 - unauthorized let's save that one
393:56 - and now notice something interesting
393:58 - if i'm going to go for example to my
394:00 - home page or product again any of the
394:02 - routes because there is no path
394:05 - in my app.used check it out i have
394:08 - unauthorized and if i inspect and in the
394:11 - network tab the same deal i have 401
394:15 - because i'm not authorized to access
394:17 - this resource i have my authorized
394:20 - middleware whereas say you didn't
394:23 - provide the query stream parameter with
394:26 - a key
394:27 - of user and more specifically you didn't
394:29 - provide here a value of john
394:32 - and since you didn't do that you cannot
394:34 - access the resource so now of course if
394:36 - we change things around and if i go
394:40 - with my question mark and if i say user
394:42 - equals john
394:44 - what do you know i have my home why well
394:47 - because now the condition is met and now
394:50 - we just go to next now why it is so
394:53 - powerful because in the authorized we
394:56 - add the user right so now of course not
394:59 - only i can check for that query string
395:02 - parameter but and also access this info
395:04 - again
395:06 - this is just demonstration normally what
395:08 - you're going to do you'll check for the
395:11 - json web token and then if the token
395:14 - exists then we communicate with database
395:17 - and actually get the user again this is
395:19 - coming up for time being we're simply
395:22 - hard coding these values so back in the
395:25 - app.js in any of the routes now i'm not
395:28 - going to add in all of them but just to
395:30 - showcase
395:31 - i'm gonna add for example in app items
395:34 - i'm gonna set up here a log and i'll
395:37 - look for
395:38 - rec and user and you'll notice something
395:41 - really cool where if i leave this
395:44 - query string parameter and if i go to
395:47 - api
395:48 - and items
395:49 - check it out first of all i have the
395:51 - items and second in console what do i
395:54 - see over here i see that user and that's
395:57 - why it's so powerful because we can add
395:59 - our middleware
396:00 - we can do some kind of functionality and
396:03 - now basically i'm attaching this to my
396:05 - request object so i have the request
396:08 - object and now i'm attaching this
396:10 - property here and now in any of my
396:12 - routes now of course i went with items
396:14 - but in any of my routes i'll have access
396:18 - to that user that's why middleware is so
396:21 - so crucial and that's why it is a big
396:24 - part of express applications because it
396:27 - truly allows us to structure our
396:29 - applications as lego blocks so we have
396:31 - this piece of functionality we have that
396:33 - piece of functionality and when we
396:35 - combine them we have this nice working
396:39 - express server now like i already
396:42 - previously mentioned
396:43 - middleware is all over express
396:46 - so just because we're done with our
396:49 - initial introduction doesn't mean that
396:51 - you're not going to see middleware
396:53 - you'll see it all over the place but
396:56 - just to complete our initial
396:58 - introduction i want to cover two common
397:02 - questions first well if we have access
397:05 - right now to app.use since we know how
397:08 - to use it
397:09 - are we going to add the middleware in a
397:12 - route and actually the answer is yes
397:14 - because imagine the scenario where
397:17 - i don't want to apply this app.use to
397:20 - all my routes
397:21 - for example i only want to check for
397:25 - authorized users in the api forward
397:27 - slash items what do i do well i simply
397:31 - add my authorized middleware correct so
397:34 - now i'll be able to access all these
397:36 - routes without any issues but the items
397:39 - want yes
397:40 - i'll check for that silly query string
397:44 - parameter and if you're wondering well
397:46 - how we can pass two middlewares if you
397:48 - would want in a single route
397:51 - same we just simply grab this array so
397:55 - we copy and paste and now of course once
397:58 - i hit the items not only i will log
398:01 - but i'll also authorize
398:04 - so let's go back
398:06 - and i'm going to take a look where in
398:08 - this case everything is fine
398:10 - i was able to access the resource since
398:14 - i provided the john so notice here name
398:16 - john id number three i also have my
398:18 - console log but if i were to go
398:21 - to just my home page like so i have the
398:25 - home and as you can see i don't get
398:27 - anything in a console i don't get my
398:29 - logger
398:30 - and i'm also not looking for any kind of
398:34 - authorized user so that's the first
398:37 - thing that i would like to cover second
398:39 - what are our options when it comes to
398:43 - middleware so far we have covered the
398:46 - first one our own so we can always set
398:48 - up our own middleware now our other two
398:52 - options are express so express provides
398:55 - quite a few
398:56 - built in middleware functions again in
398:59 - this case we don't have to worry about
399:02 - setting up the functionality we just
399:04 - need to reference the docs to see what
399:06 - options are provided and then of course
399:09 - supply those values and if you remember
399:14 - the express app example
399:17 - we used app.use and i said put the pin
399:20 - on this i'll explain this a little bit
399:22 - later if you want you can retype this
399:24 - but in my case i'm just going to copy
399:26 - this from the for express app.js
399:30 - and if we copy and paste and if i place
399:34 - it here notice so this is a app.use
399:37 - method now what argument the app.user is
399:40 - expecting it is expecting a middleware
399:43 - so in express
399:45 - we have a built in middleware by the
399:48 - name of static again somewhere in the
399:52 - express source code there is a code
399:55 - similar to this now of course this is
399:57 - silly they have way more complicated
400:00 - setup but hopefully you get the gist so
400:02 - there is a method and the only thing
400:04 - this method is looking for our public
400:06 - folder and then i already told you that
400:09 - it basically places all the contents of
400:12 - public folder
400:14 - as our static assets so they're publicly
400:16 - available so we already covered that one
400:19 - and now let me show you a simple example
400:21 - of third-party middleware now for a
400:24 - third-party malware we'll have to
400:26 - install it and one of the most popular
400:30 - ones i guess for the login is this
400:32 - morgan npm so again just go to your
400:35 - search engine and type morgan npm that
400:37 - is going to direct you to the
400:40 - docs i guess for the morgan and as you
400:43 - can see in order to install we just run
400:47 - npm i morgan so that's how we install
400:50 - the package and the syntax is following
400:52 - where we just go with morgan we required
400:55 - a morgan and then we just pass in morgan
400:58 - tiny now of course
401:00 - this one we need to set it up in our
401:03 - app.use so this is really optional
401:06 - you don't have to install it you don't
401:07 - have to run it but in order for me to
401:10 - hammer this home i will do that so let's
401:12 - go back i'll stop my server and remember
401:15 - the command was npm
401:17 - i and morgan okay i installed this one
401:21 - so now of course this package
401:23 - is going to be in my dependencies like
401:26 - so so not only i have expressed i also
401:28 - have the morgan
401:30 - and then in the app.js of course i'm
401:32 - going to have to require it so i'm going
401:34 - to go with const morgan and that is
401:37 - equal to
401:39 - require and then again i don't have to
401:42 - provide the path
401:43 - that's the module that i installed so i
401:45 - go with morgan and then where i have
401:47 - app.use
401:49 - and go with app.use since i would want
401:51 - to add to all my rows again if you want
401:54 - to add for specific one there's a
401:56 - different scenario but if you want to
401:58 - add for all the routes you just go with
402:00 - morgan
402:02 - and then they basically give you
402:03 - multiple options and the tiny one is
402:05 - just going to provide you the most
402:08 - essential data and again if you want to
402:10 - reference the docs please do so so i'm
402:13 - going to go with morgan and now i just
402:15 - need to spin up my app and i go with npm
402:18 - start now i will remove logger and
402:21 - authorized from my api items
402:24 - just because i think the terminal is
402:26 - getting quite busy
402:28 - and now of course once i navigate for
402:31 - example home page
402:33 - in a console i have get i have forward
402:36 - slash now this is a status code and then
402:38 - i have 2.8 milliseconds and that
402:41 - essentially just signals how long it
402:44 - took for the server to respond and if i
402:48 - were to go to localhost and forward
402:51 - slash about now of course i'll see that
402:54 - i have get request i have about the 200
402:58 - and now of course time is a bit
403:00 - different as well so hopefully this
403:02 - gives you a general idea
403:05 - why middleware functions are so crucial
403:08 - and how powerful they are and yes the
403:12 - bigger your express applications will
403:14 - get
403:15 - most likely the more middleware
403:17 - functions you'll have
403:20 - now
403:21 - they could be your own ones they could
403:23 - be the ones that provided by the express
403:26 - or
403:27 - there's also going to be tons of
403:29 - third-party middleware functions
403:32 - not bad not bad we have general
403:34 - understanding how middleware works in
403:37 - express and now i want to cover
403:40 - rest of the http methods
403:43 - so
403:44 - if you remember which seems like an
403:46 - eternity ago we covered the cycle the
403:49 - request message as well as response and
403:52 - in request
403:54 - well
403:55 - get was by default performed by browser
403:57 - but of course we have other methods as
404:00 - well and i also provided a second slide
404:04 - just for these methods and here you can
404:06 - see rest of the methods so get is again
404:10 - by default set up in a browser and this
404:13 - allows us to read data then we have post
404:17 - that is for inserting data so for
404:19 - example if we have some kind of api
404:23 - orders route we can add an order so user
404:26 - makes an order and we just place that
404:28 - order on the server so of course
404:31 - eventually we would say that in a
404:33 - database then we have put if we want to
404:36 - update data and of course we also have
404:39 - one for deleting the data and before we
404:42 - continue let me just mention something
404:45 - we're not going to persist this data so
404:47 - yes we'll have working examples of post
404:50 - put and delete and hopefully i'll be
404:53 - able to convey my message
404:55 - in a manner where you understand the
404:58 - general setup for rest of the methods
405:00 - but since we haven't covered how to
405:02 - connect to database we won't persist
405:05 - this data now i could have went the file
405:08 - system route
405:09 - where essentially we are persisting this
405:11 - data by writing in a file but i thought
405:14 - it's a waste of your time because most
405:16 - likely you're going to work with
405:17 - database anyway so we might as well skip
405:20 - that part so once we understand how we
405:22 - can connect to the database what are the
405:24 - methods by working with data in our
405:27 - database then we'll have a proper
405:30 - example where we're persisting in
405:33 - as well
405:34 - and in order to kick things off i'm
405:36 - going to navigate back to my address
405:38 - again the previous example is going to
405:40 - be in the file number 10 middleware
405:43 - options
405:44 - and again we're just removing pretty
405:46 - much everything starting with morgan so
405:50 - right after app
405:51 - and all the way to
405:54 - app.listen
405:56 - like so
405:57 - now there's not going to be a home route
405:59 - however i'm going to go with api and
406:02 - people now why do i go with api people
406:04 - because in the data file in the data js
406:08 - where we had the product
406:11 - there's also this one people people is
406:13 - an array each person is an object
406:16 - there's an id as well as the name as you
406:18 - can see very simple example
406:21 - so
406:22 - with this data array i want to showcase
406:26 - how we can read this data how we can add
406:29 - for example an extra person
406:31 - using the post how we can modify the
406:34 - person
406:35 - as well as deleting one and now of
406:38 - course i want to navigate to app.js and
406:40 - first i want to get my people so we
406:43 - simply go
406:44 - with import i'll structure it right away
406:47 - and as a side note since i might make
406:50 - some modifications i'll use let in this
406:53 - case
406:54 - and i'll set it equal to require
406:56 - and then data hopefully this part is
406:59 - clear since we have covered it quite a
407:02 - few times and let's start with the one
407:05 - that we already know and that is going
407:07 - to be a get method so i'm going to go
407:09 - with app dot get like i said i'll
407:12 - purposely set up my route with a value
407:15 - of api and people so that's going to be
407:18 - my path i'll say api
407:20 - and then people now this is a get method
407:24 - and simply will return
407:26 - this array so rec and res and again i'm
407:30 - just going to go with res status let's
407:33 - hard code the value of 200 then let's
407:36 - set up our json and since i want to be
407:38 - kind to my users i'll send back the
407:40 - object i'll say that the success
407:43 - property is true so the request was
407:46 - successful and as far as data property
407:49 - well i'll set it equal to people so
407:52 - let's navigate back to our browser and
407:56 - we're going to go with 5000 and of
407:59 - course cannot get
408:01 - so this is going to be 404 if i just go
408:03 - to the homepage
408:05 - and instead
408:06 - i have a route for api
408:09 - and i believe the whole path was people
408:12 - like so so we run that
408:14 - and now of course i have zoomed in
408:16 - already massively here so let me zoom
408:19 - out
408:19 - in my browser and we should see
408:23 - that we're getting our object the
408:26 - success property is true beautiful and
408:29 - then of course we have the data property
408:31 - and in there we have the people's array
408:35 - so a bunch of people in here so of
408:37 - course that is our first http
408:41 - method
408:42 - that is the get one where effectively we
408:45 - read the data and like i already have
408:47 - mentioned
408:48 - probably 20 000 times
408:50 - that's the default
408:52 - method that the browser performs so
408:55 - when you set up a request with your
408:58 - browser you right away use the http verb
409:01 - by the name of get and that's why you
409:04 - can read the data
409:06 - all right so we're clear with get method
409:10 - that's how we can read there however how
409:13 - we can add data onto the server so how
409:16 - we can
409:17 - insert data
409:19 - and in order to do that we need to use a
409:22 - post method
409:23 - but it's not like i can somehow
409:25 - configure browser and start making post
409:28 - requests unfortunately that's not how it
409:31 - works that's why i provided a little bit
409:34 - of help now keep in mind one thing where
409:37 - after we set up a post method
409:40 - effectively once we take a look at two
409:42 - flavors of how we can set up post
409:44 - request we will install one more tool
409:48 - which is going to be crucial
409:49 - in our express server development which
409:54 - is just going to allow us to
409:56 - test everything much faster
409:59 - but since for the post i do want to show
410:02 - you two flavors that we can have
410:04 - we'll use a little bit of static data
410:07 - meaning there's an app that i prepared
410:09 - but don't worry
410:10 - it's not like you'll have to do that
410:12 - each and every time to test any of these
410:15 - methods and you'll see what i'm talking
410:16 - about in the following videos so first
410:19 - let's start by jogging our memory a bit
410:22 - we have app.use now what
410:25 - app.use is doing is just applies the
410:29 - middleware
410:30 - to all our routes correct and i also
410:33 - mentioned that we have this option
410:35 - of setting up a public folder
410:38 - now we can call whatever we would want
410:40 - but for this methods example i prepared
410:45 - a
410:46 - methods.public
410:47 - as you can see it is just a folder with
410:50 - index.html with javascript html
410:53 - some css
410:55 - and once we navigate there of course
410:57 - i'll show you how the functionality
410:59 - works so this is just prepared so we can
411:02 - test those other methods meaning more
411:05 - specifically the post method because we
411:07 - cannot simply just perform a post
411:10 - request from the browser so first let's
411:13 - set up
411:14 - that methods public as our public folder
411:18 - that's step number one so let's set it
411:19 - up as our static assets and in order to
411:22 - do that i'm just going to add first a
411:24 - comment and i'll say assets and then i'm
411:28 - going to go with app.use again remember
411:31 - that is our method and this is going to
411:33 - be a built in middleware
411:36 - and the name is express static so i just
411:39 - grab my express instance i look for the
411:42 - method of static and if you remember we
411:45 - just need to provide here a path
411:48 - and instead of going public or static
411:50 - like i showed you previously i'm just
411:53 - going to go with forward slash and then
411:55 - methods and then public
411:58 - because this is where i set up my static
412:02 - files for these examples we invoke it
412:06 - and now if we go to the home page we
412:08 - shouldn't get this error so once you
412:11 - invoke
412:12 - there it is we have a
412:14 - somewhat decent looking html file with
412:18 - two options we have this javascript
412:21 - option which we're going to cover second
412:23 - and first one is going to be a
412:26 - traditional form example and again the
412:30 - reason why we do that
412:32 - is because you cannot simply just
412:34 - configure
412:36 - your browser
412:38 - to perform
412:39 - a post request you either need to use a
412:41 - tool which we're going to install by the
412:44 - name of postman or
412:46 - insomnia here's another popular one
412:49 - or you need to set up basically a
412:52 - working application
412:54 - and if you take a look in the methods
412:57 - public we have this working application
412:59 - all right and once we have the basic
413:01 - setup in place now let's take a look at
413:04 - our two flavors when it comes to the
413:07 - post method
413:09 - and i want you to navigate to index html
413:13 - and in there you'll find pretty typical
413:17 - index.html file with some styling
413:20 - with nav as well as deform
413:23 - and in form we have two attributes we
413:26 - have action one
413:28 - as well as the method and as you can
413:30 - clearly see the value for the method is
413:33 - post
413:34 - and this action one just says
413:36 - where we're going to send it and notice
413:39 - now we have forward slash login so that
413:41 - means that
413:42 - this url this path is on our server but
413:45 - of course we know that in the app.js
413:48 - we're not handling that
413:50 - so for the form there's going to be one
413:52 - path and then for the second example
413:54 - when we used straight up javascript then
413:56 - of course there's going to be a
413:58 - different path for that so this is going
414:01 - to be the url or path where we're
414:03 - submitting the form and inside of the
414:05 - form we have label we have input
414:08 - so basically
414:09 - we have name attribute for this one we
414:11 - have the id
414:13 - as well as the autocomplete so we'll
414:16 - type in some kind of value and then
414:18 - we'll send this to
414:21 - forward slash login so localhost and
414:23 - then forward slash login and of course
414:26 - we also have a submit button so now
414:29 - let's start by taking a look what
414:32 - happens when we simply submit this form
414:35 - so go here type some kind of gibberish
414:38 - in my case i'm going to go with john
414:40 - bravely press enter and of course we do
414:44 - have kind of post login okay that's fine
414:47 - we're not expecting anything anyway
414:49 - right we know that there is no route
414:52 - that handles the post
414:55 - for the login
414:56 - but what's really interesting here
414:59 - is in the network tab of course i can
415:02 - see
415:03 - my request
415:05 - in this case this is login now this is
415:08 - 404 and again i'm going to repeat this
415:10 - 20 000 times but check out the method so
415:13 - method is not
415:15 - get method is post and then we're going
415:17 - to localhost 5000 and then forward slash
415:21 - login now what's also really interesting
415:24 - all the way in the bottom
415:26 - what do you see here you see this
415:29 - forum data
415:30 - and then we have key value pair we have
415:33 - name and john and if you remember
415:37 - when we talked about http messages i
415:40 - said that the body is optional so for
415:42 - example when we're sending a get request
415:44 - we're not sending a body
415:46 - but when we're sending a post request
415:48 - it's very crucial so if i want to add
415:51 - something onto the server
415:54 - of course i want to get that data
415:56 - i mean otherwise how i'm going to know
415:58 - where to add to the server doesn't that
416:01 - make sense i hope it does so let's go
416:04 - back okay i see this name and i see john
416:08 - and if you're not familiar basically the
416:10 - way it works is whatever you provide
416:12 - here
416:13 - for the name is going to be a key
416:16 - so for example if i'm going to set this
416:19 - up as
416:20 - testing you'll see that now when we
416:23 - perform the same request the same post
416:25 - request again with the same value
416:27 - different value it doesn't really matter
416:29 - now of course that key
416:31 - name is going to be testing so whatever
416:34 - value you provide over here that is
416:36 - going to be the key and of course the
416:38 - value is whatever you're submitting so
416:41 - in my case
416:42 - it's either peter or john okay
416:46 - that's out of the way so i'm going to
416:48 - change it back to name and now we need
416:51 - to understand something
416:53 - where the request is coming in
416:56 - but a we're not handling that
416:59 - and b we don't have the middleware that
417:02 - actually adds this data that the form in
417:06 - this case is sending to our request so
417:10 - let's see how we can fix the first one
417:12 - and we simply need to come up with a
417:14 - round now in this case remember we're
417:17 - dealing with post this is not get
417:19 - and we're going to go with forward slash
417:22 - and then log in here because of course
417:25 - that's what i have in my form again we
417:27 - go with rec and res
417:29 - and technically we can come up with some
417:32 - kind of info i can say send
417:35 - and
417:36 - i'm simply going to say post
417:38 - and that's it just so we can save time
417:41 - on typing again let's navigate back and
417:44 - in this case let's try susan let's send
417:47 - it yeah i see the post so i don't have
417:50 - the 400 anymore or 404 so that's cool
417:54 - but unfortunately i have no access at
417:58 - this point to whatever
418:00 - i'm being sent
418:02 - so unfortunately i cannot access that
418:04 - susan or john or whatever value so
418:07 - unfortunately
418:08 - i cannot add for example to my list if i
418:12 - wanted to now how do we add it well this
418:15 - is where the middleware comes in so
418:18 - previously we covered static assets with
418:20 - express static
418:22 - in order to get the form data
418:25 - we need to go with url and coded
418:29 - middleware so i'll add here
418:32 - parse
418:33 - form data and essentially this is just
418:36 - going to parse that data and add the
418:38 - values to
418:40 - rec.body so where we have a post request
418:45 - in the rec.body property we'll find all
418:48 - the info
418:50 - and in order to use this middleware
418:51 - surprise surprise we're going to use
418:53 - app.use
418:55 - and then we'll pass in express
418:58 - and then url encoded and then you also
419:02 - pass in flag where you go with extended
419:05 - and you set up false and if you're
419:08 - wondering why are we adding this
419:10 - extended false flag or you just want to
419:13 - get more info about this url in coded
419:17 - middleware simply let's head back to the
419:20 - documentation in this case we're looking
419:22 - for the express and notice here i have
419:25 - express url encoded this is a built-in
419:30 - middleware function in express it parses
419:32 - incoming requests with url and coded
419:36 - payloads and it is based on the body
419:39 - parser so in the previous versions of
419:42 - express you have to actually install the
419:45 - body parser now in this case you don't
419:48 - it already comes built in and as far as
419:51 - this extended this option allows to
419:53 - choose between parsing url encoded data
419:56 - with query string library when false
419:59 - meaning
420:00 - this is our case or the qs library when
420:05 - true again i wouldn't lose my sleep over
420:07 - this one then the common approach is
420:10 - using this extended and false and once
420:13 - we can access it then we can do some
420:16 - cool functionality so first let's just
420:19 - scroll down a bit where we have the
420:21 - login and first i'm just going to start
420:23 - by console logging rec
420:25 - and body let's save that one
420:27 - and again back to our browser
420:31 - again i'm going to go with susan this
420:34 - was 200 so everything was successful and
420:38 - now of course in the right dot body i
420:41 - also have a name and the value is susan
420:45 - so
420:46 - now we can start doing something with
420:48 - this data now i purposely set up two
420:50 - examples
420:52 - one is going to be for form which of
420:54 - course is this one and then one is for
420:56 - javascript now with the javascript
420:59 - example this is where we'll actually
421:01 - manipulate this people array fourth time
421:04 - being with login this is a separate
421:07 - issue we're just dealing with the form
421:09 - so
421:09 - we'll just try to make things
421:11 - interesting by checking for the name
421:14 - if the name is provided then we'll send
421:16 - back welcome and then pass in that name
421:19 - if the name is not provided so for
421:21 - example if the user
421:23 - is trying to submit the form empty for
421:26 - example like so we'll just send back 401
421:30 - please provide credentials again
421:32 - please keep in mind this is just a
421:34 - example and i'm fully aware that we can
421:37 - check for empty values here on the front
421:39 - end again the goal of this example is to
421:42 - show you how to handle this on the
421:44 - server so i have wrecked that body okay
421:47 - i can see that in this case i have
421:50 - name but it is empty so now of course
421:53 - let's set up our logic first i'm going
421:56 - to go with const name and that one is
421:58 - equal to rec
422:00 - that body so i'm destructuring my name
422:03 - property and i'll just check if the name
422:05 - exists whatever the value that could be
422:09 - b
422:10 - that could be bobby lee not could be
422:12 - again taco burrito whatever you want and
422:15 - as you can see i'm getting quite hungry
422:17 - so let's go with return res
422:20 - dot status
422:22 - then let's set up a 200
422:26 - which just says that we were successful
422:29 - and we're gonna go with send
422:31 - and we'll set up a template string
422:34 - welcome and i'm just going to access my
422:37 - name
422:38 - so if there's some value i'll send back
422:40 - 200 and i'll say welcome whatever is the
422:44 - value if not
422:45 - well here we're going to go with res
422:48 - and let's just add status here and again
422:51 - just for kicks i'm going to go with 401
422:54 - and we're going to go with send and of
422:56 - course let's say please
422:59 - provide
423:00 - and credentials
423:02 - like so
423:03 - let's save this one and now we should
423:07 - truly see how it works in the action
423:10 - now i'll leave i guess the tab for now
423:14 - and let's just try to submit so for
423:17 - example if i submit with empty values
423:21 - i'm going to say please provide
423:22 - credentials and as far as my login it is
423:25 - 401
423:26 - that's what the server is sending back
423:28 - however if i type in some kind of value
423:31 - for example anna comes to mind i have
423:34 - welcome and anna so that's our first
423:37 - flavor when it comes to post request
423:40 - where we use the form and again this is
423:42 - just front end where we come up with an
423:45 - action and since this index.html is on
423:48 - the same server we simply go with
423:50 - forward slash and login of course if
423:54 - your front-end application is separate
423:57 - from your server then you're going to
423:59 - provide a full path where the server is
424:03 - hosted so basically a full domain and
424:06 - then we go with method post now this is
424:09 - technically a front-end part but it is
424:11 - crucial that we understand it so then we
424:14 - perform of course a post request we hit
424:18 - our url
424:20 - so in this case we hit our forward slash
424:23 - login and this is the part where we
424:25 - handle that on a server
424:27 - in order to get that data
424:30 - whatever we are being sent we need to
424:33 - use a middleware this one is built into
424:36 - express so again we simply just need to
424:38 - use
424:39 - app.use which is going to apply this
424:42 - middleware to all our incoming requests
424:46 - and then we just pass an extended false
424:49 - flag and the moment we do that
424:52 - indirect.body
424:53 - will have access to our form values so
424:56 - whatever
424:58 - is set up here as a value that is going
425:00 - to be our key and whatever is passed
425:03 - into our form well of course that is
425:06 - going to be the actual value that we're
425:08 - getting so if i go here with name i'm
425:10 - gonna see either susan anna or whatever
425:14 - user provides now like i already
425:16 - previously mentioned this is just for
425:17 - demonstration this is just so we have a
425:20 - bit more interesting example e instead
425:23 - of just sending back the name
425:27 - so hopefully this part is clear
425:30 - and now we can focus on our second
425:32 - flavor where we use javascript to
425:36 - send the request all right and once we
425:40 - have the form set up out of the way now
425:43 - let's take a look at the javascript
425:45 - option before we do though there's one
425:47 - more thing that i would like to mention
425:50 - if you take a look at the headers
425:52 - you'll notice something interesting
425:55 - where we have a content type for the
425:58 - request header and of course this is
426:01 - going to be application
426:03 - and then we have this form url encoded
426:07 - and the reason why i'm showing that
426:08 - because of course for javascript it is
426:11 - going to be a bit different so just keep
426:14 - this one for your reference now
426:18 - let's navigate back to our
426:20 - static files basically to our front end
426:23 - and now let's take a look at the
426:25 - javascript approach
426:27 - and interestingly here
426:29 - where i have the javascript i do have
426:30 - the form
426:32 - keep in mind we'll still handle this
426:33 - form but in this case it's going to be
426:35 - done strictly using javascript and we'll
426:38 - use javascript to send our http requests
426:42 - and that is very very crucial that is
426:44 - going to be the difference where instead
426:46 - of form now i'll be sending that request
426:49 - using javascript
426:50 - and of course the content type will be
426:52 - different that's why i showed you the
426:54 - form example but what you'll also notice
426:57 - that right away we have our list and if
427:00 - you don't believe me you can double
427:01 - check in data we have john peter susan
427:05 - anna and emma so what's happening well
427:08 - let's go to javascript html
427:11 - this is where we have our frontend logic
427:13 - and again let's take a look at our index
427:16 - html
427:17 - a little bit of css
427:19 - nav
427:20 - and then we have the form now in this
427:22 - case i don't have the action and i don't
427:24 - have the method
427:26 - okay interesting so i have name
427:28 - attribute it still has a value of name
427:31 - so i should expect probably that this is
427:36 - going to be the value that's coming in
427:37 - with my request then i have a little bit
427:40 - of form alert this is where we'll
427:42 - display a little bit of functionality as
427:44 - well as the result
427:46 - now if you're not familiar
427:49 - there's a package called axios which
427:51 - essentially just makes it easier to set
427:54 - up http requests
427:56 - so
427:57 - instead of using the built-in fetch
428:00 - which i could have used i think axios
428:02 - provides a cleaner api and better error
428:05 - messages
428:06 - and since i don't want to spend three
428:09 - hours on explaining all this code
428:13 - i simply went with axios and the way i
428:17 - set it up i just set up the cdn link so
428:21 - this just gets me the axios library and
428:23 - then the moment i install it of course i
428:25 - have axios in my front-end project
428:29 - please keep that in mind those are two
428:31 - separate things this is a front-end
428:34 - project and
428:35 - in order not to confuse you more i just
428:37 - set up a few script tags instead of
428:40 - going with a separate javascript font so
428:44 - as you can see here i'm selecting the
428:46 - result
428:47 - so that is my div
428:49 - and i have this fetch people
428:52 - so that is the function that fetches
428:55 - people from my server now notice the
428:59 - path
429:00 - it is api and people
429:02 - why well because
429:05 - in my server i have also api people so
429:08 - this is for get requests
429:10 - that's the default one however in this
429:12 - case we're not doing that with a browser
429:15 - we're doing with javascript so axios
429:18 - has the method by the name of surprise
429:21 - surprise get that just means that on the
429:23 - front end we're performing a
429:25 - get request
429:27 - to the same server that's why we go
429:29 - forward slash api and then people so
429:32 - make sure these urls match
429:35 - so if these paths won't match then
429:36 - you'll have an error and to showcase
429:39 - that if i go with p poles
429:42 - then if you navigate to the front end
429:43 - and if you refresh
429:45 - can't fetch data
429:46 - so we try to fetch people from our
429:49 - server then we do a little bit of logic
429:52 - and this is just vanilla.js not going to
429:54 - cover it basically we tear it over and
429:56 - then we just set up a nice heading 5s
429:59 - and all that and then we invoke the
430:02 - function but
430:04 - if there is an error we'll look for the
430:07 - error property now in this case i'm not
430:08 - the structuring it i'm actually not
430:10 - using it i just say can't fetch data so
430:14 - that's step number one now the second
430:16 - one is of course using the form
430:19 - so then i select the submit button i
430:22 - select the form i also select the alert
430:26 - because we will display an alert if the
430:29 - value is empty and again let me repeat
430:31 - i'm fully aware that we can check for
430:33 - that in the front end i just wanted to
430:36 - showcase the server setup and then
430:39 - notice something interesting where i
430:41 - have this try and catch block in my
430:44 - functionality so the moment the user is
430:47 - submitting the form of course i invoke
430:49 - my callback function it is a sync
430:52 - because
430:53 - for the actuators i can wait for
430:54 - response and notice this one so i have
430:57 - axios and again surprise surprise the
431:00 - method name is post why because we are
431:03 - sending a post request
431:05 - and this is just an axiorys thing but
431:07 - again we provide the value in this case
431:10 - the url value is api and people so
431:13 - something that we're not handling yet on
431:16 - our server and this is the value
431:19 - so again this is just axio syntax where
431:22 - in order to set up whatever data you're
431:25 - sending you just pass it as a second
431:27 - argument and you set it up as a key
431:29 - value pair now what's really cool that
431:31 - would axios they set up all the content
431:33 - types and all that good stuff for you so
431:36 - again you just save a little bit of time
431:38 - now if there is an error in our case
431:40 - that is going to be if we're trying to
431:43 - submit something and in fact there's no
431:46 - value meaning we just try to submit
431:48 - empty form value then we will display
431:51 - the error message and again this is
431:53 - really cool because axiorys just
431:55 - provides
431:56 - a very useful
431:58 - error api unlike the fetch where you
432:00 - really need to
432:02 - jump through the hoops so let me save it
432:04 - back to people so we can see of course
432:08 - all the people
432:09 - that
432:10 - we have in our array currently and then
432:13 - of course we'll focus on this post one
432:17 - so as you can see i get the input value
432:20 - and i just passed it in as a
432:23 - name property awesome so now back in our
432:27 - app js of course we need to handle it
432:29 - and please keep in mind one thing where
432:31 - app dot post
432:33 - and then api
432:35 - and people
432:36 - is not the same as api get and api
432:40 - people
432:41 - even though the url is the same
432:43 - methods are different and that goes for
432:46 - all the methods we're going to use
432:47 - whether you're talking about put delete
432:49 - or whatever so just because the urls are
432:52 - the same
432:53 - doesn't mean that they mean the same
432:55 - thing no
432:57 - the method is different here i'm just
432:59 - reading the data i'm reading data from
433:02 - api people here i'm actually trying to
433:05 - add data
433:06 - and again we're going to go with wreck
433:09 - and res
433:10 - and let's just go with some simple
433:13 - response
433:15 - now for time being i'm just going to say
433:17 - that my response is going to be 201 now
433:20 - that's the response that we send back if
433:22 - we are performing a post request and we
433:25 - are successful so i'll just say res that
433:29 - status 201
433:31 - and for time being let's just say send
433:34 - and i'm just gonna say success and of
433:36 - course now what i would want
433:38 - is to navigate back to my javascript one
433:42 - hour fresh i'm getting all my people and
433:45 - now let's try it out so i'm gonna send
433:48 - this one
433:49 - so i sent again here nothing changed but
433:52 - if i take a look at my network tab
433:56 - i should see and by the way sorry i'll
433:58 - have to do that one more time let's go
434:01 - with i don't know susan here let's try
434:04 - to submit and there it is now of course
434:06 - i have api people and 201
434:11 - so that's the response that i'm getting
434:13 - on my front end so let's bravely click
434:16 - on this one and we can see that the
434:19 - request url is api people okay
434:23 - the method was post now the response was
434:26 - 201 so it was successfully created and
434:30 - now check it out when we look at the
434:33 - request headers of course we have
434:35 - application json so on our front end we
434:39 - do need to add this content type
434:41 - when we are sending the data now again
434:44 - what's really cool about axios it adds
434:47 - for us
434:48 - but in general you need to keep that in
434:50 - mind and there it is again we have this
434:52 - request payload
434:54 - and the name is equal to susan so
434:57 - whatever i'm going to pass it in if i'm
434:59 - going to send it empty then i'm going to
435:01 - still have the key name
435:02 - and the value will be empty now the
435:05 - gotcha here is even though we're
435:07 - handling a
435:09 - form submissions we're not handling the
435:11 - json data so yes we know how we can send
435:14 - back the json data but we're not
435:17 - handling the incoming json data and this
435:20 - is where another middleware comes into
435:22 - play so i'm going to say parse json here
435:28 - and we simply need to go again with
435:30 - app.use
435:31 - and we go with express
435:33 - and json now in this case i'm not going
435:35 - to go to documentation
435:37 - if you want you can do that in my case i
435:40 - will try to save us a little bit of time
435:42 - and we'll skip that and here we have api
435:46 - people and now similarly to our login
435:51 - we have access to the form data that is
435:54 - being sent with javascript in the rec
435:57 - dot body
435:58 - previously
435:59 - before this was added no we have no
436:02 - access yes when it comes to form that
436:05 - was one setup now when it comes to
436:08 - straight up http requests for example in
436:11 - this case sent with javascript no we had
436:13 - no access so we were getting a json
436:16 - and now we added a specific middleware
436:19 - that handles that so of course in this
436:21 - case now we can set up more logic
436:24 - correct we can say that we're looking
436:26 - for the name and if the name is provided
436:30 - then awesome then i'm going to send back
436:33 - that new person that was created so we
436:36 - can add it to our front end and again
436:38 - this is the case where we're not
436:40 - persisting this data anywhere later
436:42 - we'll learn how to do that for now i
436:45 - already have the code that adds it to
436:47 - our front end however if the user tries
436:50 - to submit without any values well then
436:53 - there's going to be a error message so
436:56 - in the api people
436:58 - in the post method let's set up our
437:00 - logic
437:02 - where i'm going to go with const name is
437:04 - equal to
437:05 - rec.body
437:07 - the middleware makes it possible now
437:10 - and then i'm going to say if the name is
437:12 - not provided well then i'm going to send
437:14 - back the 400 then i'm going to say
437:17 - please provide name value so there's
437:19 - going to be a error message so i'll say
437:22 - here if and
437:24 - exclamation point and if the name is not
437:26 - provided then let's go to return
437:29 - res
437:30 - dot status and for the request error we
437:34 - go with 400 that's the status code and
437:37 - then let's go again with json and in
437:40 - this case we're gonna go with success
437:42 - now this success will be false and then
437:45 - we're going to go with message again i
437:48 - would suggest using the same properties
437:49 - because of course i'm handling them on
437:52 - the front end as well so in here i'll
437:54 - say please provide
437:56 - name value like so now if the value is
438:00 - provided whatever it is then of course
438:03 - we can send back res.status 201. hey
438:06 - guys it's john from the future with a
438:09 - small update
438:11 - as you'll see in a second while i was
438:12 - recording i forgot to change the methods
438:16 - so instead of writing json i just left
438:18 - it as send
438:19 - and while we can get away with it in
438:21 - this example normally you always want to
438:24 - use json instead so make sure you change
438:27 - your method from send to json and in
438:31 - this case
438:32 - let's just set up a proper object we'll
438:35 - say success is true so now we're being
438:38 - successful and i'm just gonna send back
438:40 - that person now i'm going to set it up
438:42 - with person key and the value will be
438:45 - named whatever i'm getting again please
438:48 - use the same ones if you want to have a
438:50 - same result now
438:52 - let's navigate back we can refresh just
438:55 - so we are all on the same page and if we
438:59 - type susan now we should see another
439:02 - susan added to our list
439:04 - and then again we can go with john and
439:07 - i'm just being lazy on coming up with
439:09 - original names and as you can see every
439:12 - time we add
439:14 - value in our form we're being successful
439:17 - we're actually getting back this value
439:19 - from our server and then we dynamically
439:23 - added to our front end and again the
439:24 - reason why we're doing this way is
439:27 - because we're not persisting this data
439:29 - so that's why the setup is following
439:31 - later of course we'll learn how to
439:32 - persist this in a database as well and
439:35 - if i try to submit with empty value
439:39 - check it out now of course i have people
439:42 - and this one is what 400 right
439:45 - notice here and it says please provide
439:48 - name value now if you want to do a bit
439:51 - of console logging you're welcome to do
439:53 - that on the front end if for example you
439:56 - are iffy about the syntax but just to
439:59 - let you know when we talk about axios
440:02 - here
440:03 - effectively we're getting back the whole
440:05 - thing so when we perform a request http
440:09 - request with axiorys we're actually
440:12 - getting back a
440:14 - giant object
440:15 - now what we're interested in that object
440:18 - is a data property
440:20 - so that's the response that is coming
440:22 - back
440:23 - from the server
440:24 - and then in here as you can see i set up
440:27 - a heading 5 with data.person so that's
440:30 - the person that we're sending back from
440:33 - our server now
440:36 - if for example there is an error we go
440:38 - with error response again data property
440:41 - because that's where the useful
440:43 - information sits because the object of
440:46 - course is giant with lots of useful
440:48 - information but as far as what we're
440:49 - sending back it is sending in data and
440:52 - then message now i'm looking for the
440:54 - message property of course here because
440:57 - i set up a message property
440:59 - on the server hopefully it is clear this
441:02 - is our second flavor
441:05 - where effectively we perform a post
441:07 - request from the application
441:10 - and of course in that case we do need to
441:12 - provide content type as well as the data
441:15 - and next video we'll install
441:17 - and cover some basic setup for a very
441:20 - useful tool
441:21 - that is going to save us a lot of
441:24 - trouble when we work with post
441:27 - delete as well as put methods
441:31 - all right so at this point we're
441:33 - familiar with two ways how we can send a
441:37 - post request
441:38 - so we covered how we can do that using
441:40 - the form
441:41 - as well as straight up http request in
441:45 - our case using javascript
441:47 - however there's a major problem in our
441:50 - current setup
441:52 - and the problem here is following
441:55 - if
441:55 - we need to create a frontend to test
441:58 - something for every route as you can see
442:02 - i mean our development is going to be
442:03 - extremely slow
442:05 - because we can clearly see that it's
442:07 - probably going to take us way longer
442:10 - just to set up a front end than setting
442:13 - up just one simple route so every time i
442:16 - create a route i'm probably going to
442:18 - spend i don't know five six times more
442:21 - on setting up the front end where i can
442:23 - test this route and of course there has
442:26 - to be a better option and that better
442:28 - option
442:29 - is a tool called postman
442:32 - and postman is just awesome for quickly
442:36 - testing our apis so at this point i
442:39 - strongly suggest that you navigate to
442:41 - postman.com again it's a free tool so
442:45 - you're not going to have to pay anything
442:46 - but for mainer of the course yes we'll
442:49 - use this so if you're kind of iffy about
442:52 - installing something new this is
442:54 - something that is required so navigate
442:57 - to
442:58 - postman.com
442:59 - and then they'll try to sign you up you
443:02 - don't have to do that just keep
443:04 - scrolling down keep scrolling down and
443:06 - all the way in the bottom you'll see
443:09 - this download app option go here and
443:12 - they'll right away detect which
443:13 - operating system you're using of course
443:15 - in my case that is mac so download the
443:18 - application once it's on my computer i'm
443:20 - going to navigate back to the desktop
443:22 - i'm going to go to downloads i'll crack
443:24 - it open
443:25 - then of course i'll just move it to my
443:27 - applications like so and i already had
443:30 - one on my computer but i removed it so
443:33 - we can do these steps together then this
443:36 - is the application let me zoom in that's
443:38 - the postman so just click on it
443:41 - and then it's going to spin up the app
443:45 - and eventually
443:47 - you'll hit the dashboard and i'm not
443:49 - going to spend half an hour on this
443:52 - setup but of course as we're progressing
443:54 - we the course as we're progressing with
443:58 - our examples we will cover
444:00 - more features
444:02 - that this app provides
444:04 - and basically here you'll have all your
444:07 - requests that you can actually group in
444:10 - collections and again that's something
444:12 - that we'll cover a bit later and this is
444:14 - where we can make those requests and in
444:17 - order to create a new request we just
444:19 - click on this plus sign and check it out
444:22 - so at the moment i have untitled a
444:24 - request
444:25 - in here i need to enter the url and i
444:28 - can send my request not orders here on
444:31 - left hand side what do i have i have get
444:35 - but what's really cool i have all these
444:38 - methods available as well so first let's
444:41 - test out the get route and then we'll
444:43 - see how we can deal with post route as
444:46 - well now as far as our url what it is
444:49 - well it is localhost 5000
444:52 - and of course the full url is api and
444:57 - people now this is for the post as well
445:00 - as the get and since we're testing it of
445:02 - course that's why we have a method with
445:05 - the value of get so let's go here local
445:09 - host and then five thousand
445:12 - then forward slash api
445:15 - and people and the moment i click send
445:18 - check it out what do i see here in the
445:20 - bottom i see my object the success value
445:23 - is true and there i have my data so as
445:27 - you can see the moment i create my route
445:30 - for example post route or put route or
445:33 - whatever i can test it immediately i can
445:37 - test it within a few seconds instead of
445:40 - building the whole front end just so i
445:42 - can test one route and of course once we
445:46 - have covered get route now let's see how
445:47 - we can deal with a post route so we need
445:50 - to change the method of course
445:53 - now the url still stays the same because
445:56 - i do have a route for the post as you
445:58 - can see and in here what i'm looking for
446:01 - i'm looking for the name
446:03 - in the body
446:05 - and how do we construct a post request
446:07 - in a postman well we do that in a
446:10 - following way first we go to the body
446:13 - and we look for raw
446:15 - and instead of text i go with json
446:19 - because i'm going to be sending a json
446:21 - data so this is not the case where we're
446:24 - working with the forms in this case
446:26 - we're sending a json data and what
446:29 - you'll notice something really
446:31 - interesting in headers right away
446:34 - there's going to be a content type
446:37 - so let's see let's set up first the body
446:39 - and you'll see how it gets added so
446:41 - we're gonna go here with a name again
446:44 - this is what i'm looking for that's why
446:46 - i need to pass it and then i'm gonna set
446:49 - up some kind of value now since i'm
446:50 - setting up the json please remember that
446:52 - we need to use double quotation marks so
446:55 - i'm going to go here with john and if
446:57 - you paid attention previously we had
446:59 - eight headers and now we have nine so
447:02 - i'm gonna go back and there it is now i
447:05 - have content type application json so
447:09 - that's really cool we don't have to do
447:10 - anything the header gets added for us
447:13 - and of course the moment i click send
447:16 - check it out now i have success true and
447:20 - person john why do i have that well
447:22 - because that is my response i have
447:24 - success true and of course whatever name
447:28 - i received i just sent it back so now of
447:30 - course let's quickly test out our 400 as
447:33 - well so i'm going to navigate back and
447:36 - then in the body i'm just going to send
447:39 - a empty string or you can remove name
447:42 - altogether that's really up to you and
447:44 - now of course i have 400 bad requests
447:48 - and success is false and of course i can
447:51 - see the message so as you can see we can
447:53 - test it within seconds and to really
447:56 - hammer this home why don't we create
447:58 - another post route and quickly set up
448:01 - some kind of response and let's test it
448:04 - out in our postman as well so i'm going
448:07 - to go in between the post and login i'm
448:10 - just going to go with app.post
448:13 - and the route is going to be following
448:15 - i'm going to go with path of api
448:18 - people
448:19 - people
448:20 - and i'm going to add a postman here
448:23 - or you know what let's do it this way
448:25 - let's go postman
448:27 - and then
448:28 - people like so
448:30 - and then as far as the callback function
448:32 - again
448:33 - we get rec res
448:36 - and then
448:37 - in the body again i'm going to be
448:39 - looking for the name property so i want
448:42 - to get that name so i'm going to say
448:44 - that i'm expecting it
448:46 - we'll go with name rec
448:49 - dot body again if you want to cancel log
448:51 - the body you can do so but i think we
448:53 - have done that quite a few times so i'm
448:55 - going to omit that then i'll copy and
448:58 - paste
448:59 - my response so again if the name is not
449:02 - provided meaning if the property is not
449:05 - there or if it's just empty i'm sending
449:07 - back to 400 however if i'm successful
449:11 - then i'm just going to take my array
449:14 - i'll add that extra person and i'll send
449:16 - it back now i'm not going to add the id
449:19 - i'll leave that one blank because
449:21 - eventually database will do that for us
449:23 - so i don't really see the point of doing
449:26 - that manually so i'm going to go back to
449:28 - my api postman people and then again
449:31 - this is my error response and now let's
449:34 - copy and paste our status and then
449:37 - instead of sending that one person we
449:40 - created why don't we do this why don't
449:42 - we go with data
449:44 - and then of course the array name is
449:46 - people and now as you can see i'm using
449:48 - the spread operator and i'm just going
449:51 - to add that one single person so i'll
449:54 - save now of course we do need to change
449:56 - the route so it's not going to be api
449:59 - it's going to be postman
450:01 - and then people like so now let's add
450:05 - for example peter and the moment i click
450:08 - send there it is i have my success true
450:11 - and as far as data
450:13 - all the way somewhere should be peter as
450:16 - well so again we just grabbed that peter
450:19 - and then we added to our array hopefully
450:23 - this makes sense and now of course we
450:24 - can work on other http methods as well
450:28 - all right and once we're familiar with
450:31 - postman now let's work on the other two
450:34 - methods
450:35 - so now we're gonna be working on put
450:37 - method as well as the delete
450:40 - so i'm gonna scroll down and below the
450:43 - post login route i'm gonna go with app
450:47 - and then put now again this method
450:50 - is for editing the data so put method is
450:55 - for update
450:56 - and again the convention is following
450:59 - where if we have a list for example in
451:02 - this case that would be api and orders
451:05 - if we want to edit
451:07 - or delete we go with our route parameter
451:11 - where effectively we set up a route for
451:14 - api orders and then we go with colon id
451:18 - and this is going to get me that one
451:20 - specific item now please keep in mind
451:23 - one thing where this is a convention so
451:26 - technically there are multiple other
451:28 - ways how you can set it up but there's a
451:30 - reason why that convention exists and
451:32 - that's why throughout the course we'll
451:34 - stick with this convention i'll cover
451:37 - the official name of this convention a
451:39 - little bit later as well as a bit more
451:42 - details about it for now i just quickly
451:44 - want to cover both of the methods so i'm
451:47 - going to navigate back i have my put
451:49 - method that is for modifying the data
451:52 - and in our case what is the url for the
451:56 - whole list because that is api people so
451:59 - this was just for testing correct and
452:02 - then we go with api forward slash
452:05 - and then we go with people
452:08 - and then of course i also want to add
452:10 - that id so this is going to get me that
452:13 - one specific item and again the reason
452:15 - why we're doing that because when we'll
452:18 - send our
452:19 - put
452:20 - or delete requests we'll send to a
452:23 - specific path
452:24 - so this is going to be that one item and
452:28 - if that item exists
452:29 - then in the body there's going to be
452:31 - data to update
452:33 - or in the case of delete there's going
452:35 - to be nothing in the body we'll just
452:37 - remove that item and you'll see how it
452:39 - works in a second so please be patient
452:42 - so we're going to go with people and
452:43 - then remember again we have route params
452:46 - and in this case i'm not going to call
452:48 - this person id i'm just going to say id
452:51 - just remember that we can call it
452:53 - technically whatever we would want and
452:55 - now in this case there's two things that
452:57 - i'm looking for first i want to get the
453:00 - value here in the params and remember we
453:02 - access that using the rec params and the
453:05 - second thing when it comes to update
453:08 - when it comes to the put request
453:10 - i'm also going to send something in the
453:13 - body why well because if i'm updating
453:15 - for example if i'm changing the name
453:17 - from peter to susan or whatever of
453:20 - course i also need to supply this value
453:22 - so you need to understand that there's
453:24 - two sides of this request
453:27 - not only we're looking for that specific
453:29 - item that's why we use the params that's
453:32 - why i specifically say hey i would like
453:34 - to get the item number one or item
453:37 - number two i also need to supply this
453:39 - value because otherwise what's the point
453:41 - of updating something so let's access
453:44 - both of those things let's say that i'm
453:47 - gonna get the id from rec params so this
453:51 - is going to tell me which item and then
453:53 - the second thing since of course i want
453:55 - to update that item i need that value as
453:58 - well correct so we're going to go here
454:00 - with const
454:02 - and i'm going to be again looking for
454:04 - the name and we'll say reg dot body
454:07 - and that's it that should do it so these
454:10 - are the two values that we're gonna get
454:12 - from our question and just to make
454:15 - things interesting i will console log
454:17 - them right now so i'm gonna go back to
454:20 - the postman and remember we need to
454:23 - change the url it's not gonna be api
454:26 - postman in this case it is going to be
454:28 - people and now you can select any of the
454:31 - ids whether that's one all the way up to
454:35 - the five so we go here with one
454:38 - and then as far as the value what is the
454:40 - value for the first one it is john so
454:43 - kind of makes sense if i'm updating that
454:45 - i go with peter correct so we have put
454:48 - request we have api and then people and
454:51 - then check it out the moment we send it
454:53 - now of course the request is hanging
454:56 - don't worry about that but in a console
454:59 - we should get api people and then the id
455:03 - and of course the reason why i don't see
455:05 - anything because i was smart enough and
455:07 - i didn't console log anything so i'm
455:09 - gonna go back with id name and you know
455:12 - what for timing let me just send back
455:14 - hello world okay let's go here
455:17 - let's actually send it one more time as
455:20 - you can see could not get the response
455:22 - that was the error this time in this
455:24 - case i am getting hello world so that
455:26 - worked beautifully and as you can see
455:29 - the status code is 200 as well and then
455:32 - in the console i have one
455:34 - and i have the repeater so this is going
455:37 - to be the id
455:38 - and of course this is going to be the
455:40 - value now if i'll change it of course if
455:42 - i'll say number two and if i'll send it
455:45 - again i get back my response and now the
455:48 - value for the id is due hopefully this
455:52 - makes sense so now of course at this
455:54 - point we need to set up the logic again
455:56 - we are going to set up the logic with
455:59 - our local data with our people array
456:02 - eventually in next examples we'll work
456:05 - actually with database but the main idea
456:07 - is exactly the same
456:09 - where from the postman while we're
456:11 - testing we're sending the id
456:14 - in the url basically we add that url
456:17 - parameter and then in the body we'll
456:20 - send the value so that part won't change
456:23 - just the functionality in here and as
456:25 - far as this functionality well since we
456:28 - have a simple javascript array first i
456:31 - would just want to get the person with
456:34 - that id
456:35 - if the person doesn't exist
456:37 - then i'll send back the error response
456:41 - and if the id does exist then i'll just
456:44 - change the value now i'm not going to be
456:46 - looking for the error message if the
456:48 - value is not provided we're going to
456:50 - cover that once actually we work with
456:52 - database i think is just going to be at
456:55 - the moment waste of our time so let's do
456:58 - it people
456:59 - i'm going to remove both of these
457:00 - console logs hopefully you understand
457:02 - how we supply both values in the postman
457:06 - and i'm going to start by
457:08 - creating a person and this is going to
457:10 - be equal to people
457:12 - dot find again i have the array so i
457:15 - have access to all the array methods and
457:17 - then
457:18 - if the person id matches
457:21 - to my params id then of course i'm going
457:24 - to get the person now let me check in
457:26 - the data notice i still have it as a
457:30 - number so i'll have to change the type
457:32 - as well so i'll say if person id is
457:35 - equal to a number and i'll pass in the
457:38 - id that i'm getting from my params
457:41 - whether that's one five or maybe it's
457:43 - going to be id that doesn't make sense
457:45 - all right good and if the person doesn't
457:48 - exist well then i'll send back the
457:52 - response now again in order to save us a
457:54 - little bit of time i'll scroll up and
457:56 - i'll look for any of my error messages
457:59 - since i just want to copy and paste and
458:02 - change some values around so in this
458:03 - case i'm going to look for this name if
458:06 - it doesn't exist
458:07 - then of course we have the error and in
458:11 - our case of course we just need to
458:12 - change it around if the person doesn't
458:14 - exist so if we cannot find that in the
458:17 - array then we're sending back 404
458:21 - remember that was the status code if we
458:24 - cannot find the resource and as far as
458:27 - the response we have success and of
458:29 - course it's going to be false and now
458:31 - let's go with message and in the message
458:34 - we're going to use a template string
458:35 - we'll say no person
458:37 - with id
458:39 - and then i'm just going to pass in the
458:41 - id
458:42 - so that's the first
458:43 - response if
458:45 - of course the person doesn't exist so if
458:48 - in the primes we enter for example value
458:50 - six
458:51 - we know that we have only one to five or
458:54 - abc now the second thing if the person
458:57 - doesn't exist now of course i just want
458:59 - to iterate over the array
459:01 - and for that specific person for the
459:05 - person whose id matches my params value
459:09 - i'll change the name since i'm expecting
459:12 - that one to be in the body again we're
459:14 - not going to deal with this error for
459:16 - now we'll do that once we work with
459:18 - database and we're going to go with new
459:20 - people
459:22 - new people here and we'll say people
459:25 - map so i'm iterating over my array again
459:29 - i'll reference each and every person as
459:32 - a person and i'll say if person id
459:36 - matches to that one i have in params so
459:40 - number id again
459:42 - then i'm going to say person name since
459:45 - that is the only other property i have
459:48 - is equal to my name now where i'm
459:51 - getting the name because i'm getting it
459:53 - from the body
459:55 - so if the id of the person matches to
459:58 - that one in the params then please
460:00 - change the name that i can find in the
460:02 - body if not
460:04 - then simply return a person return
460:07 - a person and now of course all the way
460:10 - in the bottom i'm going to go with res
460:12 - dot
460:13 - status and then we're sending back 200
460:17 - since the request was successful as far
460:19 - as the json we go with success or sorry
460:23 - not super we're gonna go with success
460:26 - true
460:28 - and then as far as data well now i'm
460:30 - sending back the new people so let's go
460:33 - back
460:34 - at this point i have two
460:36 - so let me change it back to 1 because i
460:38 - know for sure the
460:40 - first value was john so again
460:43 - the path is api
460:45 - people
460:46 - and then id of 1 and i just want to
460:49 - change it from john
460:51 - to
460:52 - peter so let me double check in data
460:55 - this should be john uh it's a good thing
460:57 - i didn't go
460:58 - with the idf2 since that one is already
461:01 - peter so now let me send it and check it
461:04 - out
461:05 - now i have success true
461:07 - and data
461:09 - of course is my array and instead of
461:12 - name being john
461:14 - for the person number one now the name
461:17 - is peter and of course if i'll do the
461:19 - same thing for example
461:21 - for the person number three again we
461:23 - send it back of course now i have three
461:25 - peters because i just keep changing
461:28 - those values again we're not persisting
461:30 - that data but while we're making
461:32 - requests you can clearly see how we are
461:35 - modifying this data and we do that using
461:38 - http put method
461:41 - and then of course the path
461:44 - is api people and then whatever the id
461:47 - and again the whole reason why is that
461:49 - happening because on our server we are
461:52 - handling that
461:54 - all right and the last method i would
461:56 - like to cover
461:57 - is a delete method so below the put
462:00 - method below the modify option i'm going
462:04 - to go with app and the method name is
462:07 - delete again the convention if you have
462:10 - a list is going with a list url and then
462:15 - add that specific id because the setup
462:17 - is going to be extremely similar to a
462:20 - put one now the only difference is going
462:22 - to be that of course in this case when
462:24 - we're deleting we're not expecting
462:26 - anything in the body
462:29 - the user hits the url for example api
462:32 - people and then one we just remove that
462:35 - sucker from our list that's it
462:39 - so let's go down where we have
462:41 - app delete and again the path is
462:44 - following where we go with api
462:46 - and then people
462:49 - and again let me stress one more time
462:51 - something where these routes are
462:54 - different
462:56 - when we talk about app.get and api
462:59 - people when we talk about
463:01 - app.post and api people or even if we
463:05 - talk about app.put and app.delete
463:09 - just because the path is the same since
463:12 - the method is different
463:13 - these are different requests that is
463:16 - crucial please don't think that just
463:18 - because you have a different method you
463:20 - have to set up a whole new path no
463:24 - you can have the same value for the path
463:26 - if the method is different that is
463:28 - totally different request so let's go
463:31 - here again with our callback function we
463:33 - should already be comfortable with this
463:34 - one we have rack and res and in this
463:38 - case i'm not gonna the structure out the
463:40 - id from the prompts i just want to
463:42 - showcase that we also have this option
463:45 - of accessing the params directly so
463:48 - first again i want to look for the
463:50 - person then we'll send back this
463:52 - response and yes oftentimes put and
463:55 - delete are going to be extremely similar
463:58 - and then if the person does exist then
464:01 - of course i'll just filter out the array
464:03 - and remove that person from the array
464:06 - since again the whole point of this
464:08 - request is to remove that person from
464:11 - the array so in this case
464:14 - you can actually copy and paste and i
464:17 - know that some of you might find that
464:19 - annoying but at the same time we do need
464:22 - to speed this up and start working with
464:25 - a database so hopefully you can forgive
464:27 - me i'm just gonna grab everything
464:29 - starting with the person all the way
464:32 - until the end of our error response d404
464:36 - let's scroll down copy and paste and
464:39 - this is what we're trying to do so i'm
464:41 - trying to find a person whose id
464:45 - matches that in the params and of course
464:47 - in this case i haven't destructured out
464:50 - the id right so i just need to change
464:52 - this around where i go with rack
464:55 - and then params and the id again the
464:58 - setup is exactly the same the difference
465:00 - is that i'm directly accessing the
465:03 - params object and if the person doesn't
465:06 - exist
465:07 - then we send back d404 so let's try this
465:11 - response
465:13 - i'm gonna go back to my postman again
465:16 - the api is people but we need to change
465:20 - the method right so now i would want to
465:22 - delete and since i want to test out the
465:24 - error and as a sign up you can send the
465:27 - body doesn't really matter we're not
465:29 - handling that on server anyway so it's
465:32 - really irrelevant but since i want to
465:34 - test out the error i'm going to go with
465:36 - abc so again the path is localhost api
465:40 - people and then abc and if everything is
465:43 - correct i should see the error and of
465:46 - course there is but something tells me
465:48 - that this is a different error so let's
465:51 - go back and check it out and of course
465:53 - the issue is following notice here in
465:56 - the json how i'm accessing the id now of
465:59 - course i haven't destructured it right
466:01 - in this case i went with rec params and
466:04 - then the id so i'm going to go with rack
466:06 - params and the id let's save it and
466:10 - let's try one more time again i'm
466:12 - looking for a person whose id doesn't
466:15 - exist so i'm gonna get the error and
466:18 - there it is i have success
466:21 - false
466:22 - and as far as the message no person with
466:24 - id of abc so i was looking for the
466:28 - person
466:30 - with id
466:31 - that's not in my array so that's why of
466:34 - course i got back the error response so
466:37 - now i'm gonna go back to our app delete
466:41 - request and here i just want to filter
466:43 - out the array and the way we're going to
466:45 - do that i'm going to go with const new
466:48 - people
466:49 - is equal to
466:51 - people.filter
466:52 - that's my array and i'm just filtering
466:54 - it i'll pass in my callback function
466:58 - and
466:59 - i'll reference each
467:00 - object with the person parameter
467:03 - and i'll just say if person
467:06 - id
467:07 - does not match
467:08 - the id found in rec dot params then
467:12 - return that person
467:14 - if it does match then it's not going to
467:16 - be included that's why we go with
467:18 - exclamation point and remember that we
467:20 - still get our id as a string so we must
467:23 - do the number one first and then only we
467:26 - go with params and the id so that's our
467:30 - new array without that specific person
467:33 - whose id
467:35 - matched the one in params so now of
467:37 - course let's just go with our return
467:39 - return
467:40 - res
467:41 - dot status
467:43 - here and this is going to be 200 of
467:45 - course
467:46 - and i'm going to go with json and we'll
467:49 - set up our object success is true
467:53 - and i'll send back the new people array
467:56 - so we're going to go with data and then
467:59 - new people let's save it
468:02 - and let me test that out e in the
468:04 - postman where of course now i'm gonna go
468:07 - with id
468:08 - that is in the array and that's gonna be
468:11 - number one so if i send notice how it is
468:14 - irrelevant if i send body
468:17 - again because i'm not handling that on
468:19 - the server anyway but
468:21 - if i take a look at my data
468:24 - well the person with id number one
468:27 - john is missing why well because his id
468:30 - matched to the one that i passed in the
468:33 - primes so now of course he was removed
468:36 - from the array so if i'll go with five
468:39 - same deal now the john is back here
468:41 - because again we're not persisting data
468:43 - but
468:44 - the person with id of five has been
468:47 - removed from the array hopefully this
468:50 - gives you a good understanding how we
468:53 - use other methods as well not just get
468:56 - and why we go with postman instead of
469:00 - setting up the front-end but before we
469:03 - cover
469:04 - router in express let me just stress
469:06 - something
469:07 - that yes
469:08 - while we're developing our server of
469:10 - course we'll use postman because you can
469:12 - clearly see how much faster it is i set
469:15 - up the route and i quickly tested
469:18 - otherwise if i would have to build a
469:20 - front end for every route that i'm
469:22 - creating i mean the process would be
469:24 - just very very long but at the end of
469:27 - the day
469:29 - when you set up the api
469:32 - the expectation is that there is going
469:34 - to be someone who's using that data now
469:37 - that could be on your own server so for
469:39 - example if you're building a full stack
469:42 - application with mern that's one of the
469:44 - options that could be decoupled
469:46 - application remember how i showed you
469:49 - a example where i have the api on my
469:52 - server but then there is a react
469:55 - application that uses it it doesn't mean
469:57 - that you have to build that front-end
469:58 - application yourself
470:00 - just be mindful that the whole idea of
470:03 - setting up the api
470:06 - is that someone is going to be using
470:08 - that data that's it that's all i want to
470:11 - say and now of course we can talk about
470:14 - router in express
470:17 - all right i think we're moving along
470:19 - quite nicely
470:20 - but as you can see the moment we're
470:23 - starting to have
470:25 - more routes
470:26 - and more functionality
470:29 - we have another issue and that issue of
470:31 - course is the fact that our app.js
470:35 - is getting quite busy and technically we
470:37 - don't even have that many routes so what
470:40 - is the solution well the solution is
470:43 - using express router where we can group
470:46 - those routes together
470:48 - and then as far as the functionality and
470:51 - actually set them up as separate
470:53 - controllers
470:55 - now eventually
470:56 - in the next example when we work with
470:58 - database i'll cover again the common
471:01 - setup
471:02 - which is called mvc basically it is a
471:05 - pattern it's not a rule but it is a
471:08 - nicely used pattern when you're setting
471:11 - up the api but we are missing the model
471:13 - part in the mvc pattern because we
471:16 - haven't connected the database so i'll
471:18 - just leave it at that just please keep
471:20 - in mind whatever i'm about to show you
471:22 - in this video and in the next yes it is
471:25 - a pretty common convention and pattern
471:28 - so
471:29 - i also suggest sticking to that now also
471:32 - i want to mention that in this video
471:35 - we will do a bit of copy and pasting
471:38 - meaning we'll have to refactor the code
471:40 - because i think this is a perfect
471:42 - example for us to set up the router
471:44 - where we already have some code so you
471:47 - can clearly see the benefits of setting
471:49 - up the router instead of me coming up
471:52 - with some empty routes and then saying
471:54 - that yes that is the best pattern so
471:58 - with that said first where we have the
472:00 - request the post request for api postman
472:04 - people i want you to change this around
472:06 - a little bit so as you can see i keep
472:08 - going back and forth in this case i want
472:11 - to go with api people and then let's
472:13 - just say postman again it doesn't really
472:15 - matter we're not going to make requests
472:17 - anymore from the postman in these
472:19 - examples anyway this is just about our
472:22 - code structure and then once we change
472:24 - this around i also want to move this
472:27 - login up just so it's a bit clearer what
472:30 - we're doing so take this login route and
472:32 - keep moving moving moving moving and
472:34 - just place it on top of your routes
472:37 - and there it is now of course i have my
472:40 - login and now notice the pattern
472:43 - whereas i have one route for the login
472:46 - but then rest of them i have api people
472:50 - api people api people postman
472:53 - api people id
472:55 - and hopefully you get the gist again i
472:57 - have api people id
473:00 - so wouldn't it be nicer
473:02 - if i could somehow group all the api
473:06 - people and also add one for the login
473:10 - but basically in a separate file and the
473:12 - way we can do that is by setting up the
473:15 - router now again common convention
473:18 - is just creating another folder
473:21 - so i just want to make sure that i'm
473:23 - actually doing that in the express
473:25 - tutorial let's create a new folder
473:28 - and common convention is calling this
473:30 - route and then you just come up with
473:33 - whatever name you want now in my case
473:35 - i'm gonna go
473:37 - off for the login because
473:40 - we're just gonna imagine that maybe
473:41 - there's going to be one for register one
473:43 - for logout or whatever
473:45 - and then there's going to be one
473:48 - 40 people so that's going to be for my
473:50 - api and people so let's set up these two
473:53 - files i will zoom in massively just so
473:56 - you don't think that i'm cheating so
473:58 - let's go here with alt js this is where
474:00 - i'll place my login one and also right
474:03 - away set up my
474:05 - people
474:06 - people
474:07 - just okay awesome i'll start working in
474:11 - people.js because it's going to be a bit
474:13 - interesting and then we'll do the same
474:15 - thing in the auth as well
474:17 - and the way we set this up we simply
474:19 - start by requiring the express so we go
474:22 - here express require and of course the
474:26 - module name is express and then instead
474:28 - of setting up the app we go with router
474:32 - and we explicitly get the router from
474:35 - the express so this is going to be a
474:37 - router instance
474:39 - that takes care of the routing instead
474:42 - of the app
474:43 - so
474:44 - we're not going to do the routing
474:45 - anymore in our app.js well sort of we
474:48 - will we'll use the middleware but as far
474:51 - as the specific urls we'll handle that
474:54 - in this routes people file and the way
474:57 - we set up the router we go with router
475:00 - and that one is equal to like i said
475:02 - express dot and then we go with capital
475:05 - letter router and then we invoke it
475:09 - awesome
475:10 - that's a great start we can save this
475:13 - sucker and now i want you to go back to
475:15 - app.js
475:16 - and don't grab the login that's why i
475:19 - set it up separately above all the
475:21 - routes but grab all of the ones with api
475:25 - and people so take these suckers here
475:29 - all the way
475:31 - up to delete
475:32 - basically stop at listen cut it out
475:36 - and then copy and paste in people like
475:38 - so okay
475:40 - great so now of course i have all my
475:43 - routes here
475:44 - now our next step is actually changing
475:47 - from app
475:49 - to router because i want the router to
475:52 - handle the routing so in my case i'm
475:55 - going to select all of my apps like so
475:57 - so i'm just doing that with command d
475:59 - in the visual studio code and
476:03 - at this point i should have multiple
476:05 - cursors like so and i'll set up my
476:08 - router
476:09 - and now all the way in the bottom
476:12 - i want to go with module
476:14 - not exports and of course at the moment
476:18 - i'm exporting my router
476:20 - and then once we export a router of
476:23 - course in the app.js
476:25 - i want to set up a app.use where i'll
476:28 - say yes for the path that starts with
476:31 - api and people
476:33 - i want to use my people router and the
476:37 - way it's going to look like we're going
476:39 - to go back
476:40 - and
476:41 - at this point we have people here and as
476:43 - a side note actually we need to cut it
476:45 - out but we're not going to use it here
476:48 - as well eventually the setup is going to
476:50 - be different so for now yes
476:53 - please cut it out and copy and paste in
476:56 - people but since we'll be setting up the
476:58 - controls we'll have to do that one more
477:00 - time anyway so i guess i'm going to go
477:02 - below the router i'm going to look for
477:05 - my people otherwise my functionality
477:07 - won't make sense and in this case
477:09 - remember
477:10 - we are sitting already in routes so i
477:13 - need to go two levels up and i still
477:17 - need to look for my data correct so now
477:20 - of course our functionality should work
477:23 - hopefully we don't have some weird bugs
477:27 - and then like i said in the app jess now
477:30 - of course i would want to use my
477:32 - app.use so i'm going to go below express
477:36 - json and i'm going to say app.use and
477:39 - now i need to set up that base route now
477:41 - what is my base route here well it is
477:44 - api and people correct
477:46 - because
477:47 - this is just my route and then in some
477:50 - cases i have the postman or i have the
477:54 - id
477:55 - that's it but the base stays the same
477:57 - okay awesome so we provide this path we
478:00 - say api and then people and now i want
478:04 - to set up that router
478:05 - and of course in order to set up the
478:07 - router
478:08 - i need to import it
478:10 - and you can call it people router you
478:12 - can just call it people again
478:14 - that is really up to you i'm just going
478:17 - to say people is equal and now we need
478:19 - to require it and remember we have a
478:22 - folder by the name of what routes
478:25 - and then we also have people file okay
478:28 - awesome we require our router
478:32 - here correct
478:34 - so that's our router and we're exporting
478:36 - awesome so we get the people and like i
478:40 - said with use we can use the path if we
478:42 - want so this is not going to be applied
478:44 - to all of them this is only going to be
478:46 - applied to the ones
478:48 - that start with api people and then we
478:52 - pass in the people we'll save it but
478:54 - there is a problem you see once we set
478:57 - up this router
478:58 - with a base path
479:00 - in the people
479:02 - actually we have a mess right now
479:05 - because we already have the base
479:07 - for our router in app js where we have
479:10 - api people and now in the people.js if
479:13 - you check it out we actually have api
479:15 - people forward slash api people so i
479:18 - fully understand that this is going to
479:21 - look a bit drastic
479:23 - but in order for this to work we
479:26 - actually remove everything we remove
479:28 - that base so we go here with just a
479:30 - forward slash why well because we
479:32 - already have the base here we have api
479:35 - people
479:36 - so that's how the route is going to
479:38 - start
479:40 - and then
479:41 - we just have the forward slash so this
479:43 - will match whatever i have in the
479:46 - address
479:47 - and since in the get and in a post both
479:50 - of them just have api people well i
479:52 - simply go with forward slash again i
479:54 - fully understand that this might look a
479:56 - bit confusing in the beginning but again
480:00 - the more routers you'll set up the
480:02 - easier it's going to get so this will
480:05 - just match
480:06 - whatever path i have here whatever base
480:09 - path i set up in my app.js so i'm just
480:13 - saying yes i'm using this people router
480:16 - and in the people since i already have
480:18 - base path in place i can simply
480:21 - reference it using the forward slash so
480:23 - this is going to match whatever i have
480:26 - in app
480:27 - and once i have spent what seems like an
480:30 - eternity on the base path i can keep on
480:33 - scrolling and again notice i have api
480:36 - people and then postman so what's the
480:38 - only thing that i need here it's just a
480:41 - postman because i already have api
480:43 - people so i remove this sucker here
480:46 - keep on scrolling
480:47 - then the same with id right we only care
480:50 - about this one that's the whole point of
480:52 - setting up the router so we can start
480:54 - splitting up our functionality in
480:57 - multiple files same goes with this last
481:00 - id
481:01 - and even though i think i said that
481:03 - we're not going to use the postman i do
481:05 - want to quickly check
481:07 - and i'm going to go with get simple if
481:09 - the get works trust me the other ones
481:11 - work as well so we go here with api
481:14 - people we send but unfortunately i get
481:17 - the error hmm that's interesting so let
481:20 - me check i think the problem here is in
481:23 - the app.js
481:24 - i don't have the forward slash so let me
481:27 - try this one
481:28 - let me send it one more time and there
481:31 - it is now of course everything works so
481:34 - my apologies i forgot to add here
481:36 - forward slash that's why we were getting
481:39 - the error and of course everything works
481:42 - i can go with get i can get my list
481:46 - if i want i can also maybe delete a
481:49 - person so i'm going to go delete and
481:51 - we're gonna test three so let's see we
481:54 - send and as you can see
481:56 - the person with id of three is missing
481:59 - so as you can see our route works so
482:02 - that's the first step so now here's the
482:04 - challenge
482:05 - try to repeat the same thing with login
482:08 - now with login
482:10 - it is going to be a bit simpler because
482:12 - we don't have that long of a path but
482:15 - again stop the video and try to set up
482:18 - the login yourself and then once you're
482:20 - ready resume it and we're going to do it
482:22 - together
482:24 - how was it hopefully you were successful
482:27 - and i'm going to give it a shot so first
482:30 - remember we needed a file so in this
482:33 - case i do have auth js awesome
482:37 - so i'm just gonna cut this sucker out
482:40 - from my app.js
482:43 - and place it in off then of course i do
482:46 - need to have the boilerplate for the
482:48 - router so again let's go with express
482:51 - require
482:52 - we require the module by the name of
482:55 - express of course then we set up our
482:57 - router
482:59 - router and that one is equal to express
483:02 - dot router we invoke it then we change
483:06 - this value
483:07 - around like so
483:09 - and then we're just gonna go with module
483:14 - and then export and that one is equal to
483:17 - our router we do this
483:20 - then we navigate back to app.js and
483:23 - we'll have to import it as well so we go
483:26 - with auth i guess let's call it that
483:29 - and we're looking for auth file
483:32 - that's where our router is coming in and
483:34 - then of course i just need to set up my
483:37 - middleware myapp.use where i provide a
483:40 - path of what well of login and in this
483:43 - case i'm going to be more careful and i
483:45 - will add the forward slash and of course
483:47 - i'll set it up as auth so let's save
483:51 - this one and then the only thing we need
483:53 - to do in the login
483:55 - is simply change it around where i'm
483:58 - already handling the login in the app.js
484:01 - so forward slash login so again my route
484:03 - now is forward slash login so i simply
484:07 - go with the forward slash i already
484:09 - covered the route in the objects so
484:12 - i don't need to do that anymore in here
484:15 - and you know for this sucker just to
484:17 - make things a bit more interesting
484:19 - why don't we use the browser now keep in
484:21 - mind you can still use the postman if
484:23 - you want but i'm gonna go the browser
484:26 - out so we're gonna go with new window
484:28 - i'm gonna go with 5
484:31 - 000 here
484:32 - and of course this is going to be the
484:34 - small screen i have traditional form so
484:37 - let's go with some kind of name peter
484:39 - and i send and i have welcome peter and
484:42 - of course if that is the case i know
484:44 - that my functionality works so we are in
484:47 - good shape again probably the most
484:50 - confusing thing
484:52 - is this one where we use app.use to set
484:56 - up our route so all the routes
484:59 - that will start with this api people are
485:02 - going to be located in the people.js in
485:05 - the routes folder and in there instead
485:08 - of using app we use the router and then
485:11 - since we already have the base
485:13 - setup in the app.js
485:16 - when we have a route that exactly
485:18 - matches the base we just go with forward
485:20 - slash now if there is something else
485:23 - after the base route so some additional
485:26 - info of course then we go with forward
485:29 - slash which just means that we match the
485:31 - base path and then we add whatever value
485:35 - we want
485:36 - and hopefully you can see how much
485:38 - cleaner is our app.js
485:42 - where now we're splitting up the
485:43 - functionality in separate files
485:46 - for our routes beautiful i think we
485:50 - really clean up our app js
485:53 - but we're not out of the woods yet
485:56 - if we take a look at our auth js yeah
485:59 - this one looks somewhat clean but we
486:01 - need to keep in mind that we only have
486:04 - one request
486:05 - we only have one post request to our
486:08 - login however if we take a look at our
486:11 - people.js
486:13 - it is still somewhat of a mess because
486:16 - we have a bunch of functionality since
486:19 - of course we have more routes
486:22 - and of course a better setup is if we
486:25 - would be able to split this up into a
486:29 - separate file and i'm talking about the
486:32 - functions so imagine this scenario where
486:35 - we only would have a router
486:38 - then i'm gonna set up my method whether
486:41 - that's get post or whatever then i'm
486:44 - still gonna have the route but the
486:46 - functionality this one the controller
486:49 - is going to be in a separate file so
486:51 - it's going to be a separate function and
486:53 - you'll see how much cleaner our file is
486:56 - going to look like just in a second so
486:59 - again we need to head back to our
487:02 - express tutorial
487:04 - now i'll zoom in
487:06 - i'll create a new folder
487:08 - and again common convention is calling
487:11 - this controllers
487:13 - for the reason that there is a pattern
487:16 - called mvc so model view controller and
487:20 - then again we come up with the name in
487:22 - my case i'm going to go with jobs or i'm
487:24 - sorry not jobs i'm going to go with
487:26 - people and i'm not gonna set up one for
487:29 - the other one for the auth since there's
487:32 - only one but for people i will set up a
487:35 - controllers file by the name of
487:37 - people.js and here
487:40 - i just to set up first my functions
487:44 - and the way it's going to work we're
487:45 - going to go with const and then again
487:47 - you just need to come up with a name so
487:49 - for example for get request where i'm
487:51 - getting people i'm just going to call
487:53 - this get people keep in mind this is
487:55 - just a function so the name is really up
487:58 - to you and since i'm going to have the
488:00 - same functionality of course i need to
488:01 - keep in mind that i do need to have
488:04 - access to rack and res now it's really
488:07 - cool that once i pass this function as a
488:10 - reference it's still going to work so i
488:12 - simply go here with this rack res and
488:15 - set up the functionality now probably
488:17 - faster is just going to be doing like
488:19 - this where i cut out
488:22 - and then back into controllers i copy
488:24 - and paste now i know that some people
488:26 - might find this annoying but yes i'm
488:28 - purposely refactoring the code so you
488:31 - can see the benefits right away and i'm
488:34 - going to do that for all the functions
488:36 - and
488:37 - for a little bit it's gonna probably
488:39 - look messy
488:40 - where i'm gonna do the same thing for
488:42 - the post so i guess first i'm just gonna
488:45 - cut it out and then back in the
488:47 - controllers nothing routes in the
488:49 - controllers let's come up with that
488:51 - function as well so const and in this
488:54 - case i'm going to call this create
488:55 - person
488:56 - i'll copy and paste the code
488:59 - okay awesome
489:00 - back in the routes let's get the postman
489:03 - one so in a controller let's also call
489:05 - this const and create
489:08 - person
489:09 - and postman like so copy and paste
489:13 - that's my function then back in routes i
489:16 - have one for put
489:18 - so i think it would make sense if i call
489:22 - this for example update person again cut
489:25 - out everything
489:27 - starting with a function and then all
489:30 - the way to the closing parenthesis
489:33 - cut it out
489:34 - back in controllers we're going to call
489:37 - it const
489:38 - update person
489:40 - like so copy and paste and lastly let's
489:44 - deal with a delete one as well
489:48 - so let's keep scrolling
489:50 - again we cut everything out
489:52 - like so
489:54 - and then back in the controller let's
489:56 - create one for deleting the person so
489:58 - const
490:00 - cons delete person
490:03 - and copy and paste and if you remember
490:06 - which seems like an eternity go
490:09 - when we covered the exports i said that
490:12 - of course we can also use right away
490:14 - module exports and then whatever so for
490:19 - example in this case that could be get
490:20 - people or create person or
490:23 - create person postman now in my case i
490:26 - always prefer to do my exports all the
490:28 - way on the bottom where i say
490:30 - module exports now this is going to be
490:33 - the object and now i just want to access
490:35 - all the functions keep in mind
490:37 - it doesn't change the functionality
490:39 - functionality is the same where i'm
490:40 - basically exporting an object
490:43 - with bunch of functions so here i just
490:45 - need to reference their names so it's
490:47 - get people it is create person
490:50 - create person postman
490:52 - then update person and lastly it is also
490:56 - for deleting the person now one thing
490:58 - that is missing of course is the people
491:01 - like i said this is just going to be
491:02 - temporary
491:03 - so i'm going to go to the controller
491:05 - here
491:06 - and i'll copy and paste now in this case
491:09 - the path is correct because
491:11 - the route was already in a separate
491:12 - folder so
491:14 - that
491:15 - should still work and of course now i
491:18 - can save my controllers and in the
491:20 - routes what i need to do is of course
491:23 - import all of them
491:24 - so in this case we go with const and
491:27 - again i'll write away the structure all
491:30 - of them so let me just copy and paste i
491:32 - think it's going to be faster
491:34 - like so since the names of course are
491:36 - going to be exactly the same i
491:38 - destructure them and i'd structure them
491:41 - from
491:41 - require and then of course we're looking
491:44 - for controllers and then more
491:46 - specifically i'm looking for the people
491:49 - like so and once we have required them
491:51 - of course now we pass in the function
491:54 - reference so for example here i can say
491:56 - get people now i do need to add a comma
492:00 - and if everything is correct our
492:02 - functionality is still going to work
492:05 - so in the controllers we're still
492:07 - accessing rack and arrays
492:10 - and we're still sending back the
492:11 - response but of course the benefit of
492:14 - all of this work
492:16 - is the fact that our routes file is
492:18 - gonna get much cleaner so in here
492:21 - remember the name was create person
492:24 - like so
492:26 - and then we have one for create person
492:28 - postman
492:30 - and let's set it up like so then we have
492:32 - also one for update
492:34 - person and lastly we have one for the
492:37 - leading person right so we go here with
492:40 - delete person i save again i'm not gonna
492:43 - test all of them out but i'm gonna go
492:45 - with for example delete
492:48 - and i'm gonna look for four this still
492:50 - works
492:51 - i remove the person number four
492:54 - and also if i check out the get one
492:57 - for the people this also should get me
493:00 - back the array so i know that my
493:02 - functionality still works but i nicely
493:04 - cleaned out my file now lastly before we
493:08 - talk about the databases i just want to
493:11 - mention that when it comes to setting up
493:13 - the routes
493:15 - we actually have two flavors so i'm
493:18 - gonna comment these ones out and i'll
493:20 - show you another way how we can set up
493:23 - the routes and effectively the benefit
493:25 - is that we can set it up in fewer lines
493:28 - of code keep in mind the functionality
493:31 - is going to be exactly the same so again
493:33 - this is going to be the case where it
493:36 - comes down to your preference if you
493:37 - prefer setting up your routes this way
493:40 - you can definitely do so there's no rule
493:42 - against it if you prefer the method that
493:45 - i'm about to show you then of course you
493:47 - can use that one instead so we go with a
493:51 - router and then we go with route and
493:54 - then in the route i set up the path
493:57 - and again since there's get and post
494:01 - that match exactly what i have in base
494:04 - same situation i just set up the forward
494:06 - slash and instead of setting up them
494:08 - separately for example get and post i
494:12 - can just chain them so chain one after
494:14 - another so i go with get that is of
494:17 - course my method
494:19 - that is not changing and then i need to
494:21 - pass in my controller function okay as
494:25 - you can see
494:27 - almost the same in this case however i
494:30 - can change it now the method names did
494:32 - not change the paths did not change
494:35 - they're still
494:36 - actually referencing the base path in
494:38 - here what we have in app.js but since we
494:41 - can chain it we can simply write it in
494:43 - one line of code so of course the
494:45 - callback function is gonna be create and
494:49 - i believe it was person so create and
494:52 - person like so
494:54 - then we have of course one for the
494:56 - postman so in this case of course it's
494:58 - not going to change it's pretty much
495:00 - going to be the same logic where we go
495:03 - the router route
495:05 - like so and then we go with forward
495:07 - slash postman and then of course i want
495:10 - to chain
495:11 - dot and i believe it was post right and
495:13 - then we go with create person postman
495:17 - and then we can again set up one line of
495:20 - code for the put and delete so in this
495:23 - case i think i'm going to just copy
495:25 - where i have router dot route then we
495:28 - set up our route and in this case it is
495:31 - going to be forward slash and then id
495:34 - and then we have two we have one for put
495:37 - and we have one for delete so we go with
495:40 - delete and then as far as the callback
495:42 - functions we go with update person
495:46 - and also we have delete person and
495:50 - finally let me just stress it one more
495:52 - time where whichever setup you choose is
495:55 - really up to your preference
495:57 - functionality is exactly the same we go
496:00 - with router route and then we can just
496:03 - chain our methods and add the callback
496:06 - functions
496:07 - now in this case we set up each route
496:11 - separately so for example if you have
496:13 - multiple urls that match yeah you're in
496:16 - good shape you can just set up router
496:18 - route pass in the url and then chain all
496:22 - the methods and lastly let me just
496:24 - quickly test it one more time since i
496:26 - made some changes i send it and there it
496:29 - is i successfully get back my people so
496:33 - with this in place
496:35 - with our router in place
496:37 - with the fact that we have covered all
496:39 - the methods
496:40 - the get post put and delete i think
496:44 - we're ready for the next level where we
496:46 - connect our server

Cleaned transcript:

this eight hour course will teach you the fundamentals of node.js and express so you can start creating backend and full stack web apps using javascript this course was created by john smilga john has created a bunch of courses including many of the more popular courses on the freecodecamp youtube channel john's teaching is very handson so you will create a bunch of projects while you're learning what's up everybody this is john from coding addict and welcome to node and express tutorial video where we'll cover fundamental building blocks of node and express js framework now since i want everyone to be on the same page we'll start the series with node and express fundamentals and gradually move to more complex topics we will build complex rest api with express.js as well as fullblown mern application in this comprehensive node.js course you'll not only learn fundamentals of node but also many related technologies like express.js framework mongodb as well as mongoose the main goal of the course is to show you how to build modern fast and scalable serverside web applications with node like in all my other courses to solidify our knowledge we'll build a bunch of cool apps and go through the steps of deployment as well lastly let me just say this if you're like me and you enjoy learning new tech by building projects instead of going through the slides you will enjoy this course all right and let's start by answering the most obvious question first what is node.js and even though there are plenty of good answers out there the one that i like the most is this one node.js is an environment to run javascript outside of the browser node.js was created in 2009 and it's built on top of chrome's v8 javascript engine as you probably are aware of every browser has an engine a tool that compiles our code down to machine code and chrome uses one by the name of v8 in extremely simple terms the creator of node ryan dahl ripped out the v8 engine and build node on top of it since the moment it was created node has evolved tremendously and while there are many things to like about node i particularly enjoy large community around node since that tremendously saves time on feature development as well as the fact that with the help of node it's never been easier to build full stack apps since both front end and backend are essentially built in the same language and you guessed it that language is our beloved javascript as far as course requirements go there are not that many my expectation is that you are familiar with basic html elements simple css rules and have general understanding of javascript especially es6 callbacks promises and a sync await since this is a node course and i already have tremendous amount of node content to cover i'm not going to spend too much time on javascript language fundamentals while you can still follow along with the course without knowing basics it's crucial if you want to understand how stuff works behind the scenes as a side note if you need to brush up on the javascript fundamentals i have a youtube channel called coding addict where i post a bunch of cool javascript related content specifically you might be interested in js nuggets playlist where i cover a bunch of useful es6 features as well as asynchronous javascript topics so if you need to jog your memory on javascript fundamentals i suggest going to youtube look for the channel by the name of coding addict and then more specifically the playlist by the name of javascript nuggets when it comes to course structure it goes something like this in first section we'll get familiar with node.js as well as my dev setup in the second section we're going to install node.js and quickly cover some general differences between browser.js and node.js then we'll spend some time on node.js fundamentals in section 3 and after that we'll learn what is express.js in section number four and once we're done with node and express fundamentals so once we're done with pleasantries then we're after the races where effectively in every section after that we will build a bunch of cool node.js apps all right and before we install node let's quickly cover some major differences between browser javascript and node.js so essentially how node.js apps are different from the browser javascript apps and let's start with the biggest one when working on node.js app you have no access let me repeat no access to browser apis since well they don't simply exist in node there is no browser so there's no dom there's no geo location no fetch and all the other cool browser goodies you see unlike browser apps that are interactive for example user clicks the button or toggles the nav and that sort of thing with node we build server side apps and i know it's hard to picture that right now but our node apps will only consist of pure logic without the graphical interface on that note you know how in browser apps we use a bunch of cool things available on the window object yeah sorry to break it to you but that's also not available in node so at no point in the course we'll write document.queryselector all right and once we have covered things that node.js does not have let's switch gears and see some of the goodies that node has to offer for example unlike browser we can access file system info about our operating system respond to network quests just to name a few also another major benefit of node is the fact that it's based on versions so unlike browser apps which depend on the user's browser our node app depends only on node.js version it was built in so in other words if we build a browser app and if our user's browser does not support a specific feature it is our responsibility to fix it otherwise our app might have bugs correct but when we're done building our node app there's no rule that we have to upgrade to a newer node.js version and possibly break our app we simply can keep running our node app in the version it was built in and without any worries go on about our day lastly unlike browsers where modules are optional in node.js you have access to modules by default and it's hard to imagine a node app where you're not going to use them as a quick side note under the hood nodejs uses common js library for the modules and while the general idea is exactly the same as for the es6 modules that we use in the browser syntax is a bit different as far as the install it's as straightforward as it gets just navigate to nodejs.org pick a lts version answer yes to all the questions and if you don't get some weird bugs congrats you have installed node in order to check if everything went correct just type node version in your terminal and you should see the version number if you don't you'll have to troubleshoot the error now as much as i would like to help when it comes to install it's impossible for me to troubleshoot your local setup so when it comes to troubleshooting install errors i strongly suggest using your favorite search engine instead typically within a matter of minutes you'll see a bunch of useful solutions to your exact problem lastly let's also talk about versions as you can see at the time of the recording i have two options 14 lts or 15 current one if you read the note docs you'll see that for production apps they always suggest using lts which stands for long term support and therefore i will also suggest the same but as far as tutorial i don't think you'll have any issues if you use the current version instead now also since you're watching this in the future your version number most likely is going to be greater than 14 basically greater than mine i definitely suggest installing the lts option that's offered to you instead of downgrading to my version and if you're stressing about content being out of date let me assure you that everything we cover in the course will work perfectly fine with your current note version and eventually if some bugs do creep in i will definitely update the course content so long story short just install your current lts version whatever it is and you'll be in good shape so in my case it is 14 i have two big buttons and of course since i would want to go with lts i'll click on left one then notice we are getting the download package and now i just need to go to my downloads and then crack it open and then like i said we just need to answer yes to all the questions so we go with continue continue and yep i would agree and again we just install and then we'll be prompted for our passport and once we add that one we should be in good shape and then like i said once the install is complete and yep we'll move this sucker to the trash then if we go to our terminal and if i massively zoom in and if i type node version there it is i should have my version number which in my case of course is 14. if you also can see the node version in your terminal you are in good shape and you can continue with the videos if not please troubleshoot it because otherwise everything we're about to do next is not going to work since you haven't installed node on your computer install is complete hopefully we all have node on our machines now what what do we do for contrast with vanilla.js it was somewhat easy right we create index.html jam our javascript code whichever way we prefer and browser does the rest it evaluates our javascript code but what about node how do we get node to evaluate our code and effectively we have two options a repl which stands for read eval print loop and cli executable which just means running our app code in node if i have to be perfectly honest reply is for playing around and cli is essentially for everything else in fact this is going to be the first and most likely the only time we'll use a rebel in this course and after that cli is going to be our best friend how do we spin up the rebel well we go to terminal and in terminal we simply type node and then no arguments nothing we just press return or enter however you would like to call the button and that's it now notice we have this little angle bracket that just means that we are in the rebel and once we are in a rebel we can do reply things what would be a first ripley thing we can do well we can simply type our name so cons and the name is equal to john and there it is of course now i can access name and my name is john as you can see you're not going to write anything serious in here and if you have written any vanilla javascript apps you know that of course we can also do the same thing in a browser console so we can also evaluate some code there but of course we're not going to write anything serious in a browser's console so the same thing is for reple yes we can come here we can play around but when it comes to serious applications of course you'll pick a cli executable instead and in order to close the repo we simply go with control and c and as you can see we have suggestion that we need to press it again and now of course we're out of the rebel not bad that bad we now know how the ripple works but what about a more serious node application how do we get node to evaluate our code well we would need to start by creating a project right so back on my desktop i'm going to create a new folder and surprise surprise i will call this tutorial why well because we'll do tutorial things and i'm going to say tutorial now of course if you want you can add node but i'm just going to leave it as a tutorial and then of course we'll have to use our text error in my case like i already previously mentioned i'm using visual studio code and my preferred method is just drag and drop and then instead of the folder what i would want is to create a new file and this is the case where you can literally name it whatever you would want and in my case i'm going to go with app and js and in this app.js okay now we want to write some more serious node program and the program is going to be following where there is a const so there's a variable by the name of amount and as a side note i'll make this bigger and i'll probably bump up the font size just so we can see a bit clearer so we're gonna go with const and not also close the sidebar hopefully you see that i have the file by the name of app.js and like i previously mentioned we're going to have a variable by the name of amount and it's going to be equal to 12 and now let's set up a if condition where if amount is less than 10 then we simply cancel log small number and otherwise we'll just say that the number e is large so we go with if and we're looking for amount is less than 10 and if that is the case we go with console log and we'll just say small number and otherwise if it is of course equal or bigger than 10 then we go with console log and we say large number and at the end of the day we just write console log hey it's my first note up as you can see an extremely complicated functionality and in this case i'm just going to set up the template strings so you understand that of course we can use them here as well i'll say hey it's my first node app and if you want of course you can jam the hello world there somewhere as well since that is the traditional approach with the first program and then in order to execute this code we effectively have two options i can navigate back to my terminal and i can zoom in like so and of course now i'm in a root so i would need to navigate to the desktop and probably the fastest way is just typing cd and drag and drop my folder here okay so now as you can see i'm in the tutorial and in order to execute my code i just need to type node and then app.js now keep in mind that technically i could have done that from the root we just need to provide the full path where i go to users blah blah blah and then tutorial and of course the file name is app.js and let me bump up the font size even more and the moment we run it check it out we have large number and hey it's my first note app now if you don't believe me we can go back and we for example can say that the number is nine and of course again we would need to run the code and we're gonna go with node and then app js beautiful we have small number and we still have our hey it's my first node up again the whole point of this line here is just to showcase that not only we can use quotation marks but also we can use the template string as well so that's one option but if you're familiar with vs code you know that it has this cool feature of integrated terminal where effectively we have our terminal but it is right away pointing to our folder so we don't need to do this whole dance where we navigate to the folder and then run the app we simply can open this up and the shortcut is control and tilde and also keep in mind that of course you can navigate through the tabs the problem is that i always forget where it is and effectively we need to go to view and then you're looking for this terminal command here as you can see this would be a shortcut and tilde and in here we have nice suggestion that we already located in tutorial folder and what do we need to do well again we just go with node app.js why well because that is my file name so for the remainder of the course i'll use the integrated terminal that comes with this code just understand that both of them effectively do the same thing and there it is now i run node app.js because that of course is the file name and i have small number and hey it's my first node app and that's how we can evaluate a more serious code using node as i note if at any point during the course you need to compare your code to mine just navigate to website johnsmilk.com and the website is johnsmega.com and then either in the project page or in the homepage you'll find node express tutorial project so in the homepage you'll find it in the latest project so just keep on scrolling but if it's not here it's definitely going to be in the projects page and you can even filter it in order to save some time so look for node in here like i said the project name is node express tutorial and not any of these links will get you to the repo and at this point you can either clone it 4k or just simply download and you're looking for this node tutorial and in here you'll find all the folders as well as the files now keep in mind that eventually when we start working on express we'll have to get this repo anyway because i'll use it for starters since i have prepared some assets for you some assets that we're going to use in our examples so this is really up to you if you want you can get it right now just keep in mind that you'll have to get it later anyway and once we have executed our first code in node let's quickly cover the concept of globals or global variables in node and the emphasis is on the word quickly yes there are more global variables available but the idea is not to spend half an hour in slide bill instead i would want to give you a general idea and as we progress with the course don't worry we will implement them and that way you can right away see them in action not just some random general description and before we continue let me just mention that throughout the tutorial the code from the previous video i'm going to save in a file so for example remember our first complex app with a mount and all that so what i did i created a file name by the one hyphen intro js and then i just copy and paste it this is what i'm gonna do throughout the no tutorial part of the course so that way you can always have access to the code and if you ever need to you can jog your memory now if you don't want to use my one if you're adding your own comments and all that i would also suggest doing that where essentially just create a file just dump it and then that way you are slowly progressing on the course and if you ever need to go back and refresh your memory you always have that option and keep in mind that if you would want to run this file you simply go with node and then whatever the file name right so in my case that would be one dash intro js again i'm going to keep on numbering them because i'm just annoying that way but you don't have to that is really up to you so back to the globals when we work in vanilla.js applications we know a very cool thing is the fact that we have access to the window object and the reason why it's so cool because in the window object we can get a bunch of useful things right so for example we can get a query selector so i can select a node i can get builtin fetch and hopefully you get the gist now i don't want to rain on your parade but you know there's no window why well because there's no browser so there's no window object so if you'll try to access window node will spit back the error and most likely your app will crash now there are some globals of course there is this concept of global variables and essentially what global variables means that anywhere in your application you can access them so no matter how complex my application gets how nested it gets or whatever i'll always have access to those variables and again let me repeat these are just some of the variables of course there's more and i'm not going to spend hours and hours talking about them i simply want to give you a general idea and then like i said we'll start using them and you'll see them in action and in my opinion that's just going to make it way clearer about what in fact they're doing and some of the useful ones we have their name so that would be underscore underscore their name just going to give us path to current directory then we have also underscore underscore filename which as you can see is going to give us a file name then we have require which is a function to use modules as well as the module that would be info about the current module now these two will literally cover them in the upcoming videos because our next big topic is going to be modules so for time being just remember that we have require and module and you'll see them in action in no time and then we have a very very very useful one and that one is a process and why it's so useful because it gives us a info about the environment where the program is executed because we need to keep in mind when it comes to a node app at the moment yeah we're executing that on our machines but when you deploy for example your api so for example your server right where is it sitting it is sitting on digital ocean or herald core or whatever so that of course is already a different environment and of course based on that environment you can make a bunch of decisions in your application again if you'll take a look at the process right now it's just going to be a giant object of gibberish data but trust me as we're progressing we the course will find a bunch of useful properties that we'll implement in our application now any of them you can simply console log and you'll get that useful data so you can just run console log and then for example their name again i'm not going to cancel log all of them probably the biggest one is going to be the process like i said you'll get a bunch of properties that at the moment will look like a gibberish and i simply need to save and of course then we go with node and app.js we run that and there it is now of course this gives me the path so if you're interested of course you can console log rest of them as well but in my case i'm going to stop with their name now also very quickly yes you have access to the console so as you can see in order to cancel log we have to use the console so that is also something that is available globally then just like in the event ljs we have set interval as well as set timeout so you can run these ones and i'm not going to run both of them but i'll show you set interval very quickly just so you don't think that i'm cheating and the way it's going to look like of course we have our callback function and then i'll say that my interval is going to run every second and i must type hello world otherwise well what kind of tutorial is this and again we simply go back to node and then app js and as you can see now after every second i have hello world in console and in order to stop it remember the command was ctrl and c and before we move on and start talking about the modules let me also mention something else where essentially we don't need to type node and then app.js you can simply write node and then app however throughout the course i'll probably keep on typing js just because i'm annoying that would be the first thing now the second thing and this is not a node thing this is actually a terminal if you don't want to type it you can simply go back to the previous command and in order to do that you need to press on arrow key up and check it out the moment you press notice that was my previous command and then i have one before that so in my case that is node and then app.js again you don't need to add that just extension but probably i will and then you just go back to the previous command and then press and again you just execute that command and of course if you want to clear the console again this is not a node thing this is a terminal i just type clear and lastly to answer the question that's probably bugging you the most we always have to just type node and then the file name because as we're going to be testing a special in tutorial it will probably get annoying and the answer is yes but only for now once we learn about npm the external packages which at the moment i fully understand doesn't make any sense at all then there's command that effectively will restart our application so we'll have to install some thirdparty module some external library and that will do the job of restarting the application for now yes all throughout tutorial up until the point where we cover that external library and external libraries in general yes we'll have to type node and then whatever is the file i know it's a little bit annoying but i just don't want to skip ahead i want to get us there with a full information of what is happening so with this in place with clear understanding of the global variables in node now let's move on to our next topic which is going to be modules in node beautiful and once we understand the globals in node now let's talk about the modules and first let's return to this command notice we have here node and then app.js probably the question that you have is well does that mean that all my application needs to be in this one file and the answer again is yes and no yes you'll execute one file but you'll split your code in modules otherwise that would be literally insane to jam all your code in one file and effectively i'll just show you with an extremely complex app and of course extremely complex is in the air quotes right now and you'll see why we'd want to use the modules in the first place so in the next video i'll give you official intro with a bunch of gibberish and all that but for time being let's just build super complex app and then see why i would want to use those modules in the first place and if you have any familiarity with es6 modules if you have worked with them in vanilla.js or in react.js you're already in good shape the syntax is going to be tiny bit different because you know it uses common js but the general idea is exactly the same and we start with a simple function by the name of say hi you guessed it and then this function is going to be looking for the name parameter and then inside of the function what do we do we simply cancel log and we say hello there and then whatever is the name of the dude or the gal that is being passed in as a parameter and of course we can invoke it and i can say say hi and then pass in susan for example and in order to make this interesting i'll set up some variables as well so i'm going to say const john is equal to john and you guessed it since there's a john there also has to be a peter and hopefully you get the gist so imagine we would have a bunch of names and then we have probably more functions than this one but for time being this is just going to be say hi we copy and paste we invoke this function i guess three times one for johnny boy one poor peter and then the first one we already have for susan and what do we do we run node app or app.js we run that and there it is now of course in our concert we can clearly see hello there susan blah blah blah now wouldn't it make sense if the names would be separate as well as this function or the future functions that we're going to create would be in separate files and then we can access them all throughout the application and that way of course we would have smaller files and more structure to our application and that is exactly what the modules allow us to do and that's why we'll move on and start talking about the modules in the next video beautiful and once we understand the main problem with this code where again the moment code is technically still tiny but as you can see it is getting bigger and more annoying with every line now let's talk about the modules and i guess let me just give you the main idea first and then we'll talk about the implementations and all that good stuff so first of all what are the modules again if you're familiar with es6 modules you already have the idea but essentially that is encapsulated code and the key here is that we're only sharing what we want so we're only sharing minimum how would that look like in real life well i can go here with secret and then i can type here super secret and then since this variable is in this file as we can see you can access anywhere okay so by mistake i can just access it i can override it now of course you can make an argument that i mean it is made with cons but hopefully you get the gist this is available to me everywhere in this file so once we set up the module you'll see what are the differences now node uses common js library under the hood that's what makes it happen and then every file in node is a module again let me repeat every file in node is a module so those super powers that we will cover in just a few seconds we have them by default we don't need to do anything we don't need to go to the store and buy some javascript code no we just get them by default and the way the modules work well we simply need to create a new file right and i'll right away set up the names here because of course eventually this code will be sitting in the file name by the three hyphen and then the module basics or whatever but the names as well as the function well it's going to be in a separate file so what i'm trying to say is that in a root of course there's no folders or nothing so everything is rude i'm going to go with four again i'm doing that because eventually this is going to be three hyphen modules something i'm gonna go with maybe names or you can type first module whatever you would want and i'm just gonna go with names.js okay awesome and then i'll take these three variables from my app.js and i'll copy and paste in the names and then also what i would want is to set up one more file and of course this one will be five and i don't know we can say second module or so i'll say here utils something generic so we set that up and now of course what i would want is to grab this function from the mgs and copy and paste in the utils and now sixty four thousand dollar question is this app gonna work or is it gonna break and of course the answer is it's gonna break because we have no access right now to say hi or to john or peter so why don't we go to the names and console log something and as i said yes you can console log this in the app.js it is a file so by default it is a module but since we'll do most of our work in the names and new tools first why don't we go to names and that way we can also see how we can run the file just by using node and what i would want to console log is the global by the name of module so in the names go below or above the variables doesn't really matter and go with console.log and then module and remember to run node and then whatever is the file name so in my case it is four dash and then names js you run this and you'll notice something pretty pretty cool where we have the object and in that object we have quite a few properties now the one that i'm interested in the most is this exports one and it tells me that this export is an object and the way the common js syntax works whatever i'm going to dump in that export i'm going to be able to access anywhere in the application so that's the key remember we're only sharing the minimum so it's up to us to set those values in that export object we decide what goes in there previously remember secret was accessible everywhere in my app.js now in the names i can be hey you know what john and peter yeah i'm sharing them anywhere in application we can access that but the secret variable no this is just going to be local so i'm going to add here i guess the comment by the name of local and that way at least we understand so this is going to be i mean i'm not going to use global but i'm just going to say that share so we're sharing this with rest of our application and then if i know that this is a object and it is sitting in the module how does that work well we go with module then it is an object so we go with export and we have multiple ways how we can set this up but the most basic one will simply say that yep it is an object and inside of that object there's going to be two properties john and peter now i can probably already guess that we're using a es6 syntax since the key name is exactly the same as the value well we can simply pass it right so we have john and peter so now what happens in the app.js we can access them so i can go back and this is the case where we'll need to run that require remember in the globals we talked about this function so in order to share them we need to use module.exports and essentially i'm setting up the object like so where i go with whatever values i would like to share now in order to access them i need to go with require and i can assign it to a variable or i can simply require now in our case we will assign it to the variable and i'll use the same type of syntax where i'm going to go with names just so we can console.log that and this is going to be equal to require so that's my function and as a parameter we need to pass in where the module is located so where is this data coming from and always always always always you will be setting up your module you have to start with dot now sometimes your modules will be two levels up i don't know three levels up whatever then of course you'll start with dot dot but you'll always start with this one dot because there's also going to be a third party modules and there's going to be builtin modules in node and then we'll use just these quotation marks again super super important every time you create your own module you'll have to start with dot and then forward slash so essentially you're giving a path now in our case what is the path well i'm looking for the names right so i set up here the path and then if i cancel out the names i should see something pretty pretty cool where i go with names and there it is now i'm going to run node and then app js now keep in mind we're not running names anymore we go with node and app.js now of course still complains that we have no access to hi let me comment this one out so let's say node and app.js and check it out now of course we have the object with john john and peter and peter and we explicitly said what we would want to export so we go with exports and that way no one has access to the secret one so this secret one is only for this file and of course we can do the same thing in the utils as well right so we have the say hi and we go with module and export and i can just simply set it equal to now the reason why i was setting this up as a object because i had multiple things at john and peter and don't worry in the next video i'll show you alternative syntax how you can also set this up but in this case i have object and then of course i'm setting these properties and i said note this is just my preferred way of actually using the exports again there's multiple ways how we can do that and i will cover the other ways in next video but this is just my preferred method that's why i right away set my exports equal to an object and then pass these two properties and in utils since i only have one thing i'm just gonna go with say hi that's it i'm saying that i'm gonna be exporting my function so say say hi like so and once i have exported my function now of course i need to go back to the app.js import my function the same name and i'm going to go with say say hi and that one is going to be coming from the different file of course so we go with five and then utils and notice here how we don't need to pass in the js if it is ajs file we just simply omit the extension as long as the file name of course matches and then i can remove now if you want you can cancel log but i already know that i'm gonna have the function over there i'll uncomment my say hi so now of course there's going to be no error and let's make a clear console and again we run the node and then app js and there it is now of course we have a different error where it says well john is not defined all right but i know that john is sitting in the names right so here we have multiple flavors either you can destructure it so instead of going with names i can go john and peter that is definitely one option or i can go with property names right so i can say names and then john and then the second one is names and peter names and peter and now hopefully everything works otherwise you're probably thinking that i'm just messing with you there it is now we have hello there susan john and peter and effectively what we did we separated our concerns again the main idea is that every file by default is a module and then when it comes to a modules we are in charge what we are sharing and in order to export or make it something available from this module we go with module exports and then we just set up the functionality whether this is going to be a object that we're exporting or we're simply exporting as a function so we set this equal to to the exports and if you're familiar with es6 modules as you can see this is very familiar to the export default and then whatever you're exporting as default whether that is a function whether that is a react component or whatever notice i'm exporting as default so of course when i'm importing this in this case app.js well i already know that this is a function so i can name this whatever i would want and the same goes here since i'm exporting this as object i can call this shaken bait as long as i access it later of course i'll be able to access the property as long as the name matches to whatever i set up over here so let me save this and now of course we can talk about our next topic all right so far we know two flavors one if we want to export one value we just set module export equal to that value and then of course wherever we want to use it we just import it set it equal to some kind of variable and of course once we use that variable we have access to that value and the second flavor is if we have multiple values then we simply set module exports equal to an object and then in that object we set up the properties however there's also another way how we can do that and essentially it is called export as you go and the way it looks like first i'm gonna set up a new file and i'll call this six and i'll call this alternative flavor now again naming is really up to you since that is the hardest thing in programming and then i'm going to come up with one array and i'm going to call this items and that will be equal to item one and item number two and then i'll set up a object and i'll say const person is equal to a object and there surprise surprise we'll go with name property and set it equal to bob and i'm purposely adding multiple data types just so you don't think that we can only export variables or functions and in here we have two options either where we are setting up the value in this case items i simply go with module exports and then whatever is the name and of course in this case i'm going to keep the items but notice the syntax where instead of going with const items i right away go with module.exports or if you are a true rebel you can do something like this module exports set up the property for example single person and set it equal to your person object why we are able to do that because if you remember in the previous video when we console logged module exports it was an object right so what are we doing here we're setting up a property on that object and set it equal to an array and here i set up another property and just set it equal to a person keep in mind of course i can still write simply module exports and then the person but since you might sometimes see this type of syntax as well i wanted to cover that and now of course we save alternative flavor.js and you're probably not going to be surprised that if we navigate to app.js and in this case i will call this data because i'm getting a object and on that object i have two properties and i need to come up with some kind of name now as always this name is really up to you you can call it shake and bake you can call it uncle bobby whatever you want in my case i'm gonna go with generic data we go with require again we're looking for the file by the name of alternative flavor and in this case i'm not gonna do anything with it apart from console logging and if i navigate back to my integrated terminal and run the node app.js there it is of course now i have the items as well as the single person now please keep in mind one thing where this syntax whether the first line or line number six at the end of the day is exactly the same like we're doing over here yes the syntax is a bit different but at the end of the day you just make these values available somewhere else in your code now just because i prefer this type of syntax most likely throughout the course you'll see this approach but if you prefer this one instead be my guest at the end of the day it is your application and you are the one who is going to be maintaining it and before we move on to built in modules as well as thirdparty modules let me throw you a mind grenade and i'm going to start by removing this console log in the app js like so and i'm going to create a new file with the same exact name a mine grenade as always if you would like to call this differently that's totally your option and i'm going to go with mine grenade like so and js and in this file i'll create some basic functionality and by the way let me save app.js so let's go with const num1 is equal to 5 and then const num 2 is equal to 10. of course there has to be a function that adds these values as always with every tutorial so go with add values just for the sake of it i'm just going to go with good old function keyword and the old setup meaning not the arrow function syntax and simply here we'll go with template string the sum is colon and then of course let's go for template literal and we'll say num1 plus num2 and instead of setting up the exports i'll simply invoke add values and now i'll throw you that migrate that i was talking about where in the app.js i'm not going to assign it to anything i'll simply write require and then we'll go with my grenade and now let me comment out these three since at the moment they will just over populate the console and again let's run node and app.js and once we're on our code we can clearly see in the console something pretty interesting where we have a log of the sum is 15. so what's happening over here well when we are setting up everything if we have a function inside of the module that we invoke yes that code will run even though we didn't assign it to a variable as you can see clearly here and we didn't invoke that variable and before we go any further let me mention three things first it's not unique you can also do that in es6 modules and if you took my vanilla javascript course you know that we use that functionality number two yes throughout the course here and there we will use this particular setup now it's going to be with third party modules and of course once we get there i will remind you about this setup so that's how it works and third i wouldn't suggest losing your sleep over it just please remember that when you import a module you actually invoke it and this is really going into weeds but the reason why that happens is because this code is not just exported on its own when the node exports this it actually wraps it in the function so that's why when you're required yeah you do invoke the code if you have some kind of function that actually is executed here keep that in mind not talking about exporting something i'm talking about executing function here and there and of course in this case you need to use the imagination that we'll do something way more useful than this at this point you're looking at it okay i could have just set up that function in app.js and you're 100 correct this is the place where you definitely need to use your imagination where of course the functionality we'll use it for is going to be way more complex but the idea is going to be similar where we'll just require some kind of module and behind the scenes that module will do a bunch of cool stuff okay that was fun we created our first module and in the process covered the general module syntax and use cases as well now what well as helpful as our say hi function is some very smart people created way more useful modules than that and the good news is that we can start using them right away so what i'm trying to say here is that node has bunch of builtin modules that we can use freely in our apps in the following videos we're going to cover following modules os module so operating system module path module file system module as well as http module to set up our http server and before we continue let me just say this i purposely cover only a few major modules and more specifically only a few properties and methods provided by those modules you see the list of builtin modules in node is quite big and the amount of properties and methods each module has combined is of course even bigger and as a result we could easily spend the remainder of the course on just that but is that really beneficial and of course the answer is no instead let's cover the general setup first and later as we progress with the course implement some modules as we go now if you're interested in more properties and methods built and modules have just navigate to the docs and go nuts so if at any point you would want to find out more about specific property or method or the builtin module in general just navigate to nodejs.org and then look for the docs and again in my case the version the long term support version is 14 so i'm gonna click here but as you can see we also have an option of going to the older versions as well so as you can see i can get the docs for the older versions as well but i'm just going to stick with my version and then be prepared to go nuts if you enjoy docs then you have yourself a big old party where of course you can look for modules and then each module has the properties as well as the methods so of course you can get a extremely detailed information on the properties as well as the methods here in the docs all right and once we have covered the general existence of builtin modules now let's take a look at few of them and i'm going to start by creating that file that i promised a few videos ago remember when i was setting up the modules i said that eventually there is going to be a file by the name of 3n modules and this one i would want to do it together just so you don't think that i'm not fulfilling my promises so we're going to go with module and then i guess modules.js i'll grab that i currently have in the address it's pretty much everything and we copy and paste and in this case i also uncommented these say hi again this all stays for your reference and you'll have access to it if you navigate to the github repo so grab everything in app.js i'll actually cut it out since we'll start from scratch and copy and paste now of course all this code is sitting in the modules and just keep in mind that of course we're still referencing the names utils alternative flavor as well as my favorite the mind grenade and back in app.js now let's start by taking a look at the os module and os module we built in module provides many useful properties and methods for interacting with operating system as well as the server and the general setup for the builtin modules or even the external ones that we're going to cover a bit later is going to be similar where we're going to go with some kind of variable and in this case i'm going to call this os for operating system then we're going to go with require and then in the require we'll have to pass in the name so since this is a builtin module of course we don't need to install anything just remember it later when we work with external ones yes we'll have to install that module first in this case it is a builtin so we just go with os but again let me stress something we're not doing dot and then forward slash no we just go with os so that way node knows all right so you're looking for the builtin module and once we set this up then we have multiple options either you can access those methods by just running this variable so it would look something like this where i go with os and notice the moment i press dot i have all these options so these are the methods and properties that i can use or if we know that we want a specific one you can simply destructure it here and of course throughout the course i'll use multiple setups just so you understand that both of them effectively do the same thing so here i have access to all the methods and properties that this module provides and of course now we can go crazy for example i could get a useful info about the current user which of course is me so say info about current and user and you know what as a side note i'll save here and i'll close all the files it's just a bit annoying that i have all those tabs open back in the app.js once i have a comment of course now i would want to assign it to a user and we'll simply go with os since that is the name of my variable and then method that i'm looking for is userinfo i don't need to pass anything i simply invoke it and of course since i would want to see the result i simply go to console log and then i'm looking for the user and you can probably already guess that we'll just run node app.js and there it is now of course i have a info about the user which is me so this would be a home directory this is going to be the default shell and all kinds of useful stuff then i want to show you how we can get the uptime of the system so effectively how long the computer has been running in seconds and i'll just add a comment method returns the system system up time up time in seconds and the way i'm going to run that i'll right away set up the console log just so you understand that of course we have multiple options how we can invoke those methods you don't always have to assign to some kind of variable now i'll leave this one in here so i'll leave the console log and then user and let's say right above or you know what let's do it this way so leave the console log where the user is and then let's go with another one we'll go with console.log in this case i'm going to go with template string and we'll say the system system uptime yes and then let's use a interpolation of course and the method that i'm looking for is uptime so again i go with my variable name and i know i've said this before but i just want to stress this point just so we all are on the same page and in this case i'm going to go with os and then the method name is uptime and then let's just add seconds and again same deal back in the integrated terminal run node and then app.js and there it is now of course not only i have the info i also have the system uptime and what's interesting this actually is 100 seconds meaning if i'll run this notice that you'd expect that this would probably stop at 60 right since we have 60 seconds in a minute but no actually this one goes to a hundred and then i'm just gonna set up a object where i'll show you a few more methods and then we'll move on to a next module because again the point is not to cover each and every method the point is just to give you a general idea how the modules the builtin modules would work in node so clear my terminal and then i'll create a object i'll call this current and then os and then in this object i'll set up properties and i'll set them equal to the method that actually returns that value from my os module so go with name and os and this is going to be equal to a type method then i can get the release and this one will be equal to os and then release again we invoke it then we'll look for total memory and free memory total and mem and of course i'll go with os and then total mam as you can see somewhat predictable and then we're gonna go with free memory and it's not going to be surprised if we're just going to go with free memory here let's save that one and lastly let's just cancel log it and we should get a bunch of info about our current operating system again we're going to go with node and then app.js and not only have the user information not only i know how long the system has been up in seconds i can also get some useful data about my operating system and again we're just scratching the surface of course there's more methods and properties but hopefully you have a clear understanding how powerful these builtin modules are in node.js since the node we can interact with the file system something we couldn't do when we used our javascript in a browser another useful module is a path module which allows us to interact with file paths easily and i'm going to remove all my code in the app.js because behind the scenes i created a file by the name of 8 os and module and of course copy and pasted the contents from the previous video that's why in app.js i'll remove everything and the setup is going to be exactly the same we come up with some kind of name now most likely it's going to be path and then we pass in the module we would want to get and in this case of course it is a path module and then let's just start with a very useful property a separator property that returns a platform specific separator so if i go straight up with console.log and then path sep this is going to return my platform specific separator so if i write node mjs there it is and of course i have forward slash now if you're using different platform for you the value might be different after that let's take a look at the path dot join so the join method which joins a sequence of path segments using that platform specific separator as the limiter and second thing it does it returns a normalized resulting path and in order to show you an example i'll create a new folder so not a new file but a new folder i'll zoom in and i'll say content and inside of this content folder i'll create another one and i'll simply call this generic subfolder and in this subfolder i'll say a test and text file and instead of the text file i mean you can place something you can omit it doesn't really matter i'll just say text and then txt and once we save it back in the app js now i want to use that path dot join method so i'll say const and then file path is equal to path dot join and then we need to pass in those values as strings so for example since i'm looking for the content folder i'll simply say forward slash and then content then i know that inside of the content folder i have the subfolder that's another folder and then eventually there's going to be a test txt so we go with test and then dot txt we save the sucker and then if we'll cancel log the file path we should see the whole path and there it is now of course it is normalized and we get it as a value so we have content subfolder test and txt so if i start adding some type of forward slashes meaning trailing slashes then of course they will be removed we still get the normalized path and we can also get the base name so for example i create this file path but i only would want the last portion of it how can i access it well the method name is base name so we're gonna go with const and base and path dot base name and we just pass in that file path and now if we cancel log the base we should see the text again these are just summaries if you want just a directory of course you can imagine that there is a method that returns that as well but since i don't want to cover each and every method that's why i will skip that one and there it is now of course not only i see my normalized path but i also see the test txt which is my base and the last method that i would want to showcase is path.resolve and why it's so cool because it returns an absolute path and once in a while in our applications we need to provide that absolute path that's why of course we'll have to use that method and when it comes to path.resolve it accepts a sequence of paths or path segments and resolves it into an absolute path so below the base i'm going to go with cons and then absolute and that one is equal to path and we're looking for dot resolve and here remember when we talked about the globals one of the first globals i covered was underscore underscored their name so this is going to point to this directory where the app.js is located and once we're here then of course we just need to provide rest of the values in my case that is content then i'm looking for sub folder and then eventually i would want to get to the test dxd i would want to get this absolute path and then once i set up the value of course if i go with my console.log and if i provide absolute once i run node and objects you can probably guess that in the console i'll have my absolute path to the test txt and if you're wondering why we would ever want that well remember our application is going to run in different environments right so of course the path to some kind of resource is going to be different in my computer in my local machine than for example in heroku hopefully it is clear and now of course we can take a look at the next useful builtin module nice now we know how we can work with path module and like i mentioned in the previous video we also have an option of interacting with a file system so what i would want right now is first create a new file i'll call this nine and we'll say path and module like so js i'll grab everything that i have in the address copy and paste and once we have this one out of the way i'll just remove and keep the app.js clean for now as well as clear the console and yes we have an option of interacting with the file system and the module the name of the module is fs now essentially there are two flavors when it comes to file module we can do it asynchronously nonblocking or we can do it synchronously which is going to be blocking but for time being we'll just cover both of the setups and then later in the course we'll cover what are the differences and why you should prefer one over the other one for now just think of them as different methods but eventually yes we'll talk about it the whole structure of the node and why would you want to use the nonblocking code instead as well as different approaches when it comes to callback functions different solutions and for now i just want to show you both methods essentially four methods and then we'll just move on to the next topic and in order to set this up in this case i'm just going to structure right away the methods that i'm looking for and in the first video we'll take a look at the synchronous ones so that's why i'll destructure read file and sync and that is coming from require and then the module name is fs again please keep in mind it would be the same thing if i were to go like this fs and then fs and whatever the name i was going with read file sync and of course i have access to it i'm just showing you a different way how we can access those methods we just destructure them out of the fs module and then the second one will be write file sync write file sync and then once i have the structured both of them then i'm going to set up two variables so first we'll read two files we haven't created those files yet but in a second we will and then eventually we'll create a new file with write file sync so i would want you to go to the content folder if you haven't created then i suggest creating one and i mean i'll keep the subfolder just because i believe the path module is still using it but in a content i'll create a new file so not in the subfolder but actually in the content i'll say first first and then txt so this by the way sets it up in the content so let me move it up or i'm sorry this sets it up in a subfolder i believe and it tells me do i want to move yes i would like to move and now i have the content that has the first txt and then i have the subfolder with test.dxt of course if you want you can place it in a subfolder that's really up to you but in my case i would want them simply in a content so i'll go the second one txt and as far as the values i'll say hello this is first first text file and then of course we can copy and paste the value and just change it around to the second file so in the second txt we'll say second text file and once we have both of the text files now let's take a look at how we can read from the file system and since we have read file sync we know it is a method and in that method we need to provide two parameters we need to provide a path to that specific file as well as well what is the encoding so the node knows how to decode the file and generally you'll go with utf8 and we'll first go with first that's my variable we'll go with read file sync my method name and like i said we provide a path we go to the content and then inside of the content there's going to be a first txt and then as far as the encoding the default one will be utf8 but if you want to be a bit specific just set up the second parameter and notice these are all your options and just go with ut effect okay and then once we have everything in place of course we can copy and paste this is going to be the value for the second one and we just need to change the file name of course so we have the second one and now in a console log we should see both of the text so if i go with console.log first and then second i should have one long text and let's go with node and app.js and there it is i have hello this is a first text file and i also have hello this is the second text file and once i have both of them why don't we create a new file and the method for that is write file sync and the way it works again we provide two values two arguments one is gonna be the file name and if the file is not there then of course node will create that file and you'll see that in a second and the second one is the value that we would want to pass and i'm going to go with write file sync write file sync and like i said first is going to be a path so you can call this third you can call this result whatever you would want in my case i'm going to go with forward slash content and then we're looking for result and then sync and this is going to be txt and then as far as the value if you want you can simply pass hello world and test it in my case i'm going to make it a bit more interesting where we'll set up a template string we'll say here is the result and why don't we use the interpolation we'll say first and second so we'll have first value and then the second value and you know what when we add here colon as well so let's say first and then let's place a comma and then we're gonna go with second again if the file is not there then of course node will create one and if the file is already there node by default will overwrite all the values that are in the file and i'll show you that in a second so i'm going to go here with node and app.js and check it out now i have result sync txt and then inside there i have here is the result hello this is first text file and also have hello this is second text file and just to showcase that if there are some values they will be overwritten by node well if i go with simple hello world and then i run node.js again i have my new result now if you just want to upend to the file well we need to pass in one more argument notice i have the first one i have the value that i would like to set up in a file and the third one is an object basically an options object and here the property name is flag and if you'll set this flag equal to a then node will append this and the easiest way for me to show you that is run node.js and now we should have two results so we have here is the result and notice how we're starting a new line why well because by default we are overriding everything and then when we add that flag then of course we create a new value so these are two very useful methods that we can use with node to read files as well as create ones from the scratch beautiful and once we have looked at the synchronous approach like promised i also would want to show you the asynchronous and as always let's start by creating a new file again in my case that is going to be 10 hyphen and then i'm going to go with fa sync and js and of course i'll grab everything in the app.js and then just copy and paste and then back in the app.js i would want to change these names so i'm not looking anymore for the read file sync i'm actually looking for a method by the name of read file so this is going to be the asynchronous one and the same goes with writefile now of course we can remove all this code as well and the way the synchronous method works we need to provide a callback and if you're familiar with callback essentially what it means is that we run that callback when we're done so when whatever functionality we're doing is complete then we run that callback just like we normally would do with add event listener on a button remember we go with add event listener we add whatever the event of course with the button that would be a click event and then pass in the callback function and that callback function will run every time we click on a button so this is the same thing where we have the read file function and we can simply use it since of course we have the structured then we need to provide a path so again we go with forward slash content and then the file name is first txt and this is where we provide that second argument and that is going to be a callback mission now in that callback function we pass into more arguments first one is going to be error if there is one as well as the result and then inside of the body first i would want to check if there is an error and then i can just return null as well as maybe console.log so we go with if error and then we'll say return null or simply return whatever you'd want and if you want you of course can cancel log the error as well like so and then if everything is correct well then of course i'll have access to my data which of course has the name the parameter name of result and since i would simply want to console log the result i'm going to go with console.log and the result but of course keep in mind that this is where you would set up the functionality so let's go back and we're going to go with node app.js and in this case something really interesting where we don't get the text right so we're getting this buffer so this is what's going to happen where if we don't provide that utf coding then of course we'll get the buffer now where do we add this encoding value well right here in between in between the content as well as the path so let's just go with string and we're looking for the utf so let's say utf8 and we'll save that one and let's run it one more time and of course i have node app.js and then hello this is the first text file and now the million dollar question well how we can set up the same functionality check it out we have read file read file and then we simply create a new file with both of these values so if you're familiar with callbacks you know that of course we would need to set up that functionality inside of this callback where i'm getting this result otherwise there's going to be an error because the only way for me to access this result if i'm setting this as a callback is of course inside of this function and this is what i was saying before where yes eventually i'll show you a different approach because inevitably we'll set up a callback help and you'll see that in a second so what i would want to do right now when i get back my first text file well now of course i would want to assign it to some kind of variable and then i would want to read that second file right and then eventually once i read the second file then of course i would want to create that new file and the way it's going to look like i'm going to go with const and i'll say first and you can name it first text i'm just going to know it first and this will be equal to my result okay awesome and then right after that result again i'm going to go with read file and then the same thing we provide a path so we go with content and then in this case of course we're looking for second and then txt then we need to provide the encoding so node knows how to decode that and we go with utf8 and then of course we need to provide our callback again same deal we go with error and result and in order to speed this up i will copy and paste so just grab everything starting with if and ending with the result copy and paste again this is the case where we're checking for the error first if there is an error we cancel log it and if everything is successful we assign this one to the second one and then eventually now i would want to set up my right file so again it is a function we need to provide that value and we already have result sync txt that's why i'll create a new one and i'll call this result and async so again we're looking for the content then we go with the filename which is going to be result and a sync and txt of course since there is no file node will create that for us i'll right away set up my data now if you want of course you can copy and paste this functionality this is totally up to you where basically we use two of them and in my case this is exactly what i'm going to do in order to speed this up if you want to create something from scratch of course that is also an option and i'm just going to copy and paste that's my template string and again if you want to add this flag you can definitely do so in my case i'm just going to omit that so here's the result i have first and second and the reason why i have access to them because of course i'm looking in the outside scope of this callback function and then again we have a callback function in the right file i know there's tons of callback functions that's why we'll have to set up a better setup when we're handling these callbacks but we'll do that a little bit later so for now let's just add a comment here where we have first parameter second parameter and then third parameter and of course this is going to be again our callback where we have error and result and then inside of this callback finally we can take a look at the value and of course the value will be in this result now of course we're creating the file and all that but hopefully you get the gist that if you'd be doing something where you're looking for this result of course it would be over here so again let's check for error quickly if there is an error then of course i would want to return as well as console log the error just in case and if everything is correct let me just console log the result so save it here and two things we need to watch out for maybe there's an error and second one we should create a new file by the name result and then async txt let me clear the console and we're going to run node app.js and i do get an error and error simply tells me that i did not add the dot in front of the content so i would need to go back to write file and just add that and once we add the dot we are going to be in good place where i'll clear the console and i'll run one more time node app.js and then the result will be undefined okay that's fine like i said in this case we're not expecting anything back but what's really cool that in the result async we should have our text here is the result hello this is first text and then the second text so hopefully it is clear this is how we would use the async pattern so let me zoom out right now here and you'll see this famous callback hell and in the next video i would want to give you a brief description of what are the differences between the asynchronous approach or nonblocking approach and the blocking one the synchronous one as well as what are the alternatives to this callback l all right and just to give you an early taste of the differences between the asynchronous or nonblocking and synchronous which is a blocking code why don't we set up few console logs now before we do that i will create a new file and i'll say 11 here and by the way i definitely need to zoom in just so you don't think that i'm cheating fs and async js and let's go to the address we'll select everything and copy and paste and of course in next video we'll set up different module in this appdress so for time being i can just remove it and then like i promised we'll set up some console logs so why don't we go back to fs and by the way during this video i'll zoom out because i definitely wanna go back to this evil evil callback hell that we're getting from nesting callback within the callback and as far as fa sync let me zoom in and why don't we set up a console log in few places let's say before we're accessing the file so i'm gonna go with log and we'll say start then we're gonna go with write file sync and then right after that we're gonna say i'm done with the task and then inside there let's write done with this task copy and paste and we're gonna go with starting the next one starting the next one meaning the next task so that should do it and of course i need to go with clear so clear my console and i'm gonna go to node and then the file name is 10 iphone and then fs and we're looking for sync i run it and notice something interesting where i have the start so that is going to be before i read the files and only then once i'm done writing that file i have done with this task and starting a next one and what we need to imagine that of course this task of getting those files as well as the second one of setting up that file well it might be very time consuming right and imagine that if we have even 10 users and they're all the time using our application and if for example this one user does this one task or both of them and they take really long time what means that node is not going to be able to serve other users and trust me it is at the end of the really really big deal and notice how javascript is reading this code synchronously it just goes line by line so we start with this task then we read these files and then we write the result and again if this is something that takes really long time then pretty much your application is down so no other user can do anything with that application because one of the users is for example reading these two files and then writing one again this is a very simple example but you need to picture that of course there's going to be tasks that take longer time and as an alternative let's take a look at the async approach so here again we'll set up some simple console logs and again we'll cover this in a bigger detail a bit later for time being let's just set up console logs and you'll see the biggest difference where i'm gonna go with log and let's say start so i'm gonna do that before i read this file and then i would want to go inside of the right file the last one and instead of console logging result which of course is undefined since in this case we are not getting anything back now i want to go with done with this task and then right after my first read file i'm going to go with log and starting next task hopefully you're able to follow along again before the read file inside of the right file and then right after the first read file because of course the other ones are nested inside of this callback and then if we go to node and if we just change it around to 11 and then fa and i believe it was async and if we run it notice something cool where i have my start and then i right away have this starting next task and eventually i have this done with this task so what this means is that since we have this asynchronous approach the moment we start this task we just offload we just offload this task and we continue with our code so that way when user number one for example comes here and wants to get this functionality yeah sure here node just offload this task and then your application can keep on serving other users again it seems a bit trivial at the moment because we have a basic approach but hopefully you get an idea where in one case we have everything happening line by line so only when we're done with the task we're starting a next one and with this approach we start a task and we just offload that task and then we start a next task right away and eventually yes we have done with this task in the console as well now as far as the implementation as far as the callbacks yes this is a bit messy right notice how we only want to accomplish few tasks and it's already somewhat off a pain now alternatives are using promises as well as async await now again hopefully you understand that when we talk about reading the file as well as the writing or file i use this as an example of some kind of task that would take a long time now for the remainder of the course mostly it's going to be reading from the database writing to the database and that sort of thing but this is a very good illustration of how some tasks would take some time so of course we would need to use a callback and as far as the callbacks yes you can use them but the code is going to get messy somewhat quickly that's why a bit later in the course we'll take a look at the alternatives which are promises and a sync await and i have to tell you honestly for the remainder of the course we'll use async await because in my opinion it is just easier to work with excellent and up next we have http module but before we continue let me just mention that i purposely won't spend too much time on explaining every single http method we're going to use in great detail and here's why you see starting from next section all of our work meaning code in some shape or form will revolve around server setup aka http module so that point of course i will cover every last bit of syntax in great detail at this point though i think it's just a waste of our time so if you're confused about something http related don't sweat it we will return to that subject shortly and cover it in far greater detail now if you're wondering why we bother with http module at this point at all since we're going to use it later anyway you see with the help of http module i believe i can show you some core features of node in action and give you somewhat of a visual representation of them otherwise i would have to base everything on slides and i don't think it's the best approach so long story short if you're iffy about something http related just please be patient and i'll answer all your questions in the next course section nice i think we've got a good initial understanding of how the file system module works in node and hopefully i did not lose too many of you so hopefully there are still some students left in the course because i fully understand that seeing this for the first time is probably a bit overwhelming and what i would want to do next is cover the last initial module the builtin module and that is going to be the http module which is going to allow us to set up a web server now please keep in mind one thing we'll just cover the basics because the large part of this course is going to be creating your own server and setting up the api now granted we will use an abstraction on top of the http module and that is going to be the package by the name of express but the whole point is going to be exactly the same that's why again we're not going to cover everything in greatest detail at the moment because i don't see the point of repeating myself and now i want to go back to objects i'll zoom back in just so you can see better what is happening by the way let me check my zoom level so i'm going with settings and i think that should do it my zoom level is two at the moment and then back in the app.js let's grab the http module and we'll assign it to some kind of variable as always let's go with require and we're looking for http that's the module name and the method we would want to use is create server again we'll assign this to some kind of variable and in this case the variable name will be server then we go with http create server and this create server method is looking for the callback and in that callback function we have two parameters and both of those parameters are objects and since they're parameters you can call it whatever you would want but a common practice is calling them rec and res now this first parameter represents the incoming request so imagine a client is requesting from the web browser your webpage so you'll have information about the method and all kinds of useful stuff in that request object and the response is what we're sending back now we're not done of course we'll set up more code here but before we do anything we also would need to specifically say what port our server is going to be listening to and that's why we'll go with server and listen so that's another method and again this is arbitrary but i'm gonna go with 5000. again if this looks like a lot of gibberish where we have the request response as well as the ports don't worry later in the course i'll cover that in more detail as well as show you some useful slides and all that good stuff and as far as the response well we have few methods we have write so we go with arrest and again this is the object and notice here how i'm not using the rack yet so i'm not checking for anything i'm just concerned about my response and the method name is right and inside the right we just come up with some kind of text and i'll say welcome to our homepage homepage and once we have sent back the response i also would wanna end my request so i'm gonna go with res.end and once we're done setting up the code inside of the callback function now of course i would want to open up my terminal clear everything and we would need to spin the sucker up and of course the way we do that is node and then objects since that is the file name make sure that you save it though so before i run i'll save it and then notice something interesting notice how we're not exiting so previously every time we ran the file every time we ran node and then whatever the file name we exited from the file right so node was done executing the code and we just moved on now in this case since we have a web server what do web servers do they keep on listening for requests and actually you want your server to always be up and of course if i go to my web browser and then i'll make this bigger and if we go with localhost and of course in this case we have 5000 there it is we have welcome to our homepage so now of course we have effectively created our first website now granted it's very basic but at least we have something on screen and before we discuss the external modules and actually set up a module that nicely watches our code and does the restarts for us i also want to showcase what we have in the request object now this is going to be a giant object so i'm not going to cover each and every property however i would want to showcase a property that gets us the url and what would be the url well that would be an address and if you're worked with reactor or dom you know that for example for the homepage we used forward slash and then if the client wants to go to for example about page he or she would enter forward slash and then the about now in our case notice how we're still serving the same content so just to give you a quick introduction of the request object as well as set up a bit more realistic application we're going to go with the request now again if you want you can log it so we're going to go here with request and you'll see that it is a giant object now since we made some changes we do need to stop it and then we'll go with node object but notice how we're not right away console logging the request object why well because server is waiting for those requests so we need to go back to our browser and then refresh and then of course once we navigate back like i said this is going to be a giant object which bunch of useful info now what we're looking for is the url property because that url property is going to tell us well what address client is requesting so what endpoint the client is requesting and like i said for the home page the common practice is using simple forward slash so in here we can set up the if statement where i say if request url is equal to the home page then of course this is what i would like to send back and just to speed this up i can tell you that we can cheat a little bit where we can just place everything in the end and in my case i'll just cut out my string so we have res dot end so now we simply send the text and now of course i also would want to check for the about or contact or whatever so in here let's go with if and then request and url and if that one is equal to about about then of course i can send different text and as far as the text i'm just going to say here is our short history and then lastly well what happens if the user is trying to access a resource that doesn't exist on our server so we'll have the about page we'll have the home page what about if the user is asking for a contact page that we don't have well here we'll simply set up a default response we'll say res that end and just to make it interesting i'll set up the template string and i'll show you that if we really want to we can also pass indirectly html and i'll say oops an explanation point i'll close my html again please understand this is just a basic scenario of course that's not how we'll be setting up our apis or nothing like that but just to give you a quick intro we'll do it quick and dirty where there's going to be a paragraph and we'll say we can't seem to find the page that you're looking for page you are looking for looking for and at the very end i would want to set up a link that allows the user to navigate back so go with href and i'll say forward slash which just means home page and we're gonna go back home let's close our link let's save that one so at the moment of course we have the about and by the way almost forgot yes we do need to stop the server and we need to go with node and then app.js refresh one more time there it is notice how we don't have the about we can't seem to have the page you're looking for and that is actually a bit interesting because it should be available right and of course the reason is because i messed up on the url property my bad let me do this one more time and we'll stop the server here again let's run node app.js and now we should have here's our short history that's our about page then we have the homepage and of course you already familiar with our error page so if i'll go with error or any kind of resource that doesn't exist then of course we'll get the error page and of course we can bravely navigate back home and we go back to our home page that should do it for the quick intro of base modules and now of course we are ready to move on to our next topic all right at this point we're familiar with two types of modules our own as well as the nodes builtin ones but just like in any good infomercial i'll say but wait there's more we also have access to the world's biggest code store and before you seriously start questioning my mental state imagine this scenario you're building an app and of course as any good app it needs to have a slider just for funsies now at this point you generally have two options build it from the scratch yourself or search on google and copy paste someone else's solution well have no issues with either of these options keep in mind that someone somewhere has struggled with the same issue the need for the slider and there's a good chance that that person was kind enough to build it and share the whole project with us so our only job is to go through the docs and with the help of one command just add it to our project we can do that because when we install node we automatically also install npm or node package manager and npm enables us to do three things reuse our own code in other projects use code written by other developers and lastly share our own solutions with other developers as well the npm project is hosted at npmjs.com again the site is npm.js and here you can find everything starting with useful utility functions to fullblown frameworks and libraries and as an example if you're familiar with react you know that react has the create react app package and of course it is hosted on the npm a typical node project will have more than few npm packages installed as dependencies and before we install some cool packages let's talk about naming npm calls the reusable code a package and a package essentially is a folder that contains a javascript code now another names you'll hear are modules and dependencies and honestly at this point all three are used interchangeably when talking about shareable javascript code so don't be surprised if during the course i call them any of these names package dependency or module at the end of the day they all mean the same thing lastly let me just mention two things first there is no quality control in npm registry anyone can publish anything so it's up to you to sniff out the empty and useless packages and yes there are quite a few of those ones out there as well a good indication of the security and usefulness of package is the amount of weekly download if the number is high meaning if it's popular it's a good chance that it's a battle tested and ready to go and that brings me to my second point remember the slider example we discussed in the beginning of the video when it comes to npm packages there's a good chance that if there is a bug someone else has already fixed it and as a result it's already fixed in the package or there's a working solution all right so that you did for intro let's start using node package manager in our own project and as a side note if you want to search for some packages just visit npmjs.com and then for example if you're looking for the bootstrap you'll find the package and of course you can click on any of them this will bring you to the docs as well as weekly downloads and rest of the stuff once we're familiar with node package manager let's see how we can start using it in our own project and the good news is that it's much simpler than you would expect you see when we install node we also install npm and because of that we have access to npm global command and you can check the npm version by running npm version in your terminal just keep in mind that the version most likely won't be the same as your node version and that is totally okay so you can either do that in the terminal or of course in the integrated terminal and you can simply type npm and then hyphen hyphen version i believe you can also check by hyphen hyphen v and there it is of course now we have the version for our node package manager and then we have two flavors we can install package as a local dependency and that just means that we'll only use that package in this particular project that we're working on and the command for that one would be npm install or i for short and then whatever is the package name so whether that is bootstrap low dash express or whatever or we can install dependency as a global dependency and that just means that we can use it in any project and the command for that one would be again npm i or install whichever method you prefer and then hyphen g so this is going to be the flag and then again the package name now when you install something globally most likely on a mac they will ask you for the sudo so you'll have to provide the credentials that's why you'll run sudo npm install and then hyphen g and again package name as far as which one you'll use more often that definitely will be a local dependency flavor because even though yes you can install packages globally with arrival of npx there's actually less and less need for setting up something globally that's why we'll focus on local dependencies first how to set it up in our project and then in a few videos when we talk about npx i'll cover why there's less need for setting up something globally now there's one more thing that we would need to set up in our project as far as dependencies so i know i know you're eager to start installing the packages but let's just wait a little bit and next video we'll add that extra thing that we're missing right now and then we'll be in good shape and then we'll start installing every package under the sun excellent we now know that we have access to the npm global command we now know that in order to install the local package we will need to run npm i and the package name so what are we missing well we're missing file by the name of package.json and essentially you can think of it as a manifest file that stores important information about our project and there are three ways how you can create package.json first is the manual approach where you just create a package.json in the root and please do that in the root if that's something that eventually you decide doing and then of course you would need to create each property or there are two ways how we can automate this and the first one is running npm init and in there they'll just step by step ask you the questions and if you want to skip it you can just press enter and the another way the third way is running npm init with a y flag and then everything is set up as default so i'm not going to show you the manual approach it's just too time consuming and we'll right away go with npm in it first i'll show you the step by step approach and then of course i'll show you how everything is set up by default using the y flag so go to your terminal and just type npm in it and there it is of course now they tell you that there's going to be a walkthrough of creating a package.json file and the first one is the package name and by default of course it is going to use the folder name now keep in mind that if you eventually want to publish this package then the name has to be unique so you need to make sure that nowhere in the npm you can see the package with the same name and i'm just gonna go with tutorial as far as version we'll talk about versions shortly so i'll just skip this one as far as description whatever again is just the default now as far as the entry point eventually will change it but for now it's good enough we're going to go with one intro js and then the test command as well as git repository and keywords and author and license and we simply say yes and we are in good shape so now of course we have the package json file with name version description as well as the main property and of course the scripts author and the license now i'll remove it i'll say delete and i'll show you that of course you can skip all those questions by simply typing npm in it and why and as you can guess yes of course you can come here later and then just change these values that's why it's definitely faster to just type npm in it and then the y flag so why do we need this package.json well because if i would want to install the package the local package now of course this package is going to be stored as a dependency and to show you that let's just go with npm and you know what let me clear the console first so we're going to go with npm i and then we're going to go with the package name lowdash and if you're not familiar with lodash it's just a utility library and i'm just specifically using for installation purposes there's no real reason to have low dash for our own project but it's just something pretty interesting that i would want to showcase that's why we're using lodash and we run it and notice how we installed the package and check it out now in the package.json we have dependencies property and it's an object and inside of that object we have a package by the name of lowdash now i'll show you in this video or maybe in the next one why it's so important to have this package.json but another thing that i would want to showcase once we can see that we have dependencies property if you go in your visual studio code and if you click on refresh explorer what you'll also notice is this node modules folder and in that node modules folder this is where all the dependencies are stored so if you don't have that folder already and pm creates it so in our case of course we didn't have any dependencies so when we install that first dependency npm creates that folder and this is where you'll find the dependencies now notice something interesting where for the low dash we only have one folder right so we have only one dependency but when we need to keep in mind that of course there's going to be some packages that have other dependencies and that's why i first installed lodash just to showcase that yes once you install dependency of course it is going to be in node modules but if you'll try to install a package that is bigger that uses other dependencies you'll notice something pretty cool where if i clear my terminal and if i'm gonna run npm i and then bootstrap again you can use any other package you'd want this is just to showcase how the packages work we won't use the bootstrap in this project so once i install and once i refresh check it out not only i have low dash not only i have bootstrap which i installed but since bootstrap is using jquery as well as the proper js now these are installed as dependencies and if you take a look at the dependencies property now of course we have the bootstrap as well and again the whole point of this video is to showcase why we need package.json so we need it because we need to provide information about our project and inside there a very important property is the dependencies one because in there we'll just store the dependencies which our project is using and then some packages are actually going to use more dependencies and they will be automatically installed as well in our case that was bootstrap and just to give you a taste of the package why don't we just navigate to app and i'm going to do that below the comments of course you probably would need to clean the file and as a side note the last module the http i saved in file by the name of 12 http and back in the app.js in order to start using the module in our case i guess i'm gonna go with low dash first i would need to set up the variable and common convention is calling the variable like so and we'll set it equal to require and now of course we have access to the low dash now this is the difference between node packages like for example the http or the file module or whatever and the ones that you install the external ones the external ones you always have to install first if you won't install the dependency well node won't be able to find it so in our case we did install the dependency the lowdash so now of course i can just assign it to the variable and since lowdash is utility library why don't we test out one of their methods and i'm just going to go with items and i'll create an array of arrays so items is going to be an array however the items are going to be arrays itself so two and three and then we're gonna go with four and low dash has this method the flat and deep method that effectively will just spit this back as a flat array and the way we set it up we just go with const and i'll call this new items and then since we have access to everything in this variable now i can simply go with underscore here dot and then flat and deep so flatten deep and then we'll pass in the items and now if we console log new items and if i go to my terminal and just type node app.js and by the way i need to save it so let me go back i'll say node app.js and once we run check it out in a console i can see of course the one two three four so lowdash has the method by the name of flattendeep we have access to it because we install it as dependency and now of course i can start using it now we're not gonna use bootstrap in this project because that would be too timeconsuming bootstrap was just used so you can see that some dependencies will have more packages so once we install one dependency there's actually going to be more dependencies and hopefully you have a clear understanding of how you would set up package.json how we would install the package and next video i would want to showcase why having package.json is so crucial and so beneficial when we are starting to share our project with other developers awesome we have package.json we installed few dependencies and now i want to cover why having package.json is so crucial when we start sharing our project with other developers and for this example i'm going to use github as well as few basic git commands and my assumption is that since this is somewhat of a advanced course you're already familiar with git and github and you have the account if you don't please stop the video create the account and just use your favorite search engine to learn about the basics of setting up the github repository as well as basic git commands so our task is to push this up to the up and now million dollar question are we just pushing everything up including the mode modules which for the most projects is going to be somewhat big i believe i just checked in our case it was like nine megabytes but trust me it always gets way bigger than that or we would just want to send the code and you can probably already guess that since i'm implying that the size is too big that we'll have to push this up to the github without the node modules and we'll start by creating a dummy repo on a github so let me open up a new window i'm going to go with github and i'll just create a temp repo and then i'm just going to create a repo and i'm looking for these three commands essentially i would want to get that url the remote url so i know where to push it and then inside of the repo before we set it up as github repo first i would want to go with new file and we'll create a git ignored because of course what i would want is to place the node modules in a git ignore file because that way they will be ignored by my source control and i won't be pushing up this giant folder to the github because you'll see in a second that there is no need for it so we're going to go with forward slash and then node modules and if you're not familiar with git ignored it's just a file that specifies which files are going to be ignored by the source control and in our case as you can see i'm placing node modules inside there then i'll clear my console and i'll just initialize this as an empty git repo and then we'll add everything so git add git commit we'll just say first commit first commit and then i'll copy and paste those three commands in order to set up that url the remote url and once i have this in place should be able to go back to my github and there it is this is my repo now probably your next question is okay so we pushed it up to the github but i can clearly see that in my app.js well technically i'm using the load as dependency right but we didn't push up the node modules folder so how the person who is going to get this repo will be able to run the code in the app.js since there's no node modules and you told us previously that we can only run it if the dependency is there well let's check it out i'm going to go with clone option so i'll just get the url i'll navigate back here and i'll do that in messed up again it doesn't really matter we're just going to go with desktop and then git clone now i copy and paste the url i'll open up a new instance of my text error copy and paste and this is where the magic happens if we have package json we simply need to run npm install and what is going to happen the npm will check for dependencies that we have in the package.json and automatically set up that node modules folder so if i go here first of all i can see that there has been some changes that is already good news that just means that i have my node modules and if i refresh check it out so now of course i have my node modules folder and if you have been using react applications you're probably already familiar with this one where again when you are setting up the code you're not sharing the node modules folder and i can showcase that by taking a look at my react projects and that's not what i wanted i didn't want to look at my awesome picture what i wanted is react and then let's go with project and you'll see that in that repo we have bunch and bunch of folders and each folder has two more folders final and setup and now check it out none of them have the node models because imagine the size of this sucker if i would push for every project for every folder the node modules instead i have package json so when you get the repo when you clone the repo or download or whatever then of course you get the package json and in here these are the dependencies and you just run npm install and they are being installed okay hopefully it is clear that why it is so crucial to have the package.json because we can just share the code without dragging the massive node modules folder with us we can simply just provide what packages our project is using and then once we get the repo then we just run npm install that is the command and then npm will install all the packages that are in the dependencies awesome we're familiar with npm we're familiar with package.json now let's finally install the dependency that we'll use for the remainder of the course and that is no other than the node one and of course if you want to get more info you can visit the npm and you can search for the package but as far as the general setup is just to watch our files and then restart our app for us so that way we don't have to each and every time type node and then whatever the file name and we can install it as a simple dependency that is definitely an option but since i also would want to cover depth dependencies we'll install that as a depth dependency and the command for dev dependencies is following where we go with npm and then i or install whatever and then we go with nodemon so that is the package name and then you can either do hyphen d so that just signals that that is a that dependency or you'll see this save and dev so again whichever method you choose that is really up to you but just remember that both of them will save it as a dev dependency so let's install it and then i'll talk about it why we would want to set up as a div dependency and the reason for that is because if we think about it do we really need nodemon in production and the answer is no when we push it up to digitalocean or heroku or whatever we'll of course use something more serious than nodemon to restart our application pm2 comes to mind but while we're developing yeah that is an option so in this case we'll add right away nodemon to the dev dependencies now what else what kind of packages we would add to dev dependencies for example testing packages for example linting for example formatting and that sort of thing again nothing stops you from jamming this in dependencies but if you think about it it makes way more sense if we add this as dev dependency so we use it while we are creating the app but then once it's in production then we just share the dependencies that actually the app is using not the ones that we used while we developed the app hopefully that is clear and once we have the package we're almost there now we just need to understand how the scripts work in a package.json and at the moment as you can see we have the test one we won't use that one and inside of the script object we just set up the commands and as a side note we can set up the command right now even without the node mod for example i could go with start and that command will be equal to npm and or i'm sorry node and then for example app.js so that is my command and once i save my package.json instead of running this node app.js i can simply run npm and start and there it is as you can see same functionality i run app.js and i get back the array as well as the hello world again we still exit the application so it's not like we're out of the woods but i'm just showcasing that yes we can set up the commands and then in the command we just provide a value and in this case of course it is node and app.js now for some commands you can simply type npm start as you can see but for some of them you'll have to provide the full value and that is going to be npm run and nor to showcase that i'm going to go with dev and that one will be equal and here we're gonna go with a node mod and then app.js so instead of running node like we're doing in the start now i'm setting up a dev command and in order to run this one i'll have to go with run and then whatever here's the command name again some of them you'll be able to use the shortcut where you go with start and some of them you'll have to go the full route with npm run and then whatever is the command and as a side note yes you can still run npm run start and this is also going to invoke the command but in our case we have dev and in here i have nodemon and then app js so let's try it out let's say first the package json and you should notice something pretty cool where if i go with npm run and dev now i'm spinning up the node one and it tells me that nodemon is watching my application and since i know that of course we can test it out where i'm gonna go with console.log and then instead of the hello world which i have after new items i'm gonna go with hello people and you should see something interesting where once i change the text yep nodemon restarts my app and now of course my value is hello people awesome so now i don't have to type every time the node and then whatever file name nodemon automatically just restarts my app and i simply set it up as a script now if you want to change this around if you don't want to run npm around dev you can simply say nodemon and then app.js and just remove the dev1 completely and a side note again if you have worked with react project you are familiar with the setup because for react again we run npm start and then there's a value that spins up the whole react dev server where we can see our application not bad not bad well we're still on a roll let's cover how we can uninstall the package as well and as a side note if you want to stop the nodemon just press again ctrl and c and notice how we're of course stopping the nodemon and again if we want to spin up we'll just go with npm start and as far as uninstalling the package we have the command for that and the name is uninstall so i'll stop the nodemon and in the terminal i'll type npm uninstall and then of course the package name which in my case is going to be a bootstrap now this is one of the approaches how we can do that and there's also a nuclear approach now why i'm calling this a nuclear approach because that way we remove the whole node modules folder and don't worry once you run the npm install then of course you set everything back up from the scratch as well as you would remove this package like json and don't worry i will cover the package.json file a bit later and the way that is going to look like well we can first clear the terminal i'll install the bootstrap from the scratch again so say bootstrap here and by the way probably need to add npm i and now again as you can see i have it as my dependency and then like i said the nuclear approach is removing the node modules yep and then removing the package log and then just running npm install now of course in the package.json if i want to remove the bootstrap for example in this case i can simply remove it from my dependencies so i just remove it in the package.json then clear everything and then we go with npm and then install and now we'll get from the scratch the node modules since we're the ones who removed it and also we'll get that package hyphen lock json now i'm showing you that nuclear approach because if you have used gatsby you know that cats be somewhat notorious for sometimes just being a little bit annoying where you do need to remove the cache folder you do need to remove the node modules as well as package lock and then once you start up everything from scratch then as a magic the gatsby app starts working and check it out if we take a look at the node modules now yes there's a bunch of modules that nodemon is using right but there's no bootstrap and i can clearly see that because there's nothing under the letter of b so we can clearly see that we removed bootstrap from our dependencies all right and now let's take a look at how we can install package globally and what would be some of the use cases and first let's start with command let's jog our memory command was npm install and then dash g and the package name and in mac they might ask you for permissions so you'll have to start with sudo and then again same spiel npm install blah blah blah and first i want to showcase that i haven't installed nodemon globally and the easiest way for me to showcase that is by running nodemon and app js so we'll try to install nodeman package globally why well because then i can use nodemon in any of my projects at the moment i have it as a local package and of course i can spin it up by running npm start but let's imagine scenario where i have i don't know 20 nodal applications and i'm constantly working on node applications so to make my life easier i will install node 1 globally and then i won't get this error because at the moment you can see command not found normal all right so how do we do that well we can install it in our terminal or we can do it in the integrated thermal it doesn't really matter when it comes to global packages you can install it from anywhere so in my case i'm just going to navigate back to my terminal just so you don't think that i'm cheating and i'll zoom in and we'll simply run and by the way i need to start with sudo and then npm install and hyphen g and of course we're looking for nodemon so now of course i'm prompted to enter my password and once i enter my password of course i'm going to install nodemon globally and now in any of my projects i can simply go with command of nodemon and then whatever is the file name now to show you some of the use cases if you work with gatsby you know that they have the global gatsby cli tool and that was one of the reasons why you installed something globally is because well you used one of the frameworks for example react or gatsby in this case and then of course in order to set up the gatsby project or react project you needed to install this globally now things have changed though with arrival of npx and i'll talk about the npx at the end of the video but notice if you navigate to your react docs and if you look for create react app which again was something that you needed to install globally now they suggest this npx route where essentially you go with npx and then again whatever is the command name for example for create react app that would be create react app for strappy the headless cms that would be create strappy app and hopefully you get the gist where for every resource that of course would be different and with that command you don't have to install that tool globally for example again in our case we're installing nodemon but normally prior to npx you would install this create react app globally and then you can spin up those react projects now i'm going to go back to my terminal as you can see i was successful so what's going to happen if i go back to my project and if i run nodemon and app.js since i have installed that package globally there it is i spin up my app.js and if you don't believe me i can change it back to hello world and i have no issues hello world and there it is now of course i have hello world e in the console so hopefully it is clear that yes we can install packages globally and yes one of the biggest use cases was working with some type of frontend library but with an arrival of npx things have shifted where now those libraries suggest using the npx route instead as far as my personal preference since i'm recording a lot of courses and since some of the global packages usually introduce some kind of bugs to the students now not for all the students but there's always this one student who just has a lot of issues with the global package personally i avoid them as much as possible so i always either use the mpx or i just set it up as a local dependency again it's not a rule you can do whatever you would want but i'm just telling you what is my preferred option as far as what is npx it stands for execute and official name is the package runner it is a feature that was introduced in npm 5.2 and again the main idea is following where you can run that cli tool for example in this case create react app without installing these globally so as long as you have npm with a version of 5.2 or greater instead of doing this whole spiel of setting up the cli tool globally you just go with npx and then whatever here is the tool name and of course the last one is the folder name as far as the package log json why do we need it well if we take a look at our dependencies we can see that they have versions and if you remember some of the dependencies have dependencies on their own and of course we need to keep in mind that those dependencies have versions as well and for example the person who gets your project you probably want them to have the same exact setup because keep in mind as these versions change well so does some of the functionality correct so for example you set up to your whole project you use some kind of dependency that uses some other package and that version changes not for example for the bootstrap but for the jquery and then pretty much your project is obsolete meaning it might get some bugs because the version of the jquery changed so that's why you have this package.json and in there you have those specific versions for all the packages not only for dependencies but also for the packages that the dependency is using now as far as this version we have three values and you can think of it as a contract between us the people who are using the package and the person who is creating and first number is a major change so when this changes that means that there are some breaking changes now the second one is a minor one so that means that it is backward compatible so for example if this changes to 18 i shouldn't expect any breaking changes and the last one is just a patch for the bug fix so that's also something to keep in mind when you decide to publish your own package that of course that's why we have here this version now lastly i would just want to mention that if you're interested in more info about the package.json i would suggest this resource so i simply went with package.json then keep on scrolling keep on scrolling and you're looking for i guess this blog post right so the name is the basics of package.json and in here you literally find everything explained to the smallest detail whether that is a name version and rest of the fields that you can find in a package.json beautiful we now know how to utilize npm and for starters as a result for the remainder of the course instead of frantically typing node.js in a terminal we'll simply spin up nodemon and it will watch for the changes and restart the app for us now what before we move on to creating servers with express.js there are a few important node topics i would like to cover first and those topics are following event loop async patterns in node.js events emitter and streams in node.js while these topics are extremely important please keep in mind that our goal is to only understand the general ideas behind these concepts and i only introduce them so you have an overall understanding of how things work in node.js before we build our first node.js app if you're not satisfied with my explanations or simply want to do more research by yourself just type any of these terms in your favorite search engine and i can guarantee you'll find plenty of useful resources within a matter of seconds like blog posts youtube videos and conference talks with that said it's my strong opinion that it might be easier to understand those concepts more deeply so not just a general understanding but understanding them more deeply once you have one or few working node apps under your developer's belt let me also mention that in order not to waste your time with time consuming setup in few upcoming videos i will run some prebuilt code let me be very clear though i'm only going to do that in a few videos and for the remainder of the course we will type out everything together all right and let's kick things off by discussing the event loop now event loop in node.js is one of those topics where i could spend the entire course discussing it and it still wouldn't be enough so let's try to avoid that and instead just understand the journal concepts while there are tons of useful event loop explanations out there the one that i probably like the most is this one the event loop is what allows node.js to perform nonblocking i o so input and output operations despite the fact that javascript is single threaded by offloading operations to the system kernel whenever possible and as you can see i'm reading straight from the node docs now don't beat yourself up if this sounds like a lot of gibberish there's a reason why one can dedicate the entire course just for event loop it is a pretty complex topic but one word i do want you to remember is this offloading and you'll see why in a second also don't worry i have prepared more examples as well as some slides to get my point across but just in case you're not happy with my examples or you just want to explore the note event loop in greater detail here are a few external resources i find particularly useful when it comes to blog posts just go to your favorite search engine and type node.js event loop and the one that i find really useful is this one and the resource is nodejs and not.org but it is dot dev and then follow the link and here they cover event loop in great detail with a lot of cool examples and pictures and slides and all that good stuff and when it comes to videos i would suggest going to youtube and then just type event loop and the first video that's going to pop up is going to be the event loop bot in browser javascript and i'll talk about it in a second and the nodejs specific event loop video is this one i believe it's 15 minutes long and you can see the name over here so this is a very very useful video where the speaker covers a lot of useful details about node.js loop in great detail and the reason why i'm suggesting the first one as well well what is the language that we use in node that of course is javascript right and even though there's some differences between the event loop the one that we use in the browser and the one that is in the node.js if you understand the concepts behind the event loop that we use in a browser trust me you're already halfway there to understanding how the no js event loop works since it's such an important topic like promised i have prepared some of my own resources as well we'll start with the slides and move on to the closed examples in next video as a side note i made all the course slides available on course api.com again their website name is coors api.com and once you click on the slides link you'll see all the slides and i would want to start our discussion by taking a look at what it means that javascript is synchronous and single threaded and effectively it's just a fancy way of saying that just repeat everything line by line so for example if i have console log with first task then i have a for loop that takes some time in this case two seconds but that could be 10 seconds that could be 20 or whatever and then i have another console log of next task javascript will just start reading everything and it will read it line by line and if this takes a long time it will only run the next test once it's done performing this time consuming one so hopefully that is clear that javascript just reads everything line by line and now let's take a look at our second slide and in here we can see the solution if we would want to offload something to the browser so when we're building browser javascript apps we have this option of offloading to the browser now of course it doesn't mean that we can offload the for loop that's not going to work this effectively is still going to be the blocking code but browser nicely provides the api where we can offload those tasks to the browser and only when the task is done then we execute the callback and probably the example we have done the most is the fetch essentially when we make the network request but we can also do that for example with a set timeout so i still have console.log with first task but then even though my set timeout function has the second argument of zero so essentially i have set timeout function i provide the callback function that's going to be executed in certain amount of time even if this is zero meaning you would expect this one to run right away it only runs after the next task so once javascript is done executing the immediate code only then it executes the callback so in this case we have the set timeout the api that is provided from the browser and we just said that we would want to execute that e in zero seconds so effectively there is no wait time however javascript will first execute this code and only then will execute the callback so that way we can offload those time consuming operations to the browser again it doesn't mean that we can offload for loops it means that browser does provide some apis where we don't have to write the blocking code now let me be very clear though when i say we cannot offload for loops what i mean is that we can still write blocking code in javascript but the browser does provide some nice apis where we can offload those time consuming tasks and that brings us to our main friend the nodejs event loop again before i go over the example let me stress something event loop is somewhat complex and this is just to give you a general understanding so let's imagine this scenario i have an app and just like any cool app i have subscribers or users or however you would want to call them and in this case since my app is so so popular i have eight of them and what do the users do well they're probably being annoying and they're requesting something from the application and as the requests are coming in the event loop is responsible for avoiding this type of scenario so let's imagine this i have all these users the requests are coming in but larry the little decides that in his request there's going to be some kind of time consuming i don't know database crawl or something like that so effectively he's requesting something and behind the scenes in my code that means that i need to perform something that takes a long time so in this case the event loop just registers the callback so it registers what needs to be done when the task is complete because if the event loop wouldn't do that then we would have this scenario where the requests are coming in and because larry is requesting something that takes a long time the rest of the users would have to wait and essentially it's not that the actual operation takes a long time it's just the fact that we're wasting our time on waiting for that operation to be done and only then we can serve the other users but what the event loop does it registers the callback and only when the operation is complete it executes it now keep in mind that again we're not executing this right away when we can effectively it's the same scenario where we run our immediate code first and only then when we have the time we execute the callback so for example in this scenario if i would have hundred console logs after the next task i would run them first and only then the second task would appear here regardless of what is the time set in here because again we're running our immediate tasks first and only then we run the callbacks so the same thing happens here where the requests are coming in let's say that the operation is complete we first registered the callback operation is complete and instead of executing that callback right away it effectively gets put at the end of the line and then when there is no immediate code to run then we execute the callback hopefully that is clear event loop is our best friend because with the help of event loop we can offload some time consuming operations and effectively just keep all our users happy all right and once we have looked at the event loop in theory to hammer this home let's also take a look at some code examples where we can see event loop in action as a side note all code examples are located in the event loop example directory so if you need to take a look just grab the repo and you can find it there and you should be familiar with our first example since it's a async version of read file method so we import read file from the fs module and then we have console.log started our task first then we have read file method where we pass the path we pass the encoding and then of course we have the callback and then in the callback i cancel logged first result and then of course i have completed the first task and then right after the read file i have starting next task and something really interesting in a console i can see that we first cancel logged started the first task then i right away have starting the next task and then of course once i'm done once i get back my result then of course i have hello this is first text file and of course completed first task and again the reason why is this happening because read file is a synchronous and we already know that event loop will offload this in this case to a file system so we start reading the file notice like okay run this line of code then offload this one and only when i get back to the result then run the callback so when the file system responds with error or the data then we invoke this one all right so we offload this task and we just keep on reading the code that's why we have started the first task starting the next one so right away go to the next test and this one this asynchronous one well we're just offloading and then once the response comes back whether it's an error whether it's a success only then we invoke the callback hopefully that is clear now as far as this comment i only added this one because we need to keep in mind that of course i'm just grabbing this code from the file but the file is sitting in the folder so if you were to run nodemon and then directly the filename which is of course going to be in the event loop the path won't match so this path only matches because of course i have app.js but if you'll try to run this code directly in this file that's why it's not going to match and you need to go one level up now my assumption is that you're running it the same as me and you're running that with npm start that's why i kept the path matching to the one in the app.js now our next example so let me clear my app.js i can close the read file as well as package.json and then the next one is set timeout so select here everything and copy and paste in my fgs i'll restart and then i have two console logs and the third one is e in a set timeout and this is pretty typical example for javascript loop as well if you have taken javascript courses which again i assume you have since you're watching the note one you probably remember this example where i got you here is following yeah i have the console log first and i have the second and third and you think that since set timeout is set to zero so since we're saying yeah call this callback function but actually wait only zero seconds you'd think that the order would be first second and third right well wrong because we have first third and second why well because set timeout is asynchronous correct and what happens with asynchronous well they get offloaded so in this case we run first third and then the second because this one gets offloaded again this one goes to the back of the line and only when we're done with our immediate code pretty much with our synchronous code only then we invoke that callback all right now i also added these comments here where i have started operating system process and then completed and exited the operating system process and the reason why i'm showing you that because in next two examples we'll do something a little bit different so now i would want to go to set interval and by the way it's going to be a bit clearer if we run here node and then app.js so let me stop this and i'll go with node and objects and you'll notice that we started the operating system process and then the moment we're done with the code that's it we exit now if we'll take a look at the set interval you'll notice something really interesting where if i go with node and app.js notice something interesting and by the way of course i didn't copy and paste so go to the third example and then just remove all this code and copy and paste so that's my third example and in here i have the set interval now again yes we'll have to run few times node app.js and now check it out so what i see here is i will run first so that's my console log and then i have the set interval and notice how we're not exiting the process here so we start the process similarly to the second example but if in the second example we actually exited because we completed all our tasks in this case we're not doing that why well because set interval is asynchronous now the difference between the set timeout and set interval is the fact that set interval runs in those increments in this case of course it is those two seconds so every two seconds the event loop is just gonna invoke that callback now that's why we're not exiting that's why we're still in the process and we can only exit the process if we kill it so that would be control and c or there's some unexpected error otherwise it will always stay alive now again keep in mind one thing where notice i will run first was first why well because again this is asynchronous and i know i've said this before 20 000 times but again this is probably the core building block of no the fact that every time we have some asynchronous action it's just going to be offloaded and then when it's time we invoke the callback and our last example is a server and again i just wanted to showcase how the process stays alive so i'll take all the code and copy and paste in app.js now i'll stop this one so stop the process and then we'll clear the console and again just to showcase how the process stays live i'm going to go with node and app.js and i'm doing that so you're not confused with nodemon and then check it out so we have server listening on port 5000 and then every time the request comes in well we invoke this callback and in our callback we're simply cancel logging request event and then we send back the hello world so now if i were to go to a localhost 5000 there it is i have the response of hello world and in a console i'll see this request event and check it out how again this process stays alive why well because listen is asynchronous and the moment we set it up now event loop is just waiting for those requests to come in and then once they come in then of course we run our callback now please don't confuse this callback with what we're responding our request i went so this callback is just when we're setting up the server because in here we can have the success over there so in our case as you can see everything went great we have server listening on port 5000 but of course there also might be an error and this one of course just responds to that request event but the whole point is with server.listen we just say hey event loop just keep listening for those incoming requests and the moments show up then respond to them appropriately hopefully it is clear and of course we can move on to our next topic all right and up next i want to talk about asynchronous patterns in node.js so if we remember when we were setting up the file system module we covered how we have two flavors we have the synchronous one and the asynchronous one and while asynchronous one is great since we're not blocking the event loop the problem is that if we're using this callback approach well it gets messy pretty quickly right because we're nesting one callback inside of the other one so now in the following videos i would want to show you the alternative that we'll use throughout the course and why in my opinion it is much cleaner syntax and that's why of course we'll use it and first what i would want is just to kill everything here and i'll start with the nodemon since i'm done showing you the event loop and we're just going to go with npm start right that was the proper one and now i'll delete everything that i currently have not here sorry so i'll leave this one the async one i would want to remove everything in the app.js and now i just want to quickly show you the code that would block that event loop again this is going to be the video where if you don't want to code along you don't have to you can just sit back and relax and effectively you'll be in good shape and again we'll set up the server like i mentioned before already 20 000 times don't worry about specific commands we have rest of the course where we'll be building servers so trust me you'll get sick of it so go with http and require and of course we're looking for http module and then remember the methods create server and listen so we go with const and we create the server that is http and create server we pass in callback a callback takes two objects request object and response object so again essentially request object is what is coming in and response object just represents what we're sending out what essentially we are responding and then i would want to listen on a port again so i run server.listen and then i'll pass in the port of 5000 and then of course we have that callback once the server is ready and in here we can just go with console.log and we'll simply say server is listening on port 5000 server is is listening or just listening listening on port and then of course in my case port is 5000 let's set that up so we should have this listening on port 5000 and then of course in my callback function i would want to check 40 urls because i want to show you how even if we try to get a different resource we're still blocked by other user if he or she is requesting some kind of resource where we have the blocking code and don't worry if this sounds like gibberish you'll see what i mean in a second so remember on the request object we could check for the url so effectively you could check what is the resource that the user is requesting so for example home page would be forward slash and then the about page would be forward slash and about and that is sitting in the property by the name of request and url so request is the object and then url is the property so again we'll do a quick and dirty way we'll just say request url is equal to a forward slash that means it's a homepage and then we just need to go with a res.end and then we'll say home page again later we'll have way more sophisticated approach but for now this will do and then we're checking for the about page okay awesome so this is going to be an about page and then if there's a page that doesn't match any of the resources then of course i'll just send back i don't know error page i'm not going to set up the whole link nothing like that all right we save it and then this should send back about page awesome and then of course in home page i can just respond with the homepage so life is beautiful users can come here and as a side note multiple users i'm representing with these tabs so imagine these are my users and life is beautiful we are requesting resources and we're just going on about our day now the problem is going to be if i go to about and if i set up some kind of blocking code now what would be a blocking code well that could be a nested for loop so i'm just going to go with blocking code and then i'll add some exclamation points and let's simply set up a for loop let's say i is equal to zero and then let's say i is less than thousand and yep i plus plus so every iteration will increase by one however i'll set it up as a nested portal so copy and paste and i'll just change these values to j so j here and j here and then let's just cancel log and we'll say j and i again doesn't really matter what we type there just say i and j now known dialogue question what do you think is gonna happen so if the user navigates to about i mean we can kind of see that this will take some time right now you would expect though that only the user who navigates here gets blocked and you'd be wrong because we'll also block the other suckers who are just trying to get to the homepage so let me navigate here and check this out so i run this one and notice how we're loading now the same thing happens here now and here okay and only when we're done here then these two can get the resource again now of course if i go to my project i can see that in the console i have all these values right because i have this blocking code i have the synchronous code that just takes a long time and this is just a representation of why we prefer this asynchronous now yes at the moment this is messy and don't worry in the next videos we'll fix it but this hopefully gives you an idea why you should always strive setting up your code asynchronously because what we've learned in the previous videos if we do that then those tasks are offloaded and then only when the data is back only when it's ready then we invoke it and that way we're not blocking the other users hopefully it is clear and now of course let's take a look at some other patterns we can use so we still get the benefits so we're not blocking that event loop but we also have a cleaner code where we don't have this nested callback mess all right and once we have covered why it's so important to use the asynchronous approach now of course let's clean up our f a a sync so instead of using these nested callbacks let's see a nicer pattern and as i say note if you want to see the code that we wrote in a previous video and the one we are about to write then the files are located in two async patterns folder so i'll close everything for now and then back in app.js i can remove it like i said if you want to access that code it is sitting in the two async patterns folder and we'll simply start by recreating the read file setup where i'm gonna go with const and i'm right away accessing that from the file system module and i'll set it equal to require of course and then file system all right that's awesome we know that it is asynchronous so we need to set it up with three parameters we go with read file and then we would want to pass in path first so again since i'm in app.js i'm going to be looking for the content and then forward slash and then first txt the file we already created before then we have encoding so comma and then again we're going to go with utf8 and then last one is going to be that callback where the first value is the error and then the second one is the data that we're getting back okay awesome so once the file system responds then of course we invoke this callback and inside of that callback we have our logic so if there's going to be an error for time being i will just return like so and then if i have the data i'll set it up as else so say here console log and data of course and we shouldn't be surprised if we've seen a console hello this is a first text file because we already covered the setup right so we're passing the path we pass in the encoding and then we set up the callback now the problem starts if we would want to perform multiple actions if i want to read two files and then for example write one correct so what would be a better solution well a better solution would be turning this into a promise and then eventually we'll set up async await now please keep in mind that the only reason why i will type out the promise stuff is because i would want you to understand what is happening behind the scenes but don't worry throughout the course we'll just stick with a sync and a weight syntax and essentially you won't have to worry about what is happening behind the scenes but the first example yes i want you to understand everything in detail so what we could do is create a new function and we can just say const and then i'll call this get text now this get text will take a path since i want to read two files and then eventually write one as well just like we did here and of course the goal here is to showcase how we can make the code in the file fs async at least that's how i called my file much cleaner and more readable so again we pass in the path and then what i would want to return from this function is a promise so we go with return new promise and then in the promise object we need to pass in is another callback function so we pass in the callback function and in here we pass in two more functions one for resolve and then one for reject and then once i have set up both of these parameters now of course what i would want is to move the read file and place it inside of the promised one okay so once we place it here first of all notice here how i'm passing in the path so of course i can change this one around so i can say path and then the encoding stays the same as well as the callback however inside of the callback once i have access to resolve and reject what i could simply say that if there is an error i will spit back the error so say reject an error and if everything goes great now of course let's go with resolve and then we'll pass in the data and once we have this setup what's really cool that now i can invoke get text and this is going to return a promise and then of course we can chain that then and catch so below the get text i can go with get text and of course we're looking for the path so we still would need to use dot and then forward slash and then content of course and first txt so that's the path and then like i said we are returning a promise so we can chain that then and of course here i can have the result and i'll just cancel log it for now or result and then i can also chain that catch and here i'm passing in the error so again we can't log it and we simply would want to see the error i save it and beautiful again in a console i have hello this is first text file so i know that it worked and also if i change the path so if i make my path incorrect we should see in the console the error where of course node cannot find file so if that works now of course we can take a look at how we can make it even cleaner by setting up async 08 and once we have our initial setup once we have turned this into a promise technically we're not out of the woods because if i would want to perform again two file reads and then eventually write the file as well and if i would want to do all of that asynchronously it's still going to be paying just by using the promises so what would be a solution well since we're returning a promise if i use async await i can wait till promise is settled and then decide what i would want to do and the way we set that one up is by creating a new function now please keep one thing in mind where eventually throughout the course those functions that i'm about to set up are going to be provided to us so we'll just attach that async to the callback functions that already provided us by the libraries okay but in this example i'll have to create one from the scratch and again the whole point here is because i would want to create a function a start function that i'm going to set up as a synchronous function and i would want to attach a weight so i would only respond once the promise is settled so in here i go const start and that's my function but i need to set it up right away as async because i would want to use my await keyword correct and then we simply go with const and i know that of course i'm looking for the first file and i'll just say first and that one is equal to get text and basically i want to pass in the same thing here now i do need to place this one in quotation marks so my bad i messed it up a little bit okay i passed it in and that should do it now of course what i'm missing here is a weight so i had this await and now only once the promise is resolved then i'll get my response so what i could do here is just comment these two or you know what this one i cannot comment out yet don't worry we will eventually this one i can comment out and then maybe move this below okay so you don't think that i'm running this code and since i have my function now of course i would need to invoke it so invoke start and check it out now of course i don't have the error which is a good sign i guess and then we'll simply go with log and none first and notice the difference where previously when we were setting up the callbacks we had to nest everything now i'm waiting for this promise to be resolved and only once it's resolved then of course i can do something with the value now every time we have this async await approach what we would want is to wrap this e in the try catch block so if something goes wrong then we have at least a little bit of control over it so i'll set up try catch block and then i'll set up my first await and eventually we'll add here more and then in the error i'll simply go with console.log and we'll console log the error and let's just save that one so now we have nice try and catch block and by the way sorry i deleted it we'll still take a look at the first one and then if we change the path then of course we'll get an error okay so that's good now i have my start function it is the synchronous i'm waiting for the promises to resolve they're all wrapped in try catch block so what's next well if you remember in here what were the actions that we were doing well we read two files correct and then we wrote one okay so let's try that one with this new approach where essentially i have first so just copy and paste and then i'll look for the second file remember we should have that in the content so this is going to be the second one second over here and then i would want to write the file now of course you could say well the problem here is going to be that i'll have to write a new wrapping function to set it up as a promise because yes we can of course read the file but functionality for the write file again we would need to wrap it don't worry there's a way how we can get this actually out of the node first i just want to showcase how much cleaner this already is where i can just wait for first second like so and now notice in the console hello this is the first text and hello this is the second file again i fully understand that you're looking at this wrapper function and you're like well this definitely doesn't look that much cleaner than this one don't worry there's a way for us to get those functions in a way that they're already returning a promise what i would want you to focus on is this code what i would want you to understand that this definitely is much cleaner than what we have here we read the file and then we set up another nested callback and another nested callback and hopefully you get the gist waiting for these promises to resolve is definitely a cleaner and more readable approach all right so this works we have our start function it is asynchronous we're waiting for prompts to resolve and we can see that it is already much cleaner how we can set up this code without the wrapping function well what's really cool that in node there is a module by the name of util and we just go here const and we'll assign it to a variable and we'll just be looking for require of course since we would want to import the module and again the name is util and then instead of this module we have a method by the name of promisify and with the use of this function we can take our read file which of course was looking for the callback and turn it into the function that returns a promise and again this is over simplified version what is happening there but hopefully you understand that as a result we'll get again this promise back now the way we'll set that up of course we have read file here already so i cannot use the same name that's why i'll go with read file and we'll call this promise and that one is equal to util that is of course my module dot and then notice the function promisify and then we pass in that read file function so now i have my promise one so now what i could do is first of all comment this out and move it down again so it stays for your reference but it doesn't compromise my view and of course now i have the error because well get text is not defined that's fine don't worry and i'll copy and paste and since i also want to write a new file i will get from the file system one the right file function and then i'll do the same thing where in this case it's going to be called write file promise and then we pass in write file and of course now instead of calling get text what i'm gonna do is go with right file or i'm sorry in this case we're going for read file promise and then keep in mind one thing where this is not a get text one so we're still looking for the path as well as the encoding that's well copy and paste and then second argument we pass in is the encoding and again our functionality shouldn't change where i should see in console the results from the first txt now of course i want to do the same thing with the second one so have read file promise second txt again we have to pass in the encoding otherwise we'll get the buffer back so copy this and paste and again if we cancel log it there it is we have hello this is first text file and this is the second one and since in the line 4 we passed in write file into promisify of course what we could also do is right away write the file so i can go with await and i'm simply not assigning this to a variable because well i'm getting back on the finder as far as data and i'm just going to go with await write file promise and the same spiel we pass in first the path and in this case of course if the file is not there node will create one and the name will be result and i'll just call this mine grenade and then txt and then the second one is data so for that one i'll set up my template string and i'll just say this is awesome awesome and then let's set up the colon and then we'll access both first as well as the second one so we'll interpolate both of them second and then once we save if we take a look at the content there it is now we have the mind grenade one correct now there's probably one where i was testing yep there's one where i was testing so i'll remove this one but if i take a look at dtxd1 then of course i'll have this is awesome hello this is first text file and then i have the second one now what's even more cool that technically we can even skip this part as well again i'll leave this one for your reference but if you go to require and then you require of course file system module but if you add dot promises what do you think is going to return well effectively the same thing so now of course i just need to change the name from read file promise and write file promise back to read file and write file since those are the two functions that i'm importing and that will right away return promises and again we save and remember that by default we're just overwriting stuff so if i were to go and add a third argument my options one and if i'm just going to say flag and i'll set it equal to upend once we save well now we have this is awesome repeat it one more time again just to showcase that our functionality still works i fully understand that there was a little detour where we created our own wrapper function and then we covered how we would consume promises but hopefully this helps you understand that this approach is definitely way better so it is more readable it is more easier to wrap your head around and that's why for the remainder of the course we'll stick with this one again some things will be provided to us by default so libraries will provide the functions that return promises will right away have the callback functions that we'll just set up as async and hopefully you get the gist so a lot of things will be given to us but the core functionality won't change where instead of using callbacks and nesting them inside of the other callbacks and nesting more and more and more we'll set up everything with async await because the syntax is cleaner and way easier to read excellent once we have covered async patterns we're going to use throughout the course now let's talk about events in node.js when working on browser javascript apps a big part of our work is to handle events for example user clicks a button and of course in our program we handle that user hovers over the link and again same deal in our program we are handling that and hopefully you get the gist essentially as our program executes at least in part it is controlled by events of course depending on a program but it's safe to say that in browser app those events are mostly external now that style of programming is actually called event driven programming and effectively it's just that a style in which the flow of the program is at least in part determined by the events that occur as the program executes now it's easier to imagine that of course when you have a gui right the graphical interface just like the button and links example i just mentioned but what about server side is it also possible and of course the answer is yes in fact event driven programming is used heavily in node.js and in the following videos we'll see some of the examples of it and basically the idea is following we listen for specific events and register functions that will execute in response to those events so once our event takes place callback function fires just like in our imaginary button example now before we continue let me stress something our first examples are going to be basic and even somewhat silly but don't let that fool you many builtin modules in node.js do use events under the hood and therefore making events and event driven programming a big part of nodejs all right and once we have covered general concepts behind events as well as eventdriven programming now let's set up our own events in node and the way we do that we come up with a variable and typically this name is event emitter because what we're getting back is the class and we require the events module so require events module and we assign it to a variable which essentially is a class and again a common practice is calling this event emitter and at this point you have two options if you want to create something custom you'll need to extend the class or if you simply want to emit an event as well as listen for it then you can just create the instance so go with the second route we'll go with const and then whatever name you would want in my case i'm just going to call this custom emitter like so and i'll assign it to new emitter so event emitter or however you call this variable and we just need to invoke it so now we have the instance of our class so essentially we have the object now there are many methods in this object however two that we're interested the most are on and emit so on we'll listen for specific amend and then emit of course will emit that event and the way we set it up we go with custom mirror or whatever name you used and then we go with on and at the very basic setup in the on method we just pass in the string where we say the name of the event now in my case i'll name my one response and then of course once i have subscribed to it i also would want to pass in the callback function so essentially when this event takes place well then i would want to do something and in my case i'll just go with console.log and we'll simply say data received or i'll place this one in the template strings and you'll see in a second why so we'll go with data received and then eventually there's going to be some more data and of course once we have subscribed to this specific event now i would want to admit it and the way we do that we just go with custom emitter and of course the method is surprise surprise emit and of course at this point these strings need to match so if i'm emitting the response event and just say here response and what you'll see in the console is wherever you have in callback so of course in my case i have console log data received and then once i run it i have data received in console so that's the most basic setup when it comes to events again we create an instance from the class that we get back from the events module and then we have two methods we have on method as well as the emit method and then in the on method we pass in the string so that's going to be the name of the event as well as the callback function so once this event takes place then of course we would want to do something and in our case we'll just console.log data received and then once we have subscribed to this event then of course we need to emit it and the way we do that we just go with whatever the name is in my case custom emitter then emit method and then we pass in the same string that we're listening for in our case of course response and then the moment we do that we of course have whatever is in the callback function which in of course of course is just a simple log data received all right and once we have covered the basic setup now let me show you some things that i would want you to be aware of first we can have as many methods we would want so for example we have the same event we have here response correct and we are omitting it so nothing stops me here just copy and paste and listen for the same event which of course in our case is this response and then do some other logic in my callback again in my case it's just going to be simple different kinds of log so i'm going to say some other logic here and i'm not going to copy and paste the same function 20 000 times just to prove my point but hopefully understand that yes we can emit our event and then yes also we can have as many functions we would want here that our listening for that event and do some other logic so that's point number one point number two that i would like to make is the fact that this order matters so we first listen for event and then we emit it so for example if i will place my emit above the second function or above both of the functions which you'll notice that i have nothing in a console why well because i first emit the event and only then i listen for it as you can see that doesn't make sense so first we would want to listen for the event and only then we would admit it so in this case notice i don't have this some other logic goes in here because i listen for response and then i right away admit the response and then again i listen for the response but i already admitted the event correct so it doesn't make sense to listen for the event once it has been already emitted so that's the point number two and then thirdly our also on a showcase that we can pass the arguments when we're omitting the event so for example i go here with my emit i pass in the name which is of course response and then i can pass in more arguments for example here i'll go john and then the id number 34. so string and a number and then in my callback function i can access those arguments as parameters just like normal functions so in this case i'll call them name and id and simply in my console.log i'll say name and the second one will be with id and then whatever is that id now i'll add here data received user and then save it and it's no surprise that in the console i see data received user john with id34 now in the second function as you can see i wasn't looking for those arguments i just don't have access to the arguments because i don't have the parameters but it's not like everything broke just because in the event i passed in the arguments and lastly i would just want to reiterate the point that even though you might not write your own events events are a core building block of node and effectively as you're building and writing out the code for your node application you are using those events at the end of the day anyway because a lot of builtin modules rely on them and as a quick side note if you'd like to see the code that we wrote in previous two lectures you can just navigate to 13 event emitter and in order to show that i'll quickly set up a server and again the code for this one you can find at 14 and then request event so copy all the contents from the file and then just copy and paste and notice something interesting where again yes we're getting the http module and remember the setup that we have used so far where we go with http create server and then we pass in this callback function and then of course this callback function will be invoked every time someone visits our server so every time the request comes in now there's another way how we can set it up by using event emitter api so we still create a server we go with http and then create server function but instead of passing in the callback function like we did previously server has the method on does that ring a bell remember our previous example we had our own instance and it had the method of on correct so the same goes for server so server has the method on and we listen for request event and when that request comes in then of course again we have this callback function that handles it so behind the scenes server emits the request event and then of course we can listen for it we can subscribe to it listen for it or respond to it however you'd want to call it and the way we do that we go with server on and then this is a specific name because of course it emits that specific name behind the scene so make sure that it is a request and then the same spiel now how do i know that well if we go to node documentation and if we look for http we keep on scrolling keep on scrolling eventually we'll hit the server and over here i can see that it has a clash okay that's a good start and that what do you see here well i see the event right and what is the event well the name is request so that's how i know that my server the instance that i create has the ability to listen for request events and if you want to dig deeper you can just click on a server you notice that it extends the net server and if we keep on digging check it out so this one extends what it extends the event emitter so hopefully that makes it clear that even though you might not be setting up events on your own a bunch of builtin modules rely heavily on this concept of events all right and up next we have streams in node.js and at its simplest streams are used to read or write sequentially basically when we have to handle and manipulate streaming data for example continuous source or a big file streams come in real handy and now there are four different types of streams we have writable used to write data sequentially then we have readable used to read data sequentially duplex used to both read and write data sequentially and also transform where data can be modified when writing or reading just like with events many builtin modules in node implement streaming interface and what's also interesting streams extend event emitters class which simply means that we can use events like data and and on streams since streams are somewhat off an advanced topic in node i'll try to keep it short and sweet mostly by showing you examples of streams and hopefully that way you get the main idea without being overwhelmed all right and once we know the theory behind the streams now let's take a look at the practical example and a very good use case is using streams when we are reading files because we need to understand one thing where when we use the sync or asynchronous approach what happens we're reading the whole file and of course in our example we were setting this equal to a variable correct but if we have a big file well first of all you're just using all that memory and second as the file size gets bigger and bigger bigger eventually the variable is not going to be good enough you will get an error that i mean the size is too big and you cannot place everything in the string so what would be a solution one solution would be read stream option and the way we'll set this up i'm going to start app.js from scratch but if you take a look at the repo you'll notice this 15 create big file so previously when we were working with files i just had some small files right so i had the first txt blah blah blah result and whatever now before we set up the read stream i would want to create a big file again this is optional you don't have to do that but in my case in order to show you how the streams work yes i'll have to set up a big file and first i'll remove it because of course i already have it since i was testing it and now i'll stop my server and of course in my case i'll run 15 the create big file js if you want to set it on your own and if you don't want to use the repo you can just get the right file sync from the fs module and then notice i have the loop where i believe i have here 10 000 and then every iteration i just write a big txt i of course i have the flag upend and then i'm just adding hello world and starting a new line so if i'll run node and then of course i'm going to go with my file name which is 15 then hyphen create big file and js like so then in the content i should have this big file and once i have my big file i'll go back to app.js and i'll use my npm start since of course i have known mine in place and then let's go with cons now i'm not going to show you how the setup would look like with file sync or the asynchronous one again hopefully you understand that the setup would be exactly the same like we have in 10 and 11 where we had the fa sync and fa async and now of course let's just go with the stream option so the method name is create read stream and we require that from the fs module like so and then we create a new variable and in my case i'll call this stream and we invoke the create read stream and the only thing by default we need to pass in is the path so of course in my case i'm going to go with content and then forward slash and since i just created that text file the big one of course i'm going to go with big txt and now remember the good old friends events well once we create this instance we actually have access to them and the ones that we're going to use is going to be data and error so we can go with stream and then on and remember the event syntax and then the event that you would want to listen for is a data and then we have our callback function and again it is a parameter so we can call whatever we would want but in my case i'm going to go result and let's just console.log the result like so and what you'll notice is that we have 64 kilobytes here that's our first console log then we have another one 464 kilobytes and the reason why i know that is because by default that's the size we're getting and then we're getting the reminder now just to prove my point i'm going to go to my folder and i'm going to look for my content and then in there if you take a look the big text file we created is 169 kilobytes so as you can see now we're reading data in chunks and by default that chunk is 64 kilobytes and every time we cancel log we see that we have 64 64 and eventually we have the remainder so instead of reading everything and placing that in the variable we're doing that in chunks and as you can see we're using the event and the event is data and in order to hammer this home why don't we take a look at the docs so first i'm going to look for my file system and then let's look for our create read stream so we go here as we can see we have this class read stream and then on this class we have these three ones we have close open and ready and as a side note we'll use this one a little bit later as well the open one so keep an eye on this one and then as far as the read stream well as you can see it is created when we go with create read stream and invoke it right so i got the create read stream that's my function i just passed in the past and i invoked it and in turn that returns the read stream right then actual read stream extends from stream.readable so right away i have these events i have close open and ready and like i said we use this open a little bit later now since it is extending from the stream check it out now of course i have the data one all right so this is a chunk of data and as you can see every time we are getting that data we can do something with it now at the moment we're just going to logging it's very simple but eventually as you can already imagine we can do way more useful things than that beautiful once we understand the basics now let's take a look at some additional info like i said by default the size of the buffer is going to be 64 kilobytes however we can also control it and the way we do that is by passing in the object when we're setting up create read stream so first argument is going to be the path which again in my case is going to be that big text file that i created using my file using my for loop and then i can pass in the options object and in there the property that you're looking for the property that controls the size of the buffer has the name of high water mark so for example if i go with 90 000 here then of course you'll see that i'll have two console logs one for 90 kilobytes and the second one will be remainder again keep in mind that our file size is 169 kilobytes that's number one number two we can right away set up the encoding as well so i go with comma and then the property name is encoding and again we'll set it up equal to utf8 like so and then you'll see in a console of course the hello world why well because that is the content coming from the file and lastly i also would want to mention that we have the error event as well so if i go with stream and then on and we're checking for the error and as always we can do something once that error happens so that's our callback function and in this case i'll just access the error property and i'll console.log the error so i'll say here error and the way we check that one out is by providing wrong path so in my case i'm just going to add two dots and then once i save check it out in a console i'll have the error where it tells me that no such file or directory all right and now let's take a look at the practical example when streams come in handy now again this is going to be one of those videos where you don't have to code along you can just sit back and relax and see how i struggle and first what i want is to make it even a bigger file so remember d15 create big file i believe i had 10 iterations right so i'm gonna add one more meaning i'll add one more zero i'll stop my server right now again this is optional you don't have to do that and i'll remove the big file like so and then i'll run one more time the file with node and then of course this file is going to be way bigger so let me navigate to my folder just to showcase that and i'm looking for content and now the big file is 1.8 megs now once i have the big file i'll go with npm start at the moment i just have the stream example but if you want to see the whole code just take a look at the file number 17 and notice again we're creating a http server and i'm just using the read file stick method i'm looking for big txt the encoding is utf8 and then i just place my variable my text one into res dot and method and effectively i'm just sending my big text file and let me restart the server here so let me go with npm start right now so let me select everything from this file and copy and paste and now if we navigate to localhost 5000 we should see a bunch of hello world now the problem with the setup is following where if i go to developer tools and if i take a look at the network and if i refresh yep this request was successful take a look at the size do you think it is the smartest thing to send these type of files over the wire and of course this is just going to make it very difficult to all your users because you're just sending large chunks of data effectively i'm sending the whole file and more specifically if i click check it out so i have the request url okay that is good the method is get now as you can see the content length is my 1.8 megs right and you'll see in a second that once we refactor this to read stream method that we're sending data in the chunks and again the best way to see that is by looking at the headers where at the moment i can see the content length and that one is at 1.8 megs but once we refactor that the setup is going to be different so at the moment i have this text i'm accessing that by read file sync so comment this out and let's set it up with our create read stream so i'll go with const and i'll call this file stream and this is going to be equal to fs and then create read stream now use the same address so use the same path and then i'll use the same encoding as well so let's go with utf8 okay awesome and once we set up the stream remember we have access to to events file stream on and of course i'm going to be looking for the open and i'll have my callback function and we'll set that functionality up in a second and the second one of course is the error so go with file stream and then on and again we're looking for the event by the name of error and then in our callback function we can access the error and i'll simply pass it in in my response so if there is an error i'll just grab the error from my parameter and pass it in now as far as the open here instead of setting it equal to instead of going res dot end and then text file stream also have the pipe method so we can go to file stream and then pipe and what the pipe is doing it is pushing from the read stream into right stream so you can imagine that if we can read data in chunks we can also write data in chunks and what happens under the herd response object can be set up as a writable stream so we have our file stream so that's our read stream we have method of pipe so we're piping this into a writable stream and now of course i'll pass in my response object and if we go back to the browser and if we'll refresh now notice something interesting yeah still same request right to localhost 5000 still same size but if i take a look at the headers now i can see that my response headers are chunked so instead of sending our file back in one large instance we're sending it back in chunks awesome congrats on completing section number three node fundamentals and hopefully after watching the section you have a good general understanding of how node works and now that we're big shots let's apply that knowledge and build some servers shall we and we're going to start section 4 with the general info of how the web works more specifically how we exchange data on the web and we're going to do that with the help of few slides now if you're one of the people who's already reached a daily slide limit i hear you once we're done with these suckers i promise we'll mostly actually write code for the remainder of the course i do believe though that before we build an actual web server it's crucial for us to understand how it works under the hood and that way we'll have clear understanding of what tasks need to be done if something is iffy you can always go back to the slides you already know where they're located and also as we're going to be progressing with the course from time to time i will swing back to them when i'll need to emphasize a specific point with that said let's talk about how we exchange data on the web um it's safe to say that if you're watching this video you know how to use a web browser but under the hood the way it works every time we open up a browser and we type the url so the web address we're actually performing a request and we are performing a request to the server that is responsible serving those resources so for example when you look for cnn.com you're looking for a server that has those resources and then that server sends you back the response and the same works with youtube the same works with johnsmeld.com or whatever so you just pick a resource you say hey can i get this data and then server who is responsible for those resources just sends you back the response now that is done using http protocol and that's why these ones are called http messages so the user sends the http request message and then the server sends the http response message and that's how we exchange data on web and for the remainder of the course we'll be responsible for building such web server using node and more specifically express now i'll talk about it while we use express as well show you a few examples later on in a course but for now just remember that yes we'll use node but in order to make our lives easier we'll use the framework by the name of express js and lastly i would just want to mention that even though name server definitely sounds way cooler than the computer at the end of the day they're just computers whose job is to always make that resource available so yes those are computers and yes there are some differences for example they most likely don't have the graphical interface or the gui and also they're probably much bigger than your laptop but at the end of the day they are computers whose job is to always make sure that that resource is available because imagine if you would have a server that only works from eight to five so if you go to your website at i don't know six o'clock at night you cannot access the resource probably that's not the service that you would pick so next time when someone asks you if it rains does the cloud still work you know what to answer because at the end of the day when we talk about cloud cloud is just a bunch of these servers bunch of these computers connected together beautiful and once we have a general understanding how data is exchanged on a web let's also cover how http messages are structured please keep in mind that since it's going to be a big part of our job we'll come back to this particular slide more than once so if you're if you're about something just please be patient and i'll answer all of your questions as we move along with the course with that said the general structure for both messages is similar they both have a start line they both have optional headers a blank line that indicates that all the meta info has been sent and effectively headers are that meta info as well as optional body and before we continue again let me stress something so request messages are what the user is sending so for example if you open up the browser to search the web or that could be your web application because remember with web applications we also can make http requests correct and then response is going to be our responsibility so we'll have to set up a proper server that sends a correct response and in general when we talk about the request message in start line there's going to be a method then the url as well as the http version now we are mostly going to be interested in these two things in the method as well as the url now there's going to be a separate slide about the methods as well and don't worry we'll cover that in a greater detail once we cover them with actual code examples so i'll come back to that slide just understand the general idea that when we talk about methods effectively we're communicating what we would want to do so for example if i want to get the resource i'm going to set it up as a get request now if i want to add the resource then of course this is going to be a post request and then of course you can read the rest now why i'm displaying here this get because that is the default request that the browser performs since when we open up the browser we want to get some kind of resource correct that's why we're performing a get request and the url is just the address and that could be for example johnsmilk.com or that could be i don't know espn forward slash basketball both of them are just a web addresses now headers is essentially optional where this is a meta information about our request and just to give you a general idea how the headers would look like they would look something like this so it is a key value pairs now don't freak out as you know when you search the web you don't need to add them manually and the same is going to be with our server a lot of it is going to be taken care of but yes some things we'll have to add on our own basically this is going to be information about our message and then we also have optional body so when the user is requesting something if you just want the resource there is nobody there's nothing basically what to send however if we would want to add a resource onto the server yes then you are expected to provide that data and it's also called payload so again i might use them interchangeably so that's the general structure of the request message we have the start line we have the headers that is the information about our message as well as the black line which just indicates that we're done with the meta information and optional body which we'll use from time to time and now of course we need to talk about the response message so response message is what we're going to be creating again most of it will be done for us but some parts yes we'll have to do it manually and it's going to be our responsibility so the start line has the http version which most likely is going to be 1.1 then we have a status code and status text now when it comes to status code it just signals what is the result of the request so for example notice here this 200 that means that request was successful so that's what we're sending back and yes there's quite a few of those codes and as we move along with the course of course we will cover them but please please please don't rush over to the search engine and start memorizing the status codes pretty much as we're going to be building the application i'll tell you which code means what and for example 400 means that there was some kind of request error so the user was trying to request some kind of research and with 400 there was a request error now for example the code 404 means that the resource is not found so when i'm sending back the message i'm like hey listen here's the status code for the message if you are successful here's 200 if there was an error for example you get a 400 if the request is unauthorized then you can get 401 and hopefully you get the gist and yes of course as we're progressing we will cover more status code then again we have the headers where basically we provide info about our message our response message and again like i said you won't have to type everything line by line but effectively it is a setup of key value pairs and the ones that i would like to mention are these ones notice this content type we have text html that is when we're sending back the html but also our second option is going to be sending back the data so hopefully you are aware that when you're building a web application when we communicate with api most of the time we're getting back the json data because over the web effectively we just send over the string so if for example i have some kind of array we transfer this into application json and i clearly indicate that in my headers where i say that no i'm not sending text and html i'm actually sending a application json and then that application who is requesting the web application knows that hey from the server i'm getting a content type which is application json so for example in that case i could send back here this array with bunch of these objects and just to give you a realworld taste why don't we do this open up a new browser tab and i'm simply going to course api because i think there's going to be less data so there's going to be less clutter so go to course api here and then you can either pick the slides or you can just look at the home page and if you inspect and if you look in the browser tab you'll find a network and very useful one is this one where we can just look for all the requests we refresh and then check it out so these are the requests that browser performed and i'll talk about it a bit later why there's also this style css in fact that's going to be one of our first examples but take a look at this one so i have this course api and then forward slash and if you remember when we were building our original server what i said that if we have this forward slash that just means home page so if we're just navigating to courseapi.com and that is our homepage we simply add this forward slash now of course in the browser that's automatically added but that's why when we're setting up the server one of the cases is going to be if the user navigates to the homepage then we simply look for forward slash so if for example you go to the slides you'll notice that uh in this case i would have to refresh notice here i have the course api forward slash slides so that is already a page in my website correct so i have the home page course api and then i have the slides page where i have the slides and if you take a look if you click on it notice all the useful data that we get over here so for example this is going to be our request url which is going to be again course api.com so that tells me well what the browser is trying to get then check it out the method why it's get because that is default in the browsers every time you open up the browser and search something then of course you'll be performing a get request now check out this one the status code it is 200 why because everything is successful because servers send back the data then we have this remote address and basically that is the ip address for my server as well as notice this colon 443 and we'll come back to this one when we set up our own server because if you remember we were always setting up the 5000 so you're probably wondering well what is this 443 and don't worry again we'll cover that one once we set up our first server and then again we have response headers for example and we also have the request adders so as you can see using this network tab we can actually find a bunch of useful information now notice here in the second set of tabs i can see this response and preview so if you take a look at the preview this is going to be basically my site and also i can see the response so as you can see pretty much sending back the html so i'm sending back the website so you go into the browser you request a resource by default it is a get request and then in that body when the server sends it back this is what we get back so we get back the site so hopefully this gives you a clear understanding of how the http messages are structured and now let's dive into creating our own server awesome once we're done with the slides now let's start setting up our server and in order to follow along with the course you'll need to have a starter project and you can get it if you navigate to my site again the url is johnsmilk.com so navigate there in the project or in home page look for node express tutorial project in a home page is going to be at the bottom in latest project if you cannot find it there then look for all projects page or simply projects page then filter for node in order to save some time and then like i already previously mentioned any of these links will get you to the repo and then bravely get the repo in my case i'm going to clone it so i'll copy the url i'll bump up the sound size in my terminal navigate to the desktop get clone here and then i'm gonna get the repo and then once the project is on my machine i'm just gonna drag and drop and then the first thing that i would suggest doing is removing the remote url and you can simply do that by just wiping out the git folder so that way if you ever do decide you push this up to the github you won't have some dumb permission errors so i'm just going to open up the integrated terminal now in my case i'm not going to run the command but if you're on mac i suggest running rm then hyphen rf and then get now if you are on windows some students have just these two commands now i haven't tested them yet but some people have replied to my tweet that yes they do work and if you want to see the whole tweet just navigate to my twitter the handle is john underscore smilga and then as you can see here is the mac command and for windows i have these two so run this command and then in next video i'll give you a brief overview of the repo all right and before we get busy why don't i give you a brief overview of the ripple and if you take a look at the first project this should look very very familiar because essentially this is all the code we have written so far everything starting with our most basic application and then of course we also have our last one our http streams example so hopefully that is clear and if you ever need to jog your memory essentially this is just here for your reference and then from now on we'll work in a folder number two by the name of express tutorial and the idea is gonna be exactly the same where basically we build a bunch of examples and in the process we learned what is express and why we would prefer using express instead of straight up http module but again let me stress something where express is built on top of node and more specifically on top of http module so it's not like you can use express without node and in folder two the setup is following where there are gonna be some assets that i provided just so we can make more real world examples so hopefully that gives you a better idea how the express works and i'm not going to cover them right now for example methods public or navbar app once we get there i'll explain everything that's happening i think that it's going to be waste of our time if i do that right now however if you take a look at the final folder you'll basically see all our examples so the same spiel if you ever need to reference the code just navigate to the final look for the file name and then of course you'll find the code just keep in mind that in order to run this code you'll have to copy and paste and run it in the app.js why because in some cases there's going to be paths and since these files are located already in the final the paths won't match okay hopefully that one is clear as well and then we also should be familiar with these files as you can see i have package.json i have package.json lock and then app.js now of course app.js could be renamed server or whatever you would want but i already have in a package.json a script that spins up the nodemon and effectively we have successfully set up a node application so package.json is of course needed because we'll have some dependencies more specifically two one is going to be nodemod and the second one is going to be express and in order to of course keep track of those dependencies we have package.json and then if you notice i don't have the node modules here and of course the reason for that is because i don't want this repo to be massive and you can clearly see that in a git ignore where i have node modules included so when i was pushing this up to the github and of course i omitted the node modules since i added them in the git ignore and then in the package json like i said you'll find some dependencies and i'll talk about express once we get there the moment let's not worry about it the one that we should be familiar with is node one which is going to be watching our application and i have a script that sets up nodemon and passes in the amp.js so any changes in our project nodemon will be watching and restarting our application however we cannot do anything before we install all dependencies otherwise you'll just get an error so that's why the first thing that i would want you to do is navigate to the folder number two and the fastest way probably is just going to be cd and then take the project number two and drag and drop like so and then once you can see that you are in this folder so not in a root not in node express course but once you are actually in the folder number two before you do anything just run npm install first and then it's really up to you you can either wait for all the dependencies to be installed and then run npm start or you can simply chain it and say npm and once you run this one then of course you'll install dependencies and if you see in a terminal express tutorial that means that everything is correct and you can continue with the videos if you don't see that then please troubleshoot because none of the things that we're about to do next are going to make sense if you're not running the project number two with all the dependencies more specifically nodemon and express and lastly i just want to mention yes there's also this data.js and again this is one of the assets that i added that we're going to use a little bit later so if you see express tutorial in a console and the reason why it's there because that's the only line of code i have in my app.js that means that everything is correct and we can move on to our next topic and why don't we start the express tutorial part by setting up the server one more time with straight up http module and in a process let's struggle a little bit let's see why we would want to use express e in the first place so yes we'll build one more time server with http module however now of course we'll dive deep into the topics that we kind of skipped over before and in order to set up the server we know that we would need to require the module right so i'm going to come up with some kind of variable and in my case that is going to be http and of course the name is not required you can call this whatever you'd want but it is somewhat off a convention to call this hdp as far as the variable name then we go with require and we just go with http again keep in mind this comes built in node so you don't have to install it we didn't install when we ran npm installed in last video we installed two other dependencies but this one is built in so we don't have to do anything we just say require and it's always going to be available to us then we need to set up the server and again convention is calling the server but you can call this box bunny and in order to do that we go with http and then on this object we have a method by the name of create server now this method takes a callback which is going to be invoked every time the user hits our server and in this callback we have two parameters and again we can call them whatever we would want so again common convention is just shorten this up a little bit and call it request and res so rec and res and the first parameter references the request object and second one is the response object and at this point it should be clear why we have access to those two parameters because in the http cycle we have request message that is coming in every time user requests the resource and also we have the response message right so that's what we need to send out so that's why in this function that runs every time user hits the server we have access to rec and res so that way we can find info about the incoming request because it makes a total sense if we have access to that info i do want to know what is the method so what the user is trying to do i do want to know what resource the user is trying to get whether that is the contact page or about page and also i would want to know whether i'm getting some data whether user is trying to add something onto the server and as far as the response well in order to serve the data i need to be extremely specific about what i'm sending so i need to explain to the browser what is coming in hopefully that is clear and in here we can just go with log and we'll say user hit the server and then we return the object from this create server and on that object we have a method by the name of listen so in order for the server to work we need to invoke listen and we need to be a bit more specific and we need to say well what port are we listening for and you're probably wondering well what's up with this port what's up with this 5000 value and the best explanation i can give you is this one imagine scenario where you have some kind of issue with your bank what do you do or that could be a phone company it doesn't really matter but i'm just going to give you a bank example what do you do you call the customer service and what is the first question that they ask you they say please describe your issue so we may better assist with your call and what do they do they give you options right so they say if you want to increase your credit limit this is going to be option number one all the way to canceling the account which maybe is going to be option number eight so they don't just randomly assist you a person they say hey what is the issue and this is the person that can serve you the best so if you press 8 you can assume that you're probably going to be speaking with someone who deals with that all the time and same goes here so if you go online and if you search for port this is just going to be a communication endpoint and we need to understand that for http traffic we have specific ports so for http we actually have port 80 because there's other ports as well if you keep on scrolling here and by the way this is wikipedia example we have port 20 which is for file transfer protocol so this is going to be for data transfer then we have port 22 for secure shell so http traffic is only one of the things that we set up on a server and once our application is in deployment we have specific ports for that we have 80 that is going to be for just http and we also have 443 which is going to be 40 secure communication that's why when you go to course api or any other website that uses https you'll notice that there is a ip address and then more specifically 443 and you can also think of this as a apartment building so every apartment building has the same exact address right but the apartments differ so the same works here so on that server if i want to access it using ssh so secure shell i'm going to use port 22 but then if for example i want to use http protocol and if i want to access resource that way then i'm going to use port 443 so once your server is already in production yes these ports are not random there are specific ports for specific things we would want to do again back to our bank example if i want to cancel the account then i'm always going to be directed to that person because i'm going to click option number eight if i want to increase the limit then of course i'm going to be directed to a different person now while we're in development this is really arbitrary i can go here with five thousand i can go here with three thousand eight thousand wherever you would want i believe the ports between zero and thousand twenty four are already taken so you shouldn't be using them but in local development again this is an arbitrary number and that's why you can use anything you would want and again the most common example create react app where we spin up the server on localhost 3000 then gatsby has i believe eight thousand and then netlify cli has 8080 and i can go on and on and on so in my case i just went with 5000 but if you don't like this number just use a different port but of course please remember the actual value for the port because you'll need it once you need to access now if you're wondering well what happens once we deploy our application just put the pin on that and once we get to deployment of course i'm going to cover how actually we set it up that we serve that traffic on the port 80 for example for http or 443 for https and now of course we can go and test it out so let me navigate to my browser and i'm just going to go with localhost and eight thousand and or i'm sorry i just said five thousand and for some reason i went to eight which is gonna be the gatsby one and you'll see this interesting spinner so what's happening over here well the thing is yeah the user hit the server as you can see user hit the server that is what i see in the terminal however remember we have the response right so we have access to the response object and now we need to send back some info to the browser otherwise the browser is like okay so i hit this resource but nothing is happening and there's a method that we always always need to include in our response and the method name is and and i right away went to node docs of course again if you want to navigate there yourself please do so but i already right away went for response dot end and as you can see this method signals to the server that all the response headers and body have been sent and as a side note we'll do the headers in the next video because this one is already getting quite long that server should consider this message complete the method response and must be called on each response so for the browser not to be confused we need to go with res that end so res dot and that is one of the methods that is available on this response object and here we can either pass the text or we can set up for example html and in this case i'm just going to say home page that's it i'll just pass in the string and if we were to go back to localhost 5000 there it is now we have our homepage response and we can clearly see that in our terminal because every time you refresh the browser you'll have this console log in a terminal user hit the service hopefully everything is clear again we have access to http module and that is built in node and we just set it up some kind of variable most common convention is calling this http then on there we have create server method that takes in the callback which is going to be invoked every time the user hits the server and as parameters we have a request and response object and common convention is just calling the american res now of course you can call this stockhold burrito if you want but again common convention is calling this iraq and res and the reason why we have access to those objects is because in the http cycle that's what happens we have a request message that is coming in where we can find a bunch of useful info about the request that is coming in and then of course we need to respond to the browser in a meaningful manner so that's why we also have the response object and in every response we should always have end which is going to signal that the communication is over and then we just need to set up the port and again in development we just come up with arbitrary numbers and in my case we go with 5000 and we pass in that port in the dot listen method which is available when we invoke create server because we get back the object hopefully the basics are clear and now we can start expanding on our knowledge all right we're done with the basics but there are two major issues with our current setup first of all we don't provide any info about the data that we're sending back so we don't have any metadata about the body that we're sending out so we're not providing any information we just go rest that end and then pass in the string so that's issue number one and then issue number two if i were to go to the local host 5000 and if i type about or if i type contact or whatever you'll see that of course we're sending back the same response each and every time so if we go with contact again this is going to be a home page so why don't we deal with issue number one first where we provide more info to the browser of what we're actually sending back and then in the next video we'll deal with the request and the way we provide more info we just need to add more methods now specifically one more method and that is going to be res dot write head and in there you can probably already guess that we're just providing headers so we're providing metadata about our response and we go here with res dot and then we go with right head so right head and then we need to provide a few things we start with a status code and i'll talk about the status code in a second and for time being i'll just pass in 200 which just means that the request was successful and then we pass in the headers and one of the most common headers is the content type so this is where i specifically say to the browser hey listen i'm sending back html or i'm sending back css so where i'm sending back the image so browser knows well what to do how to render that content and like i mentioned already previously this is done using key value pairs so we go with content type so that's the name of the header and then we pass in text and then if for example i want to pass in the html i go with text forward slash and then html and now of course in this case where i have the res.end i can set up the html so for example i could go with heading 1 and i'll say homepage same deal home page now if you want you can keep it this way where you have res that end and you directly pass in the html however i like to use better this approach where i go with res dot write and we do the same thing we pass in essentially the body and i set up my html here in the right or any content that i'm sending back and then explicitly call res.n again if you want you can pass this heading 1 into the end just make sure that you have the end and you saw that in a docs where it says if data is specified in a similar effect to calling response.write and then we pass in the data followed by res.n but you always always need to call res.n so this is really up to you if you want you can pass this directly into res.n i like to write it a bit explicitly where i say res.right so that is my body and then i just end the communication by calling res.n and now of course if i go back to the browser again i'll still have the same issue where it's going to be displayed for every request meaning either contact page homepage or whatever but now i provide way more useful info to the browser where browser knows hey i'm getting back the html so i'll need to render html and this stuff matters so let me show you if i change the content type back for example to plain and if i save and if you refresh now notice this is now treated as a text it's not treated as html so whatever you set up over here in the content type yes it does matter now express takes care of that so we won't have to do that but i just want to let you know that if you will be setting up the headers yourself yes the stuff that you type here matters and as the note it is also called mime type or you can think of it as media type so whatever we're sending back and now let's go over the status codes as well as other options for mime types and this is where i would like to introduce an awesome resource for anything http related and that is going to be no other than the mozilla docs so if you go to http and status codes you'll see probably the first link is going to be to the mdn and as you can see http response status codes indicate whether specific http request has been successfully completed and like i mentioned before there are quite a few groups over here and there are quite a few codes but i would strongly discourage you from spending your weekend on memorizing the codes as we're going to be progressing with the course as we're going to be creating more complex applications of course we'll introduce more and more status codes but the main idea is following where when we send back the response i'm just saying is it successful maybe the resource wasn't available so then i sent back 404 or maybe there was a bad request that's why there's also option 400 and hopefully you get an idea where we are setting up that status code so the browser knows what is happening with the request was it successful was there an error maybe i don't know you're not authorized to access it and on and on and on and if you keep on scrolling notice so the 100 ones are going to be informational responses then for successful one we have 200 so that probably is going to be the one that you'll use the most so that means that request has succeeded then we have 201 also something that we'll use throughout the course a lot and this one is once the post request is successful so if you add the resource successfully onto the server then you just send back to one we have 300s for redirect and then these are the ones that you probably don't want to get if you are surfing the web so 400 is for bad requests so for example you are requesting some kind of data or you're trying to do something on the server but you don't provide the info so i don't know i'm trying to add the user but i don't provide the username something along those lines then 401 is for unauthorized then 403 forbidden and 404 not found so in our case we'll set up a response if the user is trying to access the resource that does not exist so hopefully it is clear that is the status code again i wouldn't suggest memorizing it as we are moving along with the course of course we'll cover more status codes just understand the main idea where you attach that status code to let the browser know hey what's happening and it is very important that you use the correct status codes because we are in charge here nothing stops me from sending back the 404 here meaning the resource is not found and then when you navigate to the contact page for example here and if you inspect again the browser network tab you'll see this confusion info where 404 is technically not found right but at the same time we are sending back the correct resource so yes whatever we type as far as the status code it does matter it's not just some random info and that just reflects what is happening with the request and then lastly let's talk about mime types same deal just go to your favorite search engine and just type mime and types and again i suggest using the mdn and these are just going to be media types so whatever we're sending back there's quite a few out there now again express takes care of that so we don't need to worry about it but if you ever need to set it up i don't suggest memorizing them the ones that you'll need to use you'll pretty much be able to google it right away you can also use the npm packages so no you don't need to go and memorize them again just remember the main idea where you're sending back something right and you need to describe to the browser well what are you sending back are you sending back the image are you sending back css are you sending back the html and as you saw in a previous example if you change that mime type if you change that content type header yes the browser will interpret that differently and once we successfully have set up more proper response now let's start dealing with the request object beautiful and with our basic headers in place now let's deal with the request object and like i already previously mentioned it's just a giant object and if of course we can slog it then we'll see it in a terminal so i'm going to go back to my localhost 5000 and as i said note this is getting quite busy so i can just remove some of the tabs and if i just refresh the browser i should see in a terminal a giant object so what are we looking for well let's go back to our slide and remember the start line we had a method so that signals what the user is trying to do either get the resource post a resource or whatever and then we have the url now in order to save us a little bit of time i won't cover the methods with http we'll just deal with the url but we will cover of course methods once we hit the express for now i'm just going to assume that the only thing that the users are trying to do they just want to get the resources from our server so that's why we won't look for the method just keep in mind that yes of course those methods are available on this request object there is a property by the name of i believe it was just simply a method so if we cancel log and if i refresh notice here in a terminal it says get so the user is performing a get request so the user is trying to get the resource so that's one thing that we could take a look at and the other one is actually the url so let me uncomment this one and i'm looking for the url property and again i refresh and now in the console i should have this forward slash contact so that just means that the user is trying to access the resource by the name of contact and if of course the resource is there awesome we send something back if not then most likely would send back the 404 now if i delete that contact and if i simply go with 5000 notice i'm going to have the forward slash so again this just signals that we're getting the home page so forward slash is going to be the home page and then whatever other resource we would want we would have port slash and then the resource now sometimes those resources are going to be forward slash resource name and then another forward slash and another resource name and on and on and on you can really type here whatever you want so again i go with localhost about and then info and i don't know something john right so i can add that here and there it is now i'm requesting this resource and if it's not there we send back 404 if it's there then of course we send back the useful info so hopefully that is clear yes this will just mean that it is a homepage and whatever comes after the homepage well that's the resource that the user is trying to access and now of course we can set up the if statement whereas say yes if it is a home page please send back this html if it is about page then send something else and then if i cannot find that resource that you're looking for then we'll send back 404. now there's going to be a little bit of copy and pasting just so we can save a little bit of time we're just going to go with if and actually we can set this up as a property so let's go to const url is equal to request url and then we'll say if url is equal to forward slash what does that mean well that means that it is a homepage so let's grab these three lines of code and move them up and now of course i want to set up else if now i'll just set up one for the about page so if url is equal to about page then we'll do something else and if none of those match well then i'll just say else and i'll send back 404 now i will add some comments here just so we are clear on what is happening so this is going to be about page then this is going to be called home page home page and then we're going to have the 404 so resource not found so again in order to save us a little bit of time let's just copy and paste one and two and again content type will be exactly the same so that is going to be html because we'll send back the html i'll say about and i don't know page let's call that and then last one is going to be the 404 so in here of course we're not going to send back 200. 200 is for successful request now of course i want to say hey listen the resource that you're trying to access well it doesn't exist on my server so here i go with 404 and again i go with the same content type text html and then let's just send back the heading 1 with page not found so save this one and now of course once i refresh check it out i get this page not found why well because there is no resource forward slash about info and john but if i go to just about there it is now of course i have my about page and then if i go back to the homepage of course i have heading 1 with a home page now we optionally if we want we can add the status text as well and in order to see that let's just go back to the node docs so this is going to be the http and of course i'm looking for right head and we have a right head here notice we have status code optionally we can pass in status message and then we have the headers so again let's go back to our slide this is the most important one status code and then the status text essentially is just going to be added in this case we don't need to do anything because again if we were to go back to the browser network tab and if we take a look at our localhost there is first of all this is forward slash that just means that we're going to the homepage and the status code is 200 and then we have this status text now again if i navigate to a page that doesn't exist for example john then of course i'm going to get the 404 so that's the status code and then the status text is not found so hopefully it is clear now we have a bit more meaningful server where we have multiple resources we have home page we have the about page and also we have the error page and with this in place now of course we can start working on more complex setup nice and with our most basic example in place now i'm going to start throwing mine grenades at you first of all i want to let you know that of course we're not limited to passing in the html directly into the dot right or that end meaning imagine if you would have to every time just set it up or your html in methods directly of course what we can do instead is set up the file then require the file using the file system and then just pass it in now keep in mind one thing though where we will be passing in the contents of the file not the file itself and that's very important we'll be passing in the contents of the file so that means we still need to use this content type just because we're going to be getting the data from the html file doesn't really mean anything yes it's nice it's going to make our lives easier if you want to set up a more meaningful web page but we still need to set up the content type now this is going to be a temporary file because in the next video we'll cover a more serious example and i already prepared all the files for you so this is where we'll really struggle and this is where i'll show you why we use the express but for now if you want to follow along just create a simple index html or about html doesn't really matter how you call the file in the folder again this is really optional i'm going to go with new file and i'm gonna call this index html and again the whole reason why i'm doing that because i wanna set up a more proper page and i don't wanna type everything here in the right or end i mean it's much more nicer here right so i'm just going to go with emma setup in visual studio code i get my basics and i can say home page home page and then i'm just going to go with a heading 4 of hello world again this is just a showcase that sky is the limit just like you normally would set up to html you can do exactly the same thing and then i'm going to go back to app.js and first of all i'm going to get the read file so i'm gonna go with const and then read file and sync and i'm gonna talk about why i'm using this thing in a second so don't freak out i know i mentioned before that we need to be mindful of the methods that we use that there is a difference between the blocking and nonblocking and i'm just going to go with fs over here and we need to come up with some kind of name and again in the next video there's going to be more data here so that's why i'll say get all files for time being in this video i'll just get one and i'm going to call this home page again call it whatever you would want you can call this bobby lee doesn't really matter it's just a variable and we're going to go with read file and sync and of course where's the file it is in the same folder so we go with relative path and i'm just going to call this index html now again we're getting the contents now why i'm using here they read file sync well there's two reasons first of all we need to keep in mind that we're not invoking this every time someone comes to the server please keep in mind that we require that file when we instantiate our server so basically that initial time when the server starts running so it's not like when the request comes in then again every time we're requesting the file yes of course if i were to place this in the if block yeah that's a different scenario meaning if i were to even place this in a create server again same scenario but not in here again we're just requesting this once that's the first reason why i went with that and second it's just an example so i want to make my life a little bit easier what i want to focus on is something else with this home page in place now of course what i would want is to go back to my if where i'm checking for the homepage and instead of going with res.right and then typing it out i'm just going to go with our content now again we're still keeping this one the text.html and i'll show you in a second what happens if we change it to a text plane and now we go with a homepage and now be prepared to be amazed because if i go to not john my resource of course doesn't exist there it is check it out we have home page as well as the hello world so we can start making some meaningful html pages and we can serve them with our awesome server and just to reemphasize my point if we change this to a plane and save and refresh now of course we're getting a text so yes it is very important of what content type we are setting up so let's go back to html and now of course we are in good shape awesome we have our homepage and now of course i can go to index.html and go wild and crazy with my page setup not bad not bad now we know that we can access the contents of the file directly so of course we can set up proper pages but now let me throw you a mine grenade where we'll have to add way more code here if we want to really serve some meaningful web page and the example is going to be following if you navigate to navbar app so that's the folder you'll find index.html you'll find style css logo svg as well as browser hyphen app.js and i simply call this browser app file so you're not confused between the two so this is going to be for our server and this is our browser app and effectively this is a complete app that we set up i believe in my javascript course when we were building projects so effectively this is a little navbar with a toggle functionality and let me assure you something right from the get go the app works so if you get any issues along the way it's because the node is not working the app itself is going to work and i can simply showcase that if i go to navbar app and i'm going to copy that one and i'll place it on my desktop and then if you spin up the index html i can guarantee you that this is going to work there it is that's my application and i can make it smaller and there it is now i'm toggling again our goal is following i want to take this project index.html with style css logo as well as the javascript file so the html structure the styling the logo that you can see over here as well as the logic i want to take all of it and serve it on my server and i know that the app works so all that is good so let's see what struggles we're going to have along the way so here i have the home page right and instead of getting it from the index.html which by the way i'm going to delete because again this was just temporary now of course i would want to access this one from the navbar app that's the folder name right and then i'm looking for the index html and i simply just need to change my path where instead of getting it index html from the root which doesn't exist anymore i'm going to go to navbar hyphen app and then of course i still get the homepage and as you can see i'm still serving also the contents from that index.html the only thing i did is just change the path that's it and technically we should see exactly the same right but here's the kicker we navigate here and if i refresh what is happening i don't have the logo i don't have the button i mean i do have the button but it doesn't do anything and i can see only the structure and we have quite a few 404s here and actually to give you a good idea why is this happening i want to navigate back to our project and let's just console log the urls and i think this is going to give you a clear message why this is happening so let me go back and i'm just going to refresh one more time and check it out so we're requesting the homepage so that makes sense right so i come here i request the home page and i serve this html file from the navbar app and then i have three more requests i have one for styles one for browser and one for logo now why is that happening well because in my index html if you check it out of course i do reference the style css because i want to add the styling right i do reference the logo because the logo is right here in my folder and also of course i do have the one for the app right the one where i have my logic so this is what happens we send back the initial html content and the browser starts reading the content and every time we have basically a path to our server browser is like hey server give me this resource so give me style css give me logo svg as well as whatever we have here the browser app right so keep in mind that these ones are for icons and actually they are external so this one goes to phantasm that's a little bit different scenario yes the browser still performs this request but of course this is external resource now these ones are on our server but the problem is following are we handling these requests in our create server and of course the answer is no we handle forward slash we handle about and then for everything else we have this 404 so to answer your question yes now manually we'll have to request all the files so lower svg style css as well as the browser app assign them to some kind of variable and set up these paths again this is just an example if you don't want to follow along if you just want to see how it's going to work just sit back and relax but in my case i'm going to request all these resources here and then set up more else if statements where if the browser wants to get the css then of course we'll search css if the browser wants to have logo then of course the browser is going to get local and again if you take a look here in the elements you'll again see exactly why because we have our html structure and then there it is we have style css so notice how browser is going to http localhost 5000 forward slash what well style css right well do we have that path and again the answer is no so let's do this way i'm going to copy and paste and i'm just going to come up with different names here i'm going to say home styles and then the third one i guess is going to be home image and then the fourth one will be home logic so that is going to be my app one then we'll have to change some files here as well so i'm looking for styles css i believe right that's the file name then i have logo svg that's where my logo is sitting so logo svg and then finally let's just delete this one as well and call this browser hyphen app and js so home styles home image and logic and like i said yes manually one by one we'll have to add all these resources so instead of about page i'll just call this styles and the value that i want to check for here is exactly the same like in my browser so they need to match so then of course the browser will get the contents of the css file in this example so i'm going to go with styles and then css now i do want to change right now the content type because am i sending back the html of course the answer is no we're sending back the css so we go text css now let me say this one more time please don't zero in on these mime types if you will ever need them you'll be able to find them within a matter of seconds just type along with me and we're going to be in good shape now as far as the right in our body so in our response that we're sending back are we going to send back html of course the answer is no now of course i want to send the styles right and the variable for that is home styles so that's where my content is for the styles css and once i save check it out now we are moving along in the right direction because i do have the styles so it looks already somewhat decent now the logo is still missing and there's no logic because i don't have the app.js or the logo svg but we are moving in the right direction so copy and paste and you can probably already guess that we'll just repeat over here we'll say if the url is equal to logo svg and i'll say image logo as far as the comment and we're just going to go with logo and 3g and as far as the mime type for this sucker it is image image forward slash svg and plus xml like so and let's go with home and i believe i named this home and image like so and then the last one of course is going to be our javascript so let's say here logic and the resource that i would want to provide is browser app js like so and then the content type is equal to text and then javascript and of course now i would want to send the home and logic so let's save this one and now if i go to my browser and if i refresh check it out now of course we have everything we have the logo as well as the proper functionality with browser app and notice how all our requests are 200 instead of 404 where the previously browser wasn't able to find those resources and now of course we are providing them and if we want to test out the functionality there it is now i can just go here and notice how i can toggle the menu as well and now of course we'll switch gears and start working with express because hopefully it's clear that yes we can set up our server with just http module but imagine a scenario where you have a website with tons of resources and then of course you need to set up every single resource in this matter now i don't know about you but i would go nuts somewhat quickly all right and once we have struggled a bit now let's make our lives easier by getting to know express js express is a minimal and flexible node.js web app framework designed to make developing websites web apps and apis much faster and easier if i have to be honest it's almost unfair how easy and fast it is to spin up the api with the help of express and while it's not officially part of node meaning unlike http module express is not one of the builtin modules at this point in time express is pretty much a standard when creating web applications with node.js express has awesome documentation which we will reference from time to time and you can find the docs at expressjs.com again the site is expressjs.com and as far as the install you simply need to run the command of npm install and the package name is express now they do suggest this hyphen hyphen save flag and effectively the reason why they do that is because in the earlier node versions if you did not add this flag then package wasn't saved to the package json meaning when you push this up to the github the next person who was getting your project well he or she did not have the reference for the package so of course that caused the errors now currently that issue is fixed so this is just a good precaution but technically you shouldn't have any issues if you don't run the command again nothing bad is going to happen if you add this dash save but technically these days you can skip it so just grab the command like so and just navigate back to the project just keep in mind that of course i already installed the express for the express tutorial this is just for your own project if you want to install the express if you set up your own package.json and all that if you want to install the express just run this command now one thing that i would like to mention though is that i'm using version 4.17 so maybe by the time you're watching this they already have a version 5. now at the moment version 5 is in alpha meaning they're still testing everything but maybe by the time you're watching this this is already stable now if that is the case when you run npm install on express of course you'll get the latest version so your version is not going to be this 4.17 now i wouldn't worry if it's for example four point i don't know 24 but if it's five there might be some breaking changes and at that point you have two options if that is the case if the version is already five then you can either reference the api docs for yourself meaning you can take a look at the methods and all that what the version five provides or if you want to use all the methods and properties that we use in tutorial simply install the same version how you can do that well you just need to go to npm install express so this stays the same and again you can remove it you can leave the dash dash save doesn't really matter and after express you go with add and four and then again i'm gonna go with the same one just keep in mind as long as you have four you're not gonna have any issues and then one so this is going to install express with this specific version hopefully everything is clear and now let's get to know express all right and once we have covered the express library basics now of course let's spin the sucker up and see how we can make a server way easier and with way less headache and i'm going to start by removing all the code in my app.js just keep in mind that if you ever need a reference go to the final one and then of course http basics is going to be where we set up the basic http server and then for example the http app example is going to be in the file number two and the way we work with express we start by setting up some kind of variable and of course we'll have to use the require so we go with require and then we're looking for express library again we can do that because we have installed the library but if you haven't then of course you'll get the error keep that in mind and then we go with const and then app is equal to express to whatever we imported and then we invoke it now if you're a bit iffy about this syntax just keep in mind that it is very similar to our previous example where we went with http then created the server and as a result we had our server instance correct so this is similar we're getting a function back from express and we just invoke it and we right away have our server instance with bunch of cool methods now what you'll also see on a web is something like this where since this is a function we can invoke it right away and then just call this one app again this is really your preference but mostly you'll see the first option where we first import the module and only then we invoke it so once we have this setup then of course we have a object with bunch of useful methods now the methods that we'll use the most are following amp.get and i'll just copy and paste here and i'll just change it around a little bit post and put as well as delete and also there's going to be all use and a listen now listen we already covered before in the http module and this one is pretty much the same where we just go with app.listen and then we just say what port we're going to be listening on so in this case of course this is going to be 5000 and then we pass in the callback function so when we instantiate that server we will run this function and a common convention is just setting up a console log where we say that yeah the server is listening on port such and such now for time being we're hard coding this value later i'll show you how we can make this one dynamic so for now i'll just say console log and then server is listening on port and then we go 5 000. so let's save this one and i'll run my npm start and i should see in a console server is running or listening on port 5000 awesome so what about the other methods and the first four methods here just represent http verbs now if you remember when we talked about the http request and response messages well one of the things that we're looking for in the request message was the http verb and yes i set up some more meaningful examples where we'll see all of them in action for now just remember two things first this just represents what the user is trying to do whether read the data insert data update data or delete data and by default all browsers perform a get request so that's why we have here amp.get that post put and delete now all just works with all of them and we'll see that in a second when we set up the 404 page so essentially a response if we cannot find the resource on a server and app.use is responsible for middleware and since it's such a crucial part of express of course i prepared more examples on that where we cover everything from the scratch so for now just remember this is middleware but don't lose your sleep over it we'll cover it a little bit later in the course so we have app.listen beautiful we're listening on port 5000 but since i know that all the browsers are performing a get request i simply go with app dot get and then i need to specifically add two things a path so what resource the user is trying to access and it would make sense if we would start with root correct and then the second thing is the callback function so this callback function will be invoked every time user is performing a get request on our route so basically on our domain and then this callback function gets the same two arguments we go with request as well as the response so this is going to deal with incoming request message and then this is going to deal with our response and in express we go with res and then the method name is send so in here we can pass the string we can pass in the html and i'm just going to simply start with home and page so we save this one and now of course i'm going to navigate to my browser i'm going to say localhost and then 5000 and there it is now we should have homepage if you don't again please troubleshoot because otherwise it's not going to make sense what we are about to do next but if you see the home page you are in good shape so we're listening for get request on our route and then every time the user navigates to the root then of course we just send back the homepage now if you want you can of course go to log and user hit the resource or something like that doesn't really matter and then if you go back to the browser and if you refresh there it is we have user hit the resource awesome and just like in our previous example the basics one let's set up the about page as well as the 404 so i'm going to go back to my app js and right above the app that listen i'm going to go with another app that get and in this case i'm looking for about so that's the resource and of course in here again we have rec and res and then as far as the response well i'll cheat a little bit and i'll just say res.send and we're going to go with about page and then of course i would want to handle the 404 as well so if the user comes to my server and tries to access a resource that doesn't exist well what am i going to send back and we can take a look at the default one so if i'm going to go with about i should see the about page but if i go with for example a contact page let's see what the express is doing and in this case i have cannot get the contact and if i inspect i can clearly see that in my network tab i have contact and this is a404 so that's going to be the default response now i can alter this of course and i can set up my own 404 response so i'm going to go with app and this is the case where i'm going to use all methods because again user can do multiple things on a server and i want to cover them all not just getting the resource or inserting the resource or whatever i want to cover them all so that's why i'm going to use my own method again this just handles all http verbs whether get post or whatever and again this method takes two arguments first one is going to be the path and the second one is going to be a callback function and as far as the path i can say all of them so whatever resource you're trying to access the response is going to be exactly the same if i cannot find the resource then i'll just send back this response so again i have a callback function rec and res in here and then we're going to go with res dot send and just like in our http example i'm gonna go with heading one and we'll say resource not found and let's close the heading one but of course i also would want to add the status right so that would make sense i don't want to send back 200. that would be very confusing so before we invoke send method i can also add status here and as you can see i can chain it so i have res not status so this is where i'll pass in my status code and then i go with send so in our not found example of course i would want to pass in the status code of 404 that is going to be more correct and the same goes here technically we can rely on express and it does a decent job of adding those status codes but a more common approach is explicitly setting up the status code so that way you have more control of what is sent back to the browser so in here i go with res and that send but before i set up that method i set up a status one first and i go with 200 so this just means that the request was successful so similarly i'll do that in the about where i go with status we pass in the 200 and then we set up a chained send so now if i go back to my browser and if i refresh now of course i have resource not found that is my heading 1 and i can clearly see my 404 and if for example i'm looking for about there it is i have my about page as well as the homepage so if we go to localhost and 5000 that's going to be our route that is going to be our homepage all right and we're done with our basic example hopefully you can see that it is already way less code than just using the builtin http module and in the next example you'll see how express truly shines when it comes to setting up a server beautiful we're done with our basic example now let's tackle the big beast our navbar app and the setup for the following examples is really up to you if you're not a fan of retyping something you have already learned you don't have to do that you can just remove app.get all the way to app.all so basically leave the import as well as instantiation and listen as well however i am a fan of repeating something because that way whenever i need to create something from scratch i already have done it quite a few times so i don't have that blank page syndrome where you're like looking at the empty file and you don't know what to do so in my case i'm going to remove everything and we'll start from the scratch so const express is equal to require and of course we're looking for express and then i'm going to set up my app that is equal to express we invoke it and again we go with app.listen and we're going to go with 5000. now i'm not saying that i'm going to do that for every example but i'm just showcasing what is in my approach when i'm starting something new so when i'm learning something new yes i do like to retype some of the stuff quite a few times because that just makes sure that i remember it better and in here i'm going to go with server here's listening on port and we go with 5000 and then dot and in order to set everything up we're going to go with app.get so again i'm looking for the root and of course i would want to start with my index html correct that's the start and we go with app.get so we're listening for all the incoming requests that go to our route and of course we're specifically listening for get requests then we have our callback function rack and res and we'll set up the functionality in a second before we do anything let's also set up all and this is of course going to be for all the requests that will hit 404 so we're going to go with rack and res and here let's say res and then status so let's add here a 200 or i'm sorry four four my bad and then we're gonna go with send and instead of the send let's just go with the resource not found now when it comes to get in this case i would want to send the file more specifically i would want to send back the index.html and in order to do that i need to use send file method that comes with express now in there though i do need to provide a absolute path so we'll have to use one of the modules we covered before and that is going to be a path module so i go with const path is equal to require and i'm looking for path module again we don't have to install it comes preinstalled with node so we are in good shape and then where we have our callback function we go with res and send file method and here let's pass in path and then resolve so path dot resolve remember that was one of the methods we cover and effectively i would want to pass in the dirt name so this is going to be path to our directory because we do need to provide that absolute path and then of course we're looking for our index.html which is sitting in the navbar app so forward slash and then navbar hyphen app and then we have another forward slash index html now if i have to be perfectly honest in this case we can also use path dot join it doesn't really matter since their name provides that absolute path but just to be a bit explicit that we are providing absolute path i went with path dot resolve and then the their name and then whatever is the path to my index html and the moment we save it we'll have the same errors just like in the http module so i go to my localhost 5000 and i still have the same issues i still don't have style css there's no sign of browser app as well as the logo now in express though we don't have to do this whole song and dance like in http module in express i can simply go above all my app.gets and amp.alls and i can go with app dot use and this is going to be the case where i'll type out the code and then i'll explain everything that is happening and we'll pass in the express so this is what we're importing so this is not going to be our server instance instead we're going to go with express and then static that's the method and in here again we just need to provide a path now common name is setting this up as the folder by the name of public please keep in mind technically you don't have to do that you can just point to our navbar app but in my case i will do that i will set up here dot forward slash and i'll call this public so now of course what i need is to set up a folder by the name of public and then all my static resources all my static files i would want to transfer there now don't worry about it i'll cover in length what in a server land means static resources for now what i would want you to do is go back to our folder and that is going to be express tutorial and of course you can do that in visual studio code i just think that this is going to be a bit easier to see so i'm going to create a new folder again common convention is calling this public but you can call it whatever lobster it doesn't really matter and then in my case i'm just going to copy these files so take browser app take logo and take styles if you want you can move them just remember that the previous code is not going to work as far as the http module setup so i'm going to copy these ones and paste it here in my public so now of course i have browser app logo svg and style css so of course now i can zoom out and once i save check it out when we navigate to our route there it is this is our application and what's really cool all those resources are right away available so if i go to my localhost 5000 remember browser was looking for what well it was looking for example for style css if you go here there is a resource by the name of style css and of course in here i have all my css code and notice how we didn't have to set up the statuses we didn't have to set up the content types or any of that express takes care of it all now of course you probably at this point have more questions than answers so let me start clearing them up and first i'm just going to add a comment of setup static and middleware middleware and like i mentioned app.use is for setting up the middleware and we have more serious examples coming up so for time being please don't worry about this line okay so please don't worry about app.use what is express static that is essentially a built in middleware i will cover everything step by step in this video i would want you to understand what the term static asset means and it simply means that it is a file that server doesn't have to change it so instead of our http example where we created a path for every such resource and if i were to have i don't know 20 000 images i would have to repeat the same steps instead since this is a static asset meaning an asset where the server doesn't need to change it we simply place it in designated folder again the common name for those folders are public or static and then we just dump all those assets in there so if i were to have i don't know 20 000 extra images in here i can just dump them and express will take care of it all it will set up the paths it will set up the mime types it will set up the status codes and all of that good stuff so hopefully that is clear static assets are just files that server doesn't have to change and an example of a static asset is an image file here's the style file and also a javascript file and here comes the next question what is this guy with weird eastern european accent talking about because all my life i've been told that the javascript makes my apps dynamic it adds all the functionality so how come this is just another static asset and to answer your question yeah you're right javascript does make our apps dynamic however think about it this is a browser app so it makes dynamic on a browser as far as servers is concerned it is just a asset doesn't need to change now if you're wondering well how to set up something dynamic just please put the pin on that and we're going to cover that when we cover serverside rendering because there is such thing as template engines and the simplest way for me to explain that is imagine the scenario where you can actually log in or in other way just showcase whoever is visiting the site and then dynamically i would display for example name so if the peter logs in then i'm sending back the html with the text of hi peter now if the john logs in then of course i'm sending back the username with the value of john so hopefully you get the gist where in this case notice this is just same old index html that i'm sending back regardless of who is visiting the site but yes there's also an option of setting this dynamically where depending on who's visiting the site or what the user is trying to do i'm actually modifying my file before i'm sending it back so hopefully it is clear how much easier it is to work with express where if we have static assets we just set up designated folder and just dump them all in and static asset just means a file that server doesn't need to change and of course we can start working on our next example nice hopefully we are clear on static acids and before we cover more complex expressed topics i would want to throw a mine grenade at attribute and it goes something like this so if we put two and two together i talked about static assets in the previous video but if we're looking at the index.html isn't this a static asset as well and of course the answer is yes so instead of sending this file we can add it to static assets and we're going to be in good shape and if i have to be perfectly honest with you when it comes to send file if we're using it to send back for example index html actually we use other two methods instead so first i'll show you the first one where we just dump everything as far as the static assets so i'll just add index.html to all my static assets in the public and that will effectively do exactly the same like we're doing here with send file and the other one is going to be using templating engine so of course that one will cover when we go to server set rendering so i'm just trying to showcase that yes there is this option of send file and we might use it from time to time throughout the course but not for sending back index html files so first let me just say that the other option one of the two other options that we'll use the most throughout the course is just adding two static assets like so and then the second one is going to be server side rendering where basically we'll use template engine for that so in order to set everything up now of course i just need to take my index html and again if you want you can just move it or in my case i'm just going to copy and paste so again i'm going to go back to my folder i'll zoom in massively so you can see better so express tutorial there is my navbar app and i'll just take the index.html and i'll copy and paste and now it is in the public so what happens index.html is always going to be a root so when the user hits the server by default server will serve this index.html and since our index.html basically has all the paths to browser app to logo svg and all that we're going to be in good shape more effectively we don't even need to set up this send file option so now of course i can just save it and once i refresh notice how nothing changed i'm still serving my app so we're still in good shape and if you take a look at the network tab notice everything still works correctly i'm still getting all the css all the browser javascript functionality as well as the logo and to answer your question yes that is effectively how you can set up the simple sites you can simply just dump all your files in the public just make sure that you serve them up and that's it and you're in good shape now we still have the 404 but as far as just serving straight up sites with html css and javascript yes you can simply dump them into public you can simply set up the middleware and serve all the static assets and you're going to be in good shape beautiful we are successfully done with the initial express setup and ready to cover more complex express topics before we do that though there's something important i want to mention you see when it comes to express in most cases you'll use one of the two following options you'll use it to set up api or templates with server side rendering now since term api is probably one of the most overused terms in the community and in various scenarios it can mean different things let's start by understanding that in express or in http case when we talk about api we mean setting up an http interface to interact with our data now data is sent using json which stands for javascript object notation and in order to send back our response we're going to use res.json method which will do all the heavy lifting like for example setting up the proper content type and stringify our data the other flavor we have is server side rendering where we will set up templates and send back entire html and css and javascript ourselves and we're going to do that using res.render method now since i'm a big believer in actual examples over slides if you are a bit iffy on either of these flavors just hold on a bit and once we cover some examples i promise you it will all make sense now why am i telling you all of this you see when it comes to more complex express topics it only makes sense if we cover them properly using one of these flavors instead of just bunch of random examples and the option i picked is the api one so in the following examples we're going to construct api response using more advanced express setups the reason why i picked apr route is because i believe it lets us focus more on the actual express since templates by themselves add a bit more unnecessary overhead especially while we're just starting out with express with that said let me be very clear if you grasp the concepts with api so using the api flavor you'll have no problem implementing them with templates as well since for the most part express concept setup is exactly the same we'll cover server side rendering later in the course so you'll have to wait a bit for the actual example and since we're going to start with api let me just stress the main point one more time and how it looks like in a real world so like i said the main idea with apis is that our server provides data and what that means that any frontend app that wants to access it and use it can simply perform a http request and using our data set up the api and functionality how does that look like in a real world well if you navigate again back to course api and of course not the slides slides are just images but if you take a look at any of these examples you'll notice something interesting where we're sending back the json and you can clearly see that if you go again to your browser's network tab and here again let's refresh and you'll see that this is our response react tabs project so again the full url is course api.com and then react tabs project and if we take a closer look we can see that this is the response that we're sending so we're sending back a json data and i can clearly see that in my headers so in response headers as you can see content type is application json now where is this data used if you took either my react course or the vanilla javascript course you know that in the course we build quite a few projects where we practice data fetching either using vanilla jazz or react and in some examples we use external apis and in sum we use the apis that are here in the course api so for example with this react tabs project if you navigate to react project nutlify.app and keep on scrolling keep on scrolling you'll hit the tabs project and here this is the app that we build using the data so again on a server i set up my data i set up the api and i share the data so i create the http interface and then the frontend app just simply grabs this data and again if you want you can check it out here if you refresh notice this request request goes to course api react tabs project so we grab the data on a front end and then we set up the functionality as well as user interface hopefully this is clear from now on we are going to be responsible for sending back the data so now since we're setting up the server it's not going to be our responsibility to do something with it like we were doing on a frontend in this case we are responsible for setting up the responses so we're going to be setting up apis that our http interfaces to interact with our data not bad not bad i think we clearly covered our two options so one is sending back the json data and the second one is server set so why don't we start by covering the most basic json response and here's what i'm trying to mimic if you go to course api and then if you look for the tours project you'll hook the url of course and here you can see that we're getting back a json data it is an array and each object represents a tor and if you took my react course you know that we were practicing data fetching in react and effectively we hit this url and we got the data we got our json data back and then we built an app using that data but again the whole point here is following where it doesn't have to be react it can be vanilla javascript application it can be swelled framework it can be any setup where you're able to fetch that data so in here on the server we just share the json so in this case of course that is stores and then anywhere anyone who wants to access this data they can just access it and build something using that data and that's why it is so so powerful and essentially this is what we're going to do we're just going to send back first a most basic array and then we'll see how we can make this more dynamic please keep in mind two things first of course eventually we'll use database for that and of course i will mention that probably 20 000 times as we're building these examples and the second thing that i would like you to understand that when it comes to express basics so essentially how we set up the server it doesn't really matter whether we're using server side or whether we're using json again if we understand the principles we'll have no problem using any of those options so first what i would want is to navigate back to my project and again this is going to be the time where i do write everything from scratch but then starting with next example i'll just use some options that we already covered so for now yes i'll remove everything and again we'll set up express one last time so we're gonna go with express require and express okay awesome then const app is equal to require or i'm sorry not require we need to invoke the express like so and then let's go with app.listen port 5000 and then let's call our callback function and then let's go again with console.log and server is listening on port on port and of course the port number is 5000. then again i want to set up app.get because that is the http method that all browsers perform by default so i'm going to go with app.get and i'm not going to go with specific path just keep in mind that you can and of course we'll do that later for example i can go here with api and then i don't know i can call this product or whatever for time being let's just make it simple and we'll just handle all the root requests so that way we can save a little bit of typing in the browser and again we have our function our callback function rack and res and as far as the response we're going to go with res and then the method name is json now we will go to the docs just so you understand where i'm getting this information from but before we do that let me just tell you that i might omit here and there the status one just so we can save a little bit of typing but don't worry once we go to some more serious examples of course we'll still use the statuses because in my opinion that is just a better approach where we actually have control over the status and as far as documentation if we go back to express documentation we're looking for api reference again we are using four point something so we are using version four so make sure you look for the same one and don't confuse with express json so this is going to be a middleware that we pass in effectively we're looking for response in a docs and then we're looking for this json option so res object as the json method and what happens we send back the json response and this method sends a response with correct content type that is a parameter converted to a json string using json stringify this parameter can be any json type including object array string and blah blah blah so hopefully you get the gist so the only thing we need to do is go back and for example i'll provide an array where there's going to be two objects and first one will be named john and the second one will be susan so another object and we'll say name is equal to susan and we have our most basic api so if i go back to my localhost 5000 and refresh there it is so now anywhere in the world i can access this data and build something using this data now there's tiny caveat when i say anywhere in the world there's still going to be at the moment a course error and i'll cover that once we actually cover middleware so again please please please please be patient we will get there but hopefully you get the gist where this serves our data and now we can just access that data and build the frontend app using this data now this default setup is nice but of course we can do something more meaningful where if you take a look at the folder you'll notice this data js now what is data.js it is simply a file with some arrays and the first array is going to be products and here as you can see i have objects and then each of these objects represents a single product and all the way in the bottom we're exporting both arrays we're exporting products as well as the people array that we're going to cover a bit later so now what i would want to do is import product array in my address and then instead of hard coding this value like so where i just pass in the array with two objects i'll just dump the whole products data so let's go with const we already know how to do that now since i'm exporting multiple things since i'm exporting an object i will be explicit of what i would want so i'm going to go with product and basically i'm destructing right away i'm going say product is equal to require and remember the file is data js like so and then instead of passing array directly i can simply go with product and what do you know when you navigate to the root there it is now we have more meaningful json response where actually this is a product data so on my front end i can grab it and i can build some kind of nice front end using this data now lastly before we go let me just showcase that of course there's going to be a content type set up correctly as well so if you go to network tab and again if you refresh localhost like so and take a look now of course what is the content type that is application json so now of course we're correctly getting our json data so hopefully you have a clear understanding how to sound json data so now of course let's make things a bit more interesting and cover some more advanced express topics nice once we're familiar with the most basic json setup now let's build a more meaningful api and in a process we'll cover route parameters as well as query string parameters and i would want to start in following way where essentially i'll leave all this code but when it comes to my route when it comes to my home bridge i'll essentially send back the heading 1 with the link as well and that link will direct a user to a forward slash api and then product and then later we'll cover the params as well as the query string so let's start with sending back html instead so i'm not going with json one and i'm not gonna send back the file i'll go directly and i'll say send and here we have the string of course so i'm gonna go with heading one and then home page then i'll make sure that i close because i believe in one of the previous videos i believe it was the express basics i think i messed it up here notice i didn't add the closing one so now everything is correct and now i'm gonna go with my link then as far as the href i'm gonna direct a user to api and then forward slash and then of course i'll also set up a text here so products and i'll close my link so that should do it that is my home page and of course if i go to localhost 5000 there it is i have my homepage and once i click the link i navigate to api products now of course the moment i have the default response from the express meaning the default 404 response where the resource cannot be found and as i said note if you want to take a look what response do they send again go to the network this is going to be very very useful tab refresh and take a look at their response so notice the response that's the html that they send back so cannot get and then api products now we already know why there is this get the http verb because that's the method that the browser performs okay awesome so now of course our job is to set up a get request for this resource so we go with app.get and i specifically want to handle api and product so this one just looks a little bit more realistic so in here i go with api and products and keep in mind of course those values need to match otherwise you'll get that 404 again i have my callback function and now of course i would want to send back the product however in this case we'll make it a little bit different where previously notice the product we send back pretty much the whole thing right but a more realistic approach is following where when you're requesting a bunch of data so when you're requesting collection of the data you're not always returning everything for that one specific product and to give you a real world example again i'm gonna go back to my react projects and i'm simply using them because this gives you a visual representation during the course we built a ecommerce and then in the products page notice how we're fetching the products but you need to keep in mind one thing where we're only fetching about the product the title the price the image and i believe also the id and only when i go to that single product page this is where i get the rest of the data whether that is for example a stars the reviews the description the availability and all that stuff so what i'm trying to say is when you're requesting a collection of data there's going to be cases where i simply want to send back some minimal response so for example again that could be name image and the pricing scenario and only if i look for this specific product then i send back everything and in order to mimic that in our example in this response what i'm going to do is i'm just going to iterate over my product i'll use the map method and i'll just remove my description so when i'm sending back the product it's going to be without a description so again if we were to send back everything i would simply go with response json and then i pass in the product so again if we go here and if we refresh now everything is cool i'm getting my product on the api product route however i'm going to make it a bit more realistic and we're going to go with const new product is equal to product dot map so i'm mapping over and i'm creating a new array and i'll reference each item as a product and then as far as the return well first i want to structure the properties out of the product and the reason why i can access them is because those are the names that i used when i'm setting it up so id name image and all that and that is equal to the product again i'm just using simple javascript structuring and then as far as the return whatever i'm going to return from my function well that is going to be the new value so now i'm going to go with id name as well as the image and once i have this setup in place instead of returning product now of course i'm going to go with new products and if i go back to my browser there it is so now i'm getting a collection but i'm not sending everything that i know about this specific item so i'm being selective of what i'm sending back so yes there is a resource by the name of api product and we're sending back the array but we know that if the user wants to access that description he or she will have to look for a specific product and in the process we'll cover what are the url parameters all right so we're successfully sharing a list of items so now of course let's take a look at how we can provide info about that one specific product so for example if i navigate to product and then forward slash and one and then i'm going to get only the info about this first product because it has the id of one and not only i'll get these three properties but also get the description and our initial approach would go something like this where yes i see the product okay beautiful and we already know how to set up the route now since i'll delete it eventually anyway i'm just going to copy and paste so we can speed this up so i'm going to go with api products and then forward slash one that just means that i'm going to be looking for item number one in here and then instead of map we'll use the find method so i'm importing all my products and in order to get the single product i'm going to write the following code where we're going to go with const single product and don't worry we will reuse this code so it's not like we're just randomly typing something so let's go with products and then find now again i'll reference each product with a parameter of product in my callback function and then if the product id product id matches one because that is my route here then of course i'll return that single product so i'm going to say single product and technically this works so notice now of course i have only info about this one specific product and i have the description however it feels like using bazooka on a cockroach yeah it gets the job done but probably is an overkill because keep in mind at the moment we have only four products so yes if i really wanted to i could set up four routes but what if i have hundred two hundred three hundred well that's not gonna work and in express we have something called route parameters which essentially is going to be way better solution so instead of hard coding this 1 2 3 or whatever id we want we set up a route parameter and it's going to look something like this where i go with my route and then i have forward slash and then i go with colon and then whatever name out one so think of this as a placeholder so you can call this bobby lee you can call this chicken burrito in my case i'm gonna go with product and the id just to be explicit of what i'm expecting over here but again naming here is really up to you and what is more important is the fact how we can access it now if you want you can actually console log the request object again this is just going to be a giant object and for now i'm just going to leave this one the way it is so i'm still going to be returning a product number one and also let's look for request and then we're looking for the params property so let me count to lock this one and then again once i navigate back and if i refresh in the api products number one what you'll notice again this giant request object where we have bunch of useful properties and methods and of course i'm not going to cover all of them right now but similar to http of course in the express we also have access to bunch of useful things in that request object and one of them is the params so check it out now i have this product id and the value is one now please keep in mind one thing that whatever you're going to be setting up here in the url as that route parameter is always going to come back as a string and this is important in this case because if you take a look at our data the id is a number and of course we'll deal with that in a second and whatever we set up as far as our name is going to be right in here it's going to be in this request and then parameters object so now of course what i could do is i could just destructure it from the params and then use it in order to find that specific product so that way i don't have to hard code products number one product number two and on and on and on instead i just set up my route parameter and just come up with whatever name i would want just make sure that you add this colon here and then we'll access that value and get a specific product so i'll leave these two suckers for your reference just in case you would ever want to console log them and we'll simply go with const and the name is product id and that is equal to request that's my request object and params then i'm going to use this product id to get my product but remember it is a string we can clearly see that and in fact here in the array well the ids are numbers so if we'll just try to search it the way it is of course we won't be able to get our product so instead what we want is pass in the number and then product id now of course if your ids are set up as strings which is somewhat typical setup for the databases and all that as well as the headless cms is then of course you don't need to worry about it then you can just pass in the string and now of course i'm going to be able to get my one product so now if i go back and if i refresh everything still works and if i go to my url and start changing these values hopefully you can see that now of course i'm getting a different product now i'm getting product number two and i go to product number three and on and on and on so now with these few simple lines of code i can access any product in my array now of course there's also a case where we cannot find the product because keep in mind here i can type whatever i would want so i can go with products and then let's imagine that the user types abc now do we have a product with an id of abc of course the answer is no so what's happening over here now i don't get anything back right well i don't get anything back because if i go to log and then single product let's see what we're going to get back again let me refresh abc and this one is undefined so that's what we're sending back as a single product so what would be a solution well a solution is setting up a if statement here where i say get me the single product if you cannot find that single product if basically that product doesn't exist if the id that the user passed in does not make sense you cannot find the product with that id then return 404 so how's that going to look like well we can go here if and then single product so we set up a if condition and of course i'm going to go with if single product doesn't exist so i'm going to add exclamation point and of course this is going to be our case with undefined this will be true if it is undefined and then we just go with a return res and in this case i will add a status because that is extremely important that i go with 404 and then we go with send and product does not does not exist like so now if everything is correct then of course we go with res and json so in here i say return and res dot json so once i go right now to product and then abc there it is now of course i have proper 404 product does not exist and if i again take a look at the tab and i have my abc now if i'm going to navigate to a route where i can find the product then of course i'm going to get my proper product response so whenever you think of route parameters think of them as placeholders where user provides a data and then using requests and params we can access that data and then set up some kind of logic and before we continue and cover query string parameters let me just mention that route parameters can get way more complex than this so for example imagine this scenario i can go with app.get again i need to come up with some kind of routes i'm going to go with api then products so i'm looking for specific products so i'm going to use a route parameter let's call this product id then i'm going to look for all the reviews and then maybe there's a review id so review and then id and now of course again i have rec and res like so and then i'm simply going to send back some kind of dummy data but i would want to console log the rec params just so you understand how everything works and now let me send res.send so res not send and i'm just going to say simple hello world let's save this one and again in the browser let's go here we have products again some kind of id whether that's abc whether that is a number in this case it doesn't really matter since you can see that there's not much functionality in there but we need to type in here reviews and then for example the review id would be i don't know abc so once i navigate here of course i'm going to get my hello world and then in the console notice how i'm accessing all of them so i have the product id as well as the review id so again they can get way more complex than just this simple approach and one more thing i would like to mention this reviews though is hard coded so if i go back i can change the abc and 4 however i would like but if i'll change from reviews to review i'm going to get a 404 why well because review is not a route parameter so that's not a placeholder so if this is incorrect then of course i get d404 hopefully that is clear and now let's talk about the query string parameters all right and once we're familiar with rot parameters let's talk about the query string parameters or they're also called url parameters and essentially that is a way for us to send small amounts of information to the server using the url now this information is usually used as parameters to for example query database or filter results and that's really up to the people who are setting up the server they decide what parameters are going to be accepted and what functionality will depend on those values and to give you a real world example let me go to my search engine and i'm just looking for hacker news algolia api so when you're working on a frontend app i'm not sure whether you worked with this api but that is a very cool api and essentially it's going to work as a good example of how we should be setting up the server and this is as a side note but notice the url here so they go with a domain which in our case is of course localhost 5000 but here it is actually a algolia domain so algolia.com forward slash api like i said that is a pretty common practice then a version number and then whatever list you're getting so in here it is items now check out this one doesn't that ring a bell of course that is a route parameter where they say yeah here's the list of items but if you want to be more specific please provide the id and then if you keep on scrolling you'll notice the same thing with the users again we have the main domain api version one users that's the list and then if you want to get a specific one then of course again there is a route parameter now this is just to showcase that i'm not randomly coming up with those things no that's how actually the servers work in real world and let's keep on scrolling and now we come to this interesting part where we can sort so we're getting the data from the algolia api but then in my app i can sort i can say hey you know what get me specific hacker news story or get me stories based on some kind of search term and hopefully you get the gist where instead of just grabbing the whole thing i can say you know what get me all the stories that match through so again we go with the url and this is really up to you how you set this up in their case they use search and then here we have this question mark and whatever is after this question mark is not technically part of this url meaning it's just a way for us to send that data to the server and then server decides what to do with this data so the url is still this one the one that ends with search and then we have a question mark and basically this is just a specific info about the data that i'm requesting so here the user adds a query parameter and then the value is full and then also has tags of story and that means that we're going to get all the stories matching full now what else you could set up here in a query string pretty much anything a pretty typical is going to be page for example if you have a list of things and i don't want to get 100 items at a time i can say you know what split it up in pages and get me initially page number one and then only if the user clicks on a button that fetches the page number two then i get the second page then for example in here they have hits per page so that is going to be how many items per page so again after that question mark if the setup is supported by the server then of course you can add those key value pairs and the way we add them as you can see is by using key value pairs so we have question mark and then we have a key which in this case is query and then the value now before we continue let me make something very very clear it's not like you can randomly search the web and just start adding these query string parameters and then expect that as a miracle you'll just get the data that you're looking for a as far as the keys they're designed on a server so if i'll set up a key of chocolate milkshake algolia api is going to be like i don't know what you're talking about and the same goes for the value so where i'm going with this now we are in charge of that server so it's up to us to handle those query string parameters and i'm going to go back to our project and i'll purposely set up a new route please keep in mind one thing where a pretty typical setup is adding this to the list so again we'll look for specific property on our request object and then if that property is provided then of course we return a more detailed response meaning there's maybe some filtering or something like that but if not then we'll send back all the products now i'll purposely set up a new route just so we don't jam all our code in this one route but then in the next video probably i'll show you how we can combine both routes so let's keep on scrolling so this is going to be our more complex params example and let's go with app.get and again the route is really up to you i'm going to go with api now in order to make it interesting i'm going to add that version 1 just like the api of algolia has it and then i'll say query now i don't need to add question marks nothing like that i just set up query that is my route and then i have my callback function rack and res now in this callback function in order to access those query string parameters i need to go with rec and query so let's go with console.log and we're going to look for request and not params sorry we're going to go with query over here and again let's go with simple hello world just so we can speed this up and then if i go to the local host and more specifically i'm going to look for localhost then 5000 then api then version number one and then query and then if i add this question mark i can add as many query string parameters as i would like so here i'm going to go with the name that will be equal to john then in order to combine them we just add this ampersand so we're going to go with name john and then id4 just keep in mind that you can add as many query string parameters as you'd want and then once i navigate there at the moment i'm just going to get the hello world so that's my default response from this url but in a terminal notice i have name john and id number four again this is a string and this is going to be important in a second but what this allows us to do is access those parameters and then based on them do some kind of functionality now first of all i would want to change this around a little bit where i'm not going to be looking for name or id i'm going to be looking for search query parameter as well as the limit so if the user wants to search for a specific product he or she needs to provide that search query parameter as well as limiting where the user can limit of how many products they are getting back so let me navigate back and just to showcase that so again instead of name i will zoom in we'll say search is equal and then whatever i would want so in this case i'm just going to go with a so effectively this will return all the products that start with a and then the second one is the what that was the limit right so i'm gonna say limit and for now let's just go with two of them so this will return two products i'll zoom out and again i have search and i have limit after you so now of course let's set up that functionality and we'll simply start by creating new instance of those products i'm gonna go with let and you'll see in a second why so say sorted product and in here we'll use the spread operator so we imported the product and now i'm just going to copy the values so this is going to be my new array and the reason why i'm using let because we will modify this value a bit now instead of just cancel logging the query i'll comment this out and we'll set it up as const and then again i'm looking for two specific keys i'm looking for the search and i'm looking for the limit so if the user doesn't provide them well then we'll send back all the product so we're gonna go with query like so so i can see the search and limit beautiful and now instead of just sending back hello world i'm going to check if the search is in my query string parameters then i would want to filter my product so i'm going to say if and then search like so and we're going to go with sorted products since i'm using let i can do that i'm going to go with sorted product and then filter method again straight up javascript again i'll call this a product like so and what i would want to return are the products that start with the value of my search term so here i can say return product and name so if the product name starts with now again this is straight up javascript and i'll pass in the search if that is the case that is going to be my value in stored product and i can right away check for the limit as well where i'm going to say if and then limit and if it exists so if the user has provided it again let's go with sort product and filter more and in this case i'm going to use the slice method where i'm just going to get specific items from the array so i'm going to start with 0 and then remember we're getting a string so we need to go with number and then again we'll pass in the limit let's go here below both of them and let's just say res dot and then status and we're going to go with 200 like so and then a json response now when it comes to json response we're just gonna go with our sword product right so we go back and let me just showcase something where if none of the query string parameters are provided i'm gonna send back my whole data why well because i copied my products right both of them were false both of them were undefined and as a side note there is a error here cannot send headers and i'll talk about it actually in a second that is one of my next topics so let me just deal with this hello world by deleting it and we're going to be in good shape but i'll cover why we got this error and what gotchas you should be aware of so let me go back again let's see again we're getting all the products because the user did not provide that specific query string parameter so if we right now navigate to the url and i'm gonna start with a limit and if in the limit i'm gonna say that i'm only interested in two products check it out now of course my limit is two so i only have two products and if it's three then it's gonna be three and then four and hopefully you get the gist where whatever value i provide here in a limit well i have the functionality for it now keep in mind again name needs to match if this is going to be limi instead of limit again i'm just going to get back all the products regardless of what is my value and the same goes for the value of the query string parameter if this is limit but for example i decide to pass in abc nothing i get empty array why because my value wasn't what my functionality was looking for and similarly of course we can add the search option as well and i'm purposely showing them one by one so you don't get confused so let's say search and again the functionality is set up where you need to provide a starting character so in my case i'm looking only for the products that start with a and there it is i have two of them now if i want a limit i can just add and here and let's just type limit and i'm only going to be looking for one product and if i add this limit one there it is now i only get one product now there's also obviously going to be the case where we return empty array why well because i could go with search and look for the products of b and unfortunately when it comes to my product data i don't have products that start with b so we can handle that instead of sending back empty array i could check what is the length of my array and if for example it is less than one then i explicitly send back the response where i say yes the request was successful but i couldn't return any product so we can go with if and then sorted product if the length of this array is less than one if it is less than one then of course i can just go with res dot status now this is one gotcha where you're not sending back the 404 you're not saying the url doesn't exist or the resource doesn't exist in this case you're trying to filter the product but nothing came back so whatever query string parameters were provided they didn't yield any results so you're simply saying status and then you can go with send and we can go with no products products matched your search like so so we can go here and then if we refresh again with the same ones we have no product match your search so that is one option you can send back the string but a more common one is this one where i'm going to comment this out for your reference again and instead you go with return and you're going to go with res dot status and again we have this error in the server and again i'll talk about it in the next video why we have that one so we're going to go with res dot status and we pass in the 200 and instead we send back the json one and in that json again you can pass the string if you want but a more common approach is setting up the object where you explicitly say that the request was successful or a failure so you go with success and that is equal to true and then again you come up with whatever name you would want a generic one is data and then you send back the array again you are in charge here you can really do whatever you want i'm just showing you a pretty common approaches to the situation so again i'm looking for some kind of product using my query string parameter now unfortunately server can return any data meaning any product and then of course i just get this success true because the request was successful there was nothing wrong with my url however i'm just yielding a empty data so that's it i can just delete it and if i don't provide anything then i'm going to get all the products hopefully that is clear how the query string parameters work and now we can cover a few gotchas all right and two things that i would like to emphasize are following first remember those errors that we're getting in a server when we're setting up if conditions in javascript if we don't explicitly return then of course javascript just keeps reading the code correct so if i'm going to omit that return i'm actually going to get the server error where i send back one response and then javascript just keeps reading the code and then express is confused express is like hey wait a minute i already sent back the response so while you're sending another now keep in mind that it is happening in the same request so you cannot send basically two responses in the same request one after the another yeah of course you can send one based on the condition so for example if there are no products you send back one response and if you can yield some product then great then you send the second one but you cannot send both of them one after another in the same request and if you want to see that error again in action go to the query you'll add a question mark here and we're going to go with search and again it is equal to b for example that is my value that's the starting value that i'm looking for and once i do that notice yeah i'm getting back the success true and data but again i have this big fat error in my server and it says cannot set headers after they are sent to the client so we can have only one response per request and in order to avoid that we just go with return so always always when you're setting up the condition make sure that you go with return so that way we are returning from our callback function and one we set up over here and that way you'll avoid those errors now of course in this case there's no more code to read so yeah it is a better practice if you just put this return here but you won't get the error since again there's nothing after that and one more thing that i would like to mention normally you're not going to set up a separate one just for the query yeah there might be some cases maybe there's some apis who do that but normally again you can just add it to where you're getting a list so basically if there's a query beautiful you're maybe gonna sort that data you're gonna filter it you're gonna i don't know set up some pages or whatever and if no query string parameters are there then you send back the whole product and if you take a look pretty much nothing stops me here from just changing this to api and products and the functionality is going to work where if there are some query string parameters present beautiful notice how we're filtering our product if not then i always send back these products anyway and as you can see those are just copies of the products that are coming from my data js hopefully that is clear and now let's move on to our next topic nice and once we're familiar with route params and query string let's really kick things into gear and talk about middleware in express.js express middleware are functions that execute during the request to the server each middleware function has access to request and response objects and when it comes to functionality literally sky is the limit in order to hammer this home i have prepared quite a few examples where we cover middleware step by step since in my opinion actual code examples are far more helpful than text based explanations before we continue though let me just stress something middleware is literally everywhere in express you can even make an argument that express apps are nothing but a bunch of middleware functions stuffed together to make one nice express cake or dessert if you are in that sort of thing and since that is the case middleware is not one of those topics you can just skip or avoid it is at the heart and soul of express so please don't dismiss it with that said since you'll encounter it more than once if you struggle with it in the beginning don't panic the more examples you'll do the better you will understand it now let me start by cleaning out my app.js and this is going to be the case where i will leave the code at least some of the code from the previous lecture so let me delete all the middle part and i'm just going to leave express we are instantiating our app and we're listening on port 5000 and let's just start by adding a comment here for your reference so there is a incoming request and so far we have been just sending responses right so what middleware does it sits in between hence the name so middle where over here and then we pass the response so the request comes in we'll do something so we'll have access to the both to the request and response we'll do some kind of functionality again the most basic you can just cancel log something and then we'll send out the response and again i know it probably looks confusing at the moment but trust me the more examples you'll do the better you'll understand and let's start by simple scenario where i have two routes i have the home route and i have the about route and in those routes i would just want to log the method that the user is using the url that the user is trying to access and for example a date and if you think that's silly there's actually npm packages that do that because as your express apps grow bigger and bigger it is very useful to see those incoming requests in that manner so let's start here by setting up add.get again this is going to be my home page and for time being i have my callback function i pass it in and i just go with the res dot send and i send back the home and i'll do the same thing here with my about so there's going to be two routes at the moment home and about unless it's just going to say about so i'll save it and it's not going to be surprised if i navigate to localhost 5000 if i refresh this is my home and this is my about again something we have covered already before now here's the kicker if i go with logger and if i set up that functionality in the route forward homepage i'll also have to do that in the about so let me showcase that so i have request object and in there i have method i have url and i'll simply set up the year because i don't want to deal with javascript types so let's go with method now that one was on request dot method property then we also have the url so url here and that is going to be a request url property like so and then like i said i'm going to go with const and i'll name this time but in order to make it easier i'm actually going to get a full year so i'm going to go with new date and i'll invoke it and i'll say get full year and invoke it as well and of course i'm sending back home yeah that is nice but before i do anything i would also want to cancel console.log all three of them so method url as well as the time like so so i save it and now every time user is gonna hit this resource of course i'll see that in a console log so there it is if i go back to my home page like so and if i refresh quite a few times there it is now in a console i can see that the method was get so the user was trying to get the resource and then the path was the homepage that's my url and then the year is 2021. okay awesome but here's the problem if i want to have the same functionality in about what do i need to do right now well again i need to copy and paste now if i have 15 routes does that sound like a reasonable approach of course the answer is no a better solution would be if we set up a function and in that function we have all this logic and then i can just attach it really nearly to all my routes and when i say well in italy it just just means that for some routes i maybe want to attach it and for some maybe i don't so here's the deal i can go above both of my routes and i can just simply say that there's going to be a function by the name of and for time being we're not going to look for any parameters but yes there will be there and then we just take all our i believe four lines of code right and we just cut it out and pass it here okay awesome and now of course where do we attach this function so we don't have to duplicate our code and the place is following where we have the path and then we have the callback function now in between them we can stuck a middleware so in this case as you can see i'm referencing the function please keep that in mind so i'm going to go with logger that's my middleware function but now there's the second question well in the logger i'm accessing request object right so how can i do that because at the moment i'm not passing it in well the good news is that express passes it in to our middleware function so in here i just set up the reference for my function and express will do that behind the scenes it will supply the rec res and also a next and you'll see in a second why we need this next function as well so again we don't have to do anything we just pass here the middleware express supplies them but of course it's our job to access them as parameters and then set up our logic so for them being i'm not going to do anything with next i will save and we should see something where in the console i'm still going to get my log but the problem is going to be in the browser so if i navigate back and if i refresh notice something where i have this spinner okay so what's happening here well i successfully logged but i didn't pass it on to the next middleware so here's the deal when you work with middleware you must must must must must pass it on to a next middleware unless you're terminating the whole cycle by sending back the response and don't worry there's going to be examples where we do that as well so for now just keep in mind that when you have a middleware where you set up some kind of logic unless you're sending back to response yourself for example since i have access to response i simply can go with res dot and send and again i'm going to come up with testing or whatever it doesn't really matter what we send back if we refresh notice it doesn't really matter if i try to access the home page since i have my middleware i'm actually sending back the testing and this is why the middleware is so so powerful because you can literally do whatever you want over here you can set up all kinds of cool logic and you have two options either you pass it on to the next middleware which in our case of course are going to be our methods our get methods or you simply terminate the whole cycle and you just say res dot send and i'm sending back my own data so let's not be brutal over here i will actually remove this line of code and if i want to pass it on to the next function meaning in our case that is going to be my method app.get i simply go with next and we have to invoke it again please keep that in mind there's going to be more functionality later in these middleware functions but you always always either you terminate so either you send back your own response or you pass it on to the next middleware that is very crucial so now if i go again to my homepage there it is i successfully navigate to my homepage i can clearly see that that is my response and i also successfully logged in my console the method the url as well as the full year and now of course instead of adding this logic line by line to every request simply can go and i say yep i would like to invoke the logger here as well so if we go to logo host 5000 and if we're brave enough and we navigate to about there it is now i have get request about url as well as the full year hopefully that gives you a good initial understanding how the middle works and now i can talk about more complicated topics beautiful we are familiar with the middleware we have our first middleware function but there are two issues with this current setup first our appdress is getting somewhat clunky because i mean we have this logger then we have the methods it's definitely nicer if we have this logger function in a separate file it's just going to keep our app.js lean and in turn it's just going to make it easier for us to navigate and essentially work with our application and the second issue what if i have 50 more routes and i don't want to add this function manually to all of them wouldn't be nicer if there would be a method that essentially just adds my middleware function to any route and of course the answer is yes there is such a function in fact we used it a few videos ago now let's start though by moving this sucker into a separate file so i'm gonna go to my not navbar app sorry this is what happens when you have a bunch of projects open meaning a bunch of folders open let me go here where i have my app.js and i'm just going to create a new file and this is still going to create it in the final sorry so let me go here and i'll create a new file and i'll call this logger js now if you really want you can add the middleware there in name as well but in my case i'm just going to add the name of my function then i'll cut it out and what's really cool that we know how to export this right so we have cons logger and then we go with module exports and we'll just set it equal to our logger so now we have default export that's our logger so of course in the app js i simply need to go with const logger is equal and then i require it i go with logger and if i navigate to localhost 5000 i still should see in a console my log and if you do then everything is correct so that's the first part now the second how can i apply this logger to all my routes so for example let me just copy and paste these ones and i'll say api and then product and then api and i don't know not about maybe items again doesn't really matter what you place here i'm gonna go with products as well as items again i can add them manually but the more routes i'm going to have well the bigger issue this is going to become right because for every route i need to manually add this logger so a better solution is this one where i select all of them i just remove them like so now of course if i go to any of these routes i'm not going to have anything in a console but there is a method by the name of app dot use and in that app.use this is what we do we pass in the middleware so we simply go with logger and once i save check it out now if i go to about for example or if i go to home or api and then products and hopefully you get an idea all the time you'll get this log in console why well because app.use will invoke this for any route now please do keep in mind two things first order matters here if i'm gonna place this below app.get and if i'm going to try to do that in a home page i'm not going to see anything in the console why well because i invoke my use only after get and express everything goes in order so if app get is before the used one the one that applies to all the routes then yes well first we'll hit the home route and then we'll send back home so there is no logger so that's why you'll see all the middleware functions all the app.uses at the top of the document so you'll have your middleware functions first and only then you'll have all your roth methods whether that's get post and you get an idea so that's the first thing that i would like to mention now the second thing that i would like to mention is the fact that we can add here a path so if i go to app.use that's my method and instead of providing only one argument which in my case is the logger i can set up a first one and that is going to be path and i just need to come up with a value now in my case i'm going to type api and you'll see e in a second why so if you save with an api you'll notice something interesting where this is going to be apply to both of them to the products as well as the items so here's the deal once you apply this path over here basically it's gonna apply to any route after this api so for example if i go with api and then some crazy one home about and then products all the time is going to keep on applying this middleware so that's something new right because previously we worked only with a specific route so forward slash or about or products here in this case so of course these are different now when we add this path to use then of course it's going to be applied pretty much to anything that comes after the path that you provide over here so in my case since i provided api and of course it's going to go for any path that's after that now if you want to find out more info about app.use i suggest navigating to docs again we're looking for api reference in our case that is four and if you take a look at the app.use mounts specified middleware function or functions and we're gonna cover that later as well at the specified path and middleware function is executed when the base of the request path matches so this is going to be our base and then whatever comes after will still invoke that middleware function and if you omit the path then it's just going to be applied to all of your requests so if i were to remove the path now it's going to be applied to home about api product as well as api items nice we're familiar with app.use and now i want to make our example even more interesting by adding another middleware function and in the process we'll take a look at how we can execute them in that use what is the syntax in order to add it as well as what is the execution order and let's start simply by creating a new file and i'm going to call this authorize authorize dot js again i'll zoom in just so you can see that is the file name and in here i'll just set up a function similarly to how we worked in the logger one so i'm going to go with const authorized or authorized it doesn't really matter now it's going to be a middleware function so of course i know that i'll have access to rec res as well as next and then in function body for time being i'll just invoke next and maybe i'll cancel log i'll say log and authorize like so okay let's save that one remember that we need to export it so module exports and that's equal to authorized awesome and then in the app.js i'll just copy and paste and i'll say authorize like so and of course the file name is also different it's not a logger so we can go with authorize and once i have this setup in place the way we execute multiple middleware functions in app.use we simply place them in the array so i'm gonna go with my logger first so logger and then we're gonna go with authorize and now once you navigate to a localhost 5000 again any of them in this case because notice there is no path first in a console i'll see this get and then authorize and that's something to keep in mind where they will be executed in the order so if we flip this one if i go with authorized first and then i go with logger then of course in the console i'll have the opposite order where i'm going to have authorized first and only then get so that's something to keep in mind now i'm going to go back to my previous setup the logger and then authorized and now let's take a look at how we can have the if condition in our middleware function now before we do anything let me just stress something very very important where this is just for demonstration purposes this is just an example and it's not how we're going to authorize users in our express applications i just don't want to overwhelm you from the get go so i'm just going to show you simple example using the query string but again this is not this is not how we authorized users in our express applications and with that said i'm going to navigate back to my authorized middleware and in here i'm just going to set up a query string so i'm going to say if the user provides a query string in my url then i'm good to go then i'll send back the resource that the user is requesting however if the user doesn't provide the user query so query string parameter in the url then i'll just send back 401 which just stands for unauthorized so let's start i'm going to go with const and i'm going to be looking for specific query string i'm going to be looking for the user my url parameter and of course we know that it is available in rec dot query like so and i'm going to say if the user exists so if it's there with any value it doesn't really matter which one or i don't know maybe if you want to make it more interesting let's go if the user equals john okay if that is the case then i'm going to go with rec.user and notice what i'm doing here i'm actually adding a property of user onto the rack object and i'll show you why it's so powerful so i'm going to go with recuser that one is equal to whatever i mean that could be a object for example and i'll say here name john again this is just for demonstration purposes and then id i don't know four or three or whatever so that's my user now i still need to call next if i won't do that then the whole setup is gonna go bananas so i'm gonna go with next here and now of course i just need to set up a response if the user or whoever is visiting doesn't provide the query string with a key of user and then value on john and in that case i'm going to go with my else and i'll say res and then let's add a status and the 401 is going to be for unauthorized and let's just say send and simply let's try to spell this sucker unauthorized let's save that one and now notice something interesting if i'm going to go for example to my home page or product again any of the routes because there is no path in my app.used check it out i have unauthorized and if i inspect and in the network tab the same deal i have 401 because i'm not authorized to access this resource i have my authorized middleware whereas say you didn't provide the query stream parameter with a key of user and more specifically you didn't provide here a value of john and since you didn't do that you cannot access the resource so now of course if we change things around and if i go with my question mark and if i say user equals john what do you know i have my home why well because now the condition is met and now we just go to next now why it is so powerful because in the authorized we add the user right so now of course not only i can check for that query string parameter but and also access this info again this is just demonstration normally what you're going to do you'll check for the json web token and then if the token exists then we communicate with database and actually get the user again this is coming up for time being we're simply hard coding these values so back in the app.js in any of the routes now i'm not going to add in all of them but just to showcase i'm gonna add for example in app items i'm gonna set up here a log and i'll look for rec and user and you'll notice something really cool where if i leave this query string parameter and if i go to api and items check it out first of all i have the items and second in console what do i see over here i see that user and that's why it's so powerful because we can add our middleware we can do some kind of functionality and now basically i'm attaching this to my request object so i have the request object and now i'm attaching this property here and now in any of my routes now of course i went with items but in any of my routes i'll have access to that user that's why middleware is so so crucial and that's why it is a big part of express applications because it truly allows us to structure our applications as lego blocks so we have this piece of functionality we have that piece of functionality and when we combine them we have this nice working express server now like i already previously mentioned middleware is all over express so just because we're done with our initial introduction doesn't mean that you're not going to see middleware you'll see it all over the place but just to complete our initial introduction i want to cover two common questions first well if we have access right now to app.use since we know how to use it are we going to add the middleware in a route and actually the answer is yes because imagine the scenario where i don't want to apply this app.use to all my routes for example i only want to check for authorized users in the api forward slash items what do i do well i simply add my authorized middleware correct so now i'll be able to access all these routes without any issues but the items want yes i'll check for that silly query string parameter and if you're wondering well how we can pass two middlewares if you would want in a single route same we just simply grab this array so we copy and paste and now of course once i hit the items not only i will log but i'll also authorize so let's go back and i'm going to take a look where in this case everything is fine i was able to access the resource since i provided the john so notice here name john id number three i also have my console log but if i were to go to just my home page like so i have the home and as you can see i don't get anything in a console i don't get my logger and i'm also not looking for any kind of authorized user so that's the first thing that i would like to cover second what are our options when it comes to middleware so far we have covered the first one our own so we can always set up our own middleware now our other two options are express so express provides quite a few built in middleware functions again in this case we don't have to worry about setting up the functionality we just need to reference the docs to see what options are provided and then of course supply those values and if you remember the express app example we used app.use and i said put the pin on this i'll explain this a little bit later if you want you can retype this but in my case i'm just going to copy this from the for express app.js and if we copy and paste and if i place it here notice so this is a app.use method now what argument the app.user is expecting it is expecting a middleware so in express we have a built in middleware by the name of static again somewhere in the express source code there is a code similar to this now of course this is silly they have way more complicated setup but hopefully you get the gist so there is a method and the only thing this method is looking for our public folder and then i already told you that it basically places all the contents of public folder as our static assets so they're publicly available so we already covered that one and now let me show you a simple example of thirdparty middleware now for a thirdparty malware we'll have to install it and one of the most popular ones i guess for the login is this morgan npm so again just go to your search engine and type morgan npm that is going to direct you to the docs i guess for the morgan and as you can see in order to install we just run npm i morgan so that's how we install the package and the syntax is following where we just go with morgan we required a morgan and then we just pass in morgan tiny now of course this one we need to set it up in our app.use so this is really optional you don't have to install it you don't have to run it but in order for me to hammer this home i will do that so let's go back i'll stop my server and remember the command was npm i and morgan okay i installed this one so now of course this package is going to be in my dependencies like so so not only i have expressed i also have the morgan and then in the app.js of course i'm going to have to require it so i'm going to go with const morgan and that is equal to require and then again i don't have to provide the path that's the module that i installed so i go with morgan and then where i have app.use and go with app.use since i would want to add to all my rows again if you want to add for specific one there's a different scenario but if you want to add for all the routes you just go with morgan and then they basically give you multiple options and the tiny one is just going to provide you the most essential data and again if you want to reference the docs please do so so i'm going to go with morgan and now i just need to spin up my app and i go with npm start now i will remove logger and authorized from my api items just because i think the terminal is getting quite busy and now of course once i navigate for example home page in a console i have get i have forward slash now this is a status code and then i have 2.8 milliseconds and that essentially just signals how long it took for the server to respond and if i were to go to localhost and forward slash about now of course i'll see that i have get request i have about the 200 and now of course time is a bit different as well so hopefully this gives you a general idea why middleware functions are so crucial and how powerful they are and yes the bigger your express applications will get most likely the more middleware functions you'll have now they could be your own ones they could be the ones that provided by the express or there's also going to be tons of thirdparty middleware functions not bad not bad we have general understanding how middleware works in express and now i want to cover rest of the http methods so if you remember which seems like an eternity ago we covered the cycle the request message as well as response and in request well get was by default performed by browser but of course we have other methods as well and i also provided a second slide just for these methods and here you can see rest of the methods so get is again by default set up in a browser and this allows us to read data then we have post that is for inserting data so for example if we have some kind of api orders route we can add an order so user makes an order and we just place that order on the server so of course eventually we would say that in a database then we have put if we want to update data and of course we also have one for deleting the data and before we continue let me just mention something we're not going to persist this data so yes we'll have working examples of post put and delete and hopefully i'll be able to convey my message in a manner where you understand the general setup for rest of the methods but since we haven't covered how to connect to database we won't persist this data now i could have went the file system route where essentially we are persisting this data by writing in a file but i thought it's a waste of your time because most likely you're going to work with database anyway so we might as well skip that part so once we understand how we can connect to the database what are the methods by working with data in our database then we'll have a proper example where we're persisting in as well and in order to kick things off i'm going to navigate back to my address again the previous example is going to be in the file number 10 middleware options and again we're just removing pretty much everything starting with morgan so right after app and all the way to app.listen like so now there's not going to be a home route however i'm going to go with api and people now why do i go with api people because in the data file in the data js where we had the product there's also this one people people is an array each person is an object there's an id as well as the name as you can see very simple example so with this data array i want to showcase how we can read this data how we can add for example an extra person using the post how we can modify the person as well as deleting one and now of course i want to navigate to app.js and first i want to get my people so we simply go with import i'll structure it right away and as a side note since i might make some modifications i'll use let in this case and i'll set it equal to require and then data hopefully this part is clear since we have covered it quite a few times and let's start with the one that we already know and that is going to be a get method so i'm going to go with app dot get like i said i'll purposely set up my route with a value of api and people so that's going to be my path i'll say api and then people now this is a get method and simply will return this array so rec and res and again i'm just going to go with res status let's hard code the value of 200 then let's set up our json and since i want to be kind to my users i'll send back the object i'll say that the success property is true so the request was successful and as far as data property well i'll set it equal to people so let's navigate back to our browser and we're going to go with 5000 and of course cannot get so this is going to be 404 if i just go to the homepage and instead i have a route for api and i believe the whole path was people like so so we run that and now of course i have zoomed in already massively here so let me zoom out in my browser and we should see that we're getting our object the success property is true beautiful and then of course we have the data property and in there we have the people's array so a bunch of people in here so of course that is our first http method that is the get one where effectively we read the data and like i already have mentioned probably 20 000 times that's the default method that the browser performs so when you set up a request with your browser you right away use the http verb by the name of get and that's why you can read the data all right so we're clear with get method that's how we can read there however how we can add data onto the server so how we can insert data and in order to do that we need to use a post method but it's not like i can somehow configure browser and start making post requests unfortunately that's not how it works that's why i provided a little bit of help now keep in mind one thing where after we set up a post method effectively once we take a look at two flavors of how we can set up post request we will install one more tool which is going to be crucial in our express server development which is just going to allow us to test everything much faster but since for the post i do want to show you two flavors that we can have we'll use a little bit of static data meaning there's an app that i prepared but don't worry it's not like you'll have to do that each and every time to test any of these methods and you'll see what i'm talking about in the following videos so first let's start by jogging our memory a bit we have app.use now what app.use is doing is just applies the middleware to all our routes correct and i also mentioned that we have this option of setting up a public folder now we can call whatever we would want but for this methods example i prepared a methods.public as you can see it is just a folder with index.html with javascript html some css and once we navigate there of course i'll show you how the functionality works so this is just prepared so we can test those other methods meaning more specifically the post method because we cannot simply just perform a post request from the browser so first let's set up that methods public as our public folder that's step number one so let's set it up as our static assets and in order to do that i'm just going to add first a comment and i'll say assets and then i'm going to go with app.use again remember that is our method and this is going to be a built in middleware and the name is express static so i just grab my express instance i look for the method of static and if you remember we just need to provide here a path and instead of going public or static like i showed you previously i'm just going to go with forward slash and then methods and then public because this is where i set up my static files for these examples we invoke it and now if we go to the home page we shouldn't get this error so once you invoke there it is we have a somewhat decent looking html file with two options we have this javascript option which we're going to cover second and first one is going to be a traditional form example and again the reason why we do that is because you cannot simply just configure your browser to perform a post request you either need to use a tool which we're going to install by the name of postman or insomnia here's another popular one or you need to set up basically a working application and if you take a look in the methods public we have this working application all right and once we have the basic setup in place now let's take a look at our two flavors when it comes to the post method and i want you to navigate to index html and in there you'll find pretty typical index.html file with some styling with nav as well as deform and in form we have two attributes we have action one as well as the method and as you can clearly see the value for the method is post and this action one just says where we're going to send it and notice now we have forward slash login so that means that this url this path is on our server but of course we know that in the app.js we're not handling that so for the form there's going to be one path and then for the second example when we used straight up javascript then of course there's going to be a different path for that so this is going to be the url or path where we're submitting the form and inside of the form we have label we have input so basically we have name attribute for this one we have the id as well as the autocomplete so we'll type in some kind of value and then we'll send this to forward slash login so localhost and then forward slash login and of course we also have a submit button so now let's start by taking a look what happens when we simply submit this form so go here type some kind of gibberish in my case i'm going to go with john bravely press enter and of course we do have kind of post login okay that's fine we're not expecting anything anyway right we know that there is no route that handles the post for the login but what's really interesting here is in the network tab of course i can see my request in this case this is login now this is 404 and again i'm going to repeat this 20 000 times but check out the method so method is not get method is post and then we're going to localhost 5000 and then forward slash login now what's also really interesting all the way in the bottom what do you see here you see this forum data and then we have key value pair we have name and john and if you remember when we talked about http messages i said that the body is optional so for example when we're sending a get request we're not sending a body but when we're sending a post request it's very crucial so if i want to add something onto the server of course i want to get that data i mean otherwise how i'm going to know where to add to the server doesn't that make sense i hope it does so let's go back okay i see this name and i see john and if you're not familiar basically the way it works is whatever you provide here for the name is going to be a key so for example if i'm going to set this up as testing you'll see that now when we perform the same request the same post request again with the same value different value it doesn't really matter now of course that key name is going to be testing so whatever value you provide over here that is going to be the key and of course the value is whatever you're submitting so in my case it's either peter or john okay that's out of the way so i'm going to change it back to name and now we need to understand something where the request is coming in but a we're not handling that and b we don't have the middleware that actually adds this data that the form in this case is sending to our request so let's see how we can fix the first one and we simply need to come up with a round now in this case remember we're dealing with post this is not get and we're going to go with forward slash and then log in here because of course that's what i have in my form again we go with rec and res and technically we can come up with some kind of info i can say send and i'm simply going to say post and that's it just so we can save time on typing again let's navigate back and in this case let's try susan let's send it yeah i see the post so i don't have the 400 anymore or 404 so that's cool but unfortunately i have no access at this point to whatever i'm being sent so unfortunately i cannot access that susan or john or whatever value so unfortunately i cannot add for example to my list if i wanted to now how do we add it well this is where the middleware comes in so previously we covered static assets with express static in order to get the form data we need to go with url and coded middleware so i'll add here parse form data and essentially this is just going to parse that data and add the values to rec.body so where we have a post request in the rec.body property we'll find all the info and in order to use this middleware surprise surprise we're going to use app.use and then we'll pass in express and then url encoded and then you also pass in flag where you go with extended and you set up false and if you're wondering why are we adding this extended false flag or you just want to get more info about this url in coded middleware simply let's head back to the documentation in this case we're looking for the express and notice here i have express url encoded this is a builtin middleware function in express it parses incoming requests with url and coded payloads and it is based on the body parser so in the previous versions of express you have to actually install the body parser now in this case you don't it already comes built in and as far as this extended this option allows to choose between parsing url encoded data with query string library when false meaning this is our case or the qs library when true again i wouldn't lose my sleep over this one then the common approach is using this extended and false and once we can access it then we can do some cool functionality so first let's just scroll down a bit where we have the login and first i'm just going to start by console logging rec and body let's save that one and again back to our browser again i'm going to go with susan this was 200 so everything was successful and now of course in the right dot body i also have a name and the value is susan so now we can start doing something with this data now i purposely set up two examples one is going to be for form which of course is this one and then one is for javascript now with the javascript example this is where we'll actually manipulate this people array fourth time being with login this is a separate issue we're just dealing with the form so we'll just try to make things interesting by checking for the name if the name is provided then we'll send back welcome and then pass in that name if the name is not provided so for example if the user is trying to submit the form empty for example like so we'll just send back 401 please provide credentials again please keep in mind this is just a example and i'm fully aware that we can check for empty values here on the front end again the goal of this example is to show you how to handle this on the server so i have wrecked that body okay i can see that in this case i have name but it is empty so now of course let's set up our logic first i'm going to go with const name and that one is equal to rec that body so i'm destructuring my name property and i'll just check if the name exists whatever the value that could be b that could be bobby lee not could be again taco burrito whatever you want and as you can see i'm getting quite hungry so let's go with return res dot status then let's set up a 200 which just says that we were successful and we're gonna go with send and we'll set up a template string welcome and i'm just going to access my name so if there's some value i'll send back 200 and i'll say welcome whatever is the value if not well here we're going to go with res and let's just add status here and again just for kicks i'm going to go with 401 and we're going to go with send and of course let's say please provide and credentials like so let's save this one and now we should truly see how it works in the action now i'll leave i guess the tab for now and let's just try to submit so for example if i submit with empty values i'm going to say please provide credentials and as far as my login it is 401 that's what the server is sending back however if i type in some kind of value for example anna comes to mind i have welcome and anna so that's our first flavor when it comes to post request where we use the form and again this is just front end where we come up with an action and since this index.html is on the same server we simply go with forward slash and login of course if your frontend application is separate from your server then you're going to provide a full path where the server is hosted so basically a full domain and then we go with method post now this is technically a frontend part but it is crucial that we understand it so then we perform of course a post request we hit our url so in this case we hit our forward slash login and this is the part where we handle that on a server in order to get that data whatever we are being sent we need to use a middleware this one is built into express so again we simply just need to use app.use which is going to apply this middleware to all our incoming requests and then we just pass an extended false flag and the moment we do that indirect.body will have access to our form values so whatever is set up here as a value that is going to be our key and whatever is passed into our form well of course that is going to be the actual value that we're getting so if i go here with name i'm gonna see either susan anna or whatever user provides now like i already previously mentioned this is just for demonstration this is just so we have a bit more interesting example e instead of just sending back the name so hopefully this part is clear and now we can focus on our second flavor where we use javascript to send the request all right and once we have the form set up out of the way now let's take a look at the javascript option before we do though there's one more thing that i would like to mention if you take a look at the headers you'll notice something interesting where we have a content type for the request header and of course this is going to be application and then we have this form url encoded and the reason why i'm showing that because of course for javascript it is going to be a bit different so just keep this one for your reference now let's navigate back to our static files basically to our front end and now let's take a look at the javascript approach and interestingly here where i have the javascript i do have the form keep in mind we'll still handle this form but in this case it's going to be done strictly using javascript and we'll use javascript to send our http requests and that is very very crucial that is going to be the difference where instead of form now i'll be sending that request using javascript and of course the content type will be different that's why i showed you the form example but what you'll also notice that right away we have our list and if you don't believe me you can double check in data we have john peter susan anna and emma so what's happening well let's go to javascript html this is where we have our frontend logic and again let's take a look at our index html a little bit of css nav and then we have the form now in this case i don't have the action and i don't have the method okay interesting so i have name attribute it still has a value of name so i should expect probably that this is going to be the value that's coming in with my request then i have a little bit of form alert this is where we'll display a little bit of functionality as well as the result now if you're not familiar there's a package called axios which essentially just makes it easier to set up http requests so instead of using the builtin fetch which i could have used i think axios provides a cleaner api and better error messages and since i don't want to spend three hours on explaining all this code i simply went with axios and the way i set it up i just set up the cdn link so this just gets me the axios library and then the moment i install it of course i have axios in my frontend project please keep that in mind those are two separate things this is a frontend project and in order not to confuse you more i just set up a few script tags instead of going with a separate javascript font so as you can see here i'm selecting the result so that is my div and i have this fetch people so that is the function that fetches people from my server now notice the path it is api and people why well because in my server i have also api people so this is for get requests that's the default one however in this case we're not doing that with a browser we're doing with javascript so axios has the method by the name of surprise surprise get that just means that on the front end we're performing a get request to the same server that's why we go forward slash api and then people so make sure these urls match so if these paths won't match then you'll have an error and to showcase that if i go with p poles then if you navigate to the front end and if you refresh can't fetch data so we try to fetch people from our server then we do a little bit of logic and this is just vanilla.js not going to cover it basically we tear it over and then we just set up a nice heading 5s and all that and then we invoke the function but if there is an error we'll look for the error property now in this case i'm not the structuring it i'm actually not using it i just say can't fetch data so that's step number one now the second one is of course using the form so then i select the submit button i select the form i also select the alert because we will display an alert if the value is empty and again let me repeat i'm fully aware that we can check for that in the front end i just wanted to showcase the server setup and then notice something interesting where i have this try and catch block in my functionality so the moment the user is submitting the form of course i invoke my callback function it is a sync because for the actuators i can wait for response and notice this one so i have axios and again surprise surprise the method name is post why because we are sending a post request and this is just an axiorys thing but again we provide the value in this case the url value is api and people so something that we're not handling yet on our server and this is the value so again this is just axio syntax where in order to set up whatever data you're sending you just pass it as a second argument and you set it up as a key value pair now what's really cool that would axios they set up all the content types and all that good stuff for you so again you just save a little bit of time now if there is an error in our case that is going to be if we're trying to submit something and in fact there's no value meaning we just try to submit empty form value then we will display the error message and again this is really cool because axiorys just provides a very useful error api unlike the fetch where you really need to jump through the hoops so let me save it back to people so we can see of course all the people that we have in our array currently and then of course we'll focus on this post one so as you can see i get the input value and i just passed it in as a name property awesome so now back in our app js of course we need to handle it and please keep in mind one thing where app dot post and then api and people is not the same as api get and api people even though the url is the same methods are different and that goes for all the methods we're going to use whether you're talking about put delete or whatever so just because the urls are the same doesn't mean that they mean the same thing no the method is different here i'm just reading the data i'm reading data from api people here i'm actually trying to add data and again we're going to go with wreck and res and let's just go with some simple response now for time being i'm just going to say that my response is going to be 201 now that's the response that we send back if we are performing a post request and we are successful so i'll just say res that status 201 and for time being let's just say send and i'm just gonna say success and of course now what i would want is to navigate back to my javascript one hour fresh i'm getting all my people and now let's try it out so i'm gonna send this one so i sent again here nothing changed but if i take a look at my network tab i should see and by the way sorry i'll have to do that one more time let's go with i don't know susan here let's try to submit and there it is now of course i have api people and 201 so that's the response that i'm getting on my front end so let's bravely click on this one and we can see that the request url is api people okay the method was post now the response was 201 so it was successfully created and now check it out when we look at the request headers of course we have application json so on our front end we do need to add this content type when we are sending the data now again what's really cool about axios it adds for us but in general you need to keep that in mind and there it is again we have this request payload and the name is equal to susan so whatever i'm going to pass it in if i'm going to send it empty then i'm going to still have the key name and the value will be empty now the gotcha here is even though we're handling a form submissions we're not handling the json data so yes we know how we can send back the json data but we're not handling the incoming json data and this is where another middleware comes into play so i'm going to say parse json here and we simply need to go again with app.use and we go with express and json now in this case i'm not going to go to documentation if you want you can do that in my case i will try to save us a little bit of time and we'll skip that and here we have api people and now similarly to our login we have access to the form data that is being sent with javascript in the rec dot body previously before this was added no we have no access yes when it comes to form that was one setup now when it comes to straight up http requests for example in this case sent with javascript no we had no access so we were getting a json and now we added a specific middleware that handles that so of course in this case now we can set up more logic correct we can say that we're looking for the name and if the name is provided then awesome then i'm going to send back that new person that was created so we can add it to our front end and again this is the case where we're not persisting this data anywhere later we'll learn how to do that for now i already have the code that adds it to our front end however if the user tries to submit without any values well then there's going to be a error message so in the api people in the post method let's set up our logic where i'm going to go with const name is equal to rec.body the middleware makes it possible now and then i'm going to say if the name is not provided well then i'm going to send back the 400 then i'm going to say please provide name value so there's going to be a error message so i'll say here if and exclamation point and if the name is not provided then let's go to return res dot status and for the request error we go with 400 that's the status code and then let's go again with json and in this case we're gonna go with success now this success will be false and then we're going to go with message again i would suggest using the same properties because of course i'm handling them on the front end as well so in here i'll say please provide name value like so now if the value is provided whatever it is then of course we can send back res.status 201. hey guys it's john from the future with a small update as you'll see in a second while i was recording i forgot to change the methods so instead of writing json i just left it as send and while we can get away with it in this example normally you always want to use json instead so make sure you change your method from send to json and in this case let's just set up a proper object we'll say success is true so now we're being successful and i'm just gonna send back that person now i'm going to set it up with person key and the value will be named whatever i'm getting again please use the same ones if you want to have a same result now let's navigate back we can refresh just so we are all on the same page and if we type susan now we should see another susan added to our list and then again we can go with john and i'm just being lazy on coming up with original names and as you can see every time we add value in our form we're being successful we're actually getting back this value from our server and then we dynamically added to our front end and again the reason why we're doing this way is because we're not persisting this data so that's why the setup is following later of course we'll learn how to persist this in a database as well and if i try to submit with empty value check it out now of course i have people and this one is what 400 right notice here and it says please provide name value now if you want to do a bit of console logging you're welcome to do that on the front end if for example you are iffy about the syntax but just to let you know when we talk about axios here effectively we're getting back the whole thing so when we perform a request http request with axiorys we're actually getting back a giant object now what we're interested in that object is a data property so that's the response that is coming back from the server and then in here as you can see i set up a heading 5 with data.person so that's the person that we're sending back from our server now if for example there is an error we go with error response again data property because that's where the useful information sits because the object of course is giant with lots of useful information but as far as what we're sending back it is sending in data and then message now i'm looking for the message property of course here because i set up a message property on the server hopefully it is clear this is our second flavor where effectively we perform a post request from the application and of course in that case we do need to provide content type as well as the data and next video we'll install and cover some basic setup for a very useful tool that is going to save us a lot of trouble when we work with post delete as well as put methods all right so at this point we're familiar with two ways how we can send a post request so we covered how we can do that using the form as well as straight up http request in our case using javascript however there's a major problem in our current setup and the problem here is following if we need to create a frontend to test something for every route as you can see i mean our development is going to be extremely slow because we can clearly see that it's probably going to take us way longer just to set up a front end than setting up just one simple route so every time i create a route i'm probably going to spend i don't know five six times more on setting up the front end where i can test this route and of course there has to be a better option and that better option is a tool called postman and postman is just awesome for quickly testing our apis so at this point i strongly suggest that you navigate to postman.com again it's a free tool so you're not going to have to pay anything but for mainer of the course yes we'll use this so if you're kind of iffy about installing something new this is something that is required so navigate to postman.com and then they'll try to sign you up you don't have to do that just keep scrolling down keep scrolling down and all the way in the bottom you'll see this download app option go here and they'll right away detect which operating system you're using of course in my case that is mac so download the application once it's on my computer i'm going to navigate back to the desktop i'm going to go to downloads i'll crack it open then of course i'll just move it to my applications like so and i already had one on my computer but i removed it so we can do these steps together then this is the application let me zoom in that's the postman so just click on it and then it's going to spin up the app and eventually you'll hit the dashboard and i'm not going to spend half an hour on this setup but of course as we're progressing we the course as we're progressing with our examples we will cover more features that this app provides and basically here you'll have all your requests that you can actually group in collections and again that's something that we'll cover a bit later and this is where we can make those requests and in order to create a new request we just click on this plus sign and check it out so at the moment i have untitled a request in here i need to enter the url and i can send my request not orders here on left hand side what do i have i have get but what's really cool i have all these methods available as well so first let's test out the get route and then we'll see how we can deal with post route as well now as far as our url what it is well it is localhost 5000 and of course the full url is api and people now this is for the post as well as the get and since we're testing it of course that's why we have a method with the value of get so let's go here local host and then five thousand then forward slash api and people and the moment i click send check it out what do i see here in the bottom i see my object the success value is true and there i have my data so as you can see the moment i create my route for example post route or put route or whatever i can test it immediately i can test it within a few seconds instead of building the whole front end just so i can test one route and of course once we have covered get route now let's see how we can deal with a post route so we need to change the method of course now the url still stays the same because i do have a route for the post as you can see and in here what i'm looking for i'm looking for the name in the body and how do we construct a post request in a postman well we do that in a following way first we go to the body and we look for raw and instead of text i go with json because i'm going to be sending a json data so this is not the case where we're working with the forms in this case we're sending a json data and what you'll notice something really interesting in headers right away there's going to be a content type so let's see let's set up first the body and you'll see how it gets added so we're gonna go here with a name again this is what i'm looking for that's why i need to pass it and then i'm gonna set up some kind of value now since i'm setting up the json please remember that we need to use double quotation marks so i'm going to go here with john and if you paid attention previously we had eight headers and now we have nine so i'm gonna go back and there it is now i have content type application json so that's really cool we don't have to do anything the header gets added for us and of course the moment i click send check it out now i have success true and person john why do i have that well because that is my response i have success true and of course whatever name i received i just sent it back so now of course let's quickly test out our 400 as well so i'm going to navigate back and then in the body i'm just going to send a empty string or you can remove name altogether that's really up to you and now of course i have 400 bad requests and success is false and of course i can see the message so as you can see we can test it within seconds and to really hammer this home why don't we create another post route and quickly set up some kind of response and let's test it out in our postman as well so i'm going to go in between the post and login i'm just going to go with app.post and the route is going to be following i'm going to go with path of api people people and i'm going to add a postman here or you know what let's do it this way let's go postman and then people like so and then as far as the callback function again we get rec res and then in the body again i'm going to be looking for the name property so i want to get that name so i'm going to say that i'm expecting it we'll go with name rec dot body again if you want to cancel log the body you can do so but i think we have done that quite a few times so i'm going to omit that then i'll copy and paste my response so again if the name is not provided meaning if the property is not there or if it's just empty i'm sending back to 400 however if i'm successful then i'm just going to take my array i'll add that extra person and i'll send it back now i'm not going to add the id i'll leave that one blank because eventually database will do that for us so i don't really see the point of doing that manually so i'm going to go back to my api postman people and then again this is my error response and now let's copy and paste our status and then instead of sending that one person we created why don't we do this why don't we go with data and then of course the array name is people and now as you can see i'm using the spread operator and i'm just going to add that one single person so i'll save now of course we do need to change the route so it's not going to be api it's going to be postman and then people like so now let's add for example peter and the moment i click send there it is i have my success true and as far as data all the way somewhere should be peter as well so again we just grabbed that peter and then we added to our array hopefully this makes sense and now of course we can work on other http methods as well all right and once we're familiar with postman now let's work on the other two methods so now we're gonna be working on put method as well as the delete so i'm gonna scroll down and below the post login route i'm gonna go with app and then put now again this method is for editing the data so put method is for update and again the convention is following where if we have a list for example in this case that would be api and orders if we want to edit or delete we go with our route parameter where effectively we set up a route for api orders and then we go with colon id and this is going to get me that one specific item now please keep in mind one thing where this is a convention so technically there are multiple other ways how you can set it up but there's a reason why that convention exists and that's why throughout the course we'll stick with this convention i'll cover the official name of this convention a little bit later as well as a bit more details about it for now i just quickly want to cover both of the methods so i'm going to navigate back i have my put method that is for modifying the data and in our case what is the url for the whole list because that is api people so this was just for testing correct and then we go with api forward slash and then we go with people and then of course i also want to add that id so this is going to get me that one specific item and again the reason why we're doing that because when we'll send our put or delete requests we'll send to a specific path so this is going to be that one item and if that item exists then in the body there's going to be data to update or in the case of delete there's going to be nothing in the body we'll just remove that item and you'll see how it works in a second so please be patient so we're going to go with people and then remember again we have route params and in this case i'm not going to call this person id i'm just going to say id just remember that we can call it technically whatever we would want and now in this case there's two things that i'm looking for first i want to get the value here in the params and remember we access that using the rec params and the second thing when it comes to update when it comes to the put request i'm also going to send something in the body why well because if i'm updating for example if i'm changing the name from peter to susan or whatever of course i also need to supply this value so you need to understand that there's two sides of this request not only we're looking for that specific item that's why we use the params that's why i specifically say hey i would like to get the item number one or item number two i also need to supply this value because otherwise what's the point of updating something so let's access both of those things let's say that i'm gonna get the id from rec params so this is going to tell me which item and then the second thing since of course i want to update that item i need that value as well correct so we're going to go here with const and i'm going to be again looking for the name and we'll say reg dot body and that's it that should do it so these are the two values that we're gonna get from our question and just to make things interesting i will console log them right now so i'm gonna go back to the postman and remember we need to change the url it's not gonna be api postman in this case it is going to be people and now you can select any of the ids whether that's one all the way up to the five so we go here with one and then as far as the value what is the value for the first one it is john so kind of makes sense if i'm updating that i go with peter correct so we have put request we have api and then people and then check it out the moment we send it now of course the request is hanging don't worry about that but in a console we should get api people and then the id and of course the reason why i don't see anything because i was smart enough and i didn't console log anything so i'm gonna go back with id name and you know what for timing let me just send back hello world okay let's go here let's actually send it one more time as you can see could not get the response that was the error this time in this case i am getting hello world so that worked beautifully and as you can see the status code is 200 as well and then in the console i have one and i have the repeater so this is going to be the id and of course this is going to be the value now if i'll change it of course if i'll say number two and if i'll send it again i get back my response and now the value for the id is due hopefully this makes sense so now of course at this point we need to set up the logic again we are going to set up the logic with our local data with our people array eventually in next examples we'll work actually with database but the main idea is exactly the same where from the postman while we're testing we're sending the id in the url basically we add that url parameter and then in the body we'll send the value so that part won't change just the functionality in here and as far as this functionality well since we have a simple javascript array first i would just want to get the person with that id if the person doesn't exist then i'll send back the error response and if the id does exist then i'll just change the value now i'm not going to be looking for the error message if the value is not provided we're going to cover that once actually we work with database i think is just going to be at the moment waste of our time so let's do it people i'm going to remove both of these console logs hopefully you understand how we supply both values in the postman and i'm going to start by creating a person and this is going to be equal to people dot find again i have the array so i have access to all the array methods and then if the person id matches to my params id then of course i'm going to get the person now let me check in the data notice i still have it as a number so i'll have to change the type as well so i'll say if person id is equal to a number and i'll pass in the id that i'm getting from my params whether that's one five or maybe it's going to be id that doesn't make sense all right good and if the person doesn't exist well then i'll send back the response now again in order to save us a little bit of time i'll scroll up and i'll look for any of my error messages since i just want to copy and paste and change some values around so in this case i'm going to look for this name if it doesn't exist then of course we have the error and in our case of course we just need to change it around if the person doesn't exist so if we cannot find that in the array then we're sending back 404 remember that was the status code if we cannot find the resource and as far as the response we have success and of course it's going to be false and now let's go with message and in the message we're going to use a template string we'll say no person with id and then i'm just going to pass in the id so that's the first response if of course the person doesn't exist so if in the primes we enter for example value six we know that we have only one to five or abc now the second thing if the person doesn't exist now of course i just want to iterate over the array and for that specific person for the person whose id matches my params value i'll change the name since i'm expecting that one to be in the body again we're not going to deal with this error for now we'll do that once we work with database and we're going to go with new people new people here and we'll say people map so i'm iterating over my array again i'll reference each and every person as a person and i'll say if person id matches to that one i have in params so number id again then i'm going to say person name since that is the only other property i have is equal to my name now where i'm getting the name because i'm getting it from the body so if the id of the person matches to that one in the params then please change the name that i can find in the body if not then simply return a person return a person and now of course all the way in the bottom i'm going to go with res dot status and then we're sending back 200 since the request was successful as far as the json we go with success or sorry not super we're gonna go with success true and then as far as data well now i'm sending back the new people so let's go back at this point i have two so let me change it back to 1 because i know for sure the first value was john so again the path is api people and then id of 1 and i just want to change it from john to peter so let me double check in data this should be john uh it's a good thing i didn't go with the idf2 since that one is already peter so now let me send it and check it out now i have success true and data of course is my array and instead of name being john for the person number one now the name is peter and of course if i'll do the same thing for example for the person number three again we send it back of course now i have three peters because i just keep changing those values again we're not persisting that data but while we're making requests you can clearly see how we are modifying this data and we do that using http put method and then of course the path is api people and then whatever the id and again the whole reason why is that happening because on our server we are handling that all right and the last method i would like to cover is a delete method so below the put method below the modify option i'm going to go with app and the method name is delete again the convention if you have a list is going with a list url and then add that specific id because the setup is going to be extremely similar to a put one now the only difference is going to be that of course in this case when we're deleting we're not expecting anything in the body the user hits the url for example api people and then one we just remove that sucker from our list that's it so let's go down where we have app delete and again the path is following where we go with api and then people and again let me stress one more time something where these routes are different when we talk about app.get and api people when we talk about app.post and api people or even if we talk about app.put and app.delete just because the path is the same since the method is different these are different requests that is crucial please don't think that just because you have a different method you have to set up a whole new path no you can have the same value for the path if the method is different that is totally different request so let's go here again with our callback function we should already be comfortable with this one we have rack and res and in this case i'm not gonna the structure out the id from the prompts i just want to showcase that we also have this option of accessing the params directly so first again i want to look for the person then we'll send back this response and yes oftentimes put and delete are going to be extremely similar and then if the person does exist then of course i'll just filter out the array and remove that person from the array since again the whole point of this request is to remove that person from the array so in this case you can actually copy and paste and i know that some of you might find that annoying but at the same time we do need to speed this up and start working with a database so hopefully you can forgive me i'm just gonna grab everything starting with the person all the way until the end of our error response d404 let's scroll down copy and paste and this is what we're trying to do so i'm trying to find a person whose id matches that in the params and of course in this case i haven't destructured out the id right so i just need to change this around where i go with rack and then params and the id again the setup is exactly the same the difference is that i'm directly accessing the params object and if the person doesn't exist then we send back d404 so let's try this response i'm gonna go back to my postman again the api is people but we need to change the method right so now i would want to delete and since i want to test out the error and as a sign up you can send the body doesn't really matter we're not handling that on server anyway so it's really irrelevant but since i want to test out the error i'm going to go with abc so again the path is localhost api people and then abc and if everything is correct i should see the error and of course there is but something tells me that this is a different error so let's go back and check it out and of course the issue is following notice here in the json how i'm accessing the id now of course i haven't destructured it right in this case i went with rec params and then the id so i'm going to go with rack params and the id let's save it and let's try one more time again i'm looking for a person whose id doesn't exist so i'm gonna get the error and there it is i have success false and as far as the message no person with id of abc so i was looking for the person with id that's not in my array so that's why of course i got back the error response so now i'm gonna go back to our app delete request and here i just want to filter out the array and the way we're going to do that i'm going to go with const new people is equal to people.filter that's my array and i'm just filtering it i'll pass in my callback function and i'll reference each object with the person parameter and i'll just say if person id does not match the id found in rec dot params then return that person if it does match then it's not going to be included that's why we go with exclamation point and remember that we still get our id as a string so we must do the number one first and then only we go with params and the id so that's our new array without that specific person whose id matched the one in params so now of course let's just go with our return return res dot status here and this is going to be 200 of course and i'm going to go with json and we'll set up our object success is true and i'll send back the new people array so we're going to go with data and then new people let's save it and let me test that out e in the postman where of course now i'm gonna go with id that is in the array and that's gonna be number one so if i send notice how it is irrelevant if i send body again because i'm not handling that on the server anyway but if i take a look at my data well the person with id number one john is missing why well because his id matched to the one that i passed in the primes so now of course he was removed from the array so if i'll go with five same deal now the john is back here because again we're not persisting data but the person with id of five has been removed from the array hopefully this gives you a good understanding how we use other methods as well not just get and why we go with postman instead of setting up the frontend but before we cover router in express let me just stress something that yes while we're developing our server of course we'll use postman because you can clearly see how much faster it is i set up the route and i quickly tested otherwise if i would have to build a front end for every route that i'm creating i mean the process would be just very very long but at the end of the day when you set up the api the expectation is that there is going to be someone who's using that data now that could be on your own server so for example if you're building a full stack application with mern that's one of the options that could be decoupled application remember how i showed you a example where i have the api on my server but then there is a react application that uses it it doesn't mean that you have to build that frontend application yourself just be mindful that the whole idea of setting up the api is that someone is going to be using that data that's it that's all i want to say and now of course we can talk about router in express all right i think we're moving along quite nicely but as you can see the moment we're starting to have more routes and more functionality we have another issue and that issue of course is the fact that our app.js is getting quite busy and technically we don't even have that many routes so what is the solution well the solution is using express router where we can group those routes together and then as far as the functionality and actually set them up as separate controllers now eventually in the next example when we work with database i'll cover again the common setup which is called mvc basically it is a pattern it's not a rule but it is a nicely used pattern when you're setting up the api but we are missing the model part in the mvc pattern because we haven't connected the database so i'll just leave it at that just please keep in mind whatever i'm about to show you in this video and in the next yes it is a pretty common convention and pattern so i also suggest sticking to that now also i want to mention that in this video we will do a bit of copy and pasting meaning we'll have to refactor the code because i think this is a perfect example for us to set up the router where we already have some code so you can clearly see the benefits of setting up the router instead of me coming up with some empty routes and then saying that yes that is the best pattern so with that said first where we have the request the post request for api postman people i want you to change this around a little bit so as you can see i keep going back and forth in this case i want to go with api people and then let's just say postman again it doesn't really matter we're not going to make requests anymore from the postman in these examples anyway this is just about our code structure and then once we change this around i also want to move this login up just so it's a bit clearer what we're doing so take this login route and keep moving moving moving moving and just place it on top of your routes and there it is now of course i have my login and now notice the pattern whereas i have one route for the login but then rest of them i have api people api people api people postman api people id and hopefully you get the gist again i have api people id so wouldn't it be nicer if i could somehow group all the api people and also add one for the login but basically in a separate file and the way we can do that is by setting up the router now again common convention is just creating another folder so i just want to make sure that i'm actually doing that in the express tutorial let's create a new folder and common convention is calling this route and then you just come up with whatever name you want now in my case i'm gonna go off for the login because we're just gonna imagine that maybe there's going to be one for register one for logout or whatever and then there's going to be one 40 people so that's going to be for my api and people so let's set up these two files i will zoom in massively just so you don't think that i'm cheating so let's go here with alt js this is where i'll place my login one and also right away set up my people people just okay awesome i'll start working in people.js because it's going to be a bit interesting and then we'll do the same thing in the auth as well and the way we set this up we simply start by requiring the express so we go here express require and of course the module name is express and then instead of setting up the app we go with router and we explicitly get the router from the express so this is going to be a router instance that takes care of the routing instead of the app so we're not going to do the routing anymore in our app.js well sort of we will we'll use the middleware but as far as the specific urls we'll handle that in this routes people file and the way we set up the router we go with router and that one is equal to like i said express dot and then we go with capital letter router and then we invoke it awesome that's a great start we can save this sucker and now i want you to go back to app.js and don't grab the login that's why i set it up separately above all the routes but grab all of the ones with api and people so take these suckers here all the way up to delete basically stop at listen cut it out and then copy and paste in people like so okay great so now of course i have all my routes here now our next step is actually changing from app to router because i want the router to handle the routing so in my case i'm going to select all of my apps like so so i'm just doing that with command d in the visual studio code and at this point i should have multiple cursors like so and i'll set up my router and now all the way in the bottom i want to go with module not exports and of course at the moment i'm exporting my router and then once we export a router of course in the app.js i want to set up a app.use where i'll say yes for the path that starts with api and people i want to use my people router and the way it's going to look like we're going to go back and at this point we have people here and as a side note actually we need to cut it out but we're not going to use it here as well eventually the setup is going to be different so for now yes please cut it out and copy and paste in people but since we'll be setting up the controls we'll have to do that one more time anyway so i guess i'm going to go below the router i'm going to look for my people otherwise my functionality won't make sense and in this case remember we are sitting already in routes so i need to go two levels up and i still need to look for my data correct so now of course our functionality should work hopefully we don't have some weird bugs and then like i said in the app jess now of course i would want to use my app.use so i'm going to go below express json and i'm going to say app.use and now i need to set up that base route now what is my base route here well it is api and people correct because this is just my route and then in some cases i have the postman or i have the id that's it but the base stays the same okay awesome so we provide this path we say api and then people and now i want to set up that router and of course in order to set up the router i need to import it and you can call it people router you can just call it people again that is really up to you i'm just going to say people is equal and now we need to require it and remember we have a folder by the name of what routes and then we also have people file okay awesome we require our router here correct so that's our router and we're exporting awesome so we get the people and like i said with use we can use the path if we want so this is not going to be applied to all of them this is only going to be applied to the ones that start with api people and then we pass in the people we'll save it but there is a problem you see once we set up this router with a base path in the people actually we have a mess right now because we already have the base for our router in app js where we have api people and now in the people.js if you check it out we actually have api people forward slash api people so i fully understand that this is going to look a bit drastic but in order for this to work we actually remove everything we remove that base so we go here with just a forward slash why well because we already have the base here we have api people so that's how the route is going to start and then we just have the forward slash so this will match whatever i have in the address and since in the get and in a post both of them just have api people well i simply go with forward slash again i fully understand that this might look a bit confusing in the beginning but again the more routers you'll set up the easier it's going to get so this will just match whatever path i have here whatever base path i set up in my app.js so i'm just saying yes i'm using this people router and in the people since i already have base path in place i can simply reference it using the forward slash so this is going to match whatever i have in app and once i have spent what seems like an eternity on the base path i can keep on scrolling and again notice i have api people and then postman so what's the only thing that i need here it's just a postman because i already have api people so i remove this sucker here keep on scrolling then the same with id right we only care about this one that's the whole point of setting up the router so we can start splitting up our functionality in multiple files same goes with this last id and even though i think i said that we're not going to use the postman i do want to quickly check and i'm going to go with get simple if the get works trust me the other ones work as well so we go here with api people we send but unfortunately i get the error hmm that's interesting so let me check i think the problem here is in the app.js i don't have the forward slash so let me try this one let me send it one more time and there it is now of course everything works so my apologies i forgot to add here forward slash that's why we were getting the error and of course everything works i can go with get i can get my list if i want i can also maybe delete a person so i'm going to go delete and we're gonna test three so let's see we send and as you can see the person with id of three is missing so as you can see our route works so that's the first step so now here's the challenge try to repeat the same thing with login now with login it is going to be a bit simpler because we don't have that long of a path but again stop the video and try to set up the login yourself and then once you're ready resume it and we're going to do it together how was it hopefully you were successful and i'm going to give it a shot so first remember we needed a file so in this case i do have auth js awesome so i'm just gonna cut this sucker out from my app.js and place it in off then of course i do need to have the boilerplate for the router so again let's go with express require we require the module by the name of express of course then we set up our router router and that one is equal to express dot router we invoke it then we change this value around like so and then we're just gonna go with module and then export and that one is equal to our router we do this then we navigate back to app.js and we'll have to import it as well so we go with auth i guess let's call it that and we're looking for auth file that's where our router is coming in and then of course i just need to set up my middleware myapp.use where i provide a path of what well of login and in this case i'm going to be more careful and i will add the forward slash and of course i'll set it up as auth so let's save this one and then the only thing we need to do in the login is simply change it around where i'm already handling the login in the app.js so forward slash login so again my route now is forward slash login so i simply go with the forward slash i already covered the route in the objects so i don't need to do that anymore in here and you know for this sucker just to make things a bit more interesting why don't we use the browser now keep in mind you can still use the postman if you want but i'm gonna go the browser out so we're gonna go with new window i'm gonna go with 5 000 here and of course this is going to be the small screen i have traditional form so let's go with some kind of name peter and i send and i have welcome peter and of course if that is the case i know that my functionality works so we are in good shape again probably the most confusing thing is this one where we use app.use to set up our route so all the routes that will start with this api people are going to be located in the people.js in the routes folder and in there instead of using app we use the router and then since we already have the base setup in the app.js when we have a route that exactly matches the base we just go with forward slash now if there is something else after the base route so some additional info of course then we go with forward slash which just means that we match the base path and then we add whatever value we want and hopefully you can see how much cleaner is our app.js where now we're splitting up the functionality in separate files for our routes beautiful i think we really clean up our app js but we're not out of the woods yet if we take a look at our auth js yeah this one looks somewhat clean but we need to keep in mind that we only have one request we only have one post request to our login however if we take a look at our people.js it is still somewhat of a mess because we have a bunch of functionality since of course we have more routes and of course a better setup is if we would be able to split this up into a separate file and i'm talking about the functions so imagine this scenario where we only would have a router then i'm gonna set up my method whether that's get post or whatever then i'm still gonna have the route but the functionality this one the controller is going to be in a separate file so it's going to be a separate function and you'll see how much cleaner our file is going to look like just in a second so again we need to head back to our express tutorial now i'll zoom in i'll create a new folder and again common convention is calling this controllers for the reason that there is a pattern called mvc so model view controller and then again we come up with the name in my case i'm going to go with jobs or i'm sorry not jobs i'm going to go with people and i'm not gonna set up one for the other one for the auth since there's only one but for people i will set up a controllers file by the name of people.js and here i just to set up first my functions and the way it's going to work we're going to go with const and then again you just need to come up with a name so for example for get request where i'm getting people i'm just going to call this get people keep in mind this is just a function so the name is really up to you and since i'm going to have the same functionality of course i need to keep in mind that i do need to have access to rack and res now it's really cool that once i pass this function as a reference it's still going to work so i simply go here with this rack res and set up the functionality now probably faster is just going to be doing like this where i cut out and then back into controllers i copy and paste now i know that some people might find this annoying but yes i'm purposely refactoring the code so you can see the benefits right away and i'm going to do that for all the functions and for a little bit it's gonna probably look messy where i'm gonna do the same thing for the post so i guess first i'm just gonna cut it out and then back in the controllers nothing routes in the controllers let's come up with that function as well so const and in this case i'm going to call this create person i'll copy and paste the code okay awesome back in the routes let's get the postman one so in a controller let's also call this const and create person and postman like so copy and paste that's my function then back in routes i have one for put so i think it would make sense if i call this for example update person again cut out everything starting with a function and then all the way to the closing parenthesis cut it out back in controllers we're going to call it const update person like so copy and paste and lastly let's deal with a delete one as well so let's keep scrolling again we cut everything out like so and then back in the controller let's create one for deleting the person so const cons delete person and copy and paste and if you remember which seems like an eternity go when we covered the exports i said that of course we can also use right away module exports and then whatever so for example in this case that could be get people or create person or create person postman now in my case i always prefer to do my exports all the way on the bottom where i say module exports now this is going to be the object and now i just want to access all the functions keep in mind it doesn't change the functionality functionality is the same where i'm basically exporting an object with bunch of functions so here i just need to reference their names so it's get people it is create person create person postman then update person and lastly it is also for deleting the person now one thing that is missing of course is the people like i said this is just going to be temporary so i'm going to go to the controller here and i'll copy and paste now in this case the path is correct because the route was already in a separate folder so that should still work and of course now i can save my controllers and in the routes what i need to do is of course import all of them so in this case we go with const and again i'll write away the structure all of them so let me just copy and paste i think it's going to be faster like so since the names of course are going to be exactly the same i destructure them and i'd structure them from require and then of course we're looking for controllers and then more specifically i'm looking for the people like so and once we have required them of course now we pass in the function reference so for example here i can say get people now i do need to add a comma and if everything is correct our functionality is still going to work so in the controllers we're still accessing rack and arrays and we're still sending back the response but of course the benefit of all of this work is the fact that our routes file is gonna get much cleaner so in here remember the name was create person like so and then we have one for create person postman and let's set it up like so then we have also one for update person and lastly we have one for the leading person right so we go here with delete person i save again i'm not gonna test all of them out but i'm gonna go with for example delete and i'm gonna look for four this still works i remove the person number four and also if i check out the get one for the people this also should get me back the array so i know that my functionality still works but i nicely cleaned out my file now lastly before we talk about the databases i just want to mention that when it comes to setting up the routes we actually have two flavors so i'm gonna comment these ones out and i'll show you another way how we can set up the routes and effectively the benefit is that we can set it up in fewer lines of code keep in mind the functionality is going to be exactly the same so again this is going to be the case where it comes down to your preference if you prefer setting up your routes this way you can definitely do so there's no rule against it if you prefer the method that i'm about to show you then of course you can use that one instead so we go with a router and then we go with route and then in the route i set up the path and again since there's get and post that match exactly what i have in base same situation i just set up the forward slash and instead of setting up them separately for example get and post i can just chain them so chain one after another so i go with get that is of course my method that is not changing and then i need to pass in my controller function okay as you can see almost the same in this case however i can change it now the method names did not change the paths did not change they're still actually referencing the base path in here what we have in app.js but since we can chain it we can simply write it in one line of code so of course the callback function is gonna be create and i believe it was person so create and person like so then we have of course one for the postman so in this case of course it's not going to change it's pretty much going to be the same logic where we go the router route like so and then we go with forward slash postman and then of course i want to chain dot and i believe it was post right and then we go with create person postman and then we can again set up one line of code for the put and delete so in this case i think i'm going to just copy where i have router dot route then we set up our route and in this case it is going to be forward slash and then id and then we have two we have one for put and we have one for delete so we go with delete and then as far as the callback functions we go with update person and also we have delete person and finally let me just stress it one more time where whichever setup you choose is really up to your preference functionality is exactly the same we go with router route and then we can just chain our methods and add the callback functions now in this case we set up each route separately so for example if you have multiple urls that match yeah you're in good shape you can just set up router route pass in the url and then chain all the methods and lastly let me just quickly test it one more time since i made some changes i send it and there it is i successfully get back my people so with this in place with our router in place with the fact that we have covered all the methods the get post put and delete i think we're ready for the next level where we connect our server
