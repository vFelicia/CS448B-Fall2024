With timestamps:

00:00 - Hello everyone here on freeCodeCamp today and 
welcome to this course on no SQL. My name is Ania  
00:07 - Kubow, and I'm a software developer and course 
creator on YouTube as well as your instructor  
00:11 - for this video. In this video course, I will 
be demystifying what no SQL is clarifying the  
00:18 - difference between SQL and no SQL as well as going 
into a deep dive of the four main types of no SQL  
00:25 - databases. With each deep dive, we will be 
approaching each learning as an explanation,  
00:30 - example and exercise. So the three is in order 
to fully grasp the topic we are discussing.  
00:36 - After that, we will go straight into using what 
we have learned with two real life use cases.  
00:42 - By use cases, I mean, we will be getting data 
into real life projects using a document API,  
00:48 - and the Graph QL API to communicate with 
our newly made databases. And finally,  
00:54 - we'll be wrapping up with where to go next. Don't 
worry if none of this makes sense to you. Now,  
00:59 - this is what the tutorial is for. As always, if 
you like what we are doing here at freeCodeCamp,  
01:05 - please do get that subscribe button and click as 
it would really help us on our mission to provide  
01:10 - a broad spectrum of learning materials right here 
free to access for you. Now, let's get to it.  
01:21 - So the first thing you need to know is that 
no SQL is an approach to database management.  
01:26 - It is considered to be super flexible as 
it allows for a variety of data models,  
01:31 - such as key value, document, y column or 
tabular and graph formats. These are the four  
01:38 - we will be looking at today, as well as a new 
emerging trend of multi model databases. So we  
01:45 - have already mentioned that no SQL databases are 
casually considered to be flexible. But officially  
01:51 - the defining characteristics of no SQL databases 
are considered to be that they are non relational,  
01:57 - distributed and scalable. Distributed 
refers to running on clusters of machines  
02:03 - globally distributed to support apps at two 
different geographical locations. And scalable  
02:09 - means that no SQL databases are able to store and 
query life scale data, as well as support high  
02:16 - transaction throughput scaling horizontally. In 
addition to this, they're also partition tolerant,  
02:22 - meaning that they are able to work in 
the presence of network partitioning.  
02:27 - And they are also highly available, meaning that 
they are able to serve requests even when some  
02:32 - machines go down. They can do this as they have 
data replication built in. And lastly, what does  
02:39 - non relational entail? To understand this fully, 
we need to look at relational databases bust, the  
02:45 - relational data model and SQL were designed for 
databases that work on single machines and scale  
02:52 - vertically. We will go into this in a bit more 
detail later on. In fact, everything we just  
02:58 - mentioned is in contrast to what relational 
databases are all about, which is Atomicity,  
03:04 - Consistency, Isolation, durability, or acid for 
short. I am bringing up relational databases as  
03:11 - you understand where no SQL came from, 
we have to look at them as well as SQL.  
03:17 - SQL stands for Structured Query Language. It is 
used for relational databases. By relational I  
03:24 - mean, it's a collection of tables with rows and 
columns that stores a specific set of structured  
03:29 - data. No SQL is used for non relational and 
relational databases. Okay, so when you think  
03:36 - SQL think are the Structured Query Language for 
database management on relational databases,  
03:42 - and think rigid, and when you think no SQL? Well, 
let's have a look at the word itself. No SQL,  
03:50 - you might think okay, so it's the more flexible 
way to access data. So not using SQL destructed  
03:56 - query language. Simple, right? Well, you would 
actually be wrong. Because of the usefulness of  
04:02 - SQL. Many no SQL databases added support for SQL, 
leading to an understanding among developers that  
04:11 - no SQL actually means not only SQL. So you 
can use the Structured Query Language or you  
04:18 - can not use the Structured Query Language, 
it is up to you. So once again, to recap,  
04:23 - SQL is a structured query language, and no SQL is 
an approach to database management. Got it? Good.  
04:36 - And the book No SQL distilled a brief guide 
to the emerging world of polyglot persistence.  
04:41 - The writer explains two main reasons for using 
a no SQL database. The first is application  
04:47 - development productivity. When developing 
an app there is a significant amount of  
04:52 - time before starting anything really, that is 
spent on organizing data. By organizing I mean,  
04:57 - mapping data between in memory data structures and 
a relational database. So in other words a type of  
05:03 - database that supports SQL, as we just mentioned, 
as a non relational database manager approach,  
05:09 - no SQL can provide a data model that better fits 
the applications need an entire makes our life  
05:15 - easier in the long run. As the data model is more 
suited to the application, it makes debugging and  
05:20 - writing code easier, as well as allows for easy 
evolution. The second reason is large scale data.  
05:27 - As we know, organizations today love to capture as 
much data as possible to improve their offerings  
05:32 - as well as other things. However, capturing 
large amounts of data and processing it quickly  
05:37 - is expensive in terms of an operation. So whilst 
it is possible to do so with relational databases,  
05:44 - it is usually more economic to run large data 
and processes on lots and lots of little cheaper  
05:49 - machines or clusters that no SQL databases are 
designed to explicitly run on rather than one  
05:55 - large one. As is typical for relational databases. 
We will go into this in more detail in the next  
06:02 - section. So in conclusion, no SQL 
is a database management approach.  
06:07 - The characteristics we can expect from a no SQL 
database are that it is a non relational database,  
06:14 - as opposed to a relational one, a distributed 
database that is designed to manage large scale  
06:19 - data while maintaining a high performance, 
scalability, throughput and availability.  
06:28 - Now, when people look at no SQL and SQL, 
they might be tempted to compare the two.  
06:33 - But by now we know that we can't do this. Why 
again, this is because once again, no SQL is a  
06:40 - database management approach. And SQL is a query 
language. So two completely different things, it  
06:46 - might be better going forward to start referring 
to no SQL databases as non relational databases.  
06:53 - So let's go ahead and switch that. So we can start 
comparing them to relational databases from now  
06:59 - on. As we mentioned, relational databases use this 
structured query language, a language that became  
07:05 - prominent in the late 1970s. And no SQL means not 
only Structured Query Language, which allows you  
07:12 - to use the language or not use it to get data. No 
SQL appearance on the scene is noted as somewhere  
07:18 - around the 2000s. With SQL, the data is modeled 
as tables with fixed columns and rows. And with  
07:27 - no SQL databases, the data is not only modeled 
as tables with fixed rows and columns. Instead,  
07:34 - it can be modeled as JSON documents, graphs 
with nodes and edges, key value pairs or with  
07:40 - Y column or tabular databases, where columns 
can be dynamic from row to row within a table  
07:45 - instead of fixed. With a no SQL database, the 
schema is flexible. This means there doesn't have  
07:53 - to be any real fixed structure to the data. 
It can be stored in a flexible schema where  
07:59 - this approach can make development easier 
due to the high level of flexibility.  
08:04 - With a relational database, the schema is fixed, 
they will have rigid data types. So if you want to  
08:10 - put a Boolean into a column that has been 
defined to only take integers, the attempt  
08:15 - will get rejected. Think of it as a super strict 
approach. And whilst the strictness can be good,  
08:21 - it also comes with its downfalls and can be 
very time consuming when trying to implement  
08:26 - changes. And finally, let's look at scalability. 
No SQL usually scales out. This is also known as  
08:34 - horizontal scaling. This involves adding more 
and more machines to the resource pool. Rather  
08:40 - than adding resources by scaling vertically like 
relational databases do. So well no SQL scales out  
08:48 - SQL scales up by adding more resources I mean, 
it adds things like a more powerful CPU and  
08:54 - RAM to handle workload and improve performance 
rather than adding more machines such as service.  
09:04 - As mentioned, there are four main types of no 
SQL database systems each using a different  
09:09 - data model. Once again, they are the key value 
document why column or tabular and graph database  
09:16 - types. As mentioned we will be also taking a quick 
look at the emerging trend of the multimodal type  
09:23 - at the end to we will be going through each type 
and an explanation example exercise format. Okay,  
09:31 - so once again, the three is now the first thing 
you need to know is that databases have multiple  
09:37 - layers. The first layer is an interface or in 
other words, a visual platform where you can  
09:42 - visit and interact with data, which is where you 
find the format, the language and the transport.  
09:48 - In this course the interface we are going to 
use is called Data sex Astra database management  
09:53 - system. This is where we will be creating all of 
our database types for the example and exercise  
09:58 - parts DataStax Astra DB is an auto scaling 
Database as a Service built on Apache Cassandra  
10:05 - designed to simplify cloud native application 
development. Because it is built on Apache  
10:10 - Cassandra, you will see us using the Cassandra 
query language or CQ l a few times in this course,  
10:16 - CQ l offers a model close to SQL and it says that 
data is put in tables containing rows and columns.  
10:23 - I will be pointing this out to you when we use it. 
These languages are how we interact with the data  
10:29 - in our database. The next layer is an execution 
layer. This is where we pass the incoming queries  
10:36 - coming from my interface. It is also used as an 
analyzer and a dispatcher. And finally, we have  
10:42 - the storage layer in which the indexing of data 
happens. The reason I'm using datasets Astra is  
10:49 - that it will allow us to create all four types of 
database types for this tutorial, so I won't have  
10:54 - to sign up to separate database management systems 
for each section. However, you don't have to.  
10:59 - There are literally dozens and dozens to choose 
from, so please feel free to take your pick. We  
11:05 - can group these database management systems into 
families according to the CIP theorem. According  
11:11 - to the CP theorem, a no SQL database cannot 
achieve consistency, availability and partition  
11:17 - tolerance, it must sacrifice one of the three for 
example MongoDB and Kafka chose to focus on CP and  
11:26 - the database management system we are going to be 
using datasets Astra is not an Apache Cassandra,  
11:31 - which chose to focus on AP. So to recap, what 
we are doing here is using data sacks Astra  
11:38 - which is an interface essentially, that will 
allow us to work with our no SQL database,  
11:43 - which is in this case, Apache Cassandra, to 
be exact. Apache Cassandra is an open source,  
11:49 - no SQL distributed database. The language 
we will use to communicate with our database  
11:54 - is Cassandra query language, or SQL for short, 
which, as I mentioned, is very similar to SQL.  
12:02 - Most no SQL databases have their own 
query language or not. Once you are on the  
12:09 - data sex Astra platform, we're going to create a 
database. So I'm just going to head over and click  
12:14 - this button right here. And that will take me to 
the page in which I'm going to create our first  
12:20 - database, and the database name, I'm going to 
call it FCC underscore tutorial, I would recommend  
12:27 - calling your database exactly the same in order 
to avoid any issues further on for this tutorial.  
12:34 - Of course, once you have the knowledge 
that you gained out of this tutorial,  
12:37 - you will be able to name your databases, anything 
you wish. This is just a suggestion. However,  
12:44 - now under keyspace name, because the first 
example we're going to look at is tables,  
12:49 - I'm going to call the key space Tabular. 
Once again, I would recommend that you call  
12:54 - your key space name the same thing so that 
you don't run into any issues further on.  
13:00 - Okay, and next we can provide a region, we 
can choose Amazon Web Service, or Microsoft  
13:06 - Azure or Google Cloud, I'm just going to 
stick with this one. And I'm just going to  
13:10 - select a Europe as I am currently in Europe, and 
I'm going to create a database. And there we go,  
13:18 - we have created our first database, it has a 
database ID, the status is currently pending. So  
13:25 - we're gonna have to wait for that to turn active 
before we can go ahead and use the database.  
13:32 - And there we go, we're active. As you can see, 
here, the status has turned to active in green.  
13:38 - Great. Now that we have set up our database 
management system, let's start getting to some  
13:43 - examples. Okay, great. Now let's look at the first 
database type, which is a tabular database type,  
13:55 - also known as a column database type or a 
wide column database type. What you need to  
14:00 - know is that tables are relational and come with 
a schema, we are going to be making a table called  
14:06 - books in this next section and defining what kind 
of rows the table can take, and what kind of types  
14:11 - the rows are made of. For example, I'm going to 
have a table called books. And in it, I'm going to  
14:18 - say that we can only have a row that has a book ID 
and author a title a year release the categories  
14:25 - the books belongs to and a timestamp for when 
it was added. I'm also going to say that the  
14:30 - book ID needs to be a UU ID or a universal unique 
identifier. The author field needs to be some text  
14:37 - and the title needs to be some text to the end 
has to be an integer and the categories needs  
14:42 - to be a set of texts. And the timestamp needs 
to be a type of timestamp format and only that,  
14:48 - okay, so what I've done here is essentially define 
a schema. The next thing that is important to know  
14:55 - is that we are going to be saving this row based 
on a key. This is important As this is how we are  
15:00 - going to be retrieving our data with queries later 
on. Okay. So for example, if my UU ID for this  
15:07 - row looks like this, and I can save it, the only 
way I can find it is by searching for this key,  
15:13 - and the whole data row will be returned. This 
key is also what is known as a partition key.  
15:20 - Because our no SQL database is a distributed 
database, it means our data can be sold on  
15:25 - loads and loads of different nodes. So if two 
rows had the same partition key, they will be  
15:30 - stored together on one note, and when we query 
for that key, they will both return. Got it.  
15:37 - Good. Now let's use it in practice with an example 
in which we are going to be storing books in a  
15:43 - tabular database. So now that we have created the 
database and has access to us, let's go ahead and  
15:52 - create our first table. To do this, I'm just 
going to double click on the database itself,  
15:58 - it should take you to this page in which you 
will see the key spaces associated with this  
16:02 - database. At the moment, there is one as we only 
created one key space called Tabular. Great.  
16:10 - So now I'm going to do this part using the CPU 
or console. So as we know, tabular databases  
16:18 - organize data in rows and columns. Okay, so 
that's what we're going to be doing, we're  
16:22 - going to be building a table with rows and columns 
to store some data using C QL, or Cassandra query  
16:30 - language. The first thing I'm going to do is use 
a command in order to get our key space. So to do  
16:38 - this, I'm going to enter the following command, it 
is called describe key spaces. And if I hit that,  
16:46 - you will see all the key spaces associated with my 
database, you will also see that tabular is right  
16:54 - here. Just to make sure we are all on the same 
page, it keyspace is simply a word for a logical  
17:00 - grouping of tables. So now that we can see our 
tabular key space, let's actually get to using it,  
17:07 - I can use it using the following command, use 
Tabular. And just hit enter. Don't forget to  
17:14 - put the semicolon at the end. Okay, so now you'll 
see that I'm actually in the tabular key space,  
17:22 - I'm inside the key space, I now want to create a 
table inside the key space. And I'm going to use  
17:29 - the following SQL command to do so I'm going to 
write CREATE TABLE if not exists, okay. So that is  
17:36 - something you're going to need to create a table 
in your key space. And I'm going to call the table  
17:43 - books. Now, I'm going to actually define what goes 
into my table as well. I'm going to define what it  
17:50 - is I want to put into my table and what type it 
is. Okay. So for example, if I choose to put in a  
18:00 - book ID, and then also going to state that this 
is a unique identifier. Okay, so from now on,  
18:07 - I can only use Universally Unique Identifiers, or 
UU ID as the book ID. For those of you who don't  
18:15 - know what a UU ID is, it is a 128 bit label useful 
information in computer systems, I will show you  
18:24 - the structure of it as well as what it looks like 
when we get to using it later on. Next, I'm also  
18:30 - going to say that my table of books is going to 
have an author and the author. So whatever value  
18:36 - I have as the author is going to be text, okay, 
so a string. In other words, we're also going  
18:43 - to have a title, which is going to be texts a 
year, which is going to be an integer. Okay,  
18:49 - so a full number, we're going to have categories, 
which is a set up texts. Okay. So once again,  
18:57 - I will show you what that looks like we're going 
to have multiple categories. Or in other words,  
19:01 - it's going to be a set of texts. And I'm also 
going to have added, which is going to be a  
19:06 - timestamp I have defined added to be a time stamp. 
So timestamp is also a type in C QL. And finally,  
19:16 - we're going to have a primary key. A primary key 
in basic terms is how we're going to search for  
19:23 - a book in our table. Okay, so imagine our table 
has hundreds and hundreds of books. We can filter  
19:31 - through the table, we can search through the 
table by the book ID, thanks to this primary key  
19:37 - right here. The book ID that I've passed through 
into the primary key is also the partition  
19:44 - key that we discussed earlier in the introduction. 
Okay, so I'm putting in a partition key  
19:51 - into the primary key. Great, and we're just gonna 
close that off and don't forget the semicolon and  
19:58 - press enter. And there we go, we have now created 
our very fast, super simple table using CQ L, just  
20:09 - to make sure that has worked, I'm just going to 
use the command describe key space Tabular. So the  
20:16 - time I'm picking out the precise key space, and 
putting the semicolon and then just hitting Enter,  
20:22 - and there we go, we can see that our table 
has been created, okay with the book ID  
20:30 - added author categories set, and yeah, wonderful. 
So now that we have finished our table,  
20:37 - we have created our table, let's actually get 
to putting things into our table. To do this,  
20:44 - I'm going to use the command insert into. So 
I'm going to use Insert into that is a command  
20:51 - that we're going to use to insert data into our 
books table. So I'm just gonna write the word  
20:56 - books. And then once again, I'm just going to 
put in a book ID and author, a title a year,  
21:05 - the categories that are belongs to and added and 
just click enter. The next thing we're going to do  
21:13 - is actually add the values. So we didn't actually 
finish off this command, there's no semicolon,  
21:19 - so we did not finish off this command, we're just 
making a new line so it's more readable. And I'm  
21:24 - just going to put some values into our books. 
So I'm just going to open up the parenthesis,  
21:31 - and I'm actually going to create a 
unique identifier. So this is a function,  
21:36 - I'm going to call this so that it creates 
a universally unique identifier for me.  
21:42 - The next thing I'm going to do is write a string 
of Bobby Brown as we defined author as text. So  
21:50 - this needs to be text and needs to be a string. 
And then we're also going to give it a title,  
21:55 - which is also text, it is a string. So I'm going 
to put dealing with tables. The next is year,  
22:02 - which we defined as an integer. So I'm just 
going to put 1999, and then categories,  
22:08 - which is a set of texts. So to do this, I'm just 
going to open up some curly braces this time.  
22:14 - And I'm going to put the string of programming and 
the string of computers. This is because I defined  
22:21 - categories as a set of text. So I can only put 
text into this set. Okay. And finally, once again,  
22:30 - I'm going to call a function, the function is 
called to timestamp. And I'm going to open up  
22:35 - my parenthesis, and I'm just going to put an 
another function is called now I'm going to call  
22:41 - it, this will essentially create a timestamp 
with this very second. Okay, so timestamp of  
22:47 - this very second that I'm going to put into my 
table. I'm just gonna close all this off, and  
22:54 - finish it off with some semi colons, because I'm 
done with this command now, and just click enter.  
23:02 - Wonderful. So now let's see if that has worked. 
I'm going to use the command select all.  
23:09 - So this little asterix means all from our table 
called books. So we have chosen to call the table  
23:17 - books. So that's what I'm using the word books 
here, and then let's get our semicolon and just  
23:22 - click enter. and wonderful. Here is 
our table, we have created a table,  
23:29 - we've put some data into our table. Let's 
have a look. Here, you will see the UU ID  
23:35 - has been generated. This is the structure of 
universal, unique identifier that looks wonderful.  
23:42 - Next, we've got added. Okay, so this is the 
function that I wrote to timestamp. Now, if I use  
23:47 - the function, today's timestamp down to the second 
has been used to populate this cell right there.  
23:54 - And next we have the author of Bobby Brown, the 
categories and the title dealing with tables,  
24:02 - as well as the year which is an integer. Great. So 
we've created one row in our table, let's get to  
24:10 - adding a nother row into our table. So to do this, 
once again, I'm going to use the command insert  
24:17 - into again, I'm going to pick out the table that 
I created earlier, which I chose to call books.  
24:24 - And I'm going to say that into this row, 
I'm going to put in a book ID, an author,  
24:30 - a title a year categories and add it okay and 
then the values that I want for these cells  
24:38 - are going to be once again I'm going to use the 
UU ID function to create a universally unique  
24:45 - identifier for me. I'm also going to put a 
string of let's put Andrea Agnes as the author  
24:52 - for the title. I'm just going to put the moon as 
the title of my book, and for the year I'm going  
24:59 - to put 2001 is an integer, so not a string, 
that categories, I'm going to put space and  
25:06 - non fiction, non fiction like so. And then 
added. Once again, I'm going to use the to  
25:14 - timestamp and pass through now and 
call it. Okay, so there we have it.  
25:23 - Once again, I'm just going to close that off, 
and then use a semicolon to finish this command  
25:28 - and hit enter. Wonderful. So now if we 
look at everything in our books table,  
25:35 - so I'm just going to use the command to select 
all books, oops, we didn't use the semicolon,  
25:41 - select all books. Select all from books, apologies 
select all from books is the command we need.  
25:56 - Wonderful, we can see now that two rows 
exists on our table that we created. Great,  
26:04 - this is looking really good. As you can see, a 
new unique identifier has been generated a new  
26:11 - timestamp, the author name, some categories, 
a title, and the year as an integer. Correct.  
26:19 - Now what if I just want to 
select one thing from our table?  
26:23 - Well, as we mentioned, we know that we can 
use a primary key to the book ID to do this.  
26:30 - So let's go ahead and try do that. I'm going 
to use the command select all. So once again,  
26:36 - select and then we use the little star or Asterix 
from books. And I'm just gonna hit enter. So I'm  
26:41 - not gonna close up this command yet. And I'm 
gonna use the command where and then use book ID  
26:48 - equals. So I've chosen book ID for myself. I've 
called it book ID. And I'm just going to select a  
26:56 - unique identifier. Let's select this one. So what 
do we expect to return if we run this command?  
27:05 - Correct? That is correct. We are now getting 
one item from our table. This because we chose  
27:11 - to select an item by its unique identifier. 
Okay, so there we go. We have now successfully  
27:18 - picked out one item from our table using the 
book ID, or in other words, the primary key.  
27:26 - So we have now seen how we can pick out one item 
from a table. However, how can we filter out  
27:33 - multiple items from a table? Well, to do this, 
we're going to work with partitions. So let's make  
27:40 - a new table for this. I'm just going to refresh my 
page, you can actually also use the clear command,  
27:48 - instead of refreshing the page. If you want to 
clear all of this, it's up to you. So once again,  
27:54 - this is going to be some great repetition for 
you some great muscle memory practice. First off,  
28:00 - let's actually get to listing out all the key 
spaces using the describe key Space Command.  
28:07 - There we go, we can see the key space that 
we want the tabular key space, I'm going to  
28:12 - use the command use tabular in order to pick out 
the key space that we want. Next, let's actually  
28:18 - get to creating a table in the tabular key space. 
Okay, so we have one table already called books,  
28:25 - I'm going to create a nother table this time. 
So the command you need for this is create  
28:30 - table if not exists, and then we're going to 
choose to call our table restaurant by country.  
28:38 - Okay, so I've chosen to call my table that as 
you can choose to call your table, whatever you  
28:43 - wish. And now, in my table, well, I'm going to 
decide that I want to have the following columns,  
28:50 - I'm going to have the country which I'm going to 
define as text. Next we're going to have cuisine,  
28:56 - which I'm also going to define as text a URL, 
which again is going to be some text. And now  
29:04 - I'm going to have a primary key. So from our 
previous lesson, we know that we can search for  
29:10 - something in a table by its primary key, I'm going 
to choose to search by the country. The country  
29:18 - is actually the partition key we refer to in the 
explainer okay. So, we have a primary key command  
29:25 - and we are passing through where we want the 
partition key to be if that makes sense. So, what  
29:32 - I have done is chosen one of the table columns 
here I have chosen country to be my partition  
29:39 - key and I have passed that into the primary key 
like so. So now also what is happening is that  
29:46 - all my data from now on is going to be distributed 
in my database based on the value of country. Now,  
29:54 - the other values here that I have put so name 
and URL are What we call clustering keys. So what  
30:02 - this means is that when I search for data based on 
the partition key, so in this case, it's country,  
30:09 - I can make it come back in descending order, and 
URL in ascending order. Okay, so there we go,  
30:20 - let's go ahead and run that command, not 
forgetting the semicolon. And there we go.  
30:26 - Next is actually insert some data into this table. 
So just like before, I'm going to use the Insert  
30:32 - to command. And I'm going to insert into the table 
that I have chosen to call restaurant by country,  
30:39 - going to open up some parenthesis, and I'm going 
to say that I want to put in a country a name,  
30:46 - a cuisine, a URL, and I'm just going to close that 
off, and then start a new line with the values.  
30:55 - So open up the parenthesis again, and I'm going 
to put the string of Poland the name, I'm going  
31:01 - to put VAs ska, catch ma as a string. And then the 
cuisine, I'm also going to put some text for this,  
31:11 - I'm going to put traditional as a string, and 
then the URL once again, this is a string,  
31:18 - I'm going to put w w.kajima.pl. And close that 
off and for the semicolon, and click enter. And  
31:30 - wonderful, I'm just going to insert a another 
row while we are here. So once again, insert into  
31:37 - my table name is restaurant by country, I'm 
going to open a parenthesis to say what exactly  
31:42 - I want to put in this row, I'm going to put in 
a country and name a cuisine and a URL. And in  
31:50 - the next slide, I'm going to put the values this 
time, let's put Singapore and I'm going to put  
32:02 - the shark as a string, this is going to be 
American food as a string. And the URL is  
32:08 - going to be W W dot shack dot S, G, no, close 
that off. And wonderful. Hit enter. Great.  
32:20 - We can also do a third one. So I'm just going 
to actually press up this time, we will just  
32:25 - bring back the last line. And for the values, I'm 
just going to replace that with United Kingdom.  
32:35 - And for this one, let's put the red rose. 
And I'm going to put pub as the cuisine.  
32:48 - And as the URL. Let's just put red rose.co.uk. 
and wonderful. So now click enter. And great.  
33:01 - Let's check if that has worked. So I'm 
going to use the select command this time,  
33:06 - Select All. So the Asterix is all from restaurant 
by country, because that is the table name.  
33:16 - I want to get everything from the table. Oops, 
nice post I semicolon. And great. There is our  
33:23 - table. This is looking good. And once again, 
let's try and get in one thing from the table.  
33:30 - So select all from restaurant by countries of the 
table name where the country equals the string  
33:39 - Singapore. Okay. And that just puts in semi colons 
and hit enter. And that should return back the  
33:47 - singular restaurant. So the shark because that 
has the partition key of Singapore. Wonderful.  
33:53 - Now, what do you think happens if we add another 
row that also has the country Singapore? Well,  
34:00 - let's check it out. For this part, I'm going 
to involve you I'm going to break to an  
34:04 - exercise. So what I want you to do is actually 
add a nother line. So now the road to our table  
34:12 - that has the country Singapore, the name of 
the restaurant, the heart, the URL www.hud.sg  
34:21 - and cuisine Lebanese, okay, so go ahead and add 
one row to our existing table. But before we do  
34:30 - that, I'm going to ask you to refresh the page. So 
go ahead and click that. And wonderful. Go ahead.  
34:39 - I'm going to pause here while you have a go at 
doing this yourself before we carry on together.  
34:45 - Okay, so first things first you can of course 
is the describe key spaces command to list out  
34:52 - all the key spaces in your database. Or you 
can just go straight to it if you know which  
34:59 - key space You want to use. So I'm going to choose 
Use tabular, just like Sir, making sure that I am  
35:07 - in the tabular key space. Next, I'm going to 
essentially insert a row into the table restaurant  
35:16 - by country. So I'm going to do so like so. 
First things first, I'm going to use the Insert  
35:24 - into command. And I'm going to insert into rest. 
Durrant by country, just like so because that  
35:35 - is the name of our table, I'm going to insert 
a country, I'm also going to insert a name, I'm  
35:41 - going to insert some cuisine and a viewer L. Okay. 
So that's what I'm going to do. And I'm just going  
35:48 - to make a new line. So don't put the semicolon yet 
insert into restaurant by country. And then I'm  
35:55 - going to put in values. And the values are going 
to be a string of Singapore. And then the name we  
36:05 - said is going to be the heart. The URL is going 
to be WWE dot heart dot S, G. And the cuisine,  
36:16 - which is the one we miss, I'm just going to 
go back. It's going to be Lebanese, Lebanese.  
36:24 - Okay, so let's have a look. Make sure 
that it's all correct. Okay, great. And  
36:29 - hit Enter. So now we have a look at everything. 
So select everything from restaurant by country  
36:45 - that we go, you will see that line has been added, 
a new row has been added. So now if we do select  
36:55 - everything from restaurant, we could actually 
just press up. And then we go where, and I'm  
37:03 - going to get the partition key. So country equals 
Singapore, what do you expect will happen? Tada,  
37:16 - we get back the two restaurants that are in 
Singapore. Wonderful. So that is essentially  
37:23 - how you'd group data together in your 
table and retrieve that group data back.  
37:35 - Now it's time to move on and look at document 
database types, document or document oriented  
37:41 - database types are arguably one of the easiest 
types to do. This is because they require no  
37:46 - schema. So before in the tabular database, we had 
to define the columns that made up our table. With  
37:52 - this, we don't have to do any of that. As long 
as our data comes as an object, it's fine. The  
37:58 - objects are made up of keys and values look like 
this. So this is an example of perhaps an item  
38:04 - you might find in a to do list. So here you have 
an object which I have given an ID with a zero,  
38:11 - a title with fixed bike as a string description 
with a string and done which I have in this case,  
38:18 - given a Boolean that is not strict. The values 
can be strings, numbers, Boolean arrays,  
38:24 - or even objects themselves. This is called JSON, 
or JavaScript Object Notation, and is the most  
38:31 - popular format for document database types. Now, 
a group of documents is called a collection. So we  
38:39 - will not be using the word tables anymore. It has 
been replaced by collections. So keep that in mind  
38:45 - moving forward. So what are we waiting for? Let's 
get to it. In this next section, I'm going to  
38:51 - make a collection of to do items using a document 
API. Now for those of you who haven't heard of the  
38:58 - term API, let's do a quick crash course first. And 
API stands for Application Programming Interface.  
39:05 - They allow for technologies to essentially 
talk with each other and are essential to  
39:10 - serve the services we rely on today. They are 
behind most apps we use on a day to day basis.  
39:15 - And they can shape information paths between one 
technology to another. And they connect things  
39:21 - such as our cars, purchase pens, or anything 
really, to the internet. API's are everywhere.  
39:27 - As a developer, you might use the Twitter 
API to get like tweets on your site, a Map  
39:33 - API that will allow us to get data from a third 
party to use a new delivery app we are building  
39:38 - or even use them in a two way stream to get 
post or delete data from a customer relationship  
39:44 - management system. For example. There's a reason 
why these words are popping up. And let's go into  
39:50 - why. In this next section, you're going to be 
seeing these words I'm using them to communicate  
39:54 - with the database you make. In this context. 
They are called HTTP request message. That's  
40:01 - the most common are the get request, post 
request, PUT request and delete request.  
40:10 - There are others too. But for the sake of the 
tutorial, these are the ones you need to know.  
40:16 - Get essentially gets data. And that's all it does. 
So imagine you have a client or another word, your  
40:24 - computer and a server, you are on your computer. 
And the URL, which is where you want to get your  
40:33 - data from is on a server, the client. So once 
again, your computer sends an HTTP get request  
40:43 - to the server to retrieve the data we want. So 
here we have a get request or a visualization of  
40:52 - a get request, the client is requesting the server 
gives it the necessary resources we need. Then,  
41:02 - after the server has sent the response, so request 
and response, we say that we've got it. Thank you.  
41:12 - After the server sends a response, it closes 
something called a TCP or transmission control  
41:19 - protocol connection. We also have a POST requests 
and put requests. So here we have a visualization  
41:28 - of how the request would work with post requests. 
So simply sending something to the server.  
41:34 - And with the PUT request, which are the same, 
we are sending something to the server. But  
41:41 - essentially to edit something or override it, 
we will go into this in the next section. And  
41:47 - of course, a delete request to a delete request 
will essentially delete something that is pointed  
41:53 - to an idea or endpoint. So to get interacting with 
my data, you will see these different endpoints,  
42:04 - simply put an endpoint is where a 
resource lips. So with this endpoint here,  
42:12 - forward slash burgers, I will get all 
my burgers, I can also create a burger  
42:19 - to the same endpoint. To create a burger. However, 
I use the post haich TT method. As we discussed,  
42:29 - I can also edit a singular burger, also, as 
we discussed. And of course, we have delete,  
42:37 - which you guessed it will delete a singular 
burger if we provide the end points with the ID.  
42:45 - Okay, so hopefully, this theoretical example 
has made sense, let's get to using our knowledge  
42:51 - in our project. Okay, the first thing we're 
going to do is actually create a new key space,  
42:56 - I'm going to call this key space document, I'm 
just going to go here and save it. There we go.  
43:04 - Okay, so now we've got two key spaces, I'm going 
to keep the workload separate. So one for tabular,  
43:10 - and for document, because we're going to 
be working with document types in this  
43:13 - section. So to do this, I'm going to choose to 
connect to my database using the Document API.  
43:21 - However, before we do that, we're 
gonna have to get a token in order  
43:25 - to communicate with our database. So to 
do this, I'm just going to go to settings.  
43:32 - And then under Application tokens, 
organization settings, click that  
43:37 - the role I'm going to select as an admin user, 
and I'm going to generate a token. So this is  
43:43 - the token we are going to use, please, of course, 
do use your own, I will be deleting this after  
43:49 - this tutorial. So just go ahead and copy that and 
make sure to store it somewhere safe. Okay, great.  
43:57 - Now, once you've done that, just go back. And 
this time, we're not going to use the SQL console,  
44:02 - we're going to use this connect tab. And we're 
going to use the document API to connect to our  
44:08 - database. Okay. So all I'm going to do is launch 
swagger. And this will load some swagger Doc's for  
44:16 - us that will be useful in communicating with 
our database. Okay, so this is all pre made  
44:22 - for us. There's not much we're gonna have to do, 
we're just gonna have to fill out some blanks. The  
44:28 - first thing I'm going to do is actually create 
a new empty collection in a namespace. Okay,  
44:35 - so before, as mentioned, we work with tables. Now 
we're going to be working in collections. Okay.  
44:42 - So once again, we were working with tables before. 
Now we're going to work with collections. So I'm  
44:48 - going to create a new empty collection in the 
namespace and just click Try it out. And all I'm  
44:54 - going to do is fill out all of these empty spaces 
that have been created for us while We are here is  
45:00 - actually important to note that you can write your 
own code for these requests. So at the moment, we  
45:05 - are in a post request, I will be showing you how 
to do this in the project portion of this course,  
45:12 - for now, we're just going to make use of this 
pre configured UI to help us make these requests.  
45:18 - So all I'm going to do is actually put in my 
Cassandra token in here. So that's the one that  
45:24 - we just created. And under the namespace ID, well, 
we know that our namespace that we just created,  
45:32 - or in other word, a key space is called document. 
So that's what we put in here, document, okay,  
45:38 - not tabular document. And next, we're going to 
have to put something in the body of our requests.  
45:44 - Okay, so we're going to have to put in some 
JSON with the name of the collection. So all  
45:49 - I'm going to do is choose what I want to call my 
collection. And I'm going to choose to call it  
45:56 - my first collection, just like so. 
Okay, so you open up some curly braces,  
46:03 - this is how Jason looks, we open up some 
curly braces, we put the string of name  
46:08 - as we are prompted to, and the string of my first 
collection. Wonderful. So now we can scroll down.  
46:18 - And just click execute, and then wait 
for our response. And as you can see,  
46:25 - that has returned with a status code 201. Okay, 
status code 201. So that has worked. If you  
46:33 - don't know about service codes, that is a really 
handy website, I'm going to show you with all the  
46:38 - status codes that could return, it illustrates 
them with little dogs. And it's really easy to  
46:43 - understand, this is something that I use quite 
a lot in my day to day, developer life. Okay,  
46:50 - so we have now created a collection called 
My first collection, let's carry on,  
46:57 - just going to delete all of this, and cancel 
that. And now the next thing I want to do  
47:03 - is put something in our collection, right, so 
I'm going to create a new document to do this.  
47:09 - Once again, I'm just going to click Try it out. 
And I'm going to fill out all of these spaces.  
47:16 - So once again, it's putting the token that we 
just created. Next we need the namespace, or  
47:22 - as it's called on our platform, the key space. So 
once again, I'm going to put document and in the  
47:28 - collection ID. Well, the collection that I want to 
put this in is called My first collection, because  
47:35 - we just created and in the body in the body, I'm 
going to put in my first item into the collection.  
47:43 - And this is what I want it to look like. Okay, 
so once again, we have the curly braces about the  
47:48 - string of ID, which I'm going to give it as one, 
I'm going to give it the title of make dinner.  
47:58 - And then the description of make dinner to 
apologize for breaking my housemates bike. And  
48:07 - done is a Boolean of false. Okay, so this is the 
first document I want to put into my collection is  
48:15 - just an object that has some information, okay, 
I can make this information, whatever I wish.  
48:21 - So this is what my information looks like. 
Let's carry on. I'm just going to click Execute.  
48:30 - And there we go, we get a 201 code. And that 
has responded, we also get a response with this,  
48:36 - which is the document ID. So the document, 
we just created the one with ID one, the one  
48:42 - about making dinner has this document ID, 
this is its identifier in our collection.  
48:50 - Okay, great. Now let's get to using this ID. So 
now I'm going to show you how to do two things.  
48:57 - I'm going to show you how to search for everything 
in a collection. And I'm going to show you how to  
49:02 - search for one thing in a collection. So let's 
start off with the first one faster search for  
49:08 - everything in a collection. To do this, I'm going 
to just select search documents in a collection.  
49:14 - And once again, I'm just going to put in the 
Cassandra token. Let's click Try it out. I'm  
49:19 - also going to put in the namespace or key 
space as it's called on our platform. So I'm  
49:25 - going to put in document for the collection. 
I'm simply going to put my first collection,  
49:31 - and then I'm just going to execute it. Okay, so 
I'm just going to scroll down and hit execute. And  
49:39 - there we go. We get a status code 200. And 
we also get the response body. So that is  
49:46 - responding with all the data in our collection. 
At the moment. There's only one item Okay,  
49:51 - so it might be a bit hard to tell you might think 
it's just bringing about one item but it's in  
49:55 - fact bring back all the items in our collection. 
Great Now I'm going to show you how to pick up  
50:01 - an item based on the document ID. So the thing 
we created in the part just previous to this.  
50:07 - So to do this, I'm actually going to use the 
document ID. So let's just go ahead and grab that.  
50:15 - And then let's go to get a document. 
Once again, let's click Try it out,  
50:20 - I'm going to put any document ID, and then I'm 
just going to fill this out. So once again,  
50:24 - the collection I'm looking at, and it's called 
My first collection. And then the namespace is  
50:31 - called document and the Cassandra token, well, 
we just need to paste that in. And click Execute.  
50:43 - And correct. So we're returning that one item from 
our collection. Okay, based by its document I do.  
50:54 - Okay, so now that I've shown you how to create 
a collection, add a document to collection,  
50:59 - get all the documents back, and just search for 
one document in the collection by document ID,  
51:05 - I'm just going to show you how you would do this 
in the project part. So all we're going to do,  
51:11 - or essentially all of that is happening here on 
this platform is that we are constructing a URL.  
51:17 - Okay, so every time you fill out a field, you are 
constructing this long URL. As you can see here,  
51:24 - we've populated it with a namespace, a collection 
and a document ID. So this is exactly what we  
51:30 - will be doing in the project part, we're 
going to be making a request to this URL,  
51:34 - however, with authorization. So at the moment, 
if I just take this URL, and I paste it in the  
51:41 - browser, you will get a message that says role 
an authorized for this operation, missing token.  
51:47 - Okay, there are tools that we can use to help 
us if we do want to view this before building  
51:51 - our project, one tool that comes to mind is a 
tool called hopscotch that I use quite often.  
51:57 - And then all you would do so I'm just going to 
gravitate to hopscotch. And I'm simply just going  
52:03 - to create a new request here. So all I'm going to 
do is put in the URL that we just created, making  
52:11 - sure that the method is a get request, okay, 
because we are getting the data. And I'm simply  
52:19 - going to put the Cassandra token that we have. 
So the one that we've saved the really long one  
52:24 - in the header. So once again, I'm going to get 
that token, and first actually going to get x  
52:29 - Cassandra tokens, we can identify it, and then I'm 
going to paste my long token. Okay, once again,  
52:35 - make sure that this is a get request because we 
are getting data from the database, and Qlik.  
52:41 - Sense. Wonderful. So now we get a status code 200. 
And we also get some response, we get the response  
52:49 - body to be the document we have just created. 
Great. Before we move on, I'm just going to show  
52:56 - you how to do one more thing. And that is search 
for something by a filtered field. So what I can  
53:02 - do, I'm just going to go to search for documents 
again. And in here, I'm just going to add a where  
53:08 - string. So this to jog your memory is how we 
return all the documents back from a database,  
53:15 - I can also filter out which ones I can filter 
them out by title. So for example, I can choose  
53:21 - to filter out to this this syntax for filtering 
out, I can choose to filter out by say title.  
53:27 - And anything with the title of make dinner will 
be returned back to me. So once again, I'm just  
53:36 - going to do that that is the syntax for filtering 
out all of my documents and search for any one  
53:42 - that has the title make dinner, or any multiple 
ones that have the title made dinner, and then  
53:48 - click Execute. And anything with the title made 
dinner will be returned back to me. Okay, great.  
54:01 - Okay, so now that we have done that tiver a 
little exercise. Based on all the learning  
54:07 - that we have done so far, how would you go about 
creating a new item to put in our collection?  
54:14 - So at the moment, we have one item in our 
collection called My first collection,  
54:18 - I would like to add another. So which 
of these do you think I should go to?  
54:25 - That's right, I will need to make a post request 
to this URL, and replace namespaced ID and  
54:32 - collection ID as well as provide my authorization 
token. So let's go ahead and do it. I'm just going  
54:40 - to refresh this so we can start a new and click 
here. So once again, I'm just gonna click here  
54:47 - to try it out. Under the Cassandra token, I'm 
just going to put in my token, the namespace  
54:53 - ID or as we know the key space ID is called 
document and then the collection ID is called My  
55:04 - first collection. And now we need to create our 
document. So I'm going to create an object for  
55:12 - this, I could simply just have an ID like so let's 
give it the ID of two, and then a description.  
55:28 - And then make it clean dishes after dinner. 
And if I executed that, that would work.  
55:35 - However, I have chosen to keep all my objects the 
same, that is a personal choice. So let's go ahead  
55:42 - and add a title. I'm going to make the same title 
that I did last time, and I will show you why. So  
55:48 - there we go, title description, and then done, I'm 
going to give it the value of false, that does not  
55:57 - need to be in quotation marks, that is a Boolean 
value that I'm assigning to the property done.  
56:05 - Okay, so now if I click Execute, we get a 201 code 
with the response body that has come back with the  
56:14 - document ID for this document right here. Okay, 
so we've added one more item, I'm just going to  
56:23 - add a another item, let's make this ID 10. Let's 
give it a different title. So fixed shoes. And  
56:32 - take choose to fixed with done false. And 
once again, I'm just going to execute that.  
56:40 - So what that means is, I now have three items 
in my collection called My first collection.  
56:48 - Two of them have the title make dinner, and one 
has the title fix shoes. Now, if I wanted to bring  
56:55 - back all the documents, or the title make dinner, 
so all of them associated with making dinner,  
57:01 - how would I do this. So once again, three items 
in my collection, I only want to bring by two,  
57:09 - and that includes the ones that 
have the title make dinner.  
57:13 - That's right, I would have to make a GET request 
to this URL. So replace the namespace ID, the  
57:19 - collection ID and provide an authorization token. 
So once again, I'm just going to click to try this  
57:25 - out, I'm going to grab the Cassandra token, 
the namespace ID I want to look at is called  
57:30 - document or in other words, the keyspace name, the 
collection ID I want to look at is called My first  
57:36 - collection. And this is the syntax for 
filtering out I want to filter out by title  
57:43 - and want to make sure that that title is equal,  
57:48 - making sure to put this in quotation marks 
equal to make dinner, which is case sensitive.  
57:55 - Okay, so that's the syntax. And what do I 
expect to come back, I'm actually going to  
58:00 - set the page size, let's just make it Max 
20. So if I add more than two, for example,  
58:06 - and I only want to 20. To come back, this is how 
I do it. And then I'm just going to click Execute.  
58:12 - And there we go. So now we can see 
that two items have come back to us,  
58:18 - this one, this one, and we do not see 
the item that has the title fix shoes.  
58:26 - Great. And once again, all we have done is 
generated this URL by filling out all of the  
58:32 - above. Okay, so what I am doing is, there we go, 
we see the namespace has been replaced, you will  
58:39 - see the collection name has been replaced. And 
if we look where well, we are looking for a title  
58:46 - equal to make dinner. And we only want 
to bring back Max 20 items. Wonderful.  
58:56 - So I hope you've learned a lot in this section. 
Please do pause here, I can't stress enough how  
59:01 - much I recommend pausing here and having a play 
around with all the different requests you can  
59:06 - make. So for example, if you want to delete a 
document, or update a document to please have  
59:13 - a play around with that, and once you are 
done, I will see you in the next section.  
59:23 - In this next section, we are going to look at 
the key value databases. They are considered  
59:28 - to be the easiest database type and usually 
come looking like this. So you have a key  
59:33 - column and then you have a value column. You can 
actually have as many value columns as you wish.  
59:39 - The important thing here is that we can retrieve 
data back to us. So an entire row by the key as  
59:46 - that is the identifier in this case. Let's 
have a quick look at an example of a key  
59:51 - value database and how to make one next Okay, so 
I'm going to click here and just add key value,  
60:00 - and click save. Okay, great. So we can now see 
another key space has been added. Now, this time,  
60:09 - I'm going to use Graph QL, just as a little 
bit of something different in order to create  
60:14 - our key value table. Okay, so this time, I'm 
going to choose to connect using the Graph QL API,  
60:21 - just purely because we've already worked with 
the document API. So I'm going to click here,  
60:26 - and just launch the Graph QL playground, just like 
so. Now, the first thing we need to do when we are  
60:36 - here is to create a new table. So first off, I'm 
actually going to put in my Kasandra tokens are  
60:43 - able to communicate with my database. So I'm 
just going to grab it, just like so. And now  
60:51 - you should be able to see the documents populate 
with all the queries or mutations that we can do.  
60:57 - So as I said, I want to create a table. So 
let's go ahead and do that. This is a mutation  
61:04 - as it's under the mutations tab. And to create 
a table, just going to write create, table,  
61:12 - and EZ Pass through the following things. So 
a keyspace name, a table named partition keys,  
61:18 - and values. So the key space name, I'm just going 
to put this on a new line. Well, we know that the  
61:28 - key space name is key value, as we've just created 
it. Now the next thing we need to actually do is  
61:35 - give our table a name. So I'm going to call this 
shop inventory just like so. And the partition  
61:44 - keys. Now, if you remember from the first section, 
our partition keys is essentially the key that we  
61:51 - want to filter our table by or search for items 
in our table by and it says here that this needs  
61:57 - to be an array. So that's what we're going to do, 
we're making an array. And then what do we want  
62:03 - our partition key to be, I'm going to give it the 
name of Ki. And I'm also going to define the types  
62:12 - that it takes. So I'm just going to put type, 
like so. And I'm going to pass through basic text.  
62:22 - Great. So we have our key space name, we have 
our table name, we have our partition keys. Next,  
62:29 - let's put in the values. As you will see, these 
all have a bank after them. So they are required  
62:35 - values is not required, but we're going to need 
it for our table. So once again, I'm just going  
62:40 - to put a comma and put in values. And this needs 
to be an array. So I'm going to open up the array,  
62:48 - and I only want another one column. So at the 
moment, we've got one column, which is a key.  
62:54 - The next column I want to have is values. So 
I'm going to name this value. And once again,  
63:03 - I'm just going to give this the type of basic 
text, just like set. And if we click here,  
63:14 - wonderful, we have created our table. Great. 
So we've created our table, the next thing  
63:20 - I'm going to do is add keys and values to our 
table. So I'm just going to go ahead and delete  
63:27 - this. And instead of having a Graph QL schema, 
I'm going to have Graph QL forward slash,  
63:35 - and I'm just going to put in the key space. So 
key value, just like sir. and wonderful. So now  
63:45 - we're in the key space key value, I'm going to 
use another mutation to see who the mutations and  
63:53 - queries have changed because I can do a bunch 
of other stuff. I'm going to use the Insert  
64:03 - shop inventory. Okay, so that is what I'm going 
to do and start mutation as this is a mutation.  
64:10 - And I'm just going to say shop,  
64:14 - insert shop inventory, just like so. And I'm 
going to use this to insert items into my table.  
64:23 - So I need to open up some parenthesis, and then 
in here, well, I want to pass through a value.  
64:32 - And that's going to have my key. So what 
key can we give this I'm just going to put  
64:36 - an A string as we said it needs to be text. 
And I'm just going to choose to give it this  
64:42 - key. So this identifier just like so. And then the 
value of let's have beans. So what I'm saying with  
64:50 - this code is that I want to put in this row into 
my table that I have just created and the row will  
64:57 - have the key of this The value of beans, meaning 
that if I want to search for beans in my table,  
65:05 - I would use this identifier. Okay, 
so I'm just going to also have to  
65:12 - return something. So we know this works. 
So I'm just going to return the key and the  
65:20 - value. Click here. Wonderful. So now we know 
that we have inserted this one item into our  
65:28 - shop inventory into our table that we have called 
shop inventory. Let's just add another item. So  
65:34 - I'm just going to make this random once again. 
And then another item we can put in his shell.  
65:40 - And just click Yeah. Great. So now I'm going 
to actually retrieve this data. But first off,  
65:47 - I just want to show you what this looks like if we 
use the sequel console. Okay, so I'm going to go  
65:52 - back here. And under the secure console, well, I 
am just going to write, use key value, because we  
66:01 - need to get the key space. And once we are here, 
I'm going to use the command describe table.  
66:11 - Shop inventory. Okay, so we can see here, we have 
added that table, that table exists and exists  
66:21 - in the keyspace key value. And now if I 
want to grab everything from the table,  
66:26 - well, hopefully you remember this from the first 
lesson, select all this essentially means all  
66:33 - from shop inventory, making sure that I spelt it 
correctly inventory. And there we go. We have a  
66:44 - table that has a key and a value. And we can find 
any item in our table. So any row by the partition  
66:52 - key or the key right here. Great. Okay. So 
hopefully, you can see how we can make tables  
67:00 - using the key and value approach. Just while 
we're here, I'm going to show you how to retrieve  
67:06 - all the data from our table using Graph QL as 
well, just in case you are not familiar with  
67:12 - Graph QL. This time, I'm going to have to have a 
query. So I'm going to write a query just like so.  
67:17 - And I'm going to look in the shop inventory. 
Okay, so I'm looking in the shop inventory. And  
67:25 - what do I want to return? Well, if I just 
want everything, then I would simply put  
67:32 - values, key value, and click enter. And there we 
go. We are getting all the items from our shop  
67:44 - inventory table. Okay, so if you want to use this 
in the project, and you want to get all the items  
67:50 - from your shop inventory, this is the 
query that you would use. Wonderful.  
67:57 - Okay, before we move on, I'm just going to do a 
little exercise to see if you've remembered what  
68:02 - we've learned. So I'm just going to get rid of 
this. If I want to add one more item into the shop  
68:09 - inventory. How would I do this? And what two 
things do I need to check? Well, first off,  
68:15 - we need to check the we're in the correct URL. 
Okay, so we need to make sure that the URL is  
68:22 - pointing to the key space. In this case, its key 
value, because that is what I call my key space.  
68:28 - And that I also have my Cassandra token in the 
header. Okay, so those are the two things you  
68:34 - need to check. And once you have checked that 
we can write a mutation, okay, not a query,  
68:40 - a query essentially retrieves back data. And a 
mutation adds data deletes data, or edits data.  
68:48 - So for this, because we are adding a new item 
into our shop inventory, I need to write a  
68:54 - mutation. And that mutation is insert shop 
inventory, because I'm inserting into the  
69:00 - table called shop inventory. Okay. And what do we 
need to put in here? Well, we need the values of  
69:10 - key and value. And what are we going to have the 
key well, at once again, I'm just gonna put in a  
69:18 - random string like that as an identifier. 
And the value this time I'm going to put,  
69:23 - I don't know, Coca Cola. Okay, great. And just 
to check this as work, I'm going to return the  
69:31 - values of key and value. I could technically just 
return one, it is up to you, and just click here.  
69:41 - So now because that has returned, we know that has 
worked. Brilliant. Now, how do you think and this  
69:49 - is something we haven't covered? So this is going 
to require you to have a little bit of a think  
69:54 - based on what I've told you. How do you think 
we would delete an item from the shop in entry.  
70:01 - Well, that's right. Because we are changing the 
data, we're going to have to find a mutation  
70:07 - that will delete from our shop inventory. And 
because we find stuff by the partition key,  
70:12 - so this, we are probably going to have to delete 
an item by searching for this key right here. So  
70:19 - let's check it out. So I know this is going to 
be a mutation. And I can also look in the docs  
70:25 - to find the Delete shop inventory mutation to 
help me out. So that is a mutation that I need  
70:34 - delete shop inventory, and I'm just 
gonna pass through the values of  
70:50 - key, I'm just gonna grab this one right here, 
I'm just going to return the value of key.  
71:00 - Okay, and that should have worked. Let's go have a 
look here. And once again, I'm just going to chop  
71:07 - list out everything in my shop inventory. And 
amazing. So we added the Coca Cola, and then we  
71:13 - deleted the Coca Cola to great. Now, if I was 
to say try delete something by the value, so  
71:22 - let's go ahead and put sham and then just return 
the value, we will get an error. This is because  
71:32 - we cannot delete by the value we have to delete 
or the primary key, which we set to be the key.  
71:40 - Okay, wonderful. So I hope you've learned a lot 
in this section. And I'll see you in the next one.  
71:53 - In this next section, we are going to look at 
Graph databases. Graph databases are a great  
71:58 - way to store data that has relationships between 
other pieces of data, or in other words, notes.  
72:04 - Each node is connected by an edge to represent 
this relationship. Think for example, your friends  
72:10 - on social media, he was you and here are three of 
your friends. So you and your friends are nerds.  
72:15 - And the connection you have is represented by this 
line, or as we are going to call it from now on an  
72:21 - edge. Easy, right? But wait, your friends can also 
be friends with each other. So how do we represent  
72:27 - that? Well, by adding more edges to represent 
the relationships, and as your friendship circle  
72:33 - expands, the more complex it can get. So that is 
the simple idea behind how graph databases work.  
72:40 - Let's see it in action. In this section, we 
will be doing an overview of an already existing  
72:46 - demographic database. The GitHub repository 
for following along will be given to you in the  
72:51 - description below. So once it gets to that, please 
go ahead and find it below. Okay, so this time,  
72:59 - we are not going to be using the datasets Astra 
interface, we're going to be using the data stacks  
73:04 - enterprise graph. Okay, so let's go to it. For 
this part, you're going to have to have Docker  
73:11 - installed. So please go ahead and download 
Docker if you don't have it already installed  
73:17 - onto your machines. Okay, so once you have it 
installed, it should look something like this.  
73:24 - All you need to do when you're here is just 
click the settings and make sure that the  
73:30 - CPU and the memory, the swap and the disk 
image size are all around about these levels.  
73:38 - Okay, so that is what you need to 
do. Make sure that you have at least  
73:43 - two CPUs. So here you see eight, 
and at least three gigabytes or RAM.  
73:50 - So these are the settings you need. Once you have 
them. Let's carry on. And once you have that done,  
73:56 - I'm just going to ask you to get up your 
terminal. And then in whatever directory you wish,  
74:01 - please write the following command. So please 
go ahead and write the command Docker network,  
74:12 - create a graph and click enter. So what you 
should have is this long ID right here. Okay, so  
74:22 - once you have that we are now ready to carry 
on. This is your identifier for the graph.  
74:30 - The next thing I'm going to ask you 
to do is clone this directory. So  
74:35 - this is directory I will be putting at the 
bottom in the description. So just clone  
74:40 - the data stacks tabs workshop 
introduction to no SQL and click enter.  
74:49 - Now I already have that in here. So I'm just going 
to go into the directory, CD workshop introduction  
74:56 - to no SQL and once we are in here We are free to 
start the container. So what I'm going to do is  
75:06 - Docker compose up D, and then wait for that to 
open up empty localhost 9091. So this will take a  
75:23 - while please feel free to pause here have a break. 
Let's get back to it once all of this is complete.  
75:34 - Okay, great. And now let's go ahead and 
visit localhost 9091. Okay, so this is an  
75:42 - example from data size itself, please feel 
free to use it and adapt it as you wish.  
75:51 - And there we go. So this is what you should 
see here is the example that is given  
75:56 - to us from data stocks. Let's go ahead and first 
check our connections. So I'm just going to click  
76:02 - here and on connections, it's going to click 
on this one right here. And just make sure  
76:07 - that this is on DSC. Okay, so this 
essentially is pointing to our local  
76:14 - Cassandra. So once that is done, let's test it 
out. And great, so we are connected successfully.  
76:24 - Let's carry on. Now, let's go back to here 
and just click on this example one, like so.  
76:34 - Now, you will see that you're prompted to create 
a graph. So let's go ahead and create our first  
76:38 - graph. I'm just going to keep it as to do tutorial 
graph like so. So just leaving all the default  
76:44 - settings. Okay, and I'm just going to click 
Create. Wonderful, our first graph is now created.  
76:53 - Now if you move down here, you will see a language 
called Gremlin. Okay, this is the language that  
76:59 - we are going to use for this tutorial, it is 
essentially another query language. Okay, so  
77:04 - we've looked at SQL, we've looked at C QL. And now 
we have Gremlin it is a graph traversal language,  
77:12 - okay, and it has been developed by Apache 
TinkerPop of the Apache Software Foundation.  
77:17 - With this language, we are essentially creating 
schema, okay, so just like we have been doing,  
77:23 - you will see here that we are adding a schema 
called God. And we are giving a partition key.  
77:28 - In this case, it's going to be the name, which is 
some text, and it also has a property, which is  
77:34 - age, which is an integer, and we are creating it, 
we are also creating a demigod which has the same  
77:41 - partition, a human again, which has a partition 
key of name, a monster, a location and a Titan.  
77:48 - Okay, so here we have the code in order for us to 
essentially create our first graph, all about gods  
77:56 - and demigods and monsters. So I'm just going to 
click here to run this. So run this in real time.  
78:06 - And wonderful, that has been a success. So, 
now, if we look down to here, you will see  
78:13 - some more code again in the language Gremlin. 
So just like we created labels here of God,  
78:20 - demigod human monster, we have now also included 
edges. So these edges are essentially how each  
78:27 - one is going to be related. So this edge is called 
Father. So this is going to show us a relationship  
78:33 - of father and son or daughter. And then 
also we have mother and brother, too.  
78:39 - And it will also give us the direction. So a god 
is essentially the father of a demigod, but also  
78:46 - can be the father of a god if someone is a Titan. 
Okay, so that is how that looks. Let's carry on.  
78:57 - If we move down, we can see more edge labels. 
Okay, so we can also write a relationship  
79:02 - of who's battled who, as well as father and 
brother, we can also do where someone lives,  
79:06 - or if someone's a pet, and so on. And finally, 
we can actually add items to our graph.  
79:13 - So this is how you would add some items into a 
graph. So for example, here we are adding Saturn,  
79:19 - we are saying this is a Titan, we are giving it 
the property name of Saturn and we are giving an  
79:24 - age of 10,000 and so on. And we do this 
for all these other items as well. Okay.  
79:32 - So there we go, we are defining the items and we 
are defining the relationships between the items,  
79:38 - or in other words, the edges between the nodes. 
And finally, we can have a table of what this  
79:44 - looks like as well. So here we can see this in 
table format. But what is more interesting is  
79:49 - the graph view. So this is essentially what our 
information looks like once it has been graphed  
79:55 - out with nodes and edges. So the edges symbolize 
the relationship. So if you have a deeper look at  
80:03 - this, we can actually click on these, and it will 
give us more information. So for example, this  
80:08 - is a monster of Hydra, you will see the name it 
has as Hydra, you also see as the labor monster,  
80:14 - and by its node, you will see that it's battled 
the monster service. Okay, so there we go. This  
80:21 - is a great example of how graphs can really 
illustrate information and an amazing way.  
80:29 - Now, this has been a lot shorter than the other 
tutorials. This is because I just wanted to  
80:33 - show you how you can work with graph databases, 
it will involve learning the Gremlin language,  
80:39 - but I think this is a good place to start in order 
to get your head around it. So I'm going to leave  
80:44 - this information to you, I'm going to put the 
link in the description. And please do have a  
80:49 - go at getting this up yourselves and having a 
play around with it as well. So if we want to  
80:54 - add one more thing into our database, we can do 
it right here. And just don't forget to run it.  
81:05 - So now because there isn't much of an exercise 
here, I'm just going to give you a pop  
81:10 - quiz. When working with graphs, what 
would these be called. So these right  
81:15 - here that I'm putting out this little red 
guy right here, these monsters, and this god.  
81:24 - These will be called nodes. And what connects 
the nodes? That's right edges. So once again,  
81:33 - these are the edges. And if we actually 
gravitate over them in this UI, it will  
81:37 - give us the relationship between each note. Okay, 
so as we can see here, we have a little house,  
81:47 - the location is the sky. And then this is where 
Jupiter lives because he loves the fresh breezes.  
81:56 - Wonderful. Okay, so I think we are done 
with looking at graphs to power this down,  
82:03 - I'm just going to run a command, it's going to be 
Docker compose down, and just hit enter. Great. So  
82:14 - that is all four of the database types. I think 
we're now ready to move on with some projects.  
82:24 - Now that we have covered the four main database 
types, I want to quickly talk to you about the  
82:29 - multi bottle type. In this course, let's 
actually recap what we've done. Well,  
82:34 - we created a database right and in it, we stored 
the key value pairs as for the first tutorial,  
82:39 - after that we stored Jason document in 
Astra DB as per the document type tutorial.  
82:44 - We then store data in tables as per the tabular 
tutorial, section two. And finally, we stored  
82:49 - graph data. So that's a variety of different data 
models, all stored in one place by the graph one.  
82:56 - All of this is possible because Astra DB 
is actually a multi model, no SQL database,  
83:01 - you can use the same database to store 
a variety of data models. What is cool  
83:06 - about this is that you also only need to learn 
and maintain one database which makes your job  
83:11 - easier. Learn one database and use 
it to solve many different problems.  
83:19 - Okay, wonderful. Now, hopefully through the 
explanations, examples, and exercises you are  
83:24 - now feeling a lot more confident is not only 
understanding the different types of no SQL  
83:28 - database types, but also how to use them. If 
not, don't worry, I have two short term real  
83:34 - life projects that we're going to build in order 
to show you how you would interact with your  
83:38 - databases when building JavaScript projects. 
By using a data API gateway like Stargate IO,  
83:44 - Cassandra and Astra D view, developers can opt to 
use a Graph QL rest or schemaless JSON document  
83:51 - API as an alternative to C QL. Let's do it. 
Okay, and let's get to it. In this project,  
84:05 - I'm gonna be showing you how to use the document 
type as well as the document API. In order to  
84:11 - create up first project. This project is going 
to be a app which will show you all your favorite  
84:18 - burger restaurants. Okay, so let's get to it. I've 
actually started with a fresh board. So you will  
84:24 - notice there are no key spaces, and we're going 
to have to go ahead and create our database again.  
84:30 - So I'm just going to go here, and let's call our 
database project work and our keyspace Bogguss.  
84:43 - And then once again, I'm just going to have to 
create the area that I'm in and create a database.  
84:53 - Wonderful. So you will see my database is 
being created and you will see the status is  
84:59 - pending and I'm just going to wait for that to be 
active so that I can go ahead and start using it.  
85:07 - And wonderful, the status is now active, let's 
go ahead and use our database. So to do this,  
85:12 - I'm just going to double click in here, and 
you will see the key space name of bagus. Now,  
85:18 - let's get to adding some data. I'm going to 
do this thanks to the document API as stated.  
85:23 - So first off, we need to create a token. So I'm 
just going to click in here. And the role I'm  
85:31 - going to choose is admin user. And I'm just going 
to create a token. Once again, please make sure to  
85:38 - keep this token safe, I would strongly recommend 
saving it somewhere useful. Okay. So once we have  
85:45 - that, let's go back to this documentation right 
here. Let's go ahead and launch the Swagger UI.  
85:52 - So I'm just going to go ahead and click that. 
And these should populate in front of you.  
85:58 - So we have a lot of options here. And a lot of 
endpoints. If you remember from the tutorial, the  
86:04 - one I need first is this one right? Here, we need 
to create a collection in order to store our data.  
86:13 - So I'm just going to go ahead and click that and 
click Try it out. Once again, I'm just going to  
86:19 - paste the Cassandra token in here so that we can 
essentially communicate with the database. And  
86:25 - then let's go ahead and choose the namespace. Or 
in other words, the key space, we want to create  
86:31 - our collection in as we have just created it, this 
is fresh in my mind. And I know that the keyspace  
86:38 - name is bogus. Wonderful. And in here, we just 
have to pass through an object that has the name.  
86:49 - And then whatever we want to call our collection. 
So I'm going to call this burger info.  
86:58 - Just like so. And I'm just gonna click Execute.  
87:08 - And great, we get a 201 code, we've made a request 
to this URL with our new authorization token. And  
87:18 - the status code we got back was 201. Or in other 
words, let's have a look at the status docs again.  
87:26 - Or in other words, to have one for created. 
Great. So now that we have created our collection,  
87:34 - what's the next thing we need to do, the next 
thing we need to do is add some documents into  
87:41 - the collection. So I'm going to go ahead 
and do it by selecting this one right here.  
87:46 - It is a post request to this URL. So once 
again, I'm going to choose to try it out.  
87:54 - I'm going to paste in my Cassandra token, the 
namespace or the key space ID that we want to  
87:59 - communicate with is called burgers. The collection 
ID we just created is called burger info.  
88:09 - And then the body is essentially the document 
that we want to put into our burger info. So  
88:15 - I'm going to choose my document to look like 
this. I'm going to give each restaurant a name.  
88:24 - So for example, Bob's Burgers. 
So that is a string I've chosen  
88:32 - to give it the string of Bob's Burgers. 
I'm also going to give it a description  
88:45 - and I'm going to say tasty burgers  
88:53 - from a fictional character from TV, so we've got 
the name, we've got description, we can also have  
89:06 - ingredients and we can do this if we wish as an 
array. So in here I'm going to put a patty to beef  
89:17 - patty. I'm also going to put tomato  
89:28 - let's also put some cucumber, some lettuce  
89:37 - and some cheese. Okay, so those are my 
ingredients. I don't only have to put  
89:46 - strings in here. I can also put an array 
of strings if I wish. Okay. And one last  
89:54 - thing that I want to show you is okay, we 
can also have Boolean I can have visited,  
90:01 - and I can have true. And then I can also visited 
have objects within objects. So if I put location,  
90:12 - like so, as a property, I can have an object 
as a value. So that is also an option. Let's  
90:21 - go ahead and do that, I'm just going to open up 
my objects. And in here, I can have so location,  
90:31 - address. And then have that to be us 
string if I wish. So 45, lambda lambda.  
90:46 - Drive, I can also have a, let's do zip code, which 
is an integer. So I'm going to make this up. And  
90:56 - then I can also have the web address. So this is 
just going to be WW do W dot Bob's burgers.com.  
91:08 - Okay, just like that. So we have a string here, 
we have a string here we have an array of strings,  
91:17 - we have a Boolean, we also have an object, 
which has an address, a zip code as an integer,  
91:26 - and a web address as a string. Now let's have a 
look and see if this is working. We could also  
91:33 - give it a unique ID, we don't want it to 
count from zero. So perhaps let's go ahead  
91:37 - and do that. I'm just going to go ahead and 
maybe let's start from 340. Why not? Okay,  
91:47 - so now let's execute this. And great. Our 
first document has been created. And we also  
91:56 - get a document ID that has been assigned to this 
object right here. So we have one, let's go ahead  
92:05 - and add another. So I can just do so from here. 
Let's go ID 341. This time, let's go Matilda's.  
92:19 - And Matthews, man hot turn Burger 
Joint. And then let's change this  
92:31 - up. They have a tofu patty. Tomatoes, 
let's have a pickle. So pickles.  
92:43 - Let's also have some letters. And then we can 
have Bri visited I'm going to put as false. And  
92:52 - the location let's change this up. So I'm just 
going to put in a random location. Let's put  
92:59 - Denver Avenue SIC code once again, I'm just going 
to make this up. And then let's put and progress  
93:13 - and just click Execute. Great. So we have two 
documents in our Bulga info collection. Let's  
93:23 - just add two more. So I'm just going to change 
the ID again. And then let's have gertrudes place  
93:42 - hipster and gout in the city as the description 
and I'm going to have a beef patty. Let's have  
93:54 - perhaps something else here so called Slow 
pickles, lettuce and there's cheeseless cheddar.  
94:05 - This is it I'm going to have as truth and the 
location. Let's have one or three darling turn.  
94:15 - Drive. Once again, just make up the zip 
code. Go through its place.com and just click  
94:28 - Execute. Let's go ahead and just add one more. So 
there we go. And then let's have fancy burgers.  
94:44 - A new location for Burger snobs. Some 
beef patty? Let's also have a onion  
94:56 - ring in this one. Some pickles some 
letters. And let's just have some generic  
95:02 - cheese visited, I'm going to put 
out false location, I'm going to put  
95:09 - one, Walter Street. Make this up. And have 
and see progress.com and click Execute.  
95:32 - Great. So now we have four bugs in here. 
But let's just double check this has worked.  
95:39 - So to get all of our burgers back, I'm going to 
search documents in a collection. So I'm just  
95:46 - going to go here, this will be a get request, as 
I'm getting the data, I'm just going to paste in  
95:51 - my token right here, I'm going to look in burgers. 
That is the I quote my keyspace. The collection ID  
95:59 - is called burger info. And then I'm going to say 
that, I'm going to have a max of 20, come back,  
96:07 - and I'm just going to click Execute. And there we 
go, we can see all four of our Bogguss coming back  
96:17 - to us. Great. So that is exactly the data that we 
need. Now let's get to using this in a project.  
96:27 - So essentially, what I want to do is build 
a project in which I'm going to be making a  
96:31 - request to this URL right here and passing through 
my authorization token. So let's do it. I'm just  
96:40 - going to go ahead and open up WebStorm. 
So I'm going to go my WebStorm project.  
96:47 - And I'm going to say this is a React 
project. So let's call this Barger  
96:53 - app, just like so I'm going to use the Create 
react app command in order to build out  
97:00 - a React project for me all configured so we 
can go. So I'm just going to click Create.  
97:15 - And as you can see, that command has sprung into 
action. And I'm essentially just downloading all  
97:21 - the dependencies, fetching all the dependencies 
and packages that I need in order to get the  
97:26 - boilerplate for my react projects. Of course, 
if you're not using WebStorm, please go ahead  
97:33 - and get to this point as well. All you need 
to do is create a project it will directory  
97:39 - using the command MPX create react up. Correct. 
So now that we have that, let's get to it.  
97:49 - So as you can see here, the MPX create react 
app has essentially populated all this for me  
97:55 - with the following packages and ran these 
following scripts. Okay, so these are the  
98:01 - dependencies that have been installed. And 
these are the files have come with create  
98:07 - react app. So if I actually run this, I'm just 
going to go ahead and click npm start, like so  
98:22 - this is essentially what should show up on 
localhost 3000. Okay. So that is something  
98:27 - that you should be seeing right now, if I go 
ahead and actually delete all these files,  
98:33 - so I'm actually going to go ahead and just do some 
deleting. So here is our app. This is essentially  
98:38 - the spinner that we saw. So you will see here the 
spinner is this right here. I'm going to go ahead  
98:47 - and delete all of this like so. If I actually just 
go Hello, I'm going to show you how this looks.  
98:54 - Okay, as you can see that is working. So 
that is updating. So I'm just going to  
98:59 - delete this for now, I don't need a logo, 
so I'm actually going to get rid of that.  
99:04 - I don't like to semicolon. So I'm just 
going to delete that. And I like to use  
99:08 - functional expressions. So I'm just changing this 
as this is my preference, but you are free to keep  
99:14 - it as as you wish. So there we go. We don't need 
the logo. So I'm just going to go ahead and delete  
99:21 - that from this project. Don't need the report by 
tools. So I'm going to delete that. Delete anyway,  
99:31 - let's delete the tests as well as we're not 
going to be writing tests for this project.  
99:39 - And let's delete this test file. Okay, great. I 
don't also need I'm actually going to delete the  
99:49 - CSS file as I'm going to be doing all my CSS in 
this index. CSS file. So I'm going to delete this  
99:55 - I'm just going to put all my styling in one file 
for this Project. So there we go, there's our  
100:02 - app js file. And if we look in here, we don't need 
this as we've just deleted it. We don't need this  
100:09 - as that is now non existent. And once again, 
I'm just going to get rid of the semicolons.  
100:15 - Like, so. Okay, wonderful. Let's just check, 
we didn't break anything. And this is looking  
100:23 - good. It's good, my console locked up, too. Okay, 
so now that we have a blank slate, let's get to  
100:34 - actually getting our data. So to do this, I'm 
going to have to create a little mini backend.  
100:40 - So just in the root of my project, so on the 
same level as Git ignore, I'm going to create a  
100:46 - new file, just a new file like this, and I'm going 
to call it index j, s. Okay. So there we go. This  
100:54 - is essentially going to be my mini backhand in 
which I'm going to build a backend using Express.  
101:02 - So first things, first, let's decide 
what port we want our backend to run on,  
101:07 - I'm going to say that I want my port to run on 
80,000 8000. Sorry. And we're going to have to  
101:14 - install a few dependencies for this, one of them 
will be Express. So we're going to use Express for  
101:20 - this project. And use require Express. So I'm 
just going to get up my terminal and install  
101:27 - Express like so I'm also going to need 
cause Morgane node fetch so we can do  
101:34 - fetching in the backend, and dot EMV for 
storing secret variables. Okay, so please  
101:41 - go ahead and just install these dependencies, 
and I'll talk you through them as we use them.  
101:49 - Okay, so I'm just going to leave that 
to install. And let's go ahead and just  
101:54 - actually use them in the backend of the project. 
So require package cause. And then const. Morgan  
102:04 - equals require Morgan, Morgan is actually a 
package that we're going to use in order to,  
102:12 - I'm going to show you what it looks like. So 
I'm just going to go, Morgan is essentially  
102:17 - going to help us debug the backend better and 
make everything a little bit more readable.  
102:21 - So this is the package, if you want to have more 
of a look. It's essentially a little logger, that  
102:27 - will give us more information when we use it. And 
once we do use it in our project. So once we do  
102:34 - essentially do this, so we're using the package or 
storing it as Morgan we've done the same, we then  
102:42 - need to pass tiny into Morgan. Okay. So this is 
essentially what is going to let us debug better.  
102:52 - So as you can see, I've got the package, and 
I'm storing it under the constant Morgan. And  
102:56 - I'm just going to use Morgan and pass through 
tiny so we can use the logger better. Great.  
103:09 - So we've got Morgan, the next thing I 
need is a package called node fetch.  
103:13 - And this essentially works sort of similar 
to the Fetch API, and will allow me to make  
103:19 - fetch requests on the so just like 
that, that's how I'm going to use Fetch.  
103:27 - Just to be sure that everyone is using the 
same packages, please be sure to be using  
103:32 - these packages that I have right here, there could 
have been updates. So to prevent any issues, just  
103:38 - make sure that these other ones you are using, or 
if you're in doubt, please feel free to check out  
103:43 - my GitHub project that I will share with you in 
the description of this video below. And finally,  
103:50 - we also need the.in v to.in. The package will 
allow us to read secrets from the back as well.  
103:59 - And this is how you would initiate it. Okay. So 
all I'm doing is actually getting this from the  
104:05 - documentation. I'm doing this from memory as I've 
used these so many times. But if we search here  
104:17 - here we go. As you will see, all I'm doing is 
taking this and using it in my project in order  
104:27 - to use the.nv package. Whoops, please spell that 
correctly dot CSV. Okay, great. So this is looking  
104:40 - good. Now let's initialize Express. So the package 
that I have just imported and stored as Express,  
104:47 - I'm now going to initialize like so. So now if I 
use up like this, I can use Morgan tiny in my back  
105:08 - I can also use course, this will essentially 
stop me from having any cause issues,  
105:15 - I will show you what I mean by this when we 
get to building our app a little bit further.  
105:20 - And then I can also use Express, Jason. Okay. And 
this will essentially allow me to read the Jason  
105:30 - in a way that I can use it in the backend. Once 
again, I will show you what happens when I don't  
105:36 - use this. Okay, so just make 
sure to have all of these,  
105:41 - like so and all this boilerplate done, so we can 
start coding. Okay, so please pause here, make a  
105:49 - note of this, I'll make it a little bit bigger, so 
you can see everything a little bit clearer. Once  
105:54 - again, things to remember are, please do make sure 
index js files in the root of your project. Okay,  
106:00 - so on the same level as package, Jason, and then 
this is the boilerplate setup that you need in  
106:06 - order to get going with our backend. So the first 
thing I'm going to do is get all the restaurant  
106:18 - data. Okay, that's the first thing 
you can do. And I'm going to show you  
106:22 - how. So to do this, and once again, you can 
use app like so. So app is essentially what we  
106:31 - saved express as initialized expressed as, and 
now I'm not going to use use, I'm going to use  
106:38 - get. And what I'm going to pass through into here 
is an endpoint that I'm going to choose. Okay,  
106:44 - I'm going to choose this by myself. I want 
to say that if I visit localhost 8000, which  
106:54 - is going to open this up in a new tab, if I 
visit localhost 8000, forward slash burgers,  
107:02 - I essentially want the burger data to show up. 
Okay, so that's what I'm writing here. By putting  
107:09 - forward slash burgers, I'm deciding that this is 
where I want my data to populate. Okay, great.  
107:17 - So that is the first thing I'm going to 
do. Before we get going actually, let's  
107:25 - listen out to see if the server's working. So 
this I would do it once again, if you use up  
107:29 - this, I'm going to use listen. So not to 
use and not get, I'm going to use listen,  
107:34 - I'm going to listen out to port 8000. And  
107:43 - it's all working, I'm just going to 
console log out. Server is running on  
107:52 - port, and then whatever the port number is. 
Okay, so this is looking good. Let's also  
107:59 - write a script for this because we don't have 
at the moment. So I'm just going to go in here  
108:06 - and start front end. So I'm 
going to keep that script,  
108:11 - but I'm going to say stop front end needs 
to be written in order to start our app. So  
108:16 - our front end, and I'm going to add a new 
script. So this time, if I start backend,  
108:23 - like so then I just want to run the backend. 
So that's the command to do so. Okay, great.  
108:37 - So let's go ahead, and I'm 
going to stop this from running.  
108:48 - I'm going to change the script to start front 
end and run it. Okay, so the front end should  
108:55 - have started. And now I'm going to open up a new 
tab. Okay, there we go. So that's just running.  
109:00 - Let's go back to our project. And now I'm going 
to open up a new tab. So new tab in our terminal.  
109:08 - And this time, I'm just going to run this command 
that I have written. So NPM. Run, start back end.  
109:22 - Okay, great. And I'm just going to comment this 
out for now. comment this out for now because  
109:27 - we are not using it. And there we go. Okay, 
server is running on port 8000. So this is  
109:36 - looking good. Obviously, at the moment, we don't 
have anything coming back. So I'm just going to  
109:44 - continue with this. So if we visit this 
endpoint, what do we want to do? Well, we  
109:52 - want to fetch the data. So for this, I am actually 
just going to don't have a request or a response.  
110:05 - Let's just have it in here for now. And 
we might change that later. And then  
110:15 - Okay, actually, let's just get rid of 
it. So we'll just have a function a  
110:20 - callback to be precise with passing through 
a callback. And then we need to essentially  
110:28 - fetch data from the URL. So if I just save this 
as URL for now and make this a little bit smaller,  
110:36 - we essentially want to fetch data from this 
URL right here. So I'm just going to copy that,  
110:42 - I'm going to paste it as a string, like so. 
Okay, so that's all I have done for now.  
110:50 - Okay, we will be tightening this up. But this 
essentially is what this looks like at the moment.  
110:56 - So there's a URL, now I need to make a get this 
is a get request. So let's go ahead and do that.  
111:11 - So now it's time to use Fetch. So fetch 
takes a URL, okay, which is essentially this.  
111:22 - And we're also going to have to 
pass through our Cassandra token Ks,  
111:26 - or our authorization token. So I'm going to do 
this along with options. So let's define our  
111:32 - options. So const options like so. And in here, 
we know that the method is a get method, okay.  
111:40 - And we also need to pass through some headers. 
So the headers that we need to pass through,  
111:47 - we need to accept this like so as a string. And we 
also need to pass through the X Cassandra token.  
112:00 - Okay, so we need to pass through essentially 
this, just like we are passing it through. Okay,  
112:05 - you will see this is part of the header. 
Okay. So essentially what is happening  
112:10 - behind the scenes here, we are now coding out. 
So I'm just going to once again as a string  
112:15 - posts, my token. Okay. So now when we make 
a fetch, let's just uncomment this out. Now,  
112:23 - when I fetch I am passing through this year, 
well, we are fetching data from this URL,  
112:28 - it is a get request. And we are using this in 
order to pass through our Cassandra token. Okay,  
112:36 - great. So we are making a fetch, and 
this is going to return a promise.  
112:45 - So I then need to chain it with 
the then keyword. And the response  
112:53 - is going to be the response. Jason. And this 
is also actually going to return a promise.  
112:59 - So we need to chain it again. And this 
time, I just want to get the Jason  
113:11 - Okay, so great. Now we do actually need 
to pass through a request and response.  
113:19 - So let's just do that now. Okay, 
so whatever's coming back to us,  
113:24 - we need to view as JSON and then let's catch 
any errors. So I'm just going to catch the  
113:29 - errors by console logging out any errors 
that will turn so we can see. Just like so.  
113:43 - Okay, so there we have it. There's a lot of 
tidying up to do. But let's first make sure  
113:48 - that this works. Just make sure that is in the 
string itself. Cool. So let's give it a whirl.  
113:59 - Now if I visit localhost 8000, forward slash 
burgers, this is the endpoint that I have chosen.  
114:10 - Tada, you will see all my four buggers show up. 
You will see each object has its own document  
114:19 - ID as well. Great. If you're not seeing it in this 
format, it could be because you don't have a Jason  
114:27 - view extension added. This essentially will make 
your your JSON much more readable. Okay, so if  
114:34 - you don't have that, please go ahead and add the 
extension. Now. This is what it should look like.  
114:41 - Okay, wonderful. So we have our data coming 
through. Now let's get it into the front end.  
114:47 - But first, I'm just going to tidy this up 
real quick. So we don't need this anymore.  
114:53 - Okay, keep that as it is the URL. 
So essentially what we are doing is  
115:01 - Passing through the key space, which is burgers 
and passing through the collection name, okay,  
115:08 - so you could save it as separate things and pass 
it through. So for example, I could say key space  
115:16 - as the name, focus, and then pass it through into 
here with this syntax, like so. So what's gonna go  
115:27 - barbers and then make sure that these are 
backticks. So there we go. So that is an option to  
115:35 - if you want to make things I'm sorry, that should 
be key. So what do we save this as key space,  
115:40 - key space. So that is an option if you 
want to make this more readable, or  
115:44 - you can and this is what I'm going to choose 
to do. Because we are not going to be changing  
115:50 - this is pretty much going to stay as it 
is, I'm just going to get the whole URL  
115:58 - just like so. And I'm going to save this as a 
secret. So I'm just going to go in here. And  
116:05 - once again, on the same level, I'm going to 
create a new file, I'm going to call it dot  
116:10 - n fi. Okay. And now I'm going to save 
this in here as endpoint. So just  
116:18 - like so. And I'm just going to paste it in here, 
just like that. So there we go. And now to access  
116:28 - this right here, I'm going to use process NV and 
put, okay, so this wouldn't work if we didn't  
116:39 - have this package and didn't use it 
just like so. And now I think we have to  
116:46 - rerun this. Let's just check that out. Okay, 
now that seems to be working as it is. Great. So  
116:52 - we've saved our URL as a secret back here. One 
other thing that I'm going to save is my Astra  
117:00 - token. Okay, so there we have it. And once 
again, I'm just going to save all of this  
117:08 - is going to grab that as it is, and use process. 
EMV. And then whatever we call it in our Astra  
117:22 - dot EMV file is what we need to call it here. So 
let's say that and I'm just going to paste that  
117:30 - in here like so. Okay. Great. And that seems to be 
working just fine. Okay, so we've cleaned this up  
117:41 - a little bit, got a URL, we're passing 
through the URL and the options into fetch.  
117:50 - And great, one thing we can do is write 
some middleware. So if I write function  
117:58 - not found, and we post you the 
request the response and next.  
118:06 - And then in here, if we get a four, four 
status, so let's go back to our status dogs.  
118:20 - Okay, so you will see that for four means 
not found. So if we get a four of four, well,  
118:28 - then I'm going to get a new error, the error is 
going to say, not found, so we're just making  
118:41 - debugging a bit easier with this, we're going 
to get the message that says not found, okay,  
118:46 - so that is what we are going to do. And then if 
it's none of these, we move to the next function,  
118:54 - which is just an error handler in general, and 
it's going to be less specific error. And law.  
119:06 - We're gonna pass through the error to this 
error right here. And then request and response.  
119:13 - And this time, if the response if the status code 
is whatever the status codes, it's, so wherever it  
119:22 - comes back as or 500. So any error or sorry, any 
status code or 500, then I want to send a message.  
119:40 - That is, whatever comes with that status code. 
Okay, so there's two ways of doing it. So I'm  
119:47 - just going to show you what this means. Okay, 
so now let's get to using it. So once again,  
119:51 - I need to right up use and I'm 
going to use the function not found  
119:59 - and I'm also gonna pass through the 
function error handler, just like so.  
120:07 - Okay, so what I've written means that if I say 
misspelled this URL, if I wrote burgers like that,  
120:13 - I get the message, not found, I get the error 
message, not fat. However, if I didn't have this,  
120:22 - so I'm just gonna come on out, and I go 
to here. Oops, actually would have this.  
120:36 - See, it just says cannot get burgers, it 
doesn't really tell me why it doesn't give me  
120:40 - enough information. However, if it's not found, 
so for for iMessage, telling it to show me an  
120:49 - error that says not found, okay. So that is how 
we do that. And then any other error, we get a  
120:56 - different error message. So we essentially just 
get the error message that goes with these status  
121:01 - codes. But this way, we can be more specific, I 
can go pay, you are in the wrong place, buddy.  
121:15 - Hey, we're on their own pace, buddy. Okay, so 
cool. It's gonna pull it back to something more  
121:23 - general. Okay, so we are guessing all of our 
baggage data. Now let's get to using this in  
121:33 - the front end of our project. So once again, 
these are all the packages that I have used,  
121:39 - or the dependencies I've used, just make sure 
that you're using the same versions. Okay, great.  
121:52 - Now, let's carry on. So essentially, for my 
front end, so we can shut down the backend.  
121:59 - Now, in my front end, I essentially 
want to get all the data from  
122:04 - this URL, so we can use it. 
So let's go ahead and do that.  
122:12 - To do this, I'm actually going to import a nother 
package. So I'm just going to get up my terminal.  
122:18 - And I'm going to install the package Axios. Okay, 
this package is essentially going to help you make  
122:24 - the requests and fetch the data. So let's go 
ahead and do it, I'm going to write a function  
122:32 - right in here. So a function to get the data and 
we're just going to call it constipation data,  
122:38 - like so. So this is a functional expression. And 
this is actually going to be an async function.  
122:45 - Now, to fetch the data, I'm going to use Axios. 
So let's import Axios, import Axios from Axios.  
122:56 - Once again, this is the package that 
I am using Axios. So import Axios from  
123:03 - Axios. And now I'm going to use Axios. And 
we're going to make a GET request to get  
123:09 - the URL, this URL right here, because Okay, so 
because our backend is running, that should work.  
123:17 - Of course, if our back end stops running, that we 
will not be able to get to this data. And this,  
123:24 - we need to use await as that comes back with 
a promise. And let's save this as broker  
123:31 - data, just like so. So they should get the data. 
And now I'm actually going to save this. So I'm  
123:41 - going to use use effect to const. Burgers, set 
burgers, if you haven't used US state sorry,  
123:51 - use state is the one that we're going to use. 
And we're going to use this to set the state  
123:55 - in our app. So of course we have to import it. So 
I'm going to import that just above here. Import.  
124:05 - Use state. We're also going to use 
use effect I might as well just  
124:10 - import that too. We can short spell it correctly.  
124:17 - From react, okay, so there we go. So 
essentially, if I now use set burgers,  
124:27 - so at the moment, our state for burgers is now 
but if I use set burgers, I can set boggers to  
124:35 - whatever I wish and I want to set it to the ogre 
data, just like so. Okay, so let's check this  
124:45 - out. Let's see if this is working. So what I now 
need to do is going to use use effect for this.  
124:55 - And I'm going to pass through a callback function 
that will essentially fetch my data, just like  
125:03 - sir. And I was going to pass her an empty array, 
so that this doesn't keep on fetching over and  
125:08 - over again. So let's go ahead and do that. Let's 
see if that has worked. I'm going to console log  
125:18 - bogus. And see what happens. So let's go 
back to our front end. So localhost 3000.  
125:29 - Just inspect the page, a console, log out. And 
there we go. So this is what burgers looks like.  
125:38 - Now we actually just want the data. So we're going 
to go into the burger data, data. And there we  
125:44 - have our four burger objects. Great. So I'm just 
going to go ahead and do that. So burger data,  
125:54 - data. Data. Let's see what that looks like now. 
Okay, great. So there we have it, we actually have  
126:05 - an object of four objects. Cool. So this is 
looking good. There you go. As you can see,  
126:14 - there they are with their ingredients, and 
occasions and so on, I'd actually like to  
126:18 - make an array out of this, so it's easier to work 
with. So I'm going to show you how to do that. So  
126:27 - just here as well, I'm going to change this 
into an array. Let's actually just save this as  
126:35 - data this time. And I'm going 
to get the burger data data.  
126:43 - And for each one I'm going to, so let's get 
object keys for it. So I'm going to make some  
126:52 - object keys for it. Because at the moment, it 
doesn't have anything to sort of differentiate  
126:58 - each of the objects. And I'm going to map. 
So each burger object I'm going to turn into  
127:10 - I'm going to grab it from the burger data.  
127:19 - Data, Data. And I'm going to turn it into 
put it into Okay, so now whatever comes back,  
127:31 - I've said that as data, and that is what I'm going 
to say, Save As my buggers. And there we go. So  
127:38 - we now have an array of four objects, each with an 
object key. Wonderful. I wonder if I do need these  
127:47 - object keys, or if that will just work without 
it? No, we do need we need the object keys. Okay,  
127:53 - as does what we are essentially working off. 
So there we go. Wonderful. So we have our  
128:02 - four burgers. Now let's get to actually 
displaying them in the browser UI. So let's do it.  
128:13 - So for this in here, I'm actually just 
gonna create a data go into my favorite  
128:20 - burgers, the styling for this is going to be 
extremely minimal. As we have a lot to go through.  
128:25 - I don't want this to be all about styling, 
I want you to actually learn how to retrieve  
128:31 - data into an actual project. Okay, so I'm just 
going to do this, I'm going to create a div and  
128:36 - this is going to be the bag of feed, maybe give 
it a class of burger, fuge. Just like so burger  
128:43 - feed. And in here, I'm just going to 
create a card and this is going to  
128:49 - take our burger data. So let's actually map over 
each card. Let's actually create a chord first.  
128:55 - So in here, I'm actually going to create 
a folder or directory called components.  
129:04 - So new directory, and it's called components. 
And then in here, I'm going to create a new  
129:13 - file and score card J S, just like so. And 
then let's create our card. So const card,  
129:21 - and then I'm going to return at the moment, I'm 
just going to return two types like that. And I'm  
129:29 - going to use export default card not first to use 
this card. Okay and other files. So now in here,  
129:37 - I'm going to import the card input card from 
make sure to get the path correct. So in here,  
129:48 - opponents Right, yeah, okay. Then, called J 
S. Cool. We actually don't need that. Okay,  
130:00 - so this is fine. So now we've imported the 
card. And at the moment, we aren't passing  
130:06 - anything through into the card. However, I can 
actually start this up. So let's go ahead and  
130:12 - I'm just going to give this a class name just so 
you can see what's going on a little bit file.  
130:17 - And I'm going to say card. And now in here in 
my style sheet, anything with a class of card,  
130:25 - I'm just going to give a give a height for now of 
200 pixels. a width of, let's say, at view width,  
130:38 - and a background color. Of what color should 
we go cornflower blue border, radius 40 pixels.  
130:52 - Okay, so at the moment, I've just put in a card. 
So there we go. That is, that is my card. Now if  
131:00 - I map all my data onto this, okay, onto each card, 
it will actually produce as many cards as I need.  
131:07 - In this case, it's going to be four. So let's go 
ahead and do that, I'm just going to pass through  
131:13 - some props into this card. So I'm going to pass 
through Well, first off, maybe let's just map.  
131:30 - So let's get our burgers map. We're going to map 
each burger, and I'm just going to get that and  
131:45 - card and I'm going to pass through the  
131:50 - burger data. Okay, so this is looking good. As 
always, we should probably have a key with this.  
132:00 - Let's just see how this is looking. So there 
we go, we've created four cards, as we have for  
132:06 - burgers, let's actually add the key prop as 
well. So I can use the key just use the burger ID  
132:14 - as we do have one. So let's go ahead and do 
that. Okay, so we are creating the burgers,  
132:22 - let's maybe give each packet some padding 
as well. So margin, even margin pixels,  
132:31 - just so it's a bit more space out and on the 
card itself, or passing through the burger. So  
132:37 - I'm going to D structure the burger like so the 
wise we don't have to get the props. So I'm just  
132:43 - destructuring the burger. And then it's me, this 
may be a little bigger. I'm going to sit in here.  
132:57 - Grab that  
133:00 - at each of these. So let's give them an h2 tag. 
Let's pass through the burgers name. See what  
133:09 - that looks like. So there you go, you will see 
the burger name is being shown just right here.  
133:19 - What else can we pass through, we can pass through 
the burger description. Maybe let's make this a  
133:27 - p tag. So there we go. And then we can also 
pass through as much information as we wish.  
133:36 - So maybe let's put in a another 
P tag and call this burger.  
133:41 - What did we have? Location? And 
then burger location? Address.  
133:52 - Okay key location, web. I think that was one 
of them. Or was it just website? Website.  
134:09 - You can always check what it was. 
Go and hear what the description,  
134:14 - got the name description we've got visited. 
We have location is web address web zip code,  
134:22 - probably don't really want the zip code. So I'm 
just going to keep it as Web. Okay, so there we  
134:30 - go. And then we could also hide it if we've been 
there or you know, which would mean we'd only  
134:37 - see the ones we haven't but that is completely up 
to you. Okay, in fact I'm going to do this so if  
134:51 - Berger visited is true. Then we want to hand back.  
135:02 - I don't know what we can return back to sort of 
freestyling here, a div that has the class name.  
135:14 - visited. Otherwise, we could just go if it's not 
visited, there's probably neater ways to do this,  
135:24 - I am just freestyling here at the moment, 
as I said, when we can do not visited,  
135:30 - and it will show based, or show this div if we 
visited it, and this one if we haven't visited,  
135:37 - so then I can go visited and just sign up. 
And if it's visited, I can just give it  
135:44 - green, or red actually, let's make it red 
height 30 pixels with 30 pixels. Border.  
135:57 - Radius 15 pixels, background color,  
136:02 - red as we don't want to see it and if 
it's not visited, we'll give it a green.  
136:08 - Okay, and let's make this Okay, so there we go, 
we know that this means we visited and the green  
136:17 - means we have not visited these ones yet. You can 
replace this with icons, I just wanted to show you  
136:23 - one way of doing that. Wonderful. Okay, so this 
is how you would get data, usually document a p i,  
136:36 - and also using the Document Type. Okay, I'm just 
going to start this up a tiny little bit before  
136:43 - moving on paddings give the study pixels. 
Let's make all the font white font color.  
136:55 - White, of course, please feel free to you know, 
take this project really improve on it go crazy  
137:06 - on the styling because that part, my friends 
is up to you. This is not a styling course.  
137:19 - Whoops, cannot Okay, so we just have to what is 
happening here? It's gonna come out from now.  
137:33 - Okay, so it's not picking stuff up in here.  
137:40 - This is because sometimes the burger data 
might not come back fast enough. So I'm just  
137:45 - going to put that right here. Okay, good. Okay, 
so it might not read it first time. So the first  
137:54 - time this renders the burger data might not exist, 
which is why we put this question mark here. And  
137:58 - when it re renders then that will show these cuts. 
Okay, great. So this is looking a lot better.  
138:14 - Great, and then I'm just going to override the 
font if there's an h1 tag and give it the font.  
138:22 - color. Black. Cool. And let's just go back here. 
That back. Wonderful. And one last thing I would  
138:38 - do on that is center everything. So on the 
body itself, I'm going to do display flex  
138:57 - justify content, center text align, center.  
139:10 - Great. So wonderful. I hope you've learned a lot. 
Once again, this code will be available to you  
139:19 - in the description. If you're watching this 
in the future. Some of these packages might  
139:23 - have changed, just make sure to use these 
same packages for this project. Wonderful.  
139:33 - Thanks for watching and onto the next project. 
In this project, we're going to learn how to  
139:50 - use the Graph QL API in order to build out 
a hotel app. Okay, so once again, I'm going  
139:57 - to start completely from scratch in order to 
build out our react up. First things first,  
140:03 - I'm going to create a new database. So hopefully 
you are familiar with these steps already,  
140:07 - if you have been following with this tutorial. 
So what should we call our database this time,  
140:13 - let's go ahead and call it whatever we wish. So 
I'm just going to call it project work again.  
140:19 - Just like so. And it's cool are keyspace 
name hotels. The next thing I'm going to do  
140:26 - is just select where I am at the moment. So 
I'm going to go ahead and let's pick Europe  
140:33 - and West Europe and just create a database. 
Okay, so there we go, there is our database  
140:40 - it is currently being created, you will see 
the status as pending. And we're just going to  
140:45 - essentially wait until that is active in order to 
start working with it. And there we go. So let's  
140:55 - go ahead and click into here. And then here we 
will see our keyspace. Now, the first thing we're  
141:01 - going to do is just head over to the connect tab 
in order to start working with our Graph QL API.  
141:08 - We're going to be using this documentation right 
here to help us. So the first thing that we need  
141:13 - to do is just create a new application token. 
So I'm just going to click here to do that.  
141:18 - And once again, I'm going to select the role 
I want. I'm going to choose admin. However,  
141:22 - there are many others with different mutability 
levels. And I'm just going to create a token.  
141:29 - Once again, I'm just going to copy this 
right here and keep it somewhere safe.  
141:35 - Now, once we have done that, I'm just going to 
close that down. And I'm going to launch the  
141:40 - Graph QL playground by clicking right here. 
So there we have it, there's our playground  
141:46 - and a row to communicate with our playground, we 
need to just put the token we have just created  
141:52 - in the HTTP headers, just like so. So now we can 
communicate with our database. Let's go ahead and  
142:01 - create our first table. So I can use the docs to 
help me with this. So this is the mutation I'm  
142:08 - going to be using. Once again, if you watch the 
tutorials, you will know that we have queries and  
142:14 - mutations to our disposal queries will essentially 
find data for us. And mutations can create, delete  
142:21 - and update data for us. So we need to create 
a table. So I'm just going to get rid of this.  
142:30 - And this is a mutation. And the mutation that I 
want is create a table. Now if we look under here,  
142:39 - you will see that to create a table I need 
to the bank indicates that this is necessary,  
142:45 - I need a key space name. So let's go ahead 
and pass that through a key space name,  
142:51 - I'm going to put this on a new line. And 
the key space name has to be a string.  
142:58 - So I know that my key space name is called 
hotels, okay, because that is the key space  
143:03 - that we named it right here. So if I go back 
to my databases, hotels is the key space name.  
143:11 - And then the table name, this is something that 
I'm going to assign right here, I'm just going  
143:17 - to call it hotel data. So I have just chosen 
to assign this to the table name right. Now,  
143:25 - the other necessary thing that we need is a 
partition keys as an array. So let's go ahead and  
143:30 - add that partition keys as an array, and I want 
my partition key. So if we just click on here,  
143:40 - I need to give it a name and a type. So I'm going 
to go ahead and do that, I need to give it a name,  
143:49 - which is a string. So I'm going 
to choose to sort all my hotels by  
143:54 - a ID. And then I also need the type. And the type 
that I want this to be is actually going to be  
144:02 - basic text. As I don't want this to be an integer, 
I want the ID to take letters and numbers. Okay,  
144:09 - so that is one column that we have made. So far 
the partition keys. If I want to add more columns,  
144:15 - however, I could do so thanks to values. So once 
again, values is an array. So I'm just going to  
144:24 - my values. And if this is one column, this is 
actually the column we are going to filter by  
144:31 - and search by. And all these additional ones 
are going to come back if we search for this  
144:35 - column. So let's add another column. 
Again, we need to have a name for this,  
144:40 - which is going to be the hotel name and 
the type for this. I know that I want this  
144:46 - to be text. And if we want to add more columns, 
so at the moment, we have one column, a second  
144:54 - column, and I'm going to have three columns 
in here. So this is actually going to have the  
145:01 - rating. So I'm going to call this rating. 
And I'm going to give this an integer.  
145:08 - Value. Okay, so there we go. So now if we run 
this mutation, great, we have created our table.  
145:20 - Wonderful. So now that we have created our table, 
let's get to adding data into our table. So  
145:34 - all I'm going to do is navigate into my key 
space. So as you can see here, datasets is  
145:39 - actually generated the URL for me, I need to go 
into the hotels. So I'm just going to go up here.  
145:46 - And instead of Graph QL schema, I'm just going to 
go forward slash hotels to make sure that I'm in  
145:53 - the correct key space. Okay, so there we go. And 
now, instead of creating a table, if I look at  
145:59 - the docs, they will be changed, I need to insert 
hotel data. So now this is the mutation I need.  
146:07 - Once again, it's a mutation as we are going to 
be inserting data. So let's get up mutation.  
146:14 - And this time, I need to use Insert hotel data, 
just like sir. And what do we need to put in here,  
146:21 - in order for this to work? Well, I 
need to put through a value, okay,  
146:26 - and that is necessary that has got a bang there. 
So we have to do it, I'm going to give it a value.  
146:36 - And this time, I'm just gonna give it 
the ID, I'm going to make up an ID.  
146:41 - I'm also going to give it a name, so the 
name of the hotel, let's say Abby's hotel,  
146:48 - and a rating, which is an integer, so I'm going 
to give it a four out of five. So let's just  
146:54 - actually put this on different lines of just 
like so. And let's just return back the value  
147:07 - of have a name to check this has worked and 
click Run. So great, we have just inserted  
147:14 - some data into our table. Okay, let's go ahead 
and just insert some more. So I'm just going  
147:21 - to change these around a little bit. This 
time, I'm going to call this set Tories  
147:28 - give it a rating five, there we go. That 
has worked. Let's give me another it up.  
147:35 - This time, it's gonna go motel, Mays rating of 
three. And then one more, and this one is going to  
147:47 - be awesome. Hotel and give it a rating of five. 
Great. So now we know we have just added four  
147:58 - hotels into our database. But how can we actually 
see this? Well, for this, we need a query.  
148:06 - So to query this, I would simply I 
can go here and have a look, if I need  
148:11 - the queries, I need his hotel data. So I'm just 
going to write a hotel data like so. And because  
148:18 - we are not filtering out by anything, I can just 
get the values and then choose whichever values  
148:24 - I want to come back so I can get all of them, I 
can get the ID, the name and the rating. And just  
148:30 - click that. Or I can just get the name and ID. So 
that will return back. Or I can just get the name,  
148:38 - whatever you wish. So however you write that 
query is what will return back to you. I want  
148:46 - everything. So I'm just going to do that. And 
there we go. So that is essentially the query that  
148:52 - we need in order to get all of our data from our 
database. And we also need this Cassandra token  
148:59 - as the HTTP header. And also this URL, as that is 
where essentially our data lips. So let's go ahead  
149:08 - and do it. Let's start up our project now. So all 
I'm going to do is get my WebStorm up and just  
149:17 - create a new project. Once again, this is going to 
be a React project. So I'm just going to use this  
149:27 - and I'm going to call this hotel up just like so. 
And using MPX create react app. This should create  
149:34 - a project for me with all the React configuration 
ready to go. So I'm just going to click sexer.  
149:43 - And there we go. You will see 
my hotel app project right here  
149:47 - and all the dependencies being installed ready 
for me to use. Of course you don't have to use  
149:53 - WebStorm. If you're using another code editor 
or IDE that is absolutely fine to just make  
149:59 - sure Get Up to this point where your project 
is installing all the dependencies ready to go.  
150:07 - And great, we are ready to go. So the first 
thing that I'm going to do is actually just  
150:13 - delete anything we don't need. So here are all 
the files that have been generated, as well as the  
150:19 - package and all of its dependencies and 
scripts. So in here, I'm actually just going to  
150:26 - get rid of the logo as we're not going to need 
this anymore. So just delete that. Anyway,  
150:33 - I'm going to delete the report of vitals and 
setup tests. So once again, just delete that  
150:39 - as we don't need it anyway. And then I'm going to 
delete the app CSS file, as I want all my styling  
150:46 - to be in the index CSS file, and just delete 
the app, test J S and just delete that. Okay,  
150:56 - so this is looking good. Just going to 
minimize that. And delete this as we  
151:04 - don't have any more I'm going to delete the 
semi colons as I'm not a fan of semi colons.  
151:12 - There we go, save that. And then in the 
app js file, I'm going to delete all of  
151:18 - this as we don't need it anymore. And 
once again, get rid of the semi colons,  
151:22 - and we don't need the logo as we don't have 
it. We don't have this file, either. Okay,  
151:29 - so this is looking good. Now, if we run this, I'm 
just going to click this to run the start script.  
151:44 - You should see the project show up here, we've got 
rid of all the styling, so you should just see a  
151:52 - blank slate, like so. And let's get up our console 
log. Wonderful. So now that we have that, let's  
152:01 - get to making some requests. So I'm just going to 
minimize that for now. In the previous project,  
152:08 - we built a little mini backend using Express. 
However, this time, I'm just going to show you  
152:14 - a different approach. And that is using Netlify 
serverless functions. So to do this, let's get off  
152:20 - our terminal and let's install the Netlify command 
line interface. So we can use it to npm install.  
152:29 - Net LIFFE phi CLI, and I'm going to install it 
globally. Okay, so that is what the juice for  
152:35 - that is to install that locally and just let 
that run. Okay, so I'm going to leave that to do  
152:43 - its thing, the next thing we're going to do is 
actually create our first serverless function.  
152:53 - Okay, so when that is done, I'm just going 
to ask you to create a file in the root of  
153:01 - your project. So make sure it's at the root of 
your project on the same level as the package,  
153:06 - Jason is going to minimize that new. And the file 
is called net live by tunnel. Okay, and in here,  
153:14 - I'm just going to give you some code to put in 
in order to build out the sub list functions.  
153:21 - So this you can just copy, these are some 
commands that we're gonna have to put in  
153:26 - here in order to build them out. functions 
here is essentially the whatever you call  
153:33 - the directory you want to store your functions 
in. So let's go ahead and create that,  
153:37 - I'm going to create that on the same level. 
So just make sure that's in the root of your  
153:42 - project and call the directory functions just 
like you did here. Okay, so that is where we're  
153:49 - going to store our functions or serverless 
functions. And then we just need one more.  
154:00 - Command. Okay, so there we go. Make sure 
to write this exactly as I have written it  
154:07 - in a Netlify TOML file in the root of your 
project. Great. So now that we have done that,  
154:16 - I'm going to create my first function. So 
making sure you are in the functions directory,  
154:21 - create a new JavaScript file, and call it whatever 
you want your function name to be. So I'm going to  
154:27 - call this get hotels. And this is a JavaScript 
file, so that will add the J S extension.  
154:35 - Now with any surplus function Netlify serverless 
function, this is the syntax that you need.  
154:41 - So let's go ahead and write it. I'm 
going to have to write export handler  
154:50 - This is an async function. Let's make 
this a little bit bigger. Nicholas who no  
155:02 - And then we are going to have to essentially 
fetch some data. So just like we did before,  
155:08 - so we're going to import another 
directory. So we're going to get  
155:14 - node fetch, I'm just going to install it right 
now. API node, fetch, and let that install. Okay.  
155:26 - So while that is installing, let's go ahead and 
use it in this file const, fetch equals require  
155:35 - node fetch. Just like that.  
155:44 - Now, as we know, with fetch, we pass through two 
things. And that is a URL and options that will  
155:51 - have our HTTP header along with the authorization 
token. So let's go ahead and do that.  
155:58 - So once again, let's write the URL. And we 
know that the URL, so let's go back to here  
156:08 - is this right here, and this is where 
we're gonna make the requests to.  
156:16 - See, I'm just going to paste that in here, like 
so. And then Let's also get our options. So const  
156:23 - options, say this is const URL. And the options 
are going to have a method, which is a get  
156:37 - request, and the headers, okay, the headers, 
which will consist of the content type.  
156:53 - Content Type, and the X, Cassandra token, 
okay, so there we go, I'm just gonna make this  
157:05 - the same, as we see here exe Cassandra token, 
and I'm just gonna grab that. So the whole thing  
157:14 - and just put it in here, just like, so. 
It's gonna make it single quotes. Great.  
157:25 - So we have our options. And then we also have 
our new R L, format this a little bit better.  
157:32 - So URL options, I'm going to use Fetch. However, 
this time, we're actually going to save whatever  
157:39 - comes back from fetch. So we know this promise, 
const response. So whatever that returns back,  
157:47 - we're going to save as response this time. 
And this is not all we actually need to do.  
157:54 - And because this time, we actually 
have a query to pass through, okay,  
157:59 - so we do have a query to pass through. And 
that query is I'm just going to save up here.  
158:06 - So I'm going to save as constant query. And 
I'm just going to use backticks for this.  
158:12 - And I'm going to paste in my query. So let's go 
in here, this is essentially the query I want to  
158:17 - make. So I'm just going to paste that in here 
like so, maybe formatted a little bit better.  
158:31 - We need to pass that query through in with the 
options. Okay, so this is no longer a get request,  
158:38 - as we are posting, we are sending this query. So 
make sure to change this to a POST method. And  
158:46 - let's get to passing through the query into the 
body. So I'm going to pass through the query,  
158:53 - but I need to pass it through JSON stringify and 
then pass through the query like so. Okay, great.  
159:03 - So that is looking good. We are now passing 
through the query in with our options,  
159:08 - so along with the Cassandra token, the method 
and then we are putting that into the fetch  
159:16 - that we imported from node fetch. Great.  
159:23 - Now we're going to use try and catch in order 
to do this. So this is the syntax, we'll try  
159:30 - and catch we've got try and I'm going to catch any 
errors. So e4 errors. Okay, and to try to do this,  
159:41 - we actually have to make sure 
this is all in the export  
159:45 - handler. So let's just grab that and make 
sure that it is here. We are going to  
159:57 - what essentially we're getting the response 
I'm going to call this was response  
160:00 - body. So we could use this, but we also need 
the JSON from it. And this returns a promise.  
160:07 - So I'm going to have to use await in front of it 
just like sir. Okay. And then if that comes back,  
160:14 - then we're just going to return a status code 
of 200. Because that has worked. And then we are  
160:20 - going to show in the browser, the response. So I'm 
going to use JSON, string five for this to work,  
160:27 - I'm going to show the response body in the 
browser, and if it doesn't work, where we catch  
160:32 - the errors, and we're just going to console 
log the errors, okay? We can also of course,  
160:37 - return a status code to someone do return 
status code 500. And I'm just going to show  
160:44 - the error in the actual browser too. So let's 
use Jason string phi and pass through if error.  
160:50 - Okay, so this is looking good before we 
clean this up, let's just check that works.  
160:57 - So to do this, I'm gonna go in 
here and I need to run the command  
161:01 - Netlify. Net LIFFE pi, Dev. 
And that is do it's much okay.  
161:14 - So there we go localhost 888. Let's inspect 
the page. And now if if we want to get that  
161:24 - data, if we want to run 
this function, essentially,  
161:28 - I need to go into functions and get 
hotels. Okay? Oops, make sure this is an s.  
161:36 - So, I'm going to go forward slash.net. LIFFE fi, 
forward slash functions as the directory that we  
161:46 - created and then get the Taos and wonderful. So 
now we are getting all of our data. And Wonderful.  
161:59 - So is saying something's already running on port 
3000. I thought I did shut this down. But I didn't  
162:05 - cancel. Okay, so we need to stop that running. 
Make sure that stopped. Okay. Essentially,  
162:13 - what is happening here is that localhost 888 
is now our front end. Okay, so we don't want  
162:19 - anything running on localhost 3000, because we 
want everything to be running on here. Okay.  
162:24 - So that's what we want and to, and essentially, 
our front end, and our backend are now on this  
162:30 - URL. So here we go to get our data. And here is 
our front end. Great. So I hope that makes sense.  
162:41 - Once again, just make sure that Netlify Deb 
is running in order to get that to work.  
162:49 - Wonderful. So once again, I'm just 
going to show you the package Jason,  
162:54 - these other packages that I am using, if yours 
have changed, or if you're watching it's in the  
162:59 - future, then please use these for the tutorial 
in order to get this code here to work. Okay,  
163:05 - so there we go those other packages that 
you need, along with their versions.  
163:13 - Wonderful. Now that we have our data, let's get to 
clean this up a bit. So just like we did before,  
163:20 - I'm going to create a new file, a dot n v file 
in which we're going to store all our secrets.  
163:25 - So once again, I'm just going to put the endpoint 
in here. And I'm also going to put in my Astra.  
163:33 - So just like that, and then from here, I'm just 
going to get this URL to get the whole thing.  
163:43 - Put it in here. And I'm also going 
to get my token, okay, so that we go,  
163:52 - just like so doesn't need to be a 
string. You can just save it like that.  
164:00 - Okay, and now this means I can use process EMV 
in order to get my Astra token. And I can also  
164:11 - use it to get the URL, but now it's hidden. 
Okay. So now it's a bunch safer, and  
164:18 - points. Great. And we have to actually inject 
these variables. otherwise this won't work. So I  
164:24 - just inject the variables by running Netlify dev 
again. So just like Sir, okay, and you will see  
164:32 - injected endpoint and injected 
Astra token. Okay. So there we go.  
164:44 - Let's try that again. Only absolute URLs and  
164:52 - point and point and point A misspelt endpoint.  
165:04 - Okay, so once again, I need 
to re inject the tokens  
165:13 - and nullify Dev. Wait for that to be run.  
165:17 - And Wonderful. So now we have a URL or get back 
our data. As long as the backend is running,  
165:24 - let's get to using it in the front end. So 
I'm done with this. For now let's have a look  
165:30 - if this needs any cleaning up, so here 
we have all the code that is necessary,  
165:35 - this will be available to you below. So please 
make sure to use it, you don't actually need  
165:40 - to pass through an event for this. This is 
looking good. Okay, so there is all my code.  
165:48 - Great. Now let's move on to the front end. So here 
is my front end. As you can see here, once again,  
165:55 - I'm going to have to essentially fetch the data. 
So I'm just gonna do fetch data just like we did  
166:00 - before, we're gonna make this an async function. 
Okay, let's change this to a function expression  
166:07 - just because I prefer working in this way. 
And now let's actually fetch the data.  
166:16 - So now this time, I am going to 
actually use Fetch. So the Fetch API  
166:24 - going to await it as it's going to come back with 
a promise. And I'm just going to fetch this URL  
166:30 - right here. So we're gonna copy that and paste it. 
And well, we don't need all of this, I can simply  
166:35 - put forward slash Netlify functions get Hotel. 
So that is essentially the same thing. Okay,  
166:43 - so we're getting the data from that. And then 
let's go ahead and save it as something. So I'm  
166:49 - going to save it as just the response for now cost 
response. Great. So that's the line we need to  
166:57 - write. Now, once we have whatever comes back from 
us. So the response need to get is Jason. However,  
167:10 - this also returns a promise. So we need to use a 
weight. And let's say this as the response body  
167:18 - this time. And we're going to have to actually 
save this into state. So I'm just going to import  
167:26 - use state and also use effect as we're 
going to need it later. From react.  
167:34 - Okay, awesome. So we've got the response body, 
let's actually save it to the state of the app.  
167:41 - So let's use what should we have hotels, set 
hotels, and then use state? I'm going to start  
167:52 - off with the state. No. Okay. So all this means 
is that at the moment, hotels is now and I can use  
168:00 - set hotels to make hotels, whatever I wish. But at 
the moment, we're starting out with hotels being  
168:06 - not so this gets passed on to that. 
And I can use this to also change that.  
168:11 - So I'm going to use the set that tells 
to change hotels to the response body.  
168:22 - Wonderful, I think let's check out if this has 
worked. So I'm going to now use use of fact.  
168:33 - And then a callback function, you don't know 
about use effect, I would suggest doing some  
168:38 - research on these hooks at the moment. So use 
effect, just like so I'm going to fetch the data,  
168:45 - okay. And then I'm just going to put up an 
empty array, so it doesn't keep fetching  
168:49 - that data over and over again. So I'm going to 
call that and now let's console log with health  
168:55 - to see if this has worked and to see 
what's being returned back to us.  
169:05 - So now, let's go back here, and just go to the 
front end. And there we go. We are getting the  
169:13 - response body data, data, hotel data. So data, 
who told data values is what we need, and that  
169:21 - is an array. So I'm just going to go back here and 
go response body data, hotel data values. Okay,  
169:31 - in order for that to bring back just the array, 
and there we go. We have an array of four tells.  
169:42 - Wonderful, let's carry on. So now that we have 
that and we have checked that that has worked,  
169:50 - there's the whole code in its entirety. Please 
feel free to stop here and make a note of it  
169:56 - or just catch up, press pause and if you What 
up, let's carry on. So just like we did before,  
170:04 - I'm actually just going to map out all 
the hotels, I'm not going to create card  
170:08 - component this time as you know how to do 
that. So I'm just going to grab the hotels  
170:14 - if they exist. And I'm going to map so dot 
map. And for each hotel, well, I wanted to  
170:29 - return a div.  
170:35 - Let's give it a class name of a towel. And then in 
here, let's put an h1 tag that has the hotel name,  
170:49 - a p tag that has the hotel, what are the other 
ones hotel name, then we have a hotel rating.  
171:03 - So let's see how that looks. And there we go, 
we get all four of our hotels with a little  
171:10 - rating, too. Now, let's get to 
setting this up a little bit.  
171:14 - So here is my app, I'm just 
going to get my CSS file.  
171:23 - Let's put everything in the body as justify 
content. Center, of course, we need to use  
171:32 - display flex to initialize this. And align 
text, text align, apologies, text, align,  
171:45 - center. Okay, so that is looking good. 
And anything with a class of hotel,  
171:53 - I'm going to make sure that the background 
color is salmon. And border radius is 50%.  
172:09 - Okay, so maybe that's a 
bit too much border radius,  
172:13 - we can of course, change it 
as maybe make it just 10%.  
172:19 - Or whatever, really, that 
you wish it is up to. Yeah.  
172:31 - Great. So of course, please, again, feel free 
to go wild on the styling, I don't want to go  
172:38 - too crazy on the styling. This is not what this 
is about. This is a tutorial to show you how to  
172:44 - get data into a project. Okay, so I'm just going 
to put my hotels here, and we will let's make  
172:49 - this an age. Tag, like so. Great. And maybe 
let's give it some padding from the top,  
173:00 - let's give it 10 pixels. And from each side, 
I'm going to go 50 pixels to make it look really  
173:07 - long. Okay, and then also margin. five pixels. 
Correct. Okay, so hopefully, you've learned a lot  
173:20 - in how to get data, this time using Graph QL. And 
the Graph QL API, if you want to learn more about  
173:28 - how to make more advanced requests. So in making 
the functions including stuff like pagination,  
173:35 - I do suggest watch my Netflix clone in 
which we use Graph QL to do this, okay,  
173:41 - so that is an option for you. Please try go ahead 
and watch that, if you wish, it is reviewed by an  
173:46 - actual Netflix engineer. Once again, the code for 
this project will be available in the description  
173:53 - below. And that's it. So to recap, during this 
video, cause we have learned what is no SQL,  
174:01 - SQL versus no SQL and why you can't compare them 
types of no SQL databases. So document databases,  
174:08 - key value databases, wide column stores or tabular 
databases, graph databases and talks about the  
174:14 - multi model databases. We also talked about how to 
get data into projects with to real life examples,  
174:21 - and also how to look at the document API and Graph 
QL API as we did this. So action packed course  
174:28 - really. And if you're looking for ideas on where 
to go next, to really solidify your knowledge,  
174:32 - I would recommend using the Document API and 
SDK to build your own Tinder app with me here,  
174:38 - or using the Graph QL API to build a 
Netflix clone here, or even learn how  
174:42 - to federate data from two database types with 
my Graph QL Federation crypto app right here.  
174:48 - Thanks so much for watching 
and I will see you again soon.

Cleaned transcript:

Hello everyone here on freeCodeCamp today and welcome to this course on no SQL. My name is Ania Kubow, and I'm a software developer and course creator on YouTube as well as your instructor for this video. In this video course, I will be demystifying what no SQL is clarifying the difference between SQL and no SQL as well as going into a deep dive of the four main types of no SQL databases. With each deep dive, we will be approaching each learning as an explanation, example and exercise. So the three is in order to fully grasp the topic we are discussing. After that, we will go straight into using what we have learned with two real life use cases. By use cases, I mean, we will be getting data into real life projects using a document API, and the Graph QL API to communicate with our newly made databases. And finally, we'll be wrapping up with where to go next. Don't worry if none of this makes sense to you. Now, this is what the tutorial is for. As always, if you like what we are doing here at freeCodeCamp, please do get that subscribe button and click as it would really help us on our mission to provide a broad spectrum of learning materials right here free to access for you. Now, let's get to it. So the first thing you need to know is that no SQL is an approach to database management. It is considered to be super flexible as it allows for a variety of data models, such as key value, document, y column or tabular and graph formats. These are the four we will be looking at today, as well as a new emerging trend of multi model databases. So we have already mentioned that no SQL databases are casually considered to be flexible. But officially the defining characteristics of no SQL databases are considered to be that they are non relational, distributed and scalable. Distributed refers to running on clusters of machines globally distributed to support apps at two different geographical locations. And scalable means that no SQL databases are able to store and query life scale data, as well as support high transaction throughput scaling horizontally. In addition to this, they're also partition tolerant, meaning that they are able to work in the presence of network partitioning. And they are also highly available, meaning that they are able to serve requests even when some machines go down. They can do this as they have data replication built in. And lastly, what does non relational entail? To understand this fully, we need to look at relational databases bust, the relational data model and SQL were designed for databases that work on single machines and scale vertically. We will go into this in a bit more detail later on. In fact, everything we just mentioned is in contrast to what relational databases are all about, which is Atomicity, Consistency, Isolation, durability, or acid for short. I am bringing up relational databases as you understand where no SQL came from, we have to look at them as well as SQL. SQL stands for Structured Query Language. It is used for relational databases. By relational I mean, it's a collection of tables with rows and columns that stores a specific set of structured data. No SQL is used for non relational and relational databases. Okay, so when you think SQL think are the Structured Query Language for database management on relational databases, and think rigid, and when you think no SQL? Well, let's have a look at the word itself. No SQL, you might think okay, so it's the more flexible way to access data. So not using SQL destructed query language. Simple, right? Well, you would actually be wrong. Because of the usefulness of SQL. Many no SQL databases added support for SQL, leading to an understanding among developers that no SQL actually means not only SQL. So you can use the Structured Query Language or you can not use the Structured Query Language, it is up to you. So once again, to recap, SQL is a structured query language, and no SQL is an approach to database management. Got it? Good. And the book No SQL distilled a brief guide to the emerging world of polyglot persistence. The writer explains two main reasons for using a no SQL database. The first is application development productivity. When developing an app there is a significant amount of time before starting anything really, that is spent on organizing data. By organizing I mean, mapping data between in memory data structures and a relational database. So in other words a type of database that supports SQL, as we just mentioned, as a non relational database manager approach, no SQL can provide a data model that better fits the applications need an entire makes our life easier in the long run. As the data model is more suited to the application, it makes debugging and writing code easier, as well as allows for easy evolution. The second reason is large scale data. As we know, organizations today love to capture as much data as possible to improve their offerings as well as other things. However, capturing large amounts of data and processing it quickly is expensive in terms of an operation. So whilst it is possible to do so with relational databases, it is usually more economic to run large data and processes on lots and lots of little cheaper machines or clusters that no SQL databases are designed to explicitly run on rather than one large one. As is typical for relational databases. We will go into this in more detail in the next section. So in conclusion, no SQL is a database management approach. The characteristics we can expect from a no SQL database are that it is a non relational database, as opposed to a relational one, a distributed database that is designed to manage large scale data while maintaining a high performance, scalability, throughput and availability. Now, when people look at no SQL and SQL, they might be tempted to compare the two. But by now we know that we can't do this. Why again, this is because once again, no SQL is a database management approach. And SQL is a query language. So two completely different things, it might be better going forward to start referring to no SQL databases as non relational databases. So let's go ahead and switch that. So we can start comparing them to relational databases from now on. As we mentioned, relational databases use this structured query language, a language that became prominent in the late 1970s. And no SQL means not only Structured Query Language, which allows you to use the language or not use it to get data. No SQL appearance on the scene is noted as somewhere around the 2000s. With SQL, the data is modeled as tables with fixed columns and rows. And with no SQL databases, the data is not only modeled as tables with fixed rows and columns. Instead, it can be modeled as JSON documents, graphs with nodes and edges, key value pairs or with Y column or tabular databases, where columns can be dynamic from row to row within a table instead of fixed. With a no SQL database, the schema is flexible. This means there doesn't have to be any real fixed structure to the data. It can be stored in a flexible schema where this approach can make development easier due to the high level of flexibility. With a relational database, the schema is fixed, they will have rigid data types. So if you want to put a Boolean into a column that has been defined to only take integers, the attempt will get rejected. Think of it as a super strict approach. And whilst the strictness can be good, it also comes with its downfalls and can be very time consuming when trying to implement changes. And finally, let's look at scalability. No SQL usually scales out. This is also known as horizontal scaling. This involves adding more and more machines to the resource pool. Rather than adding resources by scaling vertically like relational databases do. So well no SQL scales out SQL scales up by adding more resources I mean, it adds things like a more powerful CPU and RAM to handle workload and improve performance rather than adding more machines such as service. As mentioned, there are four main types of no SQL database systems each using a different data model. Once again, they are the key value document why column or tabular and graph database types. As mentioned we will be also taking a quick look at the emerging trend of the multimodal type at the end to we will be going through each type and an explanation example exercise format. Okay, so once again, the three is now the first thing you need to know is that databases have multiple layers. The first layer is an interface or in other words, a visual platform where you can visit and interact with data, which is where you find the format, the language and the transport. In this course the interface we are going to use is called Data sex Astra database management system. This is where we will be creating all of our database types for the example and exercise parts DataStax Astra DB is an auto scaling Database as a Service built on Apache Cassandra designed to simplify cloud native application development. Because it is built on Apache Cassandra, you will see us using the Cassandra query language or CQ l a few times in this course, CQ l offers a model close to SQL and it says that data is put in tables containing rows and columns. I will be pointing this out to you when we use it. These languages are how we interact with the data in our database. The next layer is an execution layer. This is where we pass the incoming queries coming from my interface. It is also used as an analyzer and a dispatcher. And finally, we have the storage layer in which the indexing of data happens. The reason I'm using datasets Astra is that it will allow us to create all four types of database types for this tutorial, so I won't have to sign up to separate database management systems for each section. However, you don't have to. There are literally dozens and dozens to choose from, so please feel free to take your pick. We can group these database management systems into families according to the CIP theorem. According to the CP theorem, a no SQL database cannot achieve consistency, availability and partition tolerance, it must sacrifice one of the three for example MongoDB and Kafka chose to focus on CP and the database management system we are going to be using datasets Astra is not an Apache Cassandra, which chose to focus on AP. So to recap, what we are doing here is using data sacks Astra which is an interface essentially, that will allow us to work with our no SQL database, which is in this case, Apache Cassandra, to be exact. Apache Cassandra is an open source, no SQL distributed database. The language we will use to communicate with our database is Cassandra query language, or SQL for short, which, as I mentioned, is very similar to SQL. Most no SQL databases have their own query language or not. Once you are on the data sex Astra platform, we're going to create a database. So I'm just going to head over and click this button right here. And that will take me to the page in which I'm going to create our first database, and the database name, I'm going to call it FCC underscore tutorial, I would recommend calling your database exactly the same in order to avoid any issues further on for this tutorial. Of course, once you have the knowledge that you gained out of this tutorial, you will be able to name your databases, anything you wish. This is just a suggestion. However, now under keyspace name, because the first example we're going to look at is tables, I'm going to call the key space Tabular. Once again, I would recommend that you call your key space name the same thing so that you don't run into any issues further on. Okay, and next we can provide a region, we can choose Amazon Web Service, or Microsoft Azure or Google Cloud, I'm just going to stick with this one. And I'm just going to select a Europe as I am currently in Europe, and I'm going to create a database. And there we go, we have created our first database, it has a database ID, the status is currently pending. So we're gonna have to wait for that to turn active before we can go ahead and use the database. And there we go, we're active. As you can see, here, the status has turned to active in green. Great. Now that we have set up our database management system, let's start getting to some examples. Okay, great. Now let's look at the first database type, which is a tabular database type, also known as a column database type or a wide column database type. What you need to know is that tables are relational and come with a schema, we are going to be making a table called books in this next section and defining what kind of rows the table can take, and what kind of types the rows are made of. For example, I'm going to have a table called books. And in it, I'm going to say that we can only have a row that has a book ID and author a title a year release the categories the books belongs to and a timestamp for when it was added. I'm also going to say that the book ID needs to be a UU ID or a universal unique identifier. The author field needs to be some text and the title needs to be some text to the end has to be an integer and the categories needs to be a set of texts. And the timestamp needs to be a type of timestamp format and only that, okay, so what I've done here is essentially define a schema. The next thing that is important to know is that we are going to be saving this row based on a key. This is important As this is how we are going to be retrieving our data with queries later on. Okay. So for example, if my UU ID for this row looks like this, and I can save it, the only way I can find it is by searching for this key, and the whole data row will be returned. This key is also what is known as a partition key. Because our no SQL database is a distributed database, it means our data can be sold on loads and loads of different nodes. So if two rows had the same partition key, they will be stored together on one note, and when we query for that key, they will both return. Got it. Good. Now let's use it in practice with an example in which we are going to be storing books in a tabular database. So now that we have created the database and has access to us, let's go ahead and create our first table. To do this, I'm just going to double click on the database itself, it should take you to this page in which you will see the key spaces associated with this database. At the moment, there is one as we only created one key space called Tabular. Great. So now I'm going to do this part using the CPU or console. So as we know, tabular databases organize data in rows and columns. Okay, so that's what we're going to be doing, we're going to be building a table with rows and columns to store some data using C QL, or Cassandra query language. The first thing I'm going to do is use a command in order to get our key space. So to do this, I'm going to enter the following command, it is called describe key spaces. And if I hit that, you will see all the key spaces associated with my database, you will also see that tabular is right here. Just to make sure we are all on the same page, it keyspace is simply a word for a logical grouping of tables. So now that we can see our tabular key space, let's actually get to using it, I can use it using the following command, use Tabular. And just hit enter. Don't forget to put the semicolon at the end. Okay, so now you'll see that I'm actually in the tabular key space, I'm inside the key space, I now want to create a table inside the key space. And I'm going to use the following SQL command to do so I'm going to write CREATE TABLE if not exists, okay. So that is something you're going to need to create a table in your key space. And I'm going to call the table books. Now, I'm going to actually define what goes into my table as well. I'm going to define what it is I want to put into my table and what type it is. Okay. So for example, if I choose to put in a book ID, and then also going to state that this is a unique identifier. Okay, so from now on, I can only use Universally Unique Identifiers, or UU ID as the book ID. For those of you who don't know what a UU ID is, it is a 128 bit label useful information in computer systems, I will show you the structure of it as well as what it looks like when we get to using it later on. Next, I'm also going to say that my table of books is going to have an author and the author. So whatever value I have as the author is going to be text, okay, so a string. In other words, we're also going to have a title, which is going to be texts a year, which is going to be an integer. Okay, so a full number, we're going to have categories, which is a set up texts. Okay. So once again, I will show you what that looks like we're going to have multiple categories. Or in other words, it's going to be a set of texts. And I'm also going to have added, which is going to be a timestamp I have defined added to be a time stamp. So timestamp is also a type in C QL. And finally, we're going to have a primary key. A primary key in basic terms is how we're going to search for a book in our table. Okay, so imagine our table has hundreds and hundreds of books. We can filter through the table, we can search through the table by the book ID, thanks to this primary key right here. The book ID that I've passed through into the primary key is also the partition key that we discussed earlier in the introduction. Okay, so I'm putting in a partition key into the primary key. Great, and we're just gonna close that off and don't forget the semicolon and press enter. And there we go, we have now created our very fast, super simple table using CQ L, just to make sure that has worked, I'm just going to use the command describe key space Tabular. So the time I'm picking out the precise key space, and putting the semicolon and then just hitting Enter, and there we go, we can see that our table has been created, okay with the book ID added author categories set, and yeah, wonderful. So now that we have finished our table, we have created our table, let's actually get to putting things into our table. To do this, I'm going to use the command insert into. So I'm going to use Insert into that is a command that we're going to use to insert data into our books table. So I'm just gonna write the word books. And then once again, I'm just going to put in a book ID and author, a title a year, the categories that are belongs to and added and just click enter. The next thing we're going to do is actually add the values. So we didn't actually finish off this command, there's no semicolon, so we did not finish off this command, we're just making a new line so it's more readable. And I'm just going to put some values into our books. So I'm just going to open up the parenthesis, and I'm actually going to create a unique identifier. So this is a function, I'm going to call this so that it creates a universally unique identifier for me. The next thing I'm going to do is write a string of Bobby Brown as we defined author as text. So this needs to be text and needs to be a string. And then we're also going to give it a title, which is also text, it is a string. So I'm going to put dealing with tables. The next is year, which we defined as an integer. So I'm just going to put 1999, and then categories, which is a set of texts. So to do this, I'm just going to open up some curly braces this time. And I'm going to put the string of programming and the string of computers. This is because I defined categories as a set of text. So I can only put text into this set. Okay. And finally, once again, I'm going to call a function, the function is called to timestamp. And I'm going to open up my parenthesis, and I'm just going to put an another function is called now I'm going to call it, this will essentially create a timestamp with this very second. Okay, so timestamp of this very second that I'm going to put into my table. I'm just gonna close all this off, and finish it off with some semi colons, because I'm done with this command now, and just click enter. Wonderful. So now let's see if that has worked. I'm going to use the command select all. So this little asterix means all from our table called books. So we have chosen to call the table books. So that's what I'm using the word books here, and then let's get our semicolon and just click enter. and wonderful. Here is our table, we have created a table, we've put some data into our table. Let's have a look. Here, you will see the UU ID has been generated. This is the structure of universal, unique identifier that looks wonderful. Next, we've got added. Okay, so this is the function that I wrote to timestamp. Now, if I use the function, today's timestamp down to the second has been used to populate this cell right there. And next we have the author of Bobby Brown, the categories and the title dealing with tables, as well as the year which is an integer. Great. So we've created one row in our table, let's get to adding a nother row into our table. So to do this, once again, I'm going to use the command insert into again, I'm going to pick out the table that I created earlier, which I chose to call books. And I'm going to say that into this row, I'm going to put in a book ID, an author, a title a year categories and add it okay and then the values that I want for these cells are going to be once again I'm going to use the UU ID function to create a universally unique identifier for me. I'm also going to put a string of let's put Andrea Agnes as the author for the title. I'm just going to put the moon as the title of my book, and for the year I'm going to put 2001 is an integer, so not a string, that categories, I'm going to put space and non fiction, non fiction like so. And then added. Once again, I'm going to use the to timestamp and pass through now and call it. Okay, so there we have it. Once again, I'm just going to close that off, and then use a semicolon to finish this command and hit enter. Wonderful. So now if we look at everything in our books table, so I'm just going to use the command to select all books, oops, we didn't use the semicolon, select all books. Select all from books, apologies select all from books is the command we need. Wonderful, we can see now that two rows exists on our table that we created. Great, this is looking really good. As you can see, a new unique identifier has been generated a new timestamp, the author name, some categories, a title, and the year as an integer. Correct. Now what if I just want to select one thing from our table? Well, as we mentioned, we know that we can use a primary key to the book ID to do this. So let's go ahead and try do that. I'm going to use the command select all. So once again, select and then we use the little star or Asterix from books. And I'm just gonna hit enter. So I'm not gonna close up this command yet. And I'm gonna use the command where and then use book ID equals. So I've chosen book ID for myself. I've called it book ID. And I'm just going to select a unique identifier. Let's select this one. So what do we expect to return if we run this command? Correct? That is correct. We are now getting one item from our table. This because we chose to select an item by its unique identifier. Okay, so there we go. We have now successfully picked out one item from our table using the book ID, or in other words, the primary key. So we have now seen how we can pick out one item from a table. However, how can we filter out multiple items from a table? Well, to do this, we're going to work with partitions. So let's make a new table for this. I'm just going to refresh my page, you can actually also use the clear command, instead of refreshing the page. If you want to clear all of this, it's up to you. So once again, this is going to be some great repetition for you some great muscle memory practice. First off, let's actually get to listing out all the key spaces using the describe key Space Command. There we go, we can see the key space that we want the tabular key space, I'm going to use the command use tabular in order to pick out the key space that we want. Next, let's actually get to creating a table in the tabular key space. Okay, so we have one table already called books, I'm going to create a nother table this time. So the command you need for this is create table if not exists, and then we're going to choose to call our table restaurant by country. Okay, so I've chosen to call my table that as you can choose to call your table, whatever you wish. And now, in my table, well, I'm going to decide that I want to have the following columns, I'm going to have the country which I'm going to define as text. Next we're going to have cuisine, which I'm also going to define as text a URL, which again is going to be some text. And now I'm going to have a primary key. So from our previous lesson, we know that we can search for something in a table by its primary key, I'm going to choose to search by the country. The country is actually the partition key we refer to in the explainer okay. So, we have a primary key command and we are passing through where we want the partition key to be if that makes sense. So, what I have done is chosen one of the table columns here I have chosen country to be my partition key and I have passed that into the primary key like so. So now also what is happening is that all my data from now on is going to be distributed in my database based on the value of country. Now, the other values here that I have put so name and URL are What we call clustering keys. So what this means is that when I search for data based on the partition key, so in this case, it's country, I can make it come back in descending order, and URL in ascending order. Okay, so there we go, let's go ahead and run that command, not forgetting the semicolon. And there we go. Next is actually insert some data into this table. So just like before, I'm going to use the Insert to command. And I'm going to insert into the table that I have chosen to call restaurant by country, going to open up some parenthesis, and I'm going to say that I want to put in a country a name, a cuisine, a URL, and I'm just going to close that off, and then start a new line with the values. So open up the parenthesis again, and I'm going to put the string of Poland the name, I'm going to put VAs ska, catch ma as a string. And then the cuisine, I'm also going to put some text for this, I'm going to put traditional as a string, and then the URL once again, this is a string, I'm going to put w w.kajima.pl. And close that off and for the semicolon, and click enter. And wonderful, I'm just going to insert a another row while we are here. So once again, insert into my table name is restaurant by country, I'm going to open a parenthesis to say what exactly I want to put in this row, I'm going to put in a country and name a cuisine and a URL. And in the next slide, I'm going to put the values this time, let's put Singapore and I'm going to put the shark as a string, this is going to be American food as a string. And the URL is going to be W W dot shack dot S, G, no, close that off. And wonderful. Hit enter. Great. We can also do a third one. So I'm just going to actually press up this time, we will just bring back the last line. And for the values, I'm just going to replace that with United Kingdom. And for this one, let's put the red rose. And I'm going to put pub as the cuisine. And as the URL. Let's just put red rose.co.uk. and wonderful. So now click enter. And great. Let's check if that has worked. So I'm going to use the select command this time, Select All. So the Asterix is all from restaurant by country, because that is the table name. I want to get everything from the table. Oops, nice post I semicolon. And great. There is our table. This is looking good. And once again, let's try and get in one thing from the table. So select all from restaurant by countries of the table name where the country equals the string Singapore. Okay. And that just puts in semi colons and hit enter. And that should return back the singular restaurant. So the shark because that has the partition key of Singapore. Wonderful. Now, what do you think happens if we add another row that also has the country Singapore? Well, let's check it out. For this part, I'm going to involve you I'm going to break to an exercise. So what I want you to do is actually add a nother line. So now the road to our table that has the country Singapore, the name of the restaurant, the heart, the URL www.hud.sg and cuisine Lebanese, okay, so go ahead and add one row to our existing table. But before we do that, I'm going to ask you to refresh the page. So go ahead and click that. And wonderful. Go ahead. I'm going to pause here while you have a go at doing this yourself before we carry on together. Okay, so first things first you can of course is the describe key spaces command to list out all the key spaces in your database. Or you can just go straight to it if you know which key space You want to use. So I'm going to choose Use tabular, just like Sir, making sure that I am in the tabular key space. Next, I'm going to essentially insert a row into the table restaurant by country. So I'm going to do so like so. First things first, I'm going to use the Insert into command. And I'm going to insert into rest. Durrant by country, just like so because that is the name of our table, I'm going to insert a country, I'm also going to insert a name, I'm going to insert some cuisine and a viewer L. Okay. So that's what I'm going to do. And I'm just going to make a new line. So don't put the semicolon yet insert into restaurant by country. And then I'm going to put in values. And the values are going to be a string of Singapore. And then the name we said is going to be the heart. The URL is going to be WWE dot heart dot S, G. And the cuisine, which is the one we miss, I'm just going to go back. It's going to be Lebanese, Lebanese. Okay, so let's have a look. Make sure that it's all correct. Okay, great. And hit Enter. So now we have a look at everything. So select everything from restaurant by country that we go, you will see that line has been added, a new row has been added. So now if we do select everything from restaurant, we could actually just press up. And then we go where, and I'm going to get the partition key. So country equals Singapore, what do you expect will happen? Tada, we get back the two restaurants that are in Singapore. Wonderful. So that is essentially how you'd group data together in your table and retrieve that group data back. Now it's time to move on and look at document database types, document or document oriented database types are arguably one of the easiest types to do. This is because they require no schema. So before in the tabular database, we had to define the columns that made up our table. With this, we don't have to do any of that. As long as our data comes as an object, it's fine. The objects are made up of keys and values look like this. So this is an example of perhaps an item you might find in a to do list. So here you have an object which I have given an ID with a zero, a title with fixed bike as a string description with a string and done which I have in this case, given a Boolean that is not strict. The values can be strings, numbers, Boolean arrays, or even objects themselves. This is called JSON, or JavaScript Object Notation, and is the most popular format for document database types. Now, a group of documents is called a collection. So we will not be using the word tables anymore. It has been replaced by collections. So keep that in mind moving forward. So what are we waiting for? Let's get to it. In this next section, I'm going to make a collection of to do items using a document API. Now for those of you who haven't heard of the term API, let's do a quick crash course first. And API stands for Application Programming Interface. They allow for technologies to essentially talk with each other and are essential to serve the services we rely on today. They are behind most apps we use on a day to day basis. And they can shape information paths between one technology to another. And they connect things such as our cars, purchase pens, or anything really, to the internet. API's are everywhere. As a developer, you might use the Twitter API to get like tweets on your site, a Map API that will allow us to get data from a third party to use a new delivery app we are building or even use them in a two way stream to get post or delete data from a customer relationship management system. For example. There's a reason why these words are popping up. And let's go into why. In this next section, you're going to be seeing these words I'm using them to communicate with the database you make. In this context. They are called HTTP request message. That's the most common are the get request, post request, PUT request and delete request. There are others too. But for the sake of the tutorial, these are the ones you need to know. Get essentially gets data. And that's all it does. So imagine you have a client or another word, your computer and a server, you are on your computer. And the URL, which is where you want to get your data from is on a server, the client. So once again, your computer sends an HTTP get request to the server to retrieve the data we want. So here we have a get request or a visualization of a get request, the client is requesting the server gives it the necessary resources we need. Then, after the server has sent the response, so request and response, we say that we've got it. Thank you. After the server sends a response, it closes something called a TCP or transmission control protocol connection. We also have a POST requests and put requests. So here we have a visualization of how the request would work with post requests. So simply sending something to the server. And with the PUT request, which are the same, we are sending something to the server. But essentially to edit something or override it, we will go into this in the next section. And of course, a delete request to a delete request will essentially delete something that is pointed to an idea or endpoint. So to get interacting with my data, you will see these different endpoints, simply put an endpoint is where a resource lips. So with this endpoint here, forward slash burgers, I will get all my burgers, I can also create a burger to the same endpoint. To create a burger. However, I use the post haich TT method. As we discussed, I can also edit a singular burger, also, as we discussed. And of course, we have delete, which you guessed it will delete a singular burger if we provide the end points with the ID. Okay, so hopefully, this theoretical example has made sense, let's get to using our knowledge in our project. Okay, the first thing we're going to do is actually create a new key space, I'm going to call this key space document, I'm just going to go here and save it. There we go. Okay, so now we've got two key spaces, I'm going to keep the workload separate. So one for tabular, and for document, because we're going to be working with document types in this section. So to do this, I'm going to choose to connect to my database using the Document API. However, before we do that, we're gonna have to get a token in order to communicate with our database. So to do this, I'm just going to go to settings. And then under Application tokens, organization settings, click that the role I'm going to select as an admin user, and I'm going to generate a token. So this is the token we are going to use, please, of course, do use your own, I will be deleting this after this tutorial. So just go ahead and copy that and make sure to store it somewhere safe. Okay, great. Now, once you've done that, just go back. And this time, we're not going to use the SQL console, we're going to use this connect tab. And we're going to use the document API to connect to our database. Okay. So all I'm going to do is launch swagger. And this will load some swagger Doc's for us that will be useful in communicating with our database. Okay, so this is all pre made for us. There's not much we're gonna have to do, we're just gonna have to fill out some blanks. The first thing I'm going to do is actually create a new empty collection in a namespace. Okay, so before, as mentioned, we work with tables. Now we're going to be working in collections. Okay. So once again, we were working with tables before. Now we're going to work with collections. So I'm going to create a new empty collection in the namespace and just click Try it out. And all I'm going to do is fill out all of these empty spaces that have been created for us while We are here is actually important to note that you can write your own code for these requests. So at the moment, we are in a post request, I will be showing you how to do this in the project portion of this course, for now, we're just going to make use of this pre configured UI to help us make these requests. So all I'm going to do is actually put in my Cassandra token in here. So that's the one that we just created. And under the namespace ID, well, we know that our namespace that we just created, or in other word, a key space is called document. So that's what we put in here, document, okay, not tabular document. And next, we're going to have to put something in the body of our requests. Okay, so we're going to have to put in some JSON with the name of the collection. So all I'm going to do is choose what I want to call my collection. And I'm going to choose to call it my first collection, just like so. Okay, so you open up some curly braces, this is how Jason looks, we open up some curly braces, we put the string of name as we are prompted to, and the string of my first collection. Wonderful. So now we can scroll down. And just click execute, and then wait for our response. And as you can see, that has returned with a status code 201. Okay, status code 201. So that has worked. If you don't know about service codes, that is a really handy website, I'm going to show you with all the status codes that could return, it illustrates them with little dogs. And it's really easy to understand, this is something that I use quite a lot in my day to day, developer life. Okay, so we have now created a collection called My first collection, let's carry on, just going to delete all of this, and cancel that. And now the next thing I want to do is put something in our collection, right, so I'm going to create a new document to do this. Once again, I'm just going to click Try it out. And I'm going to fill out all of these spaces. So once again, it's putting the token that we just created. Next we need the namespace, or as it's called on our platform, the key space. So once again, I'm going to put document and in the collection ID. Well, the collection that I want to put this in is called My first collection, because we just created and in the body in the body, I'm going to put in my first item into the collection. And this is what I want it to look like. Okay, so once again, we have the curly braces about the string of ID, which I'm going to give it as one, I'm going to give it the title of make dinner. And then the description of make dinner to apologize for breaking my housemates bike. And done is a Boolean of false. Okay, so this is the first document I want to put into my collection is just an object that has some information, okay, I can make this information, whatever I wish. So this is what my information looks like. Let's carry on. I'm just going to click Execute. And there we go, we get a 201 code. And that has responded, we also get a response with this, which is the document ID. So the document, we just created the one with ID one, the one about making dinner has this document ID, this is its identifier in our collection. Okay, great. Now let's get to using this ID. So now I'm going to show you how to do two things. I'm going to show you how to search for everything in a collection. And I'm going to show you how to search for one thing in a collection. So let's start off with the first one faster search for everything in a collection. To do this, I'm going to just select search documents in a collection. And once again, I'm just going to put in the Cassandra token. Let's click Try it out. I'm also going to put in the namespace or key space as it's called on our platform. So I'm going to put in document for the collection. I'm simply going to put my first collection, and then I'm just going to execute it. Okay, so I'm just going to scroll down and hit execute. And there we go. We get a status code 200. And we also get the response body. So that is responding with all the data in our collection. At the moment. There's only one item Okay, so it might be a bit hard to tell you might think it's just bringing about one item but it's in fact bring back all the items in our collection. Great Now I'm going to show you how to pick up an item based on the document ID. So the thing we created in the part just previous to this. So to do this, I'm actually going to use the document ID. So let's just go ahead and grab that. And then let's go to get a document. Once again, let's click Try it out, I'm going to put any document ID, and then I'm just going to fill this out. So once again, the collection I'm looking at, and it's called My first collection. And then the namespace is called document and the Cassandra token, well, we just need to paste that in. And click Execute. And correct. So we're returning that one item from our collection. Okay, based by its document I do. Okay, so now that I've shown you how to create a collection, add a document to collection, get all the documents back, and just search for one document in the collection by document ID, I'm just going to show you how you would do this in the project part. So all we're going to do, or essentially all of that is happening here on this platform is that we are constructing a URL. Okay, so every time you fill out a field, you are constructing this long URL. As you can see here, we've populated it with a namespace, a collection and a document ID. So this is exactly what we will be doing in the project part, we're going to be making a request to this URL, however, with authorization. So at the moment, if I just take this URL, and I paste it in the browser, you will get a message that says role an authorized for this operation, missing token. Okay, there are tools that we can use to help us if we do want to view this before building our project, one tool that comes to mind is a tool called hopscotch that I use quite often. And then all you would do so I'm just going to gravitate to hopscotch. And I'm simply just going to create a new request here. So all I'm going to do is put in the URL that we just created, making sure that the method is a get request, okay, because we are getting the data. And I'm simply going to put the Cassandra token that we have. So the one that we've saved the really long one in the header. So once again, I'm going to get that token, and first actually going to get x Cassandra tokens, we can identify it, and then I'm going to paste my long token. Okay, once again, make sure that this is a get request because we are getting data from the database, and Qlik. Sense. Wonderful. So now we get a status code 200. And we also get some response, we get the response body to be the document we have just created. Great. Before we move on, I'm just going to show you how to do one more thing. And that is search for something by a filtered field. So what I can do, I'm just going to go to search for documents again. And in here, I'm just going to add a where string. So this to jog your memory is how we return all the documents back from a database, I can also filter out which ones I can filter them out by title. So for example, I can choose to filter out to this this syntax for filtering out, I can choose to filter out by say title. And anything with the title of make dinner will be returned back to me. So once again, I'm just going to do that that is the syntax for filtering out all of my documents and search for any one that has the title make dinner, or any multiple ones that have the title made dinner, and then click Execute. And anything with the title made dinner will be returned back to me. Okay, great. Okay, so now that we have done that tiver a little exercise. Based on all the learning that we have done so far, how would you go about creating a new item to put in our collection? So at the moment, we have one item in our collection called My first collection, I would like to add another. So which of these do you think I should go to? That's right, I will need to make a post request to this URL, and replace namespaced ID and collection ID as well as provide my authorization token. So let's go ahead and do it. I'm just going to refresh this so we can start a new and click here. So once again, I'm just gonna click here to try it out. Under the Cassandra token, I'm just going to put in my token, the namespace ID or as we know the key space ID is called document and then the collection ID is called My first collection. And now we need to create our document. So I'm going to create an object for this, I could simply just have an ID like so let's give it the ID of two, and then a description. And then make it clean dishes after dinner. And if I executed that, that would work. However, I have chosen to keep all my objects the same, that is a personal choice. So let's go ahead and add a title. I'm going to make the same title that I did last time, and I will show you why. So there we go, title description, and then done, I'm going to give it the value of false, that does not need to be in quotation marks, that is a Boolean value that I'm assigning to the property done. Okay, so now if I click Execute, we get a 201 code with the response body that has come back with the document ID for this document right here. Okay, so we've added one more item, I'm just going to add a another item, let's make this ID 10. Let's give it a different title. So fixed shoes. And take choose to fixed with done false. And once again, I'm just going to execute that. So what that means is, I now have three items in my collection called My first collection. Two of them have the title make dinner, and one has the title fix shoes. Now, if I wanted to bring back all the documents, or the title make dinner, so all of them associated with making dinner, how would I do this. So once again, three items in my collection, I only want to bring by two, and that includes the ones that have the title make dinner. That's right, I would have to make a GET request to this URL. So replace the namespace ID, the collection ID and provide an authorization token. So once again, I'm just going to click to try this out, I'm going to grab the Cassandra token, the namespace ID I want to look at is called document or in other words, the keyspace name, the collection ID I want to look at is called My first collection. And this is the syntax for filtering out I want to filter out by title and want to make sure that that title is equal, making sure to put this in quotation marks equal to make dinner, which is case sensitive. Okay, so that's the syntax. And what do I expect to come back, I'm actually going to set the page size, let's just make it Max 20. So if I add more than two, for example, and I only want to 20. To come back, this is how I do it. And then I'm just going to click Execute. And there we go. So now we can see that two items have come back to us, this one, this one, and we do not see the item that has the title fix shoes. Great. And once again, all we have done is generated this URL by filling out all of the above. Okay, so what I am doing is, there we go, we see the namespace has been replaced, you will see the collection name has been replaced. And if we look where well, we are looking for a title equal to make dinner. And we only want to bring back Max 20 items. Wonderful. So I hope you've learned a lot in this section. Please do pause here, I can't stress enough how much I recommend pausing here and having a play around with all the different requests you can make. So for example, if you want to delete a document, or update a document to please have a play around with that, and once you are done, I will see you in the next section. In this next section, we are going to look at the key value databases. They are considered to be the easiest database type and usually come looking like this. So you have a key column and then you have a value column. You can actually have as many value columns as you wish. The important thing here is that we can retrieve data back to us. So an entire row by the key as that is the identifier in this case. Let's have a quick look at an example of a key value database and how to make one next Okay, so I'm going to click here and just add key value, and click save. Okay, great. So we can now see another key space has been added. Now, this time, I'm going to use Graph QL, just as a little bit of something different in order to create our key value table. Okay, so this time, I'm going to choose to connect using the Graph QL API, just purely because we've already worked with the document API. So I'm going to click here, and just launch the Graph QL playground, just like so. Now, the first thing we need to do when we are here is to create a new table. So first off, I'm actually going to put in my Kasandra tokens are able to communicate with my database. So I'm just going to grab it, just like so. And now you should be able to see the documents populate with all the queries or mutations that we can do. So as I said, I want to create a table. So let's go ahead and do that. This is a mutation as it's under the mutations tab. And to create a table, just going to write create, table, and EZ Pass through the following things. So a keyspace name, a table named partition keys, and values. So the key space name, I'm just going to put this on a new line. Well, we know that the key space name is key value, as we've just created it. Now the next thing we need to actually do is give our table a name. So I'm going to call this shop inventory just like so. And the partition keys. Now, if you remember from the first section, our partition keys is essentially the key that we want to filter our table by or search for items in our table by and it says here that this needs to be an array. So that's what we're going to do, we're making an array. And then what do we want our partition key to be, I'm going to give it the name of Ki. And I'm also going to define the types that it takes. So I'm just going to put type, like so. And I'm going to pass through basic text. Great. So we have our key space name, we have our table name, we have our partition keys. Next, let's put in the values. As you will see, these all have a bank after them. So they are required values is not required, but we're going to need it for our table. So once again, I'm just going to put a comma and put in values. And this needs to be an array. So I'm going to open up the array, and I only want another one column. So at the moment, we've got one column, which is a key. The next column I want to have is values. So I'm going to name this value. And once again, I'm just going to give this the type of basic text, just like set. And if we click here, wonderful, we have created our table. Great. So we've created our table, the next thing I'm going to do is add keys and values to our table. So I'm just going to go ahead and delete this. And instead of having a Graph QL schema, I'm going to have Graph QL forward slash, and I'm just going to put in the key space. So key value, just like sir. and wonderful. So now we're in the key space key value, I'm going to use another mutation to see who the mutations and queries have changed because I can do a bunch of other stuff. I'm going to use the Insert shop inventory. Okay, so that is what I'm going to do and start mutation as this is a mutation. And I'm just going to say shop, insert shop inventory, just like so. And I'm going to use this to insert items into my table. So I need to open up some parenthesis, and then in here, well, I want to pass through a value. And that's going to have my key. So what key can we give this I'm just going to put an A string as we said it needs to be text. And I'm just going to choose to give it this key. So this identifier just like so. And then the value of let's have beans. So what I'm saying with this code is that I want to put in this row into my table that I have just created and the row will have the key of this The value of beans, meaning that if I want to search for beans in my table, I would use this identifier. Okay, so I'm just going to also have to return something. So we know this works. So I'm just going to return the key and the value. Click here. Wonderful. So now we know that we have inserted this one item into our shop inventory into our table that we have called shop inventory. Let's just add another item. So I'm just going to make this random once again. And then another item we can put in his shell. And just click Yeah. Great. So now I'm going to actually retrieve this data. But first off, I just want to show you what this looks like if we use the sequel console. Okay, so I'm going to go back here. And under the secure console, well, I am just going to write, use key value, because we need to get the key space. And once we are here, I'm going to use the command describe table. Shop inventory. Okay, so we can see here, we have added that table, that table exists and exists in the keyspace key value. And now if I want to grab everything from the table, well, hopefully you remember this from the first lesson, select all this essentially means all from shop inventory, making sure that I spelt it correctly inventory. And there we go. We have a table that has a key and a value. And we can find any item in our table. So any row by the partition key or the key right here. Great. Okay. So hopefully, you can see how we can make tables using the key and value approach. Just while we're here, I'm going to show you how to retrieve all the data from our table using Graph QL as well, just in case you are not familiar with Graph QL. This time, I'm going to have to have a query. So I'm going to write a query just like so. And I'm going to look in the shop inventory. Okay, so I'm looking in the shop inventory. And what do I want to return? Well, if I just want everything, then I would simply put values, key value, and click enter. And there we go. We are getting all the items from our shop inventory table. Okay, so if you want to use this in the project, and you want to get all the items from your shop inventory, this is the query that you would use. Wonderful. Okay, before we move on, I'm just going to do a little exercise to see if you've remembered what we've learned. So I'm just going to get rid of this. If I want to add one more item into the shop inventory. How would I do this? And what two things do I need to check? Well, first off, we need to check the we're in the correct URL. Okay, so we need to make sure that the URL is pointing to the key space. In this case, its key value, because that is what I call my key space. And that I also have my Cassandra token in the header. Okay, so those are the two things you need to check. And once you have checked that we can write a mutation, okay, not a query, a query essentially retrieves back data. And a mutation adds data deletes data, or edits data. So for this, because we are adding a new item into our shop inventory, I need to write a mutation. And that mutation is insert shop inventory, because I'm inserting into the table called shop inventory. Okay. And what do we need to put in here? Well, we need the values of key and value. And what are we going to have the key well, at once again, I'm just gonna put in a random string like that as an identifier. And the value this time I'm going to put, I don't know, Coca Cola. Okay, great. And just to check this as work, I'm going to return the values of key and value. I could technically just return one, it is up to you, and just click here. So now because that has returned, we know that has worked. Brilliant. Now, how do you think and this is something we haven't covered? So this is going to require you to have a little bit of a think based on what I've told you. How do you think we would delete an item from the shop in entry. Well, that's right. Because we are changing the data, we're going to have to find a mutation that will delete from our shop inventory. And because we find stuff by the partition key, so this, we are probably going to have to delete an item by searching for this key right here. So let's check it out. So I know this is going to be a mutation. And I can also look in the docs to find the Delete shop inventory mutation to help me out. So that is a mutation that I need delete shop inventory, and I'm just gonna pass through the values of key, I'm just gonna grab this one right here, I'm just going to return the value of key. Okay, and that should have worked. Let's go have a look here. And once again, I'm just going to chop list out everything in my shop inventory. And amazing. So we added the Coca Cola, and then we deleted the Coca Cola to great. Now, if I was to say try delete something by the value, so let's go ahead and put sham and then just return the value, we will get an error. This is because we cannot delete by the value we have to delete or the primary key, which we set to be the key. Okay, wonderful. So I hope you've learned a lot in this section. And I'll see you in the next one. In this next section, we are going to look at Graph databases. Graph databases are a great way to store data that has relationships between other pieces of data, or in other words, notes. Each node is connected by an edge to represent this relationship. Think for example, your friends on social media, he was you and here are three of your friends. So you and your friends are nerds. And the connection you have is represented by this line, or as we are going to call it from now on an edge. Easy, right? But wait, your friends can also be friends with each other. So how do we represent that? Well, by adding more edges to represent the relationships, and as your friendship circle expands, the more complex it can get. So that is the simple idea behind how graph databases work. Let's see it in action. In this section, we will be doing an overview of an already existing demographic database. The GitHub repository for following along will be given to you in the description below. So once it gets to that, please go ahead and find it below. Okay, so this time, we are not going to be using the datasets Astra interface, we're going to be using the data stacks enterprise graph. Okay, so let's go to it. For this part, you're going to have to have Docker installed. So please go ahead and download Docker if you don't have it already installed onto your machines. Okay, so once you have it installed, it should look something like this. All you need to do when you're here is just click the settings and make sure that the CPU and the memory, the swap and the disk image size are all around about these levels. Okay, so that is what you need to do. Make sure that you have at least two CPUs. So here you see eight, and at least three gigabytes or RAM. So these are the settings you need. Once you have them. Let's carry on. And once you have that done, I'm just going to ask you to get up your terminal. And then in whatever directory you wish, please write the following command. So please go ahead and write the command Docker network, create a graph and click enter. So what you should have is this long ID right here. Okay, so once you have that we are now ready to carry on. This is your identifier for the graph. The next thing I'm going to ask you to do is clone this directory. So this is directory I will be putting at the bottom in the description. So just clone the data stacks tabs workshop introduction to no SQL and click enter. Now I already have that in here. So I'm just going to go into the directory, CD workshop introduction to no SQL and once we are in here We are free to start the container. So what I'm going to do is Docker compose up D, and then wait for that to open up empty localhost 9091. So this will take a while please feel free to pause here have a break. Let's get back to it once all of this is complete. Okay, great. And now let's go ahead and visit localhost 9091. Okay, so this is an example from data size itself, please feel free to use it and adapt it as you wish. And there we go. So this is what you should see here is the example that is given to us from data stocks. Let's go ahead and first check our connections. So I'm just going to click here and on connections, it's going to click on this one right here. And just make sure that this is on DSC. Okay, so this essentially is pointing to our local Cassandra. So once that is done, let's test it out. And great, so we are connected successfully. Let's carry on. Now, let's go back to here and just click on this example one, like so. Now, you will see that you're prompted to create a graph. So let's go ahead and create our first graph. I'm just going to keep it as to do tutorial graph like so. So just leaving all the default settings. Okay, and I'm just going to click Create. Wonderful, our first graph is now created. Now if you move down here, you will see a language called Gremlin. Okay, this is the language that we are going to use for this tutorial, it is essentially another query language. Okay, so we've looked at SQL, we've looked at C QL. And now we have Gremlin it is a graph traversal language, okay, and it has been developed by Apache TinkerPop of the Apache Software Foundation. With this language, we are essentially creating schema, okay, so just like we have been doing, you will see here that we are adding a schema called God. And we are giving a partition key. In this case, it's going to be the name, which is some text, and it also has a property, which is age, which is an integer, and we are creating it, we are also creating a demigod which has the same partition, a human again, which has a partition key of name, a monster, a location and a Titan. Okay, so here we have the code in order for us to essentially create our first graph, all about gods and demigods and monsters. So I'm just going to click here to run this. So run this in real time. And wonderful, that has been a success. So, now, if we look down to here, you will see some more code again in the language Gremlin. So just like we created labels here of God, demigod human monster, we have now also included edges. So these edges are essentially how each one is going to be related. So this edge is called Father. So this is going to show us a relationship of father and son or daughter. And then also we have mother and brother, too. And it will also give us the direction. So a god is essentially the father of a demigod, but also can be the father of a god if someone is a Titan. Okay, so that is how that looks. Let's carry on. If we move down, we can see more edge labels. Okay, so we can also write a relationship of who's battled who, as well as father and brother, we can also do where someone lives, or if someone's a pet, and so on. And finally, we can actually add items to our graph. So this is how you would add some items into a graph. So for example, here we are adding Saturn, we are saying this is a Titan, we are giving it the property name of Saturn and we are giving an age of 10,000 and so on. And we do this for all these other items as well. Okay. So there we go, we are defining the items and we are defining the relationships between the items, or in other words, the edges between the nodes. And finally, we can have a table of what this looks like as well. So here we can see this in table format. But what is more interesting is the graph view. So this is essentially what our information looks like once it has been graphed out with nodes and edges. So the edges symbolize the relationship. So if you have a deeper look at this, we can actually click on these, and it will give us more information. So for example, this is a monster of Hydra, you will see the name it has as Hydra, you also see as the labor monster, and by its node, you will see that it's battled the monster service. Okay, so there we go. This is a great example of how graphs can really illustrate information and an amazing way. Now, this has been a lot shorter than the other tutorials. This is because I just wanted to show you how you can work with graph databases, it will involve learning the Gremlin language, but I think this is a good place to start in order to get your head around it. So I'm going to leave this information to you, I'm going to put the link in the description. And please do have a go at getting this up yourselves and having a play around with it as well. So if we want to add one more thing into our database, we can do it right here. And just don't forget to run it. So now because there isn't much of an exercise here, I'm just going to give you a pop quiz. When working with graphs, what would these be called. So these right here that I'm putting out this little red guy right here, these monsters, and this god. These will be called nodes. And what connects the nodes? That's right edges. So once again, these are the edges. And if we actually gravitate over them in this UI, it will give us the relationship between each note. Okay, so as we can see here, we have a little house, the location is the sky. And then this is where Jupiter lives because he loves the fresh breezes. Wonderful. Okay, so I think we are done with looking at graphs to power this down, I'm just going to run a command, it's going to be Docker compose down, and just hit enter. Great. So that is all four of the database types. I think we're now ready to move on with some projects. Now that we have covered the four main database types, I want to quickly talk to you about the multi bottle type. In this course, let's actually recap what we've done. Well, we created a database right and in it, we stored the key value pairs as for the first tutorial, after that we stored Jason document in Astra DB as per the document type tutorial. We then store data in tables as per the tabular tutorial, section two. And finally, we stored graph data. So that's a variety of different data models, all stored in one place by the graph one. All of this is possible because Astra DB is actually a multi model, no SQL database, you can use the same database to store a variety of data models. What is cool about this is that you also only need to learn and maintain one database which makes your job easier. Learn one database and use it to solve many different problems. Okay, wonderful. Now, hopefully through the explanations, examples, and exercises you are now feeling a lot more confident is not only understanding the different types of no SQL database types, but also how to use them. If not, don't worry, I have two short term real life projects that we're going to build in order to show you how you would interact with your databases when building JavaScript projects. By using a data API gateway like Stargate IO, Cassandra and Astra D view, developers can opt to use a Graph QL rest or schemaless JSON document API as an alternative to C QL. Let's do it. Okay, and let's get to it. In this project, I'm gonna be showing you how to use the document type as well as the document API. In order to create up first project. This project is going to be a app which will show you all your favorite burger restaurants. Okay, so let's get to it. I've actually started with a fresh board. So you will notice there are no key spaces, and we're going to have to go ahead and create our database again. So I'm just going to go here, and let's call our database project work and our keyspace Bogguss. And then once again, I'm just going to have to create the area that I'm in and create a database. Wonderful. So you will see my database is being created and you will see the status is pending and I'm just going to wait for that to be active so that I can go ahead and start using it. And wonderful, the status is now active, let's go ahead and use our database. So to do this, I'm just going to double click in here, and you will see the key space name of bagus. Now, let's get to adding some data. I'm going to do this thanks to the document API as stated. So first off, we need to create a token. So I'm just going to click in here. And the role I'm going to choose is admin user. And I'm just going to create a token. Once again, please make sure to keep this token safe, I would strongly recommend saving it somewhere useful. Okay. So once we have that, let's go back to this documentation right here. Let's go ahead and launch the Swagger UI. So I'm just going to go ahead and click that. And these should populate in front of you. So we have a lot of options here. And a lot of endpoints. If you remember from the tutorial, the one I need first is this one right? Here, we need to create a collection in order to store our data. So I'm just going to go ahead and click that and click Try it out. Once again, I'm just going to paste the Cassandra token in here so that we can essentially communicate with the database. And then let's go ahead and choose the namespace. Or in other words, the key space, we want to create our collection in as we have just created it, this is fresh in my mind. And I know that the keyspace name is bogus. Wonderful. And in here, we just have to pass through an object that has the name. And then whatever we want to call our collection. So I'm going to call this burger info. Just like so. And I'm just gonna click Execute. And great, we get a 201 code, we've made a request to this URL with our new authorization token. And the status code we got back was 201. Or in other words, let's have a look at the status docs again. Or in other words, to have one for created. Great. So now that we have created our collection, what's the next thing we need to do, the next thing we need to do is add some documents into the collection. So I'm going to go ahead and do it by selecting this one right here. It is a post request to this URL. So once again, I'm going to choose to try it out. I'm going to paste in my Cassandra token, the namespace or the key space ID that we want to communicate with is called burgers. The collection ID we just created is called burger info. And then the body is essentially the document that we want to put into our burger info. So I'm going to choose my document to look like this. I'm going to give each restaurant a name. So for example, Bob's Burgers. So that is a string I've chosen to give it the string of Bob's Burgers. I'm also going to give it a description and I'm going to say tasty burgers from a fictional character from TV, so we've got the name, we've got description, we can also have ingredients and we can do this if we wish as an array. So in here I'm going to put a patty to beef patty. I'm also going to put tomato let's also put some cucumber, some lettuce and some cheese. Okay, so those are my ingredients. I don't only have to put strings in here. I can also put an array of strings if I wish. Okay. And one last thing that I want to show you is okay, we can also have Boolean I can have visited, and I can have true. And then I can also visited have objects within objects. So if I put location, like so, as a property, I can have an object as a value. So that is also an option. Let's go ahead and do that, I'm just going to open up my objects. And in here, I can have so location, address. And then have that to be us string if I wish. So 45, lambda lambda. Drive, I can also have a, let's do zip code, which is an integer. So I'm going to make this up. And then I can also have the web address. So this is just going to be WW do W dot Bob's burgers.com. Okay, just like that. So we have a string here, we have a string here we have an array of strings, we have a Boolean, we also have an object, which has an address, a zip code as an integer, and a web address as a string. Now let's have a look and see if this is working. We could also give it a unique ID, we don't want it to count from zero. So perhaps let's go ahead and do that. I'm just going to go ahead and maybe let's start from 340. Why not? Okay, so now let's execute this. And great. Our first document has been created. And we also get a document ID that has been assigned to this object right here. So we have one, let's go ahead and add another. So I can just do so from here. Let's go ID 341. This time, let's go Matilda's. And Matthews, man hot turn Burger Joint. And then let's change this up. They have a tofu patty. Tomatoes, let's have a pickle. So pickles. Let's also have some letters. And then we can have Bri visited I'm going to put as false. And the location let's change this up. So I'm just going to put in a random location. Let's put Denver Avenue SIC code once again, I'm just going to make this up. And then let's put and progress and just click Execute. Great. So we have two documents in our Bulga info collection. Let's just add two more. So I'm just going to change the ID again. And then let's have gertrudes place hipster and gout in the city as the description and I'm going to have a beef patty. Let's have perhaps something else here so called Slow pickles, lettuce and there's cheeseless cheddar. This is it I'm going to have as truth and the location. Let's have one or three darling turn. Drive. Once again, just make up the zip code. Go through its place.com and just click Execute. Let's go ahead and just add one more. So there we go. And then let's have fancy burgers. A new location for Burger snobs. Some beef patty? Let's also have a onion ring in this one. Some pickles some letters. And let's just have some generic cheese visited, I'm going to put out false location, I'm going to put one, Walter Street. Make this up. And have and see progress.com and click Execute. Great. So now we have four bugs in here. But let's just double check this has worked. So to get all of our burgers back, I'm going to search documents in a collection. So I'm just going to go here, this will be a get request, as I'm getting the data, I'm just going to paste in my token right here, I'm going to look in burgers. That is the I quote my keyspace. The collection ID is called burger info. And then I'm going to say that, I'm going to have a max of 20, come back, and I'm just going to click Execute. And there we go, we can see all four of our Bogguss coming back to us. Great. So that is exactly the data that we need. Now let's get to using this in a project. So essentially, what I want to do is build a project in which I'm going to be making a request to this URL right here and passing through my authorization token. So let's do it. I'm just going to go ahead and open up WebStorm. So I'm going to go my WebStorm project. And I'm going to say this is a React project. So let's call this Barger app, just like so I'm going to use the Create react app command in order to build out a React project for me all configured so we can go. So I'm just going to click Create. And as you can see, that command has sprung into action. And I'm essentially just downloading all the dependencies, fetching all the dependencies and packages that I need in order to get the boilerplate for my react projects. Of course, if you're not using WebStorm, please go ahead and get to this point as well. All you need to do is create a project it will directory using the command MPX create react up. Correct. So now that we have that, let's get to it. So as you can see here, the MPX create react app has essentially populated all this for me with the following packages and ran these following scripts. Okay, so these are the dependencies that have been installed. And these are the files have come with create react app. So if I actually run this, I'm just going to go ahead and click npm start, like so this is essentially what should show up on localhost 3000. Okay. So that is something that you should be seeing right now, if I go ahead and actually delete all these files, so I'm actually going to go ahead and just do some deleting. So here is our app. This is essentially the spinner that we saw. So you will see here the spinner is this right here. I'm going to go ahead and delete all of this like so. If I actually just go Hello, I'm going to show you how this looks. Okay, as you can see that is working. So that is updating. So I'm just going to delete this for now, I don't need a logo, so I'm actually going to get rid of that. I don't like to semicolon. So I'm just going to delete that. And I like to use functional expressions. So I'm just changing this as this is my preference, but you are free to keep it as as you wish. So there we go. We don't need the logo. So I'm just going to go ahead and delete that from this project. Don't need the report by tools. So I'm going to delete that. Delete anyway, let's delete the tests as well as we're not going to be writing tests for this project. And let's delete this test file. Okay, great. I don't also need I'm actually going to delete the CSS file as I'm going to be doing all my CSS in this index. CSS file. So I'm going to delete this I'm just going to put all my styling in one file for this Project. So there we go, there's our app js file. And if we look in here, we don't need this as we've just deleted it. We don't need this as that is now non existent. And once again, I'm just going to get rid of the semicolons. Like, so. Okay, wonderful. Let's just check, we didn't break anything. And this is looking good. It's good, my console locked up, too. Okay, so now that we have a blank slate, let's get to actually getting our data. So to do this, I'm going to have to create a little mini backend. So just in the root of my project, so on the same level as Git ignore, I'm going to create a new file, just a new file like this, and I'm going to call it index j, s. Okay. So there we go. This is essentially going to be my mini backhand in which I'm going to build a backend using Express. So first things, first, let's decide what port we want our backend to run on, I'm going to say that I want my port to run on 80,000 8000. Sorry. And we're going to have to install a few dependencies for this, one of them will be Express. So we're going to use Express for this project. And use require Express. So I'm just going to get up my terminal and install Express like so I'm also going to need cause Morgane node fetch so we can do fetching in the backend, and dot EMV for storing secret variables. Okay, so please go ahead and just install these dependencies, and I'll talk you through them as we use them. Okay, so I'm just going to leave that to install. And let's go ahead and just actually use them in the backend of the project. So require package cause. And then const. Morgan equals require Morgan, Morgan is actually a package that we're going to use in order to, I'm going to show you what it looks like. So I'm just going to go, Morgan is essentially going to help us debug the backend better and make everything a little bit more readable. So this is the package, if you want to have more of a look. It's essentially a little logger, that will give us more information when we use it. And once we do use it in our project. So once we do essentially do this, so we're using the package or storing it as Morgan we've done the same, we then need to pass tiny into Morgan. Okay. So this is essentially what is going to let us debug better. So as you can see, I've got the package, and I'm storing it under the constant Morgan. And I'm just going to use Morgan and pass through tiny so we can use the logger better. Great. So we've got Morgan, the next thing I need is a package called node fetch. And this essentially works sort of similar to the Fetch API, and will allow me to make fetch requests on the so just like that, that's how I'm going to use Fetch. Just to be sure that everyone is using the same packages, please be sure to be using these packages that I have right here, there could have been updates. So to prevent any issues, just make sure that these other ones you are using, or if you're in doubt, please feel free to check out my GitHub project that I will share with you in the description of this video below. And finally, we also need the.in v to.in. The package will allow us to read secrets from the back as well. And this is how you would initiate it. Okay. So all I'm doing is actually getting this from the documentation. I'm doing this from memory as I've used these so many times. But if we search here here we go. As you will see, all I'm doing is taking this and using it in my project in order to use the.nv package. Whoops, please spell that correctly dot CSV. Okay, great. So this is looking good. Now let's initialize Express. So the package that I have just imported and stored as Express, I'm now going to initialize like so. So now if I use up like this, I can use Morgan tiny in my back I can also use course, this will essentially stop me from having any cause issues, I will show you what I mean by this when we get to building our app a little bit further. And then I can also use Express, Jason. Okay. And this will essentially allow me to read the Jason in a way that I can use it in the backend. Once again, I will show you what happens when I don't use this. Okay, so just make sure to have all of these, like so and all this boilerplate done, so we can start coding. Okay, so please pause here, make a note of this, I'll make it a little bit bigger, so you can see everything a little bit clearer. Once again, things to remember are, please do make sure index js files in the root of your project. Okay, so on the same level as package, Jason, and then this is the boilerplate setup that you need in order to get going with our backend. So the first thing I'm going to do is get all the restaurant data. Okay, that's the first thing you can do. And I'm going to show you how. So to do this, and once again, you can use app like so. So app is essentially what we saved express as initialized expressed as, and now I'm not going to use use, I'm going to use get. And what I'm going to pass through into here is an endpoint that I'm going to choose. Okay, I'm going to choose this by myself. I want to say that if I visit localhost 8000, which is going to open this up in a new tab, if I visit localhost 8000, forward slash burgers, I essentially want the burger data to show up. Okay, so that's what I'm writing here. By putting forward slash burgers, I'm deciding that this is where I want my data to populate. Okay, great. So that is the first thing I'm going to do. Before we get going actually, let's listen out to see if the server's working. So this I would do it once again, if you use up this, I'm going to use listen. So not to use and not get, I'm going to use listen, I'm going to listen out to port 8000. And it's all working, I'm just going to console log out. Server is running on port, and then whatever the port number is. Okay, so this is looking good. Let's also write a script for this because we don't have at the moment. So I'm just going to go in here and start front end. So I'm going to keep that script, but I'm going to say stop front end needs to be written in order to start our app. So our front end, and I'm going to add a new script. So this time, if I start backend, like so then I just want to run the backend. So that's the command to do so. Okay, great. So let's go ahead, and I'm going to stop this from running. I'm going to change the script to start front end and run it. Okay, so the front end should have started. And now I'm going to open up a new tab. Okay, there we go. So that's just running. Let's go back to our project. And now I'm going to open up a new tab. So new tab in our terminal. And this time, I'm just going to run this command that I have written. So NPM. Run, start back end. Okay, great. And I'm just going to comment this out for now. comment this out for now because we are not using it. And there we go. Okay, server is running on port 8000. So this is looking good. Obviously, at the moment, we don't have anything coming back. So I'm just going to continue with this. So if we visit this endpoint, what do we want to do? Well, we want to fetch the data. So for this, I am actually just going to don't have a request or a response. Let's just have it in here for now. And we might change that later. And then Okay, actually, let's just get rid of it. So we'll just have a function a callback to be precise with passing through a callback. And then we need to essentially fetch data from the URL. So if I just save this as URL for now and make this a little bit smaller, we essentially want to fetch data from this URL right here. So I'm just going to copy that, I'm going to paste it as a string, like so. Okay, so that's all I have done for now. Okay, we will be tightening this up. But this essentially is what this looks like at the moment. So there's a URL, now I need to make a get this is a get request. So let's go ahead and do that. So now it's time to use Fetch. So fetch takes a URL, okay, which is essentially this. And we're also going to have to pass through our Cassandra token Ks, or our authorization token. So I'm going to do this along with options. So let's define our options. So const options like so. And in here, we know that the method is a get method, okay. And we also need to pass through some headers. So the headers that we need to pass through, we need to accept this like so as a string. And we also need to pass through the X Cassandra token. Okay, so we need to pass through essentially this, just like we are passing it through. Okay, you will see this is part of the header. Okay. So essentially what is happening behind the scenes here, we are now coding out. So I'm just going to once again as a string posts, my token. Okay. So now when we make a fetch, let's just uncomment this out. Now, when I fetch I am passing through this year, well, we are fetching data from this URL, it is a get request. And we are using this in order to pass through our Cassandra token. Okay, great. So we are making a fetch, and this is going to return a promise. So I then need to chain it with the then keyword. And the response is going to be the response. Jason. And this is also actually going to return a promise. So we need to chain it again. And this time, I just want to get the Jason Okay, so great. Now we do actually need to pass through a request and response. So let's just do that now. Okay, so whatever's coming back to us, we need to view as JSON and then let's catch any errors. So I'm just going to catch the errors by console logging out any errors that will turn so we can see. Just like so. Okay, so there we have it. There's a lot of tidying up to do. But let's first make sure that this works. Just make sure that is in the string itself. Cool. So let's give it a whirl. Now if I visit localhost 8000, forward slash burgers, this is the endpoint that I have chosen. Tada, you will see all my four buggers show up. You will see each object has its own document ID as well. Great. If you're not seeing it in this format, it could be because you don't have a Jason view extension added. This essentially will make your your JSON much more readable. Okay, so if you don't have that, please go ahead and add the extension. Now. This is what it should look like. Okay, wonderful. So we have our data coming through. Now let's get it into the front end. But first, I'm just going to tidy this up real quick. So we don't need this anymore. Okay, keep that as it is the URL. So essentially what we are doing is Passing through the key space, which is burgers and passing through the collection name, okay, so you could save it as separate things and pass it through. So for example, I could say key space as the name, focus, and then pass it through into here with this syntax, like so. So what's gonna go barbers and then make sure that these are backticks. So there we go. So that is an option to if you want to make things I'm sorry, that should be key. So what do we save this as key space, key space. So that is an option if you want to make this more readable, or you can and this is what I'm going to choose to do. Because we are not going to be changing this is pretty much going to stay as it is, I'm just going to get the whole URL just like so. And I'm going to save this as a secret. So I'm just going to go in here. And once again, on the same level, I'm going to create a new file, I'm going to call it dot n fi. Okay. And now I'm going to save this in here as endpoint. So just like so. And I'm just going to paste it in here, just like that. So there we go. And now to access this right here, I'm going to use process NV and put, okay, so this wouldn't work if we didn't have this package and didn't use it just like so. And now I think we have to rerun this. Let's just check that out. Okay, now that seems to be working as it is. Great. So we've saved our URL as a secret back here. One other thing that I'm going to save is my Astra token. Okay, so there we have it. And once again, I'm just going to save all of this is going to grab that as it is, and use process. EMV. And then whatever we call it in our Astra dot EMV file is what we need to call it here. So let's say that and I'm just going to paste that in here like so. Okay. Great. And that seems to be working just fine. Okay, so we've cleaned this up a little bit, got a URL, we're passing through the URL and the options into fetch. And great, one thing we can do is write some middleware. So if I write function not found, and we post you the request the response and next. And then in here, if we get a four, four status, so let's go back to our status dogs. Okay, so you will see that for four means not found. So if we get a four of four, well, then I'm going to get a new error, the error is going to say, not found, so we're just making debugging a bit easier with this, we're going to get the message that says not found, okay, so that is what we are going to do. And then if it's none of these, we move to the next function, which is just an error handler in general, and it's going to be less specific error. And law. We're gonna pass through the error to this error right here. And then request and response. And this time, if the response if the status code is whatever the status codes, it's, so wherever it comes back as or 500. So any error or sorry, any status code or 500, then I want to send a message. That is, whatever comes with that status code. Okay, so there's two ways of doing it. So I'm just going to show you what this means. Okay, so now let's get to using it. So once again, I need to right up use and I'm going to use the function not found and I'm also gonna pass through the function error handler, just like so. Okay, so what I've written means that if I say misspelled this URL, if I wrote burgers like that, I get the message, not found, I get the error message, not fat. However, if I didn't have this, so I'm just gonna come on out, and I go to here. Oops, actually would have this. See, it just says cannot get burgers, it doesn't really tell me why it doesn't give me enough information. However, if it's not found, so for for iMessage, telling it to show me an error that says not found, okay. So that is how we do that. And then any other error, we get a different error message. So we essentially just get the error message that goes with these status codes. But this way, we can be more specific, I can go pay, you are in the wrong place, buddy. Hey, we're on their own pace, buddy. Okay, so cool. It's gonna pull it back to something more general. Okay, so we are guessing all of our baggage data. Now let's get to using this in the front end of our project. So once again, these are all the packages that I have used, or the dependencies I've used, just make sure that you're using the same versions. Okay, great. Now, let's carry on. So essentially, for my front end, so we can shut down the backend. Now, in my front end, I essentially want to get all the data from this URL, so we can use it. So let's go ahead and do that. To do this, I'm actually going to import a nother package. So I'm just going to get up my terminal. And I'm going to install the package Axios. Okay, this package is essentially going to help you make the requests and fetch the data. So let's go ahead and do it, I'm going to write a function right in here. So a function to get the data and we're just going to call it constipation data, like so. So this is a functional expression. And this is actually going to be an async function. Now, to fetch the data, I'm going to use Axios. So let's import Axios, import Axios from Axios. Once again, this is the package that I am using Axios. So import Axios from Axios. And now I'm going to use Axios. And we're going to make a GET request to get the URL, this URL right here, because Okay, so because our backend is running, that should work. Of course, if our back end stops running, that we will not be able to get to this data. And this, we need to use await as that comes back with a promise. And let's save this as broker data, just like so. So they should get the data. And now I'm actually going to save this. So I'm going to use use effect to const. Burgers, set burgers, if you haven't used US state sorry, use state is the one that we're going to use. And we're going to use this to set the state in our app. So of course we have to import it. So I'm going to import that just above here. Import. Use state. We're also going to use use effect I might as well just import that too. We can short spell it correctly. From react, okay, so there we go. So essentially, if I now use set burgers, so at the moment, our state for burgers is now but if I use set burgers, I can set boggers to whatever I wish and I want to set it to the ogre data, just like so. Okay, so let's check this out. Let's see if this is working. So what I now need to do is going to use use effect for this. And I'm going to pass through a callback function that will essentially fetch my data, just like sir. And I was going to pass her an empty array, so that this doesn't keep on fetching over and over again. So let's go ahead and do that. Let's see if that has worked. I'm going to console log bogus. And see what happens. So let's go back to our front end. So localhost 3000. Just inspect the page, a console, log out. And there we go. So this is what burgers looks like. Now we actually just want the data. So we're going to go into the burger data, data. And there we have our four burger objects. Great. So I'm just going to go ahead and do that. So burger data, data. Data. Let's see what that looks like now. Okay, great. So there we have it, we actually have an object of four objects. Cool. So this is looking good. There you go. As you can see, there they are with their ingredients, and occasions and so on, I'd actually like to make an array out of this, so it's easier to work with. So I'm going to show you how to do that. So just here as well, I'm going to change this into an array. Let's actually just save this as data this time. And I'm going to get the burger data data. And for each one I'm going to, so let's get object keys for it. So I'm going to make some object keys for it. Because at the moment, it doesn't have anything to sort of differentiate each of the objects. And I'm going to map. So each burger object I'm going to turn into I'm going to grab it from the burger data. Data, Data. And I'm going to turn it into put it into Okay, so now whatever comes back, I've said that as data, and that is what I'm going to say, Save As my buggers. And there we go. So we now have an array of four objects, each with an object key. Wonderful. I wonder if I do need these object keys, or if that will just work without it? No, we do need we need the object keys. Okay, as does what we are essentially working off. So there we go. Wonderful. So we have our four burgers. Now let's get to actually displaying them in the browser UI. So let's do it. So for this in here, I'm actually just gonna create a data go into my favorite burgers, the styling for this is going to be extremely minimal. As we have a lot to go through. I don't want this to be all about styling, I want you to actually learn how to retrieve data into an actual project. Okay, so I'm just going to do this, I'm going to create a div and this is going to be the bag of feed, maybe give it a class of burger, fuge. Just like so burger feed. And in here, I'm just going to create a card and this is going to take our burger data. So let's actually map over each card. Let's actually create a chord first. So in here, I'm actually going to create a folder or directory called components. So new directory, and it's called components. And then in here, I'm going to create a new file and score card J S, just like so. And then let's create our card. So const card, and then I'm going to return at the moment, I'm just going to return two types like that. And I'm going to use export default card not first to use this card. Okay and other files. So now in here, I'm going to import the card input card from make sure to get the path correct. So in here, opponents Right, yeah, okay. Then, called J S. Cool. We actually don't need that. Okay, so this is fine. So now we've imported the card. And at the moment, we aren't passing anything through into the card. However, I can actually start this up. So let's go ahead and I'm just going to give this a class name just so you can see what's going on a little bit file. And I'm going to say card. And now in here in my style sheet, anything with a class of card, I'm just going to give a give a height for now of 200 pixels. a width of, let's say, at view width, and a background color. Of what color should we go cornflower blue border, radius 40 pixels. Okay, so at the moment, I've just put in a card. So there we go. That is, that is my card. Now if I map all my data onto this, okay, onto each card, it will actually produce as many cards as I need. In this case, it's going to be four. So let's go ahead and do that, I'm just going to pass through some props into this card. So I'm going to pass through Well, first off, maybe let's just map. So let's get our burgers map. We're going to map each burger, and I'm just going to get that and card and I'm going to pass through the burger data. Okay, so this is looking good. As always, we should probably have a key with this. Let's just see how this is looking. So there we go, we've created four cards, as we have for burgers, let's actually add the key prop as well. So I can use the key just use the burger ID as we do have one. So let's go ahead and do that. Okay, so we are creating the burgers, let's maybe give each packet some padding as well. So margin, even margin pixels, just so it's a bit more space out and on the card itself, or passing through the burger. So I'm going to D structure the burger like so the wise we don't have to get the props. So I'm just destructuring the burger. And then it's me, this may be a little bigger. I'm going to sit in here. Grab that at each of these. So let's give them an h2 tag. Let's pass through the burgers name. See what that looks like. So there you go, you will see the burger name is being shown just right here. What else can we pass through, we can pass through the burger description. Maybe let's make this a p tag. So there we go. And then we can also pass through as much information as we wish. So maybe let's put in a another P tag and call this burger. What did we have? Location? And then burger location? Address. Okay key location, web. I think that was one of them. Or was it just website? Website. You can always check what it was. Go and hear what the description, got the name description we've got visited. We have location is web address web zip code, probably don't really want the zip code. So I'm just going to keep it as Web. Okay, so there we go. And then we could also hide it if we've been there or you know, which would mean we'd only see the ones we haven't but that is completely up to you. Okay, in fact I'm going to do this so if Berger visited is true. Then we want to hand back. I don't know what we can return back to sort of freestyling here, a div that has the class name. visited. Otherwise, we could just go if it's not visited, there's probably neater ways to do this, I am just freestyling here at the moment, as I said, when we can do not visited, and it will show based, or show this div if we visited it, and this one if we haven't visited, so then I can go visited and just sign up. And if it's visited, I can just give it green, or red actually, let's make it red height 30 pixels with 30 pixels. Border. Radius 15 pixels, background color, red as we don't want to see it and if it's not visited, we'll give it a green. Okay, and let's make this Okay, so there we go, we know that this means we visited and the green means we have not visited these ones yet. You can replace this with icons, I just wanted to show you one way of doing that. Wonderful. Okay, so this is how you would get data, usually document a p i, and also using the Document Type. Okay, I'm just going to start this up a tiny little bit before moving on paddings give the study pixels. Let's make all the font white font color. White, of course, please feel free to you know, take this project really improve on it go crazy on the styling because that part, my friends is up to you. This is not a styling course. Whoops, cannot Okay, so we just have to what is happening here? It's gonna come out from now. Okay, so it's not picking stuff up in here. This is because sometimes the burger data might not come back fast enough. So I'm just going to put that right here. Okay, good. Okay, so it might not read it first time. So the first time this renders the burger data might not exist, which is why we put this question mark here. And when it re renders then that will show these cuts. Okay, great. So this is looking a lot better. Great, and then I'm just going to override the font if there's an h1 tag and give it the font. color. Black. Cool. And let's just go back here. That back. Wonderful. And one last thing I would do on that is center everything. So on the body itself, I'm going to do display flex justify content, center text align, center. Great. So wonderful. I hope you've learned a lot. Once again, this code will be available to you in the description. If you're watching this in the future. Some of these packages might have changed, just make sure to use these same packages for this project. Wonderful. Thanks for watching and onto the next project. In this project, we're going to learn how to use the Graph QL API in order to build out a hotel app. Okay, so once again, I'm going to start completely from scratch in order to build out our react up. First things first, I'm going to create a new database. So hopefully you are familiar with these steps already, if you have been following with this tutorial. So what should we call our database this time, let's go ahead and call it whatever we wish. So I'm just going to call it project work again. Just like so. And it's cool are keyspace name hotels. The next thing I'm going to do is just select where I am at the moment. So I'm going to go ahead and let's pick Europe and West Europe and just create a database. Okay, so there we go, there is our database it is currently being created, you will see the status as pending. And we're just going to essentially wait until that is active in order to start working with it. And there we go. So let's go ahead and click into here. And then here we will see our keyspace. Now, the first thing we're going to do is just head over to the connect tab in order to start working with our Graph QL API. We're going to be using this documentation right here to help us. So the first thing that we need to do is just create a new application token. So I'm just going to click here to do that. And once again, I'm going to select the role I want. I'm going to choose admin. However, there are many others with different mutability levels. And I'm just going to create a token. Once again, I'm just going to copy this right here and keep it somewhere safe. Now, once we have done that, I'm just going to close that down. And I'm going to launch the Graph QL playground by clicking right here. So there we have it, there's our playground and a row to communicate with our playground, we need to just put the token we have just created in the HTTP headers, just like so. So now we can communicate with our database. Let's go ahead and create our first table. So I can use the docs to help me with this. So this is the mutation I'm going to be using. Once again, if you watch the tutorials, you will know that we have queries and mutations to our disposal queries will essentially find data for us. And mutations can create, delete and update data for us. So we need to create a table. So I'm just going to get rid of this. And this is a mutation. And the mutation that I want is create a table. Now if we look under here, you will see that to create a table I need to the bank indicates that this is necessary, I need a key space name. So let's go ahead and pass that through a key space name, I'm going to put this on a new line. And the key space name has to be a string. So I know that my key space name is called hotels, okay, because that is the key space that we named it right here. So if I go back to my databases, hotels is the key space name. And then the table name, this is something that I'm going to assign right here, I'm just going to call it hotel data. So I have just chosen to assign this to the table name right. Now, the other necessary thing that we need is a partition keys as an array. So let's go ahead and add that partition keys as an array, and I want my partition key. So if we just click on here, I need to give it a name and a type. So I'm going to go ahead and do that, I need to give it a name, which is a string. So I'm going to choose to sort all my hotels by a ID. And then I also need the type. And the type that I want this to be is actually going to be basic text. As I don't want this to be an integer, I want the ID to take letters and numbers. Okay, so that is one column that we have made. So far the partition keys. If I want to add more columns, however, I could do so thanks to values. So once again, values is an array. So I'm just going to my values. And if this is one column, this is actually the column we are going to filter by and search by. And all these additional ones are going to come back if we search for this column. So let's add another column. Again, we need to have a name for this, which is going to be the hotel name and the type for this. I know that I want this to be text. And if we want to add more columns, so at the moment, we have one column, a second column, and I'm going to have three columns in here. So this is actually going to have the rating. So I'm going to call this rating. And I'm going to give this an integer. Value. Okay, so there we go. So now if we run this mutation, great, we have created our table. Wonderful. So now that we have created our table, let's get to adding data into our table. So all I'm going to do is navigate into my key space. So as you can see here, datasets is actually generated the URL for me, I need to go into the hotels. So I'm just going to go up here. And instead of Graph QL schema, I'm just going to go forward slash hotels to make sure that I'm in the correct key space. Okay, so there we go. And now, instead of creating a table, if I look at the docs, they will be changed, I need to insert hotel data. So now this is the mutation I need. Once again, it's a mutation as we are going to be inserting data. So let's get up mutation. And this time, I need to use Insert hotel data, just like sir. And what do we need to put in here, in order for this to work? Well, I need to put through a value, okay, and that is necessary that has got a bang there. So we have to do it, I'm going to give it a value. And this time, I'm just gonna give it the ID, I'm going to make up an ID. I'm also going to give it a name, so the name of the hotel, let's say Abby's hotel, and a rating, which is an integer, so I'm going to give it a four out of five. So let's just actually put this on different lines of just like so. And let's just return back the value of have a name to check this has worked and click Run. So great, we have just inserted some data into our table. Okay, let's go ahead and just insert some more. So I'm just going to change these around a little bit. This time, I'm going to call this set Tories give it a rating five, there we go. That has worked. Let's give me another it up. This time, it's gonna go motel, Mays rating of three. And then one more, and this one is going to be awesome. Hotel and give it a rating of five. Great. So now we know we have just added four hotels into our database. But how can we actually see this? Well, for this, we need a query. So to query this, I would simply I can go here and have a look, if I need the queries, I need his hotel data. So I'm just going to write a hotel data like so. And because we are not filtering out by anything, I can just get the values and then choose whichever values I want to come back so I can get all of them, I can get the ID, the name and the rating. And just click that. Or I can just get the name and ID. So that will return back. Or I can just get the name, whatever you wish. So however you write that query is what will return back to you. I want everything. So I'm just going to do that. And there we go. So that is essentially the query that we need in order to get all of our data from our database. And we also need this Cassandra token as the HTTP header. And also this URL, as that is where essentially our data lips. So let's go ahead and do it. Let's start up our project now. So all I'm going to do is get my WebStorm up and just create a new project. Once again, this is going to be a React project. So I'm just going to use this and I'm going to call this hotel up just like so. And using MPX create react app. This should create a project for me with all the React configuration ready to go. So I'm just going to click sexer. And there we go. You will see my hotel app project right here and all the dependencies being installed ready for me to use. Of course you don't have to use WebStorm. If you're using another code editor or IDE that is absolutely fine to just make sure Get Up to this point where your project is installing all the dependencies ready to go. And great, we are ready to go. So the first thing that I'm going to do is actually just delete anything we don't need. So here are all the files that have been generated, as well as the package and all of its dependencies and scripts. So in here, I'm actually just going to get rid of the logo as we're not going to need this anymore. So just delete that. Anyway, I'm going to delete the report of vitals and setup tests. So once again, just delete that as we don't need it anyway. And then I'm going to delete the app CSS file, as I want all my styling to be in the index CSS file, and just delete the app, test J S and just delete that. Okay, so this is looking good. Just going to minimize that. And delete this as we don't have any more I'm going to delete the semi colons as I'm not a fan of semi colons. There we go, save that. And then in the app js file, I'm going to delete all of this as we don't need it anymore. And once again, get rid of the semi colons, and we don't need the logo as we don't have it. We don't have this file, either. Okay, so this is looking good. Now, if we run this, I'm just going to click this to run the start script. You should see the project show up here, we've got rid of all the styling, so you should just see a blank slate, like so. And let's get up our console log. Wonderful. So now that we have that, let's get to making some requests. So I'm just going to minimize that for now. In the previous project, we built a little mini backend using Express. However, this time, I'm just going to show you a different approach. And that is using Netlify serverless functions. So to do this, let's get off our terminal and let's install the Netlify command line interface. So we can use it to npm install. Net LIFFE phi CLI, and I'm going to install it globally. Okay, so that is what the juice for that is to install that locally and just let that run. Okay, so I'm going to leave that to do its thing, the next thing we're going to do is actually create our first serverless function. Okay, so when that is done, I'm just going to ask you to create a file in the root of your project. So make sure it's at the root of your project on the same level as the package, Jason is going to minimize that new. And the file is called net live by tunnel. Okay, and in here, I'm just going to give you some code to put in in order to build out the sub list functions. So this you can just copy, these are some commands that we're gonna have to put in here in order to build them out. functions here is essentially the whatever you call the directory you want to store your functions in. So let's go ahead and create that, I'm going to create that on the same level. So just make sure that's in the root of your project and call the directory functions just like you did here. Okay, so that is where we're going to store our functions or serverless functions. And then we just need one more. Command. Okay, so there we go. Make sure to write this exactly as I have written it in a Netlify TOML file in the root of your project. Great. So now that we have done that, I'm going to create my first function. So making sure you are in the functions directory, create a new JavaScript file, and call it whatever you want your function name to be. So I'm going to call this get hotels. And this is a JavaScript file, so that will add the J S extension. Now with any surplus function Netlify serverless function, this is the syntax that you need. So let's go ahead and write it. I'm going to have to write export handler This is an async function. Let's make this a little bit bigger. Nicholas who no And then we are going to have to essentially fetch some data. So just like we did before, so we're going to import another directory. So we're going to get node fetch, I'm just going to install it right now. API node, fetch, and let that install. Okay. So while that is installing, let's go ahead and use it in this file const, fetch equals require node fetch. Just like that. Now, as we know, with fetch, we pass through two things. And that is a URL and options that will have our HTTP header along with the authorization token. So let's go ahead and do that. So once again, let's write the URL. And we know that the URL, so let's go back to here is this right here, and this is where we're gonna make the requests to. See, I'm just going to paste that in here, like so. And then Let's also get our options. So const options, say this is const URL. And the options are going to have a method, which is a get request, and the headers, okay, the headers, which will consist of the content type. Content Type, and the X, Cassandra token, okay, so there we go, I'm just gonna make this the same, as we see here exe Cassandra token, and I'm just gonna grab that. So the whole thing and just put it in here, just like, so. It's gonna make it single quotes. Great. So we have our options. And then we also have our new R L, format this a little bit better. So URL options, I'm going to use Fetch. However, this time, we're actually going to save whatever comes back from fetch. So we know this promise, const response. So whatever that returns back, we're going to save as response this time. And this is not all we actually need to do. And because this time, we actually have a query to pass through, okay, so we do have a query to pass through. And that query is I'm just going to save up here. So I'm going to save as constant query. And I'm just going to use backticks for this. And I'm going to paste in my query. So let's go in here, this is essentially the query I want to make. So I'm just going to paste that in here like so, maybe formatted a little bit better. We need to pass that query through in with the options. Okay, so this is no longer a get request, as we are posting, we are sending this query. So make sure to change this to a POST method. And let's get to passing through the query into the body. So I'm going to pass through the query, but I need to pass it through JSON stringify and then pass through the query like so. Okay, great. So that is looking good. We are now passing through the query in with our options, so along with the Cassandra token, the method and then we are putting that into the fetch that we imported from node fetch. Great. Now we're going to use try and catch in order to do this. So this is the syntax, we'll try and catch we've got try and I'm going to catch any errors. So e4 errors. Okay, and to try to do this, we actually have to make sure this is all in the export handler. So let's just grab that and make sure that it is here. We are going to what essentially we're getting the response I'm going to call this was response body. So we could use this, but we also need the JSON from it. And this returns a promise. So I'm going to have to use await in front of it just like sir. Okay. And then if that comes back, then we're just going to return a status code of 200. Because that has worked. And then we are going to show in the browser, the response. So I'm going to use JSON, string five for this to work, I'm going to show the response body in the browser, and if it doesn't work, where we catch the errors, and we're just going to console log the errors, okay? We can also of course, return a status code to someone do return status code 500. And I'm just going to show the error in the actual browser too. So let's use Jason string phi and pass through if error. Okay, so this is looking good before we clean this up, let's just check that works. So to do this, I'm gonna go in here and I need to run the command Netlify. Net LIFFE pi, Dev. And that is do it's much okay. So there we go localhost 888. Let's inspect the page. And now if if we want to get that data, if we want to run this function, essentially, I need to go into functions and get hotels. Okay? Oops, make sure this is an s. So, I'm going to go forward slash.net. LIFFE fi, forward slash functions as the directory that we created and then get the Taos and wonderful. So now we are getting all of our data. And Wonderful. So is saying something's already running on port 3000. I thought I did shut this down. But I didn't cancel. Okay, so we need to stop that running. Make sure that stopped. Okay. Essentially, what is happening here is that localhost 888 is now our front end. Okay, so we don't want anything running on localhost 3000, because we want everything to be running on here. Okay. So that's what we want and to, and essentially, our front end, and our backend are now on this URL. So here we go to get our data. And here is our front end. Great. So I hope that makes sense. Once again, just make sure that Netlify Deb is running in order to get that to work. Wonderful. So once again, I'm just going to show you the package Jason, these other packages that I am using, if yours have changed, or if you're watching it's in the future, then please use these for the tutorial in order to get this code here to work. Okay, so there we go those other packages that you need, along with their versions. Wonderful. Now that we have our data, let's get to clean this up a bit. So just like we did before, I'm going to create a new file, a dot n v file in which we're going to store all our secrets. So once again, I'm just going to put the endpoint in here. And I'm also going to put in my Astra. So just like that, and then from here, I'm just going to get this URL to get the whole thing. Put it in here. And I'm also going to get my token, okay, so that we go, just like so doesn't need to be a string. You can just save it like that. Okay, and now this means I can use process EMV in order to get my Astra token. And I can also use it to get the URL, but now it's hidden. Okay. So now it's a bunch safer, and points. Great. And we have to actually inject these variables. otherwise this won't work. So I just inject the variables by running Netlify dev again. So just like Sir, okay, and you will see injected endpoint and injected Astra token. Okay. So there we go. Let's try that again. Only absolute URLs and point and point and point A misspelt endpoint. Okay, so once again, I need to re inject the tokens and nullify Dev. Wait for that to be run. And Wonderful. So now we have a URL or get back our data. As long as the backend is running, let's get to using it in the front end. So I'm done with this. For now let's have a look if this needs any cleaning up, so here we have all the code that is necessary, this will be available to you below. So please make sure to use it, you don't actually need to pass through an event for this. This is looking good. Okay, so there is all my code. Great. Now let's move on to the front end. So here is my front end. As you can see here, once again, I'm going to have to essentially fetch the data. So I'm just gonna do fetch data just like we did before, we're gonna make this an async function. Okay, let's change this to a function expression just because I prefer working in this way. And now let's actually fetch the data. So now this time, I am going to actually use Fetch. So the Fetch API going to await it as it's going to come back with a promise. And I'm just going to fetch this URL right here. So we're gonna copy that and paste it. And well, we don't need all of this, I can simply put forward slash Netlify functions get Hotel. So that is essentially the same thing. Okay, so we're getting the data from that. And then let's go ahead and save it as something. So I'm going to save it as just the response for now cost response. Great. So that's the line we need to write. Now, once we have whatever comes back from us. So the response need to get is Jason. However, this also returns a promise. So we need to use a weight. And let's say this as the response body this time. And we're going to have to actually save this into state. So I'm just going to import use state and also use effect as we're going to need it later. From react. Okay, awesome. So we've got the response body, let's actually save it to the state of the app. So let's use what should we have hotels, set hotels, and then use state? I'm going to start off with the state. No. Okay. So all this means is that at the moment, hotels is now and I can use set hotels to make hotels, whatever I wish. But at the moment, we're starting out with hotels being not so this gets passed on to that. And I can use this to also change that. So I'm going to use the set that tells to change hotels to the response body. Wonderful, I think let's check out if this has worked. So I'm going to now use use of fact. And then a callback function, you don't know about use effect, I would suggest doing some research on these hooks at the moment. So use effect, just like so I'm going to fetch the data, okay. And then I'm just going to put up an empty array, so it doesn't keep fetching that data over and over again. So I'm going to call that and now let's console log with health to see if this has worked and to see what's being returned back to us. So now, let's go back here, and just go to the front end. And there we go. We are getting the response body data, data, hotel data. So data, who told data values is what we need, and that is an array. So I'm just going to go back here and go response body data, hotel data values. Okay, in order for that to bring back just the array, and there we go. We have an array of four tells. Wonderful, let's carry on. So now that we have that and we have checked that that has worked, there's the whole code in its entirety. Please feel free to stop here and make a note of it or just catch up, press pause and if you What up, let's carry on. So just like we did before, I'm actually just going to map out all the hotels, I'm not going to create card component this time as you know how to do that. So I'm just going to grab the hotels if they exist. And I'm going to map so dot map. And for each hotel, well, I wanted to return a div. Let's give it a class name of a towel. And then in here, let's put an h1 tag that has the hotel name, a p tag that has the hotel, what are the other ones hotel name, then we have a hotel rating. So let's see how that looks. And there we go, we get all four of our hotels with a little rating, too. Now, let's get to setting this up a little bit. So here is my app, I'm just going to get my CSS file. Let's put everything in the body as justify content. Center, of course, we need to use display flex to initialize this. And align text, text align, apologies, text, align, center. Okay, so that is looking good. And anything with a class of hotel, I'm going to make sure that the background color is salmon. And border radius is 50%. Okay, so maybe that's a bit too much border radius, we can of course, change it as maybe make it just 10%. Or whatever, really, that you wish it is up to. Yeah. Great. So of course, please, again, feel free to go wild on the styling, I don't want to go too crazy on the styling. This is not what this is about. This is a tutorial to show you how to get data into a project. Okay, so I'm just going to put my hotels here, and we will let's make this an age. Tag, like so. Great. And maybe let's give it some padding from the top, let's give it 10 pixels. And from each side, I'm going to go 50 pixels to make it look really long. Okay, and then also margin. five pixels. Correct. Okay, so hopefully, you've learned a lot in how to get data, this time using Graph QL. And the Graph QL API, if you want to learn more about how to make more advanced requests. So in making the functions including stuff like pagination, I do suggest watch my Netflix clone in which we use Graph QL to do this, okay, so that is an option for you. Please try go ahead and watch that, if you wish, it is reviewed by an actual Netflix engineer. Once again, the code for this project will be available in the description below. And that's it. So to recap, during this video, cause we have learned what is no SQL, SQL versus no SQL and why you can't compare them types of no SQL databases. So document databases, key value databases, wide column stores or tabular databases, graph databases and talks about the multi model databases. We also talked about how to get data into projects with to real life examples, and also how to look at the document API and Graph QL API as we did this. So action packed course really. And if you're looking for ideas on where to go next, to really solidify your knowledge, I would recommend using the Document API and SDK to build your own Tinder app with me here, or using the Graph QL API to build a Netflix clone here, or even learn how to federate data from two database types with my Graph QL Federation crypto app right here. Thanks so much for watching and I will see you again soon.
