With timestamps:

00:00 - thank you
00:03 - [Music]
00:04 - [Applause]
00:05 - [Music]
00:09 - what's going on guys welcome to amigos
00:11 - code my name is nelson and in this
00:13 - course i'm going to teach you everything
00:15 - you need to know about functional
00:17 - programming with java
00:19 - so when i first saw functional
00:21 - programming i was like you know what is
00:24 - this i saw functions by function
00:26 - predicates being used all over the place
00:29 - and to be honest
00:31 - i only realized the power of it when i
00:33 - learned about the clarity of programming
00:35 - so you see most of us write imperative
00:38 - programming which means that you define
00:40 - every single implementation detail of
00:43 - your code whereas declarative you simply
00:45 - tell it what you want instead of
00:47 - defining you know the details for
00:49 - example you might have a variable or
00:52 - actually you might have a loop
00:54 - right so you define you know the initial
00:56 - value how to increment it and how to
00:59 - stop it right so with declarative
01:02 - programming you have none of that you
01:04 - simply tell it what you want and that's
01:06 - what i'm going to teach you in this
01:07 - course
01:08 - so in this course i'm going to teach you
01:10 - exactly you know what the differences
01:12 - what the differences are between
01:14 - imperative and declarative programming
01:17 - and why you want to move away from
01:19 - imperative programming then i'm going to
01:21 - teach you about the functional
01:22 - interfaces that java has to provide so
01:25 - functions buy functions predicates
01:28 - consumers suppliers
01:30 - and all that good stuff right so once
01:32 - you learn that you can then start to use
01:35 - streams and optionals to write code in a
01:38 - declarative way and then towards the end
01:40 - i'm going to teach you one of my
01:41 - favorite design patterns when it comes
01:44 - to functional programming and that is
01:46 - the combinator design pattern which is
01:48 - really really awesome it's really good
01:51 - for validation where you simply define
01:53 - all of your validations in an interface
01:56 - and then you define exactly step by step
01:59 - what you want your validation to be it's
02:01 - really really awesome and finally i'm
02:03 - also going to teach you exactly about
02:06 - lambdas callbacks and
02:08 - the properties of functional programming
02:10 - so that you fully grasp exactly the
02:14 - whole concept
02:16 - so if you haven't subscribed to my
02:17 - youtube channel go ahead and subscribe
02:19 - because that way i can you know provide
02:22 - more awesome content like this without
02:24 - further ado let's go ahead and learn
02:26 - everything you need to know about
02:28 - functional programming with java
02:37 - all right so before you start this
02:39 - course i want to make sure that you
02:41 - really
02:43 - learn from this course because i want to
02:44 - add value so what i want from you is to
02:47 - go ahead and practice as i teach because
02:50 - that's the best way for you to learn any
02:52 - new technology
02:54 - also go ahead and join the private
02:56 - facebook group so if you have any
02:57 - questions you can go ahead and engage
02:59 - with other students and the group is
03:01 - full of cool people just like you
03:05 - so this is all i wanted to say for now
03:07 - and enough of me talking let's go ahead
03:10 - and learn about functional programming
03:18 - all right let's go ahead and bootstrap
03:21 - our application where i'm going to show
03:22 - you all the examples throughout this
03:26 - course so i've got intellij right here
03:29 - and if you've never used intellij then i
03:32 - highly suggest you to enroll to my free
03:35 - course where i teach you pretty much how
03:37 - to use
03:38 - this awesome ide and to be honest as a
03:42 - software engineer this is probably the
03:45 - ide of your choice when it comes to
03:48 - java back-end development
03:50 - so let me go back to intellij
03:53 - and
03:54 - the first thing i want to do is to
03:55 - create project
03:57 - and right here i'm going to pick maven
04:00 - now the project sdk it doesn't really
04:02 - matter whether you use java 11 12 or any
04:06 - other version as long as is above
04:10 - 1.7
04:11 - so i'm going to stick with 11 right here
04:14 - and as i said the version does not
04:17 - matter
04:18 - next let me go ahead and click next
04:20 - and then right here for the group id i'm
04:22 - going to say com dot and then amigos
04:26 - and then code so right here this could
04:28 - be your own organization
04:30 - and right here let me simply name this
04:33 - as java and then functional
04:39 - and then i'm going to press
04:40 - next and then i'm going to save this
04:43 - under code and then java functional
04:46 - and then simply press finish
04:51 - there we go let me actually collapse
04:53 - this maven tab right here and also let
04:57 - me collapse this
04:58 - and right here go ahead and simply
05:00 - enable auto import to import
05:02 - dependencies
05:04 - and this is the actual palm file right
05:07 - so if i open the functional oh actually
05:09 - java functional folder inside you see
05:12 - that we have only the pump file
05:14 - and this contains the group id artifact
05:18 - id and then the actual version so let me
05:20 - just
05:21 - remove that line
05:22 - and also remove this pop-up
05:25 - and finally i'm going to put this full
05:27 - screen
05:29 - and this
05:30 - is all and actually let me just close
05:32 - this because we're not going to need
05:34 - this palm file and this is pretty much
05:37 - everything you need in order to
05:38 - bootstrap the application to follow
05:41 - along so obviously i'm going to give you
05:43 - the source code at the end of this
05:46 - course but i highly suggest you to
05:49 - practice as i teach because that's the
05:51 - best way
05:52 - of you learning any new topic this is
05:56 - all for now
05:57 - if you have any questions about intellij
05:59 - as i said go ahead and roll to my course
06:01 - right here where i teach you everything
06:04 - you should be aware of this awesome ide
06:13 - let me go ahead and give you an example
06:15 - of imperative programming
06:17 - so imperative programming involves you
06:21 - as a developer defining every single
06:25 - detail about your implementation
06:28 - so right here inside of the source
06:31 - folder
06:32 - inside of main and then java
06:35 - let's go ahead and create a new package
06:37 - so you can right click on this folder or
06:40 - i'm going to use keyboard shortcuts and
06:42 - also you can see
06:44 - down here so right here you can see all
06:47 - the keyboard shortcuts that i'm going to
06:48 - use throughout this course
06:51 - so right here i'm going to use
06:53 - the error so i'm going to select package
06:56 - and then right here i'm going to name
06:58 - this as imperative and then okay
07:01 - now inside go ahead and create class
07:05 - and this will be called as main
07:09 - now let me collapse this
07:11 - and inside i'm going to type p
07:14 - s
07:15 - and then vm for public static main
07:19 - there we go
07:20 - and now we have a main method that we
07:23 - can run
07:24 - so let's go ahead and define a list
07:28 - and the type of this list will be of
07:31 - type and then person
07:34 - so right here let me go ahead and simply
07:36 - name this as people
07:38 - equals
07:39 - to and then list
07:41 - and then dot and then off so right here
07:44 - what we're going to do is simply create
07:46 - few people or actually
07:48 - a few people of time person so right
07:51 - here let's go ahead and simply create a
07:53 - class so
07:55 - uh let's go ahead and say static and
07:57 - then class
07:59 - and then person
08:01 - and this person will have a name so
08:04 - private
08:05 - and then final
08:08 - string and a name
08:10 - and we also will define a gender
08:13 - so
08:15 - enum
08:16 - and this will be gender
08:19 - and the gender will be male or female
08:24 - and then right here what we're gonna do
08:27 - or actually underneath is simply say
08:30 - private
08:32 - final and then gender
08:35 - and that will be the gender
08:37 - and let me add this to constructor
08:41 - and there we go
08:43 - so now we have
08:44 - this class right here called person
08:48 - and let me also define a two string
08:49 - method right here so two and then string
08:53 - and there we go
08:54 - so now right here we can simply say list
08:58 - of
08:59 - and then new
09:01 - and then person
09:02 - and right here let's give it a name so
09:05 - john
09:06 - and john is a male
09:09 - and let me have a static import for this
09:13 - and let's go ahead and duplicate
09:15 - this so i'm going to press command d a
09:17 - couple of times
09:19 - and there we go so let's have maria
09:22 - and she's a female
09:25 - let's have
09:26 - aisha
09:28 - she's also a female
09:31 - just like that
09:32 - let's have
09:34 - alex
09:35 - it's a mel and let's finally have alice
09:39 - just like that and alice she's of course
09:42 - a female
09:45 - so
09:46 - now that we have this
09:48 - list right here
09:50 - let's go ahead and find out how many
09:53 - females that we have
09:55 - so
09:56 - the way that we will do it with
09:59 - the imperative approach is let me add a
10:01 - comment right here so in
10:03 - an imperative
10:05 - approach is simply by doing the
10:07 - following so first we need an empty list
10:11 - and then of type and then person
10:14 - and then let me simply say females right
10:17 - here equals to a list
10:20 - of
10:21 - and then or actually not even a list of
10:23 - let's go ahead and use a new
10:25 - and then array list so this is an empty
10:27 - list
10:28 - now what we need to do is to loop
10:30 - through people
10:32 - so let's go ahead and simply say four
10:35 - and then person
10:37 - and then person
10:39 - inside of people
10:42 - and right here we're going to say
10:45 - if and then person
10:47 - or actually let me go anything to say
10:49 - female
10:51 - and then dot
10:52 - equals to person
10:55 - dot and then gender just like that
10:58 - so if this is the case i'm going to say
11:01 - females dot and then add
11:04 - and then person just like that
11:07 - and that would semicolon and then right
11:09 - here at the very end what i'm going to
11:11 - do is simply print each people so again
11:14 - let me simply copy this
11:17 - just like that
11:19 - and then right here
11:22 - this instead of
11:24 - people
11:25 - this will be
11:26 - females
11:28 - and this will also be
11:30 - female
11:31 - and then
11:32 - south
11:33 - just like that so system.out.printline
11:36 - oops
11:38 - just like that and then
11:40 - female
11:42 - now if i go ahead and pretty much run
11:45 - this class right here so let's go ahead
11:48 - and run this class
11:51 - can
11:53 - and there we go
11:55 - so right here you can see that
11:58 - we have only females in our output
12:02 - and basically this is pretty much what
12:05 - imperative programming is so basically
12:08 - we are defining every single
12:11 - detail so right here you can see that
12:13 - first we have an empty list
12:16 - and then we loop through that
12:19 - and then we have an if statement
12:21 - and finally we have a final for loop
12:24 - looping through
12:26 - females and you can see that there is a
12:28 - lot of logic not you know you know a
12:31 - substantial amount of logic but you can
12:33 - see that for example this if statement
12:35 - is some logic and also you can see that
12:38 - this is a lot of code for something very
12:41 - simple and this is what i wanted to show
12:44 - you about the imperative approach next
12:47 - let's go ahead and implement this
12:49 - using the declarative approach and you
12:52 - will see that it's much neater
12:56 - and we pretty much just tell it what we
12:59 - want to do instead of defining every
13:02 - single implementation detail right here
13:10 - so to use declarative approach with java
13:14 - ia functional style programming we
13:17 - simply have to do the following let me
13:19 - let me collapse this
13:21 - so right here so what we're going to do
13:23 - here is
13:25 - instead of us creating a list
13:28 - and then having two for loops what i'm
13:30 - going to do is the following
13:32 - first let me go ahead and pretty much
13:34 - have a comment and right here this will
13:37 - be declare
13:39 - relative and then approach
13:42 - now
13:43 - the way that we use declarative approach
13:46 - is by using streams with
13:49 - collections
13:50 - so
13:51 - don't worry about um
13:53 - so much about what a stream uh is
13:56 - because i'm gonna show you exactly later
13:58 - on
13:59 - but for now just follow along so go
14:01 - ahead and simply say people so people is
14:04 - the original list right here so this
14:08 - list of people
14:10 - and then
14:11 - dot and then stream
14:13 - right here so now we have a stream and a
14:17 - stream allows us to go into an abstract
14:20 - mode where we simply tell it what we
14:23 - want
14:24 - so right here let's go ahead and simply
14:26 - say dot and then filter
14:29 - and what we want to filter
14:32 - is
14:32 - basically
14:34 - this so right here we have a person so
14:36 - this takes a person and then i'm going
14:38 - to say the exact same thing right here
14:41 - so i'm going to take this
14:43 - if statement
14:44 - oops
14:45 - let me press command w a couple of times
14:48 - command c
14:49 - and then put it here there we go
14:52 - so you see that i'm filtering and then
14:55 - this takes a person
14:56 - and i'm using this
14:59 - same if statement so basically
15:01 - female.equals and then person.gender
15:05 - right
15:06 - and then finally i'm going to say dot
15:09 - and then collect
15:10 - and then collectors
15:12 - and then to list
15:14 - end up with semicolon
15:16 - and
15:18 - right here what i'm going to do is
15:20 - put this on a new line
15:22 - and the same with collect just like that
15:27 - and right here
15:29 - we can simply now go ahead and simply
15:31 - say dot and then for each
15:34 - and then we can use system
15:40 - dot and then out
15:42 - and then column column and then print
15:45 - line
15:47 - so now let me actually add um
15:51 - right here so let me simply add this as
15:53 - a south so i'm going to print this
15:58 - just like that
15:59 - there we go
16:01 - and let me do the same here so i'm going
16:03 - to copy that
16:05 - and then paste that take this comment
16:10 - put it here so you can see exactly in
16:12 - the console what i'm doing
16:14 - so now
16:16 - you can see that
16:18 - this
16:19 - is much concise and right here you can
16:22 - see that i'm not creating a list and
16:25 - then adding to that list
16:27 - and then
16:28 - doing the if statement so on and so
16:30 - forth so you can see that
16:32 - is very straightforward and i'm just
16:34 - telling what i want so from the people
16:38 - array list or a list basically this is a
16:41 - list
16:42 - i'm going to stream so i'm going to go
16:43 - into this abstract mode
16:46 - then i'm going to filter all the females
16:49 - and then i'm going to collect to a list
16:51 - and finally i'm going to
16:53 - print everything so technically i don't
16:56 - even need this collector list because
16:59 - i'm simply printing out things
17:02 - so let me simply run this for now so you
17:06 - can see exactly what's happening
17:08 - there we go so basically you can see
17:10 - that we have the exact same
17:12 - output right so if i put this whole
17:15 - screen you can see that we have the
17:16 - exact same output but the declarative
17:19 - approach is much neater
17:22 - so obviously if you were to have this
17:27 - into a list right here so this is where
17:29 - collect comes into play
17:32 - and then i can remove
17:34 - this line
17:35 - and this with semicolon
17:37 - and then extract this to a variable
17:40 - and then say females
17:44 - and then two right
17:46 - and you can see that now i've got a list
17:49 - right here and i could again simply say
17:52 - females
17:53 - to
17:54 - dot and then for rich
17:56 - system dot out column column print
18:00 - line
18:02 - so if i run again
18:05 - you can see that this is the exact same
18:07 - output
18:09 - so there we go now you should have a
18:12 - full understanding of the differences
18:15 - between declarative and imperative
18:18 - approach
18:20 - so
18:21 - obviously i've just shown you uh you
18:23 - know the difference between both but
18:25 - there are a few things that we need to
18:27 - understand in order to
18:29 - write code
18:31 - like this
18:32 - right so i'm going to teach you about
18:34 - functions by functions predicates by
18:37 - predicates consumers
18:39 - and you know all the good stuff that
18:41 - java has to offer when it comes to
18:44 - functional programming if you have any
18:46 - questions go ahead and drop me a message
18:49 - otherwise let's move on
18:56 - all right let's go ahead in this section
18:58 - learn about the java.util.function
19:02 - package
19:03 - so basically this package contains
19:05 - functional interfaces that provides
19:07 - target times for lambda expressions and
19:09 - method references
19:11 - so each functional interface has a
19:15 - single abstract method
19:17 - basically you can have one interface
19:20 - with
19:21 - multiple
19:23 - methods but you must have only one
19:27 - single abstract method to be considered
19:30 - as a functional interface
19:33 - so basically you can see some examples
19:35 - right here so the assignment the
19:37 - assignment context so this is how you
19:40 - for example
19:41 - define a predicate
19:43 - and this is how for example you use it
19:46 - within the actual
19:48 - uh you know stream so right here you've
19:50 - seen that we can get stream from a list
19:52 - right so streaming and filter
19:55 - and
19:56 - there's another example where you can do
19:57 - some casting
19:59 - so
20:00 - this package right here contains a bunch
20:03 - of
20:04 - functional interfaces right here you can
20:06 - see by consumer by function
20:09 - binary operator by by predicate boolean
20:12 - supplier consumer
20:14 - and the list goes on
20:16 - so they are pretty much
20:18 - identical apart from the type so the
20:21 - ones that you will most likely be using
20:24 - are functions by functions predicates by
20:28 - predicates
20:29 - and consumers and also there is a by
20:31 - consumer but i'm like but i'm going to
20:34 - explain exactly how everything fits
20:36 - together
20:37 - because once you learn
20:39 - those main ones then the rest will be
20:42 - very simple
20:44 - so right here i want to show you that so
20:46 - we have a predicate so where is the
20:48 - predicate
20:50 - so let me find predicate
20:52 - so right here so a predicate let me
20:54 - quickly show you a predicate
20:56 - and
20:57 - show you that we actually have used
21:00 - you know a predicate before so a
21:02 - predicate represents
21:04 - a predicate
21:06 - basically this particular represents a
21:08 - predicate
21:09 - a boolean value function of one argument
21:15 - so let me go back to intellij
21:17 - and right here remember where we had
21:20 - this declarative approach
21:23 - so right here so this filter
21:25 - so basically if i pretty much extract
21:28 - this into a variable
21:31 - you can see that this is a predicate
21:36 - and look at this
21:37 - this predicate
21:39 - looks like this
21:40 - so the predicate accepts a person
21:44 - and then returns true or false
21:48 - based
21:49 - of that person i.e whether the person
21:53 - is of type
21:55 - female
21:56 - right but what we've done right here we
21:59 - simply inlined
22:01 - like that that's why you don't see the
22:04 - predicate keyword but indeed
22:07 - this is a predicate and a predicate
22:10 - looks like this
22:13 - so
22:14 - don't worry about
22:16 - this if it doesn't make sense but i'm
22:18 - going to try my best to explain you
22:20 - exactly
22:21 - how you go from
22:23 - uh you know normal java functions to the
22:27 - functional interface world
22:31 - join me in the next one
22:37 - all right so i've gone ahead and created
22:40 - a new package right here called
22:42 - functional interface
22:44 - and inside of this package i'm going to
22:47 - go ahead and create a class
22:49 - and first i want to name this class as
22:52 - underscore and then function
22:56 - and i'm going to explain why i'm saying
22:58 - underscore right here but for now go
23:00 - ahead and simply say underscore and fun
23:02 - underscore function or you can name this
23:05 - anything other than function without
23:09 - underscore right
23:11 - so right here what i'm going to do is
23:12 - simply say public static void main to
23:16 - have a main method
23:18 - and
23:19 - right here what i'm going to do is
23:21 - simply do the following
23:23 - so let's go ahead and create a function
23:25 - so static
23:27 - and then function so this function will
23:30 - take a number
23:31 - right so take a number and then
23:33 - increment that number by one
23:37 - so let's go ahead and simply say
23:39 - int
23:40 - and then
23:41 - increment
23:45 - and then this will take an integer
23:48 - number
23:50 - and then it will return
23:53 - number
23:54 - and then plus one
23:56 - so now if i go ahead and simply say
23:59 - increment
24:01 - and then zero
24:05 - and then end up with semicolon
24:08 - and
24:09 - if i pretty much extract this to a
24:11 - variable and for now let's go ahead and
24:13 - simply sound this
24:15 - increment
24:17 - and let me put this full screen let me
24:20 - run this now
24:23 - oops i'm running the wrong one so i need
24:26 - to run this function
24:28 - there we go so you can see that the
24:29 - result is one very simple so if i put
24:33 - one right here
24:35 - this will be
24:37 - two
24:38 - so what i want to show you is how we go
24:41 - from
24:43 - this so
24:44 - this is what you are used to
24:46 - to
24:47 - this right here so let's go ahead and
24:49 - learn about the function
24:51 - um
24:53 - interface so where is the function
24:59 - so
25:00 - this one right here
25:02 - so
25:03 - this
25:04 - says that represents a function that
25:06 - take that accepts one argument and then
25:09 - produces a result
25:11 - so this is pretty much what we have here
25:14 - right so this function that we have so
25:16 - this is a normal function in java so
25:20 - this is what you are used to
25:22 - so this
25:24 - takes
25:25 - an input
25:27 - and then returns
25:29 - one single output right here and this
25:32 - is pretty much the equivalent right here
25:36 - so represents a function that accepts
25:38 - one argument and produces a result so
25:42 - the way that we convert this into a
25:45 - function right here is the following
25:49 - so let's go ahead and simply
25:53 - say
25:54 - function
25:57 - and if i actually delete this so i want
25:59 - to show you something so function
26:01 - you can see that this function takes a t
26:05 - right so t and then r so basically these
26:08 - are the data types of the input and the
26:12 - output so let's go ahead right here and
26:15 - simply say that this
26:16 - will be of type integer so the input is
26:20 - integer
26:21 - and the output is also an integer
26:25 - right here
26:26 - so now let me go ahead and simply say
26:28 - increment
26:29 - and then function
26:31 - or actually increment by
26:34 - and then one
26:36 - function right here
26:38 - and then this
26:39 - will be
26:41 - equal to
26:42 - right now this is where things become a
26:45 - bit tricky so here
26:47 - equals two and then this will be the
26:49 - actual
26:50 - number
26:52 - and then right here we pass a lambda
26:55 - and then i'm going to say number
26:57 - and then plus plus
26:59 - there we go
27:00 - and i would semi column
27:04 - so
27:05 - you can see that
27:08 - this
27:09 - and this are the exact same thing
27:13 - so basically
27:14 - this integer right here corresponds to
27:17 - the actual input so
27:19 - this one right here right this data type
27:23 - this integer corresponds to the return
27:26 - type
27:27 - and then this number corresponds to the
27:32 - parameter to this function right here
27:35 - and then i'm saying
27:36 - number plus plus well actually let me
27:38 - simply make them the same so number plus
27:41 - one
27:42 - and let me also rename this function to
27:46 - increment by and then one
27:49 - so
27:50 - you can see that
27:52 - this is pretty much the same but now we
27:55 - are talking in
27:57 - functional
27:58 - style world
28:00 - so now the way that we use this is as
28:04 - follows
28:05 - so go ahead and simply say increment by
28:09 - one and the reason why we're not seeing
28:11 - this this function is because we can
28:14 - actually put it inside of this method
28:16 - so inside of this main method we can
28:20 - paste that function there
28:23 - or
28:25 - if you want this can also be static
28:28 - like that right
28:30 - so let me actually um
28:33 - put this on a new line so you see
28:35 - exactly
28:36 - how it is
28:38 - so right here i can say increment by one
28:41 - function
28:43 - and what i'm going to do is simply say
28:45 - dot and then apply
28:48 - so the apply pretty much takes the
28:50 - actual argument so let me go ahead and
28:52 - simply say 1
28:54 - and then right here
28:57 - i'm going to say
28:58 - increment and then 2
29:02 - and i can change this data type to
29:04 - integer
29:06 - and then simply say south
29:08 - and then increment 2
29:11 - then
29:12 - let me simply run this again
29:16 - you can see that we have the exact same
29:19 - output
29:20 - so this is how you use
29:23 - a function
29:25 - so basically
29:27 - it's the exact same thing as this
29:30 - function right here but in a functional
29:33 - style way
29:35 - so if you have any questions about this
29:37 - go ahead and drop me a message
29:39 - but i'm gonna show you exactly how
29:42 - all of this fits together right because
29:44 - now you might be asking you know why
29:47 - should i use
29:49 - uh you know this function right here
29:52 - instead of a normal regular function
29:55 - right
29:56 - and don't worry by the end of this
29:58 - course
29:58 - everything will be clarified
30:01 - so there are a few methods that i want
30:03 - to teach you so right here
30:06 - if i pretty much say increment function
30:10 - uh or actually increment by one function
30:12 - dot you can see that we have
30:14 - um apply and then this method right here
30:18 - and then so i want to teach you
30:21 - what this method is because you might
30:24 - use it later on
30:26 - so let me simply
30:27 - remove that
30:29 - and this is all for now join me in the
30:31 - next video see ya
30:38 - all right let's say that you want to
30:41 - combine multiple functions together to
30:44 - achieve
30:45 - a desired state or a desired output
30:49 - so let's say that you have this
30:52 - function right here so increment by one
30:54 - function
30:55 - but let's also create another function
30:58 - oh actually let me not copy base but
31:00 - simply say
31:02 - static and then function
31:05 - and this function will take an integer
31:09 - and
31:10 - this function will also return an
31:12 - integer
31:13 - and then i'm going to say multiply
31:16 - by
31:18 - and then 10
31:20 - right here
31:21 - so this will take the number
31:25 - oops number
31:27 - and then this will be lambda just like
31:29 - that
31:30 - and then number
31:32 - times and then 10 just like that
31:36 - so
31:38 - we have this function right here
31:41 - and what we want to do is after
31:43 - incrementing so after incrementing
31:47 - uh by one right here we want to apply
31:51 - that or the function immediately
31:54 - so you could do something like this so
31:56 - you could say
31:58 - int
31:59 - increment
32:01 - or actually multiply
32:03 - and then equals two
32:05 - and then multiply by ten
32:08 - uh let me actually rename this to a
32:10 - function
32:13 - just like that
32:15 - and then right here you could say
32:17 - equals to
32:21 - multiply by 10 function dot
32:24 - apply
32:25 - and then increment
32:28 - nn2 right
32:32 - so
32:33 - uh this is
32:35 - not quite right
32:37 - because
32:39 - this is a name so right there
32:42 - and then remove that
32:44 - and this should be multiply
32:46 - by 10
32:48 - let me grab that name there
32:50 - paste it there and there we go so now if
32:52 - i do a south
32:53 - and then multiply by 10 function
32:58 - well actually
32:59 - i'm getting all confused right here so
33:01 - this should be multiply
33:07 - there we go so this is the actual output
33:09 - so now if i run this
33:13 - you can see that
33:15 - we take 2
33:17 - multiplied by 10 is 20.
33:20 - so obviously
33:22 - this is you know quite normal for us to
33:25 - do but we can do something better so
33:27 - what we can do is
33:29 - simply combine the two functions
33:32 - together
33:33 - so right here what i'm going to do is
33:36 - simply say increment by one function
33:40 - dot
33:41 - and then and then
33:44 - multiply by 10 function
33:47 - and right here
33:49 - what i'm going to do is simply extract
33:52 - this to a variable so this will give us
33:55 - yet another function
33:57 - and let me simply say
33:59 - add by
34:01 - 1
34:03 - and
34:04 - then multiply
34:09 - by
34:10 - 10 there we go
34:13 - so if i put this on a new line and you
34:15 - can see exactly what it's doing so now
34:17 - let's go ahead and simply say add
34:20 - by 1 and multiply by 10
34:24 - and then simply say apply
34:26 - and you can see that you can keep on you
34:29 - know chaining these functions as you go
34:31 - along but for now let's simply chain two
34:34 - functions so now i'm going to say apply
34:36 - and
34:37 - the number that i want is
34:40 - one right
34:42 - so
34:44 - this should give us the exact same
34:46 - result so 1 plus 1 2
34:49 - 2 plus
34:50 - 10 you guessed it right that would be
34:52 - 20.
34:54 - so
34:55 - obviously i need to
34:58 - put this around
35:00 - system.out.printline
35:02 - just like that
35:05 - run this again
35:07 - you can see that we have 20 right here
35:10 - so if i change this
35:12 - to let's change this number right here
35:15 - so instead of one let's go ahead and
35:17 - change it to four
35:19 - four plus one five
35:22 - times ten
35:24 - fifty right here
35:26 - and this is pretty much how you chain
35:29 - functions together
35:31 - so if you have any questions go ahead
35:34 - and drop me a message
35:35 - next let me go ahead and teach you about
35:39 - by functions
35:46 - all right so what a by function is
35:50 - is
35:51 - the same as
35:52 - a function
35:54 - but instead of taking one
35:58 - input it takes two inputs and produces
36:02 - one output
36:04 - and by function for
36:06 - two things right
36:08 - so
36:09 - right here
36:11 - we have this function right here so this
36:14 - one add by one and multiply by 10.
36:17 - so let's say that the first number that
36:20 - we give it
36:21 - is the one that it should increment and
36:23 - then the second one is the one that it
36:26 - should multiply
36:28 - by
36:28 - so right here let me go ahead and define
36:30 - this as a normal function so you can see
36:33 - exactly
36:34 - um
36:37 - the equivalent so increment and we'll
36:40 - actually increment by one
36:43 - and
36:44 - multiply
36:46 - just like that so now right here
36:48 - we have a second argument so
36:52 - int num to multiply
36:57 - by
36:59 - just like that
37:01 - and now i'm going to wrap everything
37:04 - within
37:05 - parenthesis
37:07 - and then say times and then num to
37:10 - multiply by
37:11 - now the way that we define the exact
37:14 - same thing
37:16 - but using
37:18 - a by function is as follow
37:20 - so let's go ahead and simply say buy
37:23 - and then function
37:26 - so the first argument is the
37:29 - first input which is the actual number
37:32 - that we want to
37:34 - add one by so let me go ahead and simply
37:37 - say this is an integer
37:40 - the second one is also an integer
37:44 - the third one is also an integer
37:47 - so bear in mind that you can have
37:49 - different data types depending of your
37:52 - circumstances
37:54 - so right here let me simply say
37:57 - that this will have the same name but by
38:00 - function
38:01 - so usually you wouldn't include the pi
38:04 - function
38:05 - for the name but i'm just doing it so
38:07 - that you understand exactly
38:09 - and reason about these things so right
38:13 - here this now will take
38:16 - two things so because it takes two
38:19 - arguments we need to wrap this within
38:22 - parenthesis
38:23 - so this will be
38:25 - number
38:26 - to
38:28 - increment
38:30 - by
38:31 - one
38:33 - and then number
38:34 - two
38:37 - mul
38:38 - t
38:39 - ply and then buy
38:42 - and this will be now a lambda and what
38:45 - we do is simply say number two
38:49 - increment by one plus and then one
38:53 - right so this is the exact same thing
38:55 - that we did here
38:56 - and then this will be within parenthesis
39:01 - and then finally
39:04 - times and then number to multiply by
39:07 - and that would semicolon
39:09 - and let me just put this on a new line
39:13 - yet again
39:15 - so you see exactly everything so i've
39:17 - got bigger font because i want you to
39:19 - see exactly properly
39:21 - but you know you shouldn't indent things
39:23 - like this but basically
39:26 - this right here is the exact same thing
39:30 - as this
39:32 - so now let's go ahead and use it so
39:35 - right here remember
39:37 - we had this function so add by 1 and
39:40 - then multiply by 10. so let's go ahead
39:43 - and say this now is a by
39:45 - function
39:48 - and this was the function example
39:55 - so let me actually add a comment so
39:58 - takes one
40:01 - argument
40:03 - and
40:04 - produces
40:05 - one result
40:08 - so now
40:09 - the by function
40:11 - is almost the same but it takes two
40:14 - arguments right here
40:17 - so let's go ahead and use our function
40:20 - so right here so increment by one
40:23 - and then multiply
40:25 - let's go ahead and give it four
40:28 - and then let's multiply four
40:31 - by one hundred
40:33 - so basically this will be
40:34 - four plus one five
40:37 - five times 100
40:39 - 500
40:40 - so let's go ahead and simply
40:42 - uh i'm not going to even
40:45 - put this into a variable i'm simply
40:47 - going to say south
40:49 - and then just like that so let me
40:53 - put like that
40:55 - and there we go
40:57 - so now if i run this
41:01 - you can see that we have 500 right here
41:06 - now let me go ahead and use
41:09 - the by function so if i escape out of
41:12 - this
41:13 - and let's actually have the same system
41:16 - right here so
41:17 - system.line
41:19 - and right here
41:20 - let me simply use the actual
41:22 - function
41:23 - i think we have to have it as static so
41:26 - this guy right here
41:28 - so this has to be static
41:33 - there we go now it should appear
41:35 - by function
41:37 - and this should be dot and then apply
41:41 - and apply takes 4 and 100
41:45 - now if i run this
41:49 - you can see that we have the exact same
41:52 - result
41:53 - so
41:54 - this one right here is using
41:57 - normal java function
41:59 - and this one right here is using the buy
42:02 - function
42:03 - let me go ahead and show you the actual
42:06 - docks you'll see that we have lots of
42:09 - buy so let me say let me search for buy
42:12 - so you could see that we have
42:14 - you know a double
42:16 - by function to int by function to long
42:20 - by function
42:21 - and all of these by functions are the
42:24 - exact same thing as the function but
42:27 - they take two arguments as you can see
42:30 - here right
42:32 - so the same with predicate so it takes
42:34 - two arguments and returns true or false
42:37 - so this is the difference between a
42:40 - function and a by function if you have
42:42 - any questions go ahead and join me
42:44 - message
42:45 - otherwise let's move on
42:52 - all right next let's go ahead and learn
42:54 - about consumer
42:56 - so a consumer so let me search for
42:59 - consumer
43:01 - right here so consumer
43:03 - so a consumer represents an operation
43:05 - that accepts a single input argument and
43:08 - returns no result
43:10 - so let me show you exactly first the
43:13 - non-functional way and then the
43:15 - functional way so let's say that right
43:19 - here again let's have public static
43:22 - void main
43:23 - and right here let's go ahead and define
43:27 - a static class
43:29 - and then customer
43:32 - and then let's go ahead and simply say
43:34 - private
43:35 - final and let me put this full screen so
43:38 - private final
43:39 - and then string
43:41 - and then
43:42 - customer
43:43 - name
43:45 - private
43:46 - final
43:47 - string
43:49 - customer
43:50 - phone
43:51 - number just like that
43:54 - so next let me add that to constructor
43:57 - and
44:00 - now what i'm going to do is have a
44:02 - function right here
44:04 - so let me go and simply say static
44:07 - and then right here let's go ahead and
44:09 - say greet
44:10 - and then customer
44:12 - so this will take a customer
44:17 - and right here let's go ahead and simply
44:20 - say south and then hello
44:24 - and then customer
44:26 - and then dot customer name
44:29 - and then right here plus
44:32 - and comma
44:33 - thanks for registering
44:37 - and then phone
44:39 - number
44:40 - and then plus
44:42 - customer
44:44 - dot and then customer phone number
44:47 - so let me actually put this on a new
44:49 - line so you can see everything
44:52 - so now let's go ahead and simply create
44:53 - a new customer so new
44:55 - customer
44:57 - this will be
44:58 - let's say that maria
45:00 - and then my real phone number will be
45:02 - 99999
45:05 - right
45:06 - so
45:08 - let me go ahead and cut this
45:10 - and then simply say great customer pass
45:14 - new customer just like that and end up
45:16 - with semicolon
45:21 - just like that
45:22 - so
45:23 - now if i
45:25 - run this class
45:29 - you can see that we have hello maria
45:31 - thanks for registering phone number 9999
45:35 - so the way that we achieve the same but
45:38 - using the functional interface
45:42 - so the consumer functional interface
45:45 - is by doing the following
45:47 - so let me go ahead and simply say static
45:51 - and then
45:52 - consumer
45:54 - so consumer takes one argument so this
45:57 - will be of type
45:58 - customer and then right here let me go
46:01 - ahead and simply say greet
46:05 - customer consumer
46:08 - equals
46:09 - to
46:10 - and then we'll take the customer
46:14 - what we're going to do is pretty much
46:15 - the exact same thing right here so let
46:18 - me grab all of this
46:20 - and then paste it there
46:22 - and basically
46:24 - now i can go ahead and simply say
46:26 - greet customer consumer
46:30 - dot and then right here
46:32 - instead of apply we simply accept
46:35 - now let me go ahead and extract this
46:38 - customer
46:39 - so maria
46:40 - and then also pass maria right here
46:44 - so there we go so this is using
46:48 - functional
46:49 - interface
46:51 - so this is actually
46:53 - consumer
46:57 - and then normal
47:00 - java function
47:02 - right
47:03 - so
47:05 - if i run this
47:09 - you can see that we have the exact same
47:11 - thing right
47:13 - so basically a consumer takes one
47:15 - argument
47:16 - and pretty much returns
47:18 - nothing it's like a void function right
47:22 - so this customer right here is the data
47:25 - type of the input so is this one
47:30 - this customer
47:31 - is the actual name of the
47:34 - uh input so this customer right here
47:37 - and void you could technically say that
47:40 - void is a consumer
47:43 - so if you have any questions on this go
47:45 - ahead and drop me a message
47:47 - otherwise let's learn about by consumers
47:56 - all right so let's go ahead and learn
47:57 - about the buy consumer so the same way
48:00 - that we've done
48:02 - with functions
48:03 - and by functions we have the same for
48:07 - consumer so pretty much
48:09 - every one of these uh functional
48:12 - interfaces they have the
48:14 - buy
48:15 - version so in front of it they have the
48:17 - buy version
48:19 - so the by simply means that instead of
48:23 - taking one argument it takes two
48:27 - arguments
48:28 - now let's go ahead and change this
48:31 - function so let me simply
48:33 - grab that
48:35 - and
48:36 - let's go ahead and simply say v2 for
48:38 - example so this will be the version 2.
48:41 - so what we're going to have is a by
48:43 - consumer right here
48:47 - and let me import this
48:50 - so first we will take the customer
48:53 - and then we will have the boolean so
48:56 - right here so this boolean
48:58 - so this boolean
48:59 - will represent whether we should hide
49:02 - the customer's phone number
49:05 - show
49:06 - and then
49:08 - phone and then number
49:10 - so now we have an error because we have
49:12 - two arguments and because we have two
49:15 - arguments we need to enclose these
49:17 - within parenthesis just like that
49:21 - now right here what i'm going to do is
49:23 - instead of printing the actual phone
49:25 - number like that
49:27 - i'm going to say the following so i'm
49:30 - going to put this within parentheses
49:32 - just like that
49:34 - and
49:37 - right here i'm going to say show phone
49:39 - number so if show phone number
49:41 - then we can pretty much print that
49:44 - otherwise i'm simply going to have some
49:47 - stars just like that
49:49 - so now let's go ahead and test this out
49:53 - so let's go ahead and simply say great
49:55 - customer v2 and let's pass maria
50:00 - and then right here let's simply say
50:02 - true for now
50:05 - so this is actually complaining because
50:07 - we need to say dot accept
50:11 - and if i run this
50:14 - you can see that
50:17 - this is the version two of our
50:20 - function now let's go ahead and simply
50:22 - say false
50:25 - run that
50:27 - and you can see that now we are hiding
50:29 - the number right here so basically if
50:32 - you were to
50:33 - convert this into a normal regular java
50:37 - function
50:38 - this would be as follow so let me just
50:41 - duplicate all of this
50:43 - just like that
50:45 - call this v2
50:48 - and then right here
50:50 - we simply take the exact same variable
50:53 - so show phone number
50:57 - but right here
50:59 - boolean
51:00 - show phone number
51:02 - and let me grab everything from here
51:06 - and then put it here
51:09 - there we go
51:10 - and i would semicolon
51:13 - and
51:15 - i can simply now go ahead and say get oh
51:19 - actually great customer
51:22 - v2
51:25 - pass maria
51:27 - and then true
51:30 - run
51:31 - there we go
51:32 - and you can see that we have the exact
51:34 - same information so there we go this is
51:37 - how you use a
51:39 - by consumer
51:41 - if you have any questions go ahead and
51:42 - drop me a message otherwise let's move
51:45 - on
51:51 - all right let's go ahead and learn about
51:53 - predicates so i've gone ahead inside of
51:55 - the functional interface package created
51:58 - this underscore predicate
52:01 - class
52:02 - and inside let's go ahead and simply
52:05 - type public static void main
52:08 - and let's go ahead and learn about
52:10 - predicates
52:11 - so
52:12 - let's say that you want to
52:15 - do the following so let's say that you
52:17 - have a function so a normal travel
52:20 - function so static
52:22 - and then this will return a boolean
52:25 - and right here let's simply go ahead and
52:28 - say
52:28 - is
52:30 - phone
52:30 - number valid
52:33 - so let's go ahead and simply take a
52:35 - phone number so string and then phone
52:39 - number
52:41 - and for now let's go ahead and keep it
52:43 - very simple but this validation is not
52:46 - real
52:47 - but it's just to illustrate the actual
52:49 - example and purpose of predicates
52:53 - so right here let's simply say that this
52:55 - note this phone number in order to be
52:57 - valid it has to meet the following
52:59 - criterias so let's return phone number
53:03 - dot
53:04 - and then starts
53:07 - with
53:08 - and
53:09 - let's say that the phone number has to
53:11 - start with
53:13 - zero seven
53:15 - and let's also say that the phone number
53:17 - and
53:18 - phone number
53:20 - dot
53:21 - and then length
53:23 - is equal to
53:25 - eleven
53:27 - so this is a simple phone validation uh
53:31 - method but this is not real it's just to
53:34 - illustrate the purpose
53:36 - now let's go ahead and simply do a south
53:39 - here
53:40 - and let's go ahead and have this phone
53:42 - number so zero seven
53:45 - and then zero zero zero zero zero zero
53:47 - zero zero zero
53:49 - and let's have another one
53:52 - zero and then
53:54 - nine and then we can add um you know
53:58 - a couple digits like so
54:01 - right
54:02 - so the validation is not real but this
54:05 - will illustrate the purpose so now if i
54:07 - run this so let me run this main method
54:15 - you can see that i'm printing the number
54:17 - but what i meant to do was to actually
54:20 - let me cut this
54:22 - so what i meant to print was is phone
54:25 - number valid and then pass the actual
54:27 - phone number so same with that one
54:29 - cut it
54:31 - is phone number valid and then paste it
54:34 - run it again
54:37 - you can see that the first phone number
54:39 - is valid so it meets the actual
54:41 - criterias let's also have another one so
54:44 - the same but this will be 10 characters
54:47 - long
54:49 - and if i run this again
54:52 - you can see that the first one is valid
54:54 - the second one the second one the second
54:56 - one isn't and the third one isn't as
54:59 - well
55:00 - so right here we're simply doing a
55:02 - simple phone validation uh check
55:05 - now in order for us to use the
55:08 - functional style we can use the
55:11 - predicate so predicate right here so you
55:14 - can see represents
55:16 - a boolean valid function of one argument
55:19 - right
55:20 - so
55:21 - right here the way that we use a
55:23 - predicate is as follows so this exact
55:26 - same function as predicate will be
55:29 - something like this
55:30 - static
55:31 - and then right here predicate
55:35 - and then this will take a string so this
55:39 - will be the phone number
55:41 - and then let's copy this exact same name
55:45 - and then let's simply say predicate
55:49 - and right here
55:50 - this will be equal to and then
55:53 - phone number
55:56 - so let's actually grab this
56:00 - and then this lambda
56:04 - and
56:04 - on a new line i'm simply going to grab
56:08 - this
56:11 - and then paste it
56:13 - and then end with semicolon
56:15 - now let's go ahead and use it so to use
56:19 - it
56:19 - is phone number valid predicate
56:23 - dot
56:24 - and then test so this is the actual
56:26 - method that we need to use
56:28 - so now we're going to test
56:30 - the following let's test the first
56:32 - number
56:33 - so we know that the first number is
56:34 - valid so basically this will be the
56:37 - exact same thing so we need to simply
56:39 - south this
56:42 - just like that
56:45 - there we go
56:46 - and let me duplicate this
56:48 - and basically we should have the exact
56:50 - same output
56:52 - there we go
56:54 - and then paste that in
56:56 - let me do south
56:59 - without
57:01 - predicate
57:02 - and then right here
57:04 - weight
57:05 - predicate
57:11 - and if i run this
57:15 - you can see that we have the exact same
57:18 - result so true false false
57:21 - and without predicate true false false
57:24 - so basically this is the equivalent so
57:27 - the predicate is the equivalent
57:30 - as
57:31 - this normal java function
57:35 - and the cool thing about predicates is
57:36 - that you can have a bunch of predicates
57:39 - and then combine them together so the
57:42 - same way that we've done with function
57:43 - using and then we can we can also use it
57:47 - with predicates so let's say that we
57:49 - have another predicate so let's have
57:52 - another project so static and then
57:54 - predicate
57:56 - and this predicate will take a string
58:00 - and then let's say contains
58:06 - and then number and then let's simply
58:08 - say number three so if the phone number
58:10 - contains number three
58:12 - so phone number
58:14 - and right here i'm simply gonna say
58:16 - phone number
58:17 - dot and then contains
58:20 - and then three
58:22 - just like that
58:24 - now the way that you
58:27 - change predicates is as follow
58:30 - so right here let's simply go ahead and
58:31 - say is phone number valid so we're gonna
58:34 - pass this phone number so this one right
58:37 - here there we go
58:39 - and then we can say dot and then
58:42 - is phone number valid predicate
58:45 - dot
58:46 - and then and another predicate so the
58:49 - other predicate is contains number three
58:53 - dot
58:54 - and then test
58:56 - let's actually pass
58:57 - this number right here so the last one
59:01 - there we
59:02 - go and let's wrap everything without a
59:06 - system.print line
59:08 - let me put this on a new line
59:11 - and
59:14 - just like this there we go
59:17 - so if i say right here
59:20 - is
59:21 - phone
59:22 - number valid and
59:24 - contains
59:26 - number
59:27 - three
59:31 - equals and then plus
59:33 - the actual result
59:35 - let's do the same for a different number
59:38 - so let's actually
59:39 - let's actually do for this one very
59:42 - first one
59:43 - so right
59:44 - here and let's actually put a three
59:48 - right here
59:49 - so
59:50 - this should be false because the phone
59:53 - number
59:53 - isn't valid but it contains number three
59:57 - right here but this one the phone number
59:59 - is valid so it starts with zero seven
60:01 - eleven characters long
60:03 - and contains number three at the end
60:06 - so let's go ahead and
60:09 - run this method
60:11 - and there we go so you can see that the
60:14 - second one is true as i explained why
60:16 - and the first one is false
60:19 - now you can use ands but you can also
60:23 - use or
60:25 - so or means either one of them is true
60:29 - so if i was to say right here so
60:32 - instead of and i can use or
60:35 - right and then if i remove
60:38 - three here and put a zero
60:41 - run this
60:44 - this will still be true if true because
60:47 - we only need one condition to be true if
60:50 - you use an and so if you chain multiple
60:53 - predicates together using an and all of
60:56 - them have to be true
60:58 - so the same way that we have
61:00 - predicates we have by predicates by and
61:04 - then predicates right here and basically
61:06 - they are the same thing
61:08 - but instead of taking one argument they
61:10 - take two arguments
61:13 - so i'm not going to give you a full
61:15 - example on by predicates because you
61:17 - should be familiar now with by
61:19 - predicates by functions by consumers so
61:22 - on and so forth so if you have any
61:24 - questions on predicates go ahead and
61:27 - drop me a message otherwise let's go
61:29 - ahead and learn about the final
61:31 - functional interface i want to show you
61:33 - and then we can start putting all the
61:35 - puzzle together so that all of this
61:38 - starts to make sense and how you
61:41 - actually end up using it
61:44 - join me in the next one see ya
61:51 - all right go ahead and inside of the
61:53 - functional interface package create a
61:56 - class called underscore supplier with a
61:59 - public static void main
62:01 - method
62:02 - so
62:03 - let's go ahead and learn about what a
62:05 - supplier is so if i go to the docs
62:09 - right here you can see that they say
62:11 - supplier t
62:13 - represents a supplier of results
62:16 - so basically
62:18 - sometimes you might have a method right
62:20 - here that simply
62:22 - uh let's say that
62:24 - we have a method
62:26 - like that so like
62:27 - a method like this so static and then
62:30 - get or actually string
62:34 - get
62:35 - connection
62:37 - url
62:38 - watch let's simply say get db
62:44 - connection url right
62:46 - so
62:47 - this
62:48 - will
62:49 - take no arguments
62:51 - and let's simply return
62:54 - and then for example j dbc
62:58 - column for slash forward slash localhost
63:02 - and then
63:03 - 5432
63:05 - forward slash
63:06 - let's say
63:08 - users
63:09 - right so this is not real but you get
63:11 - the idea
63:12 - so
63:13 - the way that we can
63:16 - use this function now is if i simply say
63:18 - south
63:20 - and then get
63:21 - db connection url
63:24 - and then if i run this
63:26 - you can see that we get the actual
63:28 - connection url for some kind of database
63:31 - so the purpose of this function right
63:34 - here is simply to return
63:36 - a value right here so this is the value
63:39 - that it returns
63:41 - so we can do
63:43 - so we can use a supplier to represent
63:46 - the exact same thing so i'm going to
63:48 - copy this url
63:50 - and to
63:51 - have this java function as
63:54 - functional
63:55 - we simply have to say supplier or
63:58 - actually static
64:00 - and then supplier
64:02 - and then this will supply a string
64:06 - and then get
64:07 - let's
64:08 - grab this
64:10 - and then supplier
64:13 - and right here equals two and then what
64:17 - we need to do is simply have
64:19 - parenthesis
64:22 - and then we simply pass or actually
64:24 - return this
64:26 - just like that
64:28 - so if i put this on a new line so you
64:30 - can see exactly what i'm doing
64:32 - and you can see that now this is the
64:34 - exact same thing but if i go ahead and
64:37 - simply say system.out.life
64:40 - so south
64:41 - and then right here to use this i can
64:43 - say get
64:45 - db connection url supplier
64:48 - dot and then get
64:50 - so now if i run this
64:54 - i do get the exact same result
64:58 - so this is pretty much how you use a
65:01 - supplier so a supplier simply
65:04 - returns
65:05 - any kind of value that you want right so
65:08 - this data type doesn't have to be a
65:10 - string it could be you know your custom
65:13 - classes your custom objects
65:15 - um
65:16 - you know an array
65:18 - pretty much anything that you want so
65:20 - for example if you wanted to return a
65:22 - list right here you could simply say
65:24 - list
65:25 - and then of type and then string right
65:27 - here
65:28 - and then here i would say list dot of
65:33 - and then just like that and that would
65:36 - semicolon right so now if i run this
65:45 - you can see that this now is a list so
65:48 - if i was to return
65:50 - something else so
65:52 - right here
65:53 - let me simply add comma new line
65:57 - and then this
65:59 - like so so it's much neater
66:02 - just like that
66:04 - oops just like that
66:06 - and right here let's simply say uh
66:09 - customer for example right
66:11 - so get a connection urls
66:14 - and then supplier and then here urls run
66:18 - this
66:20 - and there you go so now we are returning
66:22 - a list with two urls
66:25 - so if you have any questions on
66:27 - suppliers go ahead and drop me a message
66:30 - otherwise let's move on
66:37 - all right so by now you should see
66:39 - exactly the differences between
66:42 - writing a normal java function and
66:45 - functional interfaces
66:47 - so
66:47 - the benefit of you know knowing the
66:50 - functional interfaces is when you start
66:52 - to use optionals and streams but more
66:55 - specific streams right so once you start
66:58 - using streams with all of these
67:00 - functional interfaces you will start to
67:02 - write clean code and that's what i'm
67:05 - going to teach you next
67:12 - okie dokie now that you've learned about
67:15 - consumers functions by functions
67:18 - predicates by predicates and suppliers
67:22 - and also i think by consumers
67:24 - now let's go ahead and actually learn
67:26 - how this is useful to us when writing
67:29 - code
67:30 - so
67:32 - go ahead and create a new package under
67:35 - java so package
67:37 - and call this as streams
67:41 - now go ahead and create a new class and
67:44 - simply call it underscore and then
67:47 - stream
67:48 - just like that
67:50 - enter public
67:52 - static void main
67:55 - enter
67:56 - now remember inside of the imperative
67:59 - uh package go ahead and open that up
68:02 - and let's actually steal some code so
68:05 - right here let's steal
68:07 - all of this so the enum gender as well
68:10 - as the
68:11 - person class
68:12 - so let me close this
68:15 - and then right here let me paste that in
68:18 - and i'm gonna cancel because i don't
68:19 - want to import from imperative.main so
68:23 - cancel
68:25 - and
68:27 - let me go back again
68:29 - and let's actually steal some code again
68:32 - so let's take this list right here so
68:35 - we're going to take this list and then
68:38 - we can close this once more
68:40 - and then right here inside
68:43 - let's go ahead and paste it
68:46 - and you see right here it's trying to
68:47 - import from imperative.main
68:50 - cancel out of it
68:52 - and let's simply import the actual list
68:55 - ourselves so i'll just press option
68:57 - enter and right here let's import mail
69:00 - and gender
69:02 - just like that and finally let's go
69:04 - ahead and add a static import for those
69:07 - so i'm just pressing
69:09 - option and then enter add static import
69:13 - now let me go ahead and close this
69:16 - and
69:17 - let's actually use what we've learned in
69:19 - the previous section
69:21 - with streams so this is pretty much
69:24 - where everything starts to make sense
69:27 - so
69:28 - let's go ahead and use a couple of those
69:31 - functional interfaces that we've learned
69:33 - so if i collapse this or actually open
69:35 - this so consumer function predicate and
69:38 - suppliers
69:40 - so
69:40 - go ahead and simply say people
69:43 - dot
69:44 - and then stream
69:47 - right so
69:49 - stream pretty much takes us to
69:51 - an abstraction mode and if you want to
69:54 - learn about all of this i've got this
69:58 - course right here where i teach
70:01 - everything about the java streams api
70:04 - because once you've
70:05 - because once you learn this
70:08 - the way that you write your java code
70:10 - will change quite significantly so stuff
70:13 - that you use to take 20 lines of code
70:16 - you can simply collapse into perhaps
70:19 - five lines of code and to be honest
70:21 - knowing how to use the java streams api
70:24 - will make you a much better developer
70:27 - so i also have a free video on youtube
70:31 - where i teach about filter soar group by
70:34 - all match basically this is a an
70:36 - introduction of this awesome api but for
70:39 - now let's go ahead and learn some of
70:41 - these methods
70:42 - so go ahead and say people.stream
70:46 - and now go ahead and simply say dot
70:50 - so what i want you to do is to actually
70:52 - look
70:53 - carefully so right here so look at the
70:55 - methods that we have we have map collect
70:58 - filter find first for reach all match
71:02 - but what i want you to see is exactly
71:04 - look the map function takes a function
71:08 - right takes a function
71:10 - of some type that extends person and
71:14 - then you can see the other one so the
71:16 - other argument so question mark extends
71:19 - our
71:20 - mapper so this is exactly what we've
71:22 - learned right so a function takes an
71:25 - input and
71:26 - produces an output
71:28 - so the same with collect so collect
71:31 - is a supplier
71:33 - and you can see you buy consumer so this
71:36 - is awesome right this is everything that
71:37 - we've learned so the same with filter
71:40 - takes a predicate
71:41 - find first so this returns simply an
71:43 - optional
71:45 - for which takes a consumer right
71:49 - let's look another one so for example
71:51 - drop wow this takes a predicate find any
71:56 - flat map so this is a very useful
71:58 - function
71:59 - takes a function inside
72:01 - and right here flat map to wind
72:04 - map to double so this takes a two double
72:07 - function right
72:10 - and you can see right here
72:12 - non match a verify you of a very useful
72:15 - function as well
72:17 - reduce
72:18 - binary operator
72:20 - and then right here you have another
72:22 - reduce
72:24 - and then look at this
72:26 - sorted takes a comparator it's not
72:28 - relevant to us
72:29 - take wow you can see that this takes a
72:32 - predicate
72:33 - and to array into function basically
72:36 - this is pretty much everything that we
72:39 - have learned right so functions by
72:42 - function consumers predicates
72:44 - and the other good stuff so basically
72:46 - this is now where everything comes into
72:50 - action so let me go ahead and show you
72:53 - for example how to use this map function
72:56 - so go ahead and simply select the map
72:59 - function and the map and the map and and
73:01 - the map function simply does
73:04 - transformations
73:05 - so right here this takes a person
73:09 - right and from here what we want to
73:11 - return so i want to return person
73:14 - dot and then the actual gender
73:17 - now let's go ahead and simply say dot
73:19 - and then collect
73:20 - and then collect us to set
73:23 - right
73:24 - so
73:24 - and also um
73:26 - let me extract this to a variable
73:30 - genders
73:33 - and then south
73:36 - and then genders
73:39 - or actually not even south so let me let
73:41 - me simply remove that
73:43 - because i want you to see exactly what
73:45 - we're doing so right here so instead of
73:47 - collect let's go ahead and simply say
73:49 - dot
73:50 - and then look at this
73:52 - for each takes a consumer and we've
73:54 - learned about consumers right a consumer
73:58 - simply takes an argument and produces
74:01 - nothing so void right so right here we
74:03 - will take a gender
74:07 - and what we want to do with this gender
74:09 - so we want to simply do a
74:12 - system dot out
74:15 - dot print line and then gender
74:18 - and now we can use method reference with
74:21 - this
74:21 - like so and beautiful code
74:24 - now let me go ahead and run this method
74:28 - so you can see what we are doing
74:33 - tada there we go male and female right
74:37 - so you can see that we mapped everything
74:40 - so
74:41 - right here
74:42 - we
74:43 - stream the people list
74:46 - so
74:48 - oops
74:49 - so right here
74:50 - we stream the people list right contains
74:53 - a bunch of people right here so john
74:56 - maria
74:57 - aisha alex and alice
74:59 - so
75:00 - we map so we perform a transformation on
75:03 - that list so we convert
75:05 - every single one of them into a gender
75:08 - so now we simply have a list full of
75:11 - genders
75:12 - and then we collect to a set removing
75:16 - duplicates and then we simply print
75:19 - that's why you see that we have only
75:21 - male and female
75:23 - right here
75:24 - so if i was to have another gender right
75:27 - here
75:28 - cannot
75:30 - actually
75:31 - prefer
75:36 - not to
75:39 - say but basically this is not gender i'm
75:41 - just giving you an example so right here
75:44 - let's add another one another person
75:46 - right here
75:48 - there we go
75:52 - then prefer not to say
75:54 - this will be bob
75:57 - and you could tell that this is a gender
75:59 - but
76:00 - so if i run this
76:03 - you can see that now we have prefer not
76:05 - to say as well right here
76:07 - so if i was to now
76:09 - map this into
76:12 - the actual name right so let's say name
76:16 - and then run this
76:19 - we simply now get the actual names
76:21 - instead of genders
76:23 - so this is really really really awesome
76:27 - so let me actually let me also show you
76:29 - that we can simply get the length of
76:31 - each name so let's also perform another
76:34 - map operation
76:35 - right or in
76:37 - or in this scenario let's say map
76:40 - to int
76:41 - this takes the actual
76:43 - uh
76:44 - name so this time it's name
76:46 - and then simply say name dot and then
76:49 - length
76:50 - and
76:52 - right here we're not going to collect
76:54 - set
76:55 - so let me delete that
76:57 - and then we can even change this to
76:59 - method reference
77:00 - just like that if i run this
77:05 - you can see now the length of each name
77:08 - so this is the power of streams
77:12 - so you might be asking you know what is
77:14 - this
77:15 - right or what is this
77:18 - or what is this
77:19 - so let me just show you right now so
77:22 - what i'm going to do here is simply
77:24 - extract this to a variable
77:28 - and also this to a variable
77:31 - and also this
77:34 - to a variable
77:36 - and now check this out so this is what
77:39 - you've been learning in the past videos
77:42 - so look at this function
77:44 - that takes a person returns a string
77:47 - and then the same here two in function
77:49 - we haven't learned to int function but
77:51 - basically this is the same thing so this
77:54 - takes a string and returns an integer
77:57 - that's all it does and you can see right
78:00 - here in consumer so an end consumer
78:03 - simply takes
78:05 - an integer and it prints out the result
78:08 - so right here so let me actually replace
78:10 - this with a lambda so you can see
78:12 - exactly what is this you see that
78:14 - this is what we've been
78:16 - learning throughout this course but
78:18 - when you use it with streams you don't
78:20 - have to
78:21 - have all of this syntax basically you
78:24 - can ditch the left hand side and just
78:26 - keep these right so if i now inline
78:30 - everything so
78:31 - command shift n
78:33 - command shift and there
78:35 - command shift and there
78:37 - and look at this
78:40 - right
78:41 - and here even method reference
78:43 - and there we go so if you want to learn
78:45 - more about streams
78:47 - go ahead and check my course on java
78:50 - streams api where you learn
78:53 - everything about writing code in a
78:56 - declarative way
78:58 - this is all for now join me in the next
79:00 - one
79:05 - all right let me show you some other
79:07 - methods right here so still right here
79:10 - so let's go ahead and
79:12 - uh for now i'm gonna pretty much just
79:15 - comment everything right here so i'm
79:17 - gonna comment this
79:19 - and right here let's go ahead and simply
79:21 - say people dot and then stream
79:24 - and then right here let's go ahead and
79:26 - simply say all
79:28 - and then match basically we want to know
79:31 - that in our list we only have females so
79:35 - right here so this takes a predicate and
79:37 - remember a predicate looks like this
79:40 - so this will take a person
79:43 - and then in this list we want to make
79:45 - sure that we
79:47 - only have
79:49 - females so female
79:52 - dot and then equals
79:54 - person
79:56 - dot and then
79:58 - why should not people person
80:01 - dot and then gender there we go
80:05 - and now and i'll end this with semicolon
80:09 - and if i extract this to a variable you
80:11 - can see that this
80:13 - is a boolean now let me go ahead and
80:15 - simply say contains only females there
80:19 - we go
80:20 - and if i do a south on this south
80:23 - and then contains only females
80:27 - and let me actually go ahead and
80:29 - destructure all of this so i'm going to
80:31 - extract this to a variable
80:33 - and check this out so right here so
80:36 - we've learned about predicates right so
80:38 - this is what we've learned previously
80:40 - so now let me go ahead and run this
80:44 - again
80:46 - and you can see that it's false right
80:48 - because in our list
80:50 - so right here in our list
80:52 - we contain both male and females
80:55 - so
80:56 - if you want for example to say um
81:00 - or is
81:02 - say the opposite you could say for
81:05 - example i think match let's look at for
81:07 - let's look at match so any match right
81:10 - here right so any match
81:12 - so any match
81:14 - means
81:15 - any match taking our predicate so
81:18 - if we have at least one female then this
81:21 - will return to
81:23 - run this
81:25 - there we go true right so if i for
81:28 - example remove all the females here
81:32 - just like that
81:33 - run it again
81:36 - and it's false now right
81:39 - so let me undo all of that
81:42 - and finally we have uh i think it's
81:45 - non-match
81:47 - right so let's say that now we change
81:50 - this to
81:51 - prefer
81:52 - not say
81:54 - and let's remove bob from here
81:57 - so basically
81:59 - i want to make sure that in our list we
82:02 - do not have someone with prefer not say
82:06 - gender
82:07 - if i run
82:08 - this you can see it's true
82:11 - if i add bob back
82:14 - this will be false
82:17 - there we go
82:18 - so you can see the power of streams
82:21 - right so
82:23 - obviously we have
82:24 - other methods really really useful
82:26 - methods so if i do a person or actually
82:29 - people dot and then stream
82:32 - dot and
82:34 - look at those methods right
82:36 - so
82:39 - mean peak reduce sorted
82:42 - take wow
82:44 - um
82:46 - so
82:47 - right here drop while
82:49 - not much you've seen
82:51 - find first
82:53 - map and map to int so basically
82:56 - once you learn
82:57 - all of this the way you write java code
83:00 - will change and you will become a much
83:04 - better java developer
83:06 - so this is all for
83:10 - this video next let me also show you
83:12 - that you can use um you know all of the
83:15 - goodness of java functional interfaces
83:18 - with optionals because you know again
83:20 - optionals changes the way that you deal
83:23 - with null pointer exceptions in java
83:27 - join me in the next one see ya
83:34 - all right let me go ahead and show you
83:36 - how to use java optionals with
83:39 - functional interfaces so if you've never
83:42 - heard about java optionals or if you've
83:44 - never used java optionals go ahead and
83:47 - check my youtube channel where i've got
83:49 - this
83:50 - crash course on java optionals
83:54 - and i highly suggest you to learn how to
83:56 - use optionals because
83:58 - they will help you a lot in terms of
84:01 - dealing with null pointer exceptions
84:05 - so let me go back to intellij
84:07 - and let me create a new package
84:09 - so right here
84:12 - optionals
84:14 - and inside let's go ahead and create
84:16 - main class
84:18 - and right here
84:20 - public static void main
84:22 - and there we go
84:24 - so now let's go ahead and simply say
84:26 - optional
84:28 - dot
84:28 - and then off
84:31 - nullable
84:32 - so right here let's simply say no
84:35 - right
84:36 - and
84:37 - if i now press
84:38 - dot
84:39 - check this out you can see that right
84:41 - here you have a bunch of methods but if
84:45 - you look closely again so these methods
84:48 - they do take for example the first one
84:50 - or else to throw
84:52 - takes a supplier right so this supplies
84:56 - an
84:56 - exception you can see or else
84:59 - or so right here
85:01 - this takes a supplier
85:04 - map again function
85:06 - if present consumer
85:09 - filter
85:12 - flat map
85:14 - so right here if present or else right
85:18 - is present or else get so this is a
85:21 - supplier so let me actually use this one
85:24 - or else get
85:26 - and then remember suppliers so right
85:29 - here
85:31 - oops
85:32 - there we go
85:33 - so let me simply say
85:35 - default
85:36 - value
85:37 - just like that
85:39 - extract this to a variable
85:41 - and let me simply name this as value
85:44 - now if i go ahead and simply say south
85:46 - on value
85:48 - there we go
85:50 - if i run this
85:51 - you can see that we get default value
85:54 - but now check this out if i simply add a
85:57 - value here
85:58 - so
86:00 - hello
86:02 - run this again
86:04 - you can see that we get a low right
86:07 - so let's
86:09 - try something else so instead of or else
86:11 - get
86:12 - let's go ahead and simply say dot
86:15 - or
86:18 - so right here so or else
86:22 - throw so this again we have to
86:25 - supply an exception
86:27 - oops just like that
86:30 - new
86:31 - illegal set exception
86:34 - and you can have for example a message
86:36 - right there
86:37 - and
86:39 - exception
86:40 - for example right
86:42 - so
86:44 - you can see that if i extract this to a
86:46 - variable
86:48 - this is a supplier and we've learned
86:50 - about suppliers remember so right here
86:54 - so this is a supplier
86:57 - right
86:58 - it takes no arguments but it supplies a
87:01 - value so there we go
87:04 - now let me again show you something else
87:07 - so if i delete this
87:09 - so instead of saying or else throw let's
87:11 - go ahead and use for example
87:14 - so let's use something that has a
87:17 - consumer so if present
87:19 - there we go if present we receive the
87:21 - actual value here
87:24 - and then we do something with the value
87:27 - so right here let me simply remove that
87:31 - and let me move this above
87:34 - and then this
87:36 - there we go
87:37 - now because i only have one single value
87:41 - but basically you could do like some
87:42 - logic right here right if you had like
87:45 - you know something that you wanted to do
87:48 - like a business logic right
87:50 - so now
87:52 - because i only have one value i can
87:54 - delete all of this
87:56 - i can delete that
87:58 - and i can even go one step further
88:01 - use lambda method reference
88:04 - just like that and look at this looks
88:05 - beautiful so now let me go ahead and
88:07 - simply say john
88:11 - gmail.com
88:14 - in fact let's go ahead and pretty much
88:17 - um
88:18 - have a custom message so right here so
88:22 - email
88:23 - and what we're gonna do is simply say
88:24 - south
88:28 - and then sending
88:31 - email to
88:34 - and then
88:35 - email
88:37 - there we go
88:38 - now if i run
88:40 - this you can see that right here
88:44 - we do get sending email to john
88:47 - but now
88:48 - as soon as i pass a null here
88:53 - right
88:55 - if i run this
88:56 - we get nothing but now i can go ahead
88:59 - and pretty much change this with
89:02 - so there is another method right here so
89:06 - if present or else takes the consumer
89:09 - and then the other empty action is a
89:11 - runnable so that
89:13 - is our consumer so let me actually grab
89:16 - this so you can see what am i doing so
89:19 - this is the first one so this email
89:23 - and then right here we have to pass
89:26 - comma
89:27 - right comma
89:28 - and then a runnable so a runnable goes
89:32 - like that
89:34 - and there we go
89:35 - so let me
89:37 - pretty much just put this on a new line
89:40 - and this on a new line just like that
89:44 - and then if i close that
89:46 - indent things
89:47 - there we go and then here what i'm going
89:49 - to do is simply say south
89:53 - cannot send email
89:57 - there we go now if i run this
90:01 - you see that we have cannot send email
90:04 - as a default value so
90:07 - again i can remove that and have method
90:09 - reference
90:10 - and look at how this now starts to flow
90:13 - guys
90:14 - so this is the power of functional
90:17 - programming streams optionals
90:20 - and you know once you start writing code
90:23 - like this you can achieve a lot more
90:26 - instead of using imperative approach so
90:29 - as i said go ahead and roll to this
90:32 - course right here where i teach
90:34 - everything you need to know about java
90:37 - streams api
90:38 - also if you want to learn about
90:40 - optionals go ahead and check this video
90:42 - where i show you how to use optionals
90:45 - and how to be safe with no values
90:49 - this is all for this section if you have
90:52 - any questions go ahead and drop me a
90:53 - message
90:54 - otherwise let's move on
91:02 - let's go ahead and learn about this
91:04 - awesome design pattern called
91:07 - combinator
91:08 - so
91:10 - let me go ahead and first create a new
91:12 - package
91:14 - and right here i'm going to simply name
91:15 - this as combinator
91:18 - and then pattern
91:21 - so
91:21 - right here what i want to do is to
91:24 - create a class so i want to create class
91:28 - and let's say that we will start with
91:30 - the user so the user actually a customer
91:33 - so we have a customer
91:35 - and this customer has few properties so
91:39 - let me collapse this so private final
91:42 - string name
91:44 - let's also give it an email
91:48 - phone number
91:52 - and let's also give it a local date for
91:56 - date of birth
91:58 - now let me go ahead and pretty much just
92:01 - add those to a constructor
92:03 - and let me generate some getters right
92:05 - here so get it
92:07 - just like that
92:09 - so
92:11 - now let's say that you
92:13 - have a system right where customers do
92:16 - register to your system and you and you
92:19 - need to perform some kind of validation
92:22 - right so what you would do for example
92:24 - would be something like this so inside
92:27 - of your package you would create a class
92:30 - and then customer
92:32 - validator
92:35 - and then service
92:37 - right
92:38 - and in this class right here you would
92:41 - have few methods to validate few
92:44 - properties of a customer right
92:47 - so you could have a method so right here
92:49 - you could say public
92:51 - and then boolean
92:53 - is
92:55 - email valid
92:56 - right and this takes a customer
92:59 - or better takes a string
93:01 - email
93:03 - right
93:05 - and right here you'd simply say return
93:07 - and then email
93:08 - dot contains you know this is a rubbish
93:11 - validation but this is just for
93:13 - illustration purposes
93:15 - right so contains that
93:19 - or actually contains the add symbol for
93:21 - now let's keep it simple
93:22 - then you might want to have order
93:24 - validation for the actual
93:26 - um
93:29 - phone number so right here so is and
93:32 - then
93:34 - phone
93:36 - number valid so this will be phone
93:38 - number
93:41 - and then right here phone number
93:44 - right here contains
93:45 - so instead of contains let's go ahead
93:47 - and simply have a simple validation so
93:49 - it starts with
93:51 - and then
93:52 - plus and then zero right
93:55 - and then what did we have so if i go
93:57 - back so we have uh date of birth
94:00 - so let's go ahead and simply say that
94:02 - the date of birth so right here
94:05 - is adult so is adult
94:08 - so right here we take a local date
94:13 - and then
94:14 - dob
94:17 - and then what we're going to do here
94:19 - is simply say
94:21 - period
94:22 - dot and then between
94:24 - so we're going to
94:26 - calculate the number of years between
94:29 - two dates so the start date will be uh
94:32 - inclusive so this will be the dob so
94:35 - customers and date of birth and then
94:38 - local date dot and then now
94:41 - and then right here
94:43 - dot and then get years and let's say
94:46 - that for someone to be an adult they
94:47 - have to be
94:49 - over 16
94:51 - just like that
94:52 - right so if i put this whole screen so
94:53 - you can see
94:54 - so
94:55 - this is then your customer validator
94:58 - service right so now the way that you
95:00 - would use it is
95:02 - let's go ahead and create a new class so
95:05 - main
95:07 - and then public static void main like
95:10 - that
95:11 - customer
95:13 - and then customer equals to new and then
95:15 - customer
95:17 - and then right here let's go ahead and
95:18 - simply say that this is alice
95:21 - and then she has an email of alice at
95:24 - gmail.com
95:27 - and then the actual phone number is plus
95:31 - and then zero so oops plus and then zero
95:36 - and then any random number
95:39 - and finally let's go ahead and simply
95:41 - say that she
95:43 - was born
95:44 - so local date of
95:46 - and then 2 000
95:48 - just like that
95:51 - and then one and then one and there we
95:54 - go so if i collapse this
95:56 - and you can see that now
95:58 - we have a customer that we can perform
96:01 - some validation now obviously
96:04 - um
96:05 - you know this um validator service right
96:08 - so this could even be private
96:11 - so private
96:13 - and then private
96:15 - and then right here so let's go ahead
96:17 - and combine the both
96:19 - let's go ahead and combine everything so
96:21 - is
96:23 - oh actually let's go ahead and simply
96:24 - say public so this is the actual
96:26 - uh interface that we provide to clients
96:29 - so public
96:30 - and then boolean
96:32 - and then
96:34 - is
96:35 - valid
96:38 - just like that
96:39 - and this now will take a customer
96:44 - and now what we're going to do is simply
96:45 - say return
96:47 - and then is
96:49 - email valid
96:51 - customer dot get email
96:54 - and then and
96:56 - and then
96:57 - is phone number valid customer dot get
97:00 - phone number
97:02 - and finally and is in then adult
97:06 - customer dot and then get
97:09 - and then dob
97:10 - just like that
97:11 - so this is actually you know normal code
97:15 - uh
97:16 - but
97:17 - so
97:18 - what i want to teach you really is how
97:19 - are you going to be able to use a
97:21 - functions to
97:23 - change this in a much better way and a
97:26 - neater way right so here if you have
97:30 - extra validation you have to have
97:31 - another method
97:34 - like that and then simply append here
97:36 - and then basically right here you don't
97:38 - have
97:39 - visibility
97:40 - whether um you know whether the
97:44 - phone number was invalid or it wasn't an
97:47 - adult or or anything right because this
97:49 - simply returns a boolean right is valid
97:52 - so if i go ahead and show you what i
97:54 - mean so right here
97:55 - let's go ahead and simply say customer
97:57 - validator service
97:59 - service equals to actually let me rename
98:02 - this to
98:03 - uh validation validate the service
98:06 - new and then customer validated service
98:10 - now let's go ahead and say validator
98:12 - service
98:14 - dot
98:15 - is valid and then pass customer
98:19 - there we go so what i'm going to do
98:21 - actually is in line this oops not that
98:24 - so basically i want to inline
98:27 - um
98:28 - this guy right here so like that
98:31 - and then i'm gonna do a south
98:33 - just like that and then end that like
98:36 - that so now if i go ahead and run this
98:46 - there we go so you can see that this
98:47 - customer is valid and from now on
98:51 - let's say that
98:53 - we
98:54 - can
98:56 - store customer
99:01 - store customer in
99:04 - and then db right
99:06 - so
99:08 - now
99:09 - um
99:10 - actually let me say if and then valid
99:14 - right
99:15 - so now if i go ahead and pretty much
99:18 - just for example remove the add sign
99:21 - run this
99:23 - you can see that now it's false so it's
99:25 - not valid
99:26 - and also let me go ahead and remove the
99:28 - plus sign right here
99:32 - there we go
99:33 - still not valid but now you don't know
99:36 - exactly you know what is wrong with our
99:39 - validation so the combinator pattern
99:42 - it's an awesome design pattern that
99:45 - allows you
99:46 - to chain functions together so basically
99:50 - a combinator is a function that might
99:52 - take other function as arguments and
99:55 - returns new functions
99:58 - so this is an awesome pattern that i'm
100:00 - pretty sure that you will love and
100:03 - that's what i'm going to teach you next
100:10 - all right let's go ahead and use the
100:12 - combinator pattern to improve
100:15 - this validation service right here that
100:18 - we have so validated service actually
100:20 - so this validation sub so so this class
100:24 - right here
100:25 - is
100:26 - okay but we can do
100:28 - way better than this right because right
100:30 - here for example if you want to have
100:33 - um you know a different method that
100:36 - validates for example
100:38 - just email and their phone number then
100:40 - you would duplicate this
100:42 - so right here
100:44 - and then you would say is valid
100:46 - phone number and email
100:48 - and basically just remove for example is
100:51 - adult from here
100:52 - and we don't want to do this right so we
100:55 - want to have a very
100:57 - beautiful interface that we can simply
100:59 - chain all of these validations together
101:03 - so let's go ahead first and expand the
101:06 - project tab
101:07 - and right here let's go ahead and simply
101:09 - create
101:10 - a
101:11 - class
101:12 - and this will be called customer and
101:16 - then
101:17 - let's actually name this as registration
101:22 - validator
101:25 - there we go and instead of a class let's
101:27 - change it to an interface
101:30 - now what i'm going to do here is the
101:32 - following so
101:33 - right here i'm going to say that this
101:35 - will extend
101:37 - a function so remember we've used
101:40 - functions right here and the first
101:42 - argument that we want for this interface
101:45 - is a customer
101:47 - so the type of is a customer
101:49 - and then right here let's go ahead and
101:51 - simply say validation
101:55 - and then result
101:58 - so let me end that
102:01 - just like that
102:02 - and let me put this on a new line so you
102:04 - can see exactly what we're doing
102:06 - now this validation result this will be
102:08 - an enum so enum
102:11 - and then validation or let me actually
102:14 - just copy and paste this so validation
102:16 - result just like that
102:18 - and now i can import this oops
102:22 - actually i did the right thing and let
102:24 - me actually do a static import right
102:25 - here there we go
102:27 - now here what i'm going to do is have a
102:30 - you know few results that i want my
102:33 - validated service or actually my my
102:36 - customer registration validator to have
102:39 - so one i want this to be success right
102:42 - so this is where all the validation is
102:44 - successful
102:46 - then we have few
102:48 - errors so right here we have
102:50 - phone
102:53 - number
102:54 - not and then valid
102:58 - we also have email
103:00 - not and then valid
103:02 - and we also have
103:04 - is
103:05 - not
103:06 - an
103:07 - adult
103:08 - just like that so the way that we're
103:11 - going to
103:12 - use this with this interface is as
103:15 - follows so this is where combinator
103:17 - pattern
103:18 - uh kicks off so right here we're simply
103:20 - going to have the validations that we
103:22 - want right so here you can have as many
103:24 - validations
103:26 - as you want and then you chain them
103:28 - together at the end so right here let's
103:31 - go ahead and simply say static
103:34 - and then right here what we're going to
103:35 - return is
103:37 - this guy right here so the same
103:39 - uh interface so right here we will
103:41 - return this function right here right
103:43 - that takes a customer and returns a
103:46 - validation result so right here i'm
103:48 - gonna say is and then email valid and
103:51 - then i'm not taking anything there
103:53 - but right here what i want to say is
103:56 - return
103:57 - and then
103:58 - customer
103:59 - and right here i'm going to say customer
104:02 - so basically the exact same
104:05 - validation that we had before so
104:06 - customer
104:07 - dot and then contains
104:11 - and then at
104:14 - so if this is the case
104:17 - what i'm going to do is simply return
104:20 - you guessed it success
104:23 - otherwise phone number
104:26 - oh actually no phone number uh email is
104:29 - not valid and let me have a static
104:31 - import for this
104:32 - and the same for success
104:34 - there we go
104:35 - now let's go ahead and do the same for
104:38 - phone number
104:40 - right here let me actually steal some
104:42 - code so from here
104:44 - what did we have we had this so i'm
104:48 - gonna copy that go back
104:51 - and then is
104:54 - phone number valid
104:56 - and then i'm going to
104:58 - change that with this
105:00 - and then customer
105:02 - dot
105:03 - get phone number
105:05 - starts with that
105:08 - so if that is the case then it's valid
105:11 - otherwise so right here phone number is
105:14 - not valid let's go ahead and do the same
105:17 - for
105:18 - is adult so right here
105:20 - static
105:22 - and then customer registration
105:24 - validator
105:26 - is
105:26 - an adult
105:29 - there we go let me steal some code from
105:31 - here so
105:32 - this is what i want
105:36 - just like that go back
105:38 - and then customer
105:42 - will actually return customer
105:45 - and then i'm going to paste
105:47 - that
105:48 - and then right here
105:51 - customer dot
105:53 - and then get dob
105:55 - so if this is the case
105:58 - right so if the customer
106:00 - age is bigger than 16
106:02 - what i'm gonna do so let me put this on
106:04 - a new line
106:06 - so if it's bigger than 16 what i'm gonna
106:08 - do
106:09 - is simply return success otherwise
106:13 - is not an adult
106:16 - there we go indent this properly
106:18 - and there we go
106:20 - so
106:21 - one final thing that now we have to do
106:24 - is right here we have all of these
106:26 - functions of these three functions
106:29 - and the combinator pattern allows us to
106:32 - chain all of these functions together so
106:34 - the same way that you saw with a
106:36 - function where we can use and then and
106:39 - the same with predicates by using
106:41 - i think it was and
106:43 - right or or we can have the same logic
106:46 - with the combinator pattern so right
106:49 - here what i'm going to do here
106:52 - is the following so i'm going to have a
106:53 - default
106:55 - method and right here i'm going to
106:57 - return a customer valid data so the same
107:01 - thing that we did here and then i'm
107:02 - going to say and
107:04 - right so right here we're going to take
107:06 - a customer data
107:08 - and then i'm going to call other
107:11 - so basically this is where the magic
107:13 - happens right
107:14 - so i'm going to say other
107:16 - and
107:19 - inside i'm going to return
107:21 - and then customer
107:23 - and then inside what i'm going to do is
107:25 - simply say this dot and then apply
107:29 - so we are going to apply
107:32 - this customer
107:34 - and i'm going to shrink this to a
107:35 - variable so i'm going to say result
107:38 - and now check this out i'm going to say
107:40 - return
107:41 - and then result
107:43 - dot
107:44 - equals
107:46 - and then
107:47 - success
107:49 - so if it is equal to success
107:51 - i'm going to apply the other
107:54 - validator
107:55 - dot and then apply and then customer
107:59 - otherwise i'm going to simply pass the
108:01 - actual result not super result
108:05 - there we go
108:06 - so if we get to this point we know that
108:09 - we have an error
108:11 - so now this is complaining because i
108:12 - need to
108:13 - pass semicolon right here
108:16 - so let's go ahead now and use this
108:19 - awesome interface
108:20 - so let's go back to the main method
108:23 - right here
108:25 - and
108:26 - now let me simply comment this out and
108:29 - let me simply add an add sign right here
108:32 - or actually let me simply
108:34 - leave it as it is and then i'm going to
108:36 - show you exactly all the errors so now
108:39 - let's go ahead and simply say
108:41 - customer or actually not here um
108:46 - so
108:48 - using
108:50 - combinator
108:52 - pattern
108:53 - so right here let's go ahead and use a
108:54 - customer
108:56 - registration validator
108:58 - and then
108:59 - dot
109:00 - and check this out so we have all of
109:03 - these methods right is an adult is email
109:06 - valid and is phone number valid
109:09 - so let me go ahead and simply start with
109:11 - is
109:12 - a email valid right
109:15 - but now what i want to do is the
109:17 - following
109:18 - so right here i'm going to say
109:21 - dot
109:22 - and then check this out we have this
109:25 - method so and right here so this is the
109:27 - one that we defined so i'm going to say
109:30 - and
109:31 - and then let's use the rest so if i do
109:34 - if i press
109:35 - ctrl shift you can see that we have the
109:37 - other methods so is phone number valid
109:42 - dot and then and
109:44 - and then is an adult
109:46 - there we go
109:47 - so
109:48 - if i
109:50 - now
109:51 - add a static import
109:52 - you can see that now this becomes much
109:54 - much cleaner so now
109:59 - we have these three methods that we have
110:01 - chained together the way that we use it
110:04 - is simply by saying dot and then apply
110:07 - and then pass customer
110:09 - there we go
110:10 - now if i extract this to a variable
110:12 - so result
110:14 - and let's go ahead and simply say south
110:17 - and then result
110:19 - so now
110:22 - what i'm going to do here is say if
110:25 - and then result
110:28 - not
110:28 - equals to success so success
110:33 - we're going to throw
110:35 - so let's throw
110:37 - so throw
110:39 - new illegal state exception
110:41 - you could have your own exception but
110:43 - for now let's go ahead and throw an
110:44 - illegal state exception and then the
110:47 - actual result
110:50 - dot
110:50 - and then name
110:53 - there we go
110:54 - and basically this will actually print
110:57 - out the same thing right here but i want
110:58 - you to see the actual result so
111:01 - let's go ahead and scroll up and let's
111:03 - start with a valid customer so at gmail
111:07 - and then the phone number has to start
111:08 - with plus and then zero
111:10 - so if i go ahead and run this
111:15 - there we go we have success right here
111:19 - and
111:20 - if i scroll up let's now check all the
111:23 - validation that we have so let me remove
111:26 - the add sign
111:28 - and then
111:29 - run
111:31 - there we go you see that email is now
111:33 - valid and we've thrown an exception
111:35 - right so email or valid
111:38 - so if i add that back
111:41 - and if i remove it plus here
111:44 - run this
111:46 - there we go phone number not valid
111:49 - and if i had a plus there
111:51 - and let's make sure that this guy was
111:54 - born
111:55 - uh you know 2015
111:58 - or this guy
112:00 - alice was born 2015 so which means that
112:03 - you know she's not an adult so if i run
112:06 - this
112:08 - you can see that is not an adult right
112:12 - and you can even customize your
112:14 - exception that we throw by including the
112:16 - name or you know an id or anything like
112:19 - that but basically now you can see the
112:21 - power of the combinator pattern so
112:25 - if you have more stuff that you need to
112:27 - change to this validation so let's say
112:29 - that the requirements change you can
112:32 - simply duplicate this
112:34 - and then have your custom implementation
112:36 - inside of the
112:38 - um interface that we've defined defined
112:40 - so this one right here so customer
112:42 - registration validator
112:45 - and then just chain all the validation
112:47 - logic and scenarios that you have and
112:50 - this is the power of the combinator
112:52 - pattern so one last thing that i want to
112:54 - show you is that
112:56 - so if i
112:57 - uh command
112:59 - z a couple of times there so basically
113:01 - so right here you see that we call dot
113:04 - apply so if i comment this
113:08 - and then right here let me simply
113:10 - remove the apply there
113:13 - so the cool thing about um you know
113:15 - these functions so let me change the
113:17 - variable right here
113:18 - to a validator so the cool thing about
113:22 - this right is that this is
113:25 - lazy right
113:27 - none of this stuff is run until we
113:30 - invoke the dot apply so if i say result
113:34 - right here you can see that we have all
113:36 - of these methods right we can compose
113:39 - applies on and so forth but
113:41 - if i run this
113:45 - you can see that nothing gets printed
113:47 - out and even if i for example right here
113:50 - so
113:51 - where we um
113:54 - return here so the email
113:58 - value
113:59 - so right here so is email valid so let
114:02 - me grab that
114:03 - and then let me simply south
114:05 - and then
114:06 - running email validation
114:11 - and then right here simply return that
114:15 - and end up with semicolon there so even
114:17 - if i run this
114:20 - you can see that we still get nothing
114:23 - but as soon as i
114:25 - uh revert all of this
114:29 - just like that
114:31 - and then call apply
114:33 - now check this out if i run
114:36 - you can see that we have the running
114:38 - email validation and i think i need to
114:41 - undo all of this
114:43 - and then run it again
114:46 - and there we go so running email
114:48 - validation right and then we have is not
114:50 - an adult and the actual exception
114:53 - so i hope that you see the power of the
114:56 - combinator pattern
114:58 - i
114:58 - use it whenever i can to perform
115:01 - validation like this and you should also
115:04 - do it if you have any questions go ahead
115:07 - and drop me a message
115:09 - otherwise let's move on
115:16 - all right so in this final section let
115:18 - me go ahead and explain you few things
115:20 - that
115:21 - will help you to fully understand
115:23 - the functional interfaces and functional
115:26 - programming with java so so go ahead and
115:29 - create a new package
115:31 - and
115:32 - in this package we're going to call it
115:34 - as final
115:36 - and then section right here
115:39 - so inside create a main method
115:42 - and then so let me
115:45 - put this full screen like this
115:48 - and then ps
115:50 - and then vm for public study void main
115:54 - and
115:55 - right here what i'm going to do is i'm
115:56 - going to write some javascript and there
115:58 - we go so what i want to touch on this
116:01 - video is call backs so
116:05 - maybe you've done some javascript and
116:07 - javascript they have this notion of
116:09 - callbacks so a function in javascript
116:13 - looks like this so this won't work in
116:15 - java but it looks like this so you have
116:17 - a function
116:19 - and then you give it a name so
116:22 - hello
116:25 - and then right here you might have for
116:27 - example a variable so let's say and then
116:30 - first
116:32 - name
116:33 - last name
116:35 - and then call back
116:37 - something like that right
116:39 - so
116:40 - right here what we're going to do is
116:42 - let's say for example the last name is
116:45 - not provided then we simply have like
116:47 - console.log so let's simply say
116:50 - console.log
116:52 - and then right here
116:54 - first
116:56 - and then name
116:58 - and then i can say if
117:01 - if we have last name
117:04 - then we're going to console.log
117:08 - and then last name
117:13 - otherwise we will have this callback so
117:16 - we're going to invoke the callback right
117:18 - so you might have seen code like this in
117:20 - javascript basically this is an extra
117:22 - function so if i take this command c
117:27 - and then go to chrome and then inspect
117:31 - and then right here go to console
117:33 - paste my function there
117:35 - and then enter
117:37 - you can see that we have undefined now
117:38 - if i say hello
117:41 - and then say
117:42 - first name
117:43 - john
117:44 - and then pass
117:46 - now there
117:47 - and then right here i can pass a
117:49 - function so this is a callback right
117:53 - so
117:54 - console
117:56 - dot and then log
117:58 - and then no
118:00 - last
118:02 - name provided and then end this with a
118:06 - parenthesis here
118:08 - if i now run this
118:10 - oops we have a error there and they
118:13 - should shouldn't have the column there
118:15 - so enter
118:17 - and you can see that now we have john
118:19 - and then no last name provided
118:21 - so basically you can see that this
118:24 - callback right here is a function and
118:25 - you can have like you know a lot of
118:28 - logic in it right
118:30 - but you know this is very simple so
118:31 - we're just logging but if you want to
118:33 - have for example
118:34 - an extra logic that goes to the database
118:37 - and there's you know some other stuff
118:39 - you could definitely do it i'm just
118:41 - showing you the callbacks in javascript
118:43 - so right here if i now pause so right
118:46 - here if i now say alex and then montana
118:51 - and then
118:52 - run this
118:53 - you can see that now we're not printing
118:55 - the actual callback right so now we have
118:57 - john and then montana the last name so
119:00 - we can achieve the same in
119:02 - java using functional programming and
119:05 - the functional interfaces so the way
119:07 - we're going to do it is as follow so let
119:10 - me simply
119:11 - comment this right here so you have it
119:13 - for reference
119:15 - so now what i'm going to do is actually
119:16 - have a static
119:18 - and then void and right here what i'm
119:21 - going to do is actually combine both
119:23 - worlds so we can have a
119:26 - regular method so normal java method
119:29 - and also
119:30 - inside as a parameter we can have a
119:32 - function right so this is you know
119:35 - programming because now we are free to
119:37 - do whatever we want so right here you
119:39 - see static void and then let's go ahead
119:42 - and simply say hello
119:44 - and then right here string
119:47 - and then
119:48 - first and then name
119:51 - string
119:52 - last and then name
119:54 - and then right here
119:56 - what do you think we need right so
119:58 - remember we've learned about functions
120:01 - by function consumers suppliers
120:04 - predicates so
120:06 - we kind of just want to have a function
120:11 - that might take for example last name if
120:13 - it's there print it otherwise have for
120:16 - example a default message so right here
120:19 - what we're going to do is simply say
120:21 - consumer
120:23 - and then of type and then string
120:27 - and then let's simply name this as call
120:29 - pack just like that
120:32 - there we go and then right here let me
120:34 - simply say south
120:36 - and then first name
120:38 - and then i'm going to say if
120:40 - and then
120:41 - um
120:43 - last name
120:45 - equals to no
120:46 - right we could even say is blank right
120:50 - but equals to null so if it's equal to
120:52 - null or actually let's revert this so
120:54 - it's the same as the
120:56 - function that we have right here as
120:58 - javascript so if it's not equal to no
121:00 - let's go ahead and say south and then a
121:03 - last name
121:04 - otherwise else
121:07 - we're going to say call back
121:10 - dot and then accept and then the string
121:13 - that we want is
121:14 - first name for example right so let's
121:16 - take this first name right here and then
121:18 - do something with it
121:20 - so now the way we use it is as follow so
121:23 - let's go ahead and say hello
121:26 - and then john
121:30 - right here
121:32 - and then montana
121:35 - and right here let's have our callback
121:37 - so let's go ahead and simply pass now
121:38 - for now right
121:40 - so if i run this
121:48 - there we go you see that we have john
121:49 - montana but now let's go ahead and
121:52 - define this callback so right here we'll
121:54 - have um
121:56 - a callback that takes a value and the
121:59 - value will be the actual first name it
122:02 - doesn't matter and then we will do
122:04 - something with it so right here
122:06 - south
122:08 - and then what did we have so
122:10 - right here we said
122:13 - last name not provided so let's do the
122:15 - same here
122:19 - and then four
122:21 - and then plus and then john and then
122:24 - value right
122:26 - so you could even you could even change
122:28 - this to first name if you want but i'm
122:31 - just going to leave it as value now if i
122:33 - run this
122:36 - you see that we have john montana but
122:38 - now watch this if i pass no right here
122:43 - and then run
122:47 - there we go
122:48 - no last name provided for john so
122:51 - basically i just want to show you that
122:52 - you can combine
122:54 - you know a normal function
122:56 - with
122:57 - these functional interfaces and do stuff
122:59 - like this
123:00 - and achieve
123:01 - a similar concept
123:03 - as javascript that they call callbacks
123:06 - so there are other languages that have
123:07 - the similar
123:09 - concept but javascript you see a lot of
123:11 - these callbacks been thrown and you can
123:14 - pretty much do the same with functions
123:16 - another way that you might see callback
123:19 - is
123:20 - so right here so because right here you
123:22 - might not want to pass a default value
123:24 - right so you might have something like
123:26 - this so right here
123:28 - let me just duplicate this
123:30 - and then call it two
123:32 - and then right here so i'm gonna simply
123:35 - remove this
123:36 - and then runnable
123:38 - and this will be the callback
123:40 - and then right here
123:42 - call back dot and then run
123:44 - right so this is a bit different now
123:47 - so right here the way we use it is
123:49 - simply say hello
123:51 - like here and then two
123:54 - and then right here you simply pass this
123:58 - runnable right here and you have no
124:01 - value there
124:02 - basically this now is the exact same
124:04 - thing
124:05 - as
124:06 - this concept right here right because
124:09 - we're not taking any value and because
124:12 - um i only have one line there i can
124:14 - simply do this
124:16 - and then check this out just like that
124:19 - and beautiful code so now if i run this
124:25 - you see that it's the exact same thing
124:27 - but right here we're not taking any
124:29 - arguments
124:30 - so there we go so
124:32 - this is how you combine both worlds
124:35 - where you can mix and match these
124:37 - functional interfaces with normal
124:38 - functions and have callbacks if you have
124:42 - any questions go ahead and drop me a
124:43 - message otherwise let's move on
124:50 - let me go ahead and teach you about
124:52 - lambdas
124:53 - so we've been using lambdas throughout
124:56 - this course with you know all these
124:58 - functions but basically let me show you
125:00 - exactly how they're used and for example
125:03 - if you only have one return statement if
125:05 - you have two arguments what you should
125:07 - do
125:08 - uh when using lambdas so
125:11 - let's go ahead and
125:13 - expand this so commander n1 and right
125:16 - here for this main method let me go
125:18 - ahead and simply name this as callbacks
125:22 - just like that
125:24 - now let's go ahead and create a new
125:25 - class and then simply call it as lambdas
125:29 - there we go
125:30 - oops not lambers but lambda
125:35 - and then this
125:36 - just like that
125:38 - now let me collapse that
125:40 - and then public static void main
125:43 - now inside let's go ahead and have a
125:46 - function
125:49 - there we go that takes a string
125:51 - and returns a string
125:54 - there we go so let's simply say
125:57 - uh print
125:59 - and then name
126:00 - equals two so this guy will take name
126:04 - and then right here
126:05 - so this part right here it's a lambda
126:08 - right so this is a lambda where
126:12 - this is the actual argument right so
126:14 - this name right here
126:16 - is what comes from this data type so
126:19 - right here then you have to pretty much
126:22 - just
126:22 - uh do the following so if you have only
126:26 - one line so if you simply return
126:28 - immediately you can simply do this so
126:32 - south
126:33 - and then
126:35 - actually not even south my bad
126:37 - so you can simply um and this is not a
126:40 - good example so not print name
126:43 - but let's simply say
126:46 - upper and then case
126:50 - name for example something like this
126:51 - right
126:52 - so now right here if you simply return
126:55 - immediately you can simply do this so
126:59 - name and then dot and then uppercase
127:02 - right
127:03 - so you can immediately do this so this
127:06 - is only when you have
127:08 - one
127:09 - return statement
127:11 - right after
127:12 - this um
127:15 - error right here
127:16 - so because you only have one return
127:19 - statement and you can even see that
127:22 - intellij is telling you that you can use
127:23 - a method reference so this is because
127:26 - right here this is the same as doing
127:29 - this
127:30 - right it's the exact same thing so
127:33 - this is more understandable
127:35 - but you know once you get too
127:37 - comfortable with this you'll start to
127:39 - use code like this
127:41 - now
127:42 - another thing is
127:43 - right here so
127:45 - if you have to do some extra logic and
127:49 - not return immediately you need to have
127:51 - these curly braces right here so now you
127:54 - can have a logic right so you can for
127:57 - example say if
127:58 - and then name
128:00 - dot um or actually is blank right here
128:04 - so if it's blank
128:05 - then you can
128:06 - throw
128:08 - new illegal
128:10 - and an argument exception something like
128:13 - this right
128:14 - and then right here
128:16 - otherwise now
128:18 - because
128:19 - i need to return i need to say return
128:24 - and then name to uppercase but also i
128:26 - need to
128:27 - add
128:29 - semicolon right here
128:31 - right so you can see that now
128:32 - this is the actual method body for this
128:35 - lambda right so this lambda so this is
128:37 - the entire thing right here
128:41 - so another thing that you could do with
128:43 - lambdas is you see right here
128:45 - where you have name
128:47 - so if this is a by function so by
128:50 - function
128:51 - uh just like that
128:53 - and then right here let's simply have
128:55 - um
128:57 - let's have an integer right here integer
129:00 - and this will be h
129:02 - right so now you see that
129:04 - i need to put age right here because
129:06 - this data type is for this one and this
129:10 - data type is for the second one
129:12 - right and string is what this by
129:15 - function returns now because i have two
129:18 - arguments i need to do this
129:22 - i need to enclose them within these
129:25 - parentheses so let me actually go back
129:27 - for a second so right here so where we
129:29 - have a function
129:30 - so you see this is a function
129:32 - i can even you know enclose them with
129:35 - parentheses but because i only have
129:38 - one
129:39 - argument
129:41 - right into this function right here i
129:42 - can simply ditch
129:44 - this right but if you have a by function
129:52 - and right here let's simply say integer
129:54 - again
129:56 - and then
129:57 - age now you need to enclose like that
130:01 - right
130:02 - and you could you know
130:04 - do something like another logic right
130:06 - here so south for example
130:09 - and then h something like that right
130:12 - and you know the way you'd use it is as
130:15 - follows so uppercase
130:17 - name dot
130:18 - apply
130:20 - and then
130:21 - alex let's have alex here and alex is 20
130:25 - right
130:26 - there we go and this returns a string
130:29 - right here
130:31 - upper
130:35 - cased
130:36 - name
130:39 - and then south
130:41 - and then uppercase name
130:44 - i can even in line this like so
130:47 - if i run this
130:55 - there we go so 20 and then alex
130:58 - so basically this is uh this logic
131:00 - doesn't really make sense but i just
131:02 - want to show you exactly different ways
131:04 - that you can use these lambdas right
131:07 - here
131:08 - so
131:09 - if you have any questions on lambdas go
131:11 - ahead and drop me a message otherwise
131:13 - let's move on
131:19 - all right so just to let you know that i
131:22 - think i didn't mention this at the
131:23 - beginning of this course
131:25 - but when you use these functional
131:28 - interfaces
131:29 - you see right here where you define the
131:31 - actual
131:32 - inputs and outputs of functions right so
131:35 - string and an integer and then string
131:39 - so these right here they have to be the
131:42 - object type and not the primitive so for
131:45 - example integer right so you could have
131:48 - an integer like this
131:50 - so integer and then number
131:53 - equals to no right
131:56 - and then you can also have integer and
131:58 - then let's say counter
132:01 - and right here
132:02 - i can't say
132:04 - this
132:05 - so this is invalid right because this is
132:08 - the primitive
132:09 - um
132:11 - version of
132:12 - this object type right here right so
132:15 - right here you either have to say a
132:17 - number so it could be negative number or
132:20 - positive number so if i do a zero right
132:22 - here you could see that this goes away
132:25 - so
132:26 - for that reason
132:27 - you are not allowed to have
132:30 - primitives in here right because if you
132:34 - have to pass nose then then you can so
132:38 - with primitives you cannot
132:41 - so right here you see that we have this
132:43 - integer right here so i can go ahead and
132:45 - simply say no right here
132:47 - and you see that works but if i was to
132:49 - have this integer so the primitive type
132:53 - that does not work
132:56 - and also
132:57 - one thing that i've been doing a lot
132:59 - throughout this course
133:00 - is having static right here so static
133:05 - so the reason why i've been doing static
133:07 - is because i'm outside so right here i'm
133:10 - outside
133:11 - of the main function and the main
133:14 - function is static right and you can
133:16 - only use
133:17 - static methods inside of this main
133:20 - function so right here you can see that
133:22 - this still works but if i remove the
133:24 - static keyword you can see that
133:27 - it does not work right so this is
133:30 - something that to bear in mind uh your
133:33 - functions and buy functions they don't
133:35 - have to be static right in fact having
133:38 - static throughout your code base is not
133:41 - practical so ideally what you would do
133:44 - is
133:45 - simply have for example so let's say
133:47 - that you have a class let me actually um
133:50 - put this inside
133:52 - so just like that
133:54 - so let's say that you have a class
133:57 - and then call this a service for example
133:59 - right
134:00 - what you should really be doing is like
134:03 - having you know publix
134:06 - and then your function for example or
134:11 - predicate or consumers right so consumer
134:16 - of string
134:19 - and then blur
134:20 - [Music]
134:21 - equals two
134:24 - and an s right
134:26 - just like that
134:28 - and then basically this is your public
134:31 - interface
134:32 - you can also change this to private
134:35 - or
134:36 - no
134:37 - access modifier at all so this is
134:39 - package protected right
134:41 - so just to bear in mind that
134:44 - you know they don't have to be static
134:45 - and you should avoid static but the
134:47 - reason why i've been using static is
134:49 - because i've been doing everything
134:51 - inside of this public static void main
134:55 - method
134:56 - so there we go if you have any questions
134:59 - on primitives and
135:01 - the use of solid keywords go ahead and
135:03 - drop me a message otherwise catch me on
135:06 - the next one
135:12 - all right let me go ahead and quickly
135:13 - show you the rules that come with
135:16 - functional programming and everything
135:18 - that we've learned throughout this
135:20 - course so the first thing i should know
135:22 - is that
135:23 - um
135:24 - there should be no state around
135:28 - your functions right so the functions
135:31 - they have to be pure functions so they
135:33 - shouldn't depend on any other state so
135:38 - for example if you have a global state
135:40 - like
135:41 - or a global variable your function
135:43 - should not depend on that global state
135:47 - right so that's the difference between
135:49 - pure and in pure functions so pure
135:52 - functions
135:53 - don't depend on global state impure
135:56 - functions do depend on global state
135:59 - and that comes with the side effects
136:02 - right so your functions should have no
136:05 - side effects
136:07 - other than
136:08 - everything inside of the body of your
136:11 - function right it shouldn't have a side
136:14 - effect
136:15 - outside of the function and also higher
136:19 - order functions so
136:21 - a function is considered to be higher
136:23 - order function
136:25 - if one of these two conditions are met
136:27 - the function takes one or more functions
136:30 - as parameters so we saw how to so we saw
136:34 - how to pass
136:35 - functions inside a normal functions
136:38 - right
136:39 - or if the function returns another
136:42 - function as result so with the
136:44 - combinator pattern that's exactly what
136:46 - we've done so let me actually show you
136:48 - so right here so with callbacks so right
136:52 - here
136:56 - so right here
136:57 - so you can see that right here we are
136:59 - passing
137:00 - a function right here so this is a
137:03 - function right and also within our a
137:07 - combinator pattern so remember so
137:10 - customer and then registration validator
137:15 - check this out so right here
137:17 - we are
137:18 - returning
137:19 - a function so this interface extends
137:23 - customer
137:25 - or actually extends function that takes
137:27 - a customer and sends a validation result
137:30 - but if you check the return type of
137:32 - all of these methods right here so if i
137:35 - do a
137:36 - command shift
137:37 - and then minus you can see that
137:40 - they all return
137:42 - the function right here so this means
137:45 - that
137:46 - we are satisfying with this property
137:50 - higher order functions
137:52 - so
137:54 - make sure that for example let me
137:57 - actually show you uh you know the no
137:59 - state and pure functions inside effect
138:01 - so if i go back to
138:02 - let's say lambdas right here
138:05 - so you see this function right here so
138:07 - ins by function right here so
138:11 - i should never depend
138:13 - on for example counter right so let's
138:16 - say that i do for example south
138:19 - and then counter or if i change the
138:22 - state of counter right i should never do
138:26 - this because it will break
138:29 - all of this right so you see that there
138:31 - might be some side effects on the
138:34 - outside of
138:35 - this function right here right so
138:39 - outside of this function there might be
138:41 - there's some side effects
138:42 - also you see that
138:45 - you are now mutating state
138:48 - and it's no longer a pure function it's
138:51 - an impure function because it depends on
138:55 - um
138:56 - global state so you never want to do
138:59 - this or for example increment the number
139:02 - so number
139:03 - and then you know increment um you know
139:06 - plus plus something like that you should
139:08 - never do it right so your functions
139:11 - right here they should be
139:13 - self-contained right
139:16 - so they should only depend on the state
139:18 - that you define inside so right here i
139:21 - could say in inc and then counter
139:24 - equals to zero so this is absolutely
139:27 - fine right because this counter
139:31 - so this counter right here it's only
139:33 - visible inside of this function and not
139:36 - the outside world
139:39 - so if you have any questions on these
139:41 - properties
139:42 - go ahead and drop me a message and i can
139:43 - give you more examples but this
139:46 - is pretty much everything you need to
139:49 - know about functional interfaces and
139:51 - functional programming
139:53 - with java
139:55 - if you have
139:56 - any questions go ahead and drop me a
139:58 - message
139:59 - next let's go ahead and wrap up this
140:02 - course
140:08 - okey dokey amigo
140:10 - i want to congratulate you for
140:12 - completing this course and practicing
140:14 - throughout so as you saw for you to
140:17 - write functional programming you just
140:19 - have to shift the way that you think you
140:22 - no longer think about regular java
140:25 - functions but you start to use functions
140:28 - by functions
140:29 - predicates consumers suppliers so on and
140:32 - so forth
140:33 - now the next step for you is to enroll
140:35 - to my course on java streams api because
140:39 - once you combine everything that you've
140:41 - learned in this course with java streams
140:44 - you will start to write code that really
140:47 - really shines
140:49 - instead of you writing code that takes
140:50 - for example 20 lines of code you simply
140:53 - take
140:54 - five lines of code with streams and
140:56 - functional interfaces
140:59 - so this is all for now go ahead and
141:01 - subscribe to my channel to get more
141:03 - videos like this and it really means a
141:05 - lot to me to see a lot of you you know
141:08 - sending me messages suggesting for new
141:10 - courses
141:12 - and i'm trying my best to give you
141:15 - awesome content
141:16 - that will allow you to become a software
141:19 - engineer also if you haven't joined the
141:21 - private facebook group go ahead and join
141:24 - because that way you can see what's up
141:26 - you can connect with all the students
141:28 - and if you have any questions just drop
141:30 - them and i'm pretty sure one of us will
141:33 - be able to help you this is all for now
141:35 - and i'll catch you on the next one see
141:37 - ya
141:41 - [Music]

Cleaned transcript:

thank you what's going on guys welcome to amigos code my name is nelson and in this course i'm going to teach you everything you need to know about functional programming with java so when i first saw functional programming i was like you know what is this i saw functions by function predicates being used all over the place and to be honest i only realized the power of it when i learned about the clarity of programming so you see most of us write imperative programming which means that you define every single implementation detail of your code whereas declarative you simply tell it what you want instead of defining you know the details for example you might have a variable or actually you might have a loop right so you define you know the initial value how to increment it and how to stop it right so with declarative programming you have none of that you simply tell it what you want and that's what i'm going to teach you in this course so in this course i'm going to teach you exactly you know what the differences what the differences are between imperative and declarative programming and why you want to move away from imperative programming then i'm going to teach you about the functional interfaces that java has to provide so functions buy functions predicates consumers suppliers and all that good stuff right so once you learn that you can then start to use streams and optionals to write code in a declarative way and then towards the end i'm going to teach you one of my favorite design patterns when it comes to functional programming and that is the combinator design pattern which is really really awesome it's really good for validation where you simply define all of your validations in an interface and then you define exactly step by step what you want your validation to be it's really really awesome and finally i'm also going to teach you exactly about lambdas callbacks and the properties of functional programming so that you fully grasp exactly the whole concept so if you haven't subscribed to my youtube channel go ahead and subscribe because that way i can you know provide more awesome content like this without further ado let's go ahead and learn everything you need to know about functional programming with java all right so before you start this course i want to make sure that you really learn from this course because i want to add value so what i want from you is to go ahead and practice as i teach because that's the best way for you to learn any new technology also go ahead and join the private facebook group so if you have any questions you can go ahead and engage with other students and the group is full of cool people just like you so this is all i wanted to say for now and enough of me talking let's go ahead and learn about functional programming all right let's go ahead and bootstrap our application where i'm going to show you all the examples throughout this course so i've got intellij right here and if you've never used intellij then i highly suggest you to enroll to my free course where i teach you pretty much how to use this awesome ide and to be honest as a software engineer this is probably the ide of your choice when it comes to java backend development so let me go back to intellij and the first thing i want to do is to create project and right here i'm going to pick maven now the project sdk it doesn't really matter whether you use java 11 12 or any other version as long as is above 1.7 so i'm going to stick with 11 right here and as i said the version does not matter next let me go ahead and click next and then right here for the group id i'm going to say com dot and then amigos and then code so right here this could be your own organization and right here let me simply name this as java and then functional and then i'm going to press next and then i'm going to save this under code and then java functional and then simply press finish there we go let me actually collapse this maven tab right here and also let me collapse this and right here go ahead and simply enable auto import to import dependencies and this is the actual palm file right so if i open the functional oh actually java functional folder inside you see that we have only the pump file and this contains the group id artifact id and then the actual version so let me just remove that line and also remove this popup and finally i'm going to put this full screen and this is all and actually let me just close this because we're not going to need this palm file and this is pretty much everything you need in order to bootstrap the application to follow along so obviously i'm going to give you the source code at the end of this course but i highly suggest you to practice as i teach because that's the best way of you learning any new topic this is all for now if you have any questions about intellij as i said go ahead and roll to my course right here where i teach you everything you should be aware of this awesome ide let me go ahead and give you an example of imperative programming so imperative programming involves you as a developer defining every single detail about your implementation so right here inside of the source folder inside of main and then java let's go ahead and create a new package so you can right click on this folder or i'm going to use keyboard shortcuts and also you can see down here so right here you can see all the keyboard shortcuts that i'm going to use throughout this course so right here i'm going to use the error so i'm going to select package and then right here i'm going to name this as imperative and then okay now inside go ahead and create class and this will be called as main now let me collapse this and inside i'm going to type p s and then vm for public static main there we go and now we have a main method that we can run so let's go ahead and define a list and the type of this list will be of type and then person so right here let me go ahead and simply name this as people equals to and then list and then dot and then off so right here what we're going to do is simply create few people or actually a few people of time person so right here let's go ahead and simply create a class so uh let's go ahead and say static and then class and then person and this person will have a name so private and then final string and a name and we also will define a gender so enum and this will be gender and the gender will be male or female and then right here what we're gonna do or actually underneath is simply say private final and then gender and that will be the gender and let me add this to constructor and there we go so now we have this class right here called person and let me also define a two string method right here so two and then string and there we go so now right here we can simply say list of and then new and then person and right here let's give it a name so john and john is a male and let me have a static import for this and let's go ahead and duplicate this so i'm going to press command d a couple of times and there we go so let's have maria and she's a female let's have aisha she's also a female just like that let's have alex it's a mel and let's finally have alice just like that and alice she's of course a female so now that we have this list right here let's go ahead and find out how many females that we have so the way that we will do it with the imperative approach is let me add a comment right here so in an imperative approach is simply by doing the following so first we need an empty list and then of type and then person and then let me simply say females right here equals to a list of and then or actually not even a list of let's go ahead and use a new and then array list so this is an empty list now what we need to do is to loop through people so let's go ahead and simply say four and then person and then person inside of people and right here we're going to say if and then person or actually let me go anything to say female and then dot equals to person dot and then gender just like that so if this is the case i'm going to say females dot and then add and then person just like that and that would semicolon and then right here at the very end what i'm going to do is simply print each people so again let me simply copy this just like that and then right here this instead of people this will be females and this will also be female and then south just like that so system.out.printline oops just like that and then female now if i go ahead and pretty much run this class right here so let's go ahead and run this class can and there we go so right here you can see that we have only females in our output and basically this is pretty much what imperative programming is so basically we are defining every single detail so right here you can see that first we have an empty list and then we loop through that and then we have an if statement and finally we have a final for loop looping through females and you can see that there is a lot of logic not you know you know a substantial amount of logic but you can see that for example this if statement is some logic and also you can see that this is a lot of code for something very simple and this is what i wanted to show you about the imperative approach next let's go ahead and implement this using the declarative approach and you will see that it's much neater and we pretty much just tell it what we want to do instead of defining every single implementation detail right here so to use declarative approach with java ia functional style programming we simply have to do the following let me let me collapse this so right here so what we're going to do here is instead of us creating a list and then having two for loops what i'm going to do is the following first let me go ahead and pretty much have a comment and right here this will be declare relative and then approach now the way that we use declarative approach is by using streams with collections so don't worry about um so much about what a stream uh is because i'm gonna show you exactly later on but for now just follow along so go ahead and simply say people so people is the original list right here so this list of people and then dot and then stream right here so now we have a stream and a stream allows us to go into an abstract mode where we simply tell it what we want so right here let's go ahead and simply say dot and then filter and what we want to filter is basically this so right here we have a person so this takes a person and then i'm going to say the exact same thing right here so i'm going to take this if statement oops let me press command w a couple of times command c and then put it here there we go so you see that i'm filtering and then this takes a person and i'm using this same if statement so basically female.equals and then person.gender right and then finally i'm going to say dot and then collect and then collectors and then to list end up with semicolon and right here what i'm going to do is put this on a new line and the same with collect just like that and right here we can simply now go ahead and simply say dot and then for each and then we can use system dot and then out and then column column and then print line so now let me actually add um right here so let me simply add this as a south so i'm going to print this just like that there we go and let me do the same here so i'm going to copy that and then paste that take this comment put it here so you can see exactly in the console what i'm doing so now you can see that this is much concise and right here you can see that i'm not creating a list and then adding to that list and then doing the if statement so on and so forth so you can see that is very straightforward and i'm just telling what i want so from the people array list or a list basically this is a list i'm going to stream so i'm going to go into this abstract mode then i'm going to filter all the females and then i'm going to collect to a list and finally i'm going to print everything so technically i don't even need this collector list because i'm simply printing out things so let me simply run this for now so you can see exactly what's happening there we go so basically you can see that we have the exact same output right so if i put this whole screen you can see that we have the exact same output but the declarative approach is much neater so obviously if you were to have this into a list right here so this is where collect comes into play and then i can remove this line and this with semicolon and then extract this to a variable and then say females and then two right and you can see that now i've got a list right here and i could again simply say females to dot and then for rich system dot out column column print line so if i run again you can see that this is the exact same output so there we go now you should have a full understanding of the differences between declarative and imperative approach so obviously i've just shown you uh you know the difference between both but there are a few things that we need to understand in order to write code like this right so i'm going to teach you about functions by functions predicates by predicates consumers and you know all the good stuff that java has to offer when it comes to functional programming if you have any questions go ahead and drop me a message otherwise let's move on all right let's go ahead in this section learn about the java.util.function package so basically this package contains functional interfaces that provides target times for lambda expressions and method references so each functional interface has a single abstract method basically you can have one interface with multiple methods but you must have only one single abstract method to be considered as a functional interface so basically you can see some examples right here so the assignment the assignment context so this is how you for example define a predicate and this is how for example you use it within the actual uh you know stream so right here you've seen that we can get stream from a list right so streaming and filter and there's another example where you can do some casting so this package right here contains a bunch of functional interfaces right here you can see by consumer by function binary operator by by predicate boolean supplier consumer and the list goes on so they are pretty much identical apart from the type so the ones that you will most likely be using are functions by functions predicates by predicates and consumers and also there is a by consumer but i'm like but i'm going to explain exactly how everything fits together because once you learn those main ones then the rest will be very simple so right here i want to show you that so we have a predicate so where is the predicate so let me find predicate so right here so a predicate let me quickly show you a predicate and show you that we actually have used you know a predicate before so a predicate represents a predicate basically this particular represents a predicate a boolean value function of one argument so let me go back to intellij and right here remember where we had this declarative approach so right here so this filter so basically if i pretty much extract this into a variable you can see that this is a predicate and look at this this predicate looks like this so the predicate accepts a person and then returns true or false based of that person i.e whether the person is of type female right but what we've done right here we simply inlined like that that's why you don't see the predicate keyword but indeed this is a predicate and a predicate looks like this so don't worry about this if it doesn't make sense but i'm going to try my best to explain you exactly how you go from uh you know normal java functions to the functional interface world join me in the next one all right so i've gone ahead and created a new package right here called functional interface and inside of this package i'm going to go ahead and create a class and first i want to name this class as underscore and then function and i'm going to explain why i'm saying underscore right here but for now go ahead and simply say underscore and fun underscore function or you can name this anything other than function without underscore right so right here what i'm going to do is simply say public static void main to have a main method and right here what i'm going to do is simply do the following so let's go ahead and create a function so static and then function so this function will take a number right so take a number and then increment that number by one so let's go ahead and simply say int and then increment and then this will take an integer number and then it will return number and then plus one so now if i go ahead and simply say increment and then zero and then end up with semicolon and if i pretty much extract this to a variable and for now let's go ahead and simply sound this increment and let me put this full screen let me run this now oops i'm running the wrong one so i need to run this function there we go so you can see that the result is one very simple so if i put one right here this will be two so what i want to show you is how we go from this so this is what you are used to to this right here so let's go ahead and learn about the function um interface so where is the function so this one right here so this says that represents a function that take that accepts one argument and then produces a result so this is pretty much what we have here right so this function that we have so this is a normal function in java so this is what you are used to so this takes an input and then returns one single output right here and this is pretty much the equivalent right here so represents a function that accepts one argument and produces a result so the way that we convert this into a function right here is the following so let's go ahead and simply say function and if i actually delete this so i want to show you something so function you can see that this function takes a t right so t and then r so basically these are the data types of the input and the output so let's go ahead right here and simply say that this will be of type integer so the input is integer and the output is also an integer right here so now let me go ahead and simply say increment and then function or actually increment by and then one function right here and then this will be equal to right now this is where things become a bit tricky so here equals two and then this will be the actual number and then right here we pass a lambda and then i'm going to say number and then plus plus there we go and i would semi column so you can see that this and this are the exact same thing so basically this integer right here corresponds to the actual input so this one right here right this data type this integer corresponds to the return type and then this number corresponds to the parameter to this function right here and then i'm saying number plus plus well actually let me simply make them the same so number plus one and let me also rename this function to increment by and then one so you can see that this is pretty much the same but now we are talking in functional style world so now the way that we use this is as follows so go ahead and simply say increment by one and the reason why we're not seeing this this function is because we can actually put it inside of this method so inside of this main method we can paste that function there or if you want this can also be static like that right so let me actually um put this on a new line so you see exactly how it is so right here i can say increment by one function and what i'm going to do is simply say dot and then apply so the apply pretty much takes the actual argument so let me go ahead and simply say 1 and then right here i'm going to say increment and then 2 and i can change this data type to integer and then simply say south and then increment 2 then let me simply run this again you can see that we have the exact same output so this is how you use a function so basically it's the exact same thing as this function right here but in a functional style way so if you have any questions about this go ahead and drop me a message but i'm gonna show you exactly how all of this fits together right because now you might be asking you know why should i use uh you know this function right here instead of a normal regular function right and don't worry by the end of this course everything will be clarified so there are a few methods that i want to teach you so right here if i pretty much say increment function uh or actually increment by one function dot you can see that we have um apply and then this method right here and then so i want to teach you what this method is because you might use it later on so let me simply remove that and this is all for now join me in the next video see ya all right let's say that you want to combine multiple functions together to achieve a desired state or a desired output so let's say that you have this function right here so increment by one function but let's also create another function oh actually let me not copy base but simply say static and then function and this function will take an integer and this function will also return an integer and then i'm going to say multiply by and then 10 right here so this will take the number oops number and then this will be lambda just like that and then number times and then 10 just like that so we have this function right here and what we want to do is after incrementing so after incrementing uh by one right here we want to apply that or the function immediately so you could do something like this so you could say int increment or actually multiply and then equals two and then multiply by ten uh let me actually rename this to a function just like that and then right here you could say equals to multiply by 10 function dot apply and then increment nn2 right so uh this is not quite right because this is a name so right there and then remove that and this should be multiply by 10 let me grab that name there paste it there and there we go so now if i do a south and then multiply by 10 function well actually i'm getting all confused right here so this should be multiply there we go so this is the actual output so now if i run this you can see that we take 2 multiplied by 10 is 20. so obviously this is you know quite normal for us to do but we can do something better so what we can do is simply combine the two functions together so right here what i'm going to do is simply say increment by one function dot and then and then multiply by 10 function and right here what i'm going to do is simply extract this to a variable so this will give us yet another function and let me simply say add by 1 and then multiply by 10 there we go so if i put this on a new line and you can see exactly what it's doing so now let's go ahead and simply say add by 1 and multiply by 10 and then simply say apply and you can see that you can keep on you know chaining these functions as you go along but for now let's simply chain two functions so now i'm going to say apply and the number that i want is one right so this should give us the exact same result so 1 plus 1 2 2 plus 10 you guessed it right that would be 20. so obviously i need to put this around system.out.printline just like that run this again you can see that we have 20 right here so if i change this to let's change this number right here so instead of one let's go ahead and change it to four four plus one five times ten fifty right here and this is pretty much how you chain functions together so if you have any questions go ahead and drop me a message next let me go ahead and teach you about by functions all right so what a by function is is the same as a function but instead of taking one input it takes two inputs and produces one output and by function for two things right so right here we have this function right here so this one add by one and multiply by 10. so let's say that the first number that we give it is the one that it should increment and then the second one is the one that it should multiply by so right here let me go ahead and define this as a normal function so you can see exactly um the equivalent so increment and we'll actually increment by one and multiply just like that so now right here we have a second argument so int num to multiply by just like that and now i'm going to wrap everything within parenthesis and then say times and then num to multiply by now the way that we define the exact same thing but using a by function is as follow so let's go ahead and simply say buy and then function so the first argument is the first input which is the actual number that we want to add one by so let me go ahead and simply say this is an integer the second one is also an integer the third one is also an integer so bear in mind that you can have different data types depending of your circumstances so right here let me simply say that this will have the same name but by function so usually you wouldn't include the pi function for the name but i'm just doing it so that you understand exactly and reason about these things so right here this now will take two things so because it takes two arguments we need to wrap this within parenthesis so this will be number to increment by one and then number two mul t ply and then buy and this will be now a lambda and what we do is simply say number two increment by one plus and then one right so this is the exact same thing that we did here and then this will be within parenthesis and then finally times and then number to multiply by and that would semicolon and let me just put this on a new line yet again so you see exactly everything so i've got bigger font because i want you to see exactly properly but you know you shouldn't indent things like this but basically this right here is the exact same thing as this so now let's go ahead and use it so right here remember we had this function so add by 1 and then multiply by 10. so let's go ahead and say this now is a by function and this was the function example so let me actually add a comment so takes one argument and produces one result so now the by function is almost the same but it takes two arguments right here so let's go ahead and use our function so right here so increment by one and then multiply let's go ahead and give it four and then let's multiply four by one hundred so basically this will be four plus one five five times 100 500 so let's go ahead and simply uh i'm not going to even put this into a variable i'm simply going to say south and then just like that so let me put like that and there we go so now if i run this you can see that we have 500 right here now let me go ahead and use the by function so if i escape out of this and let's actually have the same system right here so system.line and right here let me simply use the actual function i think we have to have it as static so this guy right here so this has to be static there we go now it should appear by function and this should be dot and then apply and apply takes 4 and 100 now if i run this you can see that we have the exact same result so this one right here is using normal java function and this one right here is using the buy function let me go ahead and show you the actual docks you'll see that we have lots of buy so let me say let me search for buy so you could see that we have you know a double by function to int by function to long by function and all of these by functions are the exact same thing as the function but they take two arguments as you can see here right so the same with predicate so it takes two arguments and returns true or false so this is the difference between a function and a by function if you have any questions go ahead and join me message otherwise let's move on all right next let's go ahead and learn about consumer so a consumer so let me search for consumer right here so consumer so a consumer represents an operation that accepts a single input argument and returns no result so let me show you exactly first the nonfunctional way and then the functional way so let's say that right here again let's have public static void main and right here let's go ahead and define a static class and then customer and then let's go ahead and simply say private final and let me put this full screen so private final and then string and then customer name private final string customer phone number just like that so next let me add that to constructor and now what i'm going to do is have a function right here so let me go and simply say static and then right here let's go ahead and say greet and then customer so this will take a customer and right here let's go ahead and simply say south and then hello and then customer and then dot customer name and then right here plus and comma thanks for registering and then phone number and then plus customer dot and then customer phone number so let me actually put this on a new line so you can see everything so now let's go ahead and simply create a new customer so new customer this will be let's say that maria and then my real phone number will be 99999 right so let me go ahead and cut this and then simply say great customer pass new customer just like that and end up with semicolon just like that so now if i run this class you can see that we have hello maria thanks for registering phone number 9999 so the way that we achieve the same but using the functional interface so the consumer functional interface is by doing the following so let me go ahead and simply say static and then consumer so consumer takes one argument so this will be of type customer and then right here let me go ahead and simply say greet customer consumer equals to and then we'll take the customer what we're going to do is pretty much the exact same thing right here so let me grab all of this and then paste it there and basically now i can go ahead and simply say greet customer consumer dot and then right here instead of apply we simply accept now let me go ahead and extract this customer so maria and then also pass maria right here so there we go so this is using functional interface so this is actually consumer and then normal java function right so if i run this you can see that we have the exact same thing right so basically a consumer takes one argument and pretty much returns nothing it's like a void function right so this customer right here is the data type of the input so is this one this customer is the actual name of the uh input so this customer right here and void you could technically say that void is a consumer so if you have any questions on this go ahead and drop me a message otherwise let's learn about by consumers all right so let's go ahead and learn about the buy consumer so the same way that we've done with functions and by functions we have the same for consumer so pretty much every one of these uh functional interfaces they have the buy version so in front of it they have the buy version so the by simply means that instead of taking one argument it takes two arguments now let's go ahead and change this function so let me simply grab that and let's go ahead and simply say v2 for example so this will be the version 2. so what we're going to have is a by consumer right here and let me import this so first we will take the customer and then we will have the boolean so right here so this boolean so this boolean will represent whether we should hide the customer's phone number show and then phone and then number so now we have an error because we have two arguments and because we have two arguments we need to enclose these within parenthesis just like that now right here what i'm going to do is instead of printing the actual phone number like that i'm going to say the following so i'm going to put this within parentheses just like that and right here i'm going to say show phone number so if show phone number then we can pretty much print that otherwise i'm simply going to have some stars just like that so now let's go ahead and test this out so let's go ahead and simply say great customer v2 and let's pass maria and then right here let's simply say true for now so this is actually complaining because we need to say dot accept and if i run this you can see that this is the version two of our function now let's go ahead and simply say false run that and you can see that now we are hiding the number right here so basically if you were to convert this into a normal regular java function this would be as follow so let me just duplicate all of this just like that call this v2 and then right here we simply take the exact same variable so show phone number but right here boolean show phone number and let me grab everything from here and then put it here there we go and i would semicolon and i can simply now go ahead and say get oh actually great customer v2 pass maria and then true run there we go and you can see that we have the exact same information so there we go this is how you use a by consumer if you have any questions go ahead and drop me a message otherwise let's move on all right let's go ahead and learn about predicates so i've gone ahead inside of the functional interface package created this underscore predicate class and inside let's go ahead and simply type public static void main and let's go ahead and learn about predicates so let's say that you want to do the following so let's say that you have a function so a normal travel function so static and then this will return a boolean and right here let's simply go ahead and say is phone number valid so let's go ahead and simply take a phone number so string and then phone number and for now let's go ahead and keep it very simple but this validation is not real but it's just to illustrate the actual example and purpose of predicates so right here let's simply say that this note this phone number in order to be valid it has to meet the following criterias so let's return phone number dot and then starts with and let's say that the phone number has to start with zero seven and let's also say that the phone number and phone number dot and then length is equal to eleven so this is a simple phone validation uh method but this is not real it's just to illustrate the purpose now let's go ahead and simply do a south here and let's go ahead and have this phone number so zero seven and then zero zero zero zero zero zero zero zero zero and let's have another one zero and then nine and then we can add um you know a couple digits like so right so the validation is not real but this will illustrate the purpose so now if i run this so let me run this main method you can see that i'm printing the number but what i meant to do was to actually let me cut this so what i meant to print was is phone number valid and then pass the actual phone number so same with that one cut it is phone number valid and then paste it run it again you can see that the first phone number is valid so it meets the actual criterias let's also have another one so the same but this will be 10 characters long and if i run this again you can see that the first one is valid the second one the second one the second one isn't and the third one isn't as well so right here we're simply doing a simple phone validation uh check now in order for us to use the functional style we can use the predicate so predicate right here so you can see represents a boolean valid function of one argument right so right here the way that we use a predicate is as follows so this exact same function as predicate will be something like this static and then right here predicate and then this will take a string so this will be the phone number and then let's copy this exact same name and then let's simply say predicate and right here this will be equal to and then phone number so let's actually grab this and then this lambda and on a new line i'm simply going to grab this and then paste it and then end with semicolon now let's go ahead and use it so to use it is phone number valid predicate dot and then test so this is the actual method that we need to use so now we're going to test the following let's test the first number so we know that the first number is valid so basically this will be the exact same thing so we need to simply south this just like that there we go and let me duplicate this and basically we should have the exact same output there we go and then paste that in let me do south without predicate and then right here weight predicate and if i run this you can see that we have the exact same result so true false false and without predicate true false false so basically this is the equivalent so the predicate is the equivalent as this normal java function and the cool thing about predicates is that you can have a bunch of predicates and then combine them together so the same way that we've done with function using and then we can we can also use it with predicates so let's say that we have another predicate so let's have another project so static and then predicate and this predicate will take a string and then let's say contains and then number and then let's simply say number three so if the phone number contains number three so phone number and right here i'm simply gonna say phone number dot and then contains and then three just like that now the way that you change predicates is as follow so right here let's simply go ahead and say is phone number valid so we're gonna pass this phone number so this one right here there we go and then we can say dot and then is phone number valid predicate dot and then and another predicate so the other predicate is contains number three dot and then test let's actually pass this number right here so the last one there we go and let's wrap everything without a system.print line let me put this on a new line and just like this there we go so if i say right here is phone number valid and contains number three equals and then plus the actual result let's do the same for a different number so let's actually let's actually do for this one very first one so right here and let's actually put a three right here so this should be false because the phone number isn't valid but it contains number three right here but this one the phone number is valid so it starts with zero seven eleven characters long and contains number three at the end so let's go ahead and run this method and there we go so you can see that the second one is true as i explained why and the first one is false now you can use ands but you can also use or so or means either one of them is true so if i was to say right here so instead of and i can use or right and then if i remove three here and put a zero run this this will still be true if true because we only need one condition to be true if you use an and so if you chain multiple predicates together using an and all of them have to be true so the same way that we have predicates we have by predicates by and then predicates right here and basically they are the same thing but instead of taking one argument they take two arguments so i'm not going to give you a full example on by predicates because you should be familiar now with by predicates by functions by consumers so on and so forth so if you have any questions on predicates go ahead and drop me a message otherwise let's go ahead and learn about the final functional interface i want to show you and then we can start putting all the puzzle together so that all of this starts to make sense and how you actually end up using it join me in the next one see ya all right go ahead and inside of the functional interface package create a class called underscore supplier with a public static void main method so let's go ahead and learn about what a supplier is so if i go to the docs right here you can see that they say supplier t represents a supplier of results so basically sometimes you might have a method right here that simply uh let's say that we have a method like that so like a method like this so static and then get or actually string get connection url watch let's simply say get db connection url right so this will take no arguments and let's simply return and then for example j dbc column for slash forward slash localhost and then 5432 forward slash let's say users right so this is not real but you get the idea so the way that we can use this function now is if i simply say south and then get db connection url and then if i run this you can see that we get the actual connection url for some kind of database so the purpose of this function right here is simply to return a value right here so this is the value that it returns so we can do so we can use a supplier to represent the exact same thing so i'm going to copy this url and to have this java function as functional we simply have to say supplier or actually static and then supplier and then this will supply a string and then get let's grab this and then supplier and right here equals two and then what we need to do is simply have parenthesis and then we simply pass or actually return this just like that so if i put this on a new line so you can see exactly what i'm doing and you can see that now this is the exact same thing but if i go ahead and simply say system.out.life so south and then right here to use this i can say get db connection url supplier dot and then get so now if i run this i do get the exact same result so this is pretty much how you use a supplier so a supplier simply returns any kind of value that you want right so this data type doesn't have to be a string it could be you know your custom classes your custom objects um you know an array pretty much anything that you want so for example if you wanted to return a list right here you could simply say list and then of type and then string right here and then here i would say list dot of and then just like that and that would semicolon right so now if i run this you can see that this now is a list so if i was to return something else so right here let me simply add comma new line and then this like so so it's much neater just like that oops just like that and right here let's simply say uh customer for example right so get a connection urls and then supplier and then here urls run this and there you go so now we are returning a list with two urls so if you have any questions on suppliers go ahead and drop me a message otherwise let's move on all right so by now you should see exactly the differences between writing a normal java function and functional interfaces so the benefit of you know knowing the functional interfaces is when you start to use optionals and streams but more specific streams right so once you start using streams with all of these functional interfaces you will start to write clean code and that's what i'm going to teach you next okie dokie now that you've learned about consumers functions by functions predicates by predicates and suppliers and also i think by consumers now let's go ahead and actually learn how this is useful to us when writing code so go ahead and create a new package under java so package and call this as streams now go ahead and create a new class and simply call it underscore and then stream just like that enter public static void main enter now remember inside of the imperative uh package go ahead and open that up and let's actually steal some code so right here let's steal all of this so the enum gender as well as the person class so let me close this and then right here let me paste that in and i'm gonna cancel because i don't want to import from imperative.main so cancel and let me go back again and let's actually steal some code again so let's take this list right here so we're going to take this list and then we can close this once more and then right here inside let's go ahead and paste it and you see right here it's trying to import from imperative.main cancel out of it and let's simply import the actual list ourselves so i'll just press option enter and right here let's import mail and gender just like that and finally let's go ahead and add a static import for those so i'm just pressing option and then enter add static import now let me go ahead and close this and let's actually use what we've learned in the previous section with streams so this is pretty much where everything starts to make sense so let's go ahead and use a couple of those functional interfaces that we've learned so if i collapse this or actually open this so consumer function predicate and suppliers so go ahead and simply say people dot and then stream right so stream pretty much takes us to an abstraction mode and if you want to learn about all of this i've got this course right here where i teach everything about the java streams api because once you've because once you learn this the way that you write your java code will change quite significantly so stuff that you use to take 20 lines of code you can simply collapse into perhaps five lines of code and to be honest knowing how to use the java streams api will make you a much better developer so i also have a free video on youtube where i teach about filter soar group by all match basically this is a an introduction of this awesome api but for now let's go ahead and learn some of these methods so go ahead and say people.stream and now go ahead and simply say dot so what i want you to do is to actually look carefully so right here so look at the methods that we have we have map collect filter find first for reach all match but what i want you to see is exactly look the map function takes a function right takes a function of some type that extends person and then you can see the other one so the other argument so question mark extends our mapper so this is exactly what we've learned right so a function takes an input and produces an output so the same with collect so collect is a supplier and you can see you buy consumer so this is awesome right this is everything that we've learned so the same with filter takes a predicate find first so this returns simply an optional for which takes a consumer right let's look another one so for example drop wow this takes a predicate find any flat map so this is a very useful function takes a function inside and right here flat map to wind map to double so this takes a two double function right and you can see right here non match a verify you of a very useful function as well reduce binary operator and then right here you have another reduce and then look at this sorted takes a comparator it's not relevant to us take wow you can see that this takes a predicate and to array into function basically this is pretty much everything that we have learned right so functions by function consumers predicates and the other good stuff so basically this is now where everything comes into action so let me go ahead and show you for example how to use this map function so go ahead and simply select the map function and the map and the map and and the map function simply does transformations so right here this takes a person right and from here what we want to return so i want to return person dot and then the actual gender now let's go ahead and simply say dot and then collect and then collect us to set right so and also um let me extract this to a variable genders and then south and then genders or actually not even south so let me let me simply remove that because i want you to see exactly what we're doing so right here so instead of collect let's go ahead and simply say dot and then look at this for each takes a consumer and we've learned about consumers right a consumer simply takes an argument and produces nothing so void right so right here we will take a gender and what we want to do with this gender so we want to simply do a system dot out dot print line and then gender and now we can use method reference with this like so and beautiful code now let me go ahead and run this method so you can see what we are doing tada there we go male and female right so you can see that we mapped everything so right here we stream the people list so oops so right here we stream the people list right contains a bunch of people right here so john maria aisha alex and alice so we map so we perform a transformation on that list so we convert every single one of them into a gender so now we simply have a list full of genders and then we collect to a set removing duplicates and then we simply print that's why you see that we have only male and female right here so if i was to have another gender right here cannot actually prefer not to say but basically this is not gender i'm just giving you an example so right here let's add another one another person right here there we go then prefer not to say this will be bob and you could tell that this is a gender but so if i run this you can see that now we have prefer not to say as well right here so if i was to now map this into the actual name right so let's say name and then run this we simply now get the actual names instead of genders so this is really really really awesome so let me actually let me also show you that we can simply get the length of each name so let's also perform another map operation right or in or in this scenario let's say map to int this takes the actual uh name so this time it's name and then simply say name dot and then length and right here we're not going to collect set so let me delete that and then we can even change this to method reference just like that if i run this you can see now the length of each name so this is the power of streams so you might be asking you know what is this right or what is this or what is this so let me just show you right now so what i'm going to do here is simply extract this to a variable and also this to a variable and also this to a variable and now check this out so this is what you've been learning in the past videos so look at this function that takes a person returns a string and then the same here two in function we haven't learned to int function but basically this is the same thing so this takes a string and returns an integer that's all it does and you can see right here in consumer so an end consumer simply takes an integer and it prints out the result so right here so let me actually replace this with a lambda so you can see exactly what is this you see that this is what we've been learning throughout this course but when you use it with streams you don't have to have all of this syntax basically you can ditch the left hand side and just keep these right so if i now inline everything so command shift n command shift and there command shift and there and look at this right and here even method reference and there we go so if you want to learn more about streams go ahead and check my course on java streams api where you learn everything about writing code in a declarative way this is all for now join me in the next one all right let me show you some other methods right here so still right here so let's go ahead and uh for now i'm gonna pretty much just comment everything right here so i'm gonna comment this and right here let's go ahead and simply say people dot and then stream and then right here let's go ahead and simply say all and then match basically we want to know that in our list we only have females so right here so this takes a predicate and remember a predicate looks like this so this will take a person and then in this list we want to make sure that we only have females so female dot and then equals person dot and then why should not people person dot and then gender there we go and now and i'll end this with semicolon and if i extract this to a variable you can see that this is a boolean now let me go ahead and simply say contains only females there we go and if i do a south on this south and then contains only females and let me actually go ahead and destructure all of this so i'm going to extract this to a variable and check this out so right here so we've learned about predicates right so this is what we've learned previously so now let me go ahead and run this again and you can see that it's false right because in our list so right here in our list we contain both male and females so if you want for example to say um or is say the opposite you could say for example i think match let's look at for let's look at match so any match right here right so any match so any match means any match taking our predicate so if we have at least one female then this will return to run this there we go true right so if i for example remove all the females here just like that run it again and it's false now right so let me undo all of that and finally we have uh i think it's nonmatch right so let's say that now we change this to prefer not say and let's remove bob from here so basically i want to make sure that in our list we do not have someone with prefer not say gender if i run this you can see it's true if i add bob back this will be false there we go so you can see the power of streams right so obviously we have other methods really really useful methods so if i do a person or actually people dot and then stream dot and look at those methods right so mean peak reduce sorted take wow um so right here drop while not much you've seen find first map and map to int so basically once you learn all of this the way you write java code will change and you will become a much better java developer so this is all for this video next let me also show you that you can use um you know all of the goodness of java functional interfaces with optionals because you know again optionals changes the way that you deal with null pointer exceptions in java join me in the next one see ya all right let me go ahead and show you how to use java optionals with functional interfaces so if you've never heard about java optionals or if you've never used java optionals go ahead and check my youtube channel where i've got this crash course on java optionals and i highly suggest you to learn how to use optionals because they will help you a lot in terms of dealing with null pointer exceptions so let me go back to intellij and let me create a new package so right here optionals and inside let's go ahead and create main class and right here public static void main and there we go so now let's go ahead and simply say optional dot and then off nullable so right here let's simply say no right and if i now press dot check this out you can see that right here you have a bunch of methods but if you look closely again so these methods they do take for example the first one or else to throw takes a supplier right so this supplies an exception you can see or else or so right here this takes a supplier map again function if present consumer filter flat map so right here if present or else right is present or else get so this is a supplier so let me actually use this one or else get and then remember suppliers so right here oops there we go so let me simply say default value just like that extract this to a variable and let me simply name this as value now if i go ahead and simply say south on value there we go if i run this you can see that we get default value but now check this out if i simply add a value here so hello run this again you can see that we get a low right so let's try something else so instead of or else get let's go ahead and simply say dot or so right here so or else throw so this again we have to supply an exception oops just like that new illegal set exception and you can have for example a message right there and exception for example right so you can see that if i extract this to a variable this is a supplier and we've learned about suppliers remember so right here so this is a supplier right it takes no arguments but it supplies a value so there we go now let me again show you something else so if i delete this so instead of saying or else throw let's go ahead and use for example so let's use something that has a consumer so if present there we go if present we receive the actual value here and then we do something with the value so right here let me simply remove that and let me move this above and then this there we go now because i only have one single value but basically you could do like some logic right here right if you had like you know something that you wanted to do like a business logic right so now because i only have one value i can delete all of this i can delete that and i can even go one step further use lambda method reference just like that and look at this looks beautiful so now let me go ahead and simply say john gmail.com in fact let's go ahead and pretty much um have a custom message so right here so email and what we're gonna do is simply say south and then sending email to and then email there we go now if i run this you can see that right here we do get sending email to john but now as soon as i pass a null here right if i run this we get nothing but now i can go ahead and pretty much change this with so there is another method right here so if present or else takes the consumer and then the other empty action is a runnable so that is our consumer so let me actually grab this so you can see what am i doing so this is the first one so this email and then right here we have to pass comma right comma and then a runnable so a runnable goes like that and there we go so let me pretty much just put this on a new line and this on a new line just like that and then if i close that indent things there we go and then here what i'm going to do is simply say south cannot send email there we go now if i run this you see that we have cannot send email as a default value so again i can remove that and have method reference and look at how this now starts to flow guys so this is the power of functional programming streams optionals and you know once you start writing code like this you can achieve a lot more instead of using imperative approach so as i said go ahead and roll to this course right here where i teach everything you need to know about java streams api also if you want to learn about optionals go ahead and check this video where i show you how to use optionals and how to be safe with no values this is all for this section if you have any questions go ahead and drop me a message otherwise let's move on let's go ahead and learn about this awesome design pattern called combinator so let me go ahead and first create a new package and right here i'm going to simply name this as combinator and then pattern so right here what i want to do is to create a class so i want to create class and let's say that we will start with the user so the user actually a customer so we have a customer and this customer has few properties so let me collapse this so private final string name let's also give it an email phone number and let's also give it a local date for date of birth now let me go ahead and pretty much just add those to a constructor and let me generate some getters right here so get it just like that so now let's say that you have a system right where customers do register to your system and you and you need to perform some kind of validation right so what you would do for example would be something like this so inside of your package you would create a class and then customer validator and then service right and in this class right here you would have few methods to validate few properties of a customer right so you could have a method so right here you could say public and then boolean is email valid right and this takes a customer or better takes a string email right and right here you'd simply say return and then email dot contains you know this is a rubbish validation but this is just for illustration purposes right so contains that or actually contains the add symbol for now let's keep it simple then you might want to have order validation for the actual um phone number so right here so is and then phone number valid so this will be phone number and then right here phone number right here contains so instead of contains let's go ahead and simply have a simple validation so it starts with and then plus and then zero right and then what did we have so if i go back so we have uh date of birth so let's go ahead and simply say that the date of birth so right here is adult so is adult so right here we take a local date and then dob and then what we're going to do here is simply say period dot and then between so we're going to calculate the number of years between two dates so the start date will be uh inclusive so this will be the dob so customers and date of birth and then local date dot and then now and then right here dot and then get years and let's say that for someone to be an adult they have to be over 16 just like that right so if i put this whole screen so you can see so this is then your customer validator service right so now the way that you would use it is let's go ahead and create a new class so main and then public static void main like that customer and then customer equals to new and then customer and then right here let's go ahead and simply say that this is alice and then she has an email of alice at gmail.com and then the actual phone number is plus and then zero so oops plus and then zero and then any random number and finally let's go ahead and simply say that she was born so local date of and then 2 000 just like that and then one and then one and there we go so if i collapse this and you can see that now we have a customer that we can perform some validation now obviously um you know this um validator service right so this could even be private so private and then private and then right here so let's go ahead and combine the both let's go ahead and combine everything so is oh actually let's go ahead and simply say public so this is the actual uh interface that we provide to clients so public and then boolean and then is valid just like that and this now will take a customer and now what we're going to do is simply say return and then is email valid customer dot get email and then and and then is phone number valid customer dot get phone number and finally and is in then adult customer dot and then get and then dob just like that so this is actually you know normal code uh but so what i want to teach you really is how are you going to be able to use a functions to change this in a much better way and a neater way right so here if you have extra validation you have to have another method like that and then simply append here and then basically right here you don't have visibility whether um you know whether the phone number was invalid or it wasn't an adult or or anything right because this simply returns a boolean right is valid so if i go ahead and show you what i mean so right here let's go ahead and simply say customer validator service service equals to actually let me rename this to uh validation validate the service new and then customer validated service now let's go ahead and say validator service dot is valid and then pass customer there we go so what i'm going to do actually is in line this oops not that so basically i want to inline um this guy right here so like that and then i'm gonna do a south just like that and then end that like that so now if i go ahead and run this there we go so you can see that this customer is valid and from now on let's say that we can store customer store customer in and then db right so now um actually let me say if and then valid right so now if i go ahead and pretty much just for example remove the add sign run this you can see that now it's false so it's not valid and also let me go ahead and remove the plus sign right here there we go still not valid but now you don't know exactly you know what is wrong with our validation so the combinator pattern it's an awesome design pattern that allows you to chain functions together so basically a combinator is a function that might take other function as arguments and returns new functions so this is an awesome pattern that i'm pretty sure that you will love and that's what i'm going to teach you next all right let's go ahead and use the combinator pattern to improve this validation service right here that we have so validated service actually so this validation sub so so this class right here is okay but we can do way better than this right because right here for example if you want to have um you know a different method that validates for example just email and their phone number then you would duplicate this so right here and then you would say is valid phone number and email and basically just remove for example is adult from here and we don't want to do this right so we want to have a very beautiful interface that we can simply chain all of these validations together so let's go ahead first and expand the project tab and right here let's go ahead and simply create a class and this will be called customer and then let's actually name this as registration validator there we go and instead of a class let's change it to an interface now what i'm going to do here is the following so right here i'm going to say that this will extend a function so remember we've used functions right here and the first argument that we want for this interface is a customer so the type of is a customer and then right here let's go ahead and simply say validation and then result so let me end that just like that and let me put this on a new line so you can see exactly what we're doing now this validation result this will be an enum so enum and then validation or let me actually just copy and paste this so validation result just like that and now i can import this oops actually i did the right thing and let me actually do a static import right here there we go now here what i'm going to do is have a you know few results that i want my validated service or actually my my customer registration validator to have so one i want this to be success right so this is where all the validation is successful then we have few errors so right here we have phone number not and then valid we also have email not and then valid and we also have is not an adult just like that so the way that we're going to use this with this interface is as follows so this is where combinator pattern uh kicks off so right here we're simply going to have the validations that we want right so here you can have as many validations as you want and then you chain them together at the end so right here let's go ahead and simply say static and then right here what we're going to return is this guy right here so the same uh interface so right here we will return this function right here right that takes a customer and returns a validation result so right here i'm gonna say is and then email valid and then i'm not taking anything there but right here what i want to say is return and then customer and right here i'm going to say customer so basically the exact same validation that we had before so customer dot and then contains and then at so if this is the case what i'm going to do is simply return you guessed it success otherwise phone number oh actually no phone number uh email is not valid and let me have a static import for this and the same for success there we go now let's go ahead and do the same for phone number right here let me actually steal some code so from here what did we have we had this so i'm gonna copy that go back and then is phone number valid and then i'm going to change that with this and then customer dot get phone number starts with that so if that is the case then it's valid otherwise so right here phone number is not valid let's go ahead and do the same for is adult so right here static and then customer registration validator is an adult there we go let me steal some code from here so this is what i want just like that go back and then customer will actually return customer and then i'm going to paste that and then right here customer dot and then get dob so if this is the case right so if the customer age is bigger than 16 what i'm gonna do so let me put this on a new line so if it's bigger than 16 what i'm gonna do is simply return success otherwise is not an adult there we go indent this properly and there we go so one final thing that now we have to do is right here we have all of these functions of these three functions and the combinator pattern allows us to chain all of these functions together so the same way that you saw with a function where we can use and then and the same with predicates by using i think it was and right or or we can have the same logic with the combinator pattern so right here what i'm going to do here is the following so i'm going to have a default method and right here i'm going to return a customer valid data so the same thing that we did here and then i'm going to say and right so right here we're going to take a customer data and then i'm going to call other so basically this is where the magic happens right so i'm going to say other and inside i'm going to return and then customer and then inside what i'm going to do is simply say this dot and then apply so we are going to apply this customer and i'm going to shrink this to a variable so i'm going to say result and now check this out i'm going to say return and then result dot equals and then success so if it is equal to success i'm going to apply the other validator dot and then apply and then customer otherwise i'm going to simply pass the actual result not super result there we go so if we get to this point we know that we have an error so now this is complaining because i need to pass semicolon right here so let's go ahead now and use this awesome interface so let's go back to the main method right here and now let me simply comment this out and let me simply add an add sign right here or actually let me simply leave it as it is and then i'm going to show you exactly all the errors so now let's go ahead and simply say customer or actually not here um so using combinator pattern so right here let's go ahead and use a customer registration validator and then dot and check this out so we have all of these methods right is an adult is email valid and is phone number valid so let me go ahead and simply start with is a email valid right but now what i want to do is the following so right here i'm going to say dot and then check this out we have this method so and right here so this is the one that we defined so i'm going to say and and then let's use the rest so if i do if i press ctrl shift you can see that we have the other methods so is phone number valid dot and then and and then is an adult there we go so if i now add a static import you can see that now this becomes much much cleaner so now we have these three methods that we have chained together the way that we use it is simply by saying dot and then apply and then pass customer there we go now if i extract this to a variable so result and let's go ahead and simply say south and then result so now what i'm going to do here is say if and then result not equals to success so success we're going to throw so let's throw so throw new illegal state exception you could have your own exception but for now let's go ahead and throw an illegal state exception and then the actual result dot and then name there we go and basically this will actually print out the same thing right here but i want you to see the actual result so let's go ahead and scroll up and let's start with a valid customer so at gmail and then the phone number has to start with plus and then zero so if i go ahead and run this there we go we have success right here and if i scroll up let's now check all the validation that we have so let me remove the add sign and then run there we go you see that email is now valid and we've thrown an exception right so email or valid so if i add that back and if i remove it plus here run this there we go phone number not valid and if i had a plus there and let's make sure that this guy was born uh you know 2015 or this guy alice was born 2015 so which means that you know she's not an adult so if i run this you can see that is not an adult right and you can even customize your exception that we throw by including the name or you know an id or anything like that but basically now you can see the power of the combinator pattern so if you have more stuff that you need to change to this validation so let's say that the requirements change you can simply duplicate this and then have your custom implementation inside of the um interface that we've defined defined so this one right here so customer registration validator and then just chain all the validation logic and scenarios that you have and this is the power of the combinator pattern so one last thing that i want to show you is that so if i uh command z a couple of times there so basically so right here you see that we call dot apply so if i comment this and then right here let me simply remove the apply there so the cool thing about um you know these functions so let me change the variable right here to a validator so the cool thing about this right is that this is lazy right none of this stuff is run until we invoke the dot apply so if i say result right here you can see that we have all of these methods right we can compose applies on and so forth but if i run this you can see that nothing gets printed out and even if i for example right here so where we um return here so the email value so right here so is email valid so let me grab that and then let me simply south and then running email validation and then right here simply return that and end up with semicolon there so even if i run this you can see that we still get nothing but as soon as i uh revert all of this just like that and then call apply now check this out if i run you can see that we have the running email validation and i think i need to undo all of this and then run it again and there we go so running email validation right and then we have is not an adult and the actual exception so i hope that you see the power of the combinator pattern i use it whenever i can to perform validation like this and you should also do it if you have any questions go ahead and drop me a message otherwise let's move on all right so in this final section let me go ahead and explain you few things that will help you to fully understand the functional interfaces and functional programming with java so so go ahead and create a new package and in this package we're going to call it as final and then section right here so inside create a main method and then so let me put this full screen like this and then ps and then vm for public study void main and right here what i'm going to do is i'm going to write some javascript and there we go so what i want to touch on this video is call backs so maybe you've done some javascript and javascript they have this notion of callbacks so a function in javascript looks like this so this won't work in java but it looks like this so you have a function and then you give it a name so hello and then right here you might have for example a variable so let's say and then first name last name and then call back something like that right so right here what we're going to do is let's say for example the last name is not provided then we simply have like console.log so let's simply say console.log and then right here first and then name and then i can say if if we have last name then we're going to console.log and then last name otherwise we will have this callback so we're going to invoke the callback right so you might have seen code like this in javascript basically this is an extra function so if i take this command c and then go to chrome and then inspect and then right here go to console paste my function there and then enter you can see that we have undefined now if i say hello and then say first name john and then pass now there and then right here i can pass a function so this is a callback right so console dot and then log and then no last name provided and then end this with a parenthesis here if i now run this oops we have a error there and they should shouldn't have the column there so enter and you can see that now we have john and then no last name provided so basically you can see that this callback right here is a function and you can have like you know a lot of logic in it right but you know this is very simple so we're just logging but if you want to have for example an extra logic that goes to the database and there's you know some other stuff you could definitely do it i'm just showing you the callbacks in javascript so right here if i now pause so right here if i now say alex and then montana and then run this you can see that now we're not printing the actual callback right so now we have john and then montana the last name so we can achieve the same in java using functional programming and the functional interfaces so the way we're going to do it is as follow so let me simply comment this right here so you have it for reference so now what i'm going to do is actually have a static and then void and right here what i'm going to do is actually combine both worlds so we can have a regular method so normal java method and also inside as a parameter we can have a function right so this is you know programming because now we are free to do whatever we want so right here you see static void and then let's go ahead and simply say hello and then right here string and then first and then name string last and then name and then right here what do you think we need right so remember we've learned about functions by function consumers suppliers predicates so we kind of just want to have a function that might take for example last name if it's there print it otherwise have for example a default message so right here what we're going to do is simply say consumer and then of type and then string and then let's simply name this as call pack just like that there we go and then right here let me simply say south and then first name and then i'm going to say if and then um last name equals to no right we could even say is blank right but equals to null so if it's equal to null or actually let's revert this so it's the same as the function that we have right here as javascript so if it's not equal to no let's go ahead and say south and then a last name otherwise else we're going to say call back dot and then accept and then the string that we want is first name for example right so let's take this first name right here and then do something with it so now the way we use it is as follow so let's go ahead and say hello and then john right here and then montana and right here let's have our callback so let's go ahead and simply pass now for now right so if i run this there we go you see that we have john montana but now let's go ahead and define this callback so right here we'll have um a callback that takes a value and the value will be the actual first name it doesn't matter and then we will do something with it so right here south and then what did we have so right here we said last name not provided so let's do the same here and then four and then plus and then john and then value right so you could even you could even change this to first name if you want but i'm just going to leave it as value now if i run this you see that we have john montana but now watch this if i pass no right here and then run there we go no last name provided for john so basically i just want to show you that you can combine you know a normal function with these functional interfaces and do stuff like this and achieve a similar concept as javascript that they call callbacks so there are other languages that have the similar concept but javascript you see a lot of these callbacks been thrown and you can pretty much do the same with functions another way that you might see callback is so right here so because right here you might not want to pass a default value right so you might have something like this so right here let me just duplicate this and then call it two and then right here so i'm gonna simply remove this and then runnable and this will be the callback and then right here call back dot and then run right so this is a bit different now so right here the way we use it is simply say hello like here and then two and then right here you simply pass this runnable right here and you have no value there basically this now is the exact same thing as this concept right here right because we're not taking any value and because um i only have one line there i can simply do this and then check this out just like that and beautiful code so now if i run this you see that it's the exact same thing but right here we're not taking any arguments so there we go so this is how you combine both worlds where you can mix and match these functional interfaces with normal functions and have callbacks if you have any questions go ahead and drop me a message otherwise let's move on let me go ahead and teach you about lambdas so we've been using lambdas throughout this course with you know all these functions but basically let me show you exactly how they're used and for example if you only have one return statement if you have two arguments what you should do uh when using lambdas so let's go ahead and expand this so commander n1 and right here for this main method let me go ahead and simply name this as callbacks just like that now let's go ahead and create a new class and then simply call it as lambdas there we go oops not lambers but lambda and then this just like that now let me collapse that and then public static void main now inside let's go ahead and have a function there we go that takes a string and returns a string there we go so let's simply say uh print and then name equals two so this guy will take name and then right here so this part right here it's a lambda right so this is a lambda where this is the actual argument right so this name right here is what comes from this data type so right here then you have to pretty much just uh do the following so if you have only one line so if you simply return immediately you can simply do this so south and then actually not even south my bad so you can simply um and this is not a good example so not print name but let's simply say upper and then case name for example something like this right so now right here if you simply return immediately you can simply do this so name and then dot and then uppercase right so you can immediately do this so this is only when you have one return statement right after this um error right here so because you only have one return statement and you can even see that intellij is telling you that you can use a method reference so this is because right here this is the same as doing this right it's the exact same thing so this is more understandable but you know once you get too comfortable with this you'll start to use code like this now another thing is right here so if you have to do some extra logic and not return immediately you need to have these curly braces right here so now you can have a logic right so you can for example say if and then name dot um or actually is blank right here so if it's blank then you can throw new illegal and an argument exception something like this right and then right here otherwise now because i need to return i need to say return and then name to uppercase but also i need to add semicolon right here right so you can see that now this is the actual method body for this lambda right so this lambda so this is the entire thing right here so another thing that you could do with lambdas is you see right here where you have name so if this is a by function so by function uh just like that and then right here let's simply have um let's have an integer right here integer and this will be h right so now you see that i need to put age right here because this data type is for this one and this data type is for the second one right and string is what this by function returns now because i have two arguments i need to do this i need to enclose them within these parentheses so let me actually go back for a second so right here so where we have a function so you see this is a function i can even you know enclose them with parentheses but because i only have one argument right into this function right here i can simply ditch this right but if you have a by function and right here let's simply say integer again and then age now you need to enclose like that right and you could you know do something like another logic right here so south for example and then h something like that right and you know the way you'd use it is as follows so uppercase name dot apply and then alex let's have alex here and alex is 20 right there we go and this returns a string right here upper cased name and then south and then uppercase name i can even in line this like so if i run this there we go so 20 and then alex so basically this is uh this logic doesn't really make sense but i just want to show you exactly different ways that you can use these lambdas right here so if you have any questions on lambdas go ahead and drop me a message otherwise let's move on all right so just to let you know that i think i didn't mention this at the beginning of this course but when you use these functional interfaces you see right here where you define the actual inputs and outputs of functions right so string and an integer and then string so these right here they have to be the object type and not the primitive so for example integer right so you could have an integer like this so integer and then number equals to no right and then you can also have integer and then let's say counter and right here i can't say this so this is invalid right because this is the primitive um version of this object type right here right so right here you either have to say a number so it could be negative number or positive number so if i do a zero right here you could see that this goes away so for that reason you are not allowed to have primitives in here right because if you have to pass nose then then you can so with primitives you cannot so right here you see that we have this integer right here so i can go ahead and simply say no right here and you see that works but if i was to have this integer so the primitive type that does not work and also one thing that i've been doing a lot throughout this course is having static right here so static so the reason why i've been doing static is because i'm outside so right here i'm outside of the main function and the main function is static right and you can only use static methods inside of this main function so right here you can see that this still works but if i remove the static keyword you can see that it does not work right so this is something that to bear in mind uh your functions and buy functions they don't have to be static right in fact having static throughout your code base is not practical so ideally what you would do is simply have for example so let's say that you have a class let me actually um put this inside so just like that so let's say that you have a class and then call this a service for example right what you should really be doing is like having you know publix and then your function for example or predicate or consumers right so consumer of string and then blur equals two and an s right just like that and then basically this is your public interface you can also change this to private or no access modifier at all so this is package protected right so just to bear in mind that you know they don't have to be static and you should avoid static but the reason why i've been using static is because i've been doing everything inside of this public static void main method so there we go if you have any questions on primitives and the use of solid keywords go ahead and drop me a message otherwise catch me on the next one all right let me go ahead and quickly show you the rules that come with functional programming and everything that we've learned throughout this course so the first thing i should know is that um there should be no state around your functions right so the functions they have to be pure functions so they shouldn't depend on any other state so for example if you have a global state like or a global variable your function should not depend on that global state right so that's the difference between pure and in pure functions so pure functions don't depend on global state impure functions do depend on global state and that comes with the side effects right so your functions should have no side effects other than everything inside of the body of your function right it shouldn't have a side effect outside of the function and also higher order functions so a function is considered to be higher order function if one of these two conditions are met the function takes one or more functions as parameters so we saw how to so we saw how to pass functions inside a normal functions right or if the function returns another function as result so with the combinator pattern that's exactly what we've done so let me actually show you so right here so with callbacks so right here so right here so you can see that right here we are passing a function right here so this is a function right and also within our a combinator pattern so remember so customer and then registration validator check this out so right here we are returning a function so this interface extends customer or actually extends function that takes a customer and sends a validation result but if you check the return type of all of these methods right here so if i do a command shift and then minus you can see that they all return the function right here so this means that we are satisfying with this property higher order functions so make sure that for example let me actually show you uh you know the no state and pure functions inside effect so if i go back to let's say lambdas right here so you see this function right here so ins by function right here so i should never depend on for example counter right so let's say that i do for example south and then counter or if i change the state of counter right i should never do this because it will break all of this right so you see that there might be some side effects on the outside of this function right here right so outside of this function there might be there's some side effects also you see that you are now mutating state and it's no longer a pure function it's an impure function because it depends on um global state so you never want to do this or for example increment the number so number and then you know increment um you know plus plus something like that you should never do it right so your functions right here they should be selfcontained right so they should only depend on the state that you define inside so right here i could say in inc and then counter equals to zero so this is absolutely fine right because this counter so this counter right here it's only visible inside of this function and not the outside world so if you have any questions on these properties go ahead and drop me a message and i can give you more examples but this is pretty much everything you need to know about functional interfaces and functional programming with java if you have any questions go ahead and drop me a message next let's go ahead and wrap up this course okey dokey amigo i want to congratulate you for completing this course and practicing throughout so as you saw for you to write functional programming you just have to shift the way that you think you no longer think about regular java functions but you start to use functions by functions predicates consumers suppliers so on and so forth now the next step for you is to enroll to my course on java streams api because once you combine everything that you've learned in this course with java streams you will start to write code that really really shines instead of you writing code that takes for example 20 lines of code you simply take five lines of code with streams and functional interfaces so this is all for now go ahead and subscribe to my channel to get more videos like this and it really means a lot to me to see a lot of you you know sending me messages suggesting for new courses and i'm trying my best to give you awesome content that will allow you to become a software engineer also if you haven't joined the private facebook group go ahead and join because that way you can see what's up you can connect with all the students and if you have any questions just drop them and i'm pretty sure one of us will be able to help you this is all for now and i'll catch you on the next one see ya
