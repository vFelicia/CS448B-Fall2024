With timestamps:

00:00 - Welcome to Introduction to programming. My name 
is Steven in my name is Shawn. Over the next 90  
00:06 - minutes, we'll be taking you through this series 
consisting of 21 different segments that hope to  
00:10 - cover the basics of computer programming, which 
can apply to any and all programming languages you  
00:15 - might want to learn. We'll be starting with the 
simplest question of what is programming. And from  
00:19 - there, we will be working our way up as we talk 
about common features of computer science such  
00:23 - as loops and arrays, we'll discuss how to read 
and write code, debug code that you've written  
00:28 - some strategies to help you plan out your code 
and much, much more. The complete list of topics  
00:34 - that are going to be covered in this lecture style 
video are shown on the screen. Now, additionally,  
00:38 - there will be timestamps in the description, 
so feel free to skip around. If you're already  
00:42 - proficient in some areas of computer science, or 
just want to know about a specific topic we will  
00:46 - be covering. Hopefully, by the end of the series, 
you'll have a basic understanding of what computer  
00:51 - science is, along with an armory of useful skills 
that will help you unravel whichever programming  
00:56 - language you decide to learn. First, we'll only 
be covering the major key points that apply to  
01:00 - all programming languages. So we'll be shying 
away from topics such as object oriented coding,  
01:05 - and command line navigation, as those are things 
which are language specific. Additionally, there  
01:10 - will be no software required for you to download 
in order to follow along with this tutorial,  
01:14 - as we won't be writing any code in an ID to 
keep things simple and concentrated. This video  
01:20 - is meant for those who are interested in computer 
science and programming but have no idea where to  
01:24 - start and have little to no background information 
on coding. And so if that sounds like you,  
01:27 - then strap in, as Shawn and I work our way 
through the wacky world of computer science,  
01:32 - starting with the biggest question probably on 
your mind, which is what even is programming?  
01:36 - Well, the dictionary defines it as the process of 
preparing an instructional program for a device.  
01:43 - But that's a really confusing definition. So 
in layman's terms, what exactly does that mean?  
01:50 - Essentially, it is attempting to get a computer to 
complete a specific task without making mistakes.  
01:57 - Imagine this for example, you want your less 
than intelligent friend to build a Lego set,  
02:04 - except he has lost the instructions and can only 
build based on your commands. Remember, though,  
02:10 - your friend is far from competent. And so if they 
are not given very specific instructions on how to  
02:16 - build the set, there are many mistakes that they 
could make. If he thinks like a computer, then if  
02:22 - there's even one piece that you have not told him 
specifically where to place and how to place it,  
02:26 - the entire Lego set will be ruined, and you will 
be left to suffer a complete mental breakdown,  
02:30 - causing the whole goal of the project to be 
corrupted. giving instructions to your friend  
02:36 - is very similar to how programmers code. Instead 
of a less than intelligent friend, you have a  
02:42 - less than intelligent computer. And instead 
of instructions on how to build a Lego set,  
02:46 - we are feeding information on how to complete a 
program like a game or a web application. And an  
02:51 - important thing to note is that computers are 
actually very dumb. We built them up to be this  
02:57 - super sophisticated piece of technology, when in 
actuality, a computer's main functionality comes  
03:03 - from how we manipulate it to serve our needs. 
Now, programming isn't as simple as giving your  
03:08 - friend instructions. Since in a programmers case, 
the computer doesn't speak the same language as  
03:12 - you. The computer only understands machine 
code, which is a numerical language known as  
03:17 - binary that is designed so that the computer can 
quickly read it and carry out instructions. Every  
03:23 - instruction fed to the computer is converted into 
a string of ones and zeros and then interpreted by  
03:28 - the computer to carry out a task. Going back to 
the Lego example, this process wouldn't be like  
03:34 - if he was not only less than intelligent. But 
to make matters worse, he could not understand  
03:40 - English and only speaks in Mandarin Chinese. 
In order to speak with him, you have to convert  
03:45 - the instructions that you understand in English 
into the language that your friend understand.  
03:50 - This process is essentially what you must do for 
your computer in order to make it understand the  
03:56 - instructions that you give. The big difference 
between the two examples, however, is that it is  
04:01 - very difficult for people to understand machine 
code in binary. Directly translating what you  
04:06 - want the computer to do into machine code is 
extremely difficult, in fact, almost impossible,  
04:11 - and will take a very long time to do it if you 
could. Each program is composed of millions upon  
04:17 - millions of those ones and zeros. So how exactly 
are we supposed to translate our instructions  
04:22 - into machine code. This is where programming 
languages come into play. programming languages  
04:29 - are fundamentally a middleman for translating a 
program into machine code. These languages are  
04:34 - much easier for humans to learn than machine code, 
and thus are very useful for programmers. Going  
04:39 - back to our Lego example, a programming language 
would sort of be like an interpreter that's able  
04:45 - to take the instructions you give them in English 
and translate them into instructions your non  
04:49 - English speaking friend can understand. This makes 
programming languages extremely useful and the  
04:54 - backbone of any good program. Think of programming 
languages as not English and not machine code, but  
05:00 - somewhere in the middle. There are many different 
programming languages out there that each have  
05:06 - their own unique uses. languages such as Python 
and Java, are just general purpose languages that  
05:11 - can perform a variety of computational tasks, or 
robots C or HTML or CSS, or languages designed for  
05:18 - more specific purposes, such as moving a robot 
or constructing a website. languages can also  
05:24 - vary and how powerful they are. For instance, 
JavaScript is a scripting language that is  
05:29 - designed for smaller tasks, or Java or Python 
can carry out much more computationally taxing  
05:34 - processes. We can measure a programming languages 
power, or level by how similar it is to machine  
05:41 - code, the series of zeros and ones we talked 
about earlier. low level programming languages,  
05:46 - such as assembly, or C, are closer to binary than 
a high level programming language, such as Java or  
05:52 - Python. The basic idea is that the lower the level 
of your programming language, the more your code  
05:58 - will resemble what the machine can interpret as 
instructions. Aside from the different purposes  
06:03 - that each language fulfills, choosing a language 
typically comes down to a matter of preference,  
06:08 - as are usually many languages that can accomplish 
similar tasks. Try different languages,  
06:13 - and decide which ones rules interface and 
level of simplification you like best?  
06:22 - So now that we know what programming is, how do we 
actually write code? It sounds like we can simply  
06:27 - type words into a text document and automatically 
assume that the computer can translate it into  
06:31 - machine code, read it and carry out a task 
like opening up a browser. And additionally,  
06:36 - we can't just write down rubbish in certain 
programming languages mentioned in the previous  
06:39 - segment, and expect the computer to understand. 
So how are we supposed to write code then? Well,  
06:45 - the answer is with an ID. And ID, which stands 
for integrated development environment allows the  
06:49 - facilitation of code by a computer. It is provide 
a graphic interface on your computer in which the  
06:55 - programmer can easily write, run and debug code 
without having to worry about problems with  
06:59 - complication or interpretation of the program. 
Think of an ID is any other program on your  
07:04 - computer, such as a game browser, or even the file 
explorer, except we'll be using it to write code,  
07:09 - IDs are able to turn your code into machine 
code and run it through the computer to produce  
07:13 - results. In addition to providing a place for 
programmers to develop their code IDs provide  
07:19 - some extremely useful tools for programmers 
to ease the job of writing code, such as built  
07:23 - in error checking, because as we'll talk about 
later, code doesn't always run correctly. Auto  
07:27 - filling for frequently used words or phrases, and 
a project hierarchy, which will help you organize  
07:32 - and manipulate the files within your project. 
Back in the olden days before IDs code used to  
07:37 - be written on punch cards and then fed into 
computers, which would take hours and cause  
07:41 - a lot of pain. IDs nowadays act as sort of a fast 
track to writing code and make things a whole lot  
07:47 - easier for programmers. An example of a specific 
ID can be seen on your screen now. In the center,  
07:53 - you can see the program that is currently being 
written. And right below it is the console,  
07:56 - which can print out useful information for the 
programmer. This specific ID is used to write  
08:01 - Java code. IDs are extremely powerful and will be 
used in almost 100% of your programming projects.  
08:08 - So through these IDs, we are finally able to write 
and compile code smoothly without worrying about  
08:13 - the computer not being able to understand it. 
The next problem we run into then becomes how  
08:17 - do we write this code in the ID. Because it's not 
like we can just type random words from a certain  
08:22 - programming language and expect the computer to 
understand this is where a programming languages  
08:27 - syntax comes into play. Now, just as if you were 
learning a real language, learning a computer  
08:33 - language can be very similar. Some have different 
styles that may seem odd. Some may make you use  
08:38 - weird or abstract concepts which may be confusing. 
And like all languages, programming languages have  
08:43 - a set of rules that you must follow when writing 
code in that language. And at the forefront of  
08:48 - those rules is grammar. Programming grammar is 
referred to as syntax and is very similar to  
08:54 - real world grammar. Each programming language has 
its own syntax or rules that you have to follow to  
08:59 - a tee if you want your program to run correctly, 
just as if you were speaking in real life. These  
09:04 - can be things such as how you type out certain 
functions, what you put at the end of the line of  
09:08 - code, and how you set up certain functions. Each 
language is unique in its syntax, and while some  
09:14 - may share similar rules, all will have some quirk 
which makes it stand out from the rest. syntax is  
09:20 - something that catches a lot of people off guard 
since many expect every programming language to  
09:24 - follow the same set of rules. But as we spoke 
about in the last segment, because each language  
09:28 - is specialized for a specific task, each needs 
its own set of rules to function. Breaking or  
09:34 - disregarding these rules will result in an error. 
Just how breaking or disregarding rules in real  
09:39 - life will result in an unintended message. As an 
example, if you wanted to do something simple,  
09:45 - such as initialize a variable, which is something 
that we haven't covered yet, but the example is  
09:49 - still relevant. In Java, you'll notice how we have 
to specify what type of variable we're defining,  
09:54 - in this case an integer and also add a 
semi colon after the statement. In Python,  
09:59 - we don't even need to define that we are trying 
to create a variable and just have to type what  
10:03 - we want to create. And in JavaScript, we 
just specify that we are making a variable,  
10:08 - but we don't include what type of variable we want 
to make like in Java. Even in this simple example,  
10:13 - you can see how much a syntax matters when 
learning a new language. Since while the  
10:17 - goal of our program remained the same, which 
was to define an integer with the value three,  
10:22 - all the programming languages shown took different 
approaches. All these languages require that you  
10:27 - follow this syntax because remember, computers 
are extremely dumb. If you forget one semi colon  
10:33 - or misplace a character, the entire program 
will not run and send you back a syntax error,  
10:37 - which is something we'll talk about later. Think 
of this as if you forget a comma in a sentence and  
10:42 - the entire context of what you're trying to say 
gets misinterpreted. For example, in the sentence,  
10:47 - let's eat grandma. If you were to forget that 
comma. While it may seem like a small mistake,  
10:52 - it changes the entire context of the sentence, 
making it sound like you're going to eat your  
10:56 - grandma. The same rules follow for programming. 
If you forget a semi colon, the entire context of  
11:02 - your program can be corrupted and misinterpreted 
by the ID. Now another thing which makes it so  
11:08 - useful is that they will let you know if and 
when there are syntax errors in your code. syntax  
11:13 - errors, of course, being parts of your code, which 
do not follow the same rules where we talked about  
11:17 - previously, the ID will tell you where in your 
code the errors, and also won't let you run your  
11:22 - program until the error has been fixed. Because 
of how important syntax is to writing code and  
11:27 - learning a new language. It's recommended that 
you learn the rules and syntax of a language  
11:31 - before beginning to write complex programs in 
that language. Most of the rules are tedious  
11:36 - to learn but easy to master. And as soon as you 
can do that, you'll be able to easily identify  
11:40 - syntax errors and take care of them easily and 
be writing code in no time. That covers the basic  
11:46 - gist of syntax and programming rules. So now that 
we know how to write code and where to write code,  
11:50 - we next need to cover what happens after we 
have typed out our program and run our code.  
11:54 - Because writing a piece of code for a game or for 
a database is cool and all. But after the computer  
11:58 - interprets the program, how will we know what's 
happening and whether or not is working? Well,  
12:03 - programmers do this by looking at the console. The 
console is a text interface within your computer  
12:07 - that us programmers can use for a variety 
of different purposes. If you remember,  
12:12 - a short while ago, we heard a picture of a basic 
ID. And one of the main parts of the picture was  
12:17 - the console. The main use of the console is to 
output text from the program. This is usually done  
12:23 - by using a print statement. A print statement is a 
command that does exactly what it sounds like. It  
12:27 - prints text to the console. The print statement 
is the first piece of actual code we've talked  
12:31 - about in this series. And it's about as simple 
as the print statement. Despite its simplicity  
12:36 - is one of the most important functions in 
programming and exists in some form in just  
12:40 - about every programming language. The most basic 
thing you can ask the print statement to do is  
12:45 - to just simply make it Say something. This 
is done by instructing the console to print,  
12:49 - and then include wherever you want to be printed 
inside the parentheses. For example, in Python,  
12:54 - the segment of code print hello world will cause 
a message reading HelloWorld to appear onto the  
12:59 - console. Pretty neat. The print statement is also 
vital for viewing interpreting the computer's  
13:04 - output from program. For instance, if you could 
tell a computer to run a simple calculation. For  
13:10 - example, to determine what four plus three is, 
they will run the program internally and compute  
13:15 - an answer. However, what is the purpose of having 
the computer run this program if you will not be  
13:19 - able to tell what the result is, instead of simply 
telling the computer to perform this calculation,  
13:22 - instruct the computer to print the 
output of the program to the console,  
13:26 - and upon the program's completion, seven 
will appear on the console. As you can see,  
13:30 - the console allows us to easily print information 
out to the developer for a variety of uses. It is  
13:35 - important to note that the print statement varies 
depending on the programming language being used.  
13:38 - For example, in Java, there are multiple versions 
of the print statement depending upon whether you  
13:42 - would like a line break after the printed text 
or not, as well as specialized print statements  
13:46 - which make your code run more efficiently. Also, 
the general syntax of using a print statement and  
13:51 - certain nuances of its function contains between 
languages. However, you can generally rely on it  
13:56 - to carry out the same overall function as it 
is a foundational statement for programming in  
14:00 - general. All of its functionality makes a print 
statement along with the console and very useful  
14:05 - developer tool. However, it is important to 
remember that that is all it is the developer  
14:10 - tool. The console is not really meant to be viewed 
by the end user of your program. It tends to be  
14:15 - hidden away behind the scenes and other methods of 
displaying information, such as displaying text,  
14:19 - graphics, or images are used to convey information 
to the user instead, think of it like this. When  
14:24 - you're using your phone, you see the console 
and none of the programs you use. So while you  
14:28 - can use the console to give yourself information 
about how your program is performing, don't try  
14:32 - to implement it in the final product because it 
fundamentally just isn't meant for that. Overall,  
14:37 - remember to use the console to its fullest extent 
when writing and fixing problems in your programs,  
14:41 - as it is a great tool to use to tell how 
your program is performing behind the scenes.  
14:47 - So now that we know a bunch of information about 
programming languages, and how and where to write  
14:52 - them, along with the print statement under our 
belts, let's go over some intuitive things that  
14:56 - the computer can do all by itself without you 
having to tell it how To. More specifically,  
15:01 - we'll be covering some basic number mathematics 
as well as string math. Starting off with basic  
15:06 - mathematics, the computer already knows how to 
do simple arithmetic. This includes addition,  
15:11 - subtraction, multiplication, and division, all of 
which are represented by the symbol shown on the  
15:16 - screen now, in any ID that you may install, you'll 
be able to print out the answer to simple math  
15:21 - problems using the print statement. Which may seem 
counterintuitive, because why would you use the  
15:25 - computer to do math when you have a perfectly good 
calculator on your phone. But you have to remember  
15:30 - that computers are dumb. And anything we want a 
computer to do, we have to build up from scratch.  
15:35 - basic arithmetic, while simple helps out in almost 
any program you may write. For example, if we  
15:41 - wanted to build a basic calculator app, we need to 
utilize this functionality in order to correctly  
15:46 - display the answer to an arithmetic problem when 
our user tries to add, subtract, multiply or  
15:52 - divide two numbers. Now in addition to the four 
basic math equations, most programming languages  
15:58 - include an additional operator known as modulus. 
If this is your first time hearing this word,  
16:02 - don't worry, since it's not usually taught in math 
classes. modulus allows us to get the remainder of  
16:08 - a divisional operation. For example, when we take 
10 modulus three, we're essentially telling the  
16:14 - computer to take 10 divided by three, ignore the 
actual answer and just give us the remainder of  
16:19 - the operation. In this case, one, since when we 
divide 10 by one, the answer is three remainder  
16:25 - one. The one in this case is what gets printed 
out to the console. If there is no remainder,  
16:31 - say in the case that we take 50 modulus two, since 
the remainder is zero, the function would return  
16:37 - zero if we were to print it out to the console. 
This can be extremely useful. In many cases,  
16:43 - the most obvious being if we want to determine 
whether or not a certain integer is even or odd.  
16:48 - If we take a certain number, modulus two, and it 
returns zero, then we know that is even because  
16:55 - any number divided by two will always result in a 
full answer without a remainder. But if the system  
17:01 - returns one, then we know that the integer is 
odd, you will find yourself using the basic math  
17:06 - operators a lot more than you think. So it's good 
to keep them in mind when running your program.  
17:10 - Now, not only can our computer work with numbers, 
but it can also work with strings. strings,  
17:16 - by the way, are just another way to say text. For 
example, hello world is a string, the letter A is  
17:22 - a string, and anything enclosed by quotation marks 
is denoted as a string in programming languages.  
17:27 - We'll cover more about strings in a bit when we 
talk about variables. But for now, let's continue.  
17:32 - We already talked about printing strings to the 
console. But let's say we're making a game and we  
17:37 - wanted to print out the statement, game over 
for was your final score. Now while we could  
17:43 - just make a string that says that exact phrase 
and print it out to the console, in some cases,  
17:47 - it would be more useful to print out the actual 
integer value, especially in the case of a game  
17:52 - where the score can change each time you play. 
Because score definitely isn't always going to be  
17:56 - for. Well, we're also able to print out multiple 
strings of text and even integers by adding them  
18:03 - together in the print statement. This is known as 
concatenation. Continuing with our score example,  
18:09 - if we wanted to print out the statement gameover 
for was your final score, using four as an integer  
18:15 - rather than a string. We could do this by 
breaking down the statement into two strings  
18:19 - and an integer like so. Print game over plus 
four plus was your final score. We of course  
18:27 - begin with a print statement, which again will be 
different across all languages. But in this case,  
18:32 - we're using Python. Inside the print statement, 
we start off by printing the string game over. Now  
18:39 - here comes the important part. From there, we use 
a plus sign and add four to the print statement.  
18:44 - Just like if you were adding two numbers, then 
we can repeat this process with another plus  
18:49 - sign for the final string was your final score. 
And we're able to print out the entirety of our  
18:55 - statement easily. Doing this we can easily 
print out multiple different strings and  
18:59 - integers together in one print statement. We could 
also combine the two lessons we've learned thus  
19:05 - far and do something such as game over plus four 
plus four plus was your final score. In the case,  
19:12 - let's say where you have a game which gives you 
a base score and then four points for a certain  
19:17 - task that you complete it. This demonstration also 
displays Another important part of programming,  
19:22 - which is that oftentimes to get your program 
to be the most efficient, you have to combine  
19:26 - aspects of code. Now it's important to note 
that the computer will take whatever you put  
19:31 - in the parentheses and print it out character for 
character. So oftentimes programmers will forget  
19:36 - to add a space onto the end of their strings. This 
can result in a small mistake in which the string  
19:41 - from the previous example would be printed out 
as if to say gameover four was your final score,  
19:46 - which isn't that appealing when displayed on the 
screen to the user. So it's a good practice to  
19:50 - always put a space after and before your strings 
to make sure this doesn't happen, and your string  
19:56 - doesn't end up like that. Another important 
thing to note is the difference between four in  
20:01 - quotation marks, and four without quotation marks. 
Now for in quotation marks is treated as a string,  
20:08 - rather than a four without quotation marks, which 
is treated as a number. This may not seem like a  
20:14 - big deal, but again, computers are dumb. And if 
you try to do math with a number in quotation  
20:19 - marks, it will return an error. Because the 
computer doesn't understand that you're trying  
20:23 - to perform the operation on a number and thinks 
you're trying to add an integer to a string,  
20:27 - which is a big no no in programming when you're 
adding numbers. So when you're programming,  
20:32 - make sure to make a mental note of whether or not 
you want to make something an integer or string,  
20:36 - because that type of stuff makes a big difference. 
All right, that concludes our segment on the base  
20:42 - power of computers. Now Next up, we're going to 
be covering one of the most important components  
20:47 - of computer science. So make sure you pay 
attention because next up we're going to be  
20:51 - discussing variables, what they are and how 
we use them. First of all, what exactly is  
20:56 - a variable? A variable is simply something that 
can store information and can be referenced and  
21:01 - manipulated. Think of variables like a cardboard 
box. cardboard boxes, servers means to store items  
21:07 - in them, which can be changed that replaced and 
modified variables are like cardboard boxes to  
21:12 - store information for the programmer to reference 
or manipulate. each variable simply has a type,  
21:16 - a name, and a piece of information stored inside 
of it. The type and piece of information will be  
21:21 - covered next, and the name is simply a name for 
the variable. Think of it as writing out a label  
21:25 - on the cardboard box in Sharpie. Now there 
are many different types of variables that  
21:30 - a programmer can use, or right now, we will just 
be covering what are called primitive variables,  
21:34 - which include integers, Boolean, floats, and 
doubles, strings, and characters. We'll start  
21:40 - off by talking about an integer. An integer 
or int for short, is as simple as it sounds,  
21:46 - a variable that can store an integer value. 
This includes all whole numbers from negative  
21:51 - 2,147,483,648 to 2,147,483,648. Notice how I 
said whole numbers, integer values can not and  
22:04 - will not hold any decimal values. So keep that in 
mind when using variables. Secondly is a Boolean.  
22:10 - A Boolean is very primitive variable which can 
store a value of either true or false. Boolean  
22:16 - variables can only hold these two values, and 
are extremely useful for conditional statements,  
22:20 - which we will cover soon. The next few types of 
variables are floats and doubles. Both of these  
22:26 - variable types are floating point data types, 
which essentially means that these variables  
22:29 - can store numbers with decimal places. Whereas 
integers values cannot hold decimal values,  
22:34 - floats and doubles can. The main difference 
between the two is that a float variable can  
22:39 - store numbers of our precision up to 32 bit. All 
doubles can store numbers with a precision up to  
22:45 - 64 bit. Essentially, a double can store more 
decimal places than a float. So it all comes  
22:50 - down to how precise you want the variable to be. 
Up. Next, we have string variables, which are like  
22:54 - the strings we've talked about beforehand, except 
store somewhere in a value. String variables can  
22:59 - store strings of letters, which are just words and 
sentences. Strings are useful for displaying text  
23:04 - and storing input information. Strings can also 
be concatenated together to form combinations  
23:08 - of string variables and pre written strings. This 
can be very useful for outputting information in a  
23:13 - readable format for the user. For example, imagine 
we have a string called name. The code asked for  
23:18 - input and storage that string of text and name. 
To output this information to the user. Rather  
23:23 - than simply displaying their name, you can add the 
phrase Your name is and make it into a sentence by  
23:27 - concatenating. Your name is plus a name plus a 
period. This makes it easier to read your code,  
23:32 - while also adding variability to your code, which 
always makes things more interesting for the  
23:37 - end user. Finally, we have char variables. char 
stands for character, and just as a name suggests,  
23:43 - they can each hold one character. This is useful 
when a programmer wants to read one button press  
23:48 - or one character in a string without using a 
string variable. a specific example is being  
23:52 - a game that is controlled by the keyboard, the 
program needs to recognize the character that is  
23:56 - pressed and translate that into carrying out some 
function. Now strings can also hold one character,  
24:01 - but chars can hold more than one character. So 
keep that in mind when defining variables. Now,  
24:06 - why are variables so useful? Well, being 
able to store information in a format that  
24:10 - can be easily referenced later is essential 
for any good program. Oftentimes, in code,  
24:14 - you're going to want to keep track of things such 
as a user's name, or score. And so by creating  
24:19 - a variable called name or score, you store this 
information in the variable and then reference it,  
24:23 - add to it or modify it. Also, many times to 
program will want to take input from the user,  
24:28 - which cannot be pre programmed into the code, 
and thus the variables required to store the  
24:32 - information. A program may also rely on factors 
that will change as the program progresses,  
24:36 - in which case a variable is once again required. 
Also, taking these variables and manipulating them  
24:41 - is quite necessary for carrying out many 
of the tasks you want to program to carry  
24:44 - out. For instance, multiplying in variables or 
concatenating string variables. Overall variables  
24:49 - are the backbone of any program, and you'll find 
yourself using them often if you want to clean and  
24:54 - efficient code. So it's best that you learn what 
types of variables you need to use and when. So  
24:59 - now that we know all about the different variable 
types, and we've talked about them a little bit,  
25:02 - we're going to delve further into what happens 
when we actually define or create a variable,  
25:07 - how we reference them, and how we can 
manipulate them for our programs. To start,  
25:12 - let's go over what happens when we actually define 
a variable. Now when we write a line of code,  
25:17 - which initializes a variable, and that code is 
executed, the computer essentially creates a  
25:22 - little space in memory that stores your variable 
name and its contents so that it can be referenced  
25:27 - later. Going back to our cardboard box example 
from the previous segment. Think of this as if  
25:32 - you had your own storage facility, and you make a 
new cardboard box labeled name. And inside of it,  
25:38 - you put a piece of paper with the word no 
pointer exception on it. Now, anytime you  
25:43 - want to know the contents of your name box, you 
could simply look inside and see that it has  
25:47 - the contents no pointer exception. This is what 
the computer does, except the storage facility  
25:53 - is the memory in your computer. The box is a 
variable and the contents of the box or whatever  
25:58 - the variable is set to be equal to. Anytime you 
want to know the contents of the name variable,  
26:04 - you can simply call it and the computer will pull 
the information that is stored in that variable,  
26:09 - and use it how the user see fits. Another thing 
to note really quickly is that you can actually  
26:15 - make a variable without putting information inside 
of it. This would simply be like if you built up a  
26:21 - new cardboard box, gave it a label with a sharpie, 
but just didn't put information inside of it.  
26:26 - You're simply saving that space in your storage 
facility for later. This can be maybe because  
26:32 - you want to store information in it later down 
the road. Or if you're going to use it to store  
26:36 - information given to you by the user, in which 
case you can't give it information since you don't  
26:41 - know what the user will input. Just to note that 
if you try to reference or point to a variable,  
26:46 - which does not have any information in it, you'll 
get what's known as a null pointer exception,  
26:50 - which despite being an amazing name for a YouTube 
channel is something you generally want to avoid  
26:55 - when programming. Now programming languages allow 
us to do some pretty cool things with these boxes  
27:01 - that we've created. For example, let's say we 
created a second variable called channel name.  
27:07 - And instead of setting it equal to no pointer 
exception, we instead set it equal to our already  
27:12 - created named variable. This doesn't create a 
space in memory for this new variable. However,  
27:18 - it simply points to the same location of memory we 
have already created for the name variable. Going  
27:24 - back to our storage facility example, this would 
be like instead of creating a whole new box label  
27:29 - channel name and storing sheet of paper with the 
word no pointer exception on it, we instead simply  
27:34 - added another label below the name box, and 
titled channel name. Now we have two variables  
27:41 - which point to the same contents, that being 
the string no pointer exception, we usually do  
27:47 - this to save space in our code for things that we 
know are going to have the same value. variables  
27:52 - can also be updated throughout your code. For 
example, let's say you had an age variable,  
27:56 - and inside of it was the integer 17. Then you 
celebrated a birthday and wanted to update your  
28:02 - age, all you would have to do is reference the 
variable and set it equal to whatever new integer  
28:07 - you want the variable to hold. In this case, 18. 
This would be the same as having a box labeled age  
28:13 - with a sheet of paper eating 17 inside of it, and 
then taking that piece of paper out, erasing 17,  
28:19 - replacing it with 18 and then placing it back in 
the box. Doing this we are able to easily update  
28:25 - the contents of our variables throughout the code 
as things dynamically shift. As another example,  
28:31 - if you were making an RPG, your character would 
likely have stats such as attack, defense manner,  
28:36 - etc. As the game progressed, you could 
continuously update the variables so that the  
28:42 - player could get more powerful, the further along 
they went through the game. And you wouldn't have  
28:46 - to create new variables, you would simply need 
to just keep grabbing that box from your storage  
28:51 - facility, erasing and replacing the numbers on 
the piece of paper and then continue along with  
28:55 - your code. Just keep in mind that these variables 
are nothing more than places in memory in which a  
29:01 - certain value is stored. So we can easily update 
the numbers and their place will remain constant.  
29:05 - After the code has run its course the place in 
memory is deleted until you run the code again,  
29:11 - and the program dedicated space for the variable 
again, each time you run the code, you're making  
29:16 - new boxes in your storage facility. And at the end 
of the code, you destroy them all to make room for  
29:21 - the new boxes next time. Another cool thing you 
can do with integer float and double variables  
29:27 - is add them subtract them, divide them, multiply 
them and even modulus them. For example, if you're  
29:33 - making a calculator app and you store the first 
number, the user entered as number one and the  
29:38 - second as number two. You could then multiply 
num one and num two together and either print  
29:44 - them or store them in a new variable entitled 
result. Then each time you run the program,  
29:49 - the user could input new numbers into the number 
one and number two variables. And they would  
29:54 - simply be set to those new integers that the user 
inputted and return the result that correspond  
30:00 - Through those specific numbers, this allows you 
to keep easy track of which numbers are which,  
30:04 - and what's going on in your program, which is 
extremely useful. Also, while you cannot subtract,  
30:10 - multiply, divide or take the modulus of strings, 
you are able to add them. Like we said previously,  
30:16 - let's say you had a string str one with the 
contents Hello, and a string str two with the  
30:22 - contents there, you could add str one and str 
two to create a string that had the contents  
30:28 - Hello there, either storing it in a third 
variable or printing it out to the console.  
30:33 - The last topic we'll be covering on the topic of 
variables is the naming conventions of variables,  
30:38 - which will be it may seem odd, but it's extremely 
important when trying to read your code. So we'll  
30:44 - be covering it now. Now variables have to be one 
continuous string. And so if you wanted to make a  
30:50 - variable that store the player score, you'd have 
to find some way to combine the words player and  
30:55 - score. Since you can't have the phrase player 
score be the name of a variable. All programmers  
31:01 - have their own personal preference when it comes 
to naming variables. But the one we'll be using  
31:04 - in this lecture is called camelcase, which is 
the process of not capitalizing the first word,  
31:10 - but capitalizing every word that follows 
it. Going back to the player score example,  
31:15 - using the camel case method, the variable 
would be called player score. This allows  
31:20 - us to easily see and identify each word and 
becomes really useful for long variable names,  
31:25 - like the player score before the final boss. 
Whereas if we just type it out without camelcase,  
31:31 - it would be really confusing and hard to read. 
This will help you out a ton when we start finding  
31:37 - bugs in our code and need to quickly scan through 
our program to figure out what is wrong and adds  
31:42 - to the overall readability of the program. 
Other programmers might use different naming  
31:47 - conventions like using underscores to separate the 
words in a phrase. But for now, and this series,  
31:52 - we'll be sticking with camel case. Next, 
we'll be moving on to conditional statements,  
31:58 - which at their core, are statements that change 
the path of our code depending on certain  
32:02 - conditions. For the sake of keeping things simple 
for this section, where Atlanta will connote that  
32:06 - our code will not be following the specific path. 
In Greenland's I mean, our code is following the  
32:10 - path. The main type of conditional statement 
that programmers use is the if statement,  
32:16 - and this will show up countless amount of times 
in any program you write. It is as simple as it  
32:21 - sounds, if some condition is true, and usually 
that condition will be enclosed by braces, then  
32:28 - carry out the instructions located within the if 
statements brackets, else do another thing. Now,  
32:34 - brackets are used in most programming languages 
to indicate a segment of code which will run it  
32:40 - works like this. If the condition in parentheses 
is true, then all of the code contained within the  
32:45 - brackets will run. And if the condition within 
the parentheses is not true, then it will skip  
32:50 - over all the statements within the brackets. A 
quick note is that while this is the case, with  
32:55 - most programming languages, some, like Python, 
use columns and whitespace to determine where a  
33:01 - piece of code starts and ends. But for the sake of 
this series, we'll be using curly braces. Now, the  
33:08 - condition within the parentheses can take on 1000s 
of different forms, such as if the value of the  
33:13 - string variable name is equal to Steven, or if the 
player score stored in an int variable is greater  
33:19 - than five. The list goes on and on. Each of these 
statements is evaluated as a Boolean, which you  
33:25 - will remember from when we talked about variables 
is either true or false. If the Boolean is true,  
33:30 - we run the code inside the curly braces. If it's 
not, we pretend everything inside the curly braces  
33:36 - never existed, and move on with our code. The 
if statement comes with two more additional  
33:42 - statements that go with it elsif and eltons. 
elsif is a conditional statement used directly  
33:48 - after an if statement, and carries out mainly 
the same function as an if statement. However,  
33:53 - the elsif statement will only be evaluated if the 
proceeding F or the preceding elsif statement is  
34:00 - bypassed due to its condition being false. So we 
will run through it like so. If something is true,  
34:06 - we will run the code inside of that statements 
curly braces out if that's something is not true.  
34:11 - But another statement inside of the parentheses 
is true, we would then run that code segment. And  
34:17 - if neither of them are true, we would skip both 
segments of code and move on in our program. This  
34:22 - can be a hard concept to wrap your head around 
to so let's do an example. If we had a program  
34:27 - that evaluated the if statement, if age is equal 
to 10, we then have a statement under that which  
34:32 - stated outs if age is equal to 12. Now, if the age 
variable was 10, which we can see from the example  
34:38 - that it is, then the code immediately following 
that conditional statement in the brackets would  
34:42 - run. The Ultra statement we made will not even 
be tested. Since we know that it is going to be  
34:47 - false. And thus the print statement inside of that 
conditional statements brackets will be ignored,  
34:51 - and the code will move on to the rest of the 
program. Now for example, let's say we change the  
34:56 - age variable to be 12 instead of 10. Now instead 
of the first conditional statement being true,  
35:01 - it actually evaluates as false since age is no 
longer equal to 10. So what we do now is first  
35:06 - skip over the print statement, which prints out 
that ages 10 and does not. And then we evaluate  
35:10 - the elsif statement, we check if age is equal to 
12, which again it is. And so now we run all the  
35:15 - code inside of that conditional statement before 
finally moving on to the rest of our program. So  
35:20 - as a review, we check the initial if statement. 
If it's good, then we run all the code within that  
35:25 - if statements curly brackets and move on with our 
program. If the initial if statement is not true,  
35:29 - we then move on to any elsif statements and 
evaluate if those conditional statements are  
35:33 - true. We can have as many elsif statements as we 
want, although this could lead to clutter amongst  
35:38 - your code. So we'll talk about some alternatives 
later to help us out. Now that takes care of  
35:42 - the FL statement. So now we'll move on to the 
else statement. The out statement, once again,  
35:47 - it comes after an IF or an elsif statement, 
and we'll carry out its instructions no matter  
35:51 - what. As long as the proceeding statement slash 
statements are evaluated as false. If we went  
35:56 - back to our previous program, we could add an 
elf statement, which would only have the code in  
36:00 - his brackets run at the age variable wasn't 10, 
or 12. This will catch all cases of the program  
36:05 - that didn't fit into our parameters. It's good 
practice to always have another statement at the  
36:09 - end of your conditional statements to catch any 
weird cases that may come up in your program.  
36:12 - Now remember back to the fact that we could have 
1000s of Elif statements after a while that can  
36:18 - get pretty cluttered. And so another very useful 
conditional statement helps circumnavigate this  
36:22 - problem is a switch statement. A switch statement 
is functionally similar to many if and else  
36:26 - statements together, you write a switch statement 
in the form of switch variable. And then below  
36:30 - that you write out how many cases the variable 
can be. For instance, if we wrote switch var,  
36:34 - and then under read write out five cases that the 
variable var could be and then the instructions  
36:39 - listed under each case would be carried out 
if the var variable it would be equal to that  
36:42 - case. Now switch statements are different sets. 
Instead of using brackets, they use a column to  
36:47 - signify the start of a set of instructions and a 
break statement to end them. This is very useful,  
36:52 - because you are able to essentially use many if 
and else if statements without having to write  
36:55 - nearly as much. In switch statements, you just 
always have to remember to include default case  
37:00 - at the bottom of the expression to denote any and 
all cases that don't meet the above requirements.  
37:04 - There simply catches all the inputs that don't fit 
within the program's main cases. It's very similar  
37:09 - to just case the end of an if else chain. Now, 
why are these statements so useful? Well, many  
37:15 - times programmers want their programs to function 
differently depending on different conditions.  
37:18 - For instance, a program could function differently 
depending on the information that the user inputs,  
37:22 - such as allowing user to use a program or not user 
program if they are above or below 18 years old,  
37:27 - respectively. Or in say, a video game. If the user 
experiences above a certain threshold, you might  
37:32 - want to give them harder opponents to battle. 
Another example could be a program was changing  
37:36 - the color scheme depending on the time of day. Or 
even more simply, if a user presses a button that  
37:41 - is meant to move on to another screen in an app, 
the programmer would only want that app to change  
37:44 - screens if the user clicks that button. A program 
without conditional statements would do the same  
37:49 - thing every time, and would be very primitive 
compared to one that can change depending on  
37:52 - its conditions. So now that we know how to make 
and use variables, how to compare them, and what  
37:58 - we can do with those comparisons, let's move on to 
another foundational concept of computer science.  
38:03 - And that is arrays. Now we've already talked about 
variables, and how great they are for storing  
38:09 - singular bits of information for making our code 
more simplistic. But one of the biggest drawbacks  
38:14 - that comes with variables is their inability to 
hold more than one piece of different information.  
38:18 - For example, let's say you're making an app which 
allows a user to create a grocery list. Well,  
38:24 - there's no real easy way to create lists using 
variables. Because it's not like you can have one  
38:29 - variable store the names of six or seven different 
food items. Remember, we can only put one piece of  
38:35 - paper in our cardboard box no more. And besides, 
even if you were able to add multiple items to one  
38:41 - string variable, you would still have a lot of 
trouble doing simple tasks you might want from  
38:45 - a list such as searching through it, splitting it 
or even deleting items from the list when you're  
38:50 - done with them. This is the problem that using 
arrays solves for us. An array is as you may have  
38:56 - guessed by now, a list, you can have an array 
of integers, an array of strings, and even an  
39:02 - array of other arrays, which is something we'll 
cover in a minute. Programmers use arrays when  
39:07 - they want to store a lot of variables containing 
information that is all related to each other,  
39:10 - such as a grocery list or a high score list in 
the game. Think of arrays as a column in Excel  
39:16 - or Google Sheets. Here the title at the top and 
then below it are a bunch of bits of information,  
39:21 - which all relate back to the title. Arrays are 
super useful when programmers want to store a lot  
39:26 - of information that can be easily searched 
through because programmers have developed  
39:30 - methods of breaking down and using arrays to find 
specific information in arrays full of 1000s of  
39:35 - different variables. As an example to show just 
how useful arrays are. Let's say you're a startup  
39:40 - company that owns an app that has 100,000 users. 
Every time a user wants to create a new account,  
39:45 - they input the username they want and then your 
program will have to check to make sure the  
39:49 - account name hasn't already been taken. Doing this 
requires you to search through the information of  
39:53 - all 100,000 of your users to see if that username 
has an account with your service and array would  
39:59 - be able to get Pain all of this information 
and make it easy to search through and find  
40:03 - out if the account name has already been taken 
with little to no delay. Now, the single most  
40:08 - important thing to note about arrays is how you 
reference each element of the array within them.  
40:13 - Let's create a basic array called numbers and 
inside of it, put the digits one through 10. Now,  
40:19 - when we want to refer to each cell in his array, 
we would call upon its index. an index is just a  
40:24 - fancy way of saying that numbers placed within the 
array. Now you would think that the first integer  
40:30 - in this array would be the first index, the 
second would be the second index and so on. But  
40:35 - that's simply not the case. In computer science, 
programming languages refer to the first cell as  
40:40 - zero with element in the array. This means that 
if we were talking about our array of numbers  
40:45 - we just made, the number four would actually be 
in the third index, five would be in the fourth,  
40:50 - and so on. So instead of starting our count from 
one, we start from zero. It's extremely weird and  
40:56 - confusing, but it's one of those programming 
quirks, you're going to have to memorize and  
40:59 - commit to memory. If you were to not follow this 
nomenclature, and refer to the last element in  
41:04 - this array as the 10th, you get what is referred 
to as an array out of bounds error, since you're  
41:09 - trying to reference the 10th element, but there 
is no 10th element, where you're actually trying  
41:14 - to do is reference the ninth element. Another 
extremely important thing to note about arrays  
41:18 - has to do with their size. When you initialize 
an array, you can do it in either one of two  
41:23 - ways. You can either populate it with the elements 
that you want contained in the array right then in  
41:28 - there, creating and filling the array at the same 
time. Or you can define how many elements you want  
41:34 - the array to hold, essentially the array size, 
and then populate it with elements later. This  
41:40 - is because when we initialize an array, it creates 
a space in memory that has a size of exactly what  
41:45 - you give it. no more and no less. This is great 
for when we want to access elements in the array,  
41:51 - because we can do so instantaneously because the 
computer knows exactly where in memory the array  
41:56 - is stored. But the one downside is that we can't 
increase the size of the array later on. All array  
42:02 - sizes are final. Think of this like setting up 
a bookshelf with books by populating a bookshelf  
42:09 - with a certain number of books. And then moving on 
and filling the next shelf with different books,  
42:13 - we have no way to go back and add books to that 
first shelf without shifting everything over. Once  
42:19 - we decide how much space to dedicate for an array, 
in this case, there's no way to add more space.  
42:24 - Once again, because this is extremely important to 
remember. This means that once an array has been  
42:30 - defined, there is no way to change the size of it. 
If you have an array titled names with a size of  
42:36 - eight, and you try to add another name to the 
array, you will receive an error. So be careful  
42:40 - when messing around with array sizes. Of course, 
you can always go back to the start of your code,  
42:45 - when you initially make the array and allocate 
more space to it, increasing its size. If you  
42:50 - find out that you need more space to hold items, 
but once it's defined, you cannot change its size  
42:56 - through conventional methods. Another small thing 
I want to touch upon really quickly is that when  
43:01 - you initialize an array, you must determine 
which type of array it is right then in there,  
43:05 - for example, you have to specifically say it 
will be an array of strings or integers when  
43:10 - defining it. And also you're not allowed to mix 
and match. Meaning that you can't have an array  
43:15 - full of integers with a few strings and some 
doubles thrown into the mix, they all have to  
43:20 - be the same type. Now the last thing we're going 
to cover on arrays is a little funky. And that is  
43:25 - the practice of putting arrays inside of arrays. 
If you make an array of arrays is referred to as  
43:30 - a 2d or two dimensional array. Think of these as 
matrices if you've taken an algebra class before.  
43:36 - Now, if you haven't Think back to our Google 
Sheets example, but instead of using columns,  
43:41 - we would add rows as well. So now each element in 
an array would simply just be a string variable  
43:47 - or an integer variable. But an entirely new array 
with its own set of values and elements. The way  
43:53 - we index these is mostly the same, except we would 
have two numbers to index instead of one. We start  
43:59 - with the row and then the column. So a number 
in the positions 02 would be in the first row,  
44:04 - three columns down, in this case, the name 
Clint a number in the position one one would  
44:11 - be two rows down and to columns across, in this 
case, the name Chris, you get the idea. Now you  
44:18 - can also make three dimensional arrays by putting 
an array inside of an array inside of an array,  
44:22 - but that's a little above what we're going to 
be covering. So I'm going to cut it off there.  
44:26 - Next up, we're going to be talking about loops. 
So what exactly are loops? Next up, we're going  
44:30 - to be talking about loops. So what exactly are 
loops? Next up, we're going to be talking about  
44:35 - loops. So what exactly are loops? Next up, we're 
going to be talking about loops. So what exactly  
44:40 - are loops? Next up, we're going to be talking 
about loops. So what exactly are loops? Well,  
44:46 - as you can probably tell by that statement right 
there. A programming loop is a statement that is  
44:50 - used to run certain instructions repeatedly. Just 
like how the opening statement of this topic was  
44:54 - repeated five times. loops are very useful for a 
variety of reasons. For instance, imagine you want  
44:59 - to print something 15 Sure, you could just copy 
and paste the print statement 15 times, but this  
45:03 - is really annoying to have to do, it becomes even 
more unrealistic when that number goes up to say  
45:07 - 100 or so. Now what if instead of rewriting 
the same instructions over and over again,  
45:12 - you would simply place the print statement inside 
of a loop, and it will occur as many times as you  
45:16 - would like. Now that's the power of loops. With 
loops were able to repeat parts of code multiple  
45:20 - times. Now, there are three different types 
of loops that we will be discussing today.  
45:24 - And first is the for a for loop is very useful 
for situations like the one described above,  
45:30 - where you would like to carry out a certain set of 
instructions numerous times. The syntax for a for  
45:35 - loop varies depending on the language, however, it 
usually consists of three parts an integer value,  
45:39 - a condition which the integer value must meet in 
order to exit the loop, and an operation to modify  
45:44 - the integer value at the instructions inside the 
loop are completed. Each time the for loop runs,  
45:48 - the operation you set will be performed on the 
integer as long as that integer still needs to  
45:53 - condition your set, usually being greater than 
or less than a constant value, the for loop will  
45:57 - continue to run. Eventually, when the integer has 
been modified by either increasing or decreasing  
46:02 - it to the point where it no longer meets the 
condition, the for loop will terminate and the  
46:06 - code will continue to run. For example, let's say 
our integer value was I and we set it equal to  
46:10 - zero, then we set the conditional statement 
as I being less than three. So basically,  
46:15 - we're saying that as long as I the variable we 
just created is less than three, continue running  
46:19 - the instructions contained within the loop. 
Finally, we make the operation i plus plus,  
46:23 - meaning each time the loop runs, we increase it 
by one, and inside of the loop, let's just put  
46:27 - a simple print statement. Now let's run through 
the for loop, we start with i equals 00 is less  
46:34 - than three, so we enter the loop and print out 
hello world. Now that the instructions are done,  
46:38 - we add one two, I'm making it one moving on. One 
is again less than three. So we want to get into  
46:44 - the loop and print out hello world. Again, we had 
one two, I'm making a two now to is still less  
46:50 - than three, so enter the loop again and print out 
hello world. Finally, we add one to it once again,  
46:54 - and it becomes three. Three is not less than three 
though, is equal to three, and so we don't enter  
46:59 - the loop and it terminates. Moving on to the next 
segment of code. This is a simple example. But you  
47:03 - can extrapolate it across programming to fit your 
needs. Now when using a for loop, we have to make  
47:08 - sure to set up a condition that given the initial 
integer value and the operation will at some point  
47:12 - not be met to avoid creating an infinite loop 
and crashing your program. an infinite loop  
47:17 - occurs when you give a for loop a condition which 
will always be met given the parameters of the  
47:20 - program. And so software crashes. For example, a 
for the beginning at 10. And checking if is over  
47:26 - less than zero, and then adding one to either the 
end of the loop will never terminate since I will  
47:30 - suggest increase infinitely. After the for loop is 
the very similar for each loop. A for each loop,  
47:36 - or a for in a list loop in Python is used for 
iterating through arrays or lists. Essentially,  
47:43 - the loop will go through each element in the 
array and carry out some server instructions  
47:48 - for each value. If you would like to read all of 
the elements in an array and compare them to some  
47:53 - value, or perform some operation on them, a for 
each loop is extremely useful. So for example,  
47:59 - we could have a for each loop which iterated 
across an array and simply printed out the  
48:04 - value of each array location. Next up we have the 
while loop. A while loop will continually carry  
48:10 - out instructions while a conditional statement 
given to it is true. This can be as long as a  
48:14 - certain variable is true. As long as the numbers 
that's another number, or while a value is still  
48:18 - equal to another value. For example, while loops 
are different than for loops in that the loop is  
48:22 - not contained within one statement but stretched 
out and will continue to run. As long as this  
48:26 - condition is true. Like a for loop, you could make 
the condition such that it will eventually return  
48:31 - false and exit the loop. However, while loops 
will not crash your computer should you create an  
48:35 - infinite loop. In fact, it is very common for wild 
lips to run infinitely. As for certain programs,  
48:40 - you would like the program to continually 
be iterated through instead of running once  
48:44 - all the way through until you exit out of the 
program. When programming a game for instance,  
48:48 - a while loop would be used to iterate through your 
code, continually refreshing the screen as the  
48:52 - game runs. From there you can perform operations 
on the screen to make the game playable. Creating  
48:57 - infinite while loop could be done by simply using 
the syntax, while true, as the condition true will  
49:01 - always be evaluated as true. Finally, I'd quickly 
like to cover the extension of a while loop  
49:06 - the do while loop. Do while loops are very similar 
to while loops, except they will carry out their  
49:11 - instructions at least once even if the condition 
is false. And then we'll carry on like a basic  
49:16 - while loop. Essentially, the conditions inside 
of the loop will run at least once. And then if  
49:20 - the condition is still met, they will run again 
and function as a normal while loop would. As you  
49:25 - can see loops in there many varieties has some 
extremely useful functions. using them, you're  
49:30 - able to perform an operation many times in a 
row. You can iterate through arrays and lists and  
49:35 - overall decrease the clutter of your code. Next 
up, we're going to be taking a break from learning  
49:41 - about common programming statements and dive into 
what happens when the code we write doesn't work.  
49:45 - More specifically, we'll be covering the different 
types of errors that can occur when you're  
49:49 - programming and what causes them. Now when you're 
writing code, you have to understand that things  
49:54 - aren't always going to go the way you expected 
them to. And sometimes the program doesn't always  
49:58 - work as you had intended. too. We programmers call 
these errors. And while annoying, they're always  
50:04 - going to come up in computer science, and so 
it's best to learn what they are and how to deal  
50:08 - with them. Often referred to as bugs, errors and 
scripting languages can be narrowed down to one  
50:14 - of three types, syntax errors, runtime errors, and 
logic errors, all three of which we'll be covering  
50:20 - in today's video. To kick things off, let's talk 
about syntax errors. These are usually the easiest  
50:26 - of the three to solve, since they are oftentimes 
something that can be fixed within seconds. If  
50:30 - you remember back to earlier in the video, when we 
talked about syntax and programming rules, we said  
50:36 - that if you were to break the programming rules or 
syntax that would result in an error. Well, that's  
50:41 - what syntax errors are parts in your program where 
you fail to meet the programming rules, and so the  
50:46 - computer doesn't know how to interpret your code. 
This can be anything from forgetting a semicolon  
50:50 - at the end of a statement in Java, accidentally 
defining a variable with two words instead of one,  
50:55 - or even just misspelling the word string when 
you're trying to define a string variable.  
50:59 - Lucky for you guys, these errors are extremely 
easy to fix, since you just need to figure out  
51:04 - where the error occurred, and what the syntax 
rule you broke was. Now thinking back to IDs,  
51:10 - we mentioned that IDs are so useful because they 
do precisely that. They underline the syntax  
51:15 - errors and usually provide helpful hints as to 
how to fix them. Think of syntax errors as small  
51:20 - misspellings or grammatical errors in an essay 
you're writing annoying, yes, but not the most  
51:25 - infuriating things. Another useful thing about 
it is when it comes to syntax errors is that the  
51:31 - program will actually restrict you from running 
the code unless all syntax errors are cleared,  
51:35 - making them even easier to identify and fix. The 
second type of error we will be covering is the  
51:42 - runtime error. These errors don't show until you 
actually run the code, hence the name runtime  
51:48 - error. runtime errors are usually caused by a 
statement in your code that seems logically sound,  
51:53 - but the computer physically has no way of 
computing it in a reasonable amount of time.  
51:57 - The most common of these errors is one which 
we've already talked about the infinite loop,  
52:03 - as a refresher or an example. Think of an infinite 
loop like this. Say you set your friend down in  
52:08 - front of the TV, put on the office, and told him 
he could leave as soon as Michael made it. That's  
52:13 - what she said joke. Seems pretty simple, right? 
Wrong, because instead of putting in the office,  
52:19 - you put in friends on blu ray. Now, Michael, 
no inappropriate joke, meaning your friend  
52:24 - would be sitting there for the rest of his life. 
This is basically what happens with a computer,  
52:29 - you give it some condition that it has to complete 
before the program can terminate. However,  
52:33 - you give it no feasible way to finish that task. 
This puts the computer in error mode, and most  
52:39 - likely it will crash your program. As the computer 
desperately tries to complete the condition you  
52:44 - gave it. As a computer example, if we try to have 
a program terminate when integer i is no longer  
52:50 - greater than 99. But eyes initially 100 and only 
ever increases, the loop will never terminate,  
52:57 - and the program will crash. To avoid these, you 
generally want to think through the flow of your  
53:02 - code before running it, especially with loops 
to make sure that all of your statements can be  
53:07 - completed by the computer. Carefully planning out 
your code before you begin writing is an extremely  
53:12 - useful practice, and something we'll be covering 
towards the later part of this video. The final  
53:18 - type of error that we'll be covering is a logic 
error. This error is also pretty self explanatory.  
53:22 - A logic error occurs when the code runs smoothly 
without any runtime or syntax errors. But the  
53:28 - result that you get just isn't what you want it. 
For example, let's say you had a calculator app,  
53:33 - and you want it to instruct a program to add two 
numbers, except it multiplied them because you use  
53:38 - the multiplication symbol on accident. This leads 
to the sum being 36 instead of 13. nothing went  
53:46 - wrong with the code syntax or runtime wise, the 
code runs just fine. It just doesn't work as you  
53:51 - had intended it to. These are often the hardest 
types of errors to debug. Since most of the time,  
53:57 - you'll have no idea why the code isn't working, 
and certainly not any idea of how to fix it.  
54:01 - This is why it's a good idea to test your 
code incrementally. Don't wait until you've  
54:06 - been programming for an hour before testing your 
application. We're all to run into a lot of logic  
54:11 - errors. Logic errors can be extremely fury ating, 
and could cost you a lot of time making them a  
54:16 - huge pain. But if you know how to effectively 
debug your code, you'll be just fine. Speaking  
54:23 - of debugging your code that brings us straight 
into our next topic, which is how to debug your  
54:27 - program. Now let's say you've written a program, 
you think it's ready and you're ready to test.  
54:32 - You've been working hard on this and you're just 
wanting to see it in action. You run the program  
54:36 - and wait for it to run smoothly and efficiently. 
Only it doesn't work. you've encountered one of  
54:41 - the three errors we've just mentioned. You really 
want this code to work but how this is where  
54:45 - debugging comes into play. If the code is giving 
you an error, the first thing you should do is  
54:50 - read the error. Oftentimes for syntax and runtime 
errors, the ID will print an error message out to  
54:55 - the console. See what line or lines it points to 
since those little lines with the occurred, and  
55:00 - see if you can understand and fix what the problem 
is. If the error isn't clear, or you've never  
55:06 - heard of it, then try googling it as there are 
many websites out there. So just Stack Overflow,  
55:10 - which service forums to ask an answer problems 
with code. Chances are, if you've had a problem,  
55:16 - someone else has had the same issue and there's 
likely a tested solution. Usually, when the syntax  
55:21 - or runtime error pops up, you should be able 
to find a fix for it fairly easily. However,  
55:26 - as I said before, the issue may arise from some 
loophole or oversight in the code you hadn't  
55:31 - planned for beforehand. Maybe you did something 
as simple as multiply two variables instead of  
55:35 - adding them. These are logic errors we talked 
about previously, these problems usually won't  
55:39 - have red text show up to explain what went wrong, 
you'll have to figure it out yourself. Now, there  
55:45 - are a few different strategies that you can use in 
order to track down and fix a logic error. First,  
55:50 - you could use print statements and the console 
in order to determine where the code is going  
55:55 - wrong. Imagine you have a conditional statement 
that will run one segment of code if an integer  
55:59 - x is greater than five, and it will run another 
segment of code if not, if in your program. X is  
56:06 - supposed to be greater than five when the program 
reached this conditional, but for some reason,  
56:10 - the program is still printing out x is small, 
you can use a wrench they're meant to help. For  
56:15 - this problem. Specifically, you could place 
the print statement before the branch or the  
56:18 - conditional that would print the value of x. Now 
when you run the program, you know exactly what  
56:23 - the computer is thinking, printing out the value 
of x just before the FL statement. While you know  
56:28 - the variable has the value you wanted to have. And 
if it doesn't, you know that somewhere above that  
56:33 - conditional is something went wrong, and x was set 
to a value you didn't want it to. In this case,  
56:37 - x is equal to two, which is why x is small is 
being printed out. Now that we know what the  
56:43 - problem is, we can track down where and when in 
the code, we modify x in order to solve it. Use  
56:48 - print statements to determine where your program 
goes wrong, and then try to track down the cause  
56:52 - of these issues and solve them. If you use this 
strategy, make sure you end up deleting the print  
56:57 - statements afterwards to avoid clutter in the 
console. The situation described above could  
57:02 - also be solved using a breakpoint. a breakpoint 
pauses your program when the line you placed a  
57:07 - breakpoint at is reached. If say you would like to 
program to run through a certain conditional and  
57:12 - set a variable based on that conditional. But you 
are unsure if this actually happens in your code,  
57:16 - you can place a breakpoint inside the conditional 
path that you expect to run. Upon the breakpoint  
57:22 - being reached, the program will pause and wait 
for you to continue it through a button press.  
57:25 - This signals that this button occurred where the 
breakpoint was placed. In this case, the correct  
57:30 - conditional path has been reached by your program. 
You can then continue the program knowing that  
57:35 - this was or wasn't where the error in your code 
occurred. breakpoints can be used in conjunction  
57:40 - with print statements. In order to do both pause 
the program and perhaps view the values of your  
57:44 - variables at the moment in time to give yourself 
all of the information you could want. You can  
57:49 - also have multiple breakpoints to help slowly work 
your way through your program and determine where  
57:53 - an error has occurred. A combination of these two 
strategies will help you easily determine where  
57:58 - in your code you have incurred a logic error. 
Next, let's go over what to do if you think you  
58:04 - have tracked down the section of code that causes 
the problem. You may think you should delete it,  
58:09 - but it's likely you put it there for a reason. 
And you don't want to lose all that work if you  
58:13 - don't have to. Firstly, try commenting it out. 
Comments are used to markup code and explain their  
58:18 - surrounding sections. They can also be used to the 
bug. Anything that is designated as a comment will  
58:24 - not be read by the program as code and will be 
skipped over. Essentially, it becomes something  
58:29 - that is only there for you, the programmer to 
read. The syntax varies from language to language,  
58:34 - but it usually involves placing some symbols 
before or around the code you would like to be  
58:38 - commented, examples of how to comment in different 
languages can be seen on the screen now. Also,  
58:43 - when you comment something, the ID will grayscale 
that line of code, making it extremely easy  
58:48 - to determine what's commented and what's not 
commenting code deletes it in the computer's  
58:53 - eyes without actually deleting it. If a problem is 
present before you comment a section of code, but  
58:58 - it's gone afterwards, then that section of code is 
the culprit. If you comment part of the code out  
59:03 - and there are still issues and move on to another 
section until you find the culprit. Once you do,  
59:08 - you can tweak it until it works as intended 
or deleted entirely. And you'll have a fully  
59:13 - functioning program once again. Now that we've 
talked about what to do if you've encountered an  
59:17 - error, and a strategy on how to find and fix it, 
I'd like to talk about some strategies you can use  
59:22 - to avoid errors in the first place. Firstly, 
backup your code frequently. In the event of  
59:27 - the code completely bugging out and you being 
unable to fix it, you will want the ability to  
59:31 - revert to a previous version where the code was 
still working. If you save frequently enough,  
59:36 - you will probably not lose too much work. Version 
managers like GitHub or subversion can help with  
59:41 - this as they backup code to an online cloud 
service, which you can easily pull previous  
59:46 - versions of the program from at any point. Also on 
top of saving, running your program frequently to  
59:52 - ensure that the current version works as intended. 
This accomplishes two things. First of all,  
59:56 - it prevents you from saving a backup that 
doesn't work second If you encounter a problem,  
60:01 - it will be easier to find if you have only 
made a small number of changes since the last  
60:05 - time you ran it, and it worked. And thus, you 
will only have to look through the new code for  
60:08 - problems. If you've spent five hours coding 
and hadn't run it during that time period,  
60:12 - it's going to be likely that at some point, 
during that five hour code session, you messed up,  
60:16 - and it's going to be even harder to figure out 
where you went wrong. errors, while annoying and  
60:21 - extremely frustrating, are a fundamental part 
of making you a better programmer. Alright,  
60:26 - now that we've covered errors for a bit, let's 
hop back onto the programming statement train  
60:30 - and talk about one of the most important concepts 
in computer science, they'll function. Now, you  
60:36 - may not know it, but we've actually been talking 
about a few functions, this entire series, print  
60:41 - statements for loops. And even the basic math 
operations we've talked about are all examples  
60:46 - of functions, which of course, begs the question 
of what actually defines a function? Well,  
60:51 - a function is a segment of code that can be easily 
run by calling the function name. And depending on  
60:57 - the type of function will do something in return. 
functions can be called numerous times and in  
61:02 - numerous places in your code. Essentially, they're 
like wrapping up a segment of code into a nice  
61:07 - present, and giving it a name, which, when called, 
will unwrap the present and go through the code  
61:13 - that you had wrapped up. For example, the print 
statements we've been using this series allow  
61:18 - us to print something to the console anytime we 
want. Those are functions, you see, we just call  
61:24 - the print function and enter in what we want to be 
printed to the console into the parentheses, and  
61:29 - the computer does it for us. Behind the scenes, 
there's actually even more complex code that is  
61:34 - in charge of taking your text and translating it 
to the console to be printed. The developers of  
61:40 - almost all programming languages realize that you 
don't want to program something that manually has  
61:45 - to print something to the console through the use 
of complex programming. And so they implemented  
61:50 - the print statement to reduce the stress and 
complexity of code on the user, abstracting it  
61:55 - to the single line of code that is print. All of 
that code that is used to print something to the  
62:01 - console is wrapped up like a present and given 
to us in the form of one line. This is actually  
62:06 - the main theme of all functions and the backbone 
of any good program. Oftentimes, in your program,  
62:12 - there are going to be sections of code which are 
repeated and serve the same purpose, or equations,  
62:17 - which you want to allow different inputs of. And 
so you can use functions in order to condense  
62:21 - these down into singular lines of code to save 
both time and reduce clutter on your code. As  
62:27 - you will see soon functions are extremely 
powerful, and will definitely be something  
62:32 - you utilize all the time in your computer science 
journey. The print statement is just one example  
62:38 - of functions in everyday code. There are 1000s 
of functions that are available to you through  
62:43 - the IDs. However, because we won't always use 
all the functions that are available to you in  
62:48 - a single program, you have to import these 
functions from packages found in the ID E,  
62:52 - which is something that we'll be covering later 
on. Now, there are four main types of functions  
62:57 - in most programming languages. And they are 
separated by two defining features, whether or  
63:02 - not they take in arguments and whether or not 
they return values. Let's start by separating  
63:07 - them by whether or not they take arguments. But 
first we have to cover what arguments actually  
63:11 - are. arguments are essentially variables that we 
pass into the function in order to be manipulated,  
63:18 - and then either returned back to us printed to 
the console or used in another operation. Think of  
63:24 - functions with arguments like this. If you walked 
up to your local Five Guys, and told them that  
63:29 - you wanted to get food without supplying a type of 
food, they would probably look at you confused. In  
63:33 - order to get the food that you want, you need to 
tell them exactly what you want to order so that  
63:38 - they can give it to you. In this case, getting 
food is the function and what you order in terms  
63:44 - of food is being passed in as the argument based 
on what you tell them or the argument that you  
63:50 - pass into the get food function, they will 
do something different. You should also note  
63:55 - that the argument can be many different things. It 
could be fries, burgers, sodas, really anything on  
64:00 - the menu, and such as the case with arguments in 
programming. Arguments can be strings, integers,  
64:06 - arrays, pretty much anything. As an example of a 
function that takes in arguments, let's look at  
64:13 - the max function, which takes in two integers as 
arguments and returns the maximum number between  
64:18 - the two. Now for this function, if you don't 
input two numbers or variables for it to compare,  
64:24 - it's going to throw you an error. Just like the 
five guys employee. He doesn't know what you  
64:29 - want to eat Since you didn't provide him with any 
arguments. And the computer doesn't know which two  
64:33 - numbers you want it to compare and return Since 
you didn't provide it with two integers. arguments  
64:39 - are a way for programmers to have one function 
that can do many different things depending  
64:43 - on whichever variables can be passed through 
arguments, add variability to programming and can  
64:48 - help diversify your code. Think of it like this, 
a restaurant that only allows one type of food to  
64:54 - be made regardless of what you order isn't going 
to be very useful or diversified but We're able to  
65:00 - pass in arguments and tell them what food we want, 
our experience can be heightened and more options  
65:05 - can become available to us, which is exactly what 
happens when you start using arguments in your  
65:10 - function. Now that we've talked about functions 
that take in arguments, let's move on to functions  
65:16 - which do not, because functions can also be 
created and used without taking arguments in  
65:20 - and still be incredibly useful to the programmer. 
For example, let's say you're making a text based  
65:26 - RPG game, and one of the options you give your 
player is the ability to view their stats at  
65:31 - various points throughout the game. Now every 
time you come upon this option, and they choose  
65:35 - the view stats button, you don't have to type out 
six different print statements for every statistic  
65:41 - they may have, your code would get cluttered and 
messy very quickly. Instead, what you could do  
65:46 - is you could package the six different print 
statements in a simple function called print  
65:50 - stats, you don't need to pass in any arguments 
into the function, since the function will do the  
65:56 - same thing no matter what the statistics on the 
player are. Now, every time the user wants to view  
66:01 - their stats, you could simply call the print stats 
function, and voila, the user stats are printed  
66:07 - for them to view. This allows you to save a lot of 
time writing code, but also a lot of space, which  
66:13 - is extremely important when your programs begin 
getting into hundreds and 1000s of lines of code,  
66:17 - and you want to easily search through it to maybe 
debug. Okay, now that we've separated functions  
66:24 - into those that take arguments and those that 
do not, let's again, split these up into those  
66:28 - that return values and those that do not. Another 
thing you have to understand is that when you're  
66:34 - making your own functions, which is something 
that we'll be covering very soon, you have to  
66:38 - choose what your function will return, if anything 
at all, functions are able to return values back  
66:44 - to the user, whether they be in the form of string 
variables, integer variables, or even arrays. Now,  
66:50 - the thing to note about returning variables is 
that calling the function alone won't do anything,  
66:56 - you have to return the value into something or 
print it out. As an example, the max function we  
67:02 - talked about previously would return an integer 
back to the user. But in order to do something  
67:07 - with it, we would have to either set a new integer 
variable equal to the result of that max function.  
67:13 - Or we can print out the result of the function, 
which in this case, which is print out the maximum  
67:18 - value between the two integers. Using functions 
which returned values don't do much on their own,  
67:23 - you have to pair it with something in order to 
gain the use from it. Let's do another example.  
67:29 - Let's say you had created a function which took in 
two string variables as arguments and combine that  
67:35 - using that fancy string that we talked about 
earlier, and then return them as a singular  
67:40 - string. This combined string function could then 
be used to create new string variables. Since what  
67:46 - it returns is basically a string, the variable 
would simply be set to whatever is returned from  
67:52 - this combined string function. The last type of 
function is one that does not return anything. And  
67:58 - these are known as void functions. Oftentimes, 
these are like the print stack functions that  
68:03 - we created earlier. Simply use to condense large 
amounts of print statements that appear often in  
68:08 - your code. These cannot be set to variables since 
they don't return anything, and just get the code  
68:14 - that's within them run through. So there you have 
it, the four types of functions, ones that taking  
68:20 - arguments and return something, ones that take in 
arguments and don't return something. ones that  
68:26 - don't take in arguments, but still return values, 
and ones that take in arguments and don't return  
68:31 - anything. Each of these four types of functions 
are useful and unique in their own way. And you  
68:36 - will probably find yourself using each of them 
through your programming journey. So get used to  
68:41 - the different types of functions and know how to 
make the most of them, as they are all extremely  
68:45 - powerful. Finally, I'd like to talk about one of 
the major benefits of functions, which is that  
68:50 - it makes it super useful to make large changes 
to your code without having to go through the  
68:55 - entire program. Each function call is essentially 
just a copy of that functions original code. And  
69:01 - so it's very easy to make changes to that initial 
function, and have it translate across your entire  
69:06 - code. Let's go back to our print stats function 
and say that you wanted to go back and add in a  
69:11 - new statistic that the player could level up and 
through experience in the game. Without functions,  
69:17 - you'd have to go back into your code and find 
every instance that you'd printed out the user  
69:21 - stats and create another print statement 
to display the new statistic. However,  
69:26 - if you had created a print stats function like 
we did just a while ago, all you would need to  
69:32 - do is find out where you define that function and 
add in a print statement, which displays the new  
69:37 - statistic and you're done. Now every place which 
you had previously called the print stats function  
69:42 - will now also print the new statistic as well. 
You can see just how powerful functions can be  
69:49 - if used properly, and we haven't even scratched 
the surface yet. Now, up next, we're going to  
69:55 - cover how we can import other people's functions 
that they've written and use them in our code.  
70:00 - Before we get technical, close your eyes and 
imagine you're trying to build a house. Sure,  
70:04 - you could grow your own trees, chop down your own 
wood, make your own tools and nails and build from  
70:10 - scratch. But why do that when you can simply go to 
your local Home Depot and buy these materials that  
70:15 - others have already made ready for you. That's 
the main idea behind importing functions into  
70:19 - your code. Importing functions allows you to gain 
access to libraries of functions that other people  
70:24 - have already made for you. This is just as useful 
as it sounds. There are so many functions that  
70:30 - are super useful for any given program, that it 
will take you forever to write them all yourself.  
70:34 - Luckily, other people have already done most 
of this for you. In each programming language,  
70:40 - you were able to use an import statement to import 
libraries of functions into your program that you  
70:44 - can use as you write it. A library is simply a 
collection of functions that all have the same  
70:49 - theme, and maybe a math library, a data analysis 
library, a library that was translated text,  
70:55 - or anything you can think of really, there's such 
a variety of libraries for any given language that  
71:01 - most functions you require that are not hyper 
specific to your program can likely be found  
71:05 - at some library. In fact, a good portion of any 
programmers job is looking online for packages,  
71:11 - which can make his or her job easier, instead of 
hand writing functions. Now I can hear you saying,  
71:16 - Wow, that's sick. How do I do it? Well, it's quite 
simple, an import statement. In most languages,  
71:24 - an import statement consists of three parts. The 
library you would like to import from the package  
71:30 - you would like to import from that library, and 
then which class from that package you would  
71:34 - like to use. For example, we can load up the Java 
library. And from there import the util package,  
71:40 - short for utilities. And then from that utilities 
package, import the scanner class, a class which  
71:46 - allows us to read information from the user. A 
package is simply a smaller set of functions and  
71:51 - methods to help differentiate between the 1000s 
of methods contained in a library, and a class is  
71:56 - even more specialized than that. Now, if you don't 
know what specific classes you're going to want to  
72:02 - pull methods from, you can use a start import all 
classes within the package you'd like. However,  
72:08 - it can be beneficial to be more specific, 
and only import the classes you would like,  
72:12 - as it helps with the efficiency of the program in 
the long run. For instance, in Python, the syntax  
72:18 - to import a library is import followed by the 
library name. However, importing an entire library  
72:24 - is more computationally taxing than importing 
specific functions from a library. Imagine you  
72:31 - would only be using the factorial function from 
the Python math library, it would be a waste of  
72:35 - computing power to import the entire library, and 
it would increase the load time for your program.  
72:40 - For smaller programs, this isn't a big deal. 
But it really starts to add up when dealing with  
72:45 - larger projects. Therefore, you would instead use 
from math import factorial, or the Java equivalent  
72:52 - import java dot math dot factorial, and now have 
access to that one math command only. This limits  
72:58 - the functions that you can use. However, it saves 
programming runtime, if you decide you want to use  
73:03 - another function that you hadn't planned for, 
you can always go back and import that too.  
73:07 - Many times. If you try to use a function from a 
common package, and you have not yet imported, the  
73:12 - ID, he will prompt you to do so if you're trying 
to figure out which libraries you want to import,  
73:18 - think of the functions you're going to need in 
your program, perform a simple Google search. And  
73:22 - you will probably run into a package or library 
that already exists in your ID that you can use.  
73:28 - And if you can't, there are ways to download and 
import additional projects to fit your needs. But  
73:34 - what if, after all that you still can't find a 
library that contains the function you're looking  
73:39 - for? Well, that's a perfect segue into what we're 
going to talk about next, which is the basic  
73:43 - structure for writing your own functions. So at 
this point, we've talked about both what functions  
73:50 - are and how we can get some very useful functions 
by importing them through packages. But there are  
73:54 - definitely going to be moments in your programming 
career where you're going to want to make your  
73:58 - own functions because you want one to be made 
specifically to your program in code. Luckily,  
74:03 - making your own functions is extremely simple. 
There are just some basic rules that I want to  
74:08 - cover. Now we've previously used making functions 
as an example. For other topics such as the Player  
74:14 - Stats function from a little bit ago, they were 
extremely abstract and didn't go into depth  
74:19 - into what is needed for an actual function to 
operate. So right now, we're going to be covering  
74:23 - a skeletal system of everything that needs to 
be included in a function in order to get it to  
74:28 - work. Now think back to the four different types 
of functions that we talked about previously,  
74:32 - functions that do and don't return values 
and functions that both do and don't take  
74:37 - in arguments. For creating your own functions. 
We're just going to have to go down the list and  
74:42 - talk about how to approach creating each one of 
them. Starting with the most basic of the bunch,  
74:46 - one which takes in no arguments and returns no 
values. Before we start that there are a few  
74:53 - small things I want to note about function naming 
conventions, the variable naming conventions we  
74:58 - talked about previously. also translate over 
to function names. So you can't have two word  
75:03 - functions, and you can't use special characters 
like periods or commas. Generally, you're going  
75:09 - to want to follow the same camel case style, 
which we talked about in the variables video,  
75:13 - which is not capitalizing the first word, but 
capitalizing each word after that. Alright,  
75:19 - so in general, for making functions, each language 
differentiates on how you tell the computer,  
75:23 - that it's actually a function. In Java, you have 
to define the function scope, which is something  
75:29 - you don't really need to know unless you're going 
to become more invested in Java. But basically, it  
75:34 - tells the computer which parts of the code can use 
the function in which type can, for this series,  
75:40 - all of our functions that we make are going to 
be public. From there, you then determine which  
75:45 - type of function it is. So in this case, since 
it won't be returning any variables, we'll just  
75:49 - put void to signify this type of function will 
not be returning anything. Finally, you put the  
75:55 - function name after those two identifiers, along 
with a set of parentheses after it like so, the  
76:00 - parentheses are where your arguments would go, if 
you were making a function that took in arguments.  
76:05 - But since for our first type of function, we're 
not incorporating arguments into this function,  
76:09 - let's just leave those blank. All of that 
is just for Java, Python, on the other hand,  
76:16 - all you have to do is put the word def, short for 
define, and then the function name with a set of  
76:21 - parentheses. So as you can see, each language is 
going to be a little bit different in how you make  
76:26 - functions. But the main thing we want to remember 
is to always add parentheses. From there, we just  
76:32 - have what we want our void function to do within 
the confines of the function and close it off,  
76:37 - and we're done. In Java, the confines of the loop 
would be whatever is contained within the curly  
76:42 - braces. And in Python, it would be until you are 
no longer indented. At its core, this is the most  
76:48 - primitive type of function, we've made. Something 
which takes in no arguments and returns no values,  
76:53 - quite similar to the print stats function from 
early on. Moving on to the next type of function,  
76:59 - creating a void function that takes in arguments. 
Now this process is going to seem very similar  
77:04 - to the previous except for one small adjustment. 
Remember the parentheses that I mentioned earlier?  
77:10 - Well, we put any variables, we want the user to 
pass into the function into these parentheses.  
77:15 - And then when we call that specific function, 
it will be required to have those variables  
77:20 - passed into it. For example, in Java, let's make a 
function that takes in two numbers and prints out  
77:26 - the product of those numbers. We start with the 
public void plus name of function setup again,  
77:31 - since we won't be returning any values, and 
here comes a new part. Inside the parentheses,  
77:37 - you define which type of variables you would like 
to pass in as arguments, in this case, an integer  
77:42 - and then a name for that variable. This name is 
what you will use to refer to the integer that the  
77:48 - user passes in. For example, let's just call it 
num one. Then if we want to add another argument,  
77:54 - we simply add a comma in between the two and 
we can make another integer variable num two to  
78:00 - hold the second number. We can do this for however 
many variables we want to pass into the function.  
78:05 - But for now, let's close off the parentheses 
and just print out the product of num one and  
78:10 - number two, as you can see, we refer to the two 
numbers that the user will input into the function  
78:15 - has num one and m two, whatever numbers that the 
user passes into the function will be converted  
78:21 - into num one and m two. Now, whenever we want to 
call the multiply numbers function, we just have  
78:28 - to make sure that we are putting two numbers 
in as arguments. In this case, the number five  
78:33 - becomes num one and the number eight becomes num 
two. From there, we simply run the code and the  
78:38 - number 40 is printed to the console. It's pretty 
important to note that you can also mix and match  
78:43 - variables when making arguments. So you can have 
some function which takes in a car, an integer,  
78:49 - and two strings all within one function. The last 
thing I want to mention about arguments is that  
78:55 - when you call a function, you have to follow the 
variables you defined when making the function. So  
79:00 - for our multiply numbers function, you couldn't 
put in a string and then an int, it has to be  
79:05 - two integers, because that's what the computer is 
expecting to be passed into the function. So now  
79:11 - that we've gone over how to make functions that 
don't return variables, we have to cover those  
79:15 - that do. And we'll start with ones that don't 
take in arguments. Now the main difference between  
79:20 - defining functions that return variables and 
defining ones that do not is that in some cases,  
79:25 - you have to specify that you want this function to 
return an integer variable. This is most common in  
79:30 - Java, where you would replace void with int to 
tell the computer that you want this function  
79:35 - to give you something back to you in the form of 
an integer. This works the same as if you wanted  
79:41 - to return a string care or even in an array. 
You simply replace the word after public with  
79:47 - whatever variable you want to be returned by that 
function. The most important thing to remember  
79:52 - about making functions that return variables is 
that no matter what path your code takes, it must  
79:58 - return a variable no matter What? What does this 
mean? Well, let's say you had some string function  
80:04 - in a game. And inside of it, there was an if 
statement where if the player score was above 10,  
80:08 - you returned a congratulatory message. This works 
fine if you printed the result of this function,  
80:13 - and the player score is above 10. But if the 
player score was less than 10, then you don't  
80:18 - enter the if statement, and then you don't have 
something prepared to be returned to the user.  
80:22 - And so the function is going to throw you an 
error, you have to have all your paths covered,  
80:27 - which may seem simple. But if you're making a 
function with a switch statement in it containing  
80:32 - high amounts of cases, then this can get out of 
hand very quickly. Something I like to do to make  
80:37 - sure this doesn't happen is put a return statement 
at the bottom of a function with a string or an  
80:42 - integer so unique that I'm able to tell that the 
code is not running properly and can fix it. Also,  
80:47 - usually, an ID will let you know if there's a path 
in your code or in a function that does not return  
80:53 - a variable when it should. The main point I'm 
trying to get across however, is always cover your  
80:58 - exits and make sure you have a return statement 
prepared for any case the user may throw at you.  
81:02 - Another small thing to note is that you can't 
return one type of variable if you've already  
81:07 - defined the function to return another type. For 
example, you can't return a string and an integer  
81:12 - function or vice versa. The return statement must 
always match the type of function no matter what  
81:18 - the final type of function is one that returns 
variables and also takes in arguments. And  
81:23 - for these, all you need to do is combine what 
we've learned from the previous cases. First,  
81:28 - you assign your arguments in between the 
parentheses making sure that you've also defined  
81:32 - what type of variable you want to return, and then 
ensure that no matter what path the code takes,  
81:37 - that you're always returning that variable type. 
That concludes our discussion on functions. As you  
81:44 - can probably tell, functions are an extremely vast 
subject area, and require a little bit of practice  
81:49 - to fully understand, which is why later on in this 
series will recommend some websites you can use  
81:53 - to practice those more difficult topics. Now, I'd 
like to switch gears a little bit and continue our  
82:01 - discussion from earlier on arrays. arrays, while 
useful aren't the only way to store and manipulate  
82:07 - information. In fact, there are a multitude of 
different ways to store data in computer science,  
82:13 - including linked lists, stacks, queues, maps, 
trees, and many others to right now though,  
82:21 - I'd like to talk about two cool, wacky and zany 
ways to store data that we haven't previously  
82:27 - covered, array lists and dictionaries. But before 
we get into those, let's get a little review and  
82:33 - reinforcement of arrays. As you may remember, 
arrays are basically lists of values that are  
82:39 - stored together. When you initialize an array, you 
give it a size and this size is fixed, you won't  
82:45 - be able to increase the size of the array. So when 
you make an array of length is final. To access  
82:50 - the values in an array, you reference them using 
an index for starts at zero. What this means is  
82:56 - that the first item of an array is not at position 
one, it is that position zero. And its position is  
83:02 - commonly referred to as its index location. So to 
find the nth item in an array, you would refer to  
83:08 - it as index location n minus one. However, as the 
size of an array is fixed, you have to be careful  
83:15 - to not reference a position that's beyond the 
total size of the array, or to append too many  
83:20 - items to it. As this will return an error. We also 
have what are known as two dimensional arrays,  
83:25 - which is an array containing an array and each of 
its indexes. Or you could have an array containing  
83:30 - arrays containing arrays containing arrays 
containing arrays, depending on what you're trying  
83:35 - to do. multi dimensional arrays can be useful 
in more advanced programs for organizing a wide  
83:39 - volume of related values. If that's confusing 
at all, just get back to earlier for our full  
83:45 - discussion on arrays, the timestamps will be in 
the description. Now that we've reviewed arrays,  
83:50 - let's go over array lists. Array lists are just 
lists in Python can be thought of as a growing  
83:55 - array. Earlier, we mentioned how you have to be 
careful to set an appropriate size of your array,  
84:01 - and to make sure that you only referenced in the 
pin values such that you remain within the size.  
84:05 - However, with array lists, this isn't a problem. 
After you initialize an array list instinctively  
84:12 - has a size of 10. What if you append values, such 
that the size of the array list goes beyond 10  
84:18 - elements, an array list will grow itself, meaning 
that the computer will allocate more memory to  
84:23 - the array to increase its total size so that the 
new values can be appended. This is quite useful  
84:28 - when you don't know the exact number of values 
that the array will need to store. Or you want  
84:33 - the ability to store more values to your heart's 
content. such as when you're making a database  
84:37 - with an unknown amount of users that will sign up. 
There's a lot more to uncover when regarding array  
84:42 - lists. But for this surface level series, that 
is all you pretty much need to know. So let's  
84:46 - move on to dictionaries. Now when we're talking 
about dictionaries, we're not referencing that  
84:51 - thick book you probably have lying around your 
house, which has 1000s of definitions. In computer  
84:56 - science. dictionaries are like arrays in that they 
store multiple values. Use, however, their values  
85:01 - are stored very differently. Rather than being 
referenced by their linear position within the  
85:05 - dictionary, each value is tied to another value 
that is used to reference it, or its key. Because  
85:10 - of this, we need to throw away all conceptions 
of dictionaries as a linear way of looking at  
85:15 - data. Since in actuality, it is much more fluid 
and entertaining. Basically, we say that each  
85:21 - position in a dictionary holds a key value pair. 
When referencing a value in a dictionary, you  
85:27 - will use its unique key, and the dictionary will 
tell you the value that it is tied to think of it  
85:32 - like this. Each time when item to your dictionary, 
your computer creates the handcrafted box to store  
85:38 - the data. And also a custom makes a jewel key one 
of a kind, no other like in the world. This way,  
85:44 - there's only one key that goes to the box 
that stores a certain bit of information.  
85:48 - Because each key must be unique, we're using 
the key in a dictionary, it will result in an  
85:53 - error being thrown. Because having two keys 
that are exactly the same will confuse the  
85:57 - computer as to what box or piece of information 
that key leads to. However, you can store the  
86:03 - same value in multiple key value pairs since the 
keys would all be different. Now, like I said,  
86:08 - dictionaries are more fluid, making them easier 
to organize and then arrays as everything is set  
86:13 - up in a more logical manner. That is to say, 
it is easier to find the value you are looking  
86:18 - for when you're using keys, rather than simply 
referencing their positions. Let me explain what  
86:24 - I mean. Imagine you have a dictionary of prices at 
a store where the key is the name of the product,  
86:28 - and the value is the price of the item. Maybe 
apples cost $1 milk costs $2 and bread costs $3.  
86:35 - You can see the in the dictionary, each key is the 
name of a product, and each value corresponds to  
86:41 - the price of each product. So to find the price 
of bread, all you need to do is simply call the  
86:45 - dictionary using the key bread. This makes it 
extremely easy to track values through your code.  
86:51 - Since you're working with tangible values rather 
than numbers which don't mean anything to you. You  
86:55 - can also manipulate dictionaries and money the 
same way as you can manipulate arrays and array  
87:00 - lists. You can iterate through a dictionary and 
perform many operations and comparisons on the  
87:04 - values. If you want to find the product with 
the highest price for example, you can iterate  
87:09 - through the dictionary to find the value that is 
highest amongst the grocery store items. arrays,  
87:14 - array lists and dictionaries are useful in their 
own right, as are the mass amounts of other ways  
87:19 - to store data, and each boasts certain advantages 
over one another. We already covered the basics of  
87:24 - these three. But since there are so many, we 
don't have time to go in depth into each and  
87:28 - every one of them. And so in order to help you 
grasp the basics of storing information, we're  
87:33 - now going to talk about one of the most important 
functions needed to understand arrays, which are  
87:37 - searching algorithms. Now just as there are many 
ways to store information in computer science,  
87:42 - there are even more ways of searching through 
lists. Searching algorithms at their core are  
87:47 - ways in which we can look through a list of values 
stored in an array, say a patient name list or a  
87:52 - high score list and find a particular piece of 
data. The goal of a searching algorithm is simply  
87:58 - to give the algorithm a string or object you 
want it to find and have it return the index of  
88:02 - the array that contains that string or object as 
fast as possible. Now while this may seem simple,  
88:08 - lots of software runs on the backbone of being 
able to search through lists extremely quickly,  
88:12 - making searching algorithms and in particular, 
efficient searching algorithms an important  
88:18 - topic to cover. Additionally, this is the main 
functionality that arrays are used for. And it's  
88:23 - the backbone of many of the methods used within 
ArrayList as well as many other storage methods.  
88:28 - So knowing them will take you a very long way. 
Typically, searching algorithms are used to return  
88:34 - the index of a particular data points so that 
it can be used, modified or updated or checked  
88:39 - on. For example, if you're about to check into 
a hospital run on an array system for patients,  
88:45 - the staff must search through your name in the 
database. And by returning the index of where  
88:49 - your name is, they now have a quantifiable number 
that they can use to easily check you in, rent out  
88:55 - prescriptions schedule you for checkups, update 
your personal information, etc. Without having to  
89:00 - search through the list for your name every single 
time. You may think that there's little difference  
89:05 - between searching algorithms since computers 
nowadays can perform millions of calculations  
89:09 - per second. But when you're a huge multi billion 
dollar corporation trying to find a certain data  
89:14 - point in a list containing 1000s, or even millions 
of data points, small differences in efficiency  
89:20 - are going to make or break the user experience. 
Even a 1% improvement in efficiency can mean a big  
89:26 - differences in the amount of time that a user is 
waiting for a simple task. Now before we jump into  
89:31 - different types of searching algorithms, we must 
discern between the two states that a razor list  
89:36 - can be in either sorted or unsorted. A sorted 
list of information is characterized by some  
89:42 - sort of rankl value, whether that be a patient ID, 
credit card number, or even by alphabetical values  
89:49 - like usernames or legal names. An unsorted list is 
just some random assortment of related information  
89:55 - not sorted by any particular order or reason. Some 
searching algorithms only work for sorted lists,  
90:01 - usually the more efficient ones, and some work 
for both sorted and unsorted lists. Although these  
90:08 - are usually less efficient if you end up pursuing 
computer science further, you'll have to deal with  
90:12 - both sorted and unsorted lists. So it's good to 
know a common searching practice for both. Another  
90:19 - thing to note is that we determine the efficiency 
of searching algorithms, based on both the worst  
90:23 - case scenario and the average number of items 
that must search in order to find the index. We  
90:28 - call this big O notation in which each searching 
algorithm has an equation which takes in the size  
90:33 - of the array as an integer and, and will output a 
worst case scenario efficiency value that we can  
90:39 - use to compare with other searching algorithms. 
We can then also look at how long on average it  
90:45 - takes to find an element in a list. Using these 
two methods allows us to easily compare how  
90:50 - efficient two algorithms are. Alright, now that 
we've got some background on searching algorithms,  
90:55 - let's hop right into it. The first type of search 
we'll be talking about is called a linear search.  
91:00 - And Eve honestly probably uses multiple times 
throughout your life. Every time you have to  
91:05 - search for your name on a list of people, you 
probably follow the same pattern, you start at  
91:09 - the top check to see if the first name on the list 
is yours. If it is great. If not, you move on to  
91:15 - the next name on the list until either you find 
your name or you don't in which case you leave.  
91:19 - A linear search works in the same way, you start 
with the first element in the list compared to the  
91:25 - value that you're trying to find. And if they're 
the same, you found your match and you return the  
91:29 - index of that element. And if not, you move on 
to the next element in the list until you either  
91:34 - find the thing you're searching for, or you run 
out of lists to check. Pretty simple, right? This  
91:40 - is because linear searches are pretty bad when 
it comes to efficiency, especially in the worst  
91:44 - case scenario. If the item you're searching for in 
the list is the last element, you're going to have  
91:49 - to check the entire list of items before you find 
the one you're searching for. On average, however,  
91:55 - you're going to get it about halfway through the 
list. This makes the linear search oven worst case  
92:00 - scenario since in the worst possible case, it will 
take the entire length of the array or n to find  
92:06 - the correct value. But linear search on average 
will return the correct index in O of n divided by  
92:11 - two. We're halfway through the list. Now while the 
linear search is in great, it can work with both  
92:17 - sorted and unsorted lists, because of the fact 
that it will eventually cover every element in  
92:23 - the list. The other search we're going to cover 
requires the list to be sorted, which may seem  
92:28 - like a drawback, but having a sorted list allows 
you to use algorithms that are far more efficient  
92:33 - than the linear search. So overall, the linear 
search is a good basic searching algorithm for  
92:38 - if you have an unsorted list. But if your list is 
sorted, there are way more efficient options out  
92:42 - there for you, such as the binary search, which 
we'll be talking about now. The binary search uses  
92:48 - a recursive process to break the data in your list 
down into more and more manageable bites. Taking  
92:54 - advantage of the fact that it's sorted in order to 
find the item you're looking for faster. This one  
92:58 - is much harder to wrap your head around. So let's 
start with an example. Let's say you have a list  
93:04 - of 10 names sorted alphabetically, like shown on 
the screen now, and you want it to find your name  
93:09 - within that list. in binary search, you would look 
for the middle most name, in this case, the one at  
93:15 - the fourth index. Just a quick aside, since there 
is no true middle since the list is 10 names long,  
93:21 - the computer automatically uses the next one 
down as the middle value. Now, once you find your  
93:28 - middle value, you first check to see if the name 
you're searching for at the index you've chosen is  
93:33 - the name that you're looking for. If it is you 
simply return that index. But 99% of the time  
93:40 - it's not going to be including right now. So let's 
keep going. If the value at the middle name is not  
93:47 - equal to the one you're searching for, you check 
to see if the value you're searching for comes  
93:52 - before or after the middle index. For example, 
if you were looking for the name Brandon, and  
93:57 - the value at the middle index was Carl, Brandon 
obviously comes before Carl alphabetically. And  
94:04 - since we know that the list is sorted, what we 
can now do is ignore the entire bottom half of the  
94:10 - list and just focus on the top. Since we know that 
if Brendon is even in the list, it's going to be  
94:15 - in that top half. Now we simply treat the top half 
of the list as an entirely new entity and repeat  
94:21 - the process over again. Again, we would find the 
middle most element of this new list of names and  
94:27 - again compared to the name you're trying to find. 
If it's the name we're trying to find we return  
94:32 - that index, but if not, we compare it to see if it 
comes before or after the middle index. Going back  
94:38 - to our example. Let's say the middle index of this 
new list is AJ. Now we know that Brennan comes  
94:44 - after AJ alphabetically. So what we can now do 
is ignore the top half of the list. Since we know  
94:49 - that if Brennan is in the list, it's not going 
to be in the top half of our list. Now we again  
94:55 - repeat this process again and again until we find 
the name we are looking for. So if For example,  
95:00 - the middle index is time is Brenden. And that's 
what we're searching for. So finally, we would  
95:05 - return the index to in binary search. Eventually, 
the index we were compared to our search term  
95:11 - will be the same. And once it is we can return the 
index and move on. Now if we don't find it, which  
95:17 - happens after we have eliminated the entirety 
of the list without finding our search term,  
95:21 - the algorithm will simply return a null value to 
let you know that the item you're searching for  
95:26 - cannot be found in the list. The binary search 
is way faster and more efficient than a linear  
95:32 - search. Since we are drastically cutting down the 
amount of elements, we have to look at making the  
95:37 - program run faster. In almost 99.9% of cases, in 
which your list is sorted, the binary search it's  
95:44 - going to return a result faster than the linear 
search. So if you have a sorted list, your best  
95:49 - option is to go for binary. As for efficiency, 
the binary search is O log n for the worst case  
95:56 - scenario, which could be confusing if you don't 
fully understand logarithms. But all you need to  
96:01 - know is that it is way more efficient than the 
linear search. Its average scenario is actually  
96:06 - also o log n as well, which again, is infinitely 
times more efficient than linear cases. Now while  
96:14 - there are other types of searching algorithms you 
can use, these two are the most common for both  
96:18 - unsorted and sorted lists. So we will stop there 
for now. Up next, we're going to be covering one  
96:23 - of the most confusing and important topics in 
computer science recursion. Let's start with  
96:31 - the most important question, what exactly does 
recursion mean? in programming recursion refers  
96:37 - to functions that repeatedly call themselves 
meaning that any instructions that occur within  
96:41 - a function, one of the instructions will be a call 
to that same function you're already in. In the  
96:47 - extremely primitive example, on your screen. 
Now, you can see we have some function which,  
96:50 - in the confines of itself, calls itself, a 
recursive function will usually take into account  
96:56 - some integer as an argument. And we'll use this to 
carry out some instructions, modifying the integer  
97:01 - that was entered before calling itself again 
with a new integer as its argument. To better  
97:06 - understand these functions, let's discuss the 
basics of how we go about programming one of them.  
97:10 - A really good and easy example of a recursive 
function is one which sums up all numbers from  
97:16 - one to n. So let's make a recursive function 
that does just that. The first thing we need  
97:20 - is the actual function. And we're going to make 
it an integer function, which takes an integer  
97:25 - and as its argument, the reason we do this will be 
explained later. But for now, let's move on to the  
97:30 - base case. A base case is simply a definite value, 
which all recursive statements are the ones that  
97:35 - are being repeatedly called as we go through the 
function tried to get towards at the beginning of  
97:40 - the function, we test the value that was passed 
in by the argument against the base case to see  
97:44 - if it is satisfied. Usually, these base cases are 
some requirements like of n as I described before,  
97:49 - which has a certain value or is equal to a 
certain value, it is extremely important that  
97:55 - the base case is set to some requirement that and 
will eventually meet for the same reason that it  
98:01 - is important to avoid an infinite loop. We do not 
want a Stack Overflow error to occur. For example,  
98:08 - if our base case, what's the stop calling the 
recursive function when n was greater than 100.  
98:12 - And if it is not, we will call the same function 
again. But with n minus one. And we started with  
98:17 - ns, say 99, we would never reach the base case 
and the recursive functional or purely call itself  
98:23 - over and over again, subtracting one from n and 
hoping that somehow it will eventually be greater  
98:29 - than 100 until your computer crashes. Not fun. 
So anyways, back to our recursive some example,  
98:36 - let's make our base case when n is less than 
or equal to one. This way when you start at  
98:41 - some positive integer and and subtract from 
it until it is less than or equal to one,  
98:46 - in which case we can exit the recursive statement. 
Cool. Now, if n is not less than or equal to one,  
98:54 - what we want to do is return the sum of both n 
and then the returning value of our recursive sum  
99:01 - method minus one. Why do we add and the function 
call? Well, let's actually go through the function  
99:08 - as if we were at the computer and see why we start 
with a call of recursive sum with n equals three,  
99:14 - we know that three is not less than or equal to 
one. So now we tried to return a recursive sum  
99:21 - of n, which is three and the returning value of 
recursive sum within n of two. We don't know what  
99:28 - the returning value of recursive sum with an N 
of two is. So we have to go through the function  
99:33 - again, only this time and is two again, and is not 
less than or equal to one. And so this function  
99:42 - will go through the lF statement and return to 
plus another recursive statement, in this case,  
99:47 - the returning value of recursive sum with an 
N of one. So once again, we have to go through  
99:54 - the recursive sum function to get that value that 
will be added to two and then returned and added  
99:59 - to three And then returned, hang in there, we're 
close now in this function, and is less than or  
100:07 - equal to one, and so we return n, which is 
one. Now we take that n, which again is one,  
100:15 - and that is what gets added to to the previous 
function call, and then return. So this would  
100:21 - return three. Now, this three is what gets added 
to the first function call, which is three, and  
100:27 - so it becomes three plus three, which is six. And 
finally, after all that time, we get six return  
100:35 - from the function, which if you've been following 
along at home, three plus two plus one is indeed  
100:41 - six. Now this may seem like a waste of time, since 
three plus two plus one is not a hard operation.  
100:48 - But those of you saying that I asked you to please 
give me a sum of all the numbers from one to 3567.  
100:54 - Godspeed. Now recursion is a very difficult 
concept to wrap your head around. So if you're  
101:00 - not 100% comfortable with it at the moment, feel 
free to rewatch this section of the video in order  
101:06 - to better familiarize yourself with it. Alright, 
cool. Now that we have a little background on  
101:12 - recursion, let's talk about why it works so well. 
Now to understand why and how recursion works,  
101:17 - we must first understand what a stack is. A stack 
is a data structure that contains all of the tasks  
101:23 - you instruct your program to complete. Based on a 
certain method, your program will then carry out  
101:29 - the tasks you give it is called a stack. Because 
if we start another process before the previous  
101:34 - one completes, the process is stacked on top 
of the other one, such as the animation on your  
101:39 - screen is showing now, programs we write will 
follow the LIFO structure. For those unfamiliar  
101:46 - with accounting LIFO means lastin. First out, or 
the last item put on the stack will be the first  
101:52 - one removed from it. Essentially, every time you 
ask your computer to complete a task, that task is  
101:58 - added to the stack, and will be the first one to 
be resolved. Think of it like a stack of stones,  
102:03 - you can keep adding stones on top of your pile. 
But in order to get to the one at the bottom,  
102:08 - you must first remove all the rocks on top of 
it. Now when your functions continually cause  
102:13 - itself without end, without a base case, like in 
our infinite loop example, then this stack will  
102:18 - never be resolved, as items will be continually 
added to the stack without any of them ever been  
102:24 - completed. In this case, the memory allocated 
to the stack exceeds the maximum allowed and  
102:30 - a Stack Overflow error occurs resulting in your 
program crashing. Think of this as if you're doing  
102:37 - chores. And before you complete one chore, you 
get called to do another chore. And then before  
102:42 - you can complete that one, you get called to do 
another one. Since you keep stacking tasks, or  
102:47 - shores on top of one another, the stack of tasks 
will never be completed. And you will probably  
102:52 - die before ever finishing all of your chores. 
This is the same logic that makes infinite loops  
102:58 - crash your program. recursion works on these same 
principles. The initial call makes a second call,  
103:04 - which is added to the stack. And now that one 
must be taken care of first. But in that one,  
103:09 - another function is called which gets added to 
the stack, and so on until you reach the base  
103:15 - case and what you slowly start going back down 
the stack. In conclusion, recursion in general  
103:21 - is extremely useful, because by calling the same 
functions repeatedly, it breaks down the problem  
103:26 - into smaller sections, and results in the program 
being more efficient. small parts of problems are  
103:32 - easier to solve and less taxing to compute than 
the entire problem at once. And the computer can  
103:38 - combine these small solutions into the whole 
solution at the end. Now as we wind down our  
103:44 - introduction to programming series, we want to 
take some time and go over some of the soft skills  
103:47 - needed to be successful computer scientists. 
Since it's not all about writing code. In fact,  
103:53 - many professional computer scientists will tell 
you that the majority of their job is spent  
103:57 - thinking about code rather than actually writing 
it. This is because much of programming boils  
104:02 - down to problem solving. How do we optimize the 
system? How can we make this feature for our app?  
104:07 - What type of movement Do we want for our game? 
And how can we program it? The harsh truth is  
104:12 - that no good program has ever been written simply 
from the programmer, getting the prompter idea,  
104:17 - sitting down, hopping on an ID and starting to 
write code. There are many tasks we should go  
104:23 - through beforehand in order to plan out our code. 
So we ensure that when the time comes to program,  
104:27 - it's a clean and easy process and not riddled with 
mistakes and bugs. This is where pseudocode comes  
104:33 - into play. Think of pseudocode like this, if you 
wanted to take a family trip to the Grand Canyon,  
104:38 - would you simply hop in your car and drive off and 
figure out things later? No, because that would be  
104:44 - ridiculous. Instead, you would spend some time 
planning out the trip. What sites or places do  
104:49 - you want to visit? What hotel reservations are you 
going to have to make? What kinds of things are  
104:53 - you going to do when you get there? What routes 
or highways are you going to take and why? All  
104:57 - of these things must be determined before you can 
even think about hopping in your Ford Explorer.  
105:01 - So how does this translate to pseudocode? 
Well think of our family trip to the Grand  
105:06 - Canyon as a program, programmers use pseudocode 
pseudo meaning not real, and code, meaning code  
105:12 - as a means to plan out their programs before they 
write them. Just like how we planned out our trip  
105:18 - before going. They throw away syntax and naming 
conventions for variables and just focus on what  
105:23 - they want the program to accomplish, and how they 
plan on doing that. pseudocode is very similar to  
105:29 - constructing an outline for a paper that you're 
writing, you write down the main topics of the  
105:33 - essay, and plan out your major talking points. 
But you don't worry about the nitty gritty  
105:37 - details of it all, such as word choice, grammar, 
conventions, and proper formatting. By doing this,  
105:43 - we allow ourselves to think freely and not worry 
about stressing the small stuff, at least not  
105:47 - yet. Alright, now that we know what pseudocode is, 
let's talk about how we write pseudocode. You see,  
105:53 - the best part about pseudocode is that it can 
take the form of many different things for many  
105:57 - different people. Each computer scientist 
has their own methodology for planning out  
106:02 - their code. And there are probably hundreds of 
different methods of writing pseudocode that  
106:05 - are out there today. Today, however, I'd like to 
focus on three popular ones that I think you might  
106:10 - find to be extremely useful. The first of these 
is known as flowcharts. And mainly they can be  
106:16 - used to think through the process of a particular 
function. a flowchart is fundamentally a graphical  
106:21 - representation of a function and how it might 
flow. Many programmers do this and lay out the  
106:27 - conditional statements and loops that they want 
as different blocks in the flow chart connected  
106:31 - by arrows and charting out every path of their 
function. From there, it's extremely easy to  
106:36 - create test cases and follow them through the flow 
of the function through the different blocks and  
106:40 - arrows. For example, we could have a flow chart 
that goes something like this, a user enters in  
106:46 - a number, and if the number is eight, I want the 
program to return true. However, if the number is  
106:52 - not eight, then I want it to return false. It's a 
great way to visualize what the functions overall  
106:57 - purpose is, and also look for any errors that you 
may have missed when thinking about the function,  
107:02 - such as a missing path. It also abstracts the 
programming statements up to simple blocks,  
107:07 - making it easier to modify or change completely. 
The best part is that when you have finished  
107:12 - testing cases, you can simply convert the blocks 
into programming statements, and you have a well  
107:18 - written function without any debugging. Another 
popular pseudocode technique that is often used  
107:23 - is to simply write out what you want your code 
to do chronologically. don't necessarily think  
107:28 - about what programming statements and functions 
you want to use. just jot down from start to  
107:33 - finish what it is the program you're writing 
is going to do step by step. For example,  
107:38 - let's say you're making an app that takes in two 
numbers and divides them. The pseudocode for that  
107:43 - would look a little something like this. First, 
I want to prompt the user to enter a number. And  
107:48 - then I want to wait for the user to enter in that 
first number. After I get the first number, I want  
107:54 - to again prompt the user to input a second number. 
Once they do, I complete the operation by defining  
108:00 - the two numbers entered and returning the result 
back to the user. This all seems like it would be  
108:05 - common sense. But remember that oftentimes, we're 
not going to be working with simple multiplication  
108:09 - or division functions. We may be working with full 
scale games, algorithms or user interfaces with  
108:15 - many different options. This method allows you 
the programmer to not get bogged down with the  
108:21 - syntax and conventions that you have to follow, 
you're simply making a note of what the program's  
108:25 - ultimate goal should be, as if you were explaining 
it to a friend of yours. This method really lets  
108:30 - you plan out everything that needs to happen in 
your program in order for it to run smoothly.  
108:34 - It also ensures you don't forget about a piece of 
an algorithm or a certain function that you need  
108:40 - to write in afterwards. And the final pseudocode 
strategy that I'd like to talk about to you today  
108:45 - is writing out the main features you want the 
user to have when using your program, and what  
108:50 - functions or smaller programs, you're going to 
need to complete these features. Let's do another  
108:55 - example. Say you're making a banking interface. 
And on startup, you want the user to initially  
109:00 - have two options, they can set up a new account, 
or log into an existing account. From there,  
109:07 - if they log into their account, then you want 
them to have the functionality to withdraw money,  
109:11 - deposit money, take out a loan or pay back a 
loan. If they decide to set up a new account,  
109:16 - you want them to be able to create an account, 
store their information in a database, and then  
109:21 - access all of the features that are returning 
member would have. This may look very similar  
109:26 - to the flow chart method. The only difference 
being that this is abstracted one level higher  
109:31 - over an entire program, rather than just a single 
function. If you really wanted to, you could also  
109:37 - create a flowchart that would go through the 
functionality of all the four methods described  
109:41 - above. Setting up a hierarchy like seeing on your 
screen now makes it easy and clear to see every  
109:47 - function interface you're going to have to make. 
This prevents you from having to try to shoehorn  
109:51 - a function or feature into an already finished 
program at the last second, which is not a very  
109:57 - fun experience in the slightest. So There you have 
it three pseudocode strategies you can use to plan  
110:03 - out your code before you even start writing any 
the flowchart method, which is good for thinking  
110:08 - through the flow of a certain function. The write 
up method, which is good for getting the general  
110:12 - idea down for a program, or the functionality 
planning method, good for listing out the  
110:17 - functions of a certain programs, you can use 
all of them, none of them are a mixture of them,  
110:22 - or even disregard these and find and create your 
own pseudocode methods. The main goal here is  
110:27 - to drastically minimize the amount of errors that 
occurred during your program and relieve a lot of  
110:31 - stress on your head. The importance of pseudocode 
cannot be stressed enough. And if you don't  
110:36 - believe me, I urge you to try to complete a large 
project without it. Okay, so if you've watched the  
110:43 - series up until this point, you've gotten a pretty 
good understanding of many aspects of programming,  
110:48 - and also how to plan out your programs. Now it's 
time to go out into the real world and write some  
110:54 - actual code. But what kind of program I can hear 
you asking me? And the answer is truly whatever  
111:00 - you want, really, as I'm sure you know, by now, 
you can program just about anything you have on  
111:05 - your mind. Anything from simple games to complex 
software. This video has equipped you with the  
111:10 - basics that are going to need to be used in pretty 
much any program you decide to write. But that  
111:15 - doesn't mean that every programming language is 
perfect for every application. Each language has  
111:20 - its own strengths and weaknesses. and choosing the 
right one is very important for making it easier,  
111:25 - and sometimes just even possible for you to 
program what you want. So that's what we're  
111:30 - going to be talking about now, choosing the best 
language for what you want to accomplish. Now,  
111:35 - we talked earlier about low level versus high 
level programming languages. In case you forgot,  
111:41 - let's do a quick refresher. higher level 
programming languages have a higher level  
111:45 - of abstraction from machine language, that 
series of zeros and ones from way back when,  
111:49 - while lower level programming languages have a 
low level of abstraction for machine language.  
111:55 - For example, block program where you can drag 
and drop programming statements together like  
112:00 - 2d Legos would be a high level language, as it 
does not take a high level of understanding of  
112:05 - the inner workings of a computer to programming. 
The theoretical highest level of a programming  
112:10 - language would be if I could just write down what 
I wanted the computer to do in Simple English,  
112:15 - and it would just work. But sadly, that doesn't 
exist yet. On the other side of the spectrum,  
112:22 - the lowest level programming language would be 
just feeding zeros and ones into the computer at  
112:27 - supersonic speed, which would be almost impossible 
and extremely absurd. So how do you choose  
112:33 - what type of language is best for your needs? 
Well, it depends on what you are trying to do,  
112:38 - as sometimes you need very specialized languages 
to get done what you want. The world of computer  
112:44 - science is vast and contains many fields. So 
trying to cover everything in one language would  
112:49 - be impossible. This has led to the creation of 
hundreds of different programming languages, each  
112:54 - designed for a specific task. Right now though, 
we'll cover some of the most popular languages  
112:59 - and their uses. Now, if you are trying to design a 
website, using HTML and CSS is probably your best  
113:06 - bet. HTML is a markup language that is designed 
for writing the content of a website. While CSS is  
113:13 - great for designing the style of the website. you 
interact with HTML every day. And you can even see  
113:18 - it right now. If you right click and hit Inspect 
Element. This will truly show you how complex HTML  
113:24 - and CSS can be. Maybe it would be best for you to 
use a scripting language. A scripting language is  
113:30 - a language that has many commands for you to use. 
And that can also be run without needing to be  
113:34 - compiled. Scripts can be faster to write in most 
programs, and tend to be easier to port between  
113:40 - operating systems allowing for cross platform 
support. Scripts can also be used with websites,  
113:46 - oftentimes adding to the overall user experience 
of the site. If you want to go into web design,  
113:52 - this might also be a path for you to go down. 
Examples of scripting languages are Perl, PHP,  
113:57 - Ajax, and JavaScript. For most programs, you 
could probably use a general purpose language.  
114:04 - General Purpose languages, as they sound 
have a wide range of applications. Usually,  
114:10 - these should be your go to languages. Examples 
of general purpose languages are Java, c++,  
114:17 - and Python. They each have their own different 
benefits over one another. Java is very useful  
114:23 - for developing games and interactive web pages. 
Python can act as a scripting language for web  
114:28 - programming, as well as writing applications 
and data analysis. And c++ tends to be used for  
114:33 - writing applications and system programs. They all 
have a variety of packages that you can import and  
114:39 - use to achieve the functionality you need from 
them. while selecting the right general purpose  
114:43 - language for your big projects is very important. 
For most of your programs, any one of them will  
114:48 - work. It really comes down to preference. Get to 
know each language and decide which ones syntax  
114:54 - rules you like best and find most comfortable. 
If you get to know one general purpose language  
114:58 - really well and enjoy programming with it, you 
can apply it to just about any of the programs  
115:03 - you plan on writing. Personally, I tend to use 
Python for most of my projects. This is mostly  
115:07 - not due to any functional difference between 
Python and any other general purpose language,  
115:12 - though there are a few, but it is mainly because 
I find it syntax rules most convenient and easiest  
115:18 - to write programs with. Overall, either you 
can consider the product you plan on doing and  
115:23 - research and see which language boasts the most 
advantages for your purposes. Or you can simply  
115:28 - become comfortable with a language and use it for 
most of the programs you decide to write. will now  
115:35 - be looking at our final topic of this introduction 
to programming miniseries, you now have the basic  
115:41 - knowledge of programming, which will take you 
far in any language that you decide to learn,  
115:45 - you know, some good pre programming pseudocode 
strategies to help you design your code from  
115:49 - the ground up. And you might already have a good 
idea as to the type of programming language you  
115:54 - might want to start with. So what's the next 
step? How can I learn that language? And what  
115:58 - applications can it be used for? Well, that's 
what we're going to be covering now. So let's  
116:03 - just jump right into it. Starting with the biggest 
question, which is what is the next step? Well,  
116:08 - now that you might know which type of language 
you might be interested in, research that language  
116:13 - and find out whether or not you truly want to 
pursue that programming language. Most languages  
116:18 - like Python or c++ will have either an official 
website where you can read up on the language,  
116:23 - or Wikipedia page, which will provide you with 
useful information in deciding whether or not  
116:28 - you want to pursue that path. From there, the 
next step is to actually learn the language,  
116:32 - which can be done right here on YouTube. While 
we've taught you the basics of any programming  
116:37 - language, each specific language is going to 
expand upon these concepts. And so watching  
116:42 - tutorial videos on a certain language is going 
to be very beneficial. I would start with an  
116:47 - introduction series, like the one you're currently 
watching both for the language you've chosen and  
116:52 - work your way through that series, picking up on 
the syntax and rules of that language until you  
116:57 - become comfortable with it. Once you do that, you 
come to a crossroads. You know how to program in  
117:03 - a certain language, but you may be completely 
clueless as to what to make in that language.  
117:07 - Programmers blog can leave you uninspired and 
not want to continue programming. So I'd like  
117:12 - to give you a few websites to help out. First 
is coding bat, a completely free website which  
117:18 - has hundreds of coding challenges in both Java and 
Python to help you refine your programming skills,  
117:23 - and even learn some new programming shortcuts and 
tips. This is great if you want to get better at  
117:29 - improving your efficiency and need something to 
hone your skills as a developer. The next is coder  
117:35 - bite, which offers over 200 plus challenges that 
you can complete in over 10 different languages,  
117:39 - something that is sure to help you improve. The 
final website I'd like to talk about is hacker  
117:44 - rank, which not only provides programming 
challenges to keep you on your toes,  
117:48 - but also provides support for you using your 
programming skills to find jobs or internships.  
117:53 - These and many more websites exists solely to 
keep you interested in code and work on refining  
117:58 - your skills to become better. Now if you're a 
teenager watching this series in high school,  
118:03 - I also encourage you to take programming 
classes in your high school. AP Computer  
118:07 - science principles and AP Computer Science a are 
both amazing courses which can help you greatly  
118:12 - in the future, and are also incredibly informative 
and important to colleges. Your school might also  
118:18 - offer other classes in the field of computer 
science, including ones on key data structures,  
118:22 - game design, and data science. Any and all classes 
you can take to help expand your knowledge of  
118:28 - programming and help you find your niche is going 
to be extremely helpful. As you can see, the world  
118:34 - of code has now been opened up to you. These are 
just a few examples of where you can go from here.  
118:39 - But there are many more we didn't talk about. You 
could get into GitHub and start contributing to  
118:43 - projects. You could work on your own projects 
and collaborate with others. The possibilities  
118:48 - are endless. The next step is up to you. This 
concludes our introduction to programming mini  
118:53 - series. We hope you enjoyed watching it as 
much as we enjoyed making it. If you enjoyed  
118:58 - the series as a whole consider subscribing to 
our channel, no pointer exception, which will  
119:03 - be linked in the description for more content like 
this coming soon. Thank you so much for watching.

Cleaned transcript:

Welcome to Introduction to programming. My name is Steven in my name is Shawn. Over the next 90 minutes, we'll be taking you through this series consisting of 21 different segments that hope to cover the basics of computer programming, which can apply to any and all programming languages you might want to learn. We'll be starting with the simplest question of what is programming. And from there, we will be working our way up as we talk about common features of computer science such as loops and arrays, we'll discuss how to read and write code, debug code that you've written some strategies to help you plan out your code and much, much more. The complete list of topics that are going to be covered in this lecture style video are shown on the screen. Now, additionally, there will be timestamps in the description, so feel free to skip around. If you're already proficient in some areas of computer science, or just want to know about a specific topic we will be covering. Hopefully, by the end of the series, you'll have a basic understanding of what computer science is, along with an armory of useful skills that will help you unravel whichever programming language you decide to learn. First, we'll only be covering the major key points that apply to all programming languages. So we'll be shying away from topics such as object oriented coding, and command line navigation, as those are things which are language specific. Additionally, there will be no software required for you to download in order to follow along with this tutorial, as we won't be writing any code in an ID to keep things simple and concentrated. This video is meant for those who are interested in computer science and programming but have no idea where to start and have little to no background information on coding. And so if that sounds like you, then strap in, as Shawn and I work our way through the wacky world of computer science, starting with the biggest question probably on your mind, which is what even is programming? Well, the dictionary defines it as the process of preparing an instructional program for a device. But that's a really confusing definition. So in layman's terms, what exactly does that mean? Essentially, it is attempting to get a computer to complete a specific task without making mistakes. Imagine this for example, you want your less than intelligent friend to build a Lego set, except he has lost the instructions and can only build based on your commands. Remember, though, your friend is far from competent. And so if they are not given very specific instructions on how to build the set, there are many mistakes that they could make. If he thinks like a computer, then if there's even one piece that you have not told him specifically where to place and how to place it, the entire Lego set will be ruined, and you will be left to suffer a complete mental breakdown, causing the whole goal of the project to be corrupted. giving instructions to your friend is very similar to how programmers code. Instead of a less than intelligent friend, you have a less than intelligent computer. And instead of instructions on how to build a Lego set, we are feeding information on how to complete a program like a game or a web application. And an important thing to note is that computers are actually very dumb. We built them up to be this super sophisticated piece of technology, when in actuality, a computer's main functionality comes from how we manipulate it to serve our needs. Now, programming isn't as simple as giving your friend instructions. Since in a programmers case, the computer doesn't speak the same language as you. The computer only understands machine code, which is a numerical language known as binary that is designed so that the computer can quickly read it and carry out instructions. Every instruction fed to the computer is converted into a string of ones and zeros and then interpreted by the computer to carry out a task. Going back to the Lego example, this process wouldn't be like if he was not only less than intelligent. But to make matters worse, he could not understand English and only speaks in Mandarin Chinese. In order to speak with him, you have to convert the instructions that you understand in English into the language that your friend understand. This process is essentially what you must do for your computer in order to make it understand the instructions that you give. The big difference between the two examples, however, is that it is very difficult for people to understand machine code in binary. Directly translating what you want the computer to do into machine code is extremely difficult, in fact, almost impossible, and will take a very long time to do it if you could. Each program is composed of millions upon millions of those ones and zeros. So how exactly are we supposed to translate our instructions into machine code. This is where programming languages come into play. programming languages are fundamentally a middleman for translating a program into machine code. These languages are much easier for humans to learn than machine code, and thus are very useful for programmers. Going back to our Lego example, a programming language would sort of be like an interpreter that's able to take the instructions you give them in English and translate them into instructions your non English speaking friend can understand. This makes programming languages extremely useful and the backbone of any good program. Think of programming languages as not English and not machine code, but somewhere in the middle. There are many different programming languages out there that each have their own unique uses. languages such as Python and Java, are just general purpose languages that can perform a variety of computational tasks, or robots C or HTML or CSS, or languages designed for more specific purposes, such as moving a robot or constructing a website. languages can also vary and how powerful they are. For instance, JavaScript is a scripting language that is designed for smaller tasks, or Java or Python can carry out much more computationally taxing processes. We can measure a programming languages power, or level by how similar it is to machine code, the series of zeros and ones we talked about earlier. low level programming languages, such as assembly, or C, are closer to binary than a high level programming language, such as Java or Python. The basic idea is that the lower the level of your programming language, the more your code will resemble what the machine can interpret as instructions. Aside from the different purposes that each language fulfills, choosing a language typically comes down to a matter of preference, as are usually many languages that can accomplish similar tasks. Try different languages, and decide which ones rules interface and level of simplification you like best? So now that we know what programming is, how do we actually write code? It sounds like we can simply type words into a text document and automatically assume that the computer can translate it into machine code, read it and carry out a task like opening up a browser. And additionally, we can't just write down rubbish in certain programming languages mentioned in the previous segment, and expect the computer to understand. So how are we supposed to write code then? Well, the answer is with an ID. And ID, which stands for integrated development environment allows the facilitation of code by a computer. It is provide a graphic interface on your computer in which the programmer can easily write, run and debug code without having to worry about problems with complication or interpretation of the program. Think of an ID is any other program on your computer, such as a game browser, or even the file explorer, except we'll be using it to write code, IDs are able to turn your code into machine code and run it through the computer to produce results. In addition to providing a place for programmers to develop their code IDs provide some extremely useful tools for programmers to ease the job of writing code, such as built in error checking, because as we'll talk about later, code doesn't always run correctly. Auto filling for frequently used words or phrases, and a project hierarchy, which will help you organize and manipulate the files within your project. Back in the olden days before IDs code used to be written on punch cards and then fed into computers, which would take hours and cause a lot of pain. IDs nowadays act as sort of a fast track to writing code and make things a whole lot easier for programmers. An example of a specific ID can be seen on your screen now. In the center, you can see the program that is currently being written. And right below it is the console, which can print out useful information for the programmer. This specific ID is used to write Java code. IDs are extremely powerful and will be used in almost 100% of your programming projects. So through these IDs, we are finally able to write and compile code smoothly without worrying about the computer not being able to understand it. The next problem we run into then becomes how do we write this code in the ID. Because it's not like we can just type random words from a certain programming language and expect the computer to understand this is where a programming languages syntax comes into play. Now, just as if you were learning a real language, learning a computer language can be very similar. Some have different styles that may seem odd. Some may make you use weird or abstract concepts which may be confusing. And like all languages, programming languages have a set of rules that you must follow when writing code in that language. And at the forefront of those rules is grammar. Programming grammar is referred to as syntax and is very similar to real world grammar. Each programming language has its own syntax or rules that you have to follow to a tee if you want your program to run correctly, just as if you were speaking in real life. These can be things such as how you type out certain functions, what you put at the end of the line of code, and how you set up certain functions. Each language is unique in its syntax, and while some may share similar rules, all will have some quirk which makes it stand out from the rest. syntax is something that catches a lot of people off guard since many expect every programming language to follow the same set of rules. But as we spoke about in the last segment, because each language is specialized for a specific task, each needs its own set of rules to function. Breaking or disregarding these rules will result in an error. Just how breaking or disregarding rules in real life will result in an unintended message. As an example, if you wanted to do something simple, such as initialize a variable, which is something that we haven't covered yet, but the example is still relevant. In Java, you'll notice how we have to specify what type of variable we're defining, in this case an integer and also add a semi colon after the statement. In Python, we don't even need to define that we are trying to create a variable and just have to type what we want to create. And in JavaScript, we just specify that we are making a variable, but we don't include what type of variable we want to make like in Java. Even in this simple example, you can see how much a syntax matters when learning a new language. Since while the goal of our program remained the same, which was to define an integer with the value three, all the programming languages shown took different approaches. All these languages require that you follow this syntax because remember, computers are extremely dumb. If you forget one semi colon or misplace a character, the entire program will not run and send you back a syntax error, which is something we'll talk about later. Think of this as if you forget a comma in a sentence and the entire context of what you're trying to say gets misinterpreted. For example, in the sentence, let's eat grandma. If you were to forget that comma. While it may seem like a small mistake, it changes the entire context of the sentence, making it sound like you're going to eat your grandma. The same rules follow for programming. If you forget a semi colon, the entire context of your program can be corrupted and misinterpreted by the ID. Now another thing which makes it so useful is that they will let you know if and when there are syntax errors in your code. syntax errors, of course, being parts of your code, which do not follow the same rules where we talked about previously, the ID will tell you where in your code the errors, and also won't let you run your program until the error has been fixed. Because of how important syntax is to writing code and learning a new language. It's recommended that you learn the rules and syntax of a language before beginning to write complex programs in that language. Most of the rules are tedious to learn but easy to master. And as soon as you can do that, you'll be able to easily identify syntax errors and take care of them easily and be writing code in no time. That covers the basic gist of syntax and programming rules. So now that we know how to write code and where to write code, we next need to cover what happens after we have typed out our program and run our code. Because writing a piece of code for a game or for a database is cool and all. But after the computer interprets the program, how will we know what's happening and whether or not is working? Well, programmers do this by looking at the console. The console is a text interface within your computer that us programmers can use for a variety of different purposes. If you remember, a short while ago, we heard a picture of a basic ID. And one of the main parts of the picture was the console. The main use of the console is to output text from the program. This is usually done by using a print statement. A print statement is a command that does exactly what it sounds like. It prints text to the console. The print statement is the first piece of actual code we've talked about in this series. And it's about as simple as the print statement. Despite its simplicity is one of the most important functions in programming and exists in some form in just about every programming language. The most basic thing you can ask the print statement to do is to just simply make it Say something. This is done by instructing the console to print, and then include wherever you want to be printed inside the parentheses. For example, in Python, the segment of code print hello world will cause a message reading HelloWorld to appear onto the console. Pretty neat. The print statement is also vital for viewing interpreting the computer's output from program. For instance, if you could tell a computer to run a simple calculation. For example, to determine what four plus three is, they will run the program internally and compute an answer. However, what is the purpose of having the computer run this program if you will not be able to tell what the result is, instead of simply telling the computer to perform this calculation, instruct the computer to print the output of the program to the console, and upon the program's completion, seven will appear on the console. As you can see, the console allows us to easily print information out to the developer for a variety of uses. It is important to note that the print statement varies depending on the programming language being used. For example, in Java, there are multiple versions of the print statement depending upon whether you would like a line break after the printed text or not, as well as specialized print statements which make your code run more efficiently. Also, the general syntax of using a print statement and certain nuances of its function contains between languages. However, you can generally rely on it to carry out the same overall function as it is a foundational statement for programming in general. All of its functionality makes a print statement along with the console and very useful developer tool. However, it is important to remember that that is all it is the developer tool. The console is not really meant to be viewed by the end user of your program. It tends to be hidden away behind the scenes and other methods of displaying information, such as displaying text, graphics, or images are used to convey information to the user instead, think of it like this. When you're using your phone, you see the console and none of the programs you use. So while you can use the console to give yourself information about how your program is performing, don't try to implement it in the final product because it fundamentally just isn't meant for that. Overall, remember to use the console to its fullest extent when writing and fixing problems in your programs, as it is a great tool to use to tell how your program is performing behind the scenes. So now that we know a bunch of information about programming languages, and how and where to write them, along with the print statement under our belts, let's go over some intuitive things that the computer can do all by itself without you having to tell it how To. More specifically, we'll be covering some basic number mathematics as well as string math. Starting off with basic mathematics, the computer already knows how to do simple arithmetic. This includes addition, subtraction, multiplication, and division, all of which are represented by the symbol shown on the screen now, in any ID that you may install, you'll be able to print out the answer to simple math problems using the print statement. Which may seem counterintuitive, because why would you use the computer to do math when you have a perfectly good calculator on your phone. But you have to remember that computers are dumb. And anything we want a computer to do, we have to build up from scratch. basic arithmetic, while simple helps out in almost any program you may write. For example, if we wanted to build a basic calculator app, we need to utilize this functionality in order to correctly display the answer to an arithmetic problem when our user tries to add, subtract, multiply or divide two numbers. Now in addition to the four basic math equations, most programming languages include an additional operator known as modulus. If this is your first time hearing this word, don't worry, since it's not usually taught in math classes. modulus allows us to get the remainder of a divisional operation. For example, when we take 10 modulus three, we're essentially telling the computer to take 10 divided by three, ignore the actual answer and just give us the remainder of the operation. In this case, one, since when we divide 10 by one, the answer is three remainder one. The one in this case is what gets printed out to the console. If there is no remainder, say in the case that we take 50 modulus two, since the remainder is zero, the function would return zero if we were to print it out to the console. This can be extremely useful. In many cases, the most obvious being if we want to determine whether or not a certain integer is even or odd. If we take a certain number, modulus two, and it returns zero, then we know that is even because any number divided by two will always result in a full answer without a remainder. But if the system returns one, then we know that the integer is odd, you will find yourself using the basic math operators a lot more than you think. So it's good to keep them in mind when running your program. Now, not only can our computer work with numbers, but it can also work with strings. strings, by the way, are just another way to say text. For example, hello world is a string, the letter A is a string, and anything enclosed by quotation marks is denoted as a string in programming languages. We'll cover more about strings in a bit when we talk about variables. But for now, let's continue. We already talked about printing strings to the console. But let's say we're making a game and we wanted to print out the statement, game over for was your final score. Now while we could just make a string that says that exact phrase and print it out to the console, in some cases, it would be more useful to print out the actual integer value, especially in the case of a game where the score can change each time you play. Because score definitely isn't always going to be for. Well, we're also able to print out multiple strings of text and even integers by adding them together in the print statement. This is known as concatenation. Continuing with our score example, if we wanted to print out the statement gameover for was your final score, using four as an integer rather than a string. We could do this by breaking down the statement into two strings and an integer like so. Print game over plus four plus was your final score. We of course begin with a print statement, which again will be different across all languages. But in this case, we're using Python. Inside the print statement, we start off by printing the string game over. Now here comes the important part. From there, we use a plus sign and add four to the print statement. Just like if you were adding two numbers, then we can repeat this process with another plus sign for the final string was your final score. And we're able to print out the entirety of our statement easily. Doing this we can easily print out multiple different strings and integers together in one print statement. We could also combine the two lessons we've learned thus far and do something such as game over plus four plus four plus was your final score. In the case, let's say where you have a game which gives you a base score and then four points for a certain task that you complete it. This demonstration also displays Another important part of programming, which is that oftentimes to get your program to be the most efficient, you have to combine aspects of code. Now it's important to note that the computer will take whatever you put in the parentheses and print it out character for character. So oftentimes programmers will forget to add a space onto the end of their strings. This can result in a small mistake in which the string from the previous example would be printed out as if to say gameover four was your final score, which isn't that appealing when displayed on the screen to the user. So it's a good practice to always put a space after and before your strings to make sure this doesn't happen, and your string doesn't end up like that. Another important thing to note is the difference between four in quotation marks, and four without quotation marks. Now for in quotation marks is treated as a string, rather than a four without quotation marks, which is treated as a number. This may not seem like a big deal, but again, computers are dumb. And if you try to do math with a number in quotation marks, it will return an error. Because the computer doesn't understand that you're trying to perform the operation on a number and thinks you're trying to add an integer to a string, which is a big no no in programming when you're adding numbers. So when you're programming, make sure to make a mental note of whether or not you want to make something an integer or string, because that type of stuff makes a big difference. All right, that concludes our segment on the base power of computers. Now Next up, we're going to be covering one of the most important components of computer science. So make sure you pay attention because next up we're going to be discussing variables, what they are and how we use them. First of all, what exactly is a variable? A variable is simply something that can store information and can be referenced and manipulated. Think of variables like a cardboard box. cardboard boxes, servers means to store items in them, which can be changed that replaced and modified variables are like cardboard boxes to store information for the programmer to reference or manipulate. each variable simply has a type, a name, and a piece of information stored inside of it. The type and piece of information will be covered next, and the name is simply a name for the variable. Think of it as writing out a label on the cardboard box in Sharpie. Now there are many different types of variables that a programmer can use, or right now, we will just be covering what are called primitive variables, which include integers, Boolean, floats, and doubles, strings, and characters. We'll start off by talking about an integer. An integer or int for short, is as simple as it sounds, a variable that can store an integer value. This includes all whole numbers from negative 2,147,483,648 to 2,147,483,648. Notice how I said whole numbers, integer values can not and will not hold any decimal values. So keep that in mind when using variables. Secondly is a Boolean. A Boolean is very primitive variable which can store a value of either true or false. Boolean variables can only hold these two values, and are extremely useful for conditional statements, which we will cover soon. The next few types of variables are floats and doubles. Both of these variable types are floating point data types, which essentially means that these variables can store numbers with decimal places. Whereas integers values cannot hold decimal values, floats and doubles can. The main difference between the two is that a float variable can store numbers of our precision up to 32 bit. All doubles can store numbers with a precision up to 64 bit. Essentially, a double can store more decimal places than a float. So it all comes down to how precise you want the variable to be. Up. Next, we have string variables, which are like the strings we've talked about beforehand, except store somewhere in a value. String variables can store strings of letters, which are just words and sentences. Strings are useful for displaying text and storing input information. Strings can also be concatenated together to form combinations of string variables and pre written strings. This can be very useful for outputting information in a readable format for the user. For example, imagine we have a string called name. The code asked for input and storage that string of text and name. To output this information to the user. Rather than simply displaying their name, you can add the phrase Your name is and make it into a sentence by concatenating. Your name is plus a name plus a period. This makes it easier to read your code, while also adding variability to your code, which always makes things more interesting for the end user. Finally, we have char variables. char stands for character, and just as a name suggests, they can each hold one character. This is useful when a programmer wants to read one button press or one character in a string without using a string variable. a specific example is being a game that is controlled by the keyboard, the program needs to recognize the character that is pressed and translate that into carrying out some function. Now strings can also hold one character, but chars can hold more than one character. So keep that in mind when defining variables. Now, why are variables so useful? Well, being able to store information in a format that can be easily referenced later is essential for any good program. Oftentimes, in code, you're going to want to keep track of things such as a user's name, or score. And so by creating a variable called name or score, you store this information in the variable and then reference it, add to it or modify it. Also, many times to program will want to take input from the user, which cannot be pre programmed into the code, and thus the variables required to store the information. A program may also rely on factors that will change as the program progresses, in which case a variable is once again required. Also, taking these variables and manipulating them is quite necessary for carrying out many of the tasks you want to program to carry out. For instance, multiplying in variables or concatenating string variables. Overall variables are the backbone of any program, and you'll find yourself using them often if you want to clean and efficient code. So it's best that you learn what types of variables you need to use and when. So now that we know all about the different variable types, and we've talked about them a little bit, we're going to delve further into what happens when we actually define or create a variable, how we reference them, and how we can manipulate them for our programs. To start, let's go over what happens when we actually define a variable. Now when we write a line of code, which initializes a variable, and that code is executed, the computer essentially creates a little space in memory that stores your variable name and its contents so that it can be referenced later. Going back to our cardboard box example from the previous segment. Think of this as if you had your own storage facility, and you make a new cardboard box labeled name. And inside of it, you put a piece of paper with the word no pointer exception on it. Now, anytime you want to know the contents of your name box, you could simply look inside and see that it has the contents no pointer exception. This is what the computer does, except the storage facility is the memory in your computer. The box is a variable and the contents of the box or whatever the variable is set to be equal to. Anytime you want to know the contents of the name variable, you can simply call it and the computer will pull the information that is stored in that variable, and use it how the user see fits. Another thing to note really quickly is that you can actually make a variable without putting information inside of it. This would simply be like if you built up a new cardboard box, gave it a label with a sharpie, but just didn't put information inside of it. You're simply saving that space in your storage facility for later. This can be maybe because you want to store information in it later down the road. Or if you're going to use it to store information given to you by the user, in which case you can't give it information since you don't know what the user will input. Just to note that if you try to reference or point to a variable, which does not have any information in it, you'll get what's known as a null pointer exception, which despite being an amazing name for a YouTube channel is something you generally want to avoid when programming. Now programming languages allow us to do some pretty cool things with these boxes that we've created. For example, let's say we created a second variable called channel name. And instead of setting it equal to no pointer exception, we instead set it equal to our already created named variable. This doesn't create a space in memory for this new variable. However, it simply points to the same location of memory we have already created for the name variable. Going back to our storage facility example, this would be like instead of creating a whole new box label channel name and storing sheet of paper with the word no pointer exception on it, we instead simply added another label below the name box, and titled channel name. Now we have two variables which point to the same contents, that being the string no pointer exception, we usually do this to save space in our code for things that we know are going to have the same value. variables can also be updated throughout your code. For example, let's say you had an age variable, and inside of it was the integer 17. Then you celebrated a birthday and wanted to update your age, all you would have to do is reference the variable and set it equal to whatever new integer you want the variable to hold. In this case, 18. This would be the same as having a box labeled age with a sheet of paper eating 17 inside of it, and then taking that piece of paper out, erasing 17, replacing it with 18 and then placing it back in the box. Doing this we are able to easily update the contents of our variables throughout the code as things dynamically shift. As another example, if you were making an RPG, your character would likely have stats such as attack, defense manner, etc. As the game progressed, you could continuously update the variables so that the player could get more powerful, the further along they went through the game. And you wouldn't have to create new variables, you would simply need to just keep grabbing that box from your storage facility, erasing and replacing the numbers on the piece of paper and then continue along with your code. Just keep in mind that these variables are nothing more than places in memory in which a certain value is stored. So we can easily update the numbers and their place will remain constant. After the code has run its course the place in memory is deleted until you run the code again, and the program dedicated space for the variable again, each time you run the code, you're making new boxes in your storage facility. And at the end of the code, you destroy them all to make room for the new boxes next time. Another cool thing you can do with integer float and double variables is add them subtract them, divide them, multiply them and even modulus them. For example, if you're making a calculator app and you store the first number, the user entered as number one and the second as number two. You could then multiply num one and num two together and either print them or store them in a new variable entitled result. Then each time you run the program, the user could input new numbers into the number one and number two variables. And they would simply be set to those new integers that the user inputted and return the result that correspond Through those specific numbers, this allows you to keep easy track of which numbers are which, and what's going on in your program, which is extremely useful. Also, while you cannot subtract, multiply, divide or take the modulus of strings, you are able to add them. Like we said previously, let's say you had a string str one with the contents Hello, and a string str two with the contents there, you could add str one and str two to create a string that had the contents Hello there, either storing it in a third variable or printing it out to the console. The last topic we'll be covering on the topic of variables is the naming conventions of variables, which will be it may seem odd, but it's extremely important when trying to read your code. So we'll be covering it now. Now variables have to be one continuous string. And so if you wanted to make a variable that store the player score, you'd have to find some way to combine the words player and score. Since you can't have the phrase player score be the name of a variable. All programmers have their own personal preference when it comes to naming variables. But the one we'll be using in this lecture is called camelcase, which is the process of not capitalizing the first word, but capitalizing every word that follows it. Going back to the player score example, using the camel case method, the variable would be called player score. This allows us to easily see and identify each word and becomes really useful for long variable names, like the player score before the final boss. Whereas if we just type it out without camelcase, it would be really confusing and hard to read. This will help you out a ton when we start finding bugs in our code and need to quickly scan through our program to figure out what is wrong and adds to the overall readability of the program. Other programmers might use different naming conventions like using underscores to separate the words in a phrase. But for now, and this series, we'll be sticking with camel case. Next, we'll be moving on to conditional statements, which at their core, are statements that change the path of our code depending on certain conditions. For the sake of keeping things simple for this section, where Atlanta will connote that our code will not be following the specific path. In Greenland's I mean, our code is following the path. The main type of conditional statement that programmers use is the if statement, and this will show up countless amount of times in any program you write. It is as simple as it sounds, if some condition is true, and usually that condition will be enclosed by braces, then carry out the instructions located within the if statements brackets, else do another thing. Now, brackets are used in most programming languages to indicate a segment of code which will run it works like this. If the condition in parentheses is true, then all of the code contained within the brackets will run. And if the condition within the parentheses is not true, then it will skip over all the statements within the brackets. A quick note is that while this is the case, with most programming languages, some, like Python, use columns and whitespace to determine where a piece of code starts and ends. But for the sake of this series, we'll be using curly braces. Now, the condition within the parentheses can take on 1000s of different forms, such as if the value of the string variable name is equal to Steven, or if the player score stored in an int variable is greater than five. The list goes on and on. Each of these statements is evaluated as a Boolean, which you will remember from when we talked about variables is either true or false. If the Boolean is true, we run the code inside the curly braces. If it's not, we pretend everything inside the curly braces never existed, and move on with our code. The if statement comes with two more additional statements that go with it elsif and eltons. elsif is a conditional statement used directly after an if statement, and carries out mainly the same function as an if statement. However, the elsif statement will only be evaluated if the proceeding F or the preceding elsif statement is bypassed due to its condition being false. So we will run through it like so. If something is true, we will run the code inside of that statements curly braces out if that's something is not true. But another statement inside of the parentheses is true, we would then run that code segment. And if neither of them are true, we would skip both segments of code and move on in our program. This can be a hard concept to wrap your head around to so let's do an example. If we had a program that evaluated the if statement, if age is equal to 10, we then have a statement under that which stated outs if age is equal to 12. Now, if the age variable was 10, which we can see from the example that it is, then the code immediately following that conditional statement in the brackets would run. The Ultra statement we made will not even be tested. Since we know that it is going to be false. And thus the print statement inside of that conditional statements brackets will be ignored, and the code will move on to the rest of the program. Now for example, let's say we change the age variable to be 12 instead of 10. Now instead of the first conditional statement being true, it actually evaluates as false since age is no longer equal to 10. So what we do now is first skip over the print statement, which prints out that ages 10 and does not. And then we evaluate the elsif statement, we check if age is equal to 12, which again it is. And so now we run all the code inside of that conditional statement before finally moving on to the rest of our program. So as a review, we check the initial if statement. If it's good, then we run all the code within that if statements curly brackets and move on with our program. If the initial if statement is not true, we then move on to any elsif statements and evaluate if those conditional statements are true. We can have as many elsif statements as we want, although this could lead to clutter amongst your code. So we'll talk about some alternatives later to help us out. Now that takes care of the FL statement. So now we'll move on to the else statement. The out statement, once again, it comes after an IF or an elsif statement, and we'll carry out its instructions no matter what. As long as the proceeding statement slash statements are evaluated as false. If we went back to our previous program, we could add an elf statement, which would only have the code in his brackets run at the age variable wasn't 10, or 12. This will catch all cases of the program that didn't fit into our parameters. It's good practice to always have another statement at the end of your conditional statements to catch any weird cases that may come up in your program. Now remember back to the fact that we could have 1000s of Elif statements after a while that can get pretty cluttered. And so another very useful conditional statement helps circumnavigate this problem is a switch statement. A switch statement is functionally similar to many if and else statements together, you write a switch statement in the form of switch variable. And then below that you write out how many cases the variable can be. For instance, if we wrote switch var, and then under read write out five cases that the variable var could be and then the instructions listed under each case would be carried out if the var variable it would be equal to that case. Now switch statements are different sets. Instead of using brackets, they use a column to signify the start of a set of instructions and a break statement to end them. This is very useful, because you are able to essentially use many if and else if statements without having to write nearly as much. In switch statements, you just always have to remember to include default case at the bottom of the expression to denote any and all cases that don't meet the above requirements. There simply catches all the inputs that don't fit within the program's main cases. It's very similar to just case the end of an if else chain. Now, why are these statements so useful? Well, many times programmers want their programs to function differently depending on different conditions. For instance, a program could function differently depending on the information that the user inputs, such as allowing user to use a program or not user program if they are above or below 18 years old, respectively. Or in say, a video game. If the user experiences above a certain threshold, you might want to give them harder opponents to battle. Another example could be a program was changing the color scheme depending on the time of day. Or even more simply, if a user presses a button that is meant to move on to another screen in an app, the programmer would only want that app to change screens if the user clicks that button. A program without conditional statements would do the same thing every time, and would be very primitive compared to one that can change depending on its conditions. So now that we know how to make and use variables, how to compare them, and what we can do with those comparisons, let's move on to another foundational concept of computer science. And that is arrays. Now we've already talked about variables, and how great they are for storing singular bits of information for making our code more simplistic. But one of the biggest drawbacks that comes with variables is their inability to hold more than one piece of different information. For example, let's say you're making an app which allows a user to create a grocery list. Well, there's no real easy way to create lists using variables. Because it's not like you can have one variable store the names of six or seven different food items. Remember, we can only put one piece of paper in our cardboard box no more. And besides, even if you were able to add multiple items to one string variable, you would still have a lot of trouble doing simple tasks you might want from a list such as searching through it, splitting it or even deleting items from the list when you're done with them. This is the problem that using arrays solves for us. An array is as you may have guessed by now, a list, you can have an array of integers, an array of strings, and even an array of other arrays, which is something we'll cover in a minute. Programmers use arrays when they want to store a lot of variables containing information that is all related to each other, such as a grocery list or a high score list in the game. Think of arrays as a column in Excel or Google Sheets. Here the title at the top and then below it are a bunch of bits of information, which all relate back to the title. Arrays are super useful when programmers want to store a lot of information that can be easily searched through because programmers have developed methods of breaking down and using arrays to find specific information in arrays full of 1000s of different variables. As an example to show just how useful arrays are. Let's say you're a startup company that owns an app that has 100,000 users. Every time a user wants to create a new account, they input the username they want and then your program will have to check to make sure the account name hasn't already been taken. Doing this requires you to search through the information of all 100,000 of your users to see if that username has an account with your service and array would be able to get Pain all of this information and make it easy to search through and find out if the account name has already been taken with little to no delay. Now, the single most important thing to note about arrays is how you reference each element of the array within them. Let's create a basic array called numbers and inside of it, put the digits one through 10. Now, when we want to refer to each cell in his array, we would call upon its index. an index is just a fancy way of saying that numbers placed within the array. Now you would think that the first integer in this array would be the first index, the second would be the second index and so on. But that's simply not the case. In computer science, programming languages refer to the first cell as zero with element in the array. This means that if we were talking about our array of numbers we just made, the number four would actually be in the third index, five would be in the fourth, and so on. So instead of starting our count from one, we start from zero. It's extremely weird and confusing, but it's one of those programming quirks, you're going to have to memorize and commit to memory. If you were to not follow this nomenclature, and refer to the last element in this array as the 10th, you get what is referred to as an array out of bounds error, since you're trying to reference the 10th element, but there is no 10th element, where you're actually trying to do is reference the ninth element. Another extremely important thing to note about arrays has to do with their size. When you initialize an array, you can do it in either one of two ways. You can either populate it with the elements that you want contained in the array right then in there, creating and filling the array at the same time. Or you can define how many elements you want the array to hold, essentially the array size, and then populate it with elements later. This is because when we initialize an array, it creates a space in memory that has a size of exactly what you give it. no more and no less. This is great for when we want to access elements in the array, because we can do so instantaneously because the computer knows exactly where in memory the array is stored. But the one downside is that we can't increase the size of the array later on. All array sizes are final. Think of this like setting up a bookshelf with books by populating a bookshelf with a certain number of books. And then moving on and filling the next shelf with different books, we have no way to go back and add books to that first shelf without shifting everything over. Once we decide how much space to dedicate for an array, in this case, there's no way to add more space. Once again, because this is extremely important to remember. This means that once an array has been defined, there is no way to change the size of it. If you have an array titled names with a size of eight, and you try to add another name to the array, you will receive an error. So be careful when messing around with array sizes. Of course, you can always go back to the start of your code, when you initially make the array and allocate more space to it, increasing its size. If you find out that you need more space to hold items, but once it's defined, you cannot change its size through conventional methods. Another small thing I want to touch upon really quickly is that when you initialize an array, you must determine which type of array it is right then in there, for example, you have to specifically say it will be an array of strings or integers when defining it. And also you're not allowed to mix and match. Meaning that you can't have an array full of integers with a few strings and some doubles thrown into the mix, they all have to be the same type. Now the last thing we're going to cover on arrays is a little funky. And that is the practice of putting arrays inside of arrays. If you make an array of arrays is referred to as a 2d or two dimensional array. Think of these as matrices if you've taken an algebra class before. Now, if you haven't Think back to our Google Sheets example, but instead of using columns, we would add rows as well. So now each element in an array would simply just be a string variable or an integer variable. But an entirely new array with its own set of values and elements. The way we index these is mostly the same, except we would have two numbers to index instead of one. We start with the row and then the column. So a number in the positions 02 would be in the first row, three columns down, in this case, the name Clint a number in the position one one would be two rows down and to columns across, in this case, the name Chris, you get the idea. Now you can also make three dimensional arrays by putting an array inside of an array inside of an array, but that's a little above what we're going to be covering. So I'm going to cut it off there. Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Next up, we're going to be talking about loops. So what exactly are loops? Well, as you can probably tell by that statement right there. A programming loop is a statement that is used to run certain instructions repeatedly. Just like how the opening statement of this topic was repeated five times. loops are very useful for a variety of reasons. For instance, imagine you want to print something 15 Sure, you could just copy and paste the print statement 15 times, but this is really annoying to have to do, it becomes even more unrealistic when that number goes up to say 100 or so. Now what if instead of rewriting the same instructions over and over again, you would simply place the print statement inside of a loop, and it will occur as many times as you would like. Now that's the power of loops. With loops were able to repeat parts of code multiple times. Now, there are three different types of loops that we will be discussing today. And first is the for a for loop is very useful for situations like the one described above, where you would like to carry out a certain set of instructions numerous times. The syntax for a for loop varies depending on the language, however, it usually consists of three parts an integer value, a condition which the integer value must meet in order to exit the loop, and an operation to modify the integer value at the instructions inside the loop are completed. Each time the for loop runs, the operation you set will be performed on the integer as long as that integer still needs to condition your set, usually being greater than or less than a constant value, the for loop will continue to run. Eventually, when the integer has been modified by either increasing or decreasing it to the point where it no longer meets the condition, the for loop will terminate and the code will continue to run. For example, let's say our integer value was I and we set it equal to zero, then we set the conditional statement as I being less than three. So basically, we're saying that as long as I the variable we just created is less than three, continue running the instructions contained within the loop. Finally, we make the operation i plus plus, meaning each time the loop runs, we increase it by one, and inside of the loop, let's just put a simple print statement. Now let's run through the for loop, we start with i equals 00 is less than three, so we enter the loop and print out hello world. Now that the instructions are done, we add one two, I'm making it one moving on. One is again less than three. So we want to get into the loop and print out hello world. Again, we had one two, I'm making a two now to is still less than three, so enter the loop again and print out hello world. Finally, we add one to it once again, and it becomes three. Three is not less than three though, is equal to three, and so we don't enter the loop and it terminates. Moving on to the next segment of code. This is a simple example. But you can extrapolate it across programming to fit your needs. Now when using a for loop, we have to make sure to set up a condition that given the initial integer value and the operation will at some point not be met to avoid creating an infinite loop and crashing your program. an infinite loop occurs when you give a for loop a condition which will always be met given the parameters of the program. And so software crashes. For example, a for the beginning at 10. And checking if is over less than zero, and then adding one to either the end of the loop will never terminate since I will suggest increase infinitely. After the for loop is the very similar for each loop. A for each loop, or a for in a list loop in Python is used for iterating through arrays or lists. Essentially, the loop will go through each element in the array and carry out some server instructions for each value. If you would like to read all of the elements in an array and compare them to some value, or perform some operation on them, a for each loop is extremely useful. So for example, we could have a for each loop which iterated across an array and simply printed out the value of each array location. Next up we have the while loop. A while loop will continually carry out instructions while a conditional statement given to it is true. This can be as long as a certain variable is true. As long as the numbers that's another number, or while a value is still equal to another value. For example, while loops are different than for loops in that the loop is not contained within one statement but stretched out and will continue to run. As long as this condition is true. Like a for loop, you could make the condition such that it will eventually return false and exit the loop. However, while loops will not crash your computer should you create an infinite loop. In fact, it is very common for wild lips to run infinitely. As for certain programs, you would like the program to continually be iterated through instead of running once all the way through until you exit out of the program. When programming a game for instance, a while loop would be used to iterate through your code, continually refreshing the screen as the game runs. From there you can perform operations on the screen to make the game playable. Creating infinite while loop could be done by simply using the syntax, while true, as the condition true will always be evaluated as true. Finally, I'd quickly like to cover the extension of a while loop the do while loop. Do while loops are very similar to while loops, except they will carry out their instructions at least once even if the condition is false. And then we'll carry on like a basic while loop. Essentially, the conditions inside of the loop will run at least once. And then if the condition is still met, they will run again and function as a normal while loop would. As you can see loops in there many varieties has some extremely useful functions. using them, you're able to perform an operation many times in a row. You can iterate through arrays and lists and overall decrease the clutter of your code. Next up, we're going to be taking a break from learning about common programming statements and dive into what happens when the code we write doesn't work. More specifically, we'll be covering the different types of errors that can occur when you're programming and what causes them. Now when you're writing code, you have to understand that things aren't always going to go the way you expected them to. And sometimes the program doesn't always work as you had intended. too. We programmers call these errors. And while annoying, they're always going to come up in computer science, and so it's best to learn what they are and how to deal with them. Often referred to as bugs, errors and scripting languages can be narrowed down to one of three types, syntax errors, runtime errors, and logic errors, all three of which we'll be covering in today's video. To kick things off, let's talk about syntax errors. These are usually the easiest of the three to solve, since they are oftentimes something that can be fixed within seconds. If you remember back to earlier in the video, when we talked about syntax and programming rules, we said that if you were to break the programming rules or syntax that would result in an error. Well, that's what syntax errors are parts in your program where you fail to meet the programming rules, and so the computer doesn't know how to interpret your code. This can be anything from forgetting a semicolon at the end of a statement in Java, accidentally defining a variable with two words instead of one, or even just misspelling the word string when you're trying to define a string variable. Lucky for you guys, these errors are extremely easy to fix, since you just need to figure out where the error occurred, and what the syntax rule you broke was. Now thinking back to IDs, we mentioned that IDs are so useful because they do precisely that. They underline the syntax errors and usually provide helpful hints as to how to fix them. Think of syntax errors as small misspellings or grammatical errors in an essay you're writing annoying, yes, but not the most infuriating things. Another useful thing about it is when it comes to syntax errors is that the program will actually restrict you from running the code unless all syntax errors are cleared, making them even easier to identify and fix. The second type of error we will be covering is the runtime error. These errors don't show until you actually run the code, hence the name runtime error. runtime errors are usually caused by a statement in your code that seems logically sound, but the computer physically has no way of computing it in a reasonable amount of time. The most common of these errors is one which we've already talked about the infinite loop, as a refresher or an example. Think of an infinite loop like this. Say you set your friend down in front of the TV, put on the office, and told him he could leave as soon as Michael made it. That's what she said joke. Seems pretty simple, right? Wrong, because instead of putting in the office, you put in friends on blu ray. Now, Michael, no inappropriate joke, meaning your friend would be sitting there for the rest of his life. This is basically what happens with a computer, you give it some condition that it has to complete before the program can terminate. However, you give it no feasible way to finish that task. This puts the computer in error mode, and most likely it will crash your program. As the computer desperately tries to complete the condition you gave it. As a computer example, if we try to have a program terminate when integer i is no longer greater than 99. But eyes initially 100 and only ever increases, the loop will never terminate, and the program will crash. To avoid these, you generally want to think through the flow of your code before running it, especially with loops to make sure that all of your statements can be completed by the computer. Carefully planning out your code before you begin writing is an extremely useful practice, and something we'll be covering towards the later part of this video. The final type of error that we'll be covering is a logic error. This error is also pretty self explanatory. A logic error occurs when the code runs smoothly without any runtime or syntax errors. But the result that you get just isn't what you want it. For example, let's say you had a calculator app, and you want it to instruct a program to add two numbers, except it multiplied them because you use the multiplication symbol on accident. This leads to the sum being 36 instead of 13. nothing went wrong with the code syntax or runtime wise, the code runs just fine. It just doesn't work as you had intended it to. These are often the hardest types of errors to debug. Since most of the time, you'll have no idea why the code isn't working, and certainly not any idea of how to fix it. This is why it's a good idea to test your code incrementally. Don't wait until you've been programming for an hour before testing your application. We're all to run into a lot of logic errors. Logic errors can be extremely fury ating, and could cost you a lot of time making them a huge pain. But if you know how to effectively debug your code, you'll be just fine. Speaking of debugging your code that brings us straight into our next topic, which is how to debug your program. Now let's say you've written a program, you think it's ready and you're ready to test. You've been working hard on this and you're just wanting to see it in action. You run the program and wait for it to run smoothly and efficiently. Only it doesn't work. you've encountered one of the three errors we've just mentioned. You really want this code to work but how this is where debugging comes into play. If the code is giving you an error, the first thing you should do is read the error. Oftentimes for syntax and runtime errors, the ID will print an error message out to the console. See what line or lines it points to since those little lines with the occurred, and see if you can understand and fix what the problem is. If the error isn't clear, or you've never heard of it, then try googling it as there are many websites out there. So just Stack Overflow, which service forums to ask an answer problems with code. Chances are, if you've had a problem, someone else has had the same issue and there's likely a tested solution. Usually, when the syntax or runtime error pops up, you should be able to find a fix for it fairly easily. However, as I said before, the issue may arise from some loophole or oversight in the code you hadn't planned for beforehand. Maybe you did something as simple as multiply two variables instead of adding them. These are logic errors we talked about previously, these problems usually won't have red text show up to explain what went wrong, you'll have to figure it out yourself. Now, there are a few different strategies that you can use in order to track down and fix a logic error. First, you could use print statements and the console in order to determine where the code is going wrong. Imagine you have a conditional statement that will run one segment of code if an integer x is greater than five, and it will run another segment of code if not, if in your program. X is supposed to be greater than five when the program reached this conditional, but for some reason, the program is still printing out x is small, you can use a wrench they're meant to help. For this problem. Specifically, you could place the print statement before the branch or the conditional that would print the value of x. Now when you run the program, you know exactly what the computer is thinking, printing out the value of x just before the FL statement. While you know the variable has the value you wanted to have. And if it doesn't, you know that somewhere above that conditional is something went wrong, and x was set to a value you didn't want it to. In this case, x is equal to two, which is why x is small is being printed out. Now that we know what the problem is, we can track down where and when in the code, we modify x in order to solve it. Use print statements to determine where your program goes wrong, and then try to track down the cause of these issues and solve them. If you use this strategy, make sure you end up deleting the print statements afterwards to avoid clutter in the console. The situation described above could also be solved using a breakpoint. a breakpoint pauses your program when the line you placed a breakpoint at is reached. If say you would like to program to run through a certain conditional and set a variable based on that conditional. But you are unsure if this actually happens in your code, you can place a breakpoint inside the conditional path that you expect to run. Upon the breakpoint being reached, the program will pause and wait for you to continue it through a button press. This signals that this button occurred where the breakpoint was placed. In this case, the correct conditional path has been reached by your program. You can then continue the program knowing that this was or wasn't where the error in your code occurred. breakpoints can be used in conjunction with print statements. In order to do both pause the program and perhaps view the values of your variables at the moment in time to give yourself all of the information you could want. You can also have multiple breakpoints to help slowly work your way through your program and determine where an error has occurred. A combination of these two strategies will help you easily determine where in your code you have incurred a logic error. Next, let's go over what to do if you think you have tracked down the section of code that causes the problem. You may think you should delete it, but it's likely you put it there for a reason. And you don't want to lose all that work if you don't have to. Firstly, try commenting it out. Comments are used to markup code and explain their surrounding sections. They can also be used to the bug. Anything that is designated as a comment will not be read by the program as code and will be skipped over. Essentially, it becomes something that is only there for you, the programmer to read. The syntax varies from language to language, but it usually involves placing some symbols before or around the code you would like to be commented, examples of how to comment in different languages can be seen on the screen now. Also, when you comment something, the ID will grayscale that line of code, making it extremely easy to determine what's commented and what's not commenting code deletes it in the computer's eyes without actually deleting it. If a problem is present before you comment a section of code, but it's gone afterwards, then that section of code is the culprit. If you comment part of the code out and there are still issues and move on to another section until you find the culprit. Once you do, you can tweak it until it works as intended or deleted entirely. And you'll have a fully functioning program once again. Now that we've talked about what to do if you've encountered an error, and a strategy on how to find and fix it, I'd like to talk about some strategies you can use to avoid errors in the first place. Firstly, backup your code frequently. In the event of the code completely bugging out and you being unable to fix it, you will want the ability to revert to a previous version where the code was still working. If you save frequently enough, you will probably not lose too much work. Version managers like GitHub or subversion can help with this as they backup code to an online cloud service, which you can easily pull previous versions of the program from at any point. Also on top of saving, running your program frequently to ensure that the current version works as intended. This accomplishes two things. First of all, it prevents you from saving a backup that doesn't work second If you encounter a problem, it will be easier to find if you have only made a small number of changes since the last time you ran it, and it worked. And thus, you will only have to look through the new code for problems. If you've spent five hours coding and hadn't run it during that time period, it's going to be likely that at some point, during that five hour code session, you messed up, and it's going to be even harder to figure out where you went wrong. errors, while annoying and extremely frustrating, are a fundamental part of making you a better programmer. Alright, now that we've covered errors for a bit, let's hop back onto the programming statement train and talk about one of the most important concepts in computer science, they'll function. Now, you may not know it, but we've actually been talking about a few functions, this entire series, print statements for loops. And even the basic math operations we've talked about are all examples of functions, which of course, begs the question of what actually defines a function? Well, a function is a segment of code that can be easily run by calling the function name. And depending on the type of function will do something in return. functions can be called numerous times and in numerous places in your code. Essentially, they're like wrapping up a segment of code into a nice present, and giving it a name, which, when called, will unwrap the present and go through the code that you had wrapped up. For example, the print statements we've been using this series allow us to print something to the console anytime we want. Those are functions, you see, we just call the print function and enter in what we want to be printed to the console into the parentheses, and the computer does it for us. Behind the scenes, there's actually even more complex code that is in charge of taking your text and translating it to the console to be printed. The developers of almost all programming languages realize that you don't want to program something that manually has to print something to the console through the use of complex programming. And so they implemented the print statement to reduce the stress and complexity of code on the user, abstracting it to the single line of code that is print. All of that code that is used to print something to the console is wrapped up like a present and given to us in the form of one line. This is actually the main theme of all functions and the backbone of any good program. Oftentimes, in your program, there are going to be sections of code which are repeated and serve the same purpose, or equations, which you want to allow different inputs of. And so you can use functions in order to condense these down into singular lines of code to save both time and reduce clutter on your code. As you will see soon functions are extremely powerful, and will definitely be something you utilize all the time in your computer science journey. The print statement is just one example of functions in everyday code. There are 1000s of functions that are available to you through the IDs. However, because we won't always use all the functions that are available to you in a single program, you have to import these functions from packages found in the ID E, which is something that we'll be covering later on. Now, there are four main types of functions in most programming languages. And they are separated by two defining features, whether or not they take in arguments and whether or not they return values. Let's start by separating them by whether or not they take arguments. But first we have to cover what arguments actually are. arguments are essentially variables that we pass into the function in order to be manipulated, and then either returned back to us printed to the console or used in another operation. Think of functions with arguments like this. If you walked up to your local Five Guys, and told them that you wanted to get food without supplying a type of food, they would probably look at you confused. In order to get the food that you want, you need to tell them exactly what you want to order so that they can give it to you. In this case, getting food is the function and what you order in terms of food is being passed in as the argument based on what you tell them or the argument that you pass into the get food function, they will do something different. You should also note that the argument can be many different things. It could be fries, burgers, sodas, really anything on the menu, and such as the case with arguments in programming. Arguments can be strings, integers, arrays, pretty much anything. As an example of a function that takes in arguments, let's look at the max function, which takes in two integers as arguments and returns the maximum number between the two. Now for this function, if you don't input two numbers or variables for it to compare, it's going to throw you an error. Just like the five guys employee. He doesn't know what you want to eat Since you didn't provide him with any arguments. And the computer doesn't know which two numbers you want it to compare and return Since you didn't provide it with two integers. arguments are a way for programmers to have one function that can do many different things depending on whichever variables can be passed through arguments, add variability to programming and can help diversify your code. Think of it like this, a restaurant that only allows one type of food to be made regardless of what you order isn't going to be very useful or diversified but We're able to pass in arguments and tell them what food we want, our experience can be heightened and more options can become available to us, which is exactly what happens when you start using arguments in your function. Now that we've talked about functions that take in arguments, let's move on to functions which do not, because functions can also be created and used without taking arguments in and still be incredibly useful to the programmer. For example, let's say you're making a text based RPG game, and one of the options you give your player is the ability to view their stats at various points throughout the game. Now every time you come upon this option, and they choose the view stats button, you don't have to type out six different print statements for every statistic they may have, your code would get cluttered and messy very quickly. Instead, what you could do is you could package the six different print statements in a simple function called print stats, you don't need to pass in any arguments into the function, since the function will do the same thing no matter what the statistics on the player are. Now, every time the user wants to view their stats, you could simply call the print stats function, and voila, the user stats are printed for them to view. This allows you to save a lot of time writing code, but also a lot of space, which is extremely important when your programs begin getting into hundreds and 1000s of lines of code, and you want to easily search through it to maybe debug. Okay, now that we've separated functions into those that take arguments and those that do not, let's again, split these up into those that return values and those that do not. Another thing you have to understand is that when you're making your own functions, which is something that we'll be covering very soon, you have to choose what your function will return, if anything at all, functions are able to return values back to the user, whether they be in the form of string variables, integer variables, or even arrays. Now, the thing to note about returning variables is that calling the function alone won't do anything, you have to return the value into something or print it out. As an example, the max function we talked about previously would return an integer back to the user. But in order to do something with it, we would have to either set a new integer variable equal to the result of that max function. Or we can print out the result of the function, which in this case, which is print out the maximum value between the two integers. Using functions which returned values don't do much on their own, you have to pair it with something in order to gain the use from it. Let's do another example. Let's say you had created a function which took in two string variables as arguments and combine that using that fancy string that we talked about earlier, and then return them as a singular string. This combined string function could then be used to create new string variables. Since what it returns is basically a string, the variable would simply be set to whatever is returned from this combined string function. The last type of function is one that does not return anything. And these are known as void functions. Oftentimes, these are like the print stack functions that we created earlier. Simply use to condense large amounts of print statements that appear often in your code. These cannot be set to variables since they don't return anything, and just get the code that's within them run through. So there you have it, the four types of functions, ones that taking arguments and return something, ones that take in arguments and don't return something. ones that don't take in arguments, but still return values, and ones that take in arguments and don't return anything. Each of these four types of functions are useful and unique in their own way. And you will probably find yourself using each of them through your programming journey. So get used to the different types of functions and know how to make the most of them, as they are all extremely powerful. Finally, I'd like to talk about one of the major benefits of functions, which is that it makes it super useful to make large changes to your code without having to go through the entire program. Each function call is essentially just a copy of that functions original code. And so it's very easy to make changes to that initial function, and have it translate across your entire code. Let's go back to our print stats function and say that you wanted to go back and add in a new statistic that the player could level up and through experience in the game. Without functions, you'd have to go back into your code and find every instance that you'd printed out the user stats and create another print statement to display the new statistic. However, if you had created a print stats function like we did just a while ago, all you would need to do is find out where you define that function and add in a print statement, which displays the new statistic and you're done. Now every place which you had previously called the print stats function will now also print the new statistic as well. You can see just how powerful functions can be if used properly, and we haven't even scratched the surface yet. Now, up next, we're going to cover how we can import other people's functions that they've written and use them in our code. Before we get technical, close your eyes and imagine you're trying to build a house. Sure, you could grow your own trees, chop down your own wood, make your own tools and nails and build from scratch. But why do that when you can simply go to your local Home Depot and buy these materials that others have already made ready for you. That's the main idea behind importing functions into your code. Importing functions allows you to gain access to libraries of functions that other people have already made for you. This is just as useful as it sounds. There are so many functions that are super useful for any given program, that it will take you forever to write them all yourself. Luckily, other people have already done most of this for you. In each programming language, you were able to use an import statement to import libraries of functions into your program that you can use as you write it. A library is simply a collection of functions that all have the same theme, and maybe a math library, a data analysis library, a library that was translated text, or anything you can think of really, there's such a variety of libraries for any given language that most functions you require that are not hyper specific to your program can likely be found at some library. In fact, a good portion of any programmers job is looking online for packages, which can make his or her job easier, instead of hand writing functions. Now I can hear you saying, Wow, that's sick. How do I do it? Well, it's quite simple, an import statement. In most languages, an import statement consists of three parts. The library you would like to import from the package you would like to import from that library, and then which class from that package you would like to use. For example, we can load up the Java library. And from there import the util package, short for utilities. And then from that utilities package, import the scanner class, a class which allows us to read information from the user. A package is simply a smaller set of functions and methods to help differentiate between the 1000s of methods contained in a library, and a class is even more specialized than that. Now, if you don't know what specific classes you're going to want to pull methods from, you can use a start import all classes within the package you'd like. However, it can be beneficial to be more specific, and only import the classes you would like, as it helps with the efficiency of the program in the long run. For instance, in Python, the syntax to import a library is import followed by the library name. However, importing an entire library is more computationally taxing than importing specific functions from a library. Imagine you would only be using the factorial function from the Python math library, it would be a waste of computing power to import the entire library, and it would increase the load time for your program. For smaller programs, this isn't a big deal. But it really starts to add up when dealing with larger projects. Therefore, you would instead use from math import factorial, or the Java equivalent import java dot math dot factorial, and now have access to that one math command only. This limits the functions that you can use. However, it saves programming runtime, if you decide you want to use another function that you hadn't planned for, you can always go back and import that too. Many times. If you try to use a function from a common package, and you have not yet imported, the ID, he will prompt you to do so if you're trying to figure out which libraries you want to import, think of the functions you're going to need in your program, perform a simple Google search. And you will probably run into a package or library that already exists in your ID that you can use. And if you can't, there are ways to download and import additional projects to fit your needs. But what if, after all that you still can't find a library that contains the function you're looking for? Well, that's a perfect segue into what we're going to talk about next, which is the basic structure for writing your own functions. So at this point, we've talked about both what functions are and how we can get some very useful functions by importing them through packages. But there are definitely going to be moments in your programming career where you're going to want to make your own functions because you want one to be made specifically to your program in code. Luckily, making your own functions is extremely simple. There are just some basic rules that I want to cover. Now we've previously used making functions as an example. For other topics such as the Player Stats function from a little bit ago, they were extremely abstract and didn't go into depth into what is needed for an actual function to operate. So right now, we're going to be covering a skeletal system of everything that needs to be included in a function in order to get it to work. Now think back to the four different types of functions that we talked about previously, functions that do and don't return values and functions that both do and don't take in arguments. For creating your own functions. We're just going to have to go down the list and talk about how to approach creating each one of them. Starting with the most basic of the bunch, one which takes in no arguments and returns no values. Before we start that there are a few small things I want to note about function naming conventions, the variable naming conventions we talked about previously. also translate over to function names. So you can't have two word functions, and you can't use special characters like periods or commas. Generally, you're going to want to follow the same camel case style, which we talked about in the variables video, which is not capitalizing the first word, but capitalizing each word after that. Alright, so in general, for making functions, each language differentiates on how you tell the computer, that it's actually a function. In Java, you have to define the function scope, which is something you don't really need to know unless you're going to become more invested in Java. But basically, it tells the computer which parts of the code can use the function in which type can, for this series, all of our functions that we make are going to be public. From there, you then determine which type of function it is. So in this case, since it won't be returning any variables, we'll just put void to signify this type of function will not be returning anything. Finally, you put the function name after those two identifiers, along with a set of parentheses after it like so, the parentheses are where your arguments would go, if you were making a function that took in arguments. But since for our first type of function, we're not incorporating arguments into this function, let's just leave those blank. All of that is just for Java, Python, on the other hand, all you have to do is put the word def, short for define, and then the function name with a set of parentheses. So as you can see, each language is going to be a little bit different in how you make functions. But the main thing we want to remember is to always add parentheses. From there, we just have what we want our void function to do within the confines of the function and close it off, and we're done. In Java, the confines of the loop would be whatever is contained within the curly braces. And in Python, it would be until you are no longer indented. At its core, this is the most primitive type of function, we've made. Something which takes in no arguments and returns no values, quite similar to the print stats function from early on. Moving on to the next type of function, creating a void function that takes in arguments. Now this process is going to seem very similar to the previous except for one small adjustment. Remember the parentheses that I mentioned earlier? Well, we put any variables, we want the user to pass into the function into these parentheses. And then when we call that specific function, it will be required to have those variables passed into it. For example, in Java, let's make a function that takes in two numbers and prints out the product of those numbers. We start with the public void plus name of function setup again, since we won't be returning any values, and here comes a new part. Inside the parentheses, you define which type of variables you would like to pass in as arguments, in this case, an integer and then a name for that variable. This name is what you will use to refer to the integer that the user passes in. For example, let's just call it num one. Then if we want to add another argument, we simply add a comma in between the two and we can make another integer variable num two to hold the second number. We can do this for however many variables we want to pass into the function. But for now, let's close off the parentheses and just print out the product of num one and number two, as you can see, we refer to the two numbers that the user will input into the function has num one and m two, whatever numbers that the user passes into the function will be converted into num one and m two. Now, whenever we want to call the multiply numbers function, we just have to make sure that we are putting two numbers in as arguments. In this case, the number five becomes num one and the number eight becomes num two. From there, we simply run the code and the number 40 is printed to the console. It's pretty important to note that you can also mix and match variables when making arguments. So you can have some function which takes in a car, an integer, and two strings all within one function. The last thing I want to mention about arguments is that when you call a function, you have to follow the variables you defined when making the function. So for our multiply numbers function, you couldn't put in a string and then an int, it has to be two integers, because that's what the computer is expecting to be passed into the function. So now that we've gone over how to make functions that don't return variables, we have to cover those that do. And we'll start with ones that don't take in arguments. Now the main difference between defining functions that return variables and defining ones that do not is that in some cases, you have to specify that you want this function to return an integer variable. This is most common in Java, where you would replace void with int to tell the computer that you want this function to give you something back to you in the form of an integer. This works the same as if you wanted to return a string care or even in an array. You simply replace the word after public with whatever variable you want to be returned by that function. The most important thing to remember about making functions that return variables is that no matter what path your code takes, it must return a variable no matter What? What does this mean? Well, let's say you had some string function in a game. And inside of it, there was an if statement where if the player score was above 10, you returned a congratulatory message. This works fine if you printed the result of this function, and the player score is above 10. But if the player score was less than 10, then you don't enter the if statement, and then you don't have something prepared to be returned to the user. And so the function is going to throw you an error, you have to have all your paths covered, which may seem simple. But if you're making a function with a switch statement in it containing high amounts of cases, then this can get out of hand very quickly. Something I like to do to make sure this doesn't happen is put a return statement at the bottom of a function with a string or an integer so unique that I'm able to tell that the code is not running properly and can fix it. Also, usually, an ID will let you know if there's a path in your code or in a function that does not return a variable when it should. The main point I'm trying to get across however, is always cover your exits and make sure you have a return statement prepared for any case the user may throw at you. Another small thing to note is that you can't return one type of variable if you've already defined the function to return another type. For example, you can't return a string and an integer function or vice versa. The return statement must always match the type of function no matter what the final type of function is one that returns variables and also takes in arguments. And for these, all you need to do is combine what we've learned from the previous cases. First, you assign your arguments in between the parentheses making sure that you've also defined what type of variable you want to return, and then ensure that no matter what path the code takes, that you're always returning that variable type. That concludes our discussion on functions. As you can probably tell, functions are an extremely vast subject area, and require a little bit of practice to fully understand, which is why later on in this series will recommend some websites you can use to practice those more difficult topics. Now, I'd like to switch gears a little bit and continue our discussion from earlier on arrays. arrays, while useful aren't the only way to store and manipulate information. In fact, there are a multitude of different ways to store data in computer science, including linked lists, stacks, queues, maps, trees, and many others to right now though, I'd like to talk about two cool, wacky and zany ways to store data that we haven't previously covered, array lists and dictionaries. But before we get into those, let's get a little review and reinforcement of arrays. As you may remember, arrays are basically lists of values that are stored together. When you initialize an array, you give it a size and this size is fixed, you won't be able to increase the size of the array. So when you make an array of length is final. To access the values in an array, you reference them using an index for starts at zero. What this means is that the first item of an array is not at position one, it is that position zero. And its position is commonly referred to as its index location. So to find the nth item in an array, you would refer to it as index location n minus one. However, as the size of an array is fixed, you have to be careful to not reference a position that's beyond the total size of the array, or to append too many items to it. As this will return an error. We also have what are known as two dimensional arrays, which is an array containing an array and each of its indexes. Or you could have an array containing arrays containing arrays containing arrays containing arrays, depending on what you're trying to do. multi dimensional arrays can be useful in more advanced programs for organizing a wide volume of related values. If that's confusing at all, just get back to earlier for our full discussion on arrays, the timestamps will be in the description. Now that we've reviewed arrays, let's go over array lists. Array lists are just lists in Python can be thought of as a growing array. Earlier, we mentioned how you have to be careful to set an appropriate size of your array, and to make sure that you only referenced in the pin values such that you remain within the size. However, with array lists, this isn't a problem. After you initialize an array list instinctively has a size of 10. What if you append values, such that the size of the array list goes beyond 10 elements, an array list will grow itself, meaning that the computer will allocate more memory to the array to increase its total size so that the new values can be appended. This is quite useful when you don't know the exact number of values that the array will need to store. Or you want the ability to store more values to your heart's content. such as when you're making a database with an unknown amount of users that will sign up. There's a lot more to uncover when regarding array lists. But for this surface level series, that is all you pretty much need to know. So let's move on to dictionaries. Now when we're talking about dictionaries, we're not referencing that thick book you probably have lying around your house, which has 1000s of definitions. In computer science. dictionaries are like arrays in that they store multiple values. Use, however, their values are stored very differently. Rather than being referenced by their linear position within the dictionary, each value is tied to another value that is used to reference it, or its key. Because of this, we need to throw away all conceptions of dictionaries as a linear way of looking at data. Since in actuality, it is much more fluid and entertaining. Basically, we say that each position in a dictionary holds a key value pair. When referencing a value in a dictionary, you will use its unique key, and the dictionary will tell you the value that it is tied to think of it like this. Each time when item to your dictionary, your computer creates the handcrafted box to store the data. And also a custom makes a jewel key one of a kind, no other like in the world. This way, there's only one key that goes to the box that stores a certain bit of information. Because each key must be unique, we're using the key in a dictionary, it will result in an error being thrown. Because having two keys that are exactly the same will confuse the computer as to what box or piece of information that key leads to. However, you can store the same value in multiple key value pairs since the keys would all be different. Now, like I said, dictionaries are more fluid, making them easier to organize and then arrays as everything is set up in a more logical manner. That is to say, it is easier to find the value you are looking for when you're using keys, rather than simply referencing their positions. Let me explain what I mean. Imagine you have a dictionary of prices at a store where the key is the name of the product, and the value is the price of the item. Maybe apples cost $1 milk costs $2 and bread costs $3. You can see the in the dictionary, each key is the name of a product, and each value corresponds to the price of each product. So to find the price of bread, all you need to do is simply call the dictionary using the key bread. This makes it extremely easy to track values through your code. Since you're working with tangible values rather than numbers which don't mean anything to you. You can also manipulate dictionaries and money the same way as you can manipulate arrays and array lists. You can iterate through a dictionary and perform many operations and comparisons on the values. If you want to find the product with the highest price for example, you can iterate through the dictionary to find the value that is highest amongst the grocery store items. arrays, array lists and dictionaries are useful in their own right, as are the mass amounts of other ways to store data, and each boasts certain advantages over one another. We already covered the basics of these three. But since there are so many, we don't have time to go in depth into each and every one of them. And so in order to help you grasp the basics of storing information, we're now going to talk about one of the most important functions needed to understand arrays, which are searching algorithms. Now just as there are many ways to store information in computer science, there are even more ways of searching through lists. Searching algorithms at their core are ways in which we can look through a list of values stored in an array, say a patient name list or a high score list and find a particular piece of data. The goal of a searching algorithm is simply to give the algorithm a string or object you want it to find and have it return the index of the array that contains that string or object as fast as possible. Now while this may seem simple, lots of software runs on the backbone of being able to search through lists extremely quickly, making searching algorithms and in particular, efficient searching algorithms an important topic to cover. Additionally, this is the main functionality that arrays are used for. And it's the backbone of many of the methods used within ArrayList as well as many other storage methods. So knowing them will take you a very long way. Typically, searching algorithms are used to return the index of a particular data points so that it can be used, modified or updated or checked on. For example, if you're about to check into a hospital run on an array system for patients, the staff must search through your name in the database. And by returning the index of where your name is, they now have a quantifiable number that they can use to easily check you in, rent out prescriptions schedule you for checkups, update your personal information, etc. Without having to search through the list for your name every single time. You may think that there's little difference between searching algorithms since computers nowadays can perform millions of calculations per second. But when you're a huge multi billion dollar corporation trying to find a certain data point in a list containing 1000s, or even millions of data points, small differences in efficiency are going to make or break the user experience. Even a 1% improvement in efficiency can mean a big differences in the amount of time that a user is waiting for a simple task. Now before we jump into different types of searching algorithms, we must discern between the two states that a razor list can be in either sorted or unsorted. A sorted list of information is characterized by some sort of rankl value, whether that be a patient ID, credit card number, or even by alphabetical values like usernames or legal names. An unsorted list is just some random assortment of related information not sorted by any particular order or reason. Some searching algorithms only work for sorted lists, usually the more efficient ones, and some work for both sorted and unsorted lists. Although these are usually less efficient if you end up pursuing computer science further, you'll have to deal with both sorted and unsorted lists. So it's good to know a common searching practice for both. Another thing to note is that we determine the efficiency of searching algorithms, based on both the worst case scenario and the average number of items that must search in order to find the index. We call this big O notation in which each searching algorithm has an equation which takes in the size of the array as an integer and, and will output a worst case scenario efficiency value that we can use to compare with other searching algorithms. We can then also look at how long on average it takes to find an element in a list. Using these two methods allows us to easily compare how efficient two algorithms are. Alright, now that we've got some background on searching algorithms, let's hop right into it. The first type of search we'll be talking about is called a linear search. And Eve honestly probably uses multiple times throughout your life. Every time you have to search for your name on a list of people, you probably follow the same pattern, you start at the top check to see if the first name on the list is yours. If it is great. If not, you move on to the next name on the list until either you find your name or you don't in which case you leave. A linear search works in the same way, you start with the first element in the list compared to the value that you're trying to find. And if they're the same, you found your match and you return the index of that element. And if not, you move on to the next element in the list until you either find the thing you're searching for, or you run out of lists to check. Pretty simple, right? This is because linear searches are pretty bad when it comes to efficiency, especially in the worst case scenario. If the item you're searching for in the list is the last element, you're going to have to check the entire list of items before you find the one you're searching for. On average, however, you're going to get it about halfway through the list. This makes the linear search oven worst case scenario since in the worst possible case, it will take the entire length of the array or n to find the correct value. But linear search on average will return the correct index in O of n divided by two. We're halfway through the list. Now while the linear search is in great, it can work with both sorted and unsorted lists, because of the fact that it will eventually cover every element in the list. The other search we're going to cover requires the list to be sorted, which may seem like a drawback, but having a sorted list allows you to use algorithms that are far more efficient than the linear search. So overall, the linear search is a good basic searching algorithm for if you have an unsorted list. But if your list is sorted, there are way more efficient options out there for you, such as the binary search, which we'll be talking about now. The binary search uses a recursive process to break the data in your list down into more and more manageable bites. Taking advantage of the fact that it's sorted in order to find the item you're looking for faster. This one is much harder to wrap your head around. So let's start with an example. Let's say you have a list of 10 names sorted alphabetically, like shown on the screen now, and you want it to find your name within that list. in binary search, you would look for the middle most name, in this case, the one at the fourth index. Just a quick aside, since there is no true middle since the list is 10 names long, the computer automatically uses the next one down as the middle value. Now, once you find your middle value, you first check to see if the name you're searching for at the index you've chosen is the name that you're looking for. If it is you simply return that index. But 99% of the time it's not going to be including right now. So let's keep going. If the value at the middle name is not equal to the one you're searching for, you check to see if the value you're searching for comes before or after the middle index. For example, if you were looking for the name Brandon, and the value at the middle index was Carl, Brandon obviously comes before Carl alphabetically. And since we know that the list is sorted, what we can now do is ignore the entire bottom half of the list and just focus on the top. Since we know that if Brendon is even in the list, it's going to be in that top half. Now we simply treat the top half of the list as an entirely new entity and repeat the process over again. Again, we would find the middle most element of this new list of names and again compared to the name you're trying to find. If it's the name we're trying to find we return that index, but if not, we compare it to see if it comes before or after the middle index. Going back to our example. Let's say the middle index of this new list is AJ. Now we know that Brennan comes after AJ alphabetically. So what we can now do is ignore the top half of the list. Since we know that if Brennan is in the list, it's not going to be in the top half of our list. Now we again repeat this process again and again until we find the name we are looking for. So if For example, the middle index is time is Brenden. And that's what we're searching for. So finally, we would return the index to in binary search. Eventually, the index we were compared to our search term will be the same. And once it is we can return the index and move on. Now if we don't find it, which happens after we have eliminated the entirety of the list without finding our search term, the algorithm will simply return a null value to let you know that the item you're searching for cannot be found in the list. The binary search is way faster and more efficient than a linear search. Since we are drastically cutting down the amount of elements, we have to look at making the program run faster. In almost 99.9% of cases, in which your list is sorted, the binary search it's going to return a result faster than the linear search. So if you have a sorted list, your best option is to go for binary. As for efficiency, the binary search is O log n for the worst case scenario, which could be confusing if you don't fully understand logarithms. But all you need to know is that it is way more efficient than the linear search. Its average scenario is actually also o log n as well, which again, is infinitely times more efficient than linear cases. Now while there are other types of searching algorithms you can use, these two are the most common for both unsorted and sorted lists. So we will stop there for now. Up next, we're going to be covering one of the most confusing and important topics in computer science recursion. Let's start with the most important question, what exactly does recursion mean? in programming recursion refers to functions that repeatedly call themselves meaning that any instructions that occur within a function, one of the instructions will be a call to that same function you're already in. In the extremely primitive example, on your screen. Now, you can see we have some function which, in the confines of itself, calls itself, a recursive function will usually take into account some integer as an argument. And we'll use this to carry out some instructions, modifying the integer that was entered before calling itself again with a new integer as its argument. To better understand these functions, let's discuss the basics of how we go about programming one of them. A really good and easy example of a recursive function is one which sums up all numbers from one to n. So let's make a recursive function that does just that. The first thing we need is the actual function. And we're going to make it an integer function, which takes an integer and as its argument, the reason we do this will be explained later. But for now, let's move on to the base case. A base case is simply a definite value, which all recursive statements are the ones that are being repeatedly called as we go through the function tried to get towards at the beginning of the function, we test the value that was passed in by the argument against the base case to see if it is satisfied. Usually, these base cases are some requirements like of n as I described before, which has a certain value or is equal to a certain value, it is extremely important that the base case is set to some requirement that and will eventually meet for the same reason that it is important to avoid an infinite loop. We do not want a Stack Overflow error to occur. For example, if our base case, what's the stop calling the recursive function when n was greater than 100. And if it is not, we will call the same function again. But with n minus one. And we started with ns, say 99, we would never reach the base case and the recursive functional or purely call itself over and over again, subtracting one from n and hoping that somehow it will eventually be greater than 100 until your computer crashes. Not fun. So anyways, back to our recursive some example, let's make our base case when n is less than or equal to one. This way when you start at some positive integer and and subtract from it until it is less than or equal to one, in which case we can exit the recursive statement. Cool. Now, if n is not less than or equal to one, what we want to do is return the sum of both n and then the returning value of our recursive sum method minus one. Why do we add and the function call? Well, let's actually go through the function as if we were at the computer and see why we start with a call of recursive sum with n equals three, we know that three is not less than or equal to one. So now we tried to return a recursive sum of n, which is three and the returning value of recursive sum within n of two. We don't know what the returning value of recursive sum with an N of two is. So we have to go through the function again, only this time and is two again, and is not less than or equal to one. And so this function will go through the lF statement and return to plus another recursive statement, in this case, the returning value of recursive sum with an N of one. So once again, we have to go through the recursive sum function to get that value that will be added to two and then returned and added to three And then returned, hang in there, we're close now in this function, and is less than or equal to one, and so we return n, which is one. Now we take that n, which again is one, and that is what gets added to to the previous function call, and then return. So this would return three. Now, this three is what gets added to the first function call, which is three, and so it becomes three plus three, which is six. And finally, after all that time, we get six return from the function, which if you've been following along at home, three plus two plus one is indeed six. Now this may seem like a waste of time, since three plus two plus one is not a hard operation. But those of you saying that I asked you to please give me a sum of all the numbers from one to 3567. Godspeed. Now recursion is a very difficult concept to wrap your head around. So if you're not 100% comfortable with it at the moment, feel free to rewatch this section of the video in order to better familiarize yourself with it. Alright, cool. Now that we have a little background on recursion, let's talk about why it works so well. Now to understand why and how recursion works, we must first understand what a stack is. A stack is a data structure that contains all of the tasks you instruct your program to complete. Based on a certain method, your program will then carry out the tasks you give it is called a stack. Because if we start another process before the previous one completes, the process is stacked on top of the other one, such as the animation on your screen is showing now, programs we write will follow the LIFO structure. For those unfamiliar with accounting LIFO means lastin. First out, or the last item put on the stack will be the first one removed from it. Essentially, every time you ask your computer to complete a task, that task is added to the stack, and will be the first one to be resolved. Think of it like a stack of stones, you can keep adding stones on top of your pile. But in order to get to the one at the bottom, you must first remove all the rocks on top of it. Now when your functions continually cause itself without end, without a base case, like in our infinite loop example, then this stack will never be resolved, as items will be continually added to the stack without any of them ever been completed. In this case, the memory allocated to the stack exceeds the maximum allowed and a Stack Overflow error occurs resulting in your program crashing. Think of this as if you're doing chores. And before you complete one chore, you get called to do another chore. And then before you can complete that one, you get called to do another one. Since you keep stacking tasks, or shores on top of one another, the stack of tasks will never be completed. And you will probably die before ever finishing all of your chores. This is the same logic that makes infinite loops crash your program. recursion works on these same principles. The initial call makes a second call, which is added to the stack. And now that one must be taken care of first. But in that one, another function is called which gets added to the stack, and so on until you reach the base case and what you slowly start going back down the stack. In conclusion, recursion in general is extremely useful, because by calling the same functions repeatedly, it breaks down the problem into smaller sections, and results in the program being more efficient. small parts of problems are easier to solve and less taxing to compute than the entire problem at once. And the computer can combine these small solutions into the whole solution at the end. Now as we wind down our introduction to programming series, we want to take some time and go over some of the soft skills needed to be successful computer scientists. Since it's not all about writing code. In fact, many professional computer scientists will tell you that the majority of their job is spent thinking about code rather than actually writing it. This is because much of programming boils down to problem solving. How do we optimize the system? How can we make this feature for our app? What type of movement Do we want for our game? And how can we program it? The harsh truth is that no good program has ever been written simply from the programmer, getting the prompter idea, sitting down, hopping on an ID and starting to write code. There are many tasks we should go through beforehand in order to plan out our code. So we ensure that when the time comes to program, it's a clean and easy process and not riddled with mistakes and bugs. This is where pseudocode comes into play. Think of pseudocode like this, if you wanted to take a family trip to the Grand Canyon, would you simply hop in your car and drive off and figure out things later? No, because that would be ridiculous. Instead, you would spend some time planning out the trip. What sites or places do you want to visit? What hotel reservations are you going to have to make? What kinds of things are you going to do when you get there? What routes or highways are you going to take and why? All of these things must be determined before you can even think about hopping in your Ford Explorer. So how does this translate to pseudocode? Well think of our family trip to the Grand Canyon as a program, programmers use pseudocode pseudo meaning not real, and code, meaning code as a means to plan out their programs before they write them. Just like how we planned out our trip before going. They throw away syntax and naming conventions for variables and just focus on what they want the program to accomplish, and how they plan on doing that. pseudocode is very similar to constructing an outline for a paper that you're writing, you write down the main topics of the essay, and plan out your major talking points. But you don't worry about the nitty gritty details of it all, such as word choice, grammar, conventions, and proper formatting. By doing this, we allow ourselves to think freely and not worry about stressing the small stuff, at least not yet. Alright, now that we know what pseudocode is, let's talk about how we write pseudocode. You see, the best part about pseudocode is that it can take the form of many different things for many different people. Each computer scientist has their own methodology for planning out their code. And there are probably hundreds of different methods of writing pseudocode that are out there today. Today, however, I'd like to focus on three popular ones that I think you might find to be extremely useful. The first of these is known as flowcharts. And mainly they can be used to think through the process of a particular function. a flowchart is fundamentally a graphical representation of a function and how it might flow. Many programmers do this and lay out the conditional statements and loops that they want as different blocks in the flow chart connected by arrows and charting out every path of their function. From there, it's extremely easy to create test cases and follow them through the flow of the function through the different blocks and arrows. For example, we could have a flow chart that goes something like this, a user enters in a number, and if the number is eight, I want the program to return true. However, if the number is not eight, then I want it to return false. It's a great way to visualize what the functions overall purpose is, and also look for any errors that you may have missed when thinking about the function, such as a missing path. It also abstracts the programming statements up to simple blocks, making it easier to modify or change completely. The best part is that when you have finished testing cases, you can simply convert the blocks into programming statements, and you have a well written function without any debugging. Another popular pseudocode technique that is often used is to simply write out what you want your code to do chronologically. don't necessarily think about what programming statements and functions you want to use. just jot down from start to finish what it is the program you're writing is going to do step by step. For example, let's say you're making an app that takes in two numbers and divides them. The pseudocode for that would look a little something like this. First, I want to prompt the user to enter a number. And then I want to wait for the user to enter in that first number. After I get the first number, I want to again prompt the user to input a second number. Once they do, I complete the operation by defining the two numbers entered and returning the result back to the user. This all seems like it would be common sense. But remember that oftentimes, we're not going to be working with simple multiplication or division functions. We may be working with full scale games, algorithms or user interfaces with many different options. This method allows you the programmer to not get bogged down with the syntax and conventions that you have to follow, you're simply making a note of what the program's ultimate goal should be, as if you were explaining it to a friend of yours. This method really lets you plan out everything that needs to happen in your program in order for it to run smoothly. It also ensures you don't forget about a piece of an algorithm or a certain function that you need to write in afterwards. And the final pseudocode strategy that I'd like to talk about to you today is writing out the main features you want the user to have when using your program, and what functions or smaller programs, you're going to need to complete these features. Let's do another example. Say you're making a banking interface. And on startup, you want the user to initially have two options, they can set up a new account, or log into an existing account. From there, if they log into their account, then you want them to have the functionality to withdraw money, deposit money, take out a loan or pay back a loan. If they decide to set up a new account, you want them to be able to create an account, store their information in a database, and then access all of the features that are returning member would have. This may look very similar to the flow chart method. The only difference being that this is abstracted one level higher over an entire program, rather than just a single function. If you really wanted to, you could also create a flowchart that would go through the functionality of all the four methods described above. Setting up a hierarchy like seeing on your screen now makes it easy and clear to see every function interface you're going to have to make. This prevents you from having to try to shoehorn a function or feature into an already finished program at the last second, which is not a very fun experience in the slightest. So There you have it three pseudocode strategies you can use to plan out your code before you even start writing any the flowchart method, which is good for thinking through the flow of a certain function. The write up method, which is good for getting the general idea down for a program, or the functionality planning method, good for listing out the functions of a certain programs, you can use all of them, none of them are a mixture of them, or even disregard these and find and create your own pseudocode methods. The main goal here is to drastically minimize the amount of errors that occurred during your program and relieve a lot of stress on your head. The importance of pseudocode cannot be stressed enough. And if you don't believe me, I urge you to try to complete a large project without it. Okay, so if you've watched the series up until this point, you've gotten a pretty good understanding of many aspects of programming, and also how to plan out your programs. Now it's time to go out into the real world and write some actual code. But what kind of program I can hear you asking me? And the answer is truly whatever you want, really, as I'm sure you know, by now, you can program just about anything you have on your mind. Anything from simple games to complex software. This video has equipped you with the basics that are going to need to be used in pretty much any program you decide to write. But that doesn't mean that every programming language is perfect for every application. Each language has its own strengths and weaknesses. and choosing the right one is very important for making it easier, and sometimes just even possible for you to program what you want. So that's what we're going to be talking about now, choosing the best language for what you want to accomplish. Now, we talked earlier about low level versus high level programming languages. In case you forgot, let's do a quick refresher. higher level programming languages have a higher level of abstraction from machine language, that series of zeros and ones from way back when, while lower level programming languages have a low level of abstraction for machine language. For example, block program where you can drag and drop programming statements together like 2d Legos would be a high level language, as it does not take a high level of understanding of the inner workings of a computer to programming. The theoretical highest level of a programming language would be if I could just write down what I wanted the computer to do in Simple English, and it would just work. But sadly, that doesn't exist yet. On the other side of the spectrum, the lowest level programming language would be just feeding zeros and ones into the computer at supersonic speed, which would be almost impossible and extremely absurd. So how do you choose what type of language is best for your needs? Well, it depends on what you are trying to do, as sometimes you need very specialized languages to get done what you want. The world of computer science is vast and contains many fields. So trying to cover everything in one language would be impossible. This has led to the creation of hundreds of different programming languages, each designed for a specific task. Right now though, we'll cover some of the most popular languages and their uses. Now, if you are trying to design a website, using HTML and CSS is probably your best bet. HTML is a markup language that is designed for writing the content of a website. While CSS is great for designing the style of the website. you interact with HTML every day. And you can even see it right now. If you right click and hit Inspect Element. This will truly show you how complex HTML and CSS can be. Maybe it would be best for you to use a scripting language. A scripting language is a language that has many commands for you to use. And that can also be run without needing to be compiled. Scripts can be faster to write in most programs, and tend to be easier to port between operating systems allowing for cross platform support. Scripts can also be used with websites, oftentimes adding to the overall user experience of the site. If you want to go into web design, this might also be a path for you to go down. Examples of scripting languages are Perl, PHP, Ajax, and JavaScript. For most programs, you could probably use a general purpose language. General Purpose languages, as they sound have a wide range of applications. Usually, these should be your go to languages. Examples of general purpose languages are Java, c++, and Python. They each have their own different benefits over one another. Java is very useful for developing games and interactive web pages. Python can act as a scripting language for web programming, as well as writing applications and data analysis. And c++ tends to be used for writing applications and system programs. They all have a variety of packages that you can import and use to achieve the functionality you need from them. while selecting the right general purpose language for your big projects is very important. For most of your programs, any one of them will work. It really comes down to preference. Get to know each language and decide which ones syntax rules you like best and find most comfortable. If you get to know one general purpose language really well and enjoy programming with it, you can apply it to just about any of the programs you plan on writing. Personally, I tend to use Python for most of my projects. This is mostly not due to any functional difference between Python and any other general purpose language, though there are a few, but it is mainly because I find it syntax rules most convenient and easiest to write programs with. Overall, either you can consider the product you plan on doing and research and see which language boasts the most advantages for your purposes. Or you can simply become comfortable with a language and use it for most of the programs you decide to write. will now be looking at our final topic of this introduction to programming miniseries, you now have the basic knowledge of programming, which will take you far in any language that you decide to learn, you know, some good pre programming pseudocode strategies to help you design your code from the ground up. And you might already have a good idea as to the type of programming language you might want to start with. So what's the next step? How can I learn that language? And what applications can it be used for? Well, that's what we're going to be covering now. So let's just jump right into it. Starting with the biggest question, which is what is the next step? Well, now that you might know which type of language you might be interested in, research that language and find out whether or not you truly want to pursue that programming language. Most languages like Python or c++ will have either an official website where you can read up on the language, or Wikipedia page, which will provide you with useful information in deciding whether or not you want to pursue that path. From there, the next step is to actually learn the language, which can be done right here on YouTube. While we've taught you the basics of any programming language, each specific language is going to expand upon these concepts. And so watching tutorial videos on a certain language is going to be very beneficial. I would start with an introduction series, like the one you're currently watching both for the language you've chosen and work your way through that series, picking up on the syntax and rules of that language until you become comfortable with it. Once you do that, you come to a crossroads. You know how to program in a certain language, but you may be completely clueless as to what to make in that language. Programmers blog can leave you uninspired and not want to continue programming. So I'd like to give you a few websites to help out. First is coding bat, a completely free website which has hundreds of coding challenges in both Java and Python to help you refine your programming skills, and even learn some new programming shortcuts and tips. This is great if you want to get better at improving your efficiency and need something to hone your skills as a developer. The next is coder bite, which offers over 200 plus challenges that you can complete in over 10 different languages, something that is sure to help you improve. The final website I'd like to talk about is hacker rank, which not only provides programming challenges to keep you on your toes, but also provides support for you using your programming skills to find jobs or internships. These and many more websites exists solely to keep you interested in code and work on refining your skills to become better. Now if you're a teenager watching this series in high school, I also encourage you to take programming classes in your high school. AP Computer science principles and AP Computer Science a are both amazing courses which can help you greatly in the future, and are also incredibly informative and important to colleges. Your school might also offer other classes in the field of computer science, including ones on key data structures, game design, and data science. Any and all classes you can take to help expand your knowledge of programming and help you find your niche is going to be extremely helpful. As you can see, the world of code has now been opened up to you. These are just a few examples of where you can go from here. But there are many more we didn't talk about. You could get into GitHub and start contributing to projects. You could work on your own projects and collaborate with others. The possibilities are endless. The next step is up to you. This concludes our introduction to programming mini series. We hope you enjoyed watching it as much as we enjoyed making it. If you enjoyed the series as a whole consider subscribing to our channel, no pointer exception, which will be linked in the description for more content like this coming soon. Thank you so much for watching.
