With timestamps:

00:00 - what's up guys back today with another
00:03 - longer video which is to build a job
00:05 - board app that could actually be a real
00:07 - startup that people use there's a lot of
00:09 - different places to find
00:12 - entry level or junior developer jobs on
00:14 - the internet for example github jobs
00:17 - stack overflow jobs
00:19 - you have angel list you have indeed but
00:22 - filtering through those especially
00:24 - because you kind of have to spam
00:25 - applications for your first job can take
00:28 - a long time so the good thing about all
00:30 - these job boards
00:32 - is they have public apis for the most
00:34 - part you always want to start with an
00:36 - mvp that is the minimum viable product
00:39 - today that means we're going to start
00:41 - with a single data feed that is a single
00:43 - job board api
00:45 - feeding into our app and then finally
00:47 - we're gonna have a super minimal simple
00:49 - front end we're gonna do this in react
00:52 - and material ui on the front end
00:54 - we're gonna use an express server
00:58 - redis for our data storage because we're
01:00 - not writing or persisting any data that
01:03 - is not part of the job feed
01:05 - and then finally a
01:07 - node cron job to fetch these jobs and
01:11 - refresh them at a certain interval which
01:13 - are going to be filtered through an
01:14 - algorithm so let's draw this all out to
01:17 - get a better idea of our plan here's our
01:19 - front end
01:21 - what we basically want here is a
01:23 - list of jobs
01:25 - this is going to be pulling data from
01:26 - our
01:27 - api
01:29 - and that will be express and then this
01:31 - will pull from
01:33 - our
01:34 - store
01:36 - which is actually going to be
01:42 - redis
01:44 - and redis will be populated by
01:48 - our
01:49 - cron
01:50 - called a worker
01:52 - which is pulling from
01:54 - [Music]
01:55 - one or more apis it's going to be
01:57 - eventually multiple this is going to be
01:59 - job uh board apis so like in let's say
02:02 - indeed
02:03 - we have
02:05 - github
02:06 - we have stack jobs
02:10 - and this is going to be filtered through
02:12 - our algorithm
02:13 - we're filtering down the jobs
02:15 - getting rid of the senior jobs getting
02:17 - rid of the
02:19 - manager jobs and
02:21 - eventually when we make it more
02:22 - complicated we could even look through
02:23 - the description for years of experience
02:25 - and create uh search indexes and
02:28 - different things like that but again the
02:29 - minimum is just going to be pulling the
02:31 - jobs in and filtering them down
02:34 - okay so this is our plan let's start
02:36 - with the front end i know a lot of you
02:38 - guys like react
02:41 - and it's gonna actually be super simple
02:44 - let's just do a create react app to get
02:46 - started
02:48 - uh i already have a folder our directory
02:51 - here called junior dev so let's uh do a
02:54 - create
02:55 - react app and then call it client
03:00 - you guys know that i love
03:02 - material ui
03:04 - so let's install that as well once we
03:06 - get into our client
03:08 - and let's do yarn add
03:19 - okay that's done
03:21 - and we will start
03:25 - our
03:26 - react
03:28 - at
03:34 - okay let's go through the stuff we can
03:37 - actually delete
03:39 - no tests you always want to write tests
03:40 - in real life but
03:42 - not today
03:43 - logo
03:46 - and
03:50 - also clear this out here
03:57 - now let's open the material ui docs
04:02 - let's get our component api and
04:05 - let's get a
04:06 - title for our page
04:08 - typography h1
04:13 - let's just copy this
04:15 - and
04:16 - instead of putting it directly in app
04:18 - let's make a new component for
04:21 - jobs
04:23 - and then let's make a new component for
04:25 - a single job
04:27 - all job
04:29 - which we'll use in jobs
04:32 - and then let's import react
04:38 - exports default
04:40 - functions
04:48 - okay
04:50 - in this we will
04:53 - use typography
04:55 - okay so just to explain what i'm doing
04:57 - here i am
04:58 - making a separate component because i
04:59 - want our app just to hold our state and
05:01 - then jobs will actually hold our
05:03 - component tree our render styling and
05:07 - app will hold our application state our
05:09 - use state and
05:11 - call our hooks for kubota did mount and
05:13 - for state
05:14 - that was really confusing sorry
05:21 - we're using typography here
05:24 - and
05:27 - let's do
05:29 - variant typography variant
05:49 - okay i'm naming our page entry level
05:50 - software jobs i think it's a good name
05:54 - then save
05:56 - import jobs
06:04 - throw that in there like this
06:12 - okay that is some huge text but we're
06:14 - gonna leave it for now
06:16 - within jobs
06:18 - we already know we're gonna um
06:20 - import
06:23 - job
06:27 - make this a similar
06:29 - export we'll just copy this whole thing
06:36 - almost sneezed
06:39 - okay
06:40 - turn div and then this will just be a
06:41 - single job row
06:43 - which will put on a class name of
06:46 - a single job and then we'll just do this
06:48 - in advance because we know we're going
06:49 - to eventually have to write some css to
06:52 - style this stuff
06:56 - let's make a job list
06:58 - should probably actually be matching our
07:00 - component name
07:02 - just to
07:03 - change that back jobs and then
07:06 - job
07:11 - okay
07:13 - so
07:19 - let's just say that we're passing down
07:21 - some props
07:22 - for all our jobs from our
07:25 - uh app which is holding our state
07:29 - let's just do it like this and let's do
07:30 - some mock json that we might return from
07:33 - our api
07:40 - swe software engineer one
07:42 - and company
07:46 - google
07:49 - um
07:50 - there's gonna be a bunch of fields but
07:51 - let's just leave them like that for now
07:56 - and my mock job so we don't get it mixed
07:57 - up mock just being mock json data
08:01 - and
08:02 - it should work
08:04 - then we can do jobs
08:06 - map
08:08 - job
08:11 - this will return a
08:13 - job
08:16 - job job
08:18 - equals
08:19 - job
08:23 - hopefully that's not too confusing
08:27 - okay now you could just
08:29 - hear
08:30 - the structure job
08:33 - in the box but job.title let's see if
08:36 - this works
08:39 - there it is job.title
08:41 - and job.company
08:47 - and let's actually add some css
08:51 - for
08:53 - job and just make it a
08:55 - display flex
08:58 - next direction
09:05 - oh that's right
09:08 - it's always freaking
09:10 - hard switching from jsx to javascript
09:12 - okay there we go boom
09:13 - i'll leave it like that for now
09:16 - we can
09:17 - add more
09:19 - stuff to this
09:22 - this list if we want
09:24 - like this facebook
09:27 - apple
09:30 - it'll map it out for us
09:33 - let's give that a little bit of
09:35 - margin a little bit of padding
09:39 - let's do a
09:41 - 10 pixel top left right zero
09:43 - and then padding will be the same
09:50 - okay not too bad not too bad
09:52 - so our front end we could call this like
09:55 - kind of done let's call this done for
09:56 - now and let's return to it
09:59 - after doing some full stack stuff
10:01 - so i'm gonna
10:03 - collapse our client
10:04 - let's see what our actual data feed is
10:06 - gonna look like coming from
10:08 - uh our source which i'm just gonna use
10:11 - as github jobs because i know that has a
10:13 - really good clean api output that you
10:16 - don't need a key for or anything
10:20 - so api github jobs
10:22 - open it up you can see some examples
10:24 - here
10:26 - okay so it says that the api supports
10:28 - pagination it'll return 50 at a time
10:31 - and you could do it by adding a
10:32 - parameter to your queries before jumping
10:34 - ahead we just know we want these json
10:36 - representation of these jobs so we can
10:38 - manipulate it with our node worker
10:42 - so what i'm actually going to do is
10:45 - call a similar url like this
10:48 - in our node side
10:51 - which is going to give us output like
10:52 - this
10:54 - just by eyeballing this i could see that
10:57 - it is somewhat matching what we already
10:59 - wrote out here
11:02 - in app.js
11:03 - where there's a title
11:06 - somewhere
11:11 - yes like that
11:13 - senior full stack node.js developer and
11:16 - there is a company
11:20 - somewhere and we can also tell in
11:22 - advance that location's going to be an
11:24 - important field too
11:29 - but basing our
11:31 - analysis on this
11:33 - we could start to model kind of what our
11:35 - worker is going to do
11:37 - as well as how
11:39 - we want our api to
11:43 - act as well
11:49 - so
11:54 - looking back at our plan let's actually
11:55 - just make a folder
11:56 - for uh all our boxes here so this is the
12:00 - client right
12:01 - api is going to be
12:03 - simplexpress server
12:05 - and then the worker is going to have our
12:07 - algorithm and it's going to be calling
12:09 - our
12:10 - apis on a cron job which is
12:13 - at a set interval
12:16 - so maybe every hour in the day we want
12:19 - to
12:20 - refresh these apis refresh our redis
12:23 - and make sure that everything is up to
12:25 - date
12:27 - there's no expired jobs that the
12:29 - companies don't want people to see
12:30 - anymore and we're basically staying in
12:32 - sync with whatever is in uh our
12:36 - upstream data source
12:45 - so within worker i want to create an
12:47 - index.js which is going to manage all
12:49 - our worker tasks and i know already that
12:51 - we're going to need the cron node
12:55 - library
12:56 - it's just going to help us run simple
12:58 - cron jobs
13:00 - which is
13:01 - what i was saying before is the
13:03 - it's the way you run a task on an
13:05 - interval basically forever if you want
13:07 - to
13:08 - opening up a new terminal tab going out
13:10 - to our main directory
13:12 - and
13:13 - within our main directory i'm just going
13:14 - to
13:15 - create a package json which is
13:18 - going to be accessible from
13:20 - all our different
13:22 - folders
13:28 - so you can see that was created here and
13:30 - then we just want to install
13:32 - cron as a dependency
13:38 - okay
13:40 - now inside a worker i just this is the
13:42 - way i pretty much start with every uh
13:45 - with every app you just copy kind of the
13:46 - basic usage and you build your way out
13:48 - from there
13:51 - so all this does is it's running a node
13:53 - process where we're importing the
13:55 - library and then this is called a
13:57 - um
13:58 - cron shorthand cron syntax something
14:01 - like that uh cron.guru you can see it
14:04 - here
14:05 - okay so this site is really useful
14:08 - no not this site crown guru
14:11 - crontab guru
14:14 - okay so
14:17 - these asterisks are called a cron
14:19 - schedule expression
14:21 - and it's basically
14:23 - symbols for how often you want your job
14:25 - to run
14:26 - you can test it over here
14:28 - slash one that's actually every minute
14:30 - this is every second
14:32 - this is every second minute it's every
14:34 - third minute
14:35 - right so
14:37 - you just have to play around with the
14:38 - syntax that'll tell you here how to do
14:40 - it and then you could do kind of
14:41 - whatever interval you want so you could
14:43 - do like once
14:44 - uh a day i think one
14:47 - yeah so you got it you just got to mess
14:48 - with it to do what you want and then you
14:50 - could just google exactly what you want
14:51 - to do and you get pulled the chronic
14:52 - especially from that but this is kind of
14:54 - a playground to
14:55 - get the chronic expression you you
14:57 - definitely want to do
14:58 - all right so let's test this um
15:01 - this basic implementation of cron to
15:03 - just see if it works
15:13 - and in our real production app this is
15:15 - actually going to run every second not
15:17 - every second every um let's say hour to
15:19 - fetch our jobs so this will fire off
15:21 - some function which is now being passed
15:23 - in as this
15:25 - a anonymous function that is just
15:27 - console logging but what we're
15:29 - eventually going to put in there is our
15:30 - script to fetch the jobs and then filter
15:33 - them down
15:35 - so in this worker folder i'm going to
15:37 - make a github um or rather let's do it
15:40 - this way i'm gonna make a tasks folder
15:44 - and then we'll do one called
15:45 - fetchgithub.js
15:50 - and we just want to play around with
15:51 - that you know github api and get it to
15:54 - do what we want so the good part about
15:56 - the github api the the good thing about
15:58 - the github api and part of the reason
16:00 - why i picked it is because it is pretty
16:02 - much all developer jobs
16:04 - so
16:04 - we don't have to filter out for
16:06 - developer jobs we could just assume
16:07 - they're all
16:08 - tech jobs and then we will take the ones
16:10 - that are just junior software engineer
16:12 - or more specifically not senior or not
16:15 - manager
16:17 - so we know our
16:19 - url is roughly going to look like this
16:21 - to do a back-end url fetch request i'm
16:24 - going to install the node fetch library
16:26 - which is the same as the client-side
16:27 - fetch library
16:28 - but you could use it in node.js
16:39 - okay so we're just required like that
16:42 - then let's do
16:44 - an anonymous async function
16:46 - just to actually now let's do it this
16:48 - way
16:48 - export default
16:50 - async
16:51 - function
16:56 - just did a hey siri for some reason
16:59 - nope
17:06 - okay so fetch github there
17:08 - and
17:13 - i'll just call it here just for
17:16 - testing purposes
17:21 - and within here let's do a
17:25 - jobs await
17:28 - etch
17:30 - and we'll do
17:32 - asurl equals
17:37 - this
17:38 - without the query string
17:41 - so let's break this down a little bit we
17:42 - have a
17:43 - question mark
17:45 - then a description equals
17:47 - and ruby
17:49 - and page equals one so this is called a
17:52 - query string here
17:53 - it's a way to pass parameters through a
17:55 - url so
17:56 - so we're passing parameters to the
17:59 - server through the query string
18:02 - syntax which is
18:04 - key equals value like this
18:06 - so in our case we're going to want to
18:10 - iterate through the pages that is we
18:12 - want to
18:13 - get all the results from all the pages
18:15 - and combine them together
18:17 - the way i think we want to do that is
18:19 - just by leaving this like this
18:21 - so this is just our
18:23 - truly base url and then let's actually
18:26 - see what happens let's see how many jobs
18:27 - we get back just by doing this
18:30 - and then logging out jobs
18:32 - length
18:34 - keep in mind that this function is
18:36 - going to run because we're calling it
18:38 - here when we just run a node on fetch
18:40 - github.js
18:50 - okay i forgot we still can't do that
19:01 - and
19:05 - let's just do this
19:15 - okay undefined
19:17 - let's console like this
19:20 - jobs
19:25 - oh i forgot we also have to do this
19:30 - this is just our raw response this is
19:32 - jobs
19:34 - press.json
19:43 - still not resolving because this is an
19:45 - async function too
19:51 - okay 50.
19:53 - i already kind of knew this going in but
19:55 - if you put no parameters here it just
19:57 - gives you the first page only
20:00 - so we have to add a query string for
20:01 - each page and iterate through to get all
20:03 - the results until we get back an empty
20:06 - page
20:09 - best way to solve this is to
20:11 - keep adding one to the page number so we
20:13 - start at zero then we try page one then
20:16 - we try page two until we get back a page
20:19 - with zero results
20:22 - so if this is the way we do it for one
20:23 - page we're just going to want to run
20:24 - this same subroutine
20:28 - for every um
20:30 - page that's not empty
20:35 - to make this a little more clear i don't
20:37 - like really how we've written this out
20:38 - so far
20:40 - uh let's just do it like
20:43 - this
20:50 - maybe it's just me being lazy
20:52 - so while the uh page
20:55 - result count is not
21:00 - empty we're going to do this
21:06 - and we have to keep track of the page
21:07 - we're on
21:09 - as well as the result count so let's
21:11 - make uh result counts and not
21:13 - zero value because
21:15 - if it's zero it'll break our loop so
21:17 - let's just start at an arbitrary value
21:19 - one and then
21:20 - after we fetch the first page it'll be
21:22 - 50 then it'll be whatever the second
21:25 - page is until it's zero at which point
21:28 - this while loop will break so we'll
21:30 - initialize it to one
21:32 - and then let's also initialize
21:35 - our
21:36 - what where are we going to call it
21:39 - on page equals zero
21:42 - we'll start on page zero
21:45 - okay so
21:46 - base url we'll do a template literal
21:49 - here
21:51 - and then slash or instead of slash we'll
21:54 - do our query string
21:56 - h equals
21:58 - on page
22:00 - okay so we loop
22:02 - we get our jobs we get our jobs length
22:05 - we're gonna want to also
22:08 - push
22:09 - the jobs we get back into an array
22:12 - called all jobs
22:17 - let's do all jobs push
22:20 - the jobs we get back from that page
22:23 - [Music]
22:24 - let's keep this in here just so we know
22:26 - what's happening
22:30 - and then finally
22:34 - increase our on-page value
22:38 - okay
22:42 - again just to review
22:44 - setting our result count to a non-zero
22:46 - value
22:47 - starting on page zero
22:50 - creating an empty array to hold
22:52 - the results we're getting back from the
22:54 - api
22:56 - we start a while loop that's gonna run
22:58 - as long as we're getting results back by
23:01 - increasing one page at a time so getting
23:03 - page zero getting page one getting page
23:05 - two
23:08 - here's where the url is constructed base
23:10 - url from up here and then page starting
23:12 - at zero
23:16 - pulling out the json from the response
23:18 - putting that json in
23:20 - our array
23:23 - logging out how many jobs we got back
23:25 - increasing the page count repeating
23:27 - until we run out of
23:30 - or rather we run into an empty page
23:34 - finally we
23:36 - have all our jobs
23:38 - so let's just log out
23:41 - how many jobs we got total
23:45 - which we're going to eventually be
23:47 - returning
23:51 - all right
23:52 - now these console logs give us an idea
23:55 - of what's happening in our
23:57 - function here otherwise we would have no
23:58 - idea
24:01 - since we refactored a little bit we have
24:02 - to call the function again
24:05 - let's see what happens
24:13 - hopefully this is not infinite loop
24:15 - please oh
24:18 - oh
24:19 - oh no
24:21 - okay
24:23 - okay what happened there
24:26 - i guess we didn't break
24:28 - oh because we're not setting result
24:29 - count okay
24:31 - so
24:33 - we got to do this
24:34 - result count
24:37 - equals
24:39 - length
24:41 - okay
24:43 - there that should work
24:44 - now but for the most part good
24:58 - okay
25:00 - okay
25:01 - so there's one thing we also overlooked
25:03 - i think
25:04 - let's look back at this
25:08 - this is a sample response we're getting
25:09 - back
25:10 - and
25:12 - if we look at this whole object let's
25:13 - just assume this is like page zero
25:15 - it's
25:16 - coming back with an array
25:18 - but then we're pushing that array
25:19 - directly into our all jobs so this is
25:22 - actually creating an array of arrays
25:26 - whereas really we want a flat array
25:29 - just a single array holding all these
25:31 - job objects
25:32 - so the simple way to do that is to
25:34 - spread that in with a spread operator
25:36 - we're just dumping the array into
25:38 - another array by spreading the values in
25:42 - if we run that
25:44 - we're totally gonna see this is gonna
25:45 - work super confident
25:50 - [Music]
25:52 - why
25:53 - i did not work that time that's weird
26:03 - interesting
26:06 - okay that's probably something we have
26:07 - to debug maybe it was a weird response
26:09 - from the server
26:11 - so our fetch github function is done
26:12 - we're returning all our jobs
26:15 - now uh
26:16 - i think we actually want a way to save
26:18 - these jobs
26:20 - into a local storage that we can
26:22 - retrieve through our api and actually
26:24 - before we do that i'm getting ahead of
26:26 - myself but we want to call this
26:28 - entire function on an interval
26:31 - so um
26:31 - [Music]
26:34 - let's go back to crontab let's just call
26:35 - it every
26:36 - uh no let's yeah let's let's let's call
26:38 - it
26:39 - uh
26:42 - every minute
26:45 - make sure i'm doing that right
26:47 - yeah every minute
26:50 - every minute
26:53 - here we'll import our fetch github
26:55 - function
26:56 - patch github boom
27:00 - just throw it in here
27:04 - and
27:05 - the beauty of this is we can
27:07 - repeat this for as many um
27:10 - functions as we want right we could we
27:12 - could fetch github we could fetch stack
27:15 - overflow jobs we could fetch indeed and
27:16 - we could create a crontab for each one
27:18 - that is not dependent on one another to
27:21 - succeed or fail so these could be all
27:23 - trying in parallel and they could also
27:25 - um give us kind of a rolling refresh of
27:27 - our jobs so maybe
27:29 - one could run every
27:32 - 10th minute of the hour one could run
27:34 - every 20th minute and it'll just
27:36 - continuously refresh without hitting any
27:38 - one of these apis too often
27:40 - let's test the uh the cron aspect of
27:42 - that i just turned it on and it's
27:44 - running
27:45 - for the first time now
27:48 - but then it should run again after a
27:50 - minute
27:52 - okay
27:54 - and that's not going to work because i
27:56 - actually
27:57 - ran directly to fetch get github one
27:59 - but if i do
28:01 - index
28:02 - okay it's gonna wait a minute
28:10 - oh okay
28:11 - i messed up i messed up
28:15 - okay so i copied exactly over from cron
28:17 - tab every minute
28:19 - okay well i guess if you put six stars
28:22 - it'll do seconds and if you put five
28:23 - it'll do minutes
28:26 - so lesson learned there so we'll see if
28:28 - that works after a minute
28:30 - and in the meantime
28:33 - let's uh let's talk about storage
28:35 - and like i mentioned earlier we're going
28:37 - to want to store these jobs actually in
28:38 - redis
28:40 - now i already have redis installed
28:43 - but you can install it through homebrew
28:45 - pretty easily
28:47 - just if you don't have homebrew
28:48 - installed you look up homebrew
28:50 - installation you just it's a simple easy
28:52 - download and then you can install
28:54 - anything with a brew install for example
28:58 - redis and then it'll basically install
29:01 - redis under the hood
29:03 - in your system
29:05 - in a directory called uh the brew
29:07 - services
29:08 - so then you hit start and stop restart
29:11 - it from from that position
29:14 - jumping back up to this you'll notice
29:15 - that it worked after a minute so that's
29:17 - awesome so let's see if it runs again
29:18 - after another minute i just cleared the
29:20 - terminal there with command k
29:23 - but like i was saying about redis i've
29:25 - already installed it with brew install
29:27 - redis and you can install
29:30 - it yourself if you don't already have it
29:33 - there are a couple different ways to
29:34 - install redis but it should always
29:35 - connect the same way
29:38 - uh since i'm starting a new project here
29:41 - i just want to make sure my redis is
29:43 - clear
29:44 - so um
29:44 - [Music]
29:46 - oops there's a command line
29:50 - command
29:51 - that
29:52 - allows you to connect to the redis
29:54 - client and then we want to clear all our
29:57 - our redis with a uh
29:59 - it's a similar um
30:01 - language to like a sql where you can uh
30:05 - basically
30:06 - this is like a drop table and then we
30:09 - just cleared everything out of our redis
30:11 - we got a fresh start
30:13 - and you'll see it ran again after a
30:14 - minute so let's just
30:16 - we could stop that we could leave it
30:17 - running whatever i'm just going to stop
30:19 - it but we know our crontab refresh is
30:21 - working every minute with our fetch
30:22 - github
30:24 - okay i have redis installed
30:26 - and um
30:28 - if you're not familiar with redis it's
30:29 - just a key value store so it's an
30:31 - in-memory database
30:33 - my sql is a little bit different because
30:35 - it's on disk
30:36 - but redis is just
30:38 - memory so it's not persistent and that
30:42 - means if your system shuts off
30:44 - you lose all your ram so
30:46 - it's not a
30:48 - fault tolerant database it's not a
30:51 - durable database
30:52 - and
30:54 - the upside is though that it's really
30:56 - fast
30:58 - it's kind of like an object in
30:59 - javascript you just
31:01 - if you have the key it's
31:03 - constant time access you just pull it
31:04 - out of your redis store and then you can
31:06 - serve it up
31:08 - in our case
31:10 - jumping back over to these um
31:14 - these job uh json that we got from
31:17 - github
31:18 - you can see every job has a uuid
31:21 - which is a guaranteed unique id because
31:24 - it has so many characters and it's
31:25 - random characters so it'll be guaranteed
31:27 - unique every time
31:31 - every job has one of these ids
31:33 - so that's a natural candidate to use as
31:35 - a redis key
31:39 - i'm thinking within redis our key is
31:40 - going to be this id
31:42 - and our value is just going to be the
31:43 - whole job object
31:46 - so it would be a string version of this
31:47 - that we can then pull out
31:49 - we know it's already json so we can just
31:51 - stringify it and then when we pull it
31:52 - out we'll just parse it into a
31:54 - javascript object
31:58 - now the slightly tricky part of this is
32:00 - okay how do we access redis through
32:03 - our node
32:05 - um worker right because we have all the
32:07 - jobs here
32:09 - right now we're just logging them and
32:10 - throwing them away but we want to put
32:11 - them in redis
32:14 - and the answer to that is there's a node
32:16 - client library to access
32:18 - and connect to
32:19 - and uh
32:21 - do all the redis actions so it's an
32:23 - interface that node uses
32:25 - called the client
32:26 - that's a library that will do everything
32:29 - you need to do in redis and you can do
32:30 - it through node with this library
32:35 - so i'm just going to search for node
32:36 - redis
32:37 - and then we will
32:39 - install it
32:43 - just like the same way as before
32:51 - and i'm gonna do exactly like i said
32:53 - before
32:54 - what the getting started docs say i know
32:56 - this is going to be better if we
32:58 - promisify this library because you can
33:01 - see right now that we have all the redis
33:03 - commands here like set is setting a key
33:05 - and then there's one called get which
33:07 - will retrieve that key just think of it
33:08 - like an object so if you put in key a
33:11 - and then the val is
33:13 - one
33:14 - then you do client.get you'll retrieve
33:17 - that one from the a key
33:21 - set and get functions are async so it's
33:26 - not going to be in line with your
33:27 - javascript code and that's just the name
33:29 - of the game because
33:31 - redis is not in javascript so there's no
33:32 - way to know
33:34 - when its response comes back
33:35 - programmatically in line it's it's going
33:38 - to wait
33:39 - redis could be over network so it's
33:40 - going to take an indeterminate amount of
33:42 - time to serve the request and then
33:44 - that's going to come back to the
33:45 - function call
33:48 - in
33:49 - this format so this is the standard
33:51 - callback format and node error and then
33:53 - data replies is going to be the response
33:57 - now you can just ignore all of that
33:58 - because
33:59 - we're going to promisify this library
34:01 - with the
34:03 - promisify util in node which will
34:06 - convert callback functions into promises
34:09 - that we could use await or then
34:12 - promise chaining with
34:14 - and so on
34:16 - let me just
34:18 - do this i'm just literally copy pasting
34:20 - it from the docs and
34:22 - get it async is the example which is
34:24 - converting that client.get function
34:27 - to a promise
34:29 - i'm going to put this below the
34:31 - client variable declaration so it works
34:34 - and
34:35 - i can tell you now that we're also going
34:37 - to need a set async
34:39 - we were thinking of setting each job as
34:41 - its own
34:43 - item in redis right
34:46 - which would be fine if we were ever
34:48 - querying for those keys
34:52 - but we're not we're
34:55 - in the mvp
34:56 - gonna just get all the jobs serving back
34:58 - to the client and then we'll let the
34:59 - client handle pagination or any kind of
35:03 - showing and hiding of these jobs
35:07 - so until we do that
35:11 - or rather until we decide we want to
35:13 - optimize this query on the server we
35:16 - could actually just set the
35:18 - response from github
35:20 - as the value of a single key it'll be a
35:22 - huge text blob and we just serve up to
35:25 - the
35:25 - front end
35:28 - and the only reason we're doing this is
35:30 - because of
35:32 - performance we don't want to
35:33 - have to wait for the api to respond
35:35 - every time we uh serve a client request
35:38 - so redis is only a buffer that's an
35:40 - intermediary holding this data that
35:42 - we're only fetching once every hour
35:44 - because the jobs aren't refreshing that
35:45 - often
35:48 - so that's a long-winded way of saying
35:49 - that
35:51 - once we create these this all jobs um
35:54 - array
35:56 - we actually are just gonna throw the
35:58 - whole thing under one key and we'll call
36:00 - that key github
36:10 - also
36:11 - let's let's
36:13 - hold on to this um
36:14 - [Music]
36:16 - let's hold on to this um
36:19 - get function in our head because we're
36:20 - gonna we're not gonna be pulling out of
36:22 - our redis until we're in the api layer
36:24 - which is serving the um
36:27 - the jobs request
36:29 - man i have kind of a stuffy nose
36:36 - okay let's do the set async
36:41 - and this takes a value github
36:44 - or a key rather github then a value will
36:46 - be our all jobs we might need to
36:48 - stringify that
36:50 - but we'll test it out
37:04 - okay
37:06 - let's run
37:07 - node worker tasks
37:10 - that's github
37:11 - and uh
37:13 - let's see if that works
37:15 - we can test it like this get
37:17 - github like that
37:19 - we still have our redis cli open there
37:23 - okay so far
37:25 - nothing happened that's not a good sign
37:27 - and here's why
37:31 - let's call our function just as a test
37:33 - i'm gonna take that out
37:34 - okay
37:36 - okay
37:40 - i hope this uh sniffly nose hasn't been
37:42 - annoying you guys too much it's actually
37:44 - annoying me and i hope it's not super
37:46 - loud on the microphone
37:49 - okay the get command
37:51 - contains the argument
37:53 - of type object
37:57 - okay i didn't like that at all
38:00 - um i'm not i'm not using get so i don't
38:03 - know
38:04 - what it's talking about here but um
38:11 - okay i know now set
38:13 - and then okay let's try that
38:21 - okay
38:23 - set contains argument of type object
38:27 - and as we expected
38:29 - this is like an array
38:36 - i think this is gonna work
38:37 - to be honest
38:46 - nice
38:47 - okay github
38:48 - there it is
38:50 - radis is working
38:52 - our
38:53 - fetch worker is is totally great
38:57 - we'll leave these logs in just so we
38:59 - have that telemetry that observability
39:02 - but
39:04 - everything is working
39:07 - oops
39:12 - okay
39:16 - just make sure that's still working with
39:17 - our crown tab here
39:21 - oops
39:24 - so we're supposed to remind me to take
39:26 - that out
39:29 - leave that running
39:30 - and we'll jump over to
39:32 - our
39:33 - next piece
39:34 - if we look at our plan
39:36 - api
39:39 - so let's just review this
39:42 - oh actually so we've got this api part
39:44 - done
39:45 - we still need this
39:46 - we still need this
39:48 - and then we'll improve our front end
39:50 - last
39:52 - so filter algorithm
39:56 - all right let's look at what's in our
39:57 - store here
40:00 - so we're getting jobs back
40:02 - and um
40:03 - [Music]
40:05 - like i said we
40:07 - we want to start with a really simple
40:10 - algorithm
40:11 - that is just filtering out by position
40:15 - so just taking like eyeballing this
40:17 - i can see that in the title
40:21 - we can gain a few insights into what
40:24 - kind of job
40:26 - it is right
40:27 - if we see a senior
40:29 - in the title we know it's not going to
40:31 - be a junior developer job
40:34 - if we see manager in the title we know
40:37 - it's not going to be a junior developer
40:38 - job
40:41 - another common thing we might see is
40:43 - like a senior abbreviated as sr
40:47 - i didn't see it in there but i know
40:49 - that's
40:50 - it's done so
40:53 - maybe if we see that word sr dot at all
40:57 - then we um
41:00 - we want to filter it out
41:05 - so this is our set in redis so we're
41:07 - gonna want our filter before that
41:13 - that's all pages
41:18 - filter
41:22 - you can always factor this out to a
41:23 - function later but for now let's um
41:27 - let's do it this way
41:29 - okay
41:33 - new array junior jobs
41:36 - it's going to be fill a
41:38 - subset of all jobs
41:40 - and we're going to filter based on a few
41:42 - different parameters
41:43 - looking at each job
41:46 - okay we're going to use one super
41:48 - important thing here and that is the
41:50 - string that includes function and we're
41:52 - going to use that on job title
41:54 - so if the job title includes
41:57 - or rather
41:59 - stop siri
42:02 - okay let's do it this way actually job
42:04 - title equals job title to lower case
42:08 - it's important
42:10 - i think the example we saw in the
42:11 - terminal was in all caps so we want to
42:14 - reduce that kind of
42:16 - variation by just lowercasing the whole
42:18 - title
42:20 - we also don't have to keep accessing the
42:21 - object if we just store it in a variable
42:22 - so this is this is for one job
42:26 - and um
42:29 - we're going through 392 so we're gonna
42:31 - have to go through each one of those
42:32 - jobs real fast
42:34 - that's part of the reason too why we're
42:35 - doing this cron method is because if we
42:37 - fetch the jobs on every front end
42:39 - request we'd have to do this whole
42:40 - filter thing every time and it's going
42:42 - to be the same logic so
42:44 - in general when you're doing the same
42:45 - logic for every client request that's
42:48 - definitely a good case for caching or
42:50 - even database denormalization so
42:53 - replicating data in your store that's a
42:55 - commonly
42:56 - a common read pattern rather
42:59 - all right we could be more curious about
43:01 - this but let's just make it super clear
43:02 - and have a default case let is junior
43:05 - equals true
43:08 - then there's going to be our logic
43:11 - then
43:12 - we're gonna just return the result is
43:14 - junior okay
43:17 - now this is gonna be our main algorithm
43:18 - logic here
43:24 - okay so if um
43:27 - job title
43:28 - includes
43:32 - senior
43:34 - we gotta remember we changed it to lower
43:36 - case
43:40 - or
43:41 - job title
43:43 - includes
43:45 - manager
43:46 - or
43:49 - job title includes sr dot senior
43:53 - or another one i'm gonna
43:55 - and i thought about this before
43:57 - i'm gonna put in is architect because
43:59 - that is
44:00 - generally a more senior role as well
44:03 - that you're not gonna be able to do as a
44:05 - junior developer that's something you
44:06 - have to gain a little skill from then
44:08 - you can design whole systems and
44:10 - you may or may not be the one
44:12 - implementing them as well
44:14 - but here's all the cases we want to
44:15 - filter out
44:17 - if any of these are true
44:20 - is junior equals false
44:26 - okay so this is the most clear we could
44:28 - way we could do it but
44:31 - i'm actually going to cut this part out
44:32 - and then
44:33 - we'll do return false
44:36 - otherwise
44:39 - we don't actually need else just
44:41 - if that didn't happen return true
44:48 - okay now
44:50 - [Music]
44:52 - we could test in our in our code how
44:54 - many get actually filtered out by this
44:57 - by um console logging
45:00 - filtered down to
45:03 - junior jobs
45:05 - okay
45:07 - and we do uh
45:11 - move this one up here
45:15 - actually i think
45:17 - yeah we'll leave that in
45:19 - make sure we're adding junior jobs in
45:21 - here only
45:23 - consolidate success okay
45:25 - just that's bothering me okay restart
45:28 - oops
45:29 - restart
45:31 - clean slate
45:33 - we'll get this extra log we'll see how
45:35 - much damage our filter does
45:38 - and then we will
45:40 - still set that in redis and then we can
45:43 - make sure it's still in there
45:46 - please work
45:51 - okay
45:53 - nice
45:55 - cool so
45:56 - if we're filtering out okay we went down
45:59 - from 392 all the way to 245 so we're
46:02 - filtering out
46:03 - almost uh one third of the jobs just
46:05 - with these words
46:09 - which i think is already making our app
46:11 - useful to some degree obviously the more
46:13 - complex we make this algorithm we could
46:15 - search through the
46:17 - job.description
46:20 - look for years of experience
46:21 - there's definitely more
46:23 - more titles we can include here
46:26 - but that would depend like what we see
46:28 - in the json
46:30 - um
46:31 - we can kind of pluck words out of there
46:32 - be like oh yeah this was obviously a
46:34 - senior term too and then add it to this
46:36 - list but for now i think it's a good
46:38 - start
46:44 - okay
46:46 - let's see
46:48 - back in our planning
46:50 - we just did our filter algorithm or very
46:52 - basic version node work is done so this
46:55 - whole section is done
46:57 - redis is done
47:00 - api
47:01 - and then we'll we'll finish up with our
47:03 - front end and then finally deploy
47:07 - okay
47:09 - so
47:10 - let's actually just close everything
47:12 - open up api
47:14 - index.js
47:17 - just want a super simple express app
47:20 - express
47:30 - again same thing i said before
47:33 - uh
47:34 - just do that npm install
47:40 - and then from there
47:42 - you take the most basic example
47:50 - make my port 3001 because i know my
47:52 - front end is running on 3000.
47:57 - get a little bit of extra space here
48:03 - and
48:04 - um okay and then this
48:08 - route
48:09 - we don't need a slash we just need a
48:10 - route called jobs
48:13 - okay
48:15 - i love this part
48:21 - okay our express install went through
48:22 - over here
48:25 - let's do um let's just run a node on api
48:28 - index.js
48:32 - sample app listening on port 3001
48:35 - and then if i curl which is just sending
48:36 - a request to something on the port 3001
48:41 - slash jobs get the hello world back
48:44 - sweet
48:46 - okay this is going to be the simplest
48:48 - api ever
48:49 - and we just want to use that
48:51 - redis
48:53 - library we already installed
48:55 - and we're going to use the get which we
48:57 - already commented out
49:00 - and we already know which key we're
49:01 - gonna get because we only set one so
49:03 - that really simplifies it
49:05 - uh so we need to copy actually all this
49:07 - code and delete this because we don't
49:09 - need it here
49:12 - get the redis client get another
49:14 - instance of that here
49:16 - and then
49:18 - do the get async and this is where the
49:19 - async part is really going to come in
49:21 - handy
49:24 - to convert this route to an async
49:27 - function
49:29 - let me do jobs here
49:31 - wait
49:32 - get async
49:35 - github
49:37 - just hardcode that in
49:45 - now let's remember we stringified it so
49:47 - json parse
49:52 - and i'm going to actually undo this
49:53 - because we are just going to have to
49:55 - re-stringify it when we send it to our
49:57 - client but um in the meantime
49:59 - just to
50:01 - see the length and or rather see that
50:03 - the length matches our
50:05 - our length that we put in let's parse it
50:08 - and then let's do dot lake
50:14 - okay
50:17 - so
50:18 - it's kind of a lot that we did without
50:19 - testing it let's restart our server
50:22 - do the same curl
50:24 - oh man okay 245.
50:26 - i don't remember if that's how many we
50:28 - put in we're definitely getting a list
50:30 - of 245 which is a good sign
50:38 - now let's just try sending this back and
50:39 - see if we get that full uh stringified
50:41 - object
50:46 - that's exactly what we want and it's
50:47 - that easy
50:53 - so that's already done
50:56 - so i don't know how long it's been guys
50:58 - but
50:59 - with this simple of an api we can
51:01 - literally
51:04 - we've literally been able to create all
51:06 - this like in such a short amount of time
51:08 - we have a data feed
51:10 - and you can replicate like before before
51:12 - i go further
51:14 - you can replicate this
51:15 - in any
51:17 - this is like 90 applications if you have
51:19 - a data feed you have storage you have a
51:22 - worker that's doing some async task on
51:24 - an interval
51:26 - uh it's called batch processing
51:29 - you have an api that's called by front
51:31 - end
51:31 - this is like 90 of crud applications
51:34 - let's create read upload delete
51:38 - in this case we're only really reading
51:39 - from the front end but the backend is
51:41 - doing some more complex stuff including
51:43 - an algorithm
51:45 - the pieces that we're using are used in
51:47 - some way in almost every
51:49 - large scale application so doing this as
51:51 - an mvp is like a really good exercise
51:56 - all right let's push on
51:59 - i might be getting a little bit tired
52:00 - but let's keep it going
52:03 - okay
52:05 - so we have our api
52:07 - uh running let's keep this running
52:10 - all right let's just restart this so we
52:11 - have the uh log that we know we're
52:13 - listening
52:15 - and um i'm gonna go back into our client
52:17 - folder
52:20 - okay
52:21 - so we're back in our app
52:24 - close that we're back in our app
52:26 - function which we we mentioned we're
52:28 - going to put the state
52:30 - in let's pull this back up
52:34 - so make sure it's still running all good
52:38 - to call our api programmatically the
52:39 - same way we're doing with curl here
52:42 - we just need to call this url
52:44 - with a function that we're going to make
52:46 - called fetch jobs
52:55 - all it's going to do is use the browser
52:56 - version of fetch which we don't need to
52:58 - import because it's built into browsers
53:00 - like chrome
53:03 - let's um instead of hard coding
53:05 - do a
53:06 - job api url constant
53:11 - it'll just be exactly what we have over
53:13 - here
53:20 - since this is async we can use in a
53:21 - weight a weight
53:24 - const jobs equals weight
53:27 - of course this will be in json so we
53:28 - have to uh convert it to json
53:32 - let's do that call this res call this
53:35 - json goes await
53:37 - as that json
53:38 - and before going further let's just log
53:40 - that out
53:43 - okay
53:45 - how do we call this in our client
53:48 - to find my number used i know i'm
53:49 - getting there
53:52 - okay if you've seen my past videos i
53:54 - talked about react hooks
53:57 - these are replacing all react class
53:59 - components
54:00 - now we just have functional components
54:02 - and we've seen hooks for
54:04 - use reducer use state and all that kind
54:06 - of stuff
54:10 - since this app is just a very simple
54:12 - state it's a list of jobs i don't feel
54:14 - like i need to use a reducer
54:16 - and i know exactly the shape of these
54:18 - jobs as well so i don't need to do any
54:20 - reducer like manipulation and it's also
54:23 - very hierarchical and shallow
54:25 - application
54:27 - meaning i just want to pass down these
54:29 - jobs one level to my job's
54:31 - view component from this app state
54:36 - i started talking about hooks and we've
54:38 - used the used state hook a lot
54:41 - in my past videos but we're gonna use
54:43 - one that we haven't used too much yet
54:44 - here which is called use effect
54:48 - and that's basically uh replacing the
54:49 - component did mount or component did
54:53 - update function from past versions of
54:55 - react
55:02 - so i'm going to use it here react i use
55:05 - effect
55:06 - and then
55:08 - this function actually takes a anonymous
55:10 - function
55:11 - in which i can do some
55:13 - function calls some async function calls
55:15 - as well as a second argument which is
55:18 - the
55:21 - basically hooks that i want to watch
55:24 - to update but if i pass in an empty
55:25 - array this react i use effect will act
55:28 - exactly like a component did mount
55:31 - all right in inside here just gonna
55:33 - fetch jobs
55:34 - and um
55:38 - i also want to think about how i'm gonna
55:39 - store those jobs so um
55:41 - let's also do a used state hook
55:44 - jobs
55:45 - this is never jobs a lot so let me just
55:47 - do job list
55:49 - was react dot use state
55:54 - and
55:55 - update jobs
55:57 - react i use state and then i'll
55:58 - initialize this to an empty list
56:01 - which i'm actually going to pass in here
56:03 - so when i do that that should actually
56:04 - clear out all my um
56:08 - chops okay good because i'm initializing
56:10 - it to an empty list
56:11 - okay in here i'm fetching jobs
56:14 - console.json
56:16 - see what happens here
56:18 - fail to fetch ah right
56:21 - this is one thing you're going to
56:22 - definitely run into if you're writing
56:23 - express apps and you're pretty new it's
56:25 - the access control allow origin
56:27 - so this is something you have to set in
56:28 - your server if you're accessing
56:31 - endpoints from a different base url it's
56:33 - called cross origin resource sharing
56:37 - and
56:38 - you basically have to set a server
56:40 - header in your api that allows requests
56:43 - from the url
56:44 - that is
56:45 - the origin
56:47 - so recall that our react app's running
56:49 - on localhost 3000 as we can see here
56:52 - so all i have to do is set a um header
56:57 - header
56:59 - uh
57:01 - i think it's like
57:02 - just literally that but
57:05 - let me just uh let me just copy
57:07 - something to so i make sure doing it
57:09 - right
57:13 - chorus res header express
57:19 - yeah here it is
57:21 - that's all i need
57:23 - press header access control origin but
57:25 - if i do the star that makes it not
57:27 - protected so i just want to make this
57:28 - http localhost
57:32 - 3000
57:34 - okay
57:36 - now this will
57:38 - i think i'm 92 percent sure it's gonna
57:40 - work
57:45 - all right
57:47 - i type it wrong
57:50 - huh
57:53 - i didn't restart my server that's why
57:57 - i was the eight percent me not
57:58 - restarting it
58:03 - wow nice guys there we go
58:06 - that's all our jobs
58:08 - beautiful okay
58:11 - we're getting close
58:14 - okay fetch jobs is um
58:17 - it's working
58:19 - i think what we still need is a um
58:23 - callback to to update these jobs
58:26 - so let's just do this
58:28 - update callback
58:32 - as we know when we use a used state hook
58:34 - the second variable
58:36 - that we destructure from the use state
58:38 - hook
58:39 - is a function
58:40 - in which we can pass a argument
58:43 - that is the new value of our state
58:46 - for job list
58:47 - so if i pass it in here like this update
58:50 - callback and then i pass the json
58:52 - directly into this
58:54 - i'm actually just setting the value
58:58 - of job list to this json which is as we
59:02 - can see over here an array of uh size
59:05 - 245 containing our jobs
59:09 - okay so i got update callback
59:12 - job list
59:14 - i didn't even have to do
59:15 - anything else it's already rendering all
59:17 - the jobs
59:19 - that are from github
59:22 - that's pretty cool
59:24 - hey guys i'm back with a new shirt let's
59:26 - finish up this front end and then get
59:28 - this app deployed
59:29 - i've pulled up another plan board here
59:31 - just to make it a little bit more clear
59:33 - what we want to do with the front end
59:34 - like i said before we always want to
59:36 - have a plan before we just jump into
59:38 - coding
59:39 - and um
59:40 - the first thing i'm going to draw out is
59:41 - just the current way the app looks which
59:44 - is just the title and then uh the list
59:46 - of all our jobs here
59:50 - right now our jobs only have the title
59:53 - and the company name but we're
59:55 - definitely gonna want also to have the
59:58 - location so title
60:02 - company
60:03 - we're definitely going to want location
60:05 - as well as
60:07 - the
60:07 - time posted
60:10 - and i think the best format for time is
60:12 - how long ago so today one day ago two
60:15 - days ago etc
60:19 - now this is in the list view and
60:21 - we gotta think about too what is going
60:23 - to happen when we click on a job
60:25 - and in that case i want to build a
60:28 - detail view modal
60:30 - also known as a dialogue or a pop-up
60:33 - that will show more details about the
60:35 - job uh which will include
60:38 - the
60:38 - company logo
60:42 - description
60:44 - as well as the
60:47 - apply link
60:50 - and that could also be a button if we
60:52 - decide to make it like that
60:55 - okay so these are the main things we
60:57 - still need to
60:59 - excuse me these are the main things we
61:01 - want in our front end the good news is
61:04 - since we already have the json
61:06 - we just have to pull it out
61:09 - of the json of each job and create a
61:11 - little bit extra functionality to make
61:13 - this modal animate
61:15 - luckily this is pretty easy with
61:17 - material ui and in fact the main reason
61:19 - i wanted to use it for this project
61:20 - because you get the modal for free with
61:22 - all the um
61:24 - animations and stuff like that
61:27 - so let's just jump back over to our um
61:31 - front end here
61:32 - and i'm gonna pull open
61:35 - the
61:36 - jobs component
61:41 - here i have variant h1
61:43 - but i think this title is definitely a
61:45 - little bit too big i don't think it
61:47 - i think that's pretty obvious and i'm
61:50 - going to switch this up to
61:52 - still using a h1 html under the hood but
61:56 - the variant will actually make it an h4
61:59 - stylistically so that's a pretty cool
62:01 - trick if you want to maintain the uh
62:03 - benefits of having h1 for seo and so on
62:11 - diving into the job itself
62:13 - let's actually log out what a single job
62:17 - is going to look like just so
62:19 - we know what we're working with and
62:20 - instead of doing that here in the job
62:22 - component i'm going to do it in jobs
62:24 - and we could just look at what the first
62:26 - job looks like
62:30 - so i'm going to use jobs 0 for that
62:35 - then we'll open the console
62:39 - and
62:40 - see that
62:41 - we have the fields we can use here
62:46 - so i said we wanted to add location and
62:49 - time posted to our list view
62:54 - uh we could pretty easily just pull out
62:56 - location
62:58 - in our job component like the way we've
63:00 - been doing with the other ones
63:10 - and there it goes
63:12 - this is looking a little bit
63:15 - let's say
63:16 - disorganized but let's worry about that
63:19 - in just a moment um
63:21 - for now i'm just going to throw these
63:22 - all in a div which is going to be
63:25 - floating to the left of our box
63:28 - and instead of space
63:31 - uh
63:32 - around i want to change this
63:35 - css to space between
63:42 - it'll make sense more in a minute why
63:44 - i'm doing that
63:46 - finally
63:47 - in another div let's do the um
63:52 - created date which i believe is over
63:54 - here in our json as well
63:59 - created underscore at
64:03 - and i'm just kind of using these
64:04 - typography elements interchangeably as
64:07 - divs
64:08 - so later on we can change the size of
64:11 - these different things
64:13 - okay so created at
64:19 - let's just see if the spacing looks
64:21 - alright there
64:23 - now that i see this here i think the
64:25 - date doesn't actually look too bad
64:28 - as long as we make it a little bit
64:30 - shorter so
64:31 - let's just split it by space
64:34 - and then take the um
64:37 - the first three words so let's take o24
64:41 - and then join that by a space
64:44 - so all i'm doing here is
64:47 - taking sunday june knife out
64:50 - of this longer string
64:53 - i meant to do 0 to 3. there we go so we
64:56 - get index 0 1 and 2.
65:00 - all right looking at our page
65:03 - it deserves a little bit of padding
65:05 - just it's pushed up against the side
65:07 - here so let's add that quickly and then
65:10 - keep going
65:11 - let's give body a
65:14 - margin
65:14 - [Music]
65:18 - top and bottom zero left and right 40.
65:23 - okay
65:25 - top and bottom
65:27 - 20.
65:34 - all right and then within job maybe we
65:36 - give a little padding
65:39 - uh top and bottom left and right ten
65:43 - okay
65:44 - pretty good
65:47 - now inside job
65:49 - we'll actually add some hierarchy
65:52 - style hierarchy to our
65:54 - job title
66:05 - let's do h5
66:10 - h6
66:12 - on this
66:22 - and so on we can just keep
66:25 - updating editing this
66:27 - um
66:28 - i think i'm actually going to flip these
66:30 - around h6h5
66:34 - but you get the point you can just keep
66:36 - tweaking it
66:38 - okay let's add that pagination thing i
66:40 - mentioned
66:41 - it's gonna be kind of a fake pagination
66:43 - you're supposed to do it on the server
66:44 - to not load all your results at once
66:47 - but this is a good stop gap we start
66:49 - just with the client implementation and
66:51 - then later if we want to improve the
66:54 - performance we could do the server
66:57 - side too
66:58 - but long story short we have over 200
67:02 - results we want these on more than one
67:04 - page so they're more navigable
67:06 - so to solve this i
67:08 - opened a material ui page for the
67:11 - stepper component and i really like this
67:13 - one down here called the
67:16 - mobile stepper progress
67:18 - so you could click through it like this
67:20 - it fills up kind of a progress bar and
67:22 - it says mobile but i like it so i'm just
67:24 - gonna pull it over
67:26 - um let's see let's just pull over
67:29 - everything here
67:32 - just in case we need it and then paste
67:34 - it right into
67:36 - our jobs component
67:38 - and um
67:41 - we could use the word step here
67:44 - interchangeably with page and i'm
67:46 - putting this state in jobs because it's
67:48 - more of a
67:50 - view state rather than an actual data
67:52 - based state so
67:55 - all our logic concerning our view is
67:57 - going to actually be in jobs and not in
67:59 - the app
68:00 - file
68:02 - okay so
68:04 - since
68:06 - these each have their own function
68:07 - handle next set uh
68:09 - oh sorry handle next handle back i'm
68:11 - just going to copy these directly over
68:13 - to
68:17 - paste those right in function inside a
68:19 - function
68:21 - and
68:22 - um all right finally i'm going to just
68:26 - put this whole thing below our
68:28 - uh jobs map
68:31 - and um let's see if by pasting it
68:34 - directly in we we
68:37 - need to do anything else
68:40 - just going to make sure that's formatted
68:42 - correctly
68:43 - saved it
68:45 - and um
68:47 - let's just take this out classes
68:58 - direction rtl
69:08 - okay let's see how theme is being used
69:10 - because this is kind of a um
69:14 - darn
69:18 - all right i don't know why that would
69:19 - change from left to right but um
69:22 - it might be a mobile implementation
69:24 - specific thing
69:25 - so let's just take this and
69:28 - hard code it as
69:30 - right and we'll hard code this one as
69:32 - left and see if we run in any problems
69:40 - okay save that
69:42 - and can't find
69:44 - module
69:47 - oh
69:48 - i forgot about this material ui icons is
69:51 - a separate library so we have to also
69:54 - install that
69:56 - in our client
69:58 - yarn add
70:02 - material ui icons
70:14 - now while that's installing let's think
70:15 - about
70:17 - how else we want to use our pages
70:20 - um
70:23 - if we want to artificially construct
70:24 - these pages from a larger list
70:28 - then we basically just want to break
70:30 - things into
70:31 - a slice depending on
70:34 - the number of results we want to show at
70:36 - a given time
70:38 - so
70:41 - let's think of it as a moving window of
70:43 - 50.
70:48 - so if step equals 1
70:52 - or let's say step equals 0 then we want
70:54 - to show
70:55 - 0 through 49
70:57 - step equals 1
70:59 - show 50
71:01 - through 100
71:04 - and so on or maybe 50-99
71:09 - okay
71:10 - so since our icon's finished let's see
71:13 - if that worked we got to go all the way
71:15 - to the bottom and yes it is here
71:18 - next
71:19 - and back okay
71:22 - okay
71:23 - so let's make this more dynamic steps is
71:25 - hard coded as six
71:26 - if we want 50 per page um
71:29 - we're going to have to do our
71:31 - well
71:33 - since we're going to use this in a
71:34 - couple different places let's get our uh
71:36 - job
71:37 - length or num jobs equals jobs.like just
71:41 - for uh better abstraction
71:44 - steps will be num jobs
71:47 - uh
71:49 - divided by
71:52 - 50. and then we'll math floor that
71:59 - or let's actually math seal that because
72:03 - it'll be
72:04 - minimum
72:06 - um one page could have you know only one
72:09 - job on it
72:10 - so we want minimum
72:13 - okay
72:16 - so that seems about right it seems like
72:18 - we have about four pages just by the
72:20 - amount of times i click that
72:23 - and um
72:24 - let's add a little more detail to right
72:27 - above this mobile stepper that just says
72:29 - and i'm just making it a different now
72:30 - but we can change it um
72:33 - page
72:36 - uh
72:39 - active step
72:41 - of
72:45 - num jobs
72:48 - okay
72:56 - um not
73:01 - okay let's let's let's factor this out
73:03 - num pages
73:08 - num pages equals this and then we can
73:11 - also use this
73:14 - where
73:15 - we are
73:18 - oh
73:19 - computers lagging again
73:23 - numb pages like that
73:26 - yeah i'm feeling pretty confident about
73:28 - that um
73:31 - see if it worked if we go to the bottom
73:34 - my
73:34 - wrist is getting real tired of scrolling
73:36 - here
73:49 - all right and then
73:51 - one thing i actually meant to do earlier
73:53 - too is
73:55 - um
74:19 - okay going all the way down
74:22 - okay oh five
74:26 - oh back one
74:29 - two three
74:31 - four
74:32 - five okay so the display number we want
74:34 - to actually be
74:36 - uh active step plus one because we're
74:38 - zero index and we're going up to
74:40 - um
74:43 - for
74:44 - yeah so this will this will work
74:47 - on pages minus one because the index is
74:50 - actually one less than the true value
74:58 - one
75:01 - two
75:02 - three
75:03 - four
75:06 - five okay
75:08 - we'll just leave it as num pages
75:11 - all right
75:14 - one other thing that i meant to add
75:16 - earlier is uh the total number of jobs
75:19 - at the top right under the title
75:24 - so let's do a
75:26 - variant h6
75:31 - and
75:32 - put in the total number of jobs here
75:35 - num jobs
75:43 - 245 cool
75:47 - getting very close to being done with
75:49 - the front end here um
75:51 - oh cancel that uh
75:54 - okay now let's implement the actual
75:57 - pagination
75:58 - um
76:01 - and we could do that by just creating a
76:02 - slice that we're gonna map over instead
76:04 - of the list of all jobs
76:09 - uh jobs on page
76:12 - which is just jobs slice
76:15 - okay let's think about how to do
76:18 - this first number is going to be
76:25 - okay um
76:27 - yeah
76:28 - so
76:34 - active step let's keep in mind is our
76:37 - page that we're on now
76:39 - so the lower bound is going to be active
76:41 - step
76:42 - times 50
76:44 - and the upper bound is going to be
76:46 - active step times 50 plus 50.
76:54 - now all we're gonna map is
76:57 - uh jobs on page not the full list
77:05 - and um now we only have 50. so much more
77:08 - navigable
77:10 - in terms of what's being rendered and
77:11 - then if we go to the next page
77:14 - it updates next page updates
77:17 - sweet
77:20 - all right that is our pagination done
77:23 - uh now all we need left
77:26 - is this pop-out modal
77:32 - and then our front end will be
77:37 - all we need left is the pop out modal
77:39 - and our front end will be totally done
77:42 - uh
77:43 - so what i want to do is click on this
77:45 - and then it'll give me a more detailed
77:46 - view as well as a link where i can apply
77:50 - so the first thing i want to do is add a
77:51 - hover state to this job div
77:55 - with a hover sudo class and css
77:58 - and then i'll just make cursor
78:01 - pointer
78:04 - pointer
78:06 - and i could also make the
78:09 - colors a
78:12 - a gray color just so it's very clear
78:15 - that we are hovering over this page
78:17 - or over the the job that i'm indicating
78:21 - so that that doesn't look great but it's
78:25 - uh okay for now let's just make this a
78:27 - little bit of a darker gray than
78:29 - dark gray
78:30 - all sixes here
78:39 - all right so that looks fine
78:42 - um
78:44 - okay so there's our hover state now on
78:49 - on click
78:53 - we're gonna want to
78:58 - push that job into
79:00 - the modal state
79:02 - because we want to know which job
79:04 - specifically to display in the modal we
79:08 - also want to set a modal open flag
79:11 - to
79:13 - let the app know to show the modal
79:15 - itself
79:16 - i think this is going to make a lot more
79:17 - sense when i actually read it out
79:21 - so um
79:25 - i'm gonna add it to
79:26 - the
79:29 - let me think about this
79:31 - yeah i'm just gonna add it to the bottom
79:33 - of jobs below my mobile stepper and i'm
79:36 - going to pull another component from
79:38 - material ui to do that
79:40 - and you might have guessed it it's going
79:42 - to be a dialog
79:43 - component
79:47 - so if you go under feedback
79:50 - there's uh dialogues
79:57 - and i kind of already know the one i
79:59 - want because i
80:01 - there's a lot of them
80:06 - and it's going to be the
80:10 - slide in alert
80:17 - i just think this one looks pretty cool
80:20 - because you click it and then it
80:22 - oh
80:23 - wait that didn't slide in where's the
80:25 - slide
80:31 - okay so you can see there it kind of
80:33 - slid up and in
80:34 - my computer is going slow but
80:36 - uh it'll look cool
80:42 - okay so we have to import a bunch of
80:44 - these components for this one to work
80:49 - in a perfect world you would
80:51 - make this modal its own component
80:54 - and
80:56 - i think i will do that actually
81:00 - call it job model
81:07 - dot js
81:22 - let's bring it react
81:26 - export default
81:29 - function job modal
81:33 - and our prop is going to be called job
81:37 - returning jsx
81:39 - and
81:41 - importing everything i just copied
81:51 - also there's some forward ref business
81:54 - going on here but
81:56 - we'll just trust that works
81:59 - like the
82:02 - material ui docs say it does
82:05 - and uh
82:07 - let's bring all of this in
82:11 - to
82:18 - here
82:30 - i am going to delete these though
82:33 - or rather i'm going to move these into
82:35 - our parent component because that's
82:38 - where we want to manage
82:39 - the state from
82:48 - it's going to go in the jobs component
82:59 - um let's
83:01 - consolidate this down
83:11 - this is for pagination
83:14 - and then modal
83:18 - consolidate this down too
83:25 - uh okay
83:26 - now we want to import
83:30 - job model
83:42 - then uh
83:43 - put this at the top here actually
83:46 - job modal open
83:48 - is open
83:50 - job is
83:52 - okay
83:55 - now this is where we have to define our
83:56 - actual modal state
84:00 - um active modal active uh no selected
84:04 - job let's do selected job
84:14 - so let's do just one more state
84:25 - okay
84:26 - state
84:29 - starting out it'll be an empty object
84:31 - default state
84:34 - and um
84:40 - select job will
84:42 - occur
84:43 - when we click on a job
84:47 - on click
84:48 - let's set some more room there
84:51 - select
84:57 - select job
84:59 - job
85:00 - like that so there's a callback in the
85:03 - on click function
85:05 - that will run when we click
85:06 - and it's going to set
85:09 - uh the selected job to whatever job we
85:12 - click
85:14 - good start and then that selected job is
85:16 - being passed in to job model
85:22 - um let's just rename this to be extra
85:24 - clear destructure job and open
85:32 - and
85:36 - if there's no job title we know this
85:38 - hasn't been set yet so we just return
85:40 - nothing
85:42 - that's just protecting against a empty
85:45 - object
85:47 - and
85:50 - let's see
85:54 - oh yeah we also gotta
85:56 - pass in our uh oh well no we don't need
85:59 - this because this is happening one level
86:01 - up
86:02 - right
86:04 - and um
86:06 - that also reminds me we have to
86:09 - not only select the job but set the
86:10 - model to open as well
86:22 - and i'll click open
86:33 - and then handle close is going to happen
86:35 - here
86:37 - and
86:38 - like
86:39 - no
86:41 - and all
86:44 - close
86:45 - okay
86:56 - pull that out
86:58 - and um
87:00 - okay let's see what errors we're getting
87:02 - i'm sure this isn't going to work out of
87:03 - the gate but
87:14 - just got a typo there
87:22 - okay
87:23 - so if i click
87:26 - what happens
88:18 - all right
88:25 - okay we actually have to pass down
88:28 - this function
88:32 - like that and then we open job
88:38 - and
88:40 - we do that on click here
88:45 - because it wasn't running
88:48 - we need to we needed to put it on the on
88:50 - the child
88:53 - oh
88:54 - nice
88:57 - nice
88:59 - got it down
89:02 - all right
89:06 - so title
89:08 - now we can start putting in our
89:10 - our variables
89:11 - this job title
89:13 - um
89:16 - instead of just having that there maybe
89:18 - we also put the
89:20 - logo
89:23 - of the company
89:31 - so
89:34 - yeah let's make this fancy
89:38 - do a image source
89:44 - company
89:48 - job company logo
89:54 - and um
90:01 - detail logo
90:04 - in here we will do
90:08 - detail
90:10 - logo
90:12 - make it pretty small 30 pixels
90:15 - float right
90:20 - now back over here
90:22 - we of course want the company
90:28 - and um
90:30 - in the content
90:32 - we definitely want the
90:34 - description
90:41 - okay one tricky thing though you'll
90:42 - notice that the
90:45 - description is in html it's an html
90:48 - string
90:50 - so a trick with react is um
90:54 - if you want to actually render html from
90:56 - a string it's considered dangerous
90:57 - because you can put in script tags and
90:59 - execute script on someone else's
91:01 - browser
91:03 - so if you want to allow this as the
91:05 - developer you have to use
91:07 - the dangerously set html inner html
91:12 - attribute like that
91:14 - and then you
91:17 - pass in an object with uh
91:19 - the key html
91:21 - equals whatever you want your html
91:24 - string to be
91:27 - and that'll do the trick but
91:29 - it's
91:30 - again dangerous so use it sparingly
91:36 - as for the
91:38 - buttons at the bottom
91:41 - let's change this one to
91:42 - apply and
91:45 - this will just be a link to
91:47 - the original job posting for now
91:50 - so we'll wrap this in an anchor tag
91:54 - a
91:56 - href uh wrap it in anchor tag
92:01 - of
92:02 - job.url which is the link to the
92:04 - original job you see here
92:08 - closing anchor tag goes on the other
92:10 - side of the button maybe we don't
92:12 - actually want this button to close
92:15 - the modal
92:17 - and then i'm just going to save
92:18 - everything we just did
92:24 - now i'm opening it again
92:31 - we do have an error but it's looking
92:34 - pretty good
92:39 - and
92:41 - i'm wondering if the
92:44 - the reason for this is that i just have
92:47 - to
92:48 - use the dangerously set inner html
92:50 - directly on this
92:54 - let's see if that works
92:57 - changing this to a self-closing uh
93:00 - tag
93:09 - and uh one thing i want to do also is
93:11 - put a break between the
93:13 - the title here and the company
93:15 - because they were both on the same line
93:17 - actually let's just do it like this put
93:19 - in a little hyphen to separate them
93:34 - when i open
93:39 - click
93:42 - okay awesome
93:47 - and uh
93:48 - if i click apply it'll take me to
93:51 - the
93:51 - company
93:53 - or the rather the original job posting
93:56 - which we may want to make a little more
93:58 - complicated down the road but for now
94:01 - it's good
94:02 - uh
94:04 - one more thing i want to do is make this
94:06 - link a
94:07 - target blank so it'll open in a new tab
94:12 - underscore blank so that'll open this
94:15 - link in a new tab
94:18 - all right as far as the modal goes i
94:20 - think
94:22 - we're pretty we're pretty much good
94:25 - so
94:26 - for now i mean that could be obviously
94:28 - we could add a little more pizzazz to
94:30 - this front end if we
94:34 - you know continue improving it over time
94:37 - but for now i mean it's very functional
94:40 - it does everything we wanted to do i can
94:42 - click on different jobs and get um
94:45 - get a different
94:46 - you know listing
94:48 - this opens and closes
94:52 - and
94:54 - these are all working with the logo
94:57 - and i can scroll it looks pretty good it
94:59 - looks pretty good
95:02 - so
95:04 - i want to say our front end is done
95:07 - all right guys we're so close to being
95:09 - done we literally just have to deploy
95:11 - our app and
95:13 - will be home free a lot of people are
95:15 - afraid of deployment but
95:17 - it's not that bad if you break it down
95:19 - into steps when i think about what we
95:21 - need it's going to be a domain
95:24 - pointing to a virtual private server
95:27 - which is hosting nginx now nginx is
95:30 - called a reverse proxy it connects your
95:32 - server to the public internet and
95:35 - provides like protection between those
95:37 - requests
95:38 - the other thing we're going to need is a
95:40 - process manager on our server after we
95:43 - install our dependencies that we have in
95:44 - our local environment so we're going to
95:46 - need the same things redis
95:48 - we're going to need node.js and then
95:50 - we're just going to need to send over
95:52 - all our files so they can actually run
95:54 - on our server in the same way they're
95:56 - running locally so let's do it i've
95:58 - pulled up a bunch of docs here we're
96:00 - going to need it's just going to be a
96:02 - lot of copy and pasting for server
96:04 - configurations and i'll put all these
96:06 - links in the description
96:08 - so like i mentioned first uh we need a
96:10 - domain i already bought one on google
96:12 - domains but you can buy a domain a ton
96:14 - of different places i just like google
96:15 - because the interface and it's because
96:17 - where my uh other domains are
96:20 - so
96:21 - i've opened my domain i already bought
96:23 - it a normal.com domain is going to be
96:25 - about 14 a year
96:27 - and the first thing we need to do is use
96:30 - the digital ocean name servers so that
96:33 - domain can be directed over to our
96:35 - server
96:36 - so you'll see that i have clicked on my
96:39 - domain i've opened the dns tab and then
96:41 - there's a name servers tab and i've
96:43 - clicked use custom name servers
96:47 - now i'm going to put that on pause and
96:49 - jump over to the digital ocean dashboard
96:51 - you can make a digitalocean account for
96:53 - free and it'll give you this dashboard
96:55 - where you can create projects which have
96:57 - resources inside of them
96:59 - a project is basically just a folder for
97:01 - a bunch of resources including domains
97:03 - and virtual servers and then all this
97:05 - stuff you see down here so i'm just
97:06 - going to create a new project and call
97:08 - it um entry level
97:10 - software jobs e lsj
97:13 - and
97:14 - it's a web application
97:16 - so i'm just going to create that and
97:18 - then like i said it's just a folder
97:20 - we're going to start with no resources
97:21 - so i'm going to skip that step for now
97:23 - but right away we're going to create a
97:27 - domain
97:31 - and the domain is going to be the one
97:33 - that we bought entry level software
97:35 - jobs.com
97:36 - so i'm just going to put that here
97:38 - and then add it
97:43 - and you'll see that
97:46 - i have the digital ocean name servers
97:48 - here so it's ns1 2 and 3. so i'm just
97:50 - going to copy this by clicking it and
97:53 - enter it here and we need all three of
97:54 - them so i'm just going to
97:56 - expand this out make this one two
97:58 - and then make this one three
98:01 - now when you change the name servers it
98:03 - could take a
98:04 - a little while to actually update it
98:06 - says up to 24 hours
98:08 - a lot of time for me it's instant but
98:09 - it's not always the case so you might
98:11 - have to wait and we'll see what happens
98:13 - here
98:14 - so next thing i'm going to do is
98:16 - actually
98:17 - create a
98:20 - droplet which is our vps virtual private
98:22 - server you can do this on any cloud
98:24 - provider
98:26 - other common ones are aws or google
98:28 - cloud
98:29 - but um
98:30 - on aws this is called an ec2
98:33 - and then i'm not sure what it's called
98:34 - in google cloud maybe just a vps but on
98:36 - do it's called a droplet which is just a
98:39 - server
98:41 - so what you have to do is choose your
98:42 - operating system i'm choosing ubuntu
98:44 - linux 1804
98:46 - and
98:48 - you can choose the size of your server
98:49 - you could always upgrade it later
98:51 - which requires a server restart
98:54 - so i'm just going to pick the 15 a month
98:56 - which has three gigabytes of ram and 60
98:59 - gigabyte of storage
99:02 - and then um moving down you could choose
99:04 - your data center where is your server
99:06 - physically located and then moving down
99:08 - you could do private networking's useful
99:10 - if you have you know multiple servers
99:12 - talking to each other but the most
99:13 - important part is here at your ssh keys
99:17 - you're probably going to want to do a
99:18 - new ssh key but i already have mine
99:19 - saved here you definitely need this step
99:22 - because you need it to actually get into
99:24 - your server to connect to it otherwise
99:26 - there's no way to get into it so you
99:28 - definitely need a ssh key and then uh
99:30 - feel free to look up a tutorial to set
99:32 - that up i'm not going to do it here but
99:34 - it's pretty easy to do
99:36 - and then i'm just going to call a
99:38 - hostname master because we're only going
99:39 - to have one server with all our services
99:41 - and then finally create this
99:48 - so this server is now being created it
99:51 - doesn't take too long and i'm going to
99:53 - go back into my domain and add an a
99:56 - record for at which is just the root
99:59 - domain and i want it to direct to our
100:02 - master server
100:03 - so i'm just going to create that record
100:05 - and that is step one in linking our
100:08 - domain to our server
100:12 - now uh once this finishes which it looks
100:14 - like it just did we got the green light
100:16 - here i'm going to copy the ipv4 address
100:19 - that's the ip address and i'm just going
100:21 - to ssh directly into this server
100:25 - by doing root at ip address just like
100:28 - that ssh root at ip address
100:32 - and it looks like it wasn't completely
100:34 - finished loading so i'm just going to
100:36 - try it one more time
100:38 - and now we type in yes
100:42 - and there we go so you can see our
100:44 - operating system here and now we have a
100:45 - command line in our server so we're
100:47 - actually in our server
100:49 - through a secure shell that's ssh so i'm
100:52 - just going to clear this out with
100:53 - command k and it's important to
100:56 - look at the command prompt to know where
100:58 - we actually are we don't want to be
101:00 - installing things on our local machine
101:02 - that we think we're doing on our server
101:04 - so always keep an eye on this i'm rude
101:06 - at master master being the name of our
101:08 - server
101:09 - all right so as i mentioned we have to
101:11 - install nginx to actually talk to the
101:14 - public internet and uh if we have a
101:16 - domain we also want to install an ssl
101:18 - certificate which gives us the https
101:22 - secure connection and that sounds
101:25 - complicated but it's really easy if you
101:27 - use the tool like certbot i have the
101:29 - documentation open here
101:31 - all you do is um you choose your
101:35 - software on your system and as you'll
101:38 - recall we used 1804
101:40 - and it'll give you a a series of
101:42 - commands to just enter into your
101:45 - server and it'll install pretty much
101:47 - everything you need so i'm just going to
101:49 - run these commands
101:51 - and a few of them require me to
101:53 - hit yes so i'm just going to do them one
101:55 - at a time
101:56 - make sure each one works while
101:58 - periodically clearing out my console
102:00 - with command k
102:01 - just to give us more space so there's
102:03 - one where i have to hit yes
102:09 - and let's just keep going through these
102:16 - so the nice thing about this certbot is
102:18 - usually you have to install nginx on its
102:20 - own but this will install our nginx and
102:22 - our certificate our certificate
102:25 - all at the same time
102:26 - and then we just have to update our
102:28 - nginx config and we'll be already
102:30 - serving our application to the uh to the
102:33 - public internet through our domain
102:39 - okay last command here
102:45 - yes
102:57 - all right
103:00 - okay i'm going to copy this
103:02 - sudo sir bot nginx command which is
103:05 - what actually runs the uh installation
103:08 - and then i'm going to enter that in and
103:09 - it'll take us through a series of
103:11 - prompts to actually install this so i'm
103:13 - going to put an email
103:14 - and then agree
103:16 - no
103:18 - now we need our actual domain we got to
103:20 - make sure we spell it right here entry
103:22 - level software jobs.com
103:35 - an important thing to take note of here
103:37 - is where it deployed our certificate so
103:40 - it deployed our certificate in sites
103:42 - enabled slash default which is a config
103:44 - file that we later have to edit if we
103:46 - want to make any changes to our domain
103:48 - configuration so um we're going to open
103:51 - that later to update the config but just
103:54 - keep in mind that location
103:57 - okay congratulations it was successful
104:00 - so let's test that and see if our name
104:02 - servers have propagated yet by going to
104:04 - the domain and that's exactly what we
104:07 - want to see welcome to nginx so this is
104:09 - a non-configured nginx but it is running
104:12 - and we're
104:13 - connected to our server from the public
104:15 - internet so that's great
104:20 - so we're done with sirbot and then like
104:22 - i mentioned we want to next edit our
104:24 - configuration file which is at that
104:26 - location etc
104:27 - nginx sites available
104:31 - uh default and i'm going to open this
104:33 - with the vim text editor by typing in vi
104:36 - and then the file location
104:38 - now vim is pretty cool if you haven't
104:40 - used it but it's basically installed on
104:42 - all unix operating systems that is linux
104:44 - and mac os and it gives us a text editor
104:46 - right in the console so what i'm doing
104:48 - here is i'm scrolling down to the second
104:51 - server block which is actually
104:54 - indicated by this server bracket
104:56 - notation and i'm going to look in here
104:59 - and i can see my
105:00 - url is defined here and being forwarded
105:04 - to uh basically port 80.
105:06 - so um within this location block i'm
105:09 - just going to completely delete what's
105:11 - in here
105:12 - that is
105:13 - inside the location block and then i'm
105:16 - going to put a new config in that is
105:18 - just pretty much something you have to
105:20 - copy and paste to do port forwarding to
105:22 - a local port on your machine so i'm
105:25 - going to copy this location here and i
105:27 - will put this link in the description
105:29 - where i'm getting this from but this is
105:30 - just a standard configuration for port
105:32 - forwarding so i'm just going to paste it
105:34 - right in
105:36 - we have that and then the other thing we
105:38 - need is to put this outside of our
105:41 - server block which is actually the port
105:44 - that we're forwarding to port 80.
105:47 - so sorry i messed that one up actually
105:50 - undo
105:51 - um go in
105:53 - to make a little space
105:55 - and then
105:56 - i'm gonna paste that in there so we're
105:58 - forwarding localhost 5000 to port 80.
106:00 - that's what this upstream is doing
106:03 - so i'm going to save this with colon
106:05 - escape colon wq
106:08 - and that saves the file and then i'm
106:10 - going to do sudum sudo system control
106:12 - restart nginx
106:15 - and that just restarts our nginx no
106:17 - errors
106:18 - um okay so that's pretty good
106:21 - um
106:22 - now let's keep moving and install our
106:26 - dependencies on our machine
106:28 - so
106:30 - i'm going over to this other tutorial
106:32 - how to set up node.js on ubuntu link in
106:35 - description and i have to install
106:37 - actually the node.js version that we
106:39 - need which is at least six to run uh
106:42 - create react app build so i'm changing
106:44 - directory into the home directory that's
106:46 - the squiggly line then i'm curling this
106:48 - file
106:49 - now i'm just running the script that i
106:51 - received from this file uh curl making a
106:54 - request to download some dot s h file
106:58 - which
106:59 - includes basically some setup
107:01 - configuration for installing node.js
107:03 - clearing the terminal and then actually
107:05 - installing node.js through apt-get which
107:07 - is
107:08 - a linux equivalent of homebrew that's
107:12 - for installing just pretty much any
107:14 - software
107:15 - okay that worked and now
107:17 - i want to install this build essential
107:20 - file which is or rather module which is
107:24 - a
107:25 - helps us run certain npm packages so it
107:27 - just makes sure we have compatibility
107:30 - with every um
107:31 - npm package that we want to use
107:34 - okay next let's actually test out that
107:36 - our port forwarding is working by
107:39 - creating a test file called hello.js so
107:42 - i'm going to do that with them here
107:43 - hello.js and then insert this uh
107:46 - code and i just want to actually change
107:48 - that to 5000 which is what we set up our
107:52 - port forwarding to as you might recall
107:55 - and then i'm just going to save that
107:56 - with escape wq and then run it with node
108:00 - so node hello js
108:02 - and it's running so let's see if that is
108:04 - actually
108:05 - being forwarded correctly and it is so
108:08 - that's great
108:09 - okay just scrolling down this page and
108:11 - i'm going to stop that server the next
108:12 - thing we need to do is install pm2 our
108:15 - process manager which allows us to run
108:17 - all our services our api front end and
108:20 - worker at the same time without us being
108:22 - actively on the server so it'll run them
108:24 - restart them capture logs and do a lot
108:26 - of stuff that's
108:27 - pretty cool for actually managing our
108:30 - server processes so i'm just going to do
108:32 - oh no we don't have npm installed
108:35 - so of course um
108:36 - you know no tutorial is perfect so
108:39 - let's just install npm as well
108:45 - it normally does that when i install
108:47 - node but i guess i'm using a different
108:49 - uh set of commands this time to to do
108:52 - this so hopefully this just um
108:54 - doesn't give us any problems later
108:58 - and uh let's see if that worked
109:00 - okay sweet so let's do the and the same
109:02 - command as before npm install gpm2 oops
109:10 - okay and then to run our react app we
109:12 - all we need to npm install g another
109:15 - dependency called serve
109:19 - okay so we got those two done
109:22 - and let's just test pm2 with our hello
109:25 - js file so let's do pm2 start lljs
109:29 - and
109:30 - we'll see our pm2 daemon is spawned so
109:33 - now we can see our pm2 processes with
109:35 - pm2 ps
109:37 - and
109:38 - there's a status cpu and memory which is
109:40 - pretty cool that we get those stats in a
109:42 - dashboard and then if i refresh my page
109:45 - the app is still running in the
109:46 - background so that's great
109:50 - so if you remember the steps we outlined
109:52 - at the beginning the next thing we need
109:54 - to do is actually get our files onto
109:56 - this server and once we do that we
109:59 - should be pretty much done so i'm going
110:00 - to open up a second
110:02 - command window here and this is
110:05 - you'll see in the command prompt my
110:07 - local machine so what we want to do is
110:09 - send through the files that we made in
110:12 - local development before we do that i'm
110:15 - going to open up this
110:16 - uh set of files and make one critical
110:19 - change that will allow us to access our
110:21 - api on our local server
110:25 - and that is to basically change this to
110:27 - just a relative path
110:30 - so i'm changing this to just slash jobs
110:34 - and actually i want to change it to be a
110:35 - little more clear to be slash api
110:38 - jobs now that means we also have to
110:40 - change our api route which shouldn't be
110:42 - a problem slash api slash jobs and we
110:44 - have to make one change in our package
110:45 - json and that's adding a proxy config
110:48 - which allows this to still work on local
110:51 - development this doesn't affect anything
110:52 - on production so um
110:55 - proxying all api routes to a
111:00 - target
111:01 - of
111:01 - localhost
111:03 - sorry
111:04 - need the double quotes there http
111:06 - localhost uh 3001 was our api server i
111:10 - believe
111:11 - and i'll save that and again that just
111:13 - helps us you know still develop in the
111:15 - same way but we need to make one config
111:18 - change for the production server as well
111:21 - so that was our change in um in our
111:23 - files and as i mentioned i'm going to go
111:26 - actually back into that nginx config
111:28 - file etc engine x
111:31 - sites available
111:33 - default and i have to add one
111:35 - additional location block just for the
111:38 - api
111:39 - route because basically what this is
111:41 - doing is appending the relative path to
111:45 - the end of our url and nginx needs to
111:47 - know to direct this to actually port um
111:51 - 3001
111:53 - on when it's being run by the browser so
111:56 - it's just basically a different port
111:58 - forwarding for a different path
112:00 - and
112:01 - the way we do that is by
112:03 - getting a proxy pass
112:05 - to
112:06 - http localhost
112:08 - 3001. semicolon is important i forget
112:11 - that a lot so
112:13 - escape wq to save and then system
112:15 - control restart nginx
112:20 - all right so we're about to send through
112:21 - our files to our production server i'm
112:24 - going to change into my client and then
112:25 - i'm going to do an npm run build to
112:27 - create a production build of my react
112:29 - app that we we just built
112:32 - this includes everything from our
112:34 - package.json and also our minified
112:37 - version of our javascript files and our
112:39 - bundle js
112:41 - now we can see that we have a build
112:43 - folder
112:44 - and
112:45 - we send this through the same way that
112:47 - we actually ssh in
112:49 - with a command called scp
112:51 - and then i'm going to put in an r flag
112:54 - for recursive so it'll send anything
112:56 - recursively within the build folder
112:58 - to
112:59 - our uh server url i'm just going to copy
113:02 - that again from here
113:04 - by going to master
113:06 - oops that's not good
113:08 - okay no it hasn't been destroyed false
113:10 - alarm uh copy the ipv4 and then do the
113:14 - same syntax root at our ipv address and
113:18 - then uh
113:19 - i need to put in a colon and then the
113:21 - home directory so where are we sending
113:24 - it to on our server and we just want to
113:26 - make sure it's going to the home
113:27 - directory
113:30 - okay so that's sent through all our
113:31 - files from the build folder and now when
113:33 - i ls inside of our server you'll see the
113:36 - build folder is there
113:38 - so that's great
113:39 - so um
113:40 - let's start this up we're not gonna have
113:42 - any data running yet because we don't
113:44 - have our workers started on our server
113:46 - but um let's
113:48 - start this up by pm2 stop hello this was
113:51 - our test server we know it works and
113:53 - then we'll do pm2 delete hello
113:57 - and now i'm going to do a special kind
113:59 - of syntax to actually serve our build
114:03 - folder publicly and that's going to
114:05 - combine the serve package we downloaded
114:07 - with the pm2
114:09 - process manager so i'm going to do pm2
114:12 - start
114:13 - serv
114:14 - dash dash s build
114:18 - this is just saying use the serve
114:20 - package and run this command dash s
114:22 - build under serve it's
114:25 - the same as pm2 starting uh just running
114:29 - this command serve as build and in fact
114:31 - let's try this first serve as build to
114:34 - see if our application is going to be
114:36 - served
114:38 - so it says serving local and network to
114:40 - the port we're forwarding to and there
114:43 - it is
114:44 - already uh we can see it's kind of
114:46 - working here's our domain and then
114:48 - here's our front end with no data but
114:50 - like i just typed we're going to
114:53 - run this in pm2 with pm2 start serve as
114:56 - build
114:58 - and you'll see it created under a name
115:00 - serve that's probably not the best but
115:03 - we can keep that in mind this is running
115:04 - under the process serve and it's online
115:07 - and then when i refresh it's still
115:08 - running so that's cool
115:10 - now we have our front end running so we
115:13 - have to send through our worker and our
115:15 - api files so i'm going to clear that out
115:18 - this is our local machine again change
115:20 - directory out to our home directory and
115:22 - then we want to send through a cpr
115:26 - let's see api
115:28 - and i'm just going to hit up a few times
115:30 - to get this command back i'll send
115:32 - through the api folder
115:34 - to our home directory then i'll send
115:36 - through the worker folder
115:41 - then i'll also send through package.json
115:43 - to get our dependencies namely express
115:47 - and the redis client
115:50 - so back over in our vps i'm you going to
115:53 - need to install redis so i'm just going
115:55 - to do sudo apt-get install redis
115:59 - yes
116:05 - and we can test whether that installed
116:07 - by doing redis cli as we did on local
116:09 - and it seems to work so exit
116:11 - and now that we have all our files here
116:13 - let's just check that we do
116:15 - let's do npm install to get those
116:17 - dependencies
116:22 - and
116:23 - now let's start our worker
116:26 - or rather let's start our api bm2
116:29 - uh start api
116:31 - index.js
116:32 - i'll do
116:33 - name api
116:36 - and then we'll also start our worker
116:39 - pm2 start
116:43 - index.js name worker
116:48 - okay everything seems to be running
116:50 - but how are we sure that our work is
116:52 - working well let's do pm2 logs
116:55 - worker just to see if those
116:57 - logs that we set with the console logs
117:00 - that actually give us the indication
117:01 - workers working
117:03 - are actually going to run so
117:05 - you'll remember that we did a cron for
117:07 - every minute so let's see if those logs
117:10 - are actually going to run after a minute
117:11 - so we just got to wait and see if that
117:13 - happens and then once that happens our
117:15 - redis will be loaded so
117:17 - in theory we should be able to refresh
117:19 - our page and then see all the jobs there
117:22 - but right now we just gotta wait the
117:24 - suspense is is kind of killing me here
117:27 - uh i feel like it's been longer than a
117:28 - minute i don't know if it's gonna work
117:30 - or not
117:32 - but i actually have faith okay
117:37 - there we go
117:41 - come on worker you can do it
117:46 - okay it says success okay
117:48 - and uh so now our reddish should be full
117:51 - if i refresh
117:52 - there's all our jobs amazing so we have
117:55 - a deployed application everything looks
117:57 - just as it did on local if i click into
117:59 - these jobs
118:00 - let's see
118:01 - uh it works there's our description logo
118:04 - and everything and then if i click apply
118:06 - it'll take us to that position
118:08 - so that's pretty cool guys we just
118:09 - deployed our whole app and it didn't
118:11 - even take that long i feel like that was
118:13 - around 30 minutes or so
118:15 - all right guys that's it we basically
118:17 - built a whole production application in
118:20 - less than 100 minutes and we got it
118:22 - deployed and now it's running on the
118:24 - public internet at
118:25 - entrylevelsoftwarejobs.com so go check
118:27 - it out
118:28 - but um i'm thinking next there's a few
118:31 - critical things we have to do before
118:32 - we're ready for like a full production
118:35 - launch so to speak this was just our
118:37 - base framework that we're building more
118:38 - features off of but at minimum i think
118:41 - we need a few more data feeds and we
118:42 - need to make our algorithm a lot more
118:45 - robust prevent it from breaking on
118:47 - errors as well as filtering down those
118:50 - jobs a lot more because if we get in
118:51 - five feeds we're just gonna have a huge
118:53 - amount of jobs and we really wanna make
118:55 - sure those are entry level jobs so i'm
118:57 - thinking that we
118:59 - parse through the description and look
119:00 - for like three to five years of
119:01 - experience and take those out i think
119:03 - anything less than three years would
119:05 - qualify as an entry-level job so
119:07 - again we're gonna have to keep working
119:09 - on the algorithm and then otherwise
119:10 - we're gonna want to add a little bit of
119:12 - monitoring logging different things like
119:14 - that but that can all come later our mvp
119:16 - is done and our base of our application
119:19 - is done so that's pretty cool so anyway
119:21 - hope you learned something um let me
119:23 - know if you have any questions and i
119:24 - will talk to you guys soon

Cleaned transcript:

what's up guys back today with another longer video which is to build a job board app that could actually be a real startup that people use there's a lot of different places to find entry level or junior developer jobs on the internet for example github jobs stack overflow jobs you have angel list you have indeed but filtering through those especially because you kind of have to spam applications for your first job can take a long time so the good thing about all these job boards is they have public apis for the most part you always want to start with an mvp that is the minimum viable product today that means we're going to start with a single data feed that is a single job board api feeding into our app and then finally we're gonna have a super minimal simple front end we're gonna do this in react and material ui on the front end we're gonna use an express server redis for our data storage because we're not writing or persisting any data that is not part of the job feed and then finally a node cron job to fetch these jobs and refresh them at a certain interval which are going to be filtered through an algorithm so let's draw this all out to get a better idea of our plan here's our front end what we basically want here is a list of jobs this is going to be pulling data from our api and that will be express and then this will pull from our store which is actually going to be redis and redis will be populated by our cron called a worker which is pulling from one or more apis it's going to be eventually multiple this is going to be job uh board apis so like in let's say indeed we have github we have stack jobs and this is going to be filtered through our algorithm we're filtering down the jobs getting rid of the senior jobs getting rid of the manager jobs and eventually when we make it more complicated we could even look through the description for years of experience and create uh search indexes and different things like that but again the minimum is just going to be pulling the jobs in and filtering them down okay so this is our plan let's start with the front end i know a lot of you guys like react and it's gonna actually be super simple let's just do a create react app to get started uh i already have a folder our directory here called junior dev so let's uh do a create react app and then call it client you guys know that i love material ui so let's install that as well once we get into our client and let's do yarn add okay that's done and we will start our react at okay let's go through the stuff we can actually delete no tests you always want to write tests in real life but not today logo and also clear this out here now let's open the material ui docs let's get our component api and let's get a title for our page typography h1 let's just copy this and instead of putting it directly in app let's make a new component for jobs and then let's make a new component for a single job all job which we'll use in jobs and then let's import react exports default functions okay in this we will use typography okay so just to explain what i'm doing here i am making a separate component because i want our app just to hold our state and then jobs will actually hold our component tree our render styling and app will hold our application state our use state and call our hooks for kubota did mount and for state that was really confusing sorry we're using typography here and let's do variant typography variant okay i'm naming our page entry level software jobs i think it's a good name then save import jobs throw that in there like this okay that is some huge text but we're gonna leave it for now within jobs we already know we're gonna um import job make this a similar export we'll just copy this whole thing almost sneezed okay turn div and then this will just be a single job row which will put on a class name of a single job and then we'll just do this in advance because we know we're going to eventually have to write some css to style this stuff let's make a job list should probably actually be matching our component name just to change that back jobs and then job okay so let's just say that we're passing down some props for all our jobs from our uh app which is holding our state let's just do it like this and let's do some mock json that we might return from our api swe software engineer one and company google um there's gonna be a bunch of fields but let's just leave them like that for now and my mock job so we don't get it mixed up mock just being mock json data and it should work then we can do jobs map job this will return a job job job equals job hopefully that's not too confusing okay now you could just hear the structure job in the box but job.title let's see if this works there it is job.title and job.company and let's actually add some css for job and just make it a display flex next direction oh that's right it's always freaking hard switching from jsx to javascript okay there we go boom i'll leave it like that for now we can add more stuff to this this list if we want like this facebook apple it'll map it out for us let's give that a little bit of margin a little bit of padding let's do a 10 pixel top left right zero and then padding will be the same okay not too bad not too bad so our front end we could call this like kind of done let's call this done for now and let's return to it after doing some full stack stuff so i'm gonna collapse our client let's see what our actual data feed is gonna look like coming from uh our source which i'm just gonna use as github jobs because i know that has a really good clean api output that you don't need a key for or anything so api github jobs open it up you can see some examples here okay so it says that the api supports pagination it'll return 50 at a time and you could do it by adding a parameter to your queries before jumping ahead we just know we want these json representation of these jobs so we can manipulate it with our node worker so what i'm actually going to do is call a similar url like this in our node side which is going to give us output like this just by eyeballing this i could see that it is somewhat matching what we already wrote out here in app.js where there's a title somewhere yes like that senior full stack node.js developer and there is a company somewhere and we can also tell in advance that location's going to be an important field too but basing our analysis on this we could start to model kind of what our worker is going to do as well as how we want our api to act as well so looking back at our plan let's actually just make a folder for uh all our boxes here so this is the client right api is going to be simplexpress server and then the worker is going to have our algorithm and it's going to be calling our apis on a cron job which is at a set interval so maybe every hour in the day we want to refresh these apis refresh our redis and make sure that everything is up to date there's no expired jobs that the companies don't want people to see anymore and we're basically staying in sync with whatever is in uh our upstream data source so within worker i want to create an index.js which is going to manage all our worker tasks and i know already that we're going to need the cron node library it's just going to help us run simple cron jobs which is what i was saying before is the it's the way you run a task on an interval basically forever if you want to opening up a new terminal tab going out to our main directory and within our main directory i'm just going to create a package json which is going to be accessible from all our different folders so you can see that was created here and then we just want to install cron as a dependency okay now inside a worker i just this is the way i pretty much start with every uh with every app you just copy kind of the basic usage and you build your way out from there so all this does is it's running a node process where we're importing the library and then this is called a um cron shorthand cron syntax something like that uh cron.guru you can see it here okay so this site is really useful no not this site crown guru crontab guru okay so these asterisks are called a cron schedule expression and it's basically symbols for how often you want your job to run you can test it over here slash one that's actually every minute this is every second this is every second minute it's every third minute right so you just have to play around with the syntax that'll tell you here how to do it and then you could do kind of whatever interval you want so you could do like once uh a day i think one yeah so you got it you just got to mess with it to do what you want and then you could just google exactly what you want to do and you get pulled the chronic especially from that but this is kind of a playground to get the chronic expression you you definitely want to do all right so let's test this um this basic implementation of cron to just see if it works and in our real production app this is actually going to run every second not every second every um let's say hour to fetch our jobs so this will fire off some function which is now being passed in as this a anonymous function that is just console logging but what we're eventually going to put in there is our script to fetch the jobs and then filter them down so in this worker folder i'm going to make a github um or rather let's do it this way i'm gonna make a tasks folder and then we'll do one called fetchgithub.js and we just want to play around with that you know github api and get it to do what we want so the good part about the github api the the good thing about the github api and part of the reason why i picked it is because it is pretty much all developer jobs so we don't have to filter out for developer jobs we could just assume they're all tech jobs and then we will take the ones that are just junior software engineer or more specifically not senior or not manager so we know our url is roughly going to look like this to do a backend url fetch request i'm going to install the node fetch library which is the same as the clientside fetch library but you could use it in node.js okay so we're just required like that then let's do an anonymous async function just to actually now let's do it this way export default async function just did a hey siri for some reason nope okay so fetch github there and i'll just call it here just for testing purposes and within here let's do a jobs await etch and we'll do asurl equals this without the query string so let's break this down a little bit we have a question mark then a description equals and ruby and page equals one so this is called a query string here it's a way to pass parameters through a url so so we're passing parameters to the server through the query string syntax which is key equals value like this so in our case we're going to want to iterate through the pages that is we want to get all the results from all the pages and combine them together the way i think we want to do that is just by leaving this like this so this is just our truly base url and then let's actually see what happens let's see how many jobs we get back just by doing this and then logging out jobs length keep in mind that this function is going to run because we're calling it here when we just run a node on fetch github.js okay i forgot we still can't do that and let's just do this okay undefined let's console like this jobs oh i forgot we also have to do this this is just our raw response this is jobs press.json still not resolving because this is an async function too okay 50. i already kind of knew this going in but if you put no parameters here it just gives you the first page only so we have to add a query string for each page and iterate through to get all the results until we get back an empty page best way to solve this is to keep adding one to the page number so we start at zero then we try page one then we try page two until we get back a page with zero results so if this is the way we do it for one page we're just going to want to run this same subroutine for every um page that's not empty to make this a little more clear i don't like really how we've written this out so far uh let's just do it like this maybe it's just me being lazy so while the uh page result count is not empty we're going to do this and we have to keep track of the page we're on as well as the result count so let's make uh result counts and not zero value because if it's zero it'll break our loop so let's just start at an arbitrary value one and then after we fetch the first page it'll be 50 then it'll be whatever the second page is until it's zero at which point this while loop will break so we'll initialize it to one and then let's also initialize our what where are we going to call it on page equals zero we'll start on page zero okay so base url we'll do a template literal here and then slash or instead of slash we'll do our query string h equals on page okay so we loop we get our jobs we get our jobs length we're gonna want to also push the jobs we get back into an array called all jobs let's do all jobs push the jobs we get back from that page let's keep this in here just so we know what's happening and then finally increase our onpage value okay again just to review setting our result count to a nonzero value starting on page zero creating an empty array to hold the results we're getting back from the api we start a while loop that's gonna run as long as we're getting results back by increasing one page at a time so getting page zero getting page one getting page two here's where the url is constructed base url from up here and then page starting at zero pulling out the json from the response putting that json in our array logging out how many jobs we got back increasing the page count repeating until we run out of or rather we run into an empty page finally we have all our jobs so let's just log out how many jobs we got total which we're going to eventually be returning all right now these console logs give us an idea of what's happening in our function here otherwise we would have no idea since we refactored a little bit we have to call the function again let's see what happens hopefully this is not infinite loop please oh oh oh no okay okay what happened there i guess we didn't break oh because we're not setting result count okay so we got to do this result count equals length okay there that should work now but for the most part good okay okay so there's one thing we also overlooked i think let's look back at this this is a sample response we're getting back and if we look at this whole object let's just assume this is like page zero it's coming back with an array but then we're pushing that array directly into our all jobs so this is actually creating an array of arrays whereas really we want a flat array just a single array holding all these job objects so the simple way to do that is to spread that in with a spread operator we're just dumping the array into another array by spreading the values in if we run that we're totally gonna see this is gonna work super confident why i did not work that time that's weird interesting okay that's probably something we have to debug maybe it was a weird response from the server so our fetch github function is done we're returning all our jobs now uh i think we actually want a way to save these jobs into a local storage that we can retrieve through our api and actually before we do that i'm getting ahead of myself but we want to call this entire function on an interval so um let's go back to crontab let's just call it every uh no let's yeah let's let's let's call it uh every minute make sure i'm doing that right yeah every minute every minute here we'll import our fetch github function patch github boom just throw it in here and the beauty of this is we can repeat this for as many um functions as we want right we could we could fetch github we could fetch stack overflow jobs we could fetch indeed and we could create a crontab for each one that is not dependent on one another to succeed or fail so these could be all trying in parallel and they could also um give us kind of a rolling refresh of our jobs so maybe one could run every 10th minute of the hour one could run every 20th minute and it'll just continuously refresh without hitting any one of these apis too often let's test the uh the cron aspect of that i just turned it on and it's running for the first time now but then it should run again after a minute okay and that's not going to work because i actually ran directly to fetch get github one but if i do index okay it's gonna wait a minute oh okay i messed up i messed up okay so i copied exactly over from cron tab every minute okay well i guess if you put six stars it'll do seconds and if you put five it'll do minutes so lesson learned there so we'll see if that works after a minute and in the meantime let's uh let's talk about storage and like i mentioned earlier we're going to want to store these jobs actually in redis now i already have redis installed but you can install it through homebrew pretty easily just if you don't have homebrew installed you look up homebrew installation you just it's a simple easy download and then you can install anything with a brew install for example redis and then it'll basically install redis under the hood in your system in a directory called uh the brew services so then you hit start and stop restart it from from that position jumping back up to this you'll notice that it worked after a minute so that's awesome so let's see if it runs again after another minute i just cleared the terminal there with command k but like i was saying about redis i've already installed it with brew install redis and you can install it yourself if you don't already have it there are a couple different ways to install redis but it should always connect the same way uh since i'm starting a new project here i just want to make sure my redis is clear so um oops there's a command line command that allows you to connect to the redis client and then we want to clear all our our redis with a uh it's a similar um language to like a sql where you can uh basically this is like a drop table and then we just cleared everything out of our redis we got a fresh start and you'll see it ran again after a minute so let's just we could stop that we could leave it running whatever i'm just going to stop it but we know our crontab refresh is working every minute with our fetch github okay i have redis installed and um if you're not familiar with redis it's just a key value store so it's an inmemory database my sql is a little bit different because it's on disk but redis is just memory so it's not persistent and that means if your system shuts off you lose all your ram so it's not a fault tolerant database it's not a durable database and the upside is though that it's really fast it's kind of like an object in javascript you just if you have the key it's constant time access you just pull it out of your redis store and then you can serve it up in our case jumping back over to these um these job uh json that we got from github you can see every job has a uuid which is a guaranteed unique id because it has so many characters and it's random characters so it'll be guaranteed unique every time every job has one of these ids so that's a natural candidate to use as a redis key i'm thinking within redis our key is going to be this id and our value is just going to be the whole job object so it would be a string version of this that we can then pull out we know it's already json so we can just stringify it and then when we pull it out we'll just parse it into a javascript object now the slightly tricky part of this is okay how do we access redis through our node um worker right because we have all the jobs here right now we're just logging them and throwing them away but we want to put them in redis and the answer to that is there's a node client library to access and connect to and uh do all the redis actions so it's an interface that node uses called the client that's a library that will do everything you need to do in redis and you can do it through node with this library so i'm just going to search for node redis and then we will install it just like the same way as before and i'm gonna do exactly like i said before what the getting started docs say i know this is going to be better if we promisify this library because you can see right now that we have all the redis commands here like set is setting a key and then there's one called get which will retrieve that key just think of it like an object so if you put in key a and then the val is one then you do client.get you'll retrieve that one from the a key set and get functions are async so it's not going to be in line with your javascript code and that's just the name of the game because redis is not in javascript so there's no way to know when its response comes back programmatically in line it's it's going to wait redis could be over network so it's going to take an indeterminate amount of time to serve the request and then that's going to come back to the function call in this format so this is the standard callback format and node error and then data replies is going to be the response now you can just ignore all of that because we're going to promisify this library with the promisify util in node which will convert callback functions into promises that we could use await or then promise chaining with and so on let me just do this i'm just literally copy pasting it from the docs and get it async is the example which is converting that client.get function to a promise i'm going to put this below the client variable declaration so it works and i can tell you now that we're also going to need a set async we were thinking of setting each job as its own item in redis right which would be fine if we were ever querying for those keys but we're not we're in the mvp gonna just get all the jobs serving back to the client and then we'll let the client handle pagination or any kind of showing and hiding of these jobs so until we do that or rather until we decide we want to optimize this query on the server we could actually just set the response from github as the value of a single key it'll be a huge text blob and we just serve up to the front end and the only reason we're doing this is because of performance we don't want to have to wait for the api to respond every time we uh serve a client request so redis is only a buffer that's an intermediary holding this data that we're only fetching once every hour because the jobs aren't refreshing that often so that's a longwinded way of saying that once we create these this all jobs um array we actually are just gonna throw the whole thing under one key and we'll call that key github also let's let's hold on to this um let's hold on to this um get function in our head because we're gonna we're not gonna be pulling out of our redis until we're in the api layer which is serving the um the jobs request man i have kind of a stuffy nose okay let's do the set async and this takes a value github or a key rather github then a value will be our all jobs we might need to stringify that but we'll test it out okay let's run node worker tasks that's github and uh let's see if that works we can test it like this get github like that we still have our redis cli open there okay so far nothing happened that's not a good sign and here's why let's call our function just as a test i'm gonna take that out okay okay i hope this uh sniffly nose hasn't been annoying you guys too much it's actually annoying me and i hope it's not super loud on the microphone okay the get command contains the argument of type object okay i didn't like that at all um i'm not i'm not using get so i don't know what it's talking about here but um okay i know now set and then okay let's try that okay set contains argument of type object and as we expected this is like an array i think this is gonna work to be honest nice okay github there it is radis is working our fetch worker is is totally great we'll leave these logs in just so we have that telemetry that observability but everything is working oops okay just make sure that's still working with our crown tab here oops so we're supposed to remind me to take that out leave that running and we'll jump over to our next piece if we look at our plan api so let's just review this oh actually so we've got this api part done we still need this we still need this and then we'll improve our front end last so filter algorithm all right let's look at what's in our store here so we're getting jobs back and um like i said we we want to start with a really simple algorithm that is just filtering out by position so just taking like eyeballing this i can see that in the title we can gain a few insights into what kind of job it is right if we see a senior in the title we know it's not going to be a junior developer job if we see manager in the title we know it's not going to be a junior developer job another common thing we might see is like a senior abbreviated as sr i didn't see it in there but i know that's it's done so maybe if we see that word sr dot at all then we um we want to filter it out so this is our set in redis so we're gonna want our filter before that that's all pages filter you can always factor this out to a function later but for now let's um let's do it this way okay new array junior jobs it's going to be fill a subset of all jobs and we're going to filter based on a few different parameters looking at each job okay we're going to use one super important thing here and that is the string that includes function and we're going to use that on job title so if the job title includes or rather stop siri okay let's do it this way actually job title equals job title to lower case it's important i think the example we saw in the terminal was in all caps so we want to reduce that kind of variation by just lowercasing the whole title we also don't have to keep accessing the object if we just store it in a variable so this is this is for one job and um we're going through 392 so we're gonna have to go through each one of those jobs real fast that's part of the reason too why we're doing this cron method is because if we fetch the jobs on every front end request we'd have to do this whole filter thing every time and it's going to be the same logic so in general when you're doing the same logic for every client request that's definitely a good case for caching or even database denormalization so replicating data in your store that's a commonly a common read pattern rather all right we could be more curious about this but let's just make it super clear and have a default case let is junior equals true then there's going to be our logic then we're gonna just return the result is junior okay now this is gonna be our main algorithm logic here okay so if um job title includes senior we gotta remember we changed it to lower case or job title includes manager or job title includes sr dot senior or another one i'm gonna and i thought about this before i'm gonna put in is architect because that is generally a more senior role as well that you're not gonna be able to do as a junior developer that's something you have to gain a little skill from then you can design whole systems and you may or may not be the one implementing them as well but here's all the cases we want to filter out if any of these are true is junior equals false okay so this is the most clear we could way we could do it but i'm actually going to cut this part out and then we'll do return false otherwise we don't actually need else just if that didn't happen return true okay now we could test in our in our code how many get actually filtered out by this by um console logging filtered down to junior jobs okay and we do uh move this one up here actually i think yeah we'll leave that in make sure we're adding junior jobs in here only consolidate success okay just that's bothering me okay restart oops restart clean slate we'll get this extra log we'll see how much damage our filter does and then we will still set that in redis and then we can make sure it's still in there please work okay nice cool so if we're filtering out okay we went down from 392 all the way to 245 so we're filtering out almost uh one third of the jobs just with these words which i think is already making our app useful to some degree obviously the more complex we make this algorithm we could search through the job.description look for years of experience there's definitely more more titles we can include here but that would depend like what we see in the json um we can kind of pluck words out of there be like oh yeah this was obviously a senior term too and then add it to this list but for now i think it's a good start okay let's see back in our planning we just did our filter algorithm or very basic version node work is done so this whole section is done redis is done api and then we'll we'll finish up with our front end and then finally deploy okay so let's actually just close everything open up api index.js just want a super simple express app express again same thing i said before uh just do that npm install and then from there you take the most basic example make my port 3001 because i know my front end is running on 3000. get a little bit of extra space here and um okay and then this route we don't need a slash we just need a route called jobs okay i love this part okay our express install went through over here let's do um let's just run a node on api index.js sample app listening on port 3001 and then if i curl which is just sending a request to something on the port 3001 slash jobs get the hello world back sweet okay this is going to be the simplest api ever and we just want to use that redis library we already installed and we're going to use the get which we already commented out and we already know which key we're gonna get because we only set one so that really simplifies it uh so we need to copy actually all this code and delete this because we don't need it here get the redis client get another instance of that here and then do the get async and this is where the async part is really going to come in handy to convert this route to an async function let me do jobs here wait get async github just hardcode that in now let's remember we stringified it so json parse and i'm going to actually undo this because we are just going to have to restringify it when we send it to our client but um in the meantime just to see the length and or rather see that the length matches our our length that we put in let's parse it and then let's do dot lake okay so it's kind of a lot that we did without testing it let's restart our server do the same curl oh man okay 245. i don't remember if that's how many we put in we're definitely getting a list of 245 which is a good sign now let's just try sending this back and see if we get that full uh stringified object that's exactly what we want and it's that easy so that's already done so i don't know how long it's been guys but with this simple of an api we can literally we've literally been able to create all this like in such a short amount of time we have a data feed and you can replicate like before before i go further you can replicate this in any this is like 90 applications if you have a data feed you have storage you have a worker that's doing some async task on an interval uh it's called batch processing you have an api that's called by front end this is like 90 of crud applications let's create read upload delete in this case we're only really reading from the front end but the backend is doing some more complex stuff including an algorithm the pieces that we're using are used in some way in almost every large scale application so doing this as an mvp is like a really good exercise all right let's push on i might be getting a little bit tired but let's keep it going okay so we have our api uh running let's keep this running all right let's just restart this so we have the uh log that we know we're listening and um i'm gonna go back into our client folder okay so we're back in our app close that we're back in our app function which we we mentioned we're going to put the state in let's pull this back up so make sure it's still running all good to call our api programmatically the same way we're doing with curl here we just need to call this url with a function that we're going to make called fetch jobs all it's going to do is use the browser version of fetch which we don't need to import because it's built into browsers like chrome let's um instead of hard coding do a job api url constant it'll just be exactly what we have over here since this is async we can use in a weight a weight const jobs equals weight of course this will be in json so we have to uh convert it to json let's do that call this res call this json goes await as that json and before going further let's just log that out okay how do we call this in our client to find my number used i know i'm getting there okay if you've seen my past videos i talked about react hooks these are replacing all react class components now we just have functional components and we've seen hooks for use reducer use state and all that kind of stuff since this app is just a very simple state it's a list of jobs i don't feel like i need to use a reducer and i know exactly the shape of these jobs as well so i don't need to do any reducer like manipulation and it's also very hierarchical and shallow application meaning i just want to pass down these jobs one level to my job's view component from this app state i started talking about hooks and we've used the used state hook a lot in my past videos but we're gonna use one that we haven't used too much yet here which is called use effect and that's basically uh replacing the component did mount or component did update function from past versions of react so i'm going to use it here react i use effect and then this function actually takes a anonymous function in which i can do some function calls some async function calls as well as a second argument which is the basically hooks that i want to watch to update but if i pass in an empty array this react i use effect will act exactly like a component did mount all right in inside here just gonna fetch jobs and um i also want to think about how i'm gonna store those jobs so um let's also do a used state hook jobs this is never jobs a lot so let me just do job list was react dot use state and update jobs react i use state and then i'll initialize this to an empty list which i'm actually going to pass in here so when i do that that should actually clear out all my um chops okay good because i'm initializing it to an empty list okay in here i'm fetching jobs console.json see what happens here fail to fetch ah right this is one thing you're going to definitely run into if you're writing express apps and you're pretty new it's the access control allow origin so this is something you have to set in your server if you're accessing endpoints from a different base url it's called cross origin resource sharing and you basically have to set a server header in your api that allows requests from the url that is the origin so recall that our react app's running on localhost 3000 as we can see here so all i have to do is set a um header header uh i think it's like just literally that but let me just uh let me just copy something to so i make sure doing it right chorus res header express yeah here it is that's all i need press header access control origin but if i do the star that makes it not protected so i just want to make this http localhost 3000 okay now this will i think i'm 92 percent sure it's gonna work all right i type it wrong huh i didn't restart my server that's why i was the eight percent me not restarting it wow nice guys there we go that's all our jobs beautiful okay we're getting close okay fetch jobs is um it's working i think what we still need is a um callback to to update these jobs so let's just do this update callback as we know when we use a used state hook the second variable that we destructure from the use state hook is a function in which we can pass a argument that is the new value of our state for job list so if i pass it in here like this update callback and then i pass the json directly into this i'm actually just setting the value of job list to this json which is as we can see over here an array of uh size 245 containing our jobs okay so i got update callback job list i didn't even have to do anything else it's already rendering all the jobs that are from github that's pretty cool hey guys i'm back with a new shirt let's finish up this front end and then get this app deployed i've pulled up another plan board here just to make it a little bit more clear what we want to do with the front end like i said before we always want to have a plan before we just jump into coding and um the first thing i'm going to draw out is just the current way the app looks which is just the title and then uh the list of all our jobs here right now our jobs only have the title and the company name but we're definitely gonna want also to have the location so title company we're definitely going to want location as well as the time posted and i think the best format for time is how long ago so today one day ago two days ago etc now this is in the list view and we gotta think about too what is going to happen when we click on a job and in that case i want to build a detail view modal also known as a dialogue or a popup that will show more details about the job uh which will include the company logo description as well as the apply link and that could also be a button if we decide to make it like that okay so these are the main things we still need to excuse me these are the main things we want in our front end the good news is since we already have the json we just have to pull it out of the json of each job and create a little bit extra functionality to make this modal animate luckily this is pretty easy with material ui and in fact the main reason i wanted to use it for this project because you get the modal for free with all the um animations and stuff like that so let's just jump back over to our um front end here and i'm gonna pull open the jobs component here i have variant h1 but i think this title is definitely a little bit too big i don't think it i think that's pretty obvious and i'm going to switch this up to still using a h1 html under the hood but the variant will actually make it an h4 stylistically so that's a pretty cool trick if you want to maintain the uh benefits of having h1 for seo and so on diving into the job itself let's actually log out what a single job is going to look like just so we know what we're working with and instead of doing that here in the job component i'm going to do it in jobs and we could just look at what the first job looks like so i'm going to use jobs 0 for that then we'll open the console and see that we have the fields we can use here so i said we wanted to add location and time posted to our list view uh we could pretty easily just pull out location in our job component like the way we've been doing with the other ones and there it goes this is looking a little bit let's say disorganized but let's worry about that in just a moment um for now i'm just going to throw these all in a div which is going to be floating to the left of our box and instead of space uh around i want to change this css to space between it'll make sense more in a minute why i'm doing that finally in another div let's do the um created date which i believe is over here in our json as well created underscore at and i'm just kind of using these typography elements interchangeably as divs so later on we can change the size of these different things okay so created at let's just see if the spacing looks alright there now that i see this here i think the date doesn't actually look too bad as long as we make it a little bit shorter so let's just split it by space and then take the um the first three words so let's take o24 and then join that by a space so all i'm doing here is taking sunday june knife out of this longer string i meant to do 0 to 3. there we go so we get index 0 1 and 2. all right looking at our page it deserves a little bit of padding just it's pushed up against the side here so let's add that quickly and then keep going let's give body a margin top and bottom zero left and right 40. okay top and bottom 20. all right and then within job maybe we give a little padding uh top and bottom left and right ten okay pretty good now inside job we'll actually add some hierarchy style hierarchy to our job title let's do h5 h6 on this and so on we can just keep updating editing this um i think i'm actually going to flip these around h6h5 but you get the point you can just keep tweaking it okay let's add that pagination thing i mentioned it's gonna be kind of a fake pagination you're supposed to do it on the server to not load all your results at once but this is a good stop gap we start just with the client implementation and then later if we want to improve the performance we could do the server side too but long story short we have over 200 results we want these on more than one page so they're more navigable so to solve this i opened a material ui page for the stepper component and i really like this one down here called the mobile stepper progress so you could click through it like this it fills up kind of a progress bar and it says mobile but i like it so i'm just gonna pull it over um let's see let's just pull over everything here just in case we need it and then paste it right into our jobs component and um we could use the word step here interchangeably with page and i'm putting this state in jobs because it's more of a view state rather than an actual data based state so all our logic concerning our view is going to actually be in jobs and not in the app file okay so since these each have their own function handle next set uh oh sorry handle next handle back i'm just going to copy these directly over to paste those right in function inside a function and um all right finally i'm going to just put this whole thing below our uh jobs map and um let's see if by pasting it directly in we we need to do anything else just going to make sure that's formatted correctly saved it and um let's just take this out classes direction rtl okay let's see how theme is being used because this is kind of a um darn all right i don't know why that would change from left to right but um it might be a mobile implementation specific thing so let's just take this and hard code it as right and we'll hard code this one as left and see if we run in any problems okay save that and can't find module oh i forgot about this material ui icons is a separate library so we have to also install that in our client yarn add material ui icons now while that's installing let's think about how else we want to use our pages um if we want to artificially construct these pages from a larger list then we basically just want to break things into a slice depending on the number of results we want to show at a given time so let's think of it as a moving window of 50. so if step equals 1 or let's say step equals 0 then we want to show 0 through 49 step equals 1 show 50 through 100 and so on or maybe 5099 okay so since our icon's finished let's see if that worked we got to go all the way to the bottom and yes it is here next and back okay okay so let's make this more dynamic steps is hard coded as six if we want 50 per page um we're going to have to do our well since we're going to use this in a couple different places let's get our uh job length or num jobs equals jobs.like just for uh better abstraction steps will be num jobs uh divided by 50. and then we'll math floor that or let's actually math seal that because it'll be minimum um one page could have you know only one job on it so we want minimum okay so that seems about right it seems like we have about four pages just by the amount of times i click that and um let's add a little more detail to right above this mobile stepper that just says and i'm just making it a different now but we can change it um page uh active step of num jobs okay um not okay let's let's let's factor this out num pages num pages equals this and then we can also use this where we are oh computers lagging again numb pages like that yeah i'm feeling pretty confident about that um see if it worked if we go to the bottom my wrist is getting real tired of scrolling here all right and then one thing i actually meant to do earlier too is um okay going all the way down okay oh five oh back one two three four five okay so the display number we want to actually be uh active step plus one because we're zero index and we're going up to um for yeah so this will this will work on pages minus one because the index is actually one less than the true value one two three four five okay we'll just leave it as num pages all right one other thing that i meant to add earlier is uh the total number of jobs at the top right under the title so let's do a variant h6 and put in the total number of jobs here num jobs 245 cool getting very close to being done with the front end here um oh cancel that uh okay now let's implement the actual pagination um and we could do that by just creating a slice that we're gonna map over instead of the list of all jobs uh jobs on page which is just jobs slice okay let's think about how to do this first number is going to be okay um yeah so active step let's keep in mind is our page that we're on now so the lower bound is going to be active step times 50 and the upper bound is going to be active step times 50 plus 50. now all we're gonna map is uh jobs on page not the full list and um now we only have 50. so much more navigable in terms of what's being rendered and then if we go to the next page it updates next page updates sweet all right that is our pagination done uh now all we need left is this popout modal and then our front end will be all we need left is the pop out modal and our front end will be totally done uh so what i want to do is click on this and then it'll give me a more detailed view as well as a link where i can apply so the first thing i want to do is add a hover state to this job div with a hover sudo class and css and then i'll just make cursor pointer pointer and i could also make the colors a a gray color just so it's very clear that we are hovering over this page or over the the job that i'm indicating so that that doesn't look great but it's uh okay for now let's just make this a little bit of a darker gray than dark gray all sixes here all right so that looks fine um okay so there's our hover state now on on click we're gonna want to push that job into the modal state because we want to know which job specifically to display in the modal we also want to set a modal open flag to let the app know to show the modal itself i think this is going to make a lot more sense when i actually read it out so um i'm gonna add it to the let me think about this yeah i'm just gonna add it to the bottom of jobs below my mobile stepper and i'm going to pull another component from material ui to do that and you might have guessed it it's going to be a dialog component so if you go under feedback there's uh dialogues and i kind of already know the one i want because i there's a lot of them and it's going to be the slide in alert i just think this one looks pretty cool because you click it and then it oh wait that didn't slide in where's the slide okay so you can see there it kind of slid up and in my computer is going slow but uh it'll look cool okay so we have to import a bunch of these components for this one to work in a perfect world you would make this modal its own component and i think i will do that actually call it job model dot js let's bring it react export default function job modal and our prop is going to be called job returning jsx and importing everything i just copied also there's some forward ref business going on here but we'll just trust that works like the material ui docs say it does and uh let's bring all of this in to here i am going to delete these though or rather i'm going to move these into our parent component because that's where we want to manage the state from it's going to go in the jobs component um let's consolidate this down this is for pagination and then modal consolidate this down too uh okay now we want to import job model then uh put this at the top here actually job modal open is open job is okay now this is where we have to define our actual modal state um active modal active uh no selected job let's do selected job so let's do just one more state okay state starting out it'll be an empty object default state and um select job will occur when we click on a job on click let's set some more room there select select job job like that so there's a callback in the on click function that will run when we click and it's going to set uh the selected job to whatever job we click good start and then that selected job is being passed in to job model um let's just rename this to be extra clear destructure job and open and if there's no job title we know this hasn't been set yet so we just return nothing that's just protecting against a empty object and let's see oh yeah we also gotta pass in our uh oh well no we don't need this because this is happening one level up right and um that also reminds me we have to not only select the job but set the model to open as well and i'll click open and then handle close is going to happen here and like no and all close okay pull that out and um okay let's see what errors we're getting i'm sure this isn't going to work out of the gate but just got a typo there okay so if i click what happens all right okay we actually have to pass down this function like that and then we open job and we do that on click here because it wasn't running we need to we needed to put it on the on the child oh nice nice got it down all right so title now we can start putting in our our variables this job title um instead of just having that there maybe we also put the logo of the company so yeah let's make this fancy do a image source company job company logo and um detail logo in here we will do detail logo make it pretty small 30 pixels float right now back over here we of course want the company and um in the content we definitely want the description okay one tricky thing though you'll notice that the description is in html it's an html string so a trick with react is um if you want to actually render html from a string it's considered dangerous because you can put in script tags and execute script on someone else's browser so if you want to allow this as the developer you have to use the dangerously set html inner html attribute like that and then you pass in an object with uh the key html equals whatever you want your html string to be and that'll do the trick but it's again dangerous so use it sparingly as for the buttons at the bottom let's change this one to apply and this will just be a link to the original job posting for now so we'll wrap this in an anchor tag a href uh wrap it in anchor tag of job.url which is the link to the original job you see here closing anchor tag goes on the other side of the button maybe we don't actually want this button to close the modal and then i'm just going to save everything we just did now i'm opening it again we do have an error but it's looking pretty good and i'm wondering if the the reason for this is that i just have to use the dangerously set inner html directly on this let's see if that works changing this to a selfclosing uh tag and uh one thing i want to do also is put a break between the the title here and the company because they were both on the same line actually let's just do it like this put in a little hyphen to separate them when i open click okay awesome and uh if i click apply it'll take me to the company or the rather the original job posting which we may want to make a little more complicated down the road but for now it's good uh one more thing i want to do is make this link a target blank so it'll open in a new tab underscore blank so that'll open this link in a new tab all right as far as the modal goes i think we're pretty we're pretty much good so for now i mean that could be obviously we could add a little more pizzazz to this front end if we you know continue improving it over time but for now i mean it's very functional it does everything we wanted to do i can click on different jobs and get um get a different you know listing this opens and closes and these are all working with the logo and i can scroll it looks pretty good it looks pretty good so i want to say our front end is done all right guys we're so close to being done we literally just have to deploy our app and will be home free a lot of people are afraid of deployment but it's not that bad if you break it down into steps when i think about what we need it's going to be a domain pointing to a virtual private server which is hosting nginx now nginx is called a reverse proxy it connects your server to the public internet and provides like protection between those requests the other thing we're going to need is a process manager on our server after we install our dependencies that we have in our local environment so we're going to need the same things redis we're going to need node.js and then we're just going to need to send over all our files so they can actually run on our server in the same way they're running locally so let's do it i've pulled up a bunch of docs here we're going to need it's just going to be a lot of copy and pasting for server configurations and i'll put all these links in the description so like i mentioned first uh we need a domain i already bought one on google domains but you can buy a domain a ton of different places i just like google because the interface and it's because where my uh other domains are so i've opened my domain i already bought it a normal.com domain is going to be about 14 a year and the first thing we need to do is use the digital ocean name servers so that domain can be directed over to our server so you'll see that i have clicked on my domain i've opened the dns tab and then there's a name servers tab and i've clicked use custom name servers now i'm going to put that on pause and jump over to the digital ocean dashboard you can make a digitalocean account for free and it'll give you this dashboard where you can create projects which have resources inside of them a project is basically just a folder for a bunch of resources including domains and virtual servers and then all this stuff you see down here so i'm just going to create a new project and call it um entry level software jobs e lsj and it's a web application so i'm just going to create that and then like i said it's just a folder we're going to start with no resources so i'm going to skip that step for now but right away we're going to create a domain and the domain is going to be the one that we bought entry level software jobs.com so i'm just going to put that here and then add it and you'll see that i have the digital ocean name servers here so it's ns1 2 and 3. so i'm just going to copy this by clicking it and enter it here and we need all three of them so i'm just going to expand this out make this one two and then make this one three now when you change the name servers it could take a a little while to actually update it says up to 24 hours a lot of time for me it's instant but it's not always the case so you might have to wait and we'll see what happens here so next thing i'm going to do is actually create a droplet which is our vps virtual private server you can do this on any cloud provider other common ones are aws or google cloud but um on aws this is called an ec2 and then i'm not sure what it's called in google cloud maybe just a vps but on do it's called a droplet which is just a server so what you have to do is choose your operating system i'm choosing ubuntu linux 1804 and you can choose the size of your server you could always upgrade it later which requires a server restart so i'm just going to pick the 15 a month which has three gigabytes of ram and 60 gigabyte of storage and then um moving down you could choose your data center where is your server physically located and then moving down you could do private networking's useful if you have you know multiple servers talking to each other but the most important part is here at your ssh keys you're probably going to want to do a new ssh key but i already have mine saved here you definitely need this step because you need it to actually get into your server to connect to it otherwise there's no way to get into it so you definitely need a ssh key and then uh feel free to look up a tutorial to set that up i'm not going to do it here but it's pretty easy to do and then i'm just going to call a hostname master because we're only going to have one server with all our services and then finally create this so this server is now being created it doesn't take too long and i'm going to go back into my domain and add an a record for at which is just the root domain and i want it to direct to our master server so i'm just going to create that record and that is step one in linking our domain to our server now uh once this finishes which it looks like it just did we got the green light here i'm going to copy the ipv4 address that's the ip address and i'm just going to ssh directly into this server by doing root at ip address just like that ssh root at ip address and it looks like it wasn't completely finished loading so i'm just going to try it one more time and now we type in yes and there we go so you can see our operating system here and now we have a command line in our server so we're actually in our server through a secure shell that's ssh so i'm just going to clear this out with command k and it's important to look at the command prompt to know where we actually are we don't want to be installing things on our local machine that we think we're doing on our server so always keep an eye on this i'm rude at master master being the name of our server all right so as i mentioned we have to install nginx to actually talk to the public internet and uh if we have a domain we also want to install an ssl certificate which gives us the https secure connection and that sounds complicated but it's really easy if you use the tool like certbot i have the documentation open here all you do is um you choose your software on your system and as you'll recall we used 1804 and it'll give you a a series of commands to just enter into your server and it'll install pretty much everything you need so i'm just going to run these commands and a few of them require me to hit yes so i'm just going to do them one at a time make sure each one works while periodically clearing out my console with command k just to give us more space so there's one where i have to hit yes and let's just keep going through these so the nice thing about this certbot is usually you have to install nginx on its own but this will install our nginx and our certificate our certificate all at the same time and then we just have to update our nginx config and we'll be already serving our application to the uh to the public internet through our domain okay last command here yes all right okay i'm going to copy this sudo sir bot nginx command which is what actually runs the uh installation and then i'm going to enter that in and it'll take us through a series of prompts to actually install this so i'm going to put an email and then agree no now we need our actual domain we got to make sure we spell it right here entry level software jobs.com an important thing to take note of here is where it deployed our certificate so it deployed our certificate in sites enabled slash default which is a config file that we later have to edit if we want to make any changes to our domain configuration so um we're going to open that later to update the config but just keep in mind that location okay congratulations it was successful so let's test that and see if our name servers have propagated yet by going to the domain and that's exactly what we want to see welcome to nginx so this is a nonconfigured nginx but it is running and we're connected to our server from the public internet so that's great so we're done with sirbot and then like i mentioned we want to next edit our configuration file which is at that location etc nginx sites available uh default and i'm going to open this with the vim text editor by typing in vi and then the file location now vim is pretty cool if you haven't used it but it's basically installed on all unix operating systems that is linux and mac os and it gives us a text editor right in the console so what i'm doing here is i'm scrolling down to the second server block which is actually indicated by this server bracket notation and i'm going to look in here and i can see my url is defined here and being forwarded to uh basically port 80. so um within this location block i'm just going to completely delete what's in here that is inside the location block and then i'm going to put a new config in that is just pretty much something you have to copy and paste to do port forwarding to a local port on your machine so i'm going to copy this location here and i will put this link in the description where i'm getting this from but this is just a standard configuration for port forwarding so i'm just going to paste it right in we have that and then the other thing we need is to put this outside of our server block which is actually the port that we're forwarding to port 80. so sorry i messed that one up actually undo um go in to make a little space and then i'm gonna paste that in there so we're forwarding localhost 5000 to port 80. that's what this upstream is doing so i'm going to save this with colon escape colon wq and that saves the file and then i'm going to do sudum sudo system control restart nginx and that just restarts our nginx no errors um okay so that's pretty good um now let's keep moving and install our dependencies on our machine so i'm going over to this other tutorial how to set up node.js on ubuntu link in description and i have to install actually the node.js version that we need which is at least six to run uh create react app build so i'm changing directory into the home directory that's the squiggly line then i'm curling this file now i'm just running the script that i received from this file uh curl making a request to download some dot s h file which includes basically some setup configuration for installing node.js clearing the terminal and then actually installing node.js through aptget which is a linux equivalent of homebrew that's for installing just pretty much any software okay that worked and now i want to install this build essential file which is or rather module which is a helps us run certain npm packages so it just makes sure we have compatibility with every um npm package that we want to use okay next let's actually test out that our port forwarding is working by creating a test file called hello.js so i'm going to do that with them here hello.js and then insert this uh code and i just want to actually change that to 5000 which is what we set up our port forwarding to as you might recall and then i'm just going to save that with escape wq and then run it with node so node hello js and it's running so let's see if that is actually being forwarded correctly and it is so that's great okay just scrolling down this page and i'm going to stop that server the next thing we need to do is install pm2 our process manager which allows us to run all our services our api front end and worker at the same time without us being actively on the server so it'll run them restart them capture logs and do a lot of stuff that's pretty cool for actually managing our server processes so i'm just going to do oh no we don't have npm installed so of course um you know no tutorial is perfect so let's just install npm as well it normally does that when i install node but i guess i'm using a different uh set of commands this time to to do this so hopefully this just um doesn't give us any problems later and uh let's see if that worked okay sweet so let's do the and the same command as before npm install gpm2 oops okay and then to run our react app we all we need to npm install g another dependency called serve okay so we got those two done and let's just test pm2 with our hello js file so let's do pm2 start lljs and we'll see our pm2 daemon is spawned so now we can see our pm2 processes with pm2 ps and there's a status cpu and memory which is pretty cool that we get those stats in a dashboard and then if i refresh my page the app is still running in the background so that's great so if you remember the steps we outlined at the beginning the next thing we need to do is actually get our files onto this server and once we do that we should be pretty much done so i'm going to open up a second command window here and this is you'll see in the command prompt my local machine so what we want to do is send through the files that we made in local development before we do that i'm going to open up this uh set of files and make one critical change that will allow us to access our api on our local server and that is to basically change this to just a relative path so i'm changing this to just slash jobs and actually i want to change it to be a little more clear to be slash api jobs now that means we also have to change our api route which shouldn't be a problem slash api slash jobs and we have to make one change in our package json and that's adding a proxy config which allows this to still work on local development this doesn't affect anything on production so um proxying all api routes to a target of localhost sorry need the double quotes there http localhost uh 3001 was our api server i believe and i'll save that and again that just helps us you know still develop in the same way but we need to make one config change for the production server as well so that was our change in um in our files and as i mentioned i'm going to go actually back into that nginx config file etc engine x sites available default and i have to add one additional location block just for the api route because basically what this is doing is appending the relative path to the end of our url and nginx needs to know to direct this to actually port um 3001 on when it's being run by the browser so it's just basically a different port forwarding for a different path and the way we do that is by getting a proxy pass to http localhost 3001. semicolon is important i forget that a lot so escape wq to save and then system control restart nginx all right so we're about to send through our files to our production server i'm going to change into my client and then i'm going to do an npm run build to create a production build of my react app that we we just built this includes everything from our package.json and also our minified version of our javascript files and our bundle js now we can see that we have a build folder and we send this through the same way that we actually ssh in with a command called scp and then i'm going to put in an r flag for recursive so it'll send anything recursively within the build folder to our uh server url i'm just going to copy that again from here by going to master oops that's not good okay no it hasn't been destroyed false alarm uh copy the ipv4 and then do the same syntax root at our ipv address and then uh i need to put in a colon and then the home directory so where are we sending it to on our server and we just want to make sure it's going to the home directory okay so that's sent through all our files from the build folder and now when i ls inside of our server you'll see the build folder is there so that's great so um let's start this up we're not gonna have any data running yet because we don't have our workers started on our server but um let's start this up by pm2 stop hello this was our test server we know it works and then we'll do pm2 delete hello and now i'm going to do a special kind of syntax to actually serve our build folder publicly and that's going to combine the serve package we downloaded with the pm2 process manager so i'm going to do pm2 start serv dash dash s build this is just saying use the serve package and run this command dash s build under serve it's the same as pm2 starting uh just running this command serve as build and in fact let's try this first serve as build to see if our application is going to be served so it says serving local and network to the port we're forwarding to and there it is already uh we can see it's kind of working here's our domain and then here's our front end with no data but like i just typed we're going to run this in pm2 with pm2 start serve as build and you'll see it created under a name serve that's probably not the best but we can keep that in mind this is running under the process serve and it's online and then when i refresh it's still running so that's cool now we have our front end running so we have to send through our worker and our api files so i'm going to clear that out this is our local machine again change directory out to our home directory and then we want to send through a cpr let's see api and i'm just going to hit up a few times to get this command back i'll send through the api folder to our home directory then i'll send through the worker folder then i'll also send through package.json to get our dependencies namely express and the redis client so back over in our vps i'm you going to need to install redis so i'm just going to do sudo aptget install redis yes and we can test whether that installed by doing redis cli as we did on local and it seems to work so exit and now that we have all our files here let's just check that we do let's do npm install to get those dependencies and now let's start our worker or rather let's start our api bm2 uh start api index.js i'll do name api and then we'll also start our worker pm2 start index.js name worker okay everything seems to be running but how are we sure that our work is working well let's do pm2 logs worker just to see if those logs that we set with the console logs that actually give us the indication workers working are actually going to run so you'll remember that we did a cron for every minute so let's see if those logs are actually going to run after a minute so we just got to wait and see if that happens and then once that happens our redis will be loaded so in theory we should be able to refresh our page and then see all the jobs there but right now we just gotta wait the suspense is is kind of killing me here uh i feel like it's been longer than a minute i don't know if it's gonna work or not but i actually have faith okay there we go come on worker you can do it okay it says success okay and uh so now our reddish should be full if i refresh there's all our jobs amazing so we have a deployed application everything looks just as it did on local if i click into these jobs let's see uh it works there's our description logo and everything and then if i click apply it'll take us to that position so that's pretty cool guys we just deployed our whole app and it didn't even take that long i feel like that was around 30 minutes or so all right guys that's it we basically built a whole production application in less than 100 minutes and we got it deployed and now it's running on the public internet at entrylevelsoftwarejobs.com so go check it out but um i'm thinking next there's a few critical things we have to do before we're ready for like a full production launch so to speak this was just our base framework that we're building more features off of but at minimum i think we need a few more data feeds and we need to make our algorithm a lot more robust prevent it from breaking on errors as well as filtering down those jobs a lot more because if we get in five feeds we're just gonna have a huge amount of jobs and we really wanna make sure those are entry level jobs so i'm thinking that we parse through the description and look for like three to five years of experience and take those out i think anything less than three years would qualify as an entrylevel job so again we're gonna have to keep working on the algorithm and then otherwise we're gonna want to add a little bit of monitoring logging different things like that but that can all come later our mvp is done and our base of our application is done so that's pretty cool so anyway hope you learned something um let me know if you have any questions and i will talk to you guys soon
