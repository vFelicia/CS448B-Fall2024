With timestamps:

00:00 - hello well welcome everyone to this nice
00:04 - very nice introduction and thank you
00:06 - Quincy it's oh boy
00:08 - I think one day if I need someone to if
00:14 - I need someone to sell myself I will
00:19 - definitely hire Quincy so let me know if
00:22 - everything is right if you can hear me
00:26 - my name is Lauren pop I'm a developer
00:28 - from Romania
00:29 - I've been coding for seven years and in
00:33 - November I started a YouTube channel you
00:37 - can subscribe there if you want to
00:38 - follow me we have almost daily live
00:41 - streams and different tutorials and also
00:45 - if you want feel free to follow me on
00:47 - Twitter we're posting almost daily and
00:51 - yeah let's start working on this new
00:55 - crazy challenge Quincy has been has been
01:01 - asking me to start this because well
01:04 - yeah it's an interesting challenge and
01:07 - we're going to do it on the free code
01:10 - camp website and we're going to do it
01:12 - with JavaScript which is pretty nice
01:17 - yeah hello Eduardo feel free feel free
01:22 - to join the chat this will be this won't
01:27 - be that kind of animal tutorial where
01:30 - I'm teaching you and I know it's all
01:35 - formal it's just us hanging out sort of
01:39 - and solving coding challenges with
01:42 - JavaScript
01:43 - this is whoops this is what I'm doing on
01:46 - my channel also so I haven't prepared
01:50 - for these challenges because I wanted
01:54 - you to to see the progress so I wanted
01:58 - you to see that it's it's okay to fail
02:00 - it's okay to Google sometimes things
02:04 - it's okay to not have the perfect
02:07 - solution and yeah it's all part of
02:12 - developer
02:13 - journey keep in mind that I've been
02:16 - programming for seven years I've been
02:18 - working as a freelancer I had a job than
02:21 - freelancer again and another job and
02:23 - then I turned into content creator this
02:26 - is what I really like to do so yeah
02:29 - thank you freakin camp for giving me
02:31 - this huge opportunity
02:32 - I usually stream for 4050 people there
02:37 - are thousands and so people now watching
02:39 - which is crazy I was pretty nervous but
02:42 - now I find ya so say hi in the chat if
02:46 - you're watching if you can also it's
02:50 - don't tell anyone but my opinion you
02:54 - should support a freaking cab Channel
02:57 - it's they're doing an amazing thing so
03:00 - feel free to become a member and then
03:02 - you will be able to join the chat if you
03:05 - have questions at any time feel free to
03:08 - ask them also I might need your help
03:11 - sometimes so feel free to help me and
03:15 - yeah hello TM sunny Eric hi all of you
03:22 - okay so yeah let's see what's the take a
03:28 - jar how are you today so this is the
03:32 - project Euler set of problems coding
03:36 - challenges I will be this will be the
03:39 - first series and then I will be doing I
03:43 - think weekly live streams in which we're
03:47 - going over these problems there are
03:50 - hundreds of problems but this challenge
03:52 - is the first 100 now I'm not sure if we
03:56 - can go over all of them like that fast
03:59 - because they're getting harder and
04:01 - harder but well we're going to try all
04:06 - right so yeah project Euler is the
04:08 - cities of challenging mathematical and
04:10 - computer programming problems meant to
04:13 - delve delve into and familiarize oh by
04:16 - the way if my English is I think she's
04:20 - off that's because of nothing in native
04:22 - English speakers so yeah any time you
04:24 - don't understand what I'm rambling
04:26 - around
04:27 - feel free to stop me and yeah wait what
04:31 - as I said I usually am on my channel
04:35 - we're all here as a family we're
04:38 - learning together we're having fun I
04:40 - don't have my orange lemonade now you
04:44 - really have an origin mone don't we yeah
04:46 - we had worth having fun okay
04:50 - so I was thinking that in this stream we
04:55 - should do the first four or five
04:57 - problems to see how it goes as I said I
05:00 - haven't really look into it just that
05:03 - just the titles but we should be fine
05:09 - hopefully hello Travis how it's going
05:14 - also so yeah the first problem
05:18 - multiplies of three and five if we list
05:22 - all the natural numbers below 10 that
05:24 - are multiplies of three or five we get
05:27 - three five six and nine all right
05:31 - the sum of this multiplies is 23 okay so
05:37 - we need to add up the sum of the
05:40 - multiplies of three or five
05:43 - all right find the sum of all the
05:45 - multiples of three or five below the
05:47 - provided parental value number okay so
05:51 - apparently we have a function which gets
05:54 - in a number and we need to return the
05:58 - sum of the multiplies all right so let's
06:02 - see first we should probably loop over
06:08 - all the numbers from 1 up to well the
06:12 - number provided and we should check if
06:15 - that number so all the numbers in the
06:17 - loop if there are multiplies of 3 or 5
06:22 - so if they their modulus I guess the
06:28 - division by 3 doesn't have any reminders
06:33 - hopefully I said that right right
06:37 - okay so hey Adam yeah thank you
06:47 - good so let's see we want to create our
06:49 - loop let me know if the font size is big
06:53 - enough if you can see the code I don't
06:55 - know if my face is in the way or I
07:00 - should probably remove these social
07:03 - buttons or whatever they are and yeah if
07:07 - anything is not okay just let me know
07:10 - and we can fix it all right so we're
07:13 - going to do a for loop starting with one
07:16 - well I guess yeah we should start with
07:21 - one because we could have a number less
07:24 - than three right so we should start with
07:26 - one and then we want to go up to the
07:30 - number right
07:31 - so I less equals than the number I plus
07:35 - plus okay and so first I'm going to do
07:41 - like a brute force thing so not very
07:47 - optimized and then we can try to improve
07:51 - it if if we find find a better way to do
07:55 - it
07:55 - hello Marco so yeah thank you by the way
07:59 - thank you to all the poppers the poppers
08:01 - are those who been following me yeah the
08:04 - poppers family thank you all of you for
08:07 - being part of this
08:08 - you've been very supportive I was very
08:11 - nervous at the beginning and yet highly
08:15 - appreciate you being here also Marco
08:19 - seems that he became a member to be in
08:21 - the chat so yeah very nice of you all
08:24 - right so we're looping over all these
08:27 - numbers now we need to see if they are
08:31 - multiplies of multiplies of three or
08:34 - five I guess I don't need this anymore
08:38 - all right so let's check here if I right
08:44 - so if I modulus three is zero or what
08:49 - and that's yeah you'll hear a lot of
08:51 - oops you're here a lot of goody-goodies
08:54 - your Hill a lot of things I just hope
09:00 - you enjoy it and the most important
09:02 - thing I really hope that you're learning
09:03 - something and yeah what we should be
09:09 - looking for is to become every day to
09:11 - become just you know if we can become
09:14 - one percent better than we were
09:16 - yesterday that's already a huge so yeah
09:20 - good so one one zero is five equals zero
09:24 - I always mix up it is the modulus
09:28 - operator or yeah someone correct me if
09:31 - I'm wrong I might be wrong multiple
09:33 - times oh that's right okay so if that's
09:36 - the case then we want to add this I to a
09:41 - sub right so let's create the sum with
09:44 - let not beat Const let's um first will
09:48 - be equal to zero
09:49 - and here we can say some classical's i
09:52 - right and so they will add up let's make
09:57 - some space here to have a pretty code
09:59 - and at the end we should return some
10:04 - right hmm
10:05 - if my logic is correct hopefully it is
10:08 - this should be good so let's see all
10:14 - right something is off
10:17 - what did I do wrong so if it's three or
10:22 - five then we should add AI K up mm that
10:32 - should be hmm does anyone notice and
10:36 - think where it could be the issue
10:42 - all right let's let's console that clock
10:45 - and see what we get so for a thousand we
10:50 - should get to top two hundred thirty two
10:54 - thousand one hundred sixty-eight and we
10:58 - get oh okay I think I know where the
11:02 - problem is so you can see the difference
11:06 - between this and the value we should get
11:09 - it's like 1000 and 1000 is the number
11:13 - we're looking so yeah it says here below
11:19 - the provided very parametric value so
11:23 - that's the issue we went up to including
11:26 - the number so we just need to remove
11:29 - here the equals and now you can see that
11:32 - we are getting the correct answer and
11:34 - let's run this and look at that pretty
11:37 - nice we solve the first one awesome all
11:44 - right let's think yeah I less the number
11:48 - Thank You Kaja I also keep in mind that
11:51 - there might be a delay from the time
11:56 - you're saying this well do the time
12:00 - you're commenting in the chat and I'm
12:03 - saying that so yeah keep that in mind
12:07 - all right
12:09 - could we improve this or should we think
12:13 - about improving something like this I
12:16 - always try to think maybe we could have
12:19 - some kind of ray method or something
12:24 - fancy but yeah it doesn't seem like you
12:29 - know we should even think about
12:30 - something it's pretty clear we have a
12:33 - sum which is zero then we'll loop over
12:35 - all the numbers and if they are
12:39 - multiplies of three or five then we are
12:42 - the sum so I guess this should be a
12:45 - pretty good solution if you have an idea
12:50 - of how can we prove this maybe I don't
12:52 - see it or who knows
12:55 - let me know but for now let's submit
12:59 - this angle to the next challenge
13:03 - all right good the second one even
13:10 - Fibonacci numbers now let's see what
13:13 - this requires each new term in a
13:16 - Fibonacci sequence is generated by
13:18 - adding the previous two terms by
13:20 - starting with one and two so yeah we
13:23 - have one and two the next one will be
13:25 - one plus two for those who don't know
13:27 - about the Fibonacci sequence then we
13:29 - have two plus three equals five then we
13:33 - have three plus five equals 8 and then
13:36 - we have so so on and so forth
13:41 - all right by considering the terms in
13:45 - the Fibonacci sequence whose values do
13:46 - not exceed an so again we don't need to
13:49 - go over and find the sum of the even
13:53 - value terms alright so let's take some
13:57 - notes we need to not exceed and what I'm
14:05 - writing here okay so up to n then we
14:09 - need even numbers all right and we need
14:15 - the numbers will be in a Fibonacci
14:18 - sequence right okay look at this
14:24 - motivating message you can do it alright
14:29 - we can do
14:34 - so I guess we should start by having the
14:40 - Fibonacci numbers the first two
14:42 - Fibonacci numbers right okay so the
14:47 - Fibonacci values should not exceed all
14:49 - right so let's do the following let a be
14:55 - the first one or I guess we could call
14:58 - it a be the first B one and let be me
15:01 - too okay so these are the first two
15:07 - Fibonacci numbers and now we want to go
15:11 - to keep adding these and changing the
15:15 - these variables this is why I used to
15:18 - add until we are up to the app so again
15:25 - now because we don't know exactly
15:28 - last time we use the for loop because we
15:30 - knew exactly how many steps we have but
15:33 - this time we don't know exactly the
15:35 - number of steps so we're going to use a
15:37 - while loop so then we're going to use
15:40 - while and we need a condition here which
15:43 - will be the condition so in the next
15:48 - loop B will equal well a will equal B so
15:53 - a will be two and B will equal a plus B
15:57 - right so it will be the next number so
16:00 - we need to check while B less than and
16:04 - right so this is our not exceeding it
16:09 - okay and also need to keep in mind that
16:12 - we need the even numbers all right and
16:17 - we need a sound so let's create that
16:19 - variable sum will be let's think we want
16:23 - the sum to be zero or we want the sum to
16:27 - be a plus B by default I guess will be a
16:32 - plus B
16:34 - oh but no because a will be an odd
16:40 - number so we only want the even number
16:43 - so that's be right we should we have be
16:47 - less than and Escada
16:49 - no because we want to go up to and
16:52 - knotek's oh yeah see yeah you're right
17:00 - so it not exceeding means that it
17:03 - doesn't go over so it could be up to and
17:06 - including very good thanks
17:08 - yeah so nothing's not exceeded but
17:13 - included okay good good catch
17:18 - see ya we might sometimes just mess it
17:22 - up but it's fine and this is why I like
17:25 - the live streams well on one hand I just
17:29 - just I know get the fool of myself but
17:32 - on the other hand I have helped my
17:34 - helpers here which will make sure that
17:39 - whenever I fail it will still around
17:44 - okay yeah and we'd also figure out when
17:49 - the code fails so probably this is a bit
17:53 - overthinking on my side just to buy the
17:57 - know lay out the building structures I
18:01 - guess the oh okay so here we want to get
18:10 - the new values so the new Fibonacci
18:12 - number which has said that a will be B
18:16 - and B will be a plus B but here is an
18:22 - issue because now we modified a here so
18:26 - we need a temporary value in which we're
18:30 - going to store a then we're going to
18:34 - change a to be B so it will be the next
18:36 - element in the Fibonacci sequence and
18:38 - then here instead of storing into a
18:41 - we're going to do temporary plus B all
18:46 - right and
18:47 - now if B is even so meaning that the
18:53 - division back to the reminder should be
18:55 - zero right so if it's even we want to
18:59 - add it to the Sun so sound plus equals B
19:03 - now if my logic is correct and I didn't
19:05 - screw it up at the end we should
19:10 - some and let's run to see look at that
19:15 - so this time we did it correctly yeah
19:21 - let me know if you understood this let
19:25 - me know if you have any questions I'm
19:26 - going to wait after I finish one one
19:29 - challenge just to make sure that
19:31 - everything is you understood everything
19:36 - yeah so apparently all the tests here
19:39 - running correctly for ten it should be a
19:43 - number sixty one thousand one hundred
19:47 - thousands of these numbers go like so
19:50 - big which is pretty pretty interesting
19:54 - okay
19:59 - I don't see any questions in the chat so
20:01 - I guess we can go to the next one now
20:06 - mmm well actually let me think could we
20:10 - improve this anyway
20:17 - I don't have an adn now I'm thinking
20:20 - about using recursion to find out the
20:22 - Fibonacci numbers but yeah that's
20:26 - probably not for this challenge
20:30 - so yeah let's move on to the next one
20:38 - all right largest prefect or prime
20:41 - factor okay so the prime factor of
20:45 - 13,000 195 are five seven thirteen and
20:50 - twenty nine what is the largest prime
20:53 - factor of the given number okay
21:00 - so let's see that's right again what we
21:06 - need to do so mm-hmm we need the prime
21:11 - factor so not only the factor is the
21:13 - prime on so we need to check and we need
21:18 - to have a function is prime okay so well
21:25 - let's see this will check if a number is
21:30 - prime okay all right then we would
21:36 - probably loop again over the entire
21:40 - numbers as we did in the first challenge
21:41 - so from 1 up to the number but I knew
21:48 - that there is a trick so we don't
21:51 - actually have to go up to the number
21:53 - because I think there was either going
21:58 - up up to the half of the number or the
22:05 - square root of the number so I never
22:08 - really really got this exactly so we're
22:12 - going to test it because you can see
22:18 - here we have a huge huge huge number and
22:22 - well doing the loop over let's see
22:25 - thousand millions billions that's well
22:31 - that's huge
22:36 - also being the prime weekend we need to
22:39 - check all the number so we need to check
22:41 - if is divisible by only one and itself
22:45 - so it doesn't have any divisors I guess
22:52 - yeah
22:53 - so for loop up to
23:01 - to half let's go up to half of the
23:03 - number because so if you're thinking
23:07 - about twenty right so then which is half
23:13 - of it
23:14 - it is a divisor right but eleven it's
23:21 - not anymore and also twelve and thirteen
23:25 - all the numbers from half up but also
23:30 - ten it's not a prime because yeah it has
23:35 - it divisible by 2 and 5 hmm
23:39 - okay let's loop so we need often just
23:45 - the largest so we're going to keep track
23:52 - of the largest so that largest first
23:56 - will be and should start with one and
24:02 - now we're going to let me remove this so
24:07 - for left I equals I think we can start
24:11 - with two or should one is definitely not
24:16 - the biggest but oh well let's start with
24:18 - 1 I less than or equal to half of the
24:24 - number number divided by 1/2 divided by
24:28 - 2 and I plus plus okay now we need to
24:34 - check if is prime so the i if is prime
24:42 - and well actually we can do i number
24:49 - modulus equals zero and it's a prime
24:54 - right
24:56 - so prime factors okie-dokie and I did
25:04 - this we're going to create another
25:06 - function just to make it more readable
25:10 - so is Prime and we're going to give it a
25:14 - number and here let's see we want to
25:22 - start from two so let I equals 2 because
25:25 - 1 is divisible so being a prime means
25:28 - it's only divisible by 1 and itself
25:31 - so we want to loop over all the other
25:34 - numbers or so from 2 up to the number
25:38 - and if we find the divisor then it's
25:40 - another prime okay I guess this also
25:48 - could go up to 1/2 hmm let's do the
25:51 - brute force and then if it fails we can
25:54 - optimize it so let I equal to I less
25:59 - than the number I plus plus
26:07 - okay
26:08 - and now if number divisible by zero then
26:16 - we can already return false right so we
26:19 - get up the function and we turn false
26:22 - otherwise we can return true and this is
26:26 - a prime number so let me put this here
26:30 - nice little bit okay so
26:37 - [Laughter]
26:38 - Quincy again speaking highly of me but I
26:43 - don't deserve it okay so we're looking
26:50 - over the numbers and now if this is the
26:54 - case so if it's divisible and if it's a
26:56 - prime then we want to store it in the
27:00 - largest so largest should be I right
27:03 - because that's the little loop okay and
27:07 - here we can return the largest
27:10 - all right this is my logic let's see if
27:14 - it's a good one okay so something's
27:19 - wrong
27:21 - let's do some yeah look at that test
27:24 - timed out so this might be a problem for
27:27 - us
27:30 - okay because it's a huge number I said
27:37 - that we'll do four or five but maybe
27:39 - we'll get stuck at three alright first
27:43 - let's let's cancel that lot to see what
27:47 - we get and whites and not working okay
27:53 - so for this we get 29 that's good for
28:01 - two we get two one
28:04 - okay that's because we go up to half and
28:08 - apparently doesn't good so
28:15 - let's see what happens for three I guess
28:17 - it's the same thing and we get only one
28:19 - four five
28:21 - yes apparently that's not okay let's go
28:25 - up to the number prime factors
28:35 - yeah feel free to correct me if you see
28:37 - the mistake there might be a couple all
28:42 - right so this should work for few but
28:47 - Danakil
28:51 - Thank You Quincy yeah also feel free to
28:55 - support the freaking camp channel by
28:57 - donating if you want super chat it will
29:01 - help the organization
29:03 - alright now yeah this is what I was
29:07 - afraid of we're passing these these
29:11 - tests but the big one is pretty big I'm
29:21 - happy to see that you enjoyed it Adam
29:27 - yeah this is what I did with the free
29:29 - code camp curriculum and also I'm going
29:32 - to do it again with the Piton series
29:35 - after everything's working and all
29:38 - always good
29:45 - so Andrews saying that in is prime only
29:51 - need to check if number is divisible by
29:53 - two three five and seven all other
29:56 - numbers are divisible by one of these
29:59 - ends if not a prime value
30:05 - yeah but it could be a for example 13 is
30:09 - a prime
30:12 - so I'm not sure if that will work
30:17 - yes sir now it's failing because of its
30:21 - test timeout so we need to reduce the
30:24 - number of loops we have
30:27 - which will be pretty interesting
30:36 - and yeah so cassia is saying so if I
30:39 - mispronounce your name sorry it's saying
30:42 - that instead of for lo pruning running
30:45 - from one equal from I equals to one can
30:48 - we run i cost a number divided by two
30:50 - till i is bigger than one so you're
30:54 - saying which should look backwards yeah
31:00 - that would be an idea and then we save
31:03 - half of the half of the loops
31:13 - yeah and I'm glad I did okay but then
31:22 - well we're going to have the same issue
31:25 - where we won't have to entry if we do
31:31 - equals the half of the number right and
31:35 - we can also not change the largest so
31:41 - let let's comment this out we need to do
31:44 - something
31:44 - slowly figure it out
31:47 - they're probably must be some kind of
31:51 - fancy thing to delete but let's try this
31:57 - so let by equals number divided by two I
32:01 - bigger than I guess one we can go there
32:10 - I I - - so we go the other way around
32:13 - and I guess we can check the same thing
32:16 - now the issue here will be for example
32:23 - for - we won't have to write and also I
32:28 - let's make it let's floor this number so
32:35 - we have a fixed number so fluorine if
32:38 - the number is not a prime it is bound to
32:41 - have a factor factor less then its
32:44 - square root according to the common
32:45 - mathematical theorem yeah so this is
32:48 - Matt Matt Matt ish yes I knew something
32:55 - about the square root so you say that
32:58 - here we should go up to the square root
33:00 - of number Matt square root right so this
33:07 - should save some loops also if you check
33:11 - divisibility by two before the loop you
33:15 - can start with I equals three and
33:17 - increment by 2 instead of incremented by
33:19 - 1
33:19 - that's another good good suggestion
33:22 - because we know that 4 is not a prime
33:28 - right so what you're saying here is that
33:33 - we can start with 3 we can increment by
33:37 - 2 so it will be 3 5 7 9 and here if the
33:44 - number is divisible by 2 then we can
33:51 - return false right so this is 4 for the
33:59 - two case alright for two kids
34:03 - [Laughter]
34:05 - and yeah for case we're divisible by two
34:10 - yeah I wanted to the comment nevermind
34:12 - alright so this will save a lot of loops
34:16 - to check the prime let's see how this
34:22 - works for a number now
34:27 - yes so it still should return to
34:33 - still timed out why did you have to do
34:38 - so big of a number alright so let's
34:44 - think well this is divisible by two but
34:49 - if it's two we want to return true right
34:53 - it might be two the number itself might
34:57 - be two so then it we should allow it so
35:01 - we need to check if is divisible by 2
35:03 - and the number is different than two
35:07 - then we should return false right and
35:10 - now it should work for for this test
35:13 - case but we still have a lot of loops
35:20 - IFS
35:21 - [Music]
35:26 - let's see what we could improve I could
35:29 - try this now but yeah my only issue with
35:34 - this is that the largest yeah you can
35:36 - see that it's not working I guess we
35:42 - could do a seal but still we don't yet
35:50 - we don't get to mm-hm all right so this
35:54 - doesn't work now we need to work on this
35:57 - one okay now for the prime factors here
36:06 - also we shouldn't go up the number
36:16 - think
36:18 - go to the square root right
36:25 - and we can also do what we did here
36:32 - skipping to at the time so one three
36:37 - like that
36:40 - two two two two
36:46 - well let's try
36:48 - [Laughter]
36:52 - okay now we get to a one
36:59 - so we have this case in there's where
37:02 - the largest prime factor it's the number
37:06 - itself
37:12 - whoa but look at this so we kind of
37:18 - passed the test the big one which is
37:22 - pretty great
37:25 - that means that we're not timed out
37:29 - anymore which is pretty pretty great now
37:32 - the only thing we need to figure out is
37:35 - what are we doing when the large prime
37:38 - factor is the number itself
37:44 - two two two two two
37:47 - let's think so
37:51 - [Music]
38:02 - but wise oh well I guess I think I know
38:07 - so if the number itself is a prime then
38:11 - that's the largest right so here we can
38:15 - just check if is prime so if the number
38:19 - is prime then we can just return the
38:23 - number right because it's itself and
38:28 - otherwise we need to do all this
38:30 - mumbo-jumbo fingerprint
38:34 - [Laughter]
38:36 - all right look at that we have one
38:40 - percent done of and this project Euler
38:45 - pretty nice so yeah see how we started
38:50 - with a brute-force and we slowly slowly
38:55 - adjusted the code to be faster and
38:58 - better and yeah okay yeah also marco is
39:08 - having good point
39:10 - someone also suggested this if we start
39:14 - from the back and yeah that will speed
39:16 - it up even even faster because yet the
39:21 - reason I didn't do from the back it's
39:23 - that we had this case scenario when we
39:26 - needed to return the number so I guess
39:31 - this is in the case where the number
39:34 - itself is a prime so then in order to
39:40 - simplify this well to speed this up even
39:43 - more we could do that we could start by
39:50 - setting I to be square root of the
39:53 - number we could we could go down to 1
39:59 - and we could do I minus 2 so this way
40:04 - whenever well I guess we could even
40:10 - not store the largest and just return
40:13 - now so if we find something like this
40:17 - return i right
40:20 - because we're fighting so the first one
40:23 - that's divisible by the number the is
40:27 - divisible by the number and if it's
40:29 - prime then it's the bigger bigger
40:31 - biggest prime right
40:35 - okay I think this speeds it up even more
40:38 - let's see okay so something's not good
40:49 - so square root we go up to one oh I see
40:56 - where we might so we might go we might
41:03 - skip the square root here might be
41:06 - something like an even number right so
41:09 - it might be something like 30 and then
41:11 - we're going to 28:26 24 so we're
41:15 - dropping like with two and they're all
41:17 - even number so they're not primes right
41:23 - then we need to see if this is even so I
41:30 - guess I could just tour
41:32 - so this is we'll already solve the
41:36 - problem and it works but sometimes it's
41:40 - good to stretch it a little bit more to
41:43 - make it better if you Canon well if you
41:45 - have the time I yeah I have the time so
41:50 - let's stretches stretch this even more
41:53 - so we want to store the square root
41:59 - right and we want to see if it's an even
42:02 - number and we'll start with that
42:06 - hello Edmundo and Lawrence thank you on
42:10 - behalf of free code camp not sure Quincy
42:13 - if I can do that to it thank you on
42:15 - behalf of a code camp for supporting
42:17 - their neuron that organ is organization
42:22 - all right so we start with this and if
42:27 - the square root is an even number then I
42:32 - guess let's add one to it so square root
42:35 - plus equals one right and now we can
42:39 - start with the
42:42 - the square root here and hopefully this
42:45 - will fix the bug we had and also speed
42:48 - this up even even faster okay so no hmm
42:55 - wasn't this the problem let's see what
42:58 - we get so if we do undefined okay so
43:07 - probably getting here it's not a number
43:13 - are we skipping it
43:18 - hmm let's cancel the flog all the ice to
43:21 - see okay so yeah look at that
43:28 - that's not good we have decimals so
43:31 - let's floor this all right
43:35 - and now do we get look at that we get 29
43:37 - so yeah should this work now us perfect
43:45 - I don't have time now but if you do have
43:50 - time use this solution and try to see
43:53 - what's the difference in the speed with
43:57 - the solution we had earlier but they say
44:00 - this is much much faster yeah although
44:05 - the curve is not the prettiest but oh
44:13 - okay let me know if you have any
44:16 - questions for this one don't be shy in
44:19 - the chat if you're in the chat say hi
44:21 - say say why say whatever you want
44:25 - it's a open communication it's not don't
44:31 - let me feel yeah all right so I guess we
44:38 - can submit this and go to the fourth one
44:46 - right ask me later please okay let's see
44:53 - palindrome this is nice so the largest
44:56 - palindrome product a palindromic number
45:00 - reads the same boat both ways so for
45:04 - example 1 1 2 2 1 1 is the palindrome
45:09 - because you can redo the same backwards
45:11 - and forwards or 1 0 0 1 or we have here
45:16 - 9 0 0 9 so it's the same it's the same
45:24 - thing select the chat
45:27 - [Music]
45:32 - okay
45:35 - not sure conceived Markham meant about
45:38 - project Euler to the back or just just
45:43 - the the challenge itself
45:50 - all right the largest palindrome made
45:54 - from the product of two digit number is
45:58 - nine thousand and nine so 91 times 99
46:03 - find the largest palindrome made from
46:06 - the product of two and digit numbers
46:11 - okay
46:14 - you
46:15 - hmm this is now quite interesting so yet
46:26 - there aren't a lot of taste test cases
46:32 - first we need to construct this number
46:37 - so these three digit numbers two digit
46:40 - numbers and we can start the same way we
46:44 - did the previous challenge so with the
46:46 - biggest number and then slowly decrease
46:50 - but the there's a catch here
46:58 - so what's the largest palindrome made
47:01 - from the product because well I'm
47:05 - thinking about having two loops right
47:07 - starting with 99 and 99 and then we do
47:10 - 99 times 99 or 99 times 9 8 and so on
47:14 - and so forth but then if we only drop in
47:18 - one loop we might get to a palindrome
47:22 - but then might not be the largest
47:35 - let's see
47:37 - so $4.99 we could 99 times 99 then drop
47:43 - to see in this case the correct answer
47:47 - is 99 times 91 so we could continue to
47:51 - drop one number right but something like
47:57 - this 97 and then we eventually get to 99
48:04 - times 91 which in this case works but we
48:11 - might get down to 99 times I don't know
48:15 - for the three digits we might get down
48:18 - to 99 999 times I don't know 101 for the
48:24 - three digits
48:25 - let me put three digits here and this
48:28 - could be a palindrome but it could not
48:32 - be the biggest
48:36 - the largest okay also we need a function
48:40 - to determine is palindrome this is
48:44 - another thing we have to do and yeah I
48:49 - was thinking also to drop them by one
48:51 - but then the toast also not it's not the
48:55 - best or we could just do the brute force
49:03 - Cal see all the palindromes and then
49:07 - return the largest yeah I think that
49:11 - should we start okay so let's have an
49:18 - array palindromes like this and now
49:23 - we're going to have two loops so
49:25 - starting with I equals so the N we're
49:29 - getting is the digit and in order to
49:32 - have so if we get to the big we want to
49:37 - start from 99 so let's see two two two
49:46 - two two
49:49 - [Music]
49:53 - it could do something like so the
49:59 - the number could be array array of n
50:05 - this will create an array of length n
50:07 - fill it up with nines and then join it
50:13 - so yeah let me show you what this black
50:18 - magic is so we're creating an array of
50:21 - length N and this array will be empty
50:25 - and then we're filling it up with the
50:27 - number nut so let me console like all
50:30 - the steps here so you can see so array
50:33 - of n then console dot log array of n
50:38 - fill with nine see we have an empty
50:42 - array and we have an array of 999 and
50:44 - then well we can cancel out this number
50:49 - which is array field join you can see
50:52 - here we have 999 but what this doesn't
50:58 - show is that this is a string so well we
51:05 - could say type off so you can see it's a
51:09 - string but we need a number so in order
51:11 - to convert to number we could use
51:12 - percent like this or what I usually do
51:18 - it's a at the plaza front where's the
51:22 - buff yeah all right okay
51:26 - now we have a number and this is the
51:29 - biggest number so I guess I could say
51:32 - biggest oh no just leave it number all
51:36 - right now let's go back to our loop
51:41 - well not sure I did if there we need the
51:44 - for-loop so let I will be number I
51:49 - greater than equals to 1 and I - - then
51:55 - for let J equals number so we want two
52:00 - loops because we want to do the
52:01 - multiplication there J greater than
52:04 - equals to 1 J minus - ok and now if I
52:11 - times J is a palindrome so is palindrome
52:20 - then we want to push it to the
52:22 - palindromes array and we're pushing to
52:24 - the array and then at the end we're
52:26 - going to get the biggest number
52:28 - palindromes that push
52:31 - well let's store this Const
52:34 - multiplication I times J and here we can
52:38 - do multiplication or and here if it's a
52:43 - palindrome we can do that alright let's
52:49 - return the palindromes here just to have
52:51 - something returned and let's create the
52:54 - is palindrome function so function is
52:59 - palindrome and we get here a number how
53:05 - do we check if this number is a
53:07 - palindrome okay so I can see here
53:11 - there's an infinite loop
53:17 - nickels ki- - I don't see why
53:24 - hmm that's interesting
53:28 - okay yeah that's what I want to do Mike
53:34 - did it already so we have a number and
53:38 - we need to check well we need to reverse
53:41 - it and check with itself right and if
53:44 - they are equal then that's vulnera so I
53:47 - want to return here the value of number
53:51 - two string and show you why we needed
53:54 - two string equals two
53:59 - number two string again so we're
54:02 - converting it to string because we can
54:05 - do now
54:06 - split so we can get all the characters
54:10 - of the string and convert them into an
54:13 - array we can reverse this array reverse
54:18 - oops
54:19 - can type and then we can join it back to
54:25 - a string so now this is the reverse
54:28 - string of the number and this is the
54:29 - number all right let's see so two string
54:35 - is played in an array we reverse the
54:38 - array and then we join back to a string
54:41 - but it still says that might be an
54:43 - infinite loop
54:48 - why
54:52 - you
54:54 - you
54:57 - [Music]
55:00 - can anyone see
55:06 - ever function
55:08 - yeah it's fact we want to use a arrow
55:12 - functions now but well guess we can't we
55:15 - could so why is this well now we have
55:21 - all the palindromes right but well I
55:24 - guess I need to forget to console that
55:26 - vlog this so here we should get a bunch
55:29 - of palindromes look at that
55:32 - so these are all the palindromes which
55:36 - are quite a lot and we need to get the
55:39 - maximum from this we can do that easily
55:43 - by saying Mad Max and with the structure
55:47 - the array so it will go inside the
55:52 - method max function
55:56 - and it should work now yeah I still
56:01 - don't know why it said that we have an
56:03 - infinite loop
56:07 - okay what will happen if we say four
56:11 - here yeah so it might run for a while
56:18 - this is why probably
56:21 - here the time test test stand out
56:27 - [Music]
56:30 - you
56:32 - and it's interesting so maybe if number
56:36 - is negative then there is an infinite
56:38 - loop because it will never be positive
56:39 - again well the number can be negative
56:42 - here we have 2 & 3 so from the test
56:45 - cases we can't really have a negative
56:47 - number and also if it's negative then
56:50 - this condition will be false right and
56:53 - it will not loop
56:58 - yeah so it shouldn't if the number is
57:03 - less than one
57:07 - then this condition will be false so it
57:10 - will run well it will get up to the loop
57:19 - all right yeah so this works
57:22 - although yeah I kind of don't understand
57:26 - why they say it's anything look oh wow I
57:31 - guess it works let's see if we could
57:36 - improve this so one way
57:42 - now we're looping over all the numbers
57:45 - so if we have 99 we're having 99 times
57:49 - 99 loops which is a lot and well in this
57:56 - case we only should look like eight
57:59 - times nine times to get to this value
58:03 - how can we
58:09 - how can we get to number to the to the
58:14 - big largest number faster so we don't
58:16 - have to loop over because it is not the
58:19 - best way now we're just getting all the
58:21 - Palin terms let's see
58:28 - last night
58:33 - and don't quite have an idea now
58:38 - [Music]
58:42 - there is something should be something
58:45 - so we can stop sooner
58:55 - you
58:58 - maybe saved a number yeah yeah that will
59:04 - be actually good we save but it's it
59:09 - improves it bad because instead of
59:13 - having an array of I don't know thousand
59:15 - numbers or and which is not that big
59:18 - we just have one number but yeah that's
59:20 - that makes sense so console are just I
59:25 - guess this needs to be minus infinity so
59:30 - the lowest number possible if it's
59:34 - palindrome and and
59:39 - and the multiplication is bigger than
59:43 - the largest then here we can set the
59:48 - largest to be the multiplication right
59:51 - so now we don't do this we just say
59:55 - largest and we need to convert this to
59:58 - let because we can't reassign constant
60:01 - okay this should still work and we saved
60:04 - a bit of time here that's right I'm just
60:07 - looking here so I don't want this kind
60:11 - of
60:15 - mm-hmm
60:22 - you
60:30 - okay yeah I guess we should move on and
60:34 - if you yeah by the way I didn't say this
60:38 - in the beginning I should have these
60:41 - challenges you should try to do them on
60:44 - your own and then well these life stone
60:49 - will be uploaded and probably this
60:50 - section of project Euler will be
60:55 - uploaded separately so you can watch it
60:58 - then right
61:03 - the loop doesn't need to continue if
61:06 - much smaller than largest perhaps yeah
61:10 - it might student but so for example in
61:15 - this case we get 291 times 99 right so
61:19 - we only have like 10 loops but we could
61:26 - get so we might have a case where we
61:31 - have like 98 times something being the
61:36 - biggest so then because of this number
61:39 - going lower than jumping back up 99
61:43 - multiplied by this number being wants
61:47 - being a smaller number then the product
61:50 - of them will be bigger so yeah that's
61:53 - also not that's also not the perfect
61:56 - solution
62:02 - all right yeah I guess huh let's leave
62:07 - it like this for now I kind of have
62:11 - something in my mind somewhere I think I
62:14 - saw this but they for some reason can't
62:19 - remember now so if you find this
62:24 - dissolution please let me know well the
62:28 - faster solution and I'll be glad to take
62:31 - a look and I'm curious
62:33 - I make search for it after this dream
62:36 - all right and let's see
62:41 - okay
62:47 - let's wrap it up now we did four let's
62:51 - go back so we did four challenges and
62:57 - we're going to I'm not sure yet on which
63:00 - days I'm going to be live on free code
63:03 - camp we still not to still have to
63:05 - figure that out but I'm going to be live
63:07 - every week and we're going to continue
63:09 - this now for those of you who are
63:11 - watching and I highly recommend you
63:16 - taking part of this challenge it's
63:18 - pretty fun I recommend that you'll take
63:23 - a look at these problems and try to
63:25 - solve them on your own and when I'm
63:28 - doing live during the live and well
63:31 - don't spoil the answer to me but then
63:35 - you can see how I'm solving it and well
63:39 - it it will be much much useful for you
63:45 - than just seeing me solve this right so
63:49 - yeah I guess I guess that's it I hope
63:53 - you liked it let me know in the chat if
63:55 - you did and if you won meat is still to
64:00 - continue to do this
64:05 - thank you for Africa camp for letting me
64:08 - do this on their channel it's a no it's
64:11 - more than I ever expected I'm doing very
64:14 - grateful for that and yeah let's help
64:19 - developers get better programming find
64:23 - it well my job is to make programming
64:27 - fun and yeah thank you all for watching
64:34 - Thank You Lawrence for for your
64:36 - encouragement thank you all for joining
64:38 - and I'll see you in the next live stream
64:42 - have a great great day forward bye

Cleaned transcript:

hello well welcome everyone to this nice very nice introduction and thank you Quincy it's oh boy I think one day if I need someone to if I need someone to sell myself I will definitely hire Quincy so let me know if everything is right if you can hear me my name is Lauren pop I'm a developer from Romania I've been coding for seven years and in November I started a YouTube channel you can subscribe there if you want to follow me we have almost daily live streams and different tutorials and also if you want feel free to follow me on Twitter we're posting almost daily and yeah let's start working on this new crazy challenge Quincy has been has been asking me to start this because well yeah it's an interesting challenge and we're going to do it on the free code camp website and we're going to do it with JavaScript which is pretty nice yeah hello Eduardo feel free feel free to join the chat this will be this won't be that kind of animal tutorial where I'm teaching you and I know it's all formal it's just us hanging out sort of and solving coding challenges with JavaScript this is whoops this is what I'm doing on my channel also so I haven't prepared for these challenges because I wanted you to to see the progress so I wanted you to see that it's it's okay to fail it's okay to Google sometimes things it's okay to not have the perfect solution and yeah it's all part of developer journey keep in mind that I've been programming for seven years I've been working as a freelancer I had a job than freelancer again and another job and then I turned into content creator this is what I really like to do so yeah thank you freakin camp for giving me this huge opportunity I usually stream for 4050 people there are thousands and so people now watching which is crazy I was pretty nervous but now I find ya so say hi in the chat if you're watching if you can also it's don't tell anyone but my opinion you should support a freaking cab Channel it's they're doing an amazing thing so feel free to become a member and then you will be able to join the chat if you have questions at any time feel free to ask them also I might need your help sometimes so feel free to help me and yeah hello TM sunny Eric hi all of you okay so yeah let's see what's the take a jar how are you today so this is the project Euler set of problems coding challenges I will be this will be the first series and then I will be doing I think weekly live streams in which we're going over these problems there are hundreds of problems but this challenge is the first 100 now I'm not sure if we can go over all of them like that fast because they're getting harder and harder but well we're going to try all right so yeah project Euler is the cities of challenging mathematical and computer programming problems meant to delve delve into and familiarize oh by the way if my English is I think she's off that's because of nothing in native English speakers so yeah any time you don't understand what I'm rambling around feel free to stop me and yeah wait what as I said I usually am on my channel we're all here as a family we're learning together we're having fun I don't have my orange lemonade now you really have an origin mone don't we yeah we had worth having fun okay so I was thinking that in this stream we should do the first four or five problems to see how it goes as I said I haven't really look into it just that just the titles but we should be fine hopefully hello Travis how it's going also so yeah the first problem multiplies of three and five if we list all the natural numbers below 10 that are multiplies of three or five we get three five six and nine all right the sum of this multiplies is 23 okay so we need to add up the sum of the multiplies of three or five all right find the sum of all the multiples of three or five below the provided parental value number okay so apparently we have a function which gets in a number and we need to return the sum of the multiplies all right so let's see first we should probably loop over all the numbers from 1 up to well the number provided and we should check if that number so all the numbers in the loop if there are multiplies of 3 or 5 so if they their modulus I guess the division by 3 doesn't have any reminders hopefully I said that right right okay so hey Adam yeah thank you good so let's see we want to create our loop let me know if the font size is big enough if you can see the code I don't know if my face is in the way or I should probably remove these social buttons or whatever they are and yeah if anything is not okay just let me know and we can fix it all right so we're going to do a for loop starting with one well I guess yeah we should start with one because we could have a number less than three right so we should start with one and then we want to go up to the number right so I less equals than the number I plus plus okay and so first I'm going to do like a brute force thing so not very optimized and then we can try to improve it if if we find find a better way to do it hello Marco so yeah thank you by the way thank you to all the poppers the poppers are those who been following me yeah the poppers family thank you all of you for being part of this you've been very supportive I was very nervous at the beginning and yet highly appreciate you being here also Marco seems that he became a member to be in the chat so yeah very nice of you all right so we're looping over all these numbers now we need to see if they are multiplies of multiplies of three or five I guess I don't need this anymore all right so let's check here if I right so if I modulus three is zero or what and that's yeah you'll hear a lot of oops you're here a lot of goodygoodies your Hill a lot of things I just hope you enjoy it and the most important thing I really hope that you're learning something and yeah what we should be looking for is to become every day to become just you know if we can become one percent better than we were yesterday that's already a huge so yeah good so one one zero is five equals zero I always mix up it is the modulus operator or yeah someone correct me if I'm wrong I might be wrong multiple times oh that's right okay so if that's the case then we want to add this I to a sub right so let's create the sum with let not beat Const let's um first will be equal to zero and here we can say some classical's i right and so they will add up let's make some space here to have a pretty code and at the end we should return some right hmm if my logic is correct hopefully it is this should be good so let's see all right something is off what did I do wrong so if it's three or five then we should add AI K up mm that should be hmm does anyone notice and think where it could be the issue all right let's let's console that clock and see what we get so for a thousand we should get to top two hundred thirty two thousand one hundred sixtyeight and we get oh okay I think I know where the problem is so you can see the difference between this and the value we should get it's like 1000 and 1000 is the number we're looking so yeah it says here below the provided very parametric value so that's the issue we went up to including the number so we just need to remove here the equals and now you can see that we are getting the correct answer and let's run this and look at that pretty nice we solve the first one awesome all right let's think yeah I less the number Thank You Kaja I also keep in mind that there might be a delay from the time you're saying this well do the time you're commenting in the chat and I'm saying that so yeah keep that in mind all right could we improve this or should we think about improving something like this I always try to think maybe we could have some kind of ray method or something fancy but yeah it doesn't seem like you know we should even think about something it's pretty clear we have a sum which is zero then we'll loop over all the numbers and if they are multiplies of three or five then we are the sum so I guess this should be a pretty good solution if you have an idea of how can we prove this maybe I don't see it or who knows let me know but for now let's submit this angle to the next challenge all right good the second one even Fibonacci numbers now let's see what this requires each new term in a Fibonacci sequence is generated by adding the previous two terms by starting with one and two so yeah we have one and two the next one will be one plus two for those who don't know about the Fibonacci sequence then we have two plus three equals five then we have three plus five equals 8 and then we have so so on and so forth all right by considering the terms in the Fibonacci sequence whose values do not exceed an so again we don't need to go over and find the sum of the even value terms alright so let's take some notes we need to not exceed and what I'm writing here okay so up to n then we need even numbers all right and we need the numbers will be in a Fibonacci sequence right okay look at this motivating message you can do it alright we can do so I guess we should start by having the Fibonacci numbers the first two Fibonacci numbers right okay so the Fibonacci values should not exceed all right so let's do the following let a be the first one or I guess we could call it a be the first B one and let be me too okay so these are the first two Fibonacci numbers and now we want to go to keep adding these and changing the these variables this is why I used to add until we are up to the app so again now because we don't know exactly last time we use the for loop because we knew exactly how many steps we have but this time we don't know exactly the number of steps so we're going to use a while loop so then we're going to use while and we need a condition here which will be the condition so in the next loop B will equal well a will equal B so a will be two and B will equal a plus B right so it will be the next number so we need to check while B less than and right so this is our not exceeding it okay and also need to keep in mind that we need the even numbers all right and we need a sound so let's create that variable sum will be let's think we want the sum to be zero or we want the sum to be a plus B by default I guess will be a plus B oh but no because a will be an odd number so we only want the even number so that's be right we should we have be less than and Escada no because we want to go up to and knotek's oh yeah see yeah you're right so it not exceeding means that it doesn't go over so it could be up to and including very good thanks yeah so nothing's not exceeded but included okay good good catch see ya we might sometimes just mess it up but it's fine and this is why I like the live streams well on one hand I just just I know get the fool of myself but on the other hand I have helped my helpers here which will make sure that whenever I fail it will still around okay yeah and we'd also figure out when the code fails so probably this is a bit overthinking on my side just to buy the know lay out the building structures I guess the oh okay so here we want to get the new values so the new Fibonacci number which has said that a will be B and B will be a plus B but here is an issue because now we modified a here so we need a temporary value in which we're going to store a then we're going to change a to be B so it will be the next element in the Fibonacci sequence and then here instead of storing into a we're going to do temporary plus B all right and now if B is even so meaning that the division back to the reminder should be zero right so if it's even we want to add it to the Sun so sound plus equals B now if my logic is correct and I didn't screw it up at the end we should some and let's run to see look at that so this time we did it correctly yeah let me know if you understood this let me know if you have any questions I'm going to wait after I finish one one challenge just to make sure that everything is you understood everything yeah so apparently all the tests here running correctly for ten it should be a number sixty one thousand one hundred thousands of these numbers go like so big which is pretty pretty interesting okay I don't see any questions in the chat so I guess we can go to the next one now mmm well actually let me think could we improve this anyway I don't have an adn now I'm thinking about using recursion to find out the Fibonacci numbers but yeah that's probably not for this challenge so yeah let's move on to the next one all right largest prefect or prime factor okay so the prime factor of 13,000 195 are five seven thirteen and twenty nine what is the largest prime factor of the given number okay so let's see that's right again what we need to do so mmhmm we need the prime factor so not only the factor is the prime on so we need to check and we need to have a function is prime okay so well let's see this will check if a number is prime okay all right then we would probably loop again over the entire numbers as we did in the first challenge so from 1 up to the number but I knew that there is a trick so we don't actually have to go up to the number because I think there was either going up up to the half of the number or the square root of the number so I never really really got this exactly so we're going to test it because you can see here we have a huge huge huge number and well doing the loop over let's see thousand millions billions that's well that's huge also being the prime weekend we need to check all the number so we need to check if is divisible by only one and itself so it doesn't have any divisors I guess yeah so for loop up to to half let's go up to half of the number because so if you're thinking about twenty right so then which is half of it it is a divisor right but eleven it's not anymore and also twelve and thirteen all the numbers from half up but also ten it's not a prime because yeah it has it divisible by 2 and 5 hmm okay let's loop so we need often just the largest so we're going to keep track of the largest so that largest first will be and should start with one and now we're going to let me remove this so for left I equals I think we can start with two or should one is definitely not the biggest but oh well let's start with 1 I less than or equal to half of the number number divided by 1/2 divided by 2 and I plus plus okay now we need to check if is prime so the i if is prime and well actually we can do i number modulus equals zero and it's a prime right so prime factors okiedokie and I did this we're going to create another function just to make it more readable so is Prime and we're going to give it a number and here let's see we want to start from two so let I equals 2 because 1 is divisible so being a prime means it's only divisible by 1 and itself so we want to loop over all the other numbers or so from 2 up to the number and if we find the divisor then it's another prime okay I guess this also could go up to 1/2 hmm let's do the brute force and then if it fails we can optimize it so let I equal to I less than the number I plus plus okay and now if number divisible by zero then we can already return false right so we get up the function and we turn false otherwise we can return true and this is a prime number so let me put this here nice little bit okay so [Laughter] Quincy again speaking highly of me but I don't deserve it okay so we're looking over the numbers and now if this is the case so if it's divisible and if it's a prime then we want to store it in the largest so largest should be I right because that's the little loop okay and here we can return the largest all right this is my logic let's see if it's a good one okay so something's wrong let's do some yeah look at that test timed out so this might be a problem for us okay because it's a huge number I said that we'll do four or five but maybe we'll get stuck at three alright first let's let's cancel that lot to see what we get and whites and not working okay so for this we get 29 that's good for two we get two one okay that's because we go up to half and apparently doesn't good so let's see what happens for three I guess it's the same thing and we get only one four five yes apparently that's not okay let's go up to the number prime factors yeah feel free to correct me if you see the mistake there might be a couple all right so this should work for few but Danakil Thank You Quincy yeah also feel free to support the freaking camp channel by donating if you want super chat it will help the organization alright now yeah this is what I was afraid of we're passing these these tests but the big one is pretty big I'm happy to see that you enjoyed it Adam yeah this is what I did with the free code camp curriculum and also I'm going to do it again with the Piton series after everything's working and all always good so Andrews saying that in is prime only need to check if number is divisible by two three five and seven all other numbers are divisible by one of these ends if not a prime value yeah but it could be a for example 13 is a prime so I'm not sure if that will work yes sir now it's failing because of its test timeout so we need to reduce the number of loops we have which will be pretty interesting and yeah so cassia is saying so if I mispronounce your name sorry it's saying that instead of for lo pruning running from one equal from I equals to one can we run i cost a number divided by two till i is bigger than one so you're saying which should look backwards yeah that would be an idea and then we save half of the half of the loops yeah and I'm glad I did okay but then well we're going to have the same issue where we won't have to entry if we do equals the half of the number right and we can also not change the largest so let let's comment this out we need to do something slowly figure it out they're probably must be some kind of fancy thing to delete but let's try this so let by equals number divided by two I bigger than I guess one we can go there I I so we go the other way around and I guess we can check the same thing now the issue here will be for example for we won't have to write and also I let's make it let's floor this number so we have a fixed number so fluorine if the number is not a prime it is bound to have a factor factor less then its square root according to the common mathematical theorem yeah so this is Matt Matt Matt ish yes I knew something about the square root so you say that here we should go up to the square root of number Matt square root right so this should save some loops also if you check divisibility by two before the loop you can start with I equals three and increment by 2 instead of incremented by 1 that's another good good suggestion because we know that 4 is not a prime right so what you're saying here is that we can start with 3 we can increment by 2 so it will be 3 5 7 9 and here if the number is divisible by 2 then we can return false right so this is 4 for the two case alright for two kids [Laughter] and yeah for case we're divisible by two yeah I wanted to the comment nevermind alright so this will save a lot of loops to check the prime let's see how this works for a number now yes so it still should return to still timed out why did you have to do so big of a number alright so let's think well this is divisible by two but if it's two we want to return true right it might be two the number itself might be two so then it we should allow it so we need to check if is divisible by 2 and the number is different than two then we should return false right and now it should work for for this test case but we still have a lot of loops IFS let's see what we could improve I could try this now but yeah my only issue with this is that the largest yeah you can see that it's not working I guess we could do a seal but still we don't yet we don't get to mmhm all right so this doesn't work now we need to work on this one okay now for the prime factors here also we shouldn't go up the number think go to the square root right and we can also do what we did here skipping to at the time so one three like that two two two two well let's try [Laughter] okay now we get to a one so we have this case in there's where the largest prime factor it's the number itself whoa but look at this so we kind of passed the test the big one which is pretty great that means that we're not timed out anymore which is pretty pretty great now the only thing we need to figure out is what are we doing when the large prime factor is the number itself two two two two two let's think so but wise oh well I guess I think I know so if the number itself is a prime then that's the largest right so here we can just check if is prime so if the number is prime then we can just return the number right because it's itself and otherwise we need to do all this mumbojumbo fingerprint [Laughter] all right look at that we have one percent done of and this project Euler pretty nice so yeah see how we started with a bruteforce and we slowly slowly adjusted the code to be faster and better and yeah okay yeah also marco is having good point someone also suggested this if we start from the back and yeah that will speed it up even even faster because yet the reason I didn't do from the back it's that we had this case scenario when we needed to return the number so I guess this is in the case where the number itself is a prime so then in order to simplify this well to speed this up even more we could do that we could start by setting I to be square root of the number we could we could go down to 1 and we could do I minus 2 so this way whenever well I guess we could even not store the largest and just return now so if we find something like this return i right because we're fighting so the first one that's divisible by the number the is divisible by the number and if it's prime then it's the bigger bigger biggest prime right okay I think this speeds it up even more let's see okay so something's not good so square root we go up to one oh I see where we might so we might go we might skip the square root here might be something like an even number right so it might be something like 30 and then we're going to 2826 24 so we're dropping like with two and they're all even number so they're not primes right then we need to see if this is even so I guess I could just tour so this is we'll already solve the problem and it works but sometimes it's good to stretch it a little bit more to make it better if you Canon well if you have the time I yeah I have the time so let's stretches stretch this even more so we want to store the square root right and we want to see if it's an even number and we'll start with that hello Edmundo and Lawrence thank you on behalf of free code camp not sure Quincy if I can do that to it thank you on behalf of a code camp for supporting their neuron that organ is organization all right so we start with this and if the square root is an even number then I guess let's add one to it so square root plus equals one right and now we can start with the the square root here and hopefully this will fix the bug we had and also speed this up even even faster okay so no hmm wasn't this the problem let's see what we get so if we do undefined okay so probably getting here it's not a number are we skipping it hmm let's cancel the flog all the ice to see okay so yeah look at that that's not good we have decimals so let's floor this all right and now do we get look at that we get 29 so yeah should this work now us perfect I don't have time now but if you do have time use this solution and try to see what's the difference in the speed with the solution we had earlier but they say this is much much faster yeah although the curve is not the prettiest but oh okay let me know if you have any questions for this one don't be shy in the chat if you're in the chat say hi say say why say whatever you want it's a open communication it's not don't let me feel yeah all right so I guess we can submit this and go to the fourth one right ask me later please okay let's see palindrome this is nice so the largest palindrome product a palindromic number reads the same boat both ways so for example 1 1 2 2 1 1 is the palindrome because you can redo the same backwards and forwards or 1 0 0 1 or we have here 9 0 0 9 so it's the same it's the same thing select the chat okay not sure conceived Markham meant about project Euler to the back or just just the the challenge itself all right the largest palindrome made from the product of two digit number is nine thousand and nine so 91 times 99 find the largest palindrome made from the product of two and digit numbers okay you hmm this is now quite interesting so yet there aren't a lot of taste test cases first we need to construct this number so these three digit numbers two digit numbers and we can start the same way we did the previous challenge so with the biggest number and then slowly decrease but the there's a catch here so what's the largest palindrome made from the product because well I'm thinking about having two loops right starting with 99 and 99 and then we do 99 times 99 or 99 times 9 8 and so on and so forth but then if we only drop in one loop we might get to a palindrome but then might not be the largest let's see so $4.99 we could 99 times 99 then drop to see in this case the correct answer is 99 times 91 so we could continue to drop one number right but something like this 97 and then we eventually get to 99 times 91 which in this case works but we might get down to 99 times I don't know for the three digits we might get down to 99 999 times I don't know 101 for the three digits let me put three digits here and this could be a palindrome but it could not be the biggest the largest okay also we need a function to determine is palindrome this is another thing we have to do and yeah I was thinking also to drop them by one but then the toast also not it's not the best or we could just do the brute force Cal see all the palindromes and then return the largest yeah I think that should we start okay so let's have an array palindromes like this and now we're going to have two loops so starting with I equals so the N we're getting is the digit and in order to have so if we get to the big we want to start from 99 so let's see two two two two two it could do something like so the the number could be array array of n this will create an array of length n fill it up with nines and then join it so yeah let me show you what this black magic is so we're creating an array of length N and this array will be empty and then we're filling it up with the number nut so let me console like all the steps here so you can see so array of n then console dot log array of n fill with nine see we have an empty array and we have an array of 999 and then well we can cancel out this number which is array field join you can see here we have 999 but what this doesn't show is that this is a string so well we could say type off so you can see it's a string but we need a number so in order to convert to number we could use percent like this or what I usually do it's a at the plaza front where's the buff yeah all right okay now we have a number and this is the biggest number so I guess I could say biggest oh no just leave it number all right now let's go back to our loop well not sure I did if there we need the forloop so let I will be number I greater than equals to 1 and I then for let J equals number so we want two loops because we want to do the multiplication there J greater than equals to 1 J minus ok and now if I times J is a palindrome so is palindrome then we want to push it to the palindromes array and we're pushing to the array and then at the end we're going to get the biggest number palindromes that push well let's store this Const multiplication I times J and here we can do multiplication or and here if it's a palindrome we can do that alright let's return the palindromes here just to have something returned and let's create the is palindrome function so function is palindrome and we get here a number how do we check if this number is a palindrome okay so I can see here there's an infinite loop nickels ki I don't see why hmm that's interesting okay yeah that's what I want to do Mike did it already so we have a number and we need to check well we need to reverse it and check with itself right and if they are equal then that's vulnera so I want to return here the value of number two string and show you why we needed two string equals two number two string again so we're converting it to string because we can do now split so we can get all the characters of the string and convert them into an array we can reverse this array reverse oops can type and then we can join it back to a string so now this is the reverse string of the number and this is the number all right let's see so two string is played in an array we reverse the array and then we join back to a string but it still says that might be an infinite loop why you you can anyone see ever function yeah it's fact we want to use a arrow functions now but well guess we can't we could so why is this well now we have all the palindromes right but well I guess I need to forget to console that vlog this so here we should get a bunch of palindromes look at that so these are all the palindromes which are quite a lot and we need to get the maximum from this we can do that easily by saying Mad Max and with the structure the array so it will go inside the method max function and it should work now yeah I still don't know why it said that we have an infinite loop okay what will happen if we say four here yeah so it might run for a while this is why probably here the time test test stand out you and it's interesting so maybe if number is negative then there is an infinite loop because it will never be positive again well the number can be negative here we have 2 & 3 so from the test cases we can't really have a negative number and also if it's negative then this condition will be false right and it will not loop yeah so it shouldn't if the number is less than one then this condition will be false so it will run well it will get up to the loop all right yeah so this works although yeah I kind of don't understand why they say it's anything look oh wow I guess it works let's see if we could improve this so one way now we're looping over all the numbers so if we have 99 we're having 99 times 99 loops which is a lot and well in this case we only should look like eight times nine times to get to this value how can we how can we get to number to the to the big largest number faster so we don't have to loop over because it is not the best way now we're just getting all the Palin terms let's see last night and don't quite have an idea now there is something should be something so we can stop sooner you maybe saved a number yeah yeah that will be actually good we save but it's it improves it bad because instead of having an array of I don't know thousand numbers or and which is not that big we just have one number but yeah that's that makes sense so console are just I guess this needs to be minus infinity so the lowest number possible if it's palindrome and and and the multiplication is bigger than the largest then here we can set the largest to be the multiplication right so now we don't do this we just say largest and we need to convert this to let because we can't reassign constant okay this should still work and we saved a bit of time here that's right I'm just looking here so I don't want this kind of mmhmm you okay yeah I guess we should move on and if you yeah by the way I didn't say this in the beginning I should have these challenges you should try to do them on your own and then well these life stone will be uploaded and probably this section of project Euler will be uploaded separately so you can watch it then right the loop doesn't need to continue if much smaller than largest perhaps yeah it might student but so for example in this case we get 291 times 99 right so we only have like 10 loops but we could get so we might have a case where we have like 98 times something being the biggest so then because of this number going lower than jumping back up 99 multiplied by this number being wants being a smaller number then the product of them will be bigger so yeah that's also not that's also not the perfect solution all right yeah I guess huh let's leave it like this for now I kind of have something in my mind somewhere I think I saw this but they for some reason can't remember now so if you find this dissolution please let me know well the faster solution and I'll be glad to take a look and I'm curious I make search for it after this dream all right and let's see okay let's wrap it up now we did four let's go back so we did four challenges and we're going to I'm not sure yet on which days I'm going to be live on free code camp we still not to still have to figure that out but I'm going to be live every week and we're going to continue this now for those of you who are watching and I highly recommend you taking part of this challenge it's pretty fun I recommend that you'll take a look at these problems and try to solve them on your own and when I'm doing live during the live and well don't spoil the answer to me but then you can see how I'm solving it and well it it will be much much useful for you than just seeing me solve this right so yeah I guess I guess that's it I hope you liked it let me know in the chat if you did and if you won meat is still to continue to do this thank you for Africa camp for letting me do this on their channel it's a no it's more than I ever expected I'm doing very grateful for that and yeah let's help developers get better programming find it well my job is to make programming fun and yeah thank you all for watching Thank You Lawrence for for your encouragement thank you all for joining and I'll see you in the next live stream have a great great day forward bye
