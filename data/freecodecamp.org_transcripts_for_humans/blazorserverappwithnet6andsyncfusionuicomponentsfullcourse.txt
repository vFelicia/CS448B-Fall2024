With timestamps:

00:00 - learn how to build a sales management
00:02 - application in this comprehensive sync
00:04 - fusion course from gavin lawn gavin has
00:07 - decades of experience that he brings to
00:09 - his courses and think fusion provided a
00:12 - grant that made this course possible hi
00:14 - i'm gavin lon i've been developing
00:16 - software professionally for over 20
00:18 - years and i'm especially excited to
00:20 - bring you this free course where we are
00:22 - going to use the sophisticated sync
00:24 - fusion components and we are going to
00:26 - build a blazer server application on net
00:29 - six the components are highly
00:31 - customizable and are fine-tuned for
00:33 - performance when dealing with high
00:36 - volumes of data
00:37 - so please join me as we develop a blazer
00:40 - application where we'll integrate the
00:41 - sophisticated syncfusion components into
00:44 - our application and we'll also integrate
00:47 - microsoft identity into our application
00:50 - syncfusion provides a ui component suite
00:53 - for building powerful web desktop and
00:56 - mobile apps
00:58 - essential studio is a software package
01:01 - provided by syncfusion that provides
01:03 - state-of-the-art solutions for startups
01:06 - and enterprises it includes more than
01:09 - 1700 components and frameworks for
01:11 - winforms wpf asp.net web forms mvc core
01:17 - uwp win ui
01:19 - xamarin flutter blazer javascript
01:22 - angular vue and react that make
01:25 - developers work easier
01:28 - please join me in this free course
01:30 - where we are going to build a real world
01:32 - sales management application using
01:34 - blazer during this course we are going
01:37 - to integrate some of the most popular
01:38 - syncfusion components in our blazer
01:41 - application like the data grid the list
01:43 - view
01:45 - the charts
01:47 - the diagram
01:49 - the scheduler and more
01:52 - laser is a web framework for building
01:54 - web ui components razer components that
01:57 - can be hosted in different ways razer
01:59 - components can run server side in
02:02 - asp.net core blazer server versus client
02:05 - side in the browser on a web assembly
02:10 - for the application that we are going to
02:11 - develop
02:12 - we are going to use the blazer server
02:14 - hosting model
02:16 - we will first develop the logic for each
02:18 - razor component where we will learn how
02:21 - we are able to harness the power and
02:23 - sophistication of the sync fusion
02:25 - components that we'll integrate into our
02:28 - application through the implementation
02:30 - of minimal amounts of code
02:32 - toward the end of the course we'll
02:34 - integrate login registration
02:36 - authentication and authorization
02:38 - functionality into our blazer server
02:40 - application using microsoft identity
02:44 - when an employee logs on to the sales
02:46 - management application they'll be able
02:48 - to access a personalized dashboard
02:52 - where these beautiful sync fusion charts
02:54 - will be displayed presenting the user
02:56 - with data of relevance to the logged on
02:58 - employee for example a sales manager
03:01 - will see sales metrics related to
03:03 - overall performance for the sales
03:05 - department
03:06 - a team leader will see sales metrics
03:08 - related to the sales performance of each
03:11 - of the team leaders team members
03:14 - the sales rep will see metrics related
03:16 - to the sales reps personal sales
03:18 - performance
03:20 - so if you go through this course with me
03:23 - i can guarantee you you are going to
03:25 - learn a tremendous amount about creating
03:28 - a sophisticated web application using
03:30 - blazer sync fusion components and
03:33 - microsoft identity
03:36 - so let me tell you more about the
03:38 - application that we are going to build
03:40 - using blazer server and the sync fusion
03:43 - components
03:44 - i've created a fictional company that
03:46 - i've named outdoor excellence or oexl
03:50 - for short this company sells outdoor and
03:53 - sporting goods to retail outlets
03:55 - situated around the united states
03:58 - the application is specifically for the
04:01 - sales department
04:03 - that consists of a sales manager
04:05 - team leaders that report to the sales
04:08 - manager and sales reps that report to
04:11 - their team leader
04:13 - the sales reps are on the road most of
04:15 - the time visiting clients and
04:17 - facilitating orders made by the clients
04:20 - for products sold by outdoor excellence
04:24 - our application will provide an ordering
04:27 - facility where a sales rep can for
04:29 - example order multiple products from the
04:32 - outdoor excellence product catalog
04:34 - displayed through our blazer application
04:36 - using the sync fusion list view
04:38 - component the sales rep could for
04:40 - example order multiple products through
04:42 - our application using a mobile device
04:45 - while in a meeting with a client
04:47 - a team leader or the sales manager can
04:50 - view their own personal dashboards and
04:52 - view analytical data displayed using
04:55 - syncfusion charts through our
04:56 - application so bob jones the sales
04:59 - manager could log in for example from
05:01 - his office on his desktop computer and
05:04 - view metrics beautifully displayed to
05:06 - him in the relevant sync fusion charts
05:09 - that have been integrated into our
05:10 - application bob jones can then use these
05:13 - sales metrics for decision making and
05:16 - strategic planning
05:18 - if for example olivia mills a sales rep
05:21 - places a large order through the system
05:24 - bob jones can see in real time the
05:26 - effect that the order has on current
05:29 - sales metrics through his personalized
05:32 - dashboard each sales rep can view their
05:35 - own personal dashboard when they log on
05:37 - to the system
05:38 - custom reports regarding their personal
05:41 - performance is available through the
05:43 - data expressed on these sophisticated
05:45 - charts provided by syncfusion a team
05:48 - leader is interested in the performance
05:50 - of the team leaders team members and is
05:53 - able to log on to the application
05:55 - perhaps at a desktop computer in the
05:57 - team leader's office
05:58 - and can see in real time how each team
06:01 - member is performing
06:03 - these charts communicate at a glance how
06:05 - the team is performing overall as well
06:08 - as how each individual team member is
06:10 - performing relative to the other team
06:12 - members
06:14 - bob jones the sales manager has
06:17 - administrative permissions and is able
06:19 - to perform crud create read update
06:22 - delete operations on employee data
06:26 - this functionality is facilitated using
06:28 - the syncfusion data grid
06:30 - bob jones is also able to view the
06:32 - employee organizational hierarchy of his
06:35 - sales department
06:37 - this display is facilitated through the
06:40 - use of the syncfusion diagram component
06:43 - so through the system bob jones can for
06:45 - example using the syncfusion data grid
06:48 - change which team leader a sales rep
06:51 - reports to
07:02 - and the change is reflected immediately
07:05 - within the syncfusion diagram depicting
07:08 - the employee organizational hierarchy
07:40 - bob can of course also add new employees
07:43 - to the system using this facility
08:12 - you can also change basic information
08:14 - associated with employees like for
08:16 - example changing someone's last name if
08:19 - for example the relevant employee gets
08:21 - married
08:38 - the data grid provides bob with
08:39 - conveniences like for example a search
08:42 - facility
08:52 - sorting functionality for each column
08:56 - and he can also easily export the data
08:59 - displayed on the data grid into other
09:02 - common application formats for example
09:04 - he can export the relevant data to an
09:07 - excel spreadsheet or a pdf document
09:19 - each employee is able to create
09:21 - appointments within the sales management
09:24 - application using this functionality
09:26 - implemented through the integration of
09:28 - the sync fusion scheduler component
09:31 - for example a sales rep can create an
09:34 - appointment in the system to meet a new
09:36 - client at a specific date and time and
09:39 - for a specific duration extra
09:41 - information about the meeting can also
09:43 - be saved for each appointment
10:00 - a team leader for example is able to
10:02 - create appointments within the
10:03 - application
10:04 - for meetings with team members
10:19 - as with all the syncfusion components
10:21 - the scheduler
10:23 - is highly customizable
10:30 - all of the technologies that we'll use
10:32 - to build our sales management
10:34 - application for outdoor excellence can
10:36 - be downloaded free of charge
10:39 - links have been included in the
10:40 - description of this video to the
10:42 - locations of where you can download and
10:45 - install the relevant technologies
10:48 - we'll be using visual studio 2022
10:50 - community edition for windows as our ide
10:54 - integrated development environment to
10:56 - develop the application we'll develop
10:58 - the application on.net 6.
11:02 - you can download and install visual
11:04 - studio from this location free of charge
11:08 - we'll be using sql server 2019
11:11 - as our back-end storage facility
11:14 - you can download sql server 2019 from
11:17 - this location
11:20 - on occasion we'll be using sql server
11:23 - management studio or ssms to update our
11:26 - data and you are able to download ssms
11:30 - from this location
11:33 - note that even if you don't have a sync
11:35 - fusion license you'll be able to follow
11:38 - along with this course
11:39 - but if you want to use the syncfusion
11:41 - components to develop commercial
11:43 - applications
11:45 - you will need a valid license
11:47 - you are able to claim a free syncfusion
11:50 - community license by clicking this link
11:53 - here and then following the appropriate
11:55 - steps
11:56 - in order to claim your free community
11:58 - license you'll need to have a valid
12:01 - linkedin or zing account
12:03 - the community license allows you to use
12:05 - syncfusion's entire product line free of
12:08 - charge in your commercial applications
12:11 - if you own the intellectual property of
12:13 - the relevant applications the community
12:16 - license is a complimentary license model
12:19 - that is reserved for organizations
12:21 - earning up to 1 million us dollars in
12:24 - revenue and employing fewer than 5
12:27 - developers
12:29 - if this does not apply to you you will
12:31 - need to get a paid license
12:34 - please navigate to this url to learn
12:37 - more about syncfusion's hassle-free
12:39 - licensing model
12:42 - in order to install the syncfusion
12:44 - components during the development of our
12:46 - application we'll use the new get
12:48 - package manager from within visual
12:50 - studio to download and install the
12:53 - relevant syncfusion packages when we are
12:55 - ready to integrate the relevant
12:57 - syncfusion components into our
12:59 - application
13:04 - although we are developing the
13:05 - application on a windows os our
13:08 - application will be cross-platform and
13:10 - we'll be able to run on most browsers
13:13 - i will be using the chrome browser for
13:15 - running the code interactively through
13:17 - visual studio
13:24 - so let's fire up visual studio 2022 and
13:27 - get started with the development of our
13:29 - sales management blazer application
13:32 - let's click the create new project
13:33 - option here
13:39 - so we can already see the project
13:40 - template we are going to use but visual
13:43 - studio does allow us to filter our
13:45 - project templates if we need to search
13:47 - for a specific project template
13:49 - so for our purposes we are going to
13:51 - select blazer server app
13:57 - let's name our project sales management
14:00 - app and make sure we are saving our
14:03 - project to an appropriate local
14:05 - directory
14:06 - let's click the next button
14:11 - here we have dot net 6 already selected
14:14 - as our version of dot net
14:17 - so we don't have to change the setting
14:19 - for the authentication type we could at
14:21 - this point choose for example individual
14:24 - accounts
14:25 - and at this stage in the development of
14:27 - our project integrate microsoft identity
14:30 - into our application
14:32 - for the purpose of the facilitation of
14:34 - login registration
14:36 - authentication and authorization
14:39 - functionality
14:40 - for now we are going to leave this
14:42 - setting at none and toward the end of
14:45 - the development of our application we'll
14:47 - integrate microsoft identity into our
14:50 - blazer server application
15:06 - we are going to start with the
15:07 - integration of the datagrid syncfusion
15:09 - component into our blazer server
15:12 - application
15:13 - we can use the sophisticated
15:15 - functionality within this component to
15:17 - perform crowd operations paging grouping
15:20 - sorting filtering searching exporting
15:22 - the data displayed in the data grid to
15:24 - an excel spreadsheet and much more
15:27 - so let's install the syncfusion data
15:29 - grid component
15:31 - we can do this by installing the
15:33 - appropriate new get package like this
15:37 - so let's right-click the dependencies
15:39 - node within our solution explorer window
15:43 - click manage new get packages
15:53 - we can then enter text that will help
15:55 - the search facility find the sync fusion
15:58 - grid nuget package that we can install
16:01 - for a blazer application
16:03 - this package contains the syncfusion
16:05 - data grid component
16:07 - and there it is the package that we want
16:09 - to install syncfusion.blazer.grid
16:13 - so at the time of the creation of this
16:16 - video for this section of the course
16:18 - the latest version of the
16:20 - syncfusion.blazer
16:22 - component is version 20.1.0.58
16:27 - so let's click the install button
16:39 - and we have successfully installed the
16:42 - syncfusion.blazer.grid new get package
16:44 - excellent
16:47 - if you'd like to read more about getting
16:49 - started with the syncfusion blazer data
16:51 - grid component
16:53 - please navigate to this url
16:55 - where syncfusion provides comprehensive
16:57 - information regarding getting started
17:00 - with the syncfusion blazer datagrid
17:02 - component
17:03 - i will of course also take you through
17:05 - the getting started process step by step
17:08 - in this course
17:10 - we also need to install the
17:12 - syncfusion.laser dot themes new get
17:14 - package so let's do this
17:29 - and the other new get package that we
17:31 - need to install
17:32 - is the syncfusion.blazer.core
17:34 - nuget package
17:45 - excellent
17:47 - so next let's open the program.cs file
17:50 - within our sales management app project
18:01 - and let's include the necessary
18:03 - registration code here for using blazer
18:05 - sync fusion components within our blazer
18:07 - application
18:12 - we have a red squiggly line under add
18:14 - sync fusion blazer
18:16 - to get rid of this let's bring in the
18:19 - syncfusion.blazer namespace
18:23 - great
18:28 - we can register our community sync
18:30 - fusion license using this line of code
18:33 - within the program.cs class like this
18:36 - you will need to of course replace the
18:38 - your license text here with your
18:40 - personal license key
18:43 - note that you will be able to follow
18:44 - along with this course without a license
18:47 - but in order to use the syncfusion
18:49 - products commercially you will need a
18:51 - valid license
18:57 - so next we need to open our
18:59 - underscorelayout.cshtml
19:02 - file
19:03 - that resides within the pages folder
19:08 - we need to add this line of code that
19:10 - references a bootstrap 5 css file
19:21 - and we also need to add this line of
19:23 - code that references a javascript file
19:37 - so we are ready to use the syncfusion
19:39 - blazer datagrid component within our
19:41 - blazer application
19:54 - as stated syncfusion provides
19:56 - comprehensive documentation for example
20:00 - the getting started section of the
20:01 - documentation pertaining to the
20:03 - syncfusion blazer data grid contains the
20:06 - instructions that we have just carried
20:08 - out
20:09 - for the integration of the syncfusion
20:11 - blazer datagrid component on.net 6.
20:15 - instructions regarding other versions of
20:17 - net are also available
20:19 - within the pages directory let's create
20:21 - a new razer component named
20:24 - employeemanagement.razer
20:39 - let's provide routing information at the
20:41 - top of our razer file using the add page
20:44 - directive
20:54 - within this shared directory let's open
20:56 - the nav menu razer component which
20:58 - houses the functionality for our
21:01 - applications main menu the nav menu
21:03 - razer component is provided to us by
21:05 - default through the blazer server app
21:08 - project template
21:11 - let's add a navigation link to our
21:13 - application's main menu
21:15 - that when clicked invokes our employee
21:18 - management razer component
21:53 - and of course now when we run our code
21:55 - interactively through visual studio we
21:58 - are able to invoke
21:59 - the employee management razer component
22:02 - by clicking the appropriate link that we
22:04 - have created within the nav menu razer
22:06 - component
22:13 - let's create a using directive at the
22:15 - top of our file
22:17 - that references the
22:19 - syncfusion.blazer.grids namespace
22:25 - we can now directly reference the types
22:28 - that reside within this namespace within
22:30 - our razor component without flagging a
22:32 - compile time error
22:35 - so let's include the data that we are
22:37 - going to wire up to our syncfusion
22:39 - datagrid component
22:41 - to quickly get started using the
22:42 - datagrid i've prepared a list of
22:45 - employee records that we can include
22:47 - within our razer component
22:49 - in a bit we'll create a sql database
22:52 - through ef core code first migrations
22:54 - and then we'll wire up the relevant data
22:57 - retrieved from the relevant database
22:59 - table to our syncfusion datagrid
23:01 - component
23:03 - let's first create a class named
23:05 - employee model that represents the shape
23:07 - of the data for an employee record
23:11 - to save time i've prepared this class
23:13 - off screen
23:15 - you can either type out the class or to
23:17 - save time you can simply navigate to
23:19 - this url where you can copy the employee
23:22 - model class from the relevant github web
23:24 - page and paste the class into your razer
23:27 - file
23:29 - a link to the relevant github web page
23:31 - is available in the description of this
23:33 - video
23:36 - so the employee model class consists of
23:38 - seven properties
23:40 - id as integer first name as string last
23:43 - name as string job title as string
23:46 - gender as string date of birth as date
23:48 - time and reports to empid as a nullable
23:52 - integer
23:53 - the question mark at the end of the int
23:55 - data type definition denotes that this
23:58 - integer property can store a null value
24:02 - let's declare a private variable to
24:04 - store a generic list that is strongly
24:06 - typed with our employee model
24:09 - user-defined type
24:25 - let's override the blazer built-in
24:27 - lifecycle event handler method named
24:30 - uninitialized this method is invoked
24:33 - when the component is ready to start
24:35 - having received its initial parameters
24:38 - from its parent in the render tree
24:41 - so off screen i've prepared the code for
24:44 - populating our list of employee model
24:46 - data
24:49 - you can copy the code that populates the
24:51 - relevant list of employee records from
24:54 - the relevant github web page
24:56 - as stated a link to this github web page
24:58 - is available below in the description of
25:00 - this video
25:02 - the data consists of made up employee
25:05 - records
25:51 - so now we are ready to create the code
25:53 - for displaying our data to the screen
25:55 - from within our razer component
25:58 - so let's create the bare minimum code we
26:01 - need to achieve this
26:03 - so let's include a syncfusion data grid
26:05 - component within our razor component by
26:07 - adding a sf grid element
26:10 - that represents our data grid here
26:14 - now all we need to do is wire up the
26:16 - data in our employee data list to the sf
26:20 - grid component
26:21 - to do this we can include a property
26:24 - within the sf grid element named
26:26 - datasource and set its value to the
26:29 - variable named employee data that has
26:32 - been assigned the list of employee model
26:34 - data
26:37 - let's run the code
26:48 - and look at that right out of the box
26:51 - our employee data is neatly displayed
26:53 - within our syncfusion datagrid component
26:55 - it is that simple we have achieved this
26:58 - through a tiny amount of code that is
27:01 - both easy to implement and easy to read
27:09 - and the datagrid component adapts its
27:11 - size based on the html element in which
27:14 - it is contained
27:51 - we can include or exclude the properties
27:53 - we want displayed on our data grid by
27:56 - including the grid columns element
27:57 - within the sf grid parent element and
28:00 - then including certain grid column
28:02 - elements within the grid columns element
28:05 - each grid column element represents a
28:07 - property
28:08 - within the class that represents an
28:10 - employee record i.e denoted by the
28:13 - employee model class
28:16 - we can use the field property within
28:18 - each grid column element to map employee
28:20 - model properties to their appropriate
28:23 - grid column element
28:41 - so the data grid will now only include
28:43 - those fields within the relevant data
28:45 - source that have an appropriate grid
28:47 - column element declared as a child
28:49 - element within the grid column's parent
28:52 - element
28:53 - so you can already get a feel for how
28:55 - easy it is to customize the sync fusion
28:58 - data grid
29:09 - we can set the width of each column by
29:11 - adjusting the width property of the
29:13 - relevant grid column element
30:03 - we can then customize the heading text
30:05 - for each column by appropriately
30:07 - including a header text property within
30:10 - the relevant grid column elements
30:35 - excellent
30:37 - we can customize our sync fusion
30:39 - datagrid component so that the data
30:41 - displayed is displayed over a number of
30:43 - pages
30:45 - to achieve this we simply set the sf
30:47 - grid elements allow paging property to
30:50 - true
30:56 - and include a reference to the grid page
30:58 - settings element within the sf grid
31:01 - element like this
31:04 - we can then assign a value representing
31:06 - the number of rows per page we want
31:08 - displayed within our data grid by
31:10 - assigning the relevant value to the page
31:13 - size property like this
31:15 - so we are telling the syncfusion data
31:18 - grid as it were
31:19 - that we want to display five rows of
31:22 - data per page on our data grid
31:32 - the sophisticated functionality is
31:34 - created with a few lines of declarative
31:36 - code that is innately easy to read
31:39 - to customize the maximum amount of rows
31:41 - we want displayed on each page it is as
31:44 - simple as appropriately assigning
31:47 - our custom page size value to the
31:49 - relevant page size property
32:00 - excellent
32:11 - if we had for example thousands of rows
32:13 - of data we would definitely need a way
32:16 - to search the relevant data we just need
32:18 - to tell the syncfusion data grid
32:20 - component as it were to include search
32:22 - functionality in order to achieve this
32:25 - we simply create a list which contains
32:27 - the string value of search
32:30 - so let's create a private variable named
32:32 - toolbar then assign the private variable
32:35 - a list of objects of course a string is
32:38 - an object so we can include a list item
32:41 - that is the string value search
32:59 - we can then let the datagrid component
33:01 - know as it were what functionality we
33:04 - wish to include on the datagrids toolbar
33:07 - to do this we can assign our list of
33:09 - objects stored in our toolbar variable
33:12 - to a property named toolbar within the
33:14 - sf grid element
33:32 - it's that simple we now have search
33:34 - functionality
33:43 - excellent
33:47 - if we want to allow the user the ability
33:49 - to group by any column all we need to do
33:52 - is set the allow grouping property
33:54 - within the sf grid element to true
34:13 - in order to group by a particular field
34:15 - the user can simply drag the column
34:17 - header that represents the column by
34:19 - which the user wishes to group the data
34:21 - grid to this panel that is now available
34:24 - on the data grid and our data is
34:26 - appropriately grouped by our chosen
34:28 - column and look at that we have grouped
34:30 - by the reports column
34:32 - and the data grid shows who each
34:34 - employee reports to in the
34:36 - organizational structure
34:38 - you can group by many columns so let's
34:40 - also group the data by gender
34:58 - great
35:08 - we are able to filter each column by
35:10 - appropriately setting the allow
35:12 - filtering property to true
35:15 - we could run the code and we would be
35:17 - able to filter each column by a text
35:19 - input field provided for each column
35:23 - we can include more sophisticated
35:24 - filtering functionality for each column
35:27 - by including a grid filter settings
35:30 - element within the sf grid element we
35:32 - can then include a type property within
35:34 - the grid filter settings element and set
35:37 - the type property to for example
35:39 - syncfusion.blazer.grids.filtertype.menu
35:43 - this provides a user the ability to
35:45 - filter each column using a variety of
35:48 - different types of criteria
35:51 - for example a user can filter a column
35:53 - by a value that the user specifies for
35:56 - field values that start with a
35:58 - user-specified string value
36:02 - a user can specify that the user wishes
36:04 - to filter the data based on field values
36:07 - that are equal to a value that the user
36:09 - specifies
36:23 - a user can filter the data based on
36:25 - values
36:26 - in the data that are greater in value
36:29 - than the user's specified value for
36:31 - example the user may wish to filter the
36:33 - data by employees born after 1990.
36:38 - with this functionality the user can
36:40 - filter the data in a variety of
36:42 - different ways where a combination of
36:44 - filters can be applied to multiple
36:46 - columns
36:48 - the user is able to clear filters from
36:50 - certain columns
36:51 - and try various combinations of
36:53 - user-specified filtering criteria
36:56 - very powerful indeed
36:59 - and look at how simple the code is for
37:01 - achieving such powerful results
37:04 - in order for the user to be able to sort
37:06 - by the columns in descending or
37:08 - ascending order all we need to do is set
37:10 - the allow sorting property within the sf
37:13 - grid element to true like this
37:35 - we are going to delve deeper into using
37:37 - the syncfusion data grid to facilitate
37:39 - crowd operations but at this point i'll
37:42 - demonstrate the very basics of how to
37:44 - customize the syncfusion data grid so
37:47 - that it provides the user with a
37:48 - facility whereby the user is able to
37:50 - perform crowd operations on the relevant
37:53 - data
37:54 - of course we haven't yet created a
37:56 - database in which we can store our data
37:59 - so we are not able to persist data to a
38:02 - database
38:03 - we can however at this point
38:05 - superficially demonstrate the relevant
38:07 - crud operations within memory data
38:10 - so to allow for the facilitation of
38:13 - crowd operations using our syncfusion
38:15 - data grid component let's include the
38:17 - grid edit settings element within the sf
38:20 - grid element like this
38:21 - to allow for add operations or in crud
38:24 - terminology create functionality
38:27 - we set a property within the grid edit
38:29 - settings element named allow adding to
38:32 - true
38:34 - then to include the appropriate toolbar
38:36 - buttons
38:38 - we can add the appropriate items to our
38:41 - toolbar like this
38:43 - so here we are telling the syncfusion
38:45 - datagrid component as it were
38:48 - that we wish to include the add update
38:51 - and cancel buttons within the datagrids
38:53 - toolbar
39:06 - and we can now add records to our data
39:09 - grid by clicking the add button
39:12 - the user is then able to enter the
39:13 - relevant data for the fields for the
39:15 - record
39:16 - that the user wishes to add to the data
39:18 - grid
39:37 - then the user can press the update
39:38 - button to save the data to the data grid
39:42 - and we can now see
39:44 - that a new row containing the data that
39:46 - we have just added
39:47 - is present within the data grid
39:52 - of course we are only dealing with
39:54 - in-memory data at this stage
39:56 - so if for example we navigate to another
39:58 - component and then back to our employee
40:01 - management component
40:03 - the data that we added to the data grid
40:05 - is no longer present within the data
40:07 - grid to achieve the functionality of
40:10 - persisting the added data to a database
40:13 - through the data grid we will need to
40:15 - further customize the data grid and of
40:18 - course implement code to save the data
40:20 - to a data storage facility like for
40:23 - example sql server
40:25 - and this is exactly what we are going to
40:26 - do in just a bit
40:29 - once we have pressed the add button the
40:31 - update button and the cancel button are
40:33 - enabled
40:35 - so we could press the cancel button to
40:37 - cancel the add operation
40:39 - or once we have entered valid data into
40:42 - the relevant fields we can press the
40:44 - update button to save the relevant data
40:46 - to the data grid
40:48 - we can allow the records denoted by the
40:51 - rows of employee data in our data grid
40:53 - to be edited by including the allow
40:56 - editing property within the grid edit
40:58 - settings element and setting the allow
41:01 - editing property to true
41:03 - let's also include an appropriate edit
41:05 - item within the toolbar list
41:18 - so a user can now select the row in the
41:21 - data grid that the user wishes to edit
41:23 - then press the edit button on the
41:25 - toolbar
41:26 - carry out the relevant edit operations
41:28 - and then press the update button to save
41:31 - the relevant changes to the data grid
41:39 - and the update functionality is
41:41 - currently not working
41:44 - in order for the edit operation to run
41:46 - correctly we need to ensure that one of
41:48 - the columns serves as a primary key
41:50 - value
41:52 - so let's add the is primary key property
41:56 - to the grid column element that is wired
41:58 - up to the id field
42:00 - and let's set the is primary key
42:02 - property to true
42:05 - this allows for each record to be
42:06 - uniquely identifiable within the data
42:09 - grid
42:18 - note that the user is also able to put a
42:20 - particular row within the data grid into
42:23 - edit mode by simply double clicking on
42:25 - the relevant row
42:53 - we can also as it were tell the sync
42:55 - fusion data grid to include delete
42:57 - functionality within the syncfusion data
43:00 - grid by including the allow deleting
43:02 - property within the grid edit settings
43:04 - element and setting the allow deleting
43:07 - property to true
43:09 - we can then include a delete button
43:11 - within the datagrids toolbar
43:14 - by including the delete item within the
43:16 - toolbar list like this
43:53 - right so let's build the sales
43:55 - management application
43:58 - let's take a brief look at a depiction
44:00 - of the relational database design for
44:03 - our applications database
44:06 - i've designed the structure of this
44:07 - database
44:09 - based on a process called normalization
44:12 - let's look at a brief explanation of
44:14 - what normalization is
44:16 - here is a brief description provided by
44:18 - wikipedia regarding the process of
44:21 - normalization
44:22 - database normalization is the process of
44:25 - structuring a relational database in
44:27 - accordance with a series of so-called
44:30 - normal forms in order to reduce data
44:32 - redundancy and improve data integrity
44:36 - a link has been included below in the
44:38 - description if you'd like to learn more
44:40 - about database normalization
44:43 - so if we look at a relational database
44:45 - design depiction for our sales
44:48 - management application
44:49 - you can see that our database will
44:51 - contain the following database tables
44:55 - our database will contain the employees
44:58 - table the employee job titles table
45:01 - a products table a product categories
45:04 - table an orders table and order items
45:07 - table
45:08 - a clients table a retail outlets table
45:12 - and lastly we have a table named sales
45:14 - order reports
45:18 - the sales order reports table will be
45:20 - the table that is used for storing
45:22 - analytical data
45:24 - the data stored in this table will be
45:27 - used for the charts that will be
45:28 - presented to the users of our
45:30 - application on their dashboards
45:33 - in terms of design this table can be
45:35 - seen as different from the other tables
45:37 - because this table has been deliberately
45:40 - denormalized
45:42 - i discuss why this table is denormalized
45:44 - and what it means for a database table
45:46 - to be denormalized when we write the
45:48 - syncfusion charts related functionality
45:52 - very basically denormalized database
45:54 - tables are often used to store
45:56 - analytical data
45:58 - and normalize database tables are used
46:01 - to store transactional data
46:03 - transactional database tables are
46:05 - generally written to more often than the
46:07 - tables used to store analytical data
46:11 - the denormalized tables are designed to
46:14 - increase the retrieval speed of the data
46:16 - stored within them
46:17 - this increased speed is made possible
46:20 - because of the elimination of the need
46:22 - to join tables together when retrieving
46:25 - the relevant data
46:27 - so a major part of the denormalization
46:29 - process is eliminating the need for
46:32 - joins
46:33 - so let's look at the normalized tables
46:36 - and their relationships
46:39 - the employees table has a many-to-one
46:41 - relationship with the employee job
46:44 - titles table many employees can have a
46:47 - particular job title for example many
46:49 - employees can have a job title of sales
46:52 - rep
46:53 - the products table has a many to one
46:56 - relationship with the product categories
46:58 - table
46:59 - many products can fall under a
47:01 - particular product category for example
47:03 - a tent falls under the camping product
47:06 - category and an air mattress
47:09 - also falls under the camping product
47:11 - category
47:13 - the orders table has a one-to-many
47:14 - relationship with the order items table
47:17 - and order consists of many order items
47:20 - the orders table has a many-to-one
47:22 - relationship with the employees table
47:25 - each order is created through a sales
47:28 - rep a particular sales rep can create
47:30 - many orders
47:32 - the orders table has a many to one
47:34 - relationship with the clients table many
47:37 - orders can be made by a particular
47:39 - client
47:40 - the clients table has a one-to-one
47:42 - relationship with the retail outlets
47:44 - table the retail outlets table contains
47:47 - details about the retail outlet itself
47:50 - for example information about the retail
47:53 - outlets location
47:54 - each retail outlet has a person who
47:57 - serves as a contact within the relevant
47:59 - retail outlet
48:01 - the clients table contains information
48:04 - like for example contact information
48:06 - about the person that serves as a sales
48:08 - reps contact
48:12 - a particular product can be associated
48:15 - with many orders
48:17 - so that was just a brief explanation of
48:20 - my thinking behind the design for the
48:22 - database that we are going to use for
48:25 - our sales management application
48:28 - as we get further into building our
48:29 - application more details regarding how
48:31 - the database design underpins the logic
48:34 - for our application will emerge
48:37 - so we are going to use ef core code
48:39 - first migrations to build our database
48:42 - at this stage we are focusing on
48:45 - integrating the syncfusion datagrid
48:47 - component for the purpose of
48:48 - facilitating cred operations
48:51 - so at this stage we only need to create
48:53 - the employees table and the employee job
48:56 - titles table
48:59 - so let's create a folder to house the
49:01 - entities that will represent our
49:03 - database tables let's name the new
49:06 - folder entities
49:11 - let's add a c-sharp class to this new
49:13 - folder named employee this employee
49:17 - class can be viewed as a template that
49:19 - represents a row in the employee's
49:21 - database table each property that is
49:24 - defined within the employee class and
49:26 - each property's data type will
49:28 - correspond to a column within the
49:30 - employees database table
49:33 - let's create an auto implemented
49:34 - property named id
49:36 - an easy way to create a property within
49:38 - visual studio is to type prop then hit
49:41 - the tab key twice and a default property
49:44 - definition is generated for us by visual
49:47 - studio we can then adjust the property
49:49 - definition for example the properties
49:51 - data type and the property's name
49:53 - according to our requirement
49:56 - for convenience you are able to navigate
49:58 - to the elements of the property
49:59 - definition using the tab key
50:02 - so we are able to for example change the
50:04 - property type and then use the tab key
50:07 - to move the cursor to the property name
50:09 - and we are then able to modify the
50:11 - property name
50:13 - so id as int
50:15 - first name as string
50:17 - last name as string
50:19 - email as string
50:28 - gender as string
50:31 - date of birth as date time
50:38 - and reports to empid as a nullable
50:41 - integer
50:43 - the question mark character following
50:45 - the ins data type definition means that
50:47 - this property can store a null value
50:52 - the employees table supports a parent
50:54 - child relationship
50:56 - the reports to empid field will contain
50:59 - either a null value or one of the values
51:02 - stored in the id field which is the
51:04 - primary key for the employees database
51:07 - table
51:09 - the relationship between the id field
51:11 - and the reports to empid denotes the
51:13 - following
51:14 - if for example an employee with an id of
51:18 - 2
51:19 - has a report to empid value of 1
51:22 - this means the employee with the id
51:24 - value of 2 reports directly to the
51:27 - employee with an id value of 1. this
51:30 - denotes that the employee with the id of
51:32 - 1 is the immediate boss of the employee
51:35 - with the id of two within the
51:37 - organizational structure
51:38 - an employee with a report to empid of
51:42 - null does not report to any other
51:44 - employee and is therefore at the top of
51:46 - the organizational structure in this
51:49 - case that employee is the sales manager
51:52 - bob jones
51:53 - team leaders reports directly to bob
51:55 - jones and sales reps report to a team
51:58 - leader
52:00 - so we are able to express the
52:02 - hierarchical structure of the
52:04 - organization for the employee data
52:06 - stored in our employees table by
52:08 - including a column that can store a null
52:11 - value and can also store a value that
52:13 - corresponds to the table's primary key
52:16 - which in this case is the id field if
52:18 - this concept is not clear to you don't
52:21 - worry this will become clearer to you
52:23 - when we integrate the syncfusion diagram
52:25 - into our application later on in this
52:27 - course in order to express our employee
52:30 - data in a hierarchical depiction i.e a
52:33 - structure that represents the
52:35 - organizational structure of our
52:37 - fictional sales department
52:39 - let's create a string property named
52:41 - image path its corresponding field in
52:43 - the database will store a path to a
52:46 - profile image of the relevant employee
52:50 - i've prepared a profile image for each
52:52 - employee
52:53 - i'll supply the relevant details of
52:55 - where you can download the profile
52:56 - images a little bit later when necessary
53:00 - we'll add data for each employee to the
53:03 - employees database table and employee
53:06 - job titles database table a little bit
53:08 - later
53:09 - lastly let's create an integer property
53:12 - named employee job title id
53:14 - this field will serve as the foreign key
53:17 - field
53:18 - from the employee job titles database
53:20 - table
53:21 - the employee job titles for our
53:23 - application are as follows the sales
53:26 - manager or sm for short the team leader
53:29 - or tl for short and the sales rep
53:33 - or sr for short
53:35 - so each employee will have one of these
53:38 - three job titles in our fictional sales
53:40 - department
53:42 - let's create a class that will
53:43 - correspond to the employee job titles
53:46 - database table
53:50 - let's name this class employee job title
54:03 - let's create the first field which must
54:05 - be named employee job title id
54:08 - this is the primary key field that joins
54:10 - this table with the foreign key field of
54:13 - the same name in the employees table
54:16 - let's create a string property named
54:18 - name
54:24 - and let's create a string property named
54:26 - description
54:42 - great
54:46 - right let's create our database using
54:47 - entity framework core code first
54:49 - migrations
54:52 - in order to do this through visual
54:54 - studio we need to install two nuget
54:56 - packages let's include the nuget package
54:59 - named microsoft dot entity framework
55:02 - core dot sql server
55:26 - great
55:27 - and let's install the new get package
55:29 - named microsoft dot entity framework
55:32 - core dot tools by installing the
55:35 - microsoft dot entity framework
55:36 - core.tools nuget package
55:39 - we'll be able to for example create our
55:41 - database migrations by running the
55:43 - relevant commands within the new get
55:45 - package manager console window from
55:47 - within visual studio we wouldn't need to
55:50 - install this package if we were to run
55:52 - the relevant migration commands through
55:54 - the.net sdk
55:56 - note that when using the.net sdk for
55:59 - running ef core migration commands the
56:02 - commands are different to when running
56:04 - the commands for the same purpose
56:06 - through visual studio
56:08 - for this course we are going to run the
56:10 - relevant migration commands directly
56:12 - through visual studio which means an
56:14 - installation of the microsoft dot entity
56:17 - framework core.tools new get package is
56:20 - necessary
56:21 - in order to build our database using ef
56:23 - core we must include a db context class
56:26 - within our application
56:28 - this dbcontext class is essential for
56:31 - when we need to retrieve or modify data
56:33 - in our database using code within our
56:36 - application
56:37 - so let's create a class to represent our
56:39 - db context within the data folder
56:46 - let's name our class sales management db
56:49 - context
57:00 - this class must inherit from the db
57:02 - context base class
57:10 - the red squiggly line under db context
57:13 - is visual studio indicating to us
57:15 - that we are missing a using directive
57:19 - an easy way to include the relevant
57:21 - namespace directive
57:23 - is to press ctrl period
57:25 - and then visual studio presents us with
57:28 - a context menu
57:29 - we can select the top menu item in this
57:32 - case and the relevant using directive is
57:34 - added to the top of our code
57:37 - so the db context type resides within
57:40 - the microsoft dot entity framework core
57:43 - namespace
57:44 - great
57:46 - let's create a constructor for our
57:47 - dbcontext class
57:50 - an easy way to generate a default
57:52 - definition for a constructor for a
57:54 - c-sharp class from within visual studio
57:57 - is to type in ctor
57:59 - and then press the tab key twice
58:02 - this constructor must accept an argument
58:05 - of the generic type db context options
58:09 - that is strongly typed with our sales
58:11 - management db context type
58:22 - we must pass this argument down to a
58:24 - constructor within the db context base
58:27 - class by using the base keyword like
58:29 - this
58:32 - and now all we need to do is tell ef
58:35 - core as it were about the classes that
58:38 - we wish to use as definitions for our
58:41 - database tables
58:43 - so to do this we include a property of
58:45 - the generic data type db set for each
58:48 - table that we wish to generate within
58:51 - our database
58:53 - we must strongly type each db set
58:55 - property with the appropriate user
58:58 - defined type that we have used to define
59:00 - the relevant database tables in our
59:03 - entities folder
59:05 - so the first property is defined with
59:07 - the generic db set type that has the
59:10 - employee user defined type passed to it
59:12 - as a type argument
59:15 - so the second property is defined with
59:17 - the generic db set type that has the
59:20 - employee job title user-defined type
59:23 - passed to it as a type argument
59:26 - each of these property names will be
59:28 - used as the database table names for the
59:31 - corresponding tables in the database
59:35 - so when we create a migration and update
59:37 - the database the database will be
59:39 - created and two database tables will be
59:42 - created within our database one named
59:44 - employees and the other named employee
59:47 - job titles the next step is to ensure
59:50 - that we have an appropriate connection
59:52 - string defined within the
59:54 - appsettings.json file
59:57 - so to do this let's create a connection
59:59 - string setting within our
60:01 - appsettings.json file
60:11 - and create a connection string named
60:13 - sales management db connection
60:23 - so we need to set the server property of
60:26 - our connection string to the server name
60:28 - on which our database will be created my
60:31 - server name is gavinlon's pc
60:39 - we must then set the database property
60:42 - of the connection string to the name of
60:43 - the database we wish to create
60:46 - sales management db seems like a
60:48 - sensible
60:54 - name then set the trusted underscore
60:57 - connection property to true this
60:59 - basically means that the windows account
61:02 - under which our application runs will be
61:04 - authenticated against the relevant sql
61:07 - server database
61:08 - great the next step is to register our
61:11 - sales management db context type for
61:14 - dependency injection
61:16 - we can do this by including the
61:17 - appropriate code within the program.cs
61:20 - file
61:21 - so let's open the program.cs file
61:25 - let's first write code to read the
61:27 - relevant connection string from our
61:29 - appsettings.json configuration file into
61:32 - memory
62:09 - let's then use the add db context method
62:12 - to register our db context class ie our
62:16 - sales management db context type
62:19 - for dependency injection
62:35 - here we are configuring our db context
62:37 - type to use a sql server database and
62:40 - the necessary details of the relevant
62:43 - sql server database have been defined
62:46 - within the relevant connection string
62:47 - that we are passing to the use sql
62:50 - server method here
62:55 - great
62:56 - so we are now ready to run the relevant
62:58 - ef core commands to generate our
63:01 - database
63:02 - to do this let's invoke the package
63:04 - manager console window like this
63:15 - to create a migration we can type the
63:18 - add dash migration command and then
63:20 - follow this command with the name of our
63:23 - migration class
63:25 - let's name this migration initial create
63:28 - let's press the enter key to run the
63:30 - command
63:42 - and our migration class has been
63:44 - generated for us
63:46 - you can see that the up method contains
63:49 - code that builds the database and the
63:52 - database tables that we have defined
63:54 - within the sales management db context
63:57 - class
63:58 - the down method contains code to undo
64:01 - the effects of the code that resides
64:03 - within the up method
64:06 - so we have created our migration
64:08 - but we have not yet run the code within
64:10 - the up method that will generate our sql
64:13 - server database
64:15 - with the database tables that we have
64:17 - defined within our sales management db
64:19 - context class ie through the properties
64:22 - defined as the db set generic type so in
64:26 - order to run our migration we must type
64:29 - in the update database command
64:43 - let's open sql server management studio
64:46 - to see if our database has been created
65:09 - excellent our sales management db
65:11 - database has been created successfully
65:14 - and we can see that the employees
65:16 - database table has been created and the
65:19 - employee job titles database table has
65:21 - also been created within the sales
65:24 - management db sql server database
65:27 - so i've prepared data for our employees
65:31 - and employee job titles tables off
65:33 - screen
65:34 - we are going to seed these database
65:36 - tables by using the code that i've
65:38 - prepared off screen
65:40 - to do this let's create a static class
65:43 - within the data folder named seed data
66:04 - let's create a static void method within
66:06 - our seed data static class named add
66:09 - employee data as stated i've prepared
66:12 - code that will add the relevant employee
66:15 - data and employee job title data to the
66:18 - relevant database tables
66:20 - and this code can be copied from a
66:23 - github web page at this url
66:39 - let's copy the code from the relevant
66:41 - github web page
66:49 - and paste the code within our add
66:52 - employee data method
67:20 - let's bring in the sales management app
67:23 - dot entities namespace
67:33 - let's include a parameter within the add
67:35 - employee data method named model builder
67:39 - which is of the type model builder we
67:41 - must also bring in the microsoft.entity
67:44 - framework namespace which is where the
67:46 - model builder type resides
68:06 - so in order to seed our employees table
68:08 - and employee job titles table
68:11 - with the data we have defined within the
68:14 - seeddata.addemployeedata method we must
68:16 - first override a method defined in the
68:18 - dbcontext base class
68:28 - an easy way to override a method within
68:30 - visual studio is to type override
68:33 - then hit the spacebar key a list of
68:36 - overrideable methods is presented to us
68:38 - by visual studio
68:40 - and on model creating is the list item
68:43 - we want so let's select on model
68:45 - creating
68:47 - then within the on model creating method
68:50 - let's call the seed data dash add
68:52 - employee data method
68:54 - and pass in the relevant model builder
68:57 - object to the add employee data method
69:00 - like this
69:05 - great
69:06 - so to seed our database tables with data
69:09 - we can now open the package manager
69:11 - console window
69:13 - we can clear the screen by typing the
69:15 - clear command and pressing enter
69:17 - and we can then type in the add dash
69:20 - migration command followed by a sensible
69:22 - name for our migration so let's name our
69:25 - migration seed employee data
69:42 - and you can see ef core has generated
69:45 - the code for seeding our database tables
70:19 - so to run the code against our database
70:21 - we can type in the update database
70:24 - command and press enter
70:41 - let's look at our data in sql server
70:43 - management studio
70:47 - excellent
70:58 - let's create functionality to retrieve
71:00 - data from within our employees database
71:03 - table
71:04 - and return the relevant data to eraser
71:06 - component
71:08 - we don't want to expose our entity
71:11 - classes directly
71:12 - to the razer components that are
71:15 - responsible for presenting the relevant
71:17 - data to the user
71:18 - so we are going to create appropriate
71:20 - model classes that will store the data
71:23 - that is directly handled from within the
71:26 - relevant razer components so by doing
71:28 - this we are creating a separation of
71:31 - concerns
71:32 - the entity classes interact directly
71:35 - with the database the ef core
71:37 - functionality the model classes
71:40 - are only concerned with the presentation
71:42 - layer
71:43 - and are handled by code within the
71:45 - relevant razer components
71:48 - so let's create a folder named models
72:03 - let's create a class named employee
72:06 - model
72:20 - let's copy the properties from the
72:22 - employee entity
72:34 - class and paste the properties into our
72:38 - employee model class
72:39 - so at this stage we could implement the
72:42 - repository pattern and wrap our database
72:44 - related functionality in specially
72:47 - created repository classes in the
72:49 - interests of simplicity for this code
72:52 - example we are going to abstract the
72:54 - database handling code in our service
72:56 - classes
72:57 - we are not going to implement the
72:59 - repository pattern in this course
73:01 - you can of course implement the
73:03 - repository pattern if you'd prefer i do
73:05 - encourage creating distinct separation
73:08 - of concerns and code
73:09 - but this course is focused on the
73:11 - integration of syncfusion components
73:13 - into a blazer application so in the
73:16 - interest of time i want to keep the
73:18 - back-end related code fairly simple
73:28 - let's create a new folder named services
73:43 - so let's create our first service class
73:45 - which will be responsible for handling
73:47 - employee data
73:59 - within the services folder let's create
74:01 - a folder named contracts
74:11 - let's create an interface within the
74:13 - contracts folder named i employee
74:16 - management service
74:32 - let's create a definition for an
74:34 - asynchronous method named get employees
74:37 - that will be responsible for returning a
74:39 - generic list
74:41 - that is strongly typed with our employee
74:43 - model user-defined type
74:54 - let's write code to implement the i
74:56 - employee management service interface
75:00 - so we need to bring in the sales
75:02 - management app dot services dot
75:04 - contracts namespace
75:11 - then with our mouse pointers positioned
75:13 - appropriately we can press control
75:15 - period again and generate code stubs for
75:18 - the methods that must be implemented
75:20 - like this
75:22 - so at this point we only need to
75:24 - implement code for one method the get
75:26 - employees method
75:28 - before we do this let's create a
75:30 - constructor for our employee service
75:32 - class
75:41 - let's add a parameter to the constructor
75:44 - of type sales management db context to
75:47 - indicate to.net as it were that we want
75:50 - an object of type sales management db
75:53 - context injected into this constructor
75:56 - at runtime so whenever an object is
75:58 - instantiated from our employee
76:00 - management service class
76:03 - an object of type sales management db
76:06 - context
76:07 - will be injected into the relevant
76:09 - employee management service object
76:15 - so let's position our mouse pointers
76:17 - appropriately press ctrl period and
76:20 - select create and assign field sales
76:23 - management db context from the menu that
76:26 - is presented to us within visual studio
76:29 - and this action results in visual studio
76:32 - generating an appropriate private member
76:34 - variable to store the object of type
76:36 - sales management's db context that will
76:39 - be injected into this constructor at
76:41 - runtime during the instantiation process
76:44 - of the employee service class
76:47 - we can now use the relevance dbcontext
76:49 - object to retrieve employee data from
76:52 - our database with this line of code
77:07 - so we have a red squiggly line
77:10 - so we must bring in the microsoft dot
77:12 - entity framework core namespace so that
77:15 - we can include the to list async
77:17 - extension method within our code here
77:20 - but we still have a red squiggly line
77:22 - this is because we want our method to
77:24 - return a list of employee model objects
77:27 - but we are currently attempting to
77:29 - return a collection of employee objects
77:32 - through our get employees method
77:34 - so to solve this we could write link
77:37 - transform code that converts our
77:40 - collection of employee objects to a
77:42 - collection of employee model objects
77:45 - within the get employees method
77:47 - and that would be fine
77:49 - but in the interests of cleaner code
77:52 - let's create a convert extension method
77:54 - for this purpose
77:55 - this means that we will be able to call
77:58 - a method named convert
78:00 - on the code that returns a collection of
78:02 - employee entities and the code we are
78:04 - about to implement for the convert
78:06 - extension method will perform the
78:08 - appropriate conversion functionality
78:11 - so let's first create a folder named
78:13 - extensions
78:30 - within the extensions folder let's
78:33 - create a static class named conversions
78:53 - within the conversions static class
78:55 - let's create a static async method named
78:58 - convert that returns a list of employee
79:02 - model objects
79:04 - in order to make this method an
79:05 - extension method that can be called on
79:07 - an object of type i queryable that is
79:10 - strongly typed as employee we need to
79:13 - include a parameter that is of type i
79:16 - queryable that is strongly typed with
79:18 - the employee type and this parameter
79:20 - must be preceded by this keyword
79:25 - an extension method must contain at
79:27 - least one parameter and the first
79:29 - parameter in an extension method must be
79:33 - of the type on which the extension
79:35 - method is called the first parameter
79:38 - must also be preceded by the this
79:41 - keyword
79:42 - if this isn't clear to you at this point
79:44 - this will become clearer when we call
79:47 - the extension method on the i queryable
79:49 - object returned by our efcor code in the
79:53 - get employees method
79:55 - so let's implement the code for our
79:57 - convert extension method
80:01 - so we can now use the employee's object
80:03 - passed as an argument to the convert
80:06 - method
80:07 - and through a link query we can perform
80:09 - the appropriate transform operation ie
80:12 - where we convert the i queryable object
80:15 - that is strongly typed with the employee
80:18 - type i.e this is a collection of
80:20 - employee objects returned from the
80:22 - database
80:23 - into a list that is strongly typed with
80:26 - the employee model type
80:28 - this is the list
80:30 - that we want to return to the relevant
80:32 - razor component that we'll create in a
80:34 - bit
81:20 - and now that our extension method is
81:22 - created we can perform the necessary
81:25 - conversion operation within our get
81:27 - employees method cleanly
81:29 - like this
81:32 - and of course we have a red squiggly
81:33 - line because we need to bring in the
81:36 - sales management app dot extensions
81:40 - namespace and that's it
81:43 - our get employees method is ready for
81:45 - use excellent
81:56 - so now we want to write codes to wire up
81:58 - our syncfusion datagrid component to the
82:01 - employee data returned from our database
82:05 - so let's open the
82:07 - employeemanagement.razer file
82:27 - let's remove the code related to the
82:28 - static data that is currently wired up
82:31 - to our sync fusion datagrid component
82:39 - we now have a red squiggly line under
82:41 - the employee model type
82:44 - because that was a reference to the
82:47 - employee model class
82:49 - that has now been removed from our razor
82:51 - file
82:53 - so let's bring in our newly defined
82:55 - employee model type
82:57 - by pressing control period and selecting
83:00 - the appropriate menu item represented to
83:03 - us by visual studio
83:09 - great
83:10 - and we need to change the field property
83:13 - value within our syncfusion data grid
83:15 - code here
83:17 - because the name in the newly defined
83:19 - employee model for the job title field
83:22 - is not job title
83:24 - but is employee job title id
83:28 - and for now let's remove code from our
83:30 - data grid relating to crud operations
83:34 - data filtering
83:36 - sorting
83:37 - grouping and paging
83:41 - and for now we also don't need our data
83:44 - grid to have a toolbar
84:09 - let's write code to override blazers
84:12 - built-in
84:13 - uninitialized async lifecycle event
84:16 - handler method
84:18 - within our uninitialized async method
84:21 - let's include code that gets the
84:23 - employee data from our database using
84:26 - our employee management service class
84:28 - and we must first write code so that an
84:31 - object of type employee management
84:33 - service is injected into our razor
84:36 - component at runtime
84:48 - great
84:50 - so let's write code to call the get
84:52 - employees method on our employee
84:55 - management service object and assign the
84:57 - returned list of employee model objects
85:00 - to our variable that we have named
85:03 - employee data
85:06 - the employee data variable is the data
85:09 - source for our data grid syncfusion
85:11 - component
85:15 - let's run the code
85:30 - and we have an error
85:32 - okay and i know exactly what has caused
85:35 - that exception
85:37 - it is because we haven't registered the
85:39 - employee management service type for
85:42 - dependency injection
85:44 - so let's open the program.cs class and
85:47 - write the code to register the employee
85:50 - management service type for dependency
85:52 - ejection
85:54 - so to do this
85:55 - we can simply include this line of code
85:57 - within the program.cs class
86:29 - let's run the code again
86:43 - and now the data stored within the
86:45 - employees table within our newly created
86:48 - sql server database
86:50 - is being neatly displayed within our
86:52 - syncfusion data grid component
86:56 - excellent
86:58 - let's explore the datagrid component
87:00 - further
87:02 - so we don't want the integer value
87:04 - displayed for the employee job title id
87:07 - field like it is being displayed at the
87:09 - moment within our data grid
87:15 - the employee job title id value
87:18 - is great for the unique identification
87:20 - of job titles
87:22 - but is not ideal for presentation
87:24 - purposes
87:25 - we want the name of the job title to be
87:27 - displayed here
87:29 - because it is more human readable than
87:31 - the employee job title id value
87:34 - we also want an administrator to be able
87:37 - to change the job title for an employee
87:40 - if necessary
87:41 - so we want this field to be able to
87:43 - display a drop down list containing all
87:46 - job titles as list items
87:49 - when an administrator puts a row
87:51 - displayed within the data grid in edit
87:53 - mode
87:55 - so
87:56 - when in read mode
87:58 - we want the name of the job title
88:00 - displayed to the user but when an
88:02 - administrator needs to change the job
88:04 - title for a particular employee
88:07 - we need the administrator
88:09 - to have access to a drop-down list
88:11 - containing all employee job title names
88:15 - the job titles that exist in the system
88:17 - at the moment are sales manager
88:20 - team leader and sales rep
88:23 - in the name field in the employee job
88:26 - titles table
88:27 - we are storing an abbreviation of these
88:30 - job titles
88:32 - sm for sales manager
88:34 - tl for team leader and sr for sales rep
88:38 - so for example if a sales rep is
88:40 - promoted to a team leader
88:43 - we want an administrator to be able to
88:45 - change the employee's job title
88:48 - from sr to tl
88:50 - from within a drop down list
88:52 - in the appropriate row in our data grid
88:55 - so to achieve this let's first go to our
88:58 - i employee management service interface
89:11 - let's create a definition for a method
89:13 - that returns a list of employee job
89:15 - title objects
89:17 - in the interests of time
89:19 - i'm going to use the employee job title
89:21 - class for the model and not create a
89:23 - model dedicated for presentation
89:25 - purposes like we did with the employee
89:28 - model class
89:37 - so let's go to the employee management
89:39 - service class and implement the code for
89:41 - our get job titles method
90:12 - great let's go to our employee
90:14 - management.razer file
90:17 - let's create a variable to store a list
90:19 - of employee job title objects
90:40 - let's write code to call our get job
90:43 - titles method on the employee management
90:46 - service object from within our override
90:48 - method
90:49 - of the uninitialized async blazer
90:52 - lifecycle method handler and we are
90:55 - assigning the returned value to our
90:58 - employee job title data
91:00 - variable so the employee job titles
91:04 - table has a one-to-many relationship
91:06 - with the employees table and we are able
91:09 - to as it were let the sync fusion data
91:12 - grid component know about the
91:14 - relationship through appropriate
91:16 - declarative code that we are about to
91:18 - create
91:19 - the employee job title id field within
91:22 - the employees table is a foreign key
91:25 - from the employee job titles table
91:28 - the employee job titles table has a
91:31 - field that serves as its primary key
91:33 - named employee job title id
91:37 - we can as it were let the syncfusion
91:39 - data grid component know about this
91:41 - relationship between the employee job
91:43 - title id primary key field in the
91:46 - employee job title data data source and
91:49 - the employee data data source
91:52 - through appropriate declarative code
91:54 - that we are about to write so to
91:56 - establish the relationship between the
91:59 - employee data data source
92:01 - that we have already wired up to our
92:03 - data grid and the employee job title
92:07 - data data source that we are going to
92:09 - wire up to the relevant drop down list
92:12 - we are going to appropriately include a
92:14 - component within the data grid named
92:17 - grid foreign column
92:19 - instead of using the grid column
92:21 - component that we are currently using to
92:24 - represent our columns so this will mean
92:27 - that when a user selects a new value
92:29 - from within the employee job titles drop
92:32 - down list
92:33 - that the employee job title id foreign
92:36 - key value will automatically be changed
92:39 - appropriately in the employee data data
92:42 - source
92:43 - so when the user changes an item within
92:45 - the employee job titles drop down list
92:48 - the employee job title id value mapped
92:52 - to the selected drop drop-down list
92:54 - will become the value reflected in the
92:56 - employee data data source which is the
92:59 - data source wired up to our data grid
93:02 - through the declarative code that we are
93:03 - implementing for our data grid we are
93:06 - telling the syncfusion data grid as it
93:08 - were
93:08 - about the one-to-many relationship
93:11 - between the employee job titles data
93:13 - source wired up to the relevant
93:15 - drop-down list and the employees data
93:18 - source wired up to the sf grid component
93:22 - so let's create the code for this
93:24 - let's delete the grid column component
93:26 - that is currently implemented to
93:28 - represent the employee job title id
93:31 - field
93:33 - let's include a component named grid
93:35 - foreign column to represent the employee
93:38 - job title id field
93:41 - as well as include the relevant
93:43 - drop-down list that will contain the
93:45 - employee job titles
93:47 - let's set the header text property value
93:50 - to designation
93:52 - let's set the t value property to
93:55 - employee job title
93:57 - we are doing this because we want the
93:59 - relevant drop down list to contain items
94:02 - of type employee job title
94:05 - we want the value of each item in the
94:08 - drop-down list to have its primary key
94:10 - value employee job title id
94:13 - mapped to the foreign key value also
94:16 - named employee job title id which is a
94:18 - foreign key field included in the
94:20 - employee model class
94:22 - we must set the foreign data source
94:25 - property to the data stored within the
94:27 - employee job title data variable
94:30 - this variable stores a list of employee
94:32 - job title objects
94:34 - we can then set the foreign key value
94:37 - property to the property that we want
94:39 - displayed to the user within the drop
94:41 - down list which is the name property
94:44 - let's make the fields width 100 pixels
94:48 - so when a row is in edit mode
94:50 - we want our drop down list to appear to
94:52 - the user
94:54 - to let the sync fusion grid component as
94:57 - it were know about this we must
94:59 - appropriately include the edit template
95:02 - component in our code like this
95:05 - within the edit template element we must
95:07 - include the sf drop-down list component
95:16 - let's bring in the appropriate namespace
95:18 - for the sf drop-down list type which
95:21 - resides in the
95:22 - syncfusion.blazer.dropdowns
95:25 - namespace
95:27 - let's use the at bind dash value
95:30 - attribute to bind the appropriate
95:32 - employee model object's
95:34 - employee job title id value to the value
95:37 - selected within the relevant drop-down
95:39 - list
95:40 - each row in the data grid corresponds to
95:43 - a list item of type employee model
95:46 - stored within the employee data data
95:48 - source for the data grid
95:50 - we are able to access each rows list
95:53 - item object
95:55 - through an object named context
95:57 - provided to us by the sync fusion data
96:00 - grid
96:02 - we can type cost the context object into
96:04 - its underlying type in this case the
96:07 - employee model type using the c sharp as
96:10 - keyword like this
96:12 - and then we can access the property that
96:15 - we wish to bind to
96:31 - let's set the id property of the sf
96:34 - drop-down list component to employee job
96:37 - title id
96:47 - let's set the data source property to
96:49 - the variable that stores the relevant
96:51 - list of type employee job title
96:54 - let's set the t item property to the
96:57 - employee job title type
96:59 - the relevant data source for our drop
97:01 - down list contains a list of items of
97:04 - type employee job title
97:07 - the value that will be bound to the
97:08 - employee data data sources employee job
97:11 - title id property must be of type int so
97:15 - let's set the t value property to end
97:25 - and then within the sf drop down list
97:27 - element
97:28 - let's include a component named drop
97:31 - down list field settings
97:33 - let's set its text property to name and
97:36 - its value property to employee job title
97:39 - id
97:41 - so the name property of the selected
97:43 - item
97:44 - will be displayed to the user in the
97:46 - drop drop-down list and the value of the
97:48 - selected item in the drop-down list
97:51 - will be the selected objects which is of
97:54 - type employee job title
97:56 - employee job title id value
97:59 - let's run the code
98:08 - great so the name of the employee job
98:10 - title is now appropriately displayed
98:13 - within the relevant column
98:15 - so we need to indicate that we want to
98:17 - allow for a user to be able to edit rows
98:20 - within the data grid so to do this we
98:23 - simply include the grid edit settings
98:26 - component within the sf grid element and
98:29 - include a property
98:30 - within the grid edit settings element
98:32 - named allow editing and set its value to
98:35 - true
98:37 - let's run the code
98:49 - and now when we double click a row
98:51 - within our data grid which puts the
98:54 - relevant row into edit mode we are able
98:56 - to change the value for an employee's
98:59 - job title through the use of an
99:01 - appropriate drop down list excellent
99:04 - you'll see later when we perform certain
99:07 - cred operations on the data that the
99:09 - drop down list values are automatically
99:12 - mapped to the employee data data source
99:15 - through the relationship between the
99:17 - employee job titles employee job title
99:20 - id field
99:21 - the employee job titles database tables
99:24 - primary key and the employees employee
99:27 - job title id foreign key field
99:32 - so let's also create a drop down list
99:34 - for the gender field
99:36 - we can implement the code for this using
99:38 - an enum
99:40 - so for this field we don't need to bind
99:43 - a primary key value from one data source
99:46 - to a foreign key value of another data
99:49 - source as we have done for the employee
99:51 - job title id field let's create an enum
99:54 - named gender val and include the
99:57 - appropriate enum list items
100:02 - let's modify the grid column component
100:04 - for the gender field so that a drop down
100:07 - list containing the gender items can be
100:10 - accessed from within the data grid when
100:12 - a row is in edit mode
100:15 - so let's first include the edit template
100:18 - element within the relevant grid column
100:20 - element so before we set the data source
100:23 - property for the relevant sf drop-down
100:26 - list element
100:27 - let's write code that converts the
100:29 - gender enum list items to an array of
100:32 - string values
100:34 - we can use the enum types get names
100:37 - method for this purpose like this
100:48 - then we can set the data source for the
100:50 - relevant sf drop-down list component to
100:53 - the variable that stores the appropriate
100:56 - string array values
100:59 - we can then tell the sync fusion data
101:01 - grid as it were about the type
101:04 - of collection that we want contained
101:07 - within the relevant drop-down list
101:09 - so in this case each item contained
101:12 - within the drop-down list is of type
101:14 - string
101:15 - so we set the t item property to string
101:18 - and the value for each item will also be
101:21 - a string
101:22 - so we can set the t value property to
101:25 - string as well
101:27 - lastly we must set the at bind value
101:31 - attribute
101:32 - to the correct property within the
101:34 - employee model type which is of course
101:37 - the gender property
101:39 - we can access the relevant employee
101:41 - model object pertaining to the relevant
101:44 - edited row
101:45 - through the context object
101:47 - that is made accessible to us by the
101:50 - sync fusion datagrid component
101:54 - let's run the code
102:14 - great
102:16 - we also want to include a drop down list
102:18 - for the report to emp id field
102:22 - in the relevant drop-down list for this
102:24 - field we want to present a list of
102:27 - employees
102:28 - that are either a team leader
102:30 - or the sales manager
102:33 - so in effect we are excluding sales reps
102:36 - from this list because no one in the
102:38 - organization reports to the sales reps
102:42 - firstly let's create a special model
102:45 - within the models folder that represents
102:47 - an employee that can be reported to as
102:50 - it were
102:52 - let's name the c-sharp class
102:53 - report2model
103:01 - so the first property is named report to
103:04 - amp id and is a nullable integer
103:08 - the reason this field is nullable is
103:10 - because an employee might not
103:12 - necessarily report to another employee
103:15 - like for example bob jones who is the
103:18 - sales manager
103:20 - and is the head of the sales department
103:22 - therefore doesn't report to anyone in
103:24 - the sales department
103:26 - then let's include a string property
103:28 - named report to name
103:31 - let's create a method definition for a
103:34 - method named get report to employee
103:37 - within the i
103:39 - employee management service interface
103:41 - for an asynchronous method that will be
103:44 - responsible for retrieving a list of
103:46 - objects of type report to model
104:00 - let's implement the code for the get
104:02 - reports to employee method within our
104:04 - employee management service class
104:23 - so let's create a link query
104:25 - that returns a list of employee objects
104:28 - so to do this we can join the employee
104:31 - entities employee job title id foreign
104:33 - key field to the employee job title
104:36 - entities employee job title id primary
104:39 - key field
104:40 - so that we can explicitly filter the
104:43 - data based on the names of the relevant
104:45 - job titles in this case the names of the
104:48 - job titles are sm
104:51 - and tl
104:54 - yes we could just use the report to id
104:57 - key for this purpose
104:59 - but i want it to be explicit regarding
105:01 - the employees that need to be included
105:04 - in the returned list based on their job
105:06 - title
105:08 - then we can assign the relevant returned
105:11 - values to the appropriate properties of
105:13 - the report to model type
105:16 - so i'm assigning the report to name
105:19 - property the employee's first name
105:22 - followed by the first character of the
105:24 - employee's last name just for clarity
105:50 - then the way we wire up the code so that
105:53 - the drop down list appropriately appears
105:56 - for our reports to empid field
105:59 - is very similar to the way in which we
106:01 - implemented the code for the employee
106:04 - job title id field
106:06 - so let's first write the code to
106:08 - retrieve the relevant data
106:24 - now let's comment out the code for the
106:26 - current grid column element
106:28 - that is currently representing the
106:31 - report to empid field
106:34 - let's make a copy of the grid foreign
106:36 - column element
106:37 - that we created
106:39 - for the employee job title id field
106:47 - and paste it appropriately above the
106:49 - code that we have just commented out
106:53 - then let's change the settings
106:54 - appropriately for our new grid foreign
106:57 - column element
107:53 - let's run the code
108:06 - and we have an exception thrown and why
108:08 - is that
108:09 - it's because our scenario here is
108:12 - slightly different to the implementation
108:14 - for the employee job title id field with
108:18 - the employee job title id field the
108:21 - value can never be null
108:23 - so the t value property here must be set
108:26 - to end
108:28 - for the report to empi d field the value
108:31 - can be null which means we need to let
108:34 - the syncfusion data grid know as it were
108:37 - that this field can be null
108:40 - so we need to set the appropriate t
108:42 - value property here
108:44 - to nullable end like this
108:48 - remember employees don't necessarily
108:50 - report to anyone
108:52 - as is the case with bob jones who
108:54 - reports to no one he is the sales
108:56 - manager the head of the department
108:59 - so we must make this field nullable
109:02 - so this field can either be set to null
109:05 - or an integer value
109:07 - so that is why we are setting the t
109:09 - value property here to c sharp's
109:12 - nullable end data type
109:14 - let's run the code
109:33 - and that's great but how does an
109:35 - administrator set the drop down list to
109:37 - a null value
109:39 - so to achieve this
109:41 - we want to make a slight modification
109:44 - for this special case
109:47 - so let's go to the get report to
109:49 - employees method within the employee
109:52 - management service class
109:54 - and add a list item
109:56 - that represents a null value to the list
109:59 - of report 2 model items returned from
110:01 - this method
110:20 - let's ensure that the null item appears
110:23 - as the first option in our drop down
110:24 - list
110:25 - so let's order the list by the report to
110:28 - empid property
110:46 - let's run the code
110:55 - excellent
110:56 - so the null value is represented by the
110:59 - text none which is wrapped in angle
111:02 - brackets great
111:20 - the syncfusion data grid is highly
111:23 - customizable
111:24 - for example we can include an image for
111:27 - each employee record that can be
111:29 - displayed within the data grid
111:32 - we can also style the image
111:34 - appropriately using css so i've prepared
111:37 - some image files for this part of the
111:39 - course
111:40 - the image path field in the employees
111:42 - table of our database has been seeded
111:45 - with the appropriate image path for each
111:48 - employee add points to the appropriate
111:50 - image which must reside
111:53 - within the www root slash images slash
111:56 - profile folder
111:58 - so let's create the images folder within
112:01 - our www root folder
112:15 - and then let's create the profile folder
112:18 - within the images folder
112:27 - please download the images from this
112:29 - location on github
112:52 - and then copy the images into the www
112:56 - root slash images
112:58 - slash profile
113:00 - folder
113:02 - great
113:03 - so to include the employees profile
113:05 - image within the data grid let's add a
113:09 - grid column element
113:17 - let's set the header text for our column
113:20 - to profile
113:24 - and let's set the width of our column to
113:27 - 120 pixels
113:29 - we can include an image within this grid
113:31 - column using the template element like
113:34 - this
113:37 - we are now able to appropriately include
113:40 - html code within the template element
113:43 - that will in effect display
113:46 - the appropriate image within the
113:48 - relevant data grid column note how we
113:50 - are able to use razor code here
113:53 - to access
113:54 - the employee model object for each row
113:57 - in the data grid
113:58 - we are able to access the context object
114:01 - for this purpose
114:11 - we can then include the image path field
114:14 - for the relevant employee model object
114:17 - as the value
114:19 - for the src attribute of the image html
114:23 - element
114:24 - that we are including within the
114:26 - template element
114:40 - and that's great the image is displayed
114:43 - within the data grid but it could look a
114:45 - lot better
114:47 - we are able to customize the images
114:49 - displayed within the relevant grid
114:51 - column of our data grid using css
114:55 - so you can see that i've included a css
114:58 - class within the div element
115:00 - that wraps the image element that is
115:02 - used for displaying the relevant
115:04 - employee profile image here
115:09 - we are able to style the image
115:10 - appropriately with basic css code
115:15 - so to do this
115:16 - let's create a style tag here
115:19 - and let's add the dot profile dash image
115:23 - dash container class here
115:29 - let's set the width of the image
115:31 - container div element to 80 pixels
115:37 - and let's also set its height to 80
115:40 - pixels
115:50 - let's target the image element that is
115:53 - responsible for displaying the profile
115:55 - image
115:56 - and set its width and height properties
115:59 - so that the image fills its container
116:01 - 100 percent
116:03 - let's say that we want our image to be
116:05 - displayed within a circle
116:09 - we can achieve this by setting the image
116:12 - elements border radius property
116:14 - to 50 pixels
116:18 - let's run the
116:26 - code excellent
116:31 - and when we put a row in edit mode our
116:34 - image does not display which is what we
116:37 - want great this is because we haven't
116:40 - wired up the relevant grid column
116:42 - responsible for displaying the employee
116:45 - profile image
116:46 - using the field property to a property
116:49 - within the employee model type
116:56 - we are only displaying a small amount of
116:58 - data within our data grid
117:00 - but if we were displaying thousands of
117:02 - records
117:04 - it is a good idea to display a spinner
117:06 - to the user while the records are
117:08 - loading
117:09 - this provides a better user experience
117:12 - ux to the users of our application
117:16 - to achieve this we can appropriately add
117:19 - the sf spinner component to our data
117:21 - grid like this
117:38 - we can set the spinner components at
117:40 - bind dash visible attribute to a boolean
117:44 - property
117:45 - that we will create in a bit
117:47 - then we can control through this
117:49 - property
117:50 - that we have named visible prop
117:53 - when the spinner is displayed to the
117:55 - user and when the spinner disappears
117:59 - let's set the visible prop property to
118:02 - true
118:03 - before code runs to retrieve relevant
118:05 - data
118:14 - and then to false once the execution of
118:17 - the relevant code has completed
118:21 - our code here is only retrieving a small
118:23 - amount of data so let's introduce an
118:26 - appropriate amount of latency to
118:28 - simulate the delay for the retrieval of
118:31 - a much larger amount of data
118:35 - so let's create a delay of two thousand
118:38 - milliseconds or two seconds
118:52 - great
118:55 - we are just using the default spinner
118:57 - style here but please check out the sync
119:00 - fusion documentation regarding the sf
119:02 - spinner component
119:04 - and you can see how you are able to
119:06 - customize the style of the spinner in
119:08 - many ways to suit your requirement
119:27 - so we can now remove the artificial
119:29 - latency that we have introduced within
119:32 - the uninitialized async method
119:42 - so earlier on in this course we looked
119:45 - at the performance of crud create read
119:47 - update delete operations facilitated by
119:50 - the sync fusion data grid component
119:54 - we can include such functionality by
119:56 - simply adding a toolbar to the data grid
119:59 - like this
120:32 - we must also ensure that we have
120:34 - included the grid edit settings element
120:36 - within the sf grid element
120:49 - then we can set the allow adding
120:50 - property to true so that a user can add
120:53 - employee records to the system through
120:56 - the use of the data grid
120:58 - the allow editing property has already
121:00 - been appropriately included and is
121:03 - already set to true which will enable a
121:05 - user to edit employee records through
121:08 - the use of the data grid
121:11 - we must also appropriately include the
121:13 - allow deleting property and set its
121:16 - value to true so that a user can delete
121:19 - employee records from the system through
121:21 - the data grid
121:24 - so a user can now perform crowd
121:26 - operations through the use of our data
121:28 - grid
121:29 - but as we demonstrated earlier on in
121:31 - this course
121:33 - when we were only dealing with in-memory
121:35 - data we were able to perform the
121:37 - relevant crat operations and the changes
121:40 - made through our crud operations were
121:42 - reflected in the data grid which is
121:44 - excellent
121:45 - but in order to sustain the changes that
121:48 - a user makes through the relevant crud
121:50 - operations
121:51 - done through the use of the data grid we
121:54 - need to customize our data grid a bit
121:56 - further
121:57 - so for example when a user adds a new
122:00 - employee record to the data grid we want
122:02 - the new employee record to be inserted
122:05 - into the employees database table
122:08 - so we have now created our database so
122:11 - we are now working with persistent data
122:13 - which means we can create functionality
122:16 - for our application so that when a user
122:18 - performs crowd operations through the
122:20 - use of the data grid the effects of the
122:22 - crad operations are both reflected in
122:25 - the data grid as well as appropriately
122:27 - persisted to our database
122:30 - sync fusion makes it easy for us
122:33 - to hook into events that are triggered
122:36 - by user actions performed on the data
122:38 - grid and therefore we are able to
122:40 - include our own custom code
122:42 - appropriately within relevant event
122:44 - handlers so that changes made by the
122:47 - user through the use of the data grid
122:49 - are appropriately saved to our database
122:52 - so for example if a user clicks the add
122:55 - button on the data grids toolbar then
122:58 - fills in values for the relevant fields
123:00 - and then clicks the update button on the
123:02 - toolbar which means the user is saving
123:05 - the relevant data to the data grid
123:07 - our custom code can run at this point
123:10 - and save the relevant data to a database
123:13 - table
123:14 - so
123:15 - how do we hook into the relevant data
123:17 - grid events
123:18 - firstly let's create the custom code
123:21 - necessary for adding a new record to our
123:23 - database
123:25 - so let's go to the i employee management
123:27 - service interface and add a definition
123:30 - for a method that will be responsible
123:32 - for adding a record to the employees
123:34 - database table
123:50 - let's implement the logic for this
123:52 - method within our employee management
123:54 - service class
124:15 - so before we do that let's create a
124:17 - convert extension method so that the
124:20 - employee model object passed into our
124:22 - add method can easily be converted into
124:26 - the employee type that can then be added
124:29 - to our employees database table using
124:32 - appropriate ef call functionality
125:26 - notice here for the image path field
125:28 - i'm setting the image for a newly added
125:31 - employee to a default image which is
125:33 - based on the employee's gender
126:29 - then we can simply call the convert
126:31 - method on the employee model object
126:34 - passed into our add method we can then
126:37 - use entity framework core functionality
126:40 - to save the newly created record to our
126:42 - employees database table
127:05 - excellent
127:06 - so now how can we run our code that we
127:09 - have just created to add a new employee
127:13 - to the employees database table based on
127:15 - a user's action performed to add a new
127:18 - employee record to the data grid
127:23 - to achieve this
127:24 - we are able to include a component named
127:27 - grid events
127:29 - within the sf grid element
127:32 - then within the grid events element
127:35 - we can set the on
127:37 - action begin property to an event
127:40 - handler method
127:41 - that we'll create in a bit
127:43 - where we can implement code to call the
127:46 - add functionality that we have just
127:49 - created within the employee management
127:51 - service class
127:54 - so let's create the method that will run
127:58 - when a user performs an action on our
128:00 - data grid
128:29 - note that we are able to use
128:30 - intellisense like this
128:32 - where we can see the method signature or
128:35 - method definition if you like
128:38 - that we need to implement for our action
128:41 - begin handler method ie the method that
128:43 - we have assigned
128:45 - to the onactionbegin property
128:50 - we are able to use the args argument
128:53 - passed to our event handler method when
128:56 - a relevant action is performed by the
128:59 - user on the data grid to assess the
129:01 - exact nature
129:03 - of the user's action
129:05 - so we want to capture the event as it
129:08 - were
129:08 - when a user clicks the update button on
129:11 - the toolbar in order to save new data to
129:14 - the data grid
129:16 - so we can do this by checking the data
129:18 - available in the args argument like this
129:22 - we can check the request type value on
129:25 - the args object
129:27 - we also want to further evaluate the
129:30 - args data to check if the save action
129:33 - occurred after the user performed an ad
129:36 - operation
129:38 - we can do this with this line of code
129:40 - where we are checking if the args
129:42 - argument action value is equal to add
129:46 - so if these two conditions are met our
129:49 - code knows as it were that the user is
129:51 - performing a create operation the user
129:54 - is adding data to the data grid
129:57 - so we can include our create
129:58 - functionality here where we can save a
130:01 - newly added employee record to the
130:03 - employees database table
130:06 - so let's use our employee management
130:09 - service functionality appropriately to
130:12 - add a new record to the employees
130:15 - database table
130:16 - note that the data inputted by the user
130:19 - is accessible through the args arguments
130:22 - data value here
130:24 - so we can pass this value to our add
130:27 - employee method like this
130:30 - before we act as a user and add a record
130:33 - to the database
130:35 - let's include the email field within our
130:37 - data grid
130:39 - we have not allowed this field to store
130:41 - null values in our employees database
130:44 - table
130:45 - so a value for the email field must be
130:49 - supplied when adding a new employee
130:51 - record to the employee's database table
131:08 - so let's adjust the data grid size to
131:10 - accommodate our new column
131:52 - so let's add a record to our database
131:55 - through the data grid
131:58 - so let's say a new sales rep named greg
132:00 - ross has just joined the company
132:03 - so let's add his details to the system
132:18 - and he will report to team leader jenny
132:21 - marks
132:41 - great and greg ross has been
132:43 - successfully added to the system
132:48 - notice that the id value is zero at the
132:51 - moment and no image is displayed for
132:54 - greg ross at present
132:57 - this is because we need to refresh the
132:59 - data in the grid in order for the id
133:02 - value related to the new employee greg
133:05 - ross to be appropriately displayed on
133:08 - the data grid
133:10 - this is also true for greg ross's
133:12 - profile image
133:14 - to make sure our data grid is refreshed
133:17 - with the latest data saved to the
133:19 - database we can hook
133:22 - into another event that fires once the
133:25 - code to add an employee record has
133:28 - completed
133:30 - so to achieve this
133:32 - let's set the on action complete
133:34 - property to a method handler that we are
133:37 - going to create in just a bit
133:39 - let's name our event handler method
133:42 - action complete handler
133:49 - you can use intellisense to see what the
133:52 - method signature or method definition
133:55 - of our event handler method must be
133:59 - so let's create the relevant event
134:01 - handler method
134:29 - we only want our custom code in this
134:31 - case to execute
134:33 - when the user has added a new record
134:36 - let's use the appropriate if statements
134:39 - to check the nature of the user's
134:41 - actions
134:42 - i am currently just checking the request
134:44 - type value for the save action here
134:48 - but we should also include code to check
134:51 - that the action value is set to the
134:54 - literal text add
134:56 - as we have done in the action begin
134:58 - handler method
135:00 - we only want the grid to refresh as it
135:02 - were once a user has added a new
135:06 - employee record through the use of the
135:08 - data grid
135:10 - for the functionality of refreshing the
135:12 - data grid we need to reference
135:15 - our sync fusion datagrid component in
135:18 - our code
135:19 - to do this
135:21 - we can use the at ref attribute and set
135:24 - its value to a property that will store
135:26 - a reference to our syncfusion datagrid
135:29 - component
135:50 - so let's create the property that will
135:52 - reference the data grid in our code here
136:06 - let's apply code to refresh the
136:08 - datagrid's data source with the latest
136:10 - employee data saved to the database by
136:14 - assigning the data source property a
136:16 - list of employee model objects returned
136:19 - by the get employees method that is
136:22 - called on the injected employee
136:24 - management service object
136:27 - and we can call the refresh method on
136:28 - the property that references our
136:31 - syncfusion data grid component like this
136:48 - so currently when we put the data grid
136:51 - into add mode the id field is editable
136:55 - we can explicitly disable this field by
136:58 - including the allow adding property
137:01 - within the appropriate grid column
137:02 - element and set its value to false
137:06 - this is an auto-incremented field and we
137:09 - don't want the user to edit this field
137:26 - let's enable sorting for our data grid
137:30 - we can achieve this by including the
137:32 - allow sorting property within the sf
137:35 - grid element and setting its property to
137:37 - true
137:51 - so if we add a new employee named david
137:54 - brown to the system
138:15 - the record has been added
138:18 - and because our code is now refreshing
138:19 - the data once the record has been added
138:22 - the id for the employee
138:24 - that we have just added will have the
138:26 - highest id value in the data grid
138:29 - so the data grid is currently being
138:30 - sorted by id in ascending order the
138:34 - newly added employee record for david
138:36 - brown will currently occupy the last row
138:39 - in the data grid
138:41 - so because we have enabled sorting
138:44 - the user can sort the id column in
138:46 - descending order so we can now see the
138:49 - newly added record at the top of the
138:51 - data grid
138:52 - the employee id saved to the employee's
138:55 - database table is displayed in the data
138:58 - grid and a default image is also
139:00 - displayed for the newly added mail
139:03 - employee
139:05 - and you can see here that i've added a
139:07 - few other records to the system
139:09 - off-screen
139:12 - so let's create the data handling
139:13 - functionality for when a user updates
139:16 - details for an employee record within
139:18 - the data grid and let's also create the
139:21 - functionality for deleting an employee
139:23 - within our employee management service
139:26 - class
139:27 - let's create a method named update
139:29 - employee
139:49 - and implement the logic like this
141:36 - let's create the logic for the delete
141:38 - employee method like this
141:41 - if at any point you get stuck and are
141:43 - struggling to follow along please
141:45 - reference the code on github you are of
141:48 - course welcome to copy the code from the
141:50 - relevant github page
142:27 - great so within the action begin handler
142:29 - method we can include a check to see if
142:32 - an edit has occurred and then apply our
142:35 - database related code appropriately here
142:49 - so for the scenario where a user action
142:52 - triggered the action begin handler
142:54 - method and a save has not been initiated
142:57 - by the user but rather a delete has been
143:00 - initiated by the user we can include an
143:03 - appropriate else if condition
143:05 - in the top if block to check for a
143:07 - delete action
143:24 - we can then apply the appropriate code
143:26 - to delete the relevant record from the
143:28 - database like this
143:39 - we only need the refresh functionality
143:41 - to run when an ad action occurs so
143:44 - please make sure that an if condition is
143:46 - appropriately included within the action
143:49 - complete handler method to check that an
143:52 - ad action has been initiated so that the
143:54 - data is only refreshed within the data
143:57 - grid when a create operation has been
143:59 - completed
144:07 - let's run the code and test that our
144:10 - update functionality has been
144:12 - implemented correctly
145:01 - excellent
145:03 - and we are now able to create employee
145:05 - records within the system
145:32 - and update employee records within the
145:34 - system using our sync fusion data grid
145:40 - we can also delete records from the
145:41 - system like this
145:44 - the effects on the employee data caused
145:46 - by user cred related actions
145:49 - are now not only reflected in the data
145:51 - grid but are also persisted to the
145:54 - employees database table great
145:57 - so
145:58 - one thing of course we need to discuss
146:01 - along with the subject of credit
146:02 - operations is validation
146:05 - so how can we enforce validation rules
146:08 - for the fields of our data grid for when
146:10 - a user is either attempting to add a new
146:13 - record to the system or update an
146:16 - already existing record in the system
146:18 - this is very simple to do those of you
146:21 - familiar with asp.net core razer pages
146:24 - or mvc will no doubt already be familiar
146:27 - with the code that can be implemented
146:29 - here for this purpose
146:32 - to enforce a specific validation rule on
146:35 - a model's property a developer is able
146:38 - to decorate the relevant models property
146:41 - with a specific attribute that indicates
146:43 - to.net as it were which validation rule
146:47 - should be applied
146:48 - to the relevant models property so let's
146:51 - look at this with an example so each row
146:54 - of data in our data grid is of type
146:56 - employee model
146:58 - so if we go to the employee model class
147:01 - we can for example apply the required
147:04 - attribute
147:05 - and therefore the required validation
147:07 - rule to the first name property like
147:10 - this
147:18 - the validation attributes reside within
147:21 - the system.component model dot data
147:24 - annotations namespace
147:26 - so we must ensure
147:28 - we include an appropriate using
147:30 - directive at the top of our code
147:41 - and if when we edit this field in our
147:44 - data grid and we violate the required
147:47 - rule a red border appears around the
147:50 - relevant input field
147:52 - and we are presented with an appropriate
147:55 - error message
147:58 - let's apply the required validation rule
148:00 - for the last name field
148:04 - the email field and the gender field
148:10 - let's apply a special rule
148:12 - for the first name property where the
148:14 - user must enter at least two characters
148:17 - for this field
148:18 - and not be allowed to enter more than
148:21 - 100 characters into this field
148:24 - we can use the string length attribute
148:26 - to enforce this rule
148:50 - let's apply the same rule for the last
148:52 - name property
149:00 - let's declare the email address
149:02 - attribute against the email field to
149:05 - ensure that the user enters an email
149:08 - address that conforms to a valid email
149:10 - address format
149:12 - you can of course create your own custom
149:14 - validation attribute by creating classes
149:17 - that inherit from the validation
149:19 - attribute base clause
149:20 - this functionality is beyond the scope
149:22 - of this course but it is easy to
149:24 - implement you can then apply your own
149:27 - custom validation attributes to the
149:29 - relevant properties
149:31 - so you are able to apply whatever
149:34 - validation rules that are required
149:37 - to any input field within the syncfusion
149:39 - data grid
150:16 - the sync fusion data grid
150:19 - allows a user
150:20 - to export the data displayed within the
150:23 - data grid to an excel spreadsheet you
150:26 - are able to automatically export the
150:28 - data displayed within the syncfusion
150:30 - data grid to an excel spreadsheet or a
150:33 - pdf document with minimal additional
150:35 - code so to enable the user to export the
150:38 - data in the data grid to an excel
150:41 - spreadsheet let's first add an
150:43 - appropriate toolbar button to our
150:45 - datagrids toolbar like this
150:52 - then within the sf grid element let's
150:55 - include the allow excel export property
150:58 - and set its value to true
151:07 - then we are able to hook into an event
151:09 - that is fired when the user clicks a
151:11 - button on the toolbar by setting the on
151:14 - toolbar click property within the grid
151:17 - events element to an event handler
151:19 - method that we'll create in just a bit
151:45 - the implementation for our event handler
151:47 - method is really simple
151:49 - so if the user clicks the excel export
151:52 - button
151:52 - run the sync fusion data grids export to
151:55 - excel async method
152:29 - and look at that excellent
152:38 - let's allow pdf export
152:52 - and let's implement the appropriate code
152:54 - in our toolbar btn click handler event
152:57 - handler method
153:28 - let's of course include a pdf export
153:30 - button on the datagrits toolbar
153:57 - great
154:06 - let's say we wanted to include a button
154:08 - on the data grids toolbar that when
154:10 - clicked executes custom functionality
154:13 - let's say for example we wanted the data
154:15 - in the grid to be exported to a special
154:18 - xml format
154:20 - we can easily achieve this
154:22 - we can create our own custom buttons on
154:25 - the datagrids toolbar using the item
154:28 - model type which resides within the
154:32 - syncfusion.blazer.navigations namespace
154:34 - like this
154:35 - in the interests of time i'm not going
154:37 - to write such xml custom functionality
154:40 - but i'll demonstrate how we are able to
154:42 - include a custom button on the datagrid
154:44 - toolbar and how custom functionality can
154:47 - be executed when the relevant custom
154:49 - button is clicked by the user
156:02 - great
156:04 - we are able to create columns that
156:07 - contain command buttons within our data
156:09 - grid
156:11 - say for example we wanted to execute the
156:14 - edit and delete operations
156:16 - from buttons that appear at the end of
156:19 - each row within our grid rather than
156:21 - through the relevant buttons on the data
156:23 - grids toolbar
156:33 - we can include the grid command columns
156:35 - element within an appropriate grid
156:37 - column element to achieve this
156:58 - we can then include the appropriate grid
157:00 - command column elements within the grid
157:02 - command columns element
157:04 - and style them appropriately like this
158:20 - so now we are able to use these buttons
158:22 - to edit and save our data
158:45 - and we can use this button to delete
158:47 - relevant data
158:57 - excellent
158:58 - we are also able to include our own
159:00 - custom command buttons within the data
159:02 - grid
159:05 - like this
159:52 - we must of course wrap the grid command
159:54 - column elements within the grid command
159:57 - columns element like this
161:56 - excellent
162:22 - and if we choose to handle our updates
162:24 - and delete operations using the command
162:27 - buttons we can remove the relevant
162:29 - buttons from the toolbar
163:11 - great
163:19 - the default mode for our grid is normal
163:21 - mode
163:22 - in normal mode when we edit a row of
163:25 - data in our data grid we edit the
163:27 - relevant fields
163:29 - directly within the data grid itself
163:32 - when we add a new record to our data
163:34 - grid while in normal mode a blank new
163:37 - row appears at the top of the grid
163:40 - and we can input the values for the
163:41 - relevant fields directly within the data
163:44 - grid
163:46 - we are able to edit or add our data
163:48 - using two other modes
163:50 - dialog mode and batch mode
163:53 - let's first discuss dialog mode
163:56 - using dialog mode when a user edits a
163:59 - row in the data grid
164:01 - or adds a row to the data grid a dialog
164:04 - is presented to the user with the
164:05 - relevant editable fields
164:08 - so the user is able to perform the edit
164:11 - or add operation
164:12 - using a separate dialog rather than
164:15 - applying the relevant changes directly
164:17 - to the data grid so to indicate that we
164:19 - want the user to add and edit data using
164:22 - a separate dialog
164:24 - rather than performing these actions
164:26 - directly on the grid for this purpose
164:29 - we must set the mode property of the
164:32 - grid edit settings element to the edit
164:35 - mode dot dialog enum value
165:04 - now when a user adds a record or editor
165:06 - record a new dialog pops up
165:09 - and the relevant operation is done using
165:12 - this dialog
165:15 - we are able to customize the dialog for
165:18 - example we can disable certain fields
165:21 - for add or edit operations like this
165:50 - we can customize the header for example
165:53 - we may want a heading on the dialog to
165:55 - reflect the action that is being
165:57 - performed
165:58 - to customize the header for the dialog
166:01 - we must add the header template element
166:04 - to the grid edit settings element like
166:07 - this
166:28 - then we are able to implement our code
166:30 - to handle the relevant customization
166:32 - functionality
167:57 - great
168:15 - we are also able to customize the footer
168:17 - of the dialog and for example change the
168:19 - captions on the buttons
168:21 - based on the operation being performed
169:55 - then we can hook into the relevant
169:56 - button events and ensure that the
169:59 - appropriate functionality is executed
170:01 - like this
170:02 - the cancel button simply closes the
170:04 - dialog
170:16 - the save button executes the relevant
170:18 - save functionality and then closes the
170:21 - dialogue
170:51 - great
171:35 - you are also able to include the
171:37 - template element within the grid edit
171:39 - settings element to customize the fields
171:42 - and layout of the fields displayed to
171:45 - the user within the dialogue
171:47 - please consult the sync fusion
171:49 - documentation for comprehensive
171:51 - information on how to do this
172:22 - batch mode
172:24 - so let's look at what we are able to
172:25 - achieve using batch mode
172:29 - when our data grid is in batch mode we
172:32 - are able to perform more than one
172:33 - operation on multiple rows of data
172:35 - before saving our data
172:38 - for example a user can add a new record
172:40 - edit a different existing record and
172:43 - delete a record before pressing the
172:46 - update button to save the effects of all
172:48 - three actions at once
172:50 - in batch mode the user's add edit and
172:53 - delete operations can be executed in a
172:56 - batch all at once
172:59 - so to run our data grid in batch mode we
173:01 - simply set the mode property here
173:03 - to the edit mode dot batch enum value
173:08 - let's include the update and cancel
173:10 - buttons within the toolbar of the data
173:13 - grid once again because in batch mode we
173:16 - are going to be able to edit multiple
173:18 - rows so performing the save operation
173:20 - once a batch of operations have been
173:22 - performed by using the appropriate
173:25 - toolbar button seems more appropriate
174:01 - you can see that once we have edited a
174:03 - field and the field loses focus that the
174:06 - background color of the relevant cell is
174:09 - set to green
174:10 - so at a glance the user is able to see
174:13 - which fields in the data grid have been
174:15 - modified before the user saves the
174:18 - relevant data
174:34 - then once the user has finished the
174:36 - batch edit the user can press the update
174:38 - button on the toolbar to save all of the
174:41 - user's changes
174:43 - however this action at the moment will
174:46 - only save the changes to the data grid
174:49 - and will not make the relevant changes
174:51 - to our database
174:53 - so to propagate the changes through to
174:55 - the database
174:56 - we are able to hook into an event
174:59 - triggered by the user's action to save a
175:01 - batch of changes made to the data grid
175:05 - so to do this within the grid events
175:08 - element let's set a property named on
175:10 - batch save to the name of a method that
175:13 - we are going to write which will handle
175:16 - the on batch save event
175:19 - and you can see via intellisense the
175:21 - method definition or method signature if
175:23 - you like
175:24 - of the event handler method that we need
175:26 - to write to handle the on batch save
175:29 - event
175:30 - so let's create this method and let's
175:32 - appropriately name it on batch update
175:35 - handler
176:10 - so through the args argument passed to
176:12 - the on batch update handler method
176:15 - we have access to the records that have
176:17 - been added changed and deleted
176:31 - the logic for our code simply traverses
176:34 - these records and executes the
176:37 - appropriate operations
178:02 - excellent
178:04 - and then of course as demonstrated
178:06 - earlier we are easily able to include
178:08 - functionality like paging in our
178:11 - syncfusion data grid like this
178:13 - if we want to include a maximum of six
178:15 - rows of data per page
178:54 - let's adjust our page size to five
179:00 - we can also easily include grouping
179:02 - functionality into our data grid by
179:04 - including this code in our datagrid
179:06 - component
180:04 - we can include basic filtering
180:06 - functionality for each column in our
180:08 - data grid by including the allow
180:10 - filtering property within the sf grid
180:13 - element and setting its value to true
180:37 - great and we can include more
180:39 - sophisticated filtering functionality
180:41 - for each column in our grid by including
180:44 - the grid filter settings element within
180:46 - the sf grid element and setting the type
180:49 - property for example to
180:50 - syncfusion.blazer
181:06 - then we are able to filter our data by
181:08 - either filtering on one column or a
181:10 - combination of columns in a variety of
181:13 - useful ways
181:36 - excellent
181:38 - so in this part of the course we have
181:40 - demonstrated how we are able to use the
181:42 - data grid for providing sophisticated
181:44 - functionality to the user and we've been
181:47 - able to integrate the sophisticated
181:49 - functionality with ease into our sales
181:51 - management application
181:53 - with clean and easy to read code
181:56 - we have been able to customize the data
181:58 - grid to suit our application's
182:00 - requirement
182:01 - please explore the comprehensive
182:03 - documentation and demo source code
182:06 - provided by syncfusion on their website
182:09 - where you'll be able to delve even
182:10 - deeper into the vast amounts of
182:12 - functionality that can be leveraged
182:14 - through the use of the syncfusion
182:16 - datagrid component
182:19 - so the developer is able to provide
182:20 - extremely rich and powerful
182:22 - functionality with minimal declarative
182:25 - code through the integration of the
182:27 - datagrid into an application
182:30 - please see the code on github for what
182:33 - the code should look like for our
182:34 - particular requirement
182:49 - so in this section of the course
182:51 - we are going to create a facility where
182:54 - sales reps can for example
182:57 - log on to the system when they are on
182:59 - site with a client and order products
183:02 - for the relevant client from a product
183:04 - catalog so for example an outdoor
183:07 - excellence sales rep regularly visits
183:10 - clients of outdoor excellence
183:14 - a client could be a buyer for a retail
183:16 - outlet that specializes in selling
183:19 - outdoor and sports products
183:23 - the sales rep presents a product catalog
183:26 - to the client and the client is able to
183:28 - instruct the sales rep on which products
183:31 - the client wishes to purchase
183:33 - from the product catalog
183:35 - the sales rep can then using the sales
183:38 - management app simply check the check
183:40 - boxes
183:41 - next to the products that the client
183:43 - wishes to order through the app and
183:46 - press a button to order the checked
183:48 - products
183:50 - details of the order are then processed
183:52 - by the system and data is captured
183:55 - regarding for example
183:57 - the order price products
183:59 - date of the order the employee id of the
184:03 - sales rep responsible for the order the
184:05 - client id of the client that instructs
184:08 - the sales rep to make the particular
184:10 - order the location of the retail outlet
184:13 - etc
184:14 - a little bit later in the course
184:16 - we are going to use syncfusion charts to
184:19 - display useful metrics gleaned from the
184:22 - order data that is captured when a
184:24 - client makes an order or multiple orders
184:27 - through the sales management application
184:31 - so in this section of the course
184:32 - basically we are going to create
184:34 - functionality for displaying a product
184:37 - catalog and also facilitate a basic
184:40 - ordering system so that a sales rep can
184:42 - create an order directly from the
184:45 - product catalog for the relevant client
184:49 - so let's first create the display
184:51 - product catalog functionality
184:53 - so let's first create a razor component
184:56 - named product catalog
185:14 - let's use the at page directive to set
185:17 - up the appropriate routing information
185:19 - for the product catalog razer component
185:29 - let's include a link to our new razor
185:31 - component within the nav menu razer file
186:13 - great
186:14 - before we write the front-end code to
186:16 - display the products to the user let's
186:19 - create a products database table and a
186:22 - product categories database table using
186:24 - ef core code first migrations
186:28 - as we have already discussed the
186:30 - products table has a many-to-one
186:32 - relationship with the product categories
186:35 - table
186:36 - for example the product category named
186:38 - camping can contain different types of
186:41 - tent products as well as different types
186:43 - of air mattresses
186:45 - the mountain bikes product category can
186:48 - contain many types of mountain bikes so
186:51 - the relationship is one product category
186:54 - too many products or conversely many
186:57 - products to one product category
187:00 - okay so let's create the product entity
187:03 - within the entities folder
188:04 - great
188:09 - let's create the product category entity
188:42 - great
188:43 - let's add the appropriate db set
188:45 - properties to our sales management db
188:47 - context class
189:15 - great
189:20 - let's create a migration and name it add
189:23 - product tables
189:48 - let's run our migration by typing in the
189:51 - update database command and pressing the
189:54 - enter key
190:21 - excellent
190:24 - so let's seed our product categories
190:26 - table and products table with data
190:30 - i've already prepared product related
190:32 - data off-screen so that we can see that
190:34 - database with appropriate product
190:37 - category data and appropriate product
190:40 - data
190:41 - please copy the relevant product seed
190:43 - data code from the github web page at
190:46 - this location a link to this webpage has
190:49 - been included below in the description
190:52 - so let's open the seed data class from
190:55 - within the data folder
190:57 - and let's add a static method named add
191:00 - product data
191:07 - then let's copy the relevant code from
191:09 - the relevant github web page
191:48 - and paste it into our new add product
191:51 - data static method
192:12 - then we can call the add product data
192:14 - method
192:15 - from within the on model creating method
192:18 - of our sales management db context class
192:44 - let's add a migration named seed product
192:47 - data
193:22 - great
193:22 - let's update the database by running the
193:24 - update dash database command
193:53 - excellent
193:55 - so you can see we have an image path
193:57 - for each product row stored within the
193:59 - products database table
194:02 - i've prepared images for each of the
194:04 - products off screen
194:06 - please download these images from this
194:08 - location on github
194:10 - a link to the location is available
194:12 - below in the description of this video
194:24 - then let's create a folder within the
194:27 - www root slash images folder named
194:31 - products
194:44 - and paste the images that we have just
194:46 - downloaded from github within this
194:49 - products folder
195:01 - great
195:03 - so we can now create the database
195:05 - related functionality to retrieve the
195:08 - data related to our products
195:10 - before we create a service for this
195:12 - purpose let's create a product model
195:14 - class
196:13 - this class will serve as the type for
196:15 - each product object displayed on the ui
196:18 - in our product catalog razer component
196:22 - let's create an interface within the
196:24 - contracts folder named i product service
196:42 - let's create a definition for a method
196:45 - that will be responsible for retrieving
196:47 - product data from our database
197:00 - let's create a class named product
197:02 - service
197:03 - where we'll implement the logic for the
197:05 - method definitions defined within the i
197:08 - product service interface
197:40 - let's create a constructor that accepts
197:43 - an argument of type sales management db
197:46 - context
197:47 - an object of type sales management db
197:49 - context will be injected into this
197:52 - constructor at runtime
197:54 - let's generate a field to reference the
197:56 - relevant sales management db context
197:59 - object
198:01 - so before we implement the logic for our
198:03 - get products method let's create an
198:05 - appropriate convert extension method
198:08 - for the purpose of transforming a
198:10 - collection of product objects to a
198:13 - collection of product model objects
199:08 - great
199:10 - we can pass in the sales management db
199:12 - context object
199:14 - to our extension method
199:16 - so that we can join to the product
199:18 - category entity in the relevant link
199:21 - query by doing this we are able to
199:24 - include the product category name in our
199:26 - list of product model data that will be
199:29 - returned to the calling code
200:19 - oops we have a little typo to fix here
200:21 - so let's go to the product model class
200:23 - and fix the issue
200:26 - not decryption but rather description
201:09 - then the code for the get products
201:10 - method is simply this
201:50 - great we want to use the syncfusion list
201:54 - view component
201:55 - to display our product data on the user
201:58 - interface
202:00 - to do this we first need to install the
202:05 - dot syncfusion.blazer.list
202:06 - new get package
202:33 - i see during the development of this
202:34 - application a new version of the
202:37 - syncfusion components has been released
202:40 - we have currently been using version
202:42 - 20.1.0.58
202:45 - of the syncfusion components
202:48 - so to be consistent let's install
202:50 - version 20.1.0.58
202:54 - of the
202:55 - syncfusion.blazer.lists nuget package we
202:58 - can always update our installation of
203:00 - our syncfusion components to the latest
203:02 - version at a later time
203:11 - great
203:12 - let's include a using directive that
203:14 - references the syncfusion.blaser.lists
203:17 - namespace at the top of our code
203:24 - in this razor component our code is
203:27 - going to refer to types within the sales
203:29 - management app.entitiesnamespace
203:32 - the
203:32 - salesmanagementapp.services.contracts
203:36 - namespace and the sales management app
203:38 - dot services namespace
203:46 - so let's cut the relevant directive code
203:48 - from the employee management razer
203:50 - component and paste this code within the
203:54 - underscore imports.razer file this means
203:57 - that these directives will now be
203:59 - applicable to all of our razor
204:01 - components
204:12 - let's write code so that a product
204:14 - service object is injected into our
204:17 - product catalog razor component at run
204:20 - time
204:24 - let's create a parent div tag that
204:26 - contains a bootstrap class so that this
204:29 - div represents a row within the
204:31 - bootstrap grid system
204:46 - let's create a div element that contains
204:48 - a bootstrap class to indicate that the
204:51 - content within this div
204:53 - should take up all 12 columns of the
204:56 - bootstrap grid
205:01 - within this div let's create declarative
205:04 - code to include the sf list view
205:07 - component appropriately within our razer
205:10 - component
205:14 - let's write code to override blaze's
205:17 - uninitialized async lifecycle event
205:20 - handler method
205:28 - let's create a variable that will
205:30 - reference the data that we'll use as a
205:32 - data source for our syncfusion list view
205:34 - component this data source will of
205:37 - course contain items of type product
205:39 - model to store the product data
205:42 - retrieved from our database
206:01 - then we can use our product service
206:03 - functionality
206:04 - to retrieve our products data from the
206:06 - database and assign this returned value
206:10 - to the private variable named product
206:12 - data that we will wire up as the data
206:16 - source for our syncfusion list view
206:18 - component
206:20 - so let's appropriately set the data
206:21 - source property of the sf list view
206:24 - element to the product data variable
206:32 - actually let's change our products data
206:34 - variable
206:35 - into a property and capitalize the p in
206:38 - product data
206:49 - great
206:50 - let's not forget to register our product
206:52 - service type for dependency injection
207:18 - great
207:20 - let's include a list view field settings
207:23 - element within our sf list view element
207:26 - like this
207:33 - let's set the t value property within
207:36 - the list view field settings element to
207:38 - product model
207:40 - let's set the id property to id and the
207:43 - text property to name
207:45 - so here we are telling the sync fusion
207:47 - list view component as it were
207:50 - which property denotes the value of a
207:52 - list view item and which property of the
207:55 - list view item which remembers of type
207:57 - product model should be displayed on the
208:00 - ui
208:13 - and there it is our products are
208:15 - displayed neatly within our list view
208:17 - component
208:19 - so of course we are able to customize
208:21 - our sync fusion list view component so
208:23 - that it suits our particular requirement
208:26 - firstly let's say we want our products
208:28 - displayed
208:30 - so that they are grouped by product
208:32 - category
208:33 - we are able to do this by setting the
208:35 - grouped by property in the list view
208:38 - field settings element to the property
208:41 - of the product model type by which we
208:44 - want our list of products grouped so we
208:46 - want to group our products by product
208:49 - category
208:50 - so we can achieve this by grouping by
208:52 - the category name property of the
208:55 - product model type like this
209:10 - great
209:12 - we are able to customize the look of the
209:14 - grouped field
209:15 - through the use of the list view
209:17 - templates component
209:19 - so let's include
209:21 - the list view templates element within
209:23 - the sf list view element
209:27 - let's set the t value property to the
209:30 - type of objects stored
209:32 - in the data source that we have wired up
209:35 - to the syncfusion list view component
209:38 - then we can include code to specifically
209:40 - target the field by which we are
209:43 - grouping the data
209:44 - to do this
209:46 - we can include the group template
209:48 - element within the list view templates
209:50 - element
209:51 - then we can use the context object to
209:54 - reference a particular list item
209:56 - and of course each list item is of type
209:59 - product model
210:01 - we are able to include basic html like
210:03 - this to style the category name property
210:06 - of the product model type
210:17 - and that looks pretty good
210:26 - we can include the template element
210:28 - within the listview templates element to
210:30 - style the list items
210:35 - within the template element we can use
210:38 - html and css
210:40 - to style the fields we want to display
210:43 - to the user
210:44 - for each list item in the list view
211:25 - the sync fusion list view component
211:27 - makes each product model list item
211:30 - available to us in code through the
211:32 - context object
211:34 - so we are able to include which fields
211:36 - from the product model type we want to
211:39 - display in our template using the
211:41 - context object
211:43 - notice that we are using certain sync
211:45 - fusion css classes to style the list
211:49 - view items
212:17 - so before we continue let's use the
212:19 - tostring
212:21 - and net globalization functionality to
212:24 - force the currency to be displayed as u
212:27 - s dollars like this
213:21 - let's set the css class property
213:24 - of the sf list view grid component to
213:27 - sync fusion's e-list dash template css
213:30 - class
213:33 - for more detail on the css structure
213:36 - in the blazer list view component please
213:39 - check out syncfusion's documentation
213:41 - regarding this topic at this location
213:45 - a link to this webpage has been included
213:47 - in the description of this video
213:54 - let's also include a class named list
213:56 - view dash template
214:00 - we can customize the style for our list
214:02 - view using appropriate css code
214:22 - let's run the code
216:00 - and i think that looks pretty good
216:02 - so i want to include a checkbox next to
216:05 - every list item so that the user can
216:07 - easily select the products
216:09 - from the product catalog before placing
216:11 - an order
216:13 - to include this functionality
216:15 - all we need to do is add the show
216:17 - checkbox property within the sf list
216:20 - view element
216:21 - and set its value to true
216:55 - excellent
217:03 - with each order made on behalf of a
217:05 - client by a sales rep we also need to
217:08 - include relevant client information
217:10 - so we want to include a combo box that
217:13 - is populated with a list of clients
217:16 - the sales rep can then choose the client
217:19 - on whose behalf an order is created from
217:22 - the combo box before placing the
217:24 - relevant order
217:25 - so firstly let's create a c-sharp class
217:28 - named client within the entities folder
217:31 - like this to represent the client entity
218:33 - great
218:38 - let's also create a c-sharp class named
218:40 - retail outlet
218:51 - and include these properties within the
218:54 - retail outlet class this c-sharp class
218:57 - represents the retail outlet entity
219:13 - the client entity has a one-to-one
219:16 - relationship with the retail outlet
219:18 - entity
219:19 - a client works for a retail outlet
219:23 - and serves as the point of contact for
219:25 - an outdoor excellence sales rep
219:29 - let's include the relevant dbset
219:31 - properties so that ef core will include
219:34 - code within our next migration to create
219:37 - the corresponding database tables within
219:39 - our database
220:08 - let's generate the migration code
220:37 - and let's update the database
221:04 - great
221:05 - let's seed our clients and our retail
221:08 - outlets tables with data
221:10 - please copy the relevant code for
221:12 - seeding these tables from the github web
221:14 - page found at this location
221:17 - a link to this page has been included in
221:19 - the description of this video so within
221:22 - the seed data class let's create a
221:24 - static method named add clients
222:04 - let's paste the appropriate code that we
222:07 - have copied from the relevant github web
222:09 - page into the add clients method
222:22 - ok so to be consistent let's rename our
222:25 - add clients method to add client data
222:29 - let's then call the add client data
222:31 - method from within the on model creating
222:34 - method within the sales management db
222:36 - context class
222:58 - let's create a migration named seed
223:00 - client data
223:31 - great
223:32 - let's update the database with our
223:34 - client data by typing in the update
223:37 - database command and then pressing the
223:40 - enter key
224:05 - excellent
224:07 - before we create a service responsible
224:10 - for our client functionality let's
224:12 - create a c-sharp class named client
224:14 - model within the models folder
225:35 - great
225:36 - let's create an interface named i client
225:39 - service
225:54 - let's create a definition for a method
225:56 - that will be responsible for retrieving
225:59 - client data from the database
226:11 - let's implement the logic for the get
226:13 - clients method within a new class named
226:15 - client service
227:06 - before we do this
227:08 - let's create an overload for the convert
227:11 - extension method that converts a
227:13 - collection of client objects to a
227:15 - collection of client model objects
227:43 - we want to join our client entity to the
227:46 - retail outlet entity within our convert
227:48 - extension method
227:50 - so we must also pass in the sales
227:53 - management db context object
228:03 - within our link query let's join the
228:05 - clients collection to the retail outlets
228:07 - collection so that we can include
228:10 - location related information within the
228:12 - returned list
229:00 - then our code logic for our get clients
229:03 - method is very simple
229:23 - great
229:34 - let's go to our product catalog razor
229:36 - component
229:38 - let's write code to include a syncfusion
229:40 - combo box within the product catalog
229:43 - razer component
230:08 - let's create a property that will
230:10 - reference the data source that we are
230:12 - going to wire up to the combo box
230:25 - let's write code to retrieve the client
230:28 - data from our database within our
230:30 - override method of the uninitialized
230:32 - async laser lifecycle event handler
230:34 - method
230:39 - in order to access an object
230:41 - of type i client service
230:44 - we must write code
230:46 - to inject an object of type i client
230:49 - service
230:50 - into our razor component at runtime
231:06 - we must of course remember to register
231:08 - our client service type for dependency
231:11 - injection within the program.cs class
231:15 - like this
231:40 - then let's set the data source property
231:42 - within the sf combobox element to the
231:45 - client data property
231:52 - let's set the t value property to end
231:56 - and the t item property to client model
232:00 - the t value property setting tells the
232:03 - syncfusion combobox component as it were
232:06 - what data type is used for the value of
232:10 - each item included within the combo box
232:14 - the t item property setting tells the
232:16 - syncfusion combo box as it were the type
232:19 - of each item that is included within the
232:22 - combo box
232:24 - then we can use the at bind dash value
232:27 - attribute to bind the value of the
232:30 - selected combobox list item to a
232:33 - property that we are going to create
232:36 - so let's create a property for this
232:38 - purpose named client id
232:40 - and initialize its value to one
233:00 - we must include an element named combo
233:03 - box field settings within the sf
233:06 - combobox element and then we can define
233:09 - which property of the client model type
233:12 - we wish to display to the user by
233:14 - appropriately setting the text property
233:18 - we can also declare which property
233:20 - denotes the value of the items contained
233:23 - within the combo box by setting the
233:26 - value property to an appropriate
233:28 - property in the client model type
233:31 - let's run the code
233:45 - great
233:46 - and the user is able to type in text
233:48 - that alludes to a particular retail
233:50 - outlet into the combo box
233:53 - and the sync fusion combo box will
233:55 - navigate to a matching item in the list
233:58 - great
234:00 - let's appropriately style our layout and
234:02 - our combo box
234:42 - great
235:05 - let's create a c-sharp class within the
235:07 - entities folder named order
235:40 - great let's create a c-sharp class
235:43 - within the entities folder named order
235:45 - item
236:24 - great
236:26 - the order entity has a one-to-many
236:28 - relationship with the order item entity
236:31 - one order can contain one or many order
236:34 - items
236:36 - let's add the necessary dbcontext
236:39 - properties so that the order entity and
236:41 - the order item entity
236:43 - are used for creating the corresponding
236:46 - database tables in our database
237:13 - let's create an appropriate migration
237:32 - and let's update the database
237:34 - by running the update dash database
237:37 - command
237:56 - great
237:57 - we don't need to see the data for these
237:59 - tables because we are going to generate
238:01 - the relevant order data through our
238:03 - application
238:05 - let's create a class named order model
238:08 - within the models folder
239:08 - let's create an interface named i order
239:10 - service within the contracts folder
239:29 - let's create a definition for a method
239:31 - that will be responsible for creating
239:34 - order data within our system
239:47 - let's create a c-sharp class named order
239:49 - service and implement the code logic for
239:52 - the create order method
240:42 - so firstly we need to add an order to
240:44 - the system so let's create an order
240:46 - object and get its property values
240:49 - from the order model object passed into
240:51 - this method as an argument
241:07 - for now we are hard coding the employee
241:09 - id for our orders to nine
241:12 - which is the id
241:14 - of the employee named benjamin lucas
241:17 - who is a sales rep
241:19 - one of the last things we are going to
241:21 - do in this course is integrate microsoft
241:24 - identity authentication and login
241:26 - functionality into our application
241:29 - as part of the login functionality we'll
241:32 - be able to retrieve the id of the
241:34 - logged-on employee
241:36 - so we'll be able to get the appropriate
241:39 - employee id field at this point based on
241:42 - the logged on users details
241:45 - for now while we test our functionality
241:48 - let's simply hard code the employee id
241:50 - field where necessary
242:04 - then we can create code to add the order
242:07 - to the system like this
242:10 - and the add async method returns the
242:12 - order entity saved to the system
242:15 - and this is how we are able to reference
242:17 - the id of the order that has just been
242:21 - added to the database
242:23 - the order entity has a one-to-many
242:25 - relationship with the order item entity
242:28 - the order item entity has an order id
242:31 - property which is a foreign key from the
242:34 - order entity
242:35 - so we must insert the order entity into
242:39 - the database
242:41 - and reference the id of the newly added
242:44 - order entity that has just been added to
242:47 - the database
242:49 - this must be done
242:50 - before we add the orders relevant order
242:53 - items to the database each order item
242:57 - must reference
242:59 - the order's id
243:01 - before we add the relevant order items
243:03 - to the database each order item must
243:05 - contain an order id value pertaining to
243:08 - an order that has been added to the
243:11 - database
243:18 - let's create a private method
243:21 - that returns the order item collection
243:24 - where each order item contains the
243:27 - relevant order id value
244:37 - then we can use the add range method to
244:39 - add the relevant order items to the
244:41 - database
245:02 - we also need to sum up the price of all
245:05 - the order items pertaining to the
245:07 - relevant order
245:15 - and sum up the quantity of items that
245:17 - were included for the order like this
245:30 - great
245:32 - so these summing operations are done
245:34 - before the order is added to the
245:36 - database
245:38 - and subsequently the order items are
245:40 - added to the database
245:59 - so let's go to the product catalog.razer
246:02 - file and write code so that an object of
246:05 - type i order service is passed into the
246:08 - product catalog razer component at
246:11 - runtime
246:18 - let's register the i order service type
246:22 - for dependency injection
246:40 - let's include a button that a user can
246:43 - click to create an order in the system
246:45 - based on the product items that have
246:48 - been checked in the list view
247:12 - let's wire up an event handler method
247:15 - that we'll create in a bit
247:17 - for the purpose of handling the relevant
247:19 - button click event
247:21 - in this case the logic for the event
247:23 - handler method will entail collating a
247:26 - selected list of products i.e the
247:28 - products that have been checked in our
247:30 - list view
247:31 - and passing the list of products which
247:34 - denotes the order items in the client's
247:36 - order
247:37 - to the relevant order service
247:39 - functionality
247:41 - so let's create the create order event
247:44 - handler method
247:59 - so in order to get the selected product
248:02 - items from the list of products
248:04 - we need to be able to reference the sf
248:07 - list view component in code
248:10 - so we can use the at ref attribute for
248:13 - this purpose
248:39 - when the create order button is clicked
248:42 - by the user
248:43 - our code for creating the order is fired
248:47 - so let's write the code
248:49 - for the relevant buttonclickeventhandler
248:51 - method
248:52 - that carries out the task of creating an
248:54 - order in the system
248:56 - we are able to use a variable of the
248:58 - generic type selected items that is
249:01 - strongly typed with our product model
249:04 - type to reference the objects of type
249:06 - product model that pertain to the items
249:09 - in the list view that the user checks
249:12 - which means these products will become
249:15 - part of an order when the user clicks
249:17 - the create order button
249:19 - we can use our sf products lv object
249:23 - that is referenced within the sf list
249:26 - view element to get the checked list
249:29 - items by calling the get checked items
249:32 - async method on the sf products lv
249:35 - object
250:01 - each of the checked product items will
250:03 - become the basis for an order item we
250:06 - can use the order model type to create
250:09 - an object that contains relevant order
250:12 - information
250:13 - and the relevant order item collection
250:16 - note that each checked product is the
250:18 - basis for an order item
250:56 - then we can pass this data as an
250:58 - argument to the create order method like
251:00 - this
251:05 - let's test the code
251:46 - great but the order id
251:49 - in the order items table is zero for our
251:52 - order so it doesn't correctly
251:55 - relate
251:56 - to the order that we created which is
251:58 - incorrect
251:59 - let's investigate what went wrong here
252:04 - oh i can see what the problem is
252:06 - we must include a line of code to save
252:08 - our changes
252:10 - when we add an order to the system
252:13 - so this is ef core functionality whereby
252:16 - the save changes async method must be
252:18 - called
252:19 - after an entity is added to the database
252:22 - table
252:23 - so
252:24 - we must call the ef cause save changes
252:27 - async method like this after the code
252:30 - that adds the relevant entity to the
252:32 - database is executed
252:35 - so i'm going to delete the incorrect
252:37 - data that we have just inserted into the
252:40 - orders table and the order items table
252:44 - using the sql truncate table statement
252:47 - within sql server management studio
252:50 - by using the truncate table statement
252:53 - instead of simply deleting the data the
252:56 - primary key columns will be initialized
252:58 - back to zero
253:12 - so let's try again
253:39 - excellent
253:40 - we now have the correct order id value
253:43 - being inserted into the order items
253:44 - table
253:50 - however the date for the order dates
253:53 - time column is not correct
253:56 - so let's truncate the orders and the
253:58 - order items table again
254:17 - let's go to our order service class
254:20 - and we can easily correct this issue by
254:23 - setting the order date time property
254:25 - here to date time dot now which denotes
254:28 - the current date and time
255:03 - so that's great we are able to create
255:05 - our order
255:06 - but currently the user has no way of
255:08 - knowing if the user's order has been
255:10 - successful
255:12 - so we need a way to notify the user as
255:14 - to whether the user's order has been
255:16 - successful or unsuccessful
255:19 - let's use syncfusion's toast component
255:23 - for this purpose
255:25 - so once a user places an order we want a
255:28 - message to pop up like toast
255:31 - informing the user whether the user's
255:33 - order has been successful or
255:35 - unsuccessful
255:36 - so to install syncfusion's toast
255:39 - component let's right-click the
255:41 - dependencies node in visual studio's
255:43 - solution explorer window
255:45 - and select manage new get packages in
255:48 - order to invoke the new get package
255:50 - manager window
255:52 - let's go to the browse tab and search
255:54 - for toast
256:00 - the syncfusion.blazer.notifications
256:03 - new get package appears in our list
256:06 - and this is the package we want to
256:08 - install
256:09 - so let's install version 20.1.0.58
256:14 - there is a later version
256:16 - but we can always update our packages to
256:18 - a later version at a later stage let's
256:21 - keep our package versions consistent and
256:23 - install version 20.1.0.58
256:30 - let's add a using directive that
256:32 - references the
256:35 - syncfusion.blazer.notifications
256:36 - namespace to our product catalog razer
256:39 - file
256:40 - so in the syncfusion demo documentation
256:43 - at this location
256:45 - i've found the functionality that i want
256:47 - to incorporate into our application
256:58 - so i'm simply going to copy the code
257:00 - from this syncfusion documentation
257:03 - and integrate it into our product
257:05 - catalog razer component
257:09 - let's copy the code for the sf toast
257:11 - component from the syncfusion demo code
257:14 - here
257:15 - and paste it into our code here
257:21 - let's include this code that has a
257:23 - variable that we'll use to reference our
257:26 - sf toast component
257:28 - and a variable used for positioning our
257:30 - toast object on the screen
257:43 - let's include the code here where a list
257:46 - is created containing various toast
257:48 - types for example for success and error
257:51 - scenarios
258:23 - let's grab all of this code
258:26 - used for the styling of our toast
258:39 - and appropriately paste it into our
258:41 - product catalog razer file
258:57 - then we can create the code for showing
258:59 - our toast within our create order method
259:02 - like this
259:03 - so if our code reaches this line here it
259:06 - means the order has been processed
259:08 - successfully so let's write codes to pop
259:11 - up the toast that represents success
259:16 - note that off screen i have changed the
259:19 - success message to a message more
259:21 - appropriate for our requirement
259:23 - so this message now reads your order has
259:26 - been created successfully
259:32 - let's test the code
260:04 - excellent
260:06 - let's include the code that represents
260:07 - that our order has failed
260:09 - within the catch section of our try
260:11 - catch block
260:12 - to test this error scenario
260:15 - let's include a line of code
260:17 - that forces an exception to occur
260:20 - and we are now handling the exception
260:22 - with our toast
260:24 - so we don't want to throw the exception
260:26 - here
260:27 - so let's comment out this line of code
260:29 - here
260:33 - let's test the code
260:43 - excellent
260:45 - let's remove the line of code that we
260:47 - have included to force an exception to
260:49 - occur
260:50 - the last piece of functionality i'd like
260:53 - to add for our product catalog razer
260:55 - component
260:57 - is so that the user is able to filter
260:59 - the products in the catalog
261:01 - while typing in text within a text box
261:03 - above the list view component
261:06 - so let's include a syncfusion text box
261:09 - in a row just below our syncfusion combo
261:12 - box here in our code like this
261:28 - let's bring in the namespace of where
261:30 - the syncfusion text box resides
261:33 - the
261:34 - syncfusion.blazer.inputs namespace
261:37 - to filter our list view by product name
261:40 - as the user types text within our sync
261:42 - fusion text box
261:45 - we can use the input property in the sf
261:48 - text box element and wire it up to an
261:51 - event handler method that we'll create
261:54 - in just a bit
262:01 - let's first create a variable named
262:04 - product collection filter
262:06 - that will be used to filter our product
262:08 - list
262:09 - let's write code to assign the list of
262:12 - products
262:13 - stored within the data source of our
262:15 - sync fusion list view component to the
262:17 - product collection filter variable
262:20 - within the uninitialized async method
262:22 - and the code for our on input event
262:24 - handler method should look like this
262:29 - our code is filtering the product
262:30 - collection filter list
262:32 - every time a user enters a character
262:34 - into the sync fusion text box
262:37 - then we are assigning the result of the
262:39 - filtering operation to the data source
262:42 - of the syncfusion list view component
262:45 - which is the list stored in the product
262:48 - data property
263:03 - and that's great
263:05 - all works as expected
263:07 - but there are certain layout and styling
263:09 - concerns that need attention
263:12 - so let's address these issues
263:15 - just a reminder the full code is
263:17 - available on github a link to the
263:19 - relevant repository is available below
263:22 - in the description of this video
264:55 - and that looks great
264:57 - and let's press f12 while using our
265:00 - chrome browsers
265:01 - to see how this looks on different
265:03 - screen sizes
265:09 - great our front end code is fully
265:11 - responsive
265:12 - excellent
265:27 - so at this stage in the course
265:30 - we have created functionality where
265:32 - sales reps can place orders on behalf of
265:34 - their clients
265:36 - this order data that is being captured
265:39 - can be very useful for sales reps team
265:41 - leaders
265:42 - and the sales manager for analytical
265:45 - purposes for example from the captured
265:48 - data a sales rep can see how well the
265:52 - sales rep is performing and see which
265:55 - products are generating the most sales
265:58 - a team leader can see how well each of
266:01 - the team leaders team members are doing
266:03 - relative to one another and see how well
266:06 - the team leaders team is doing overall
266:09 - the sales manager can see how well the
266:12 - sales department is doing overall
266:14 - the sales data can be aggregated by
266:16 - location and over a period of time
266:20 - as developers the challenge is to
266:22 - present the relevant analytical data in
266:25 - a human readable way to the user
266:28 - so the user can derive useful knowledge
266:31 - when analyzing the relevant data
266:34 - sync fusion has created excellent chart
266:36 - components that address the issue of
266:39 - presenting analytical data in an
266:41 - aesthetically pleasing and human
266:43 - readable way
266:45 - it's like the old adage says a picture
266:48 - speaks a thousand words
266:50 - these charts are highly sophisticated
266:53 - and easy to implement they are easy to
266:55 - integrate into our code
266:58 - so in the first part of this section of
267:00 - the course we are going to create a
267:02 - razor component that displays three
267:04 - basic charts using appropriate
267:06 - syncfusion chart components
267:09 - this is so that we first gain a basic
267:11 - understanding of how a developer can
267:13 - harness the power of the syncfusion
267:15 - charts in a razer component
267:18 - we'll then progress further and create a
267:20 - dashboard for each type of employee in
267:22 - the sales department each dashboard will
267:25 - be implemented as a razer component
267:27 - we'll create a dashboard for the sales
267:29 - reps that presents three sync fusion
267:32 - charts with data that is relevant to
267:34 - sales reps we'll create a dashboard for
267:37 - team leaders that presents three charts
267:40 - with data that is relevant to the team
267:42 - leaders and lastly we'll create a
267:44 - dashboard for the sales manager that
267:46 - presents three charts with data that is
267:49 - relevant to the sales manager
267:51 - we'll implement code for three different
267:53 - types of popular charts bar charts donut
267:56 - charts and line charts
267:59 - before we build the dashboards let's
268:01 - create a temporary razer component so
268:03 - that we can gain a basic understanding
268:06 - of how to use the relevant syncfusion
268:08 - charts in this razor component we'll
268:11 - implement the code for three types of
268:12 - charts a bar chart a donut chart and a
268:15 - line chart
268:17 - so let's create a razor component named
268:19 - charts
268:37 - let's create an appropriate link within
268:40 - the nav menu razer component
269:09 - before we implement code for our charts
269:11 - it would be a good idea to consolidate
269:13 - our order reports data into one database
269:16 - table
269:17 - so we are going to create a denormalized
269:20 - table in our database to store our
269:22 - analytical data i.e the data we are
269:25 - going to wire up to our charts let's see
269:28 - what wikipedia says about
269:30 - denormalization
269:31 - denormalization is a strategy used on a
269:34 - previously normalized database to
269:37 - increase performance
269:39 - in computing denormalization is the
269:42 - process of trying to improve the read
269:44 - performance of a database at the expense
269:47 - of losing some right performance
269:50 - so for the transactional database tables
269:53 - where the tables are written too
269:54 - frequently our database designed for
269:57 - these tables is based on the strategy of
269:59 - normalization which we briefly discussed
270:02 - earlier
270:03 - so basically by creating a denormalized
270:06 - table for storing the analytical data we
270:09 - are eliminating the need for creating a
270:12 - lot of joins when implementing our link
270:14 - queries for the purpose of retrieving
270:16 - the relevant analytical data from the
270:19 - database to be displayed within our
270:21 - charts
270:22 - by querying a denormalized table we
270:25 - eliminate the need for these joins and
270:27 - our link queries will be a lot simpler
270:29 - our code will be easier to read and the
270:32 - process of retrieving the relevant data
270:34 - will be a lot more efficient
270:37 - the technique of denormalization is
270:40 - often used in olap online analytical
270:42 - processing applications the details of
270:45 - olap are beyond the scope of this course
270:48 - very briefly
270:50 - in olap applications data can be
270:52 - organized into data cubes which makes
270:55 - the retrieval of aggregated data derived
270:58 - from multi-dimensional criteria
271:00 - efficient
271:02 - the data does not need to be retrieved
271:04 - from the transactional database tables
271:07 - that have been designed using
271:08 - normalization so basically this
271:11 - eliminates the need for including joins
271:14 - within the queries for retrieving the
271:16 - relevant analytical data from the
271:18 - database
271:19 - so our application is not an olap
271:22 - application but some of the principles
271:24 - that are used in the creation of an olap
271:26 - application are relevant to how we are
271:29 - going to implement our analytical
271:31 - functionality in our application
271:35 - we are essentially going to organize the
271:38 - data that will be displayed on our
271:40 - charts into appropriate shapes using
271:42 - appropriate link queries
271:44 - that will be used for querying our
271:46 - denormalized table i.e the sales order
271:49 - report database table the relevant
271:52 - results of the link queries will then be
271:55 - wired up to the relevant syncfusion
271:57 - chart components
272:01 - if this is unclear to you at the moment
272:03 - don't worry this will become clearer as
272:06 - we create the relevant code
272:08 - so
272:09 - say for example we want to create a
272:11 - report for total sales quantity broken
272:14 - down by state or location
272:17 - the aggregated data quantity of sales is
272:20 - derived summed up by the location
272:23 - dimension
272:24 - so within our data we have the concept
272:27 - of dimensions and measures
272:30 - the dimension here is the location and
272:32 - the measure is the quantity of sales
272:34 - which is aggregated summed up by
272:37 - location
272:38 - so if we add another dimension
272:41 - this will of course effect the
272:42 - aggregated data for example a period of
272:45 - time could be our other dimension for
272:48 - example we could further aggregate the
272:49 - data by the months of the current year
272:52 - displaying such data in a chronological
272:55 - order by months
272:56 - shows progress or lack of progress in
272:58 - terms of sales performance over a period
273:01 - of time per location
273:03 - so the aggregated data is the quantity
273:06 - of sales the measure and the dimensions
273:09 - of the data are the period by month and
273:12 - the location by state
273:15 - so let's create the code for generating
273:17 - our denormalized database table
273:20 - let's create a class within the entities
273:23 - folder named sales order report
273:44 - this model is going to have quite a few
273:46 - properties so just a reminder you can
273:48 - copy the relevant code from github if
273:50 - you'd prefer rather than follow along
273:52 - with me as i create the properties for
273:54 - this class
273:56 - and you can see that we are including
273:58 - fields from the relevant transactional
274:01 - database tables each row in the table we
274:04 - are about to create will denote an order
274:07 - item
274:08 - in each row in this table
274:10 - in addition to the order item
274:12 - information we are also including for
274:14 - example the relevant client information
274:17 - i.e the client responsible for the order
274:20 - the employee information i.e the sales
274:23 - rep responsible for creating the order
274:25 - in the system the order date time the
274:27 - location where the order was initiated
274:30 - etc
274:31 - any information that we may wish to
274:34 - include in our analytical data is being
274:36 - included in this table the table is
274:39 - denormalized a lot of the data is going
274:42 - to be redundant
274:43 - in other words the data is repeated in
274:46 - each of the rows whereas in a normalized
274:48 - structure the normalization process
274:51 - serves to eliminate data redundancy and
274:54 - increase data integrity
275:22 - great so we have created our class that
275:25 - represents the sales order report entity
275:43 - let's create the appropriate db set
275:45 - property within the sales management
275:47 - dbcontext class
276:05 - let's generate a migration
276:48 - and let's update the database
277:12 - the next step is to appropriately
277:14 - include code to add relevant order
277:16 - information to our sales order reports
277:19 - table when an order is created
277:22 - note that in an olap application
277:24 - relevant analytical data wouldn't
277:26 - necessarily be captured in the database
277:28 - in real time i.e as the order is created
277:31 - in an olap application the data may be
277:34 - collated from for example the relevant
277:36 - transaction databases
277:38 - and transferred over to a separate
277:41 - database in a separate process that runs
277:44 - for example once a day in the early
277:46 - hours of the morning the data for
277:48 - analytical purposes could for example be
277:50 - stored in a data warehouse for the sake
277:53 - of simplicity in our example we are
277:55 - simply going to capture the data into
277:57 - our sales order reports table at the
278:00 - time at which the order is processed
278:03 - let's create a private method for
278:05 - inserting the relevant data into the
278:07 - sales order reports table
278:25 - in the interests of time i'm going to
278:27 - paste the relevant code that i've
278:29 - prepared offline into our private method
278:33 - please feel free to copy the code for
278:34 - this method from the relevant github web
278:37 - page
279:35 - then we can call our update sales order
279:37 - reports private method after the order
279:40 - data has been inserted into the relevant
279:42 - transactional database tables i.e the
279:45 - orders table and the order items table
279:49 - so we could run this in an ef core
279:51 - transaction
279:53 - so all three processes i.e inserting
279:56 - data into the orders table the order
279:58 - items table and the sales order reports
280:00 - table are executed in one process i.e if
280:04 - one process fails then all processes
280:06 - fail
280:08 - i won't implement this code as a
280:10 - transaction at this point but this is
280:12 - something that can easily be done here
280:14 - using ef core functionality
280:16 - i have however included the relevant
280:18 - transaction code in the version of the
280:21 - code that resides in the github
280:22 - repository that stores the code for this
280:24 - application please see a link to this
280:27 - repository below in the description
280:32 - so let's run the code to see if our
280:34 - order data is being captured in our
280:36 - sales order reports table
280:59 - excellent
281:01 - before we create the code for our charts
281:03 - in our razor component let's remove the
281:05 - data from the sales order reports table
281:08 - the order items table and the orders
281:10 - table
281:39 - so let's create report related models
281:42 - that will serve as the types
281:44 - for the objects that store the data for
281:46 - specific reports
281:48 - let's first create a folder within the
281:50 - models folder named report models
282:04 - within the report models folder let's
282:07 - create a class named grouped field price
282:09 - model this model represents the type for
282:12 - an object that stores aggregated price
282:14 - data for a particular grouped field that
282:17 - will be specified in the relevant link
282:19 - queries used for querying and shaping
282:23 - the returned analytical data
282:32 - let's create an interface named i sales
282:35 - order report service
282:50 - let's create a method definition for a
282:52 - method named get employee price per
282:55 - month that is responsible for returning
282:57 - analytical data for a particular sales
282:59 - rep and show the employees gross sales
283:03 - broken down by month for the current
283:05 - year
283:06 - the first chart we are going to create
283:08 - will be a bar chart that displays the
283:11 - gross sales value per month for the
283:13 - logged on employee
283:15 - the sales rep
283:17 - we are only going to create the relevant
283:18 - login functionality toward the end of
283:21 - this course so for now we are going to
283:23 - hard code the relevant employee id to
283:26 - nine which is the id for the sales rep
283:29 - named benjamin lucas in our employees
283:31 - database table
283:33 - let's implement the code logic for our i
283:36 - sales order reports service interface
283:39 - in a class named sales order report
283:42 - service
284:40 - so in the get employee price per month
284:43 - method let's create a link query that
284:45 - returns the gross sales per month for
284:48 - benjamin lucas
284:57 - note that i haven't specified the year
284:59 - in this query
285:01 - we are going to assume that the data in
285:03 - our database only applies to the current
285:05 - year
285:06 - note that i have included the relevant
285:08 - filter code in the where clause in the
285:10 - version of the code that resides in the
285:12 - relevant github repository ie to filter
285:15 - the relevant data by the current year
286:30 - great
286:31 - and that is our query
286:35 - we are ready to create the code for our
286:38 - first chart which will be a bar chart so
286:41 - let's go to our charts razer component
286:44 - let's first install the relevant nuget
286:46 - package so in order to use the
286:48 - syncfusion charts we must install the
286:52 - syncfusion.blazer.charts nuget package
287:06 - let's choose version 20.1.0.58
287:10 - to keep consistent with the versions of
287:12 - the other syncfusion components we can
287:14 - always update our components
287:16 - to the latest version at a later stage
287:20 - let's include an appropriate using
287:21 - directive at the top of our code to
287:24 - reference the
287:26 - syncfusion.blazer.charts namespace
287:28 - let's create a div container element
287:30 - where our sync fusion chart will reside
287:37 - let's override the uninitialized async
287:40 - blazer lifecycle event handler method
287:48 - let's create a list property that stores
287:50 - objects of type grouped field price
287:53 - model
287:54 - the grouped field price model type
287:56 - resides in the sales management
287:59 - app.models.report models namespace
288:02 - many of the types that we'll create
288:04 - within the sales management app dot
288:06 - models dot report models namespace will
288:10 - be used across other razor components so
288:12 - let's create an appropriate using
288:14 - directive that references the sales
288:16 - management app dot models dot report
288:19 - models namespace within the underscore
288:21 - imports.razer file
288:50 - let's write code so that an object of
288:52 - type i sales order report service is
288:55 - injected into our razor component at
288:57 - runtime
289:05 - let's appropriately call the get
289:07 - employee price per month data method on
289:10 - the sales order report service object
289:13 - and assign the returned data to the
289:15 - appropriate property let's register the
289:18 - i sales order report service type for
289:20 - dependency injection within the
289:22 - program.cs class
289:38 - let's create the code for our first
289:40 - syncfusion chart
289:52 - let's give the title property of the sf
289:54 - chart component a value of sales gross
289:57 - forward slash month let's include the
290:00 - chart primary x axis element within the
290:03 - sf chart element
290:08 - let's set its value type property to
290:11 - syncfusion.laser.charts.valuetype.category
290:15 - let's include the chart series
290:17 - collection element within the sf chart
290:19 - element
290:28 - let's include a chart series element
290:30 - within the chart series collection
290:32 - element
290:33 - we are about to set the data source
290:35 - property for the chart series element
290:38 - but before we proceed with this let's
290:40 - rename the property that stores the data
290:42 - source data to a more appropriate name
290:50 - right
290:51 - let's set the data source property of
290:53 - the chart series element to our grouped
290:56 - field price data property
290:59 - let's set the xname property to the
291:02 - grouped key field property name of the
291:05 - group fieldpricemodel type
291:09 - let's set the yname property to the
291:11 - price property name of the grouped field
291:14 - price model type
291:23 - lastly let's set the type of our chart
291:25 - to bar chart
291:27 - we can do this by setting the relevant
291:29 - type property like this
291:38 - let's run our code
291:49 - and that is what i would expect seeing
291:52 - as we don't yet have any data in the
291:54 - sales order report database table
291:58 - so we are now able to insert data into
292:00 - the sales order reports database table
292:03 - through our application so let's do that
292:05 - let's click the products nav menu link
292:08 - and let's use our ordering facility to
292:11 - place an order
292:26 - great
292:27 - and let's now invoke the charts razor
292:29 - component
292:32 - and the relevant data is now displayed
292:35 - on our bar chart
292:37 - we don't have a lot of data yet so our
292:39 - chart is not displaying a lot of
292:41 - information
292:43 - let's create a few more orders to
292:45 - generate more report related data in our
292:48 - database
293:20 - to make our data more interesting let's
293:22 - go into sql server management studio and
293:25 - modify our order data so that our data
293:28 - reflects that some of the orders were
293:30 - made in different months of the current
293:33 - year
294:41 - great and our bar chart looks a lot more
294:44 - interesting now
294:58 - great so we have created our first chart
295:00 - which is a bar chart
295:02 - let's create a donut chart i love these
295:05 - charts but in particular i love doughnut
295:08 - charts
295:09 - let's first create a model in our report
295:11 - models folder
295:13 - let's name this model grouped field qty
295:16 - model
295:41 - let's create a new method definition
295:43 - within our i sales order report service
295:46 - interface named get qty per product
295:49 - category that will be responsible for
295:51 - returning data reflecting the quantity
295:54 - sold by an employee for each product
295:57 - category
296:01 - let's implement the code logic for the
296:03 - get qt wiper product category method
296:44 - as you can see we are grouping the data
296:47 - by product category here in our link
296:49 - query
296:52 - we should include a where clause that
296:53 - filters the query by the employee id of
296:57 - 9 benjamin lucas's id
297:00 - but these sort of specifics don't matter
297:02 - at the moment because everything
297:04 - currently has been done by benjamin
297:07 - lucas
297:08 - as we have hard-coded this id for the
297:10 - order capture functionality
297:14 - so we are assuming benjamin lucas has
297:17 - logged onto the system and is viewing
297:19 - data pertaining to his sales
297:30 - let's go to our charts.razer file
297:39 - let's create a property that will be the
297:41 - data source for our donut chart
298:02 - let's use our sales order service object
298:05 - to return the data for our donut chart
298:08 - from the database to our razor component
298:17 - so let's create the code for our donut
298:19 - chart
298:29 - so in order to do this let's include
298:32 - syncfusion's sf accumulation chart
298:34 - element in our code like this
299:40 - as you can see the code is very
299:41 - straightforward we include the
299:43 - appropriate elements declaratively in
299:45 - our code
299:46 - with the appropriate settings regarding
299:48 - how we want our donut chart to look
299:59 - let's set the data source property to
300:01 - our grouped field qty data property
300:10 - we can then declaratively set the
300:12 - dimension for our analytical data
300:16 - we must set the xname property of the
300:19 - accumulation chart series element to the
300:22 - grouped field key property of our
300:24 - grouped field qty model type
300:27 - we must set the y name property to the
300:30 - qty property
301:33 - we are able to customize our chart
301:35 - through various settings
301:37 - please view the comprehensive
301:38 - documentation provided by syncfusion for
301:41 - more detail on the chart components we
301:44 - are just scraping this surface here you
301:46 - are able to customize your charts in
301:48 - various ways the functionality in the
301:50 - sync fusion charts is very sophisticated
301:53 - and as you can see syncfusion has made
301:56 - it very easy for developers to leverage
301:59 - the sophistication of the charts through
302:01 - the implementation of simple declarative
302:04 - code
302:17 - let's run the code and see what our
302:19 - donut chart looks like
302:35 - excellent and we can at a glance see how
302:39 - many products
302:40 - benjamin lucas has sold for each product
302:42 - category great
302:50 - let's create another type of chart a
302:52 - line chart
302:53 - so let's first create the functionality
302:55 - to retrieve the data for our line chart
302:59 - let's create a definition for a method
303:01 - named get qty per month data
303:04 - which will be responsible for retrieving
303:06 - data representing the quantity of
303:08 - products ordered through benjamin lucas
303:11 - and the data is broken down by months of
303:13 - the current year
303:15 - we can reuse our grouped field qty model
303:18 - type for the objects in the list
303:20 - returned by this method
303:22 - let's implement the logic for our new
303:24 - method
304:00 - so the code structure for our new method
304:02 - is very similar to the code structure
304:05 - for the get employee price per month
304:07 - method so let's start by copying the
304:10 - code in the get employee price per month
304:12 - method and pasting it into our new
304:15 - method
304:59 - so we are grouping the data by month
305:02 - and summing up the quantity of sales
305:04 - made for each month
305:06 - this analytical data applies to the
305:08 - sales rep benjamin lucas so we are
305:10 - filtering the data by his employee id of
305:14 - nine
305:15 - let's go to the charts razor component
305:18 - and wire up the line chart with the data
305:21 - retrieved using the sales order service
305:23 - object
305:39 - let's rename the data source for our
305:41 - donut chart to a name that is more
305:44 - descriptive
306:08 - and let's name the property that will
306:10 - store the data for the line charts data
306:13 - source
306:15 - qty per month data
306:19 - let's also change the name of the
306:21 - property that stores the data
306:23 - for the data source of the bar chart to
306:25 - a name that is more descriptive
306:47 - okay so let's write the code that
306:50 - retrieves the data for the line chart
306:53 - and assign it to our new property qty
306:56 - per month data
308:04 - so the code for our line chart is very
308:07 - similar to the code for our bar chart
308:09 - the first chart we created note however
308:12 - that we are setting the type property in
308:14 - the chart series element to chart series
308:17 - type dot line
308:38 - to make our data more interesting let's
308:41 - place a few more orders
309:26 - let's go into sql server management
309:28 - studio and alter the months of the order
309:32 - date time field
309:33 - for some of our captured data
309:36 - so we have a better spread of our data
309:38 - as it were across more months
310:31 - let's look at our charts
310:38 - and that data looks a lot more
310:40 - interesting let's look at our line chart
310:45 - excellent our line chart looks great
310:48 - you can see the quantity of sales made
310:50 - by benjamin lucas broken down by the
310:52 - months of the current year excellent
310:59 - so these charts look great but our
311:01 - layout for the charts could use some
311:03 - attention
311:05 - let's build our first dashboard for the
311:07 - sales reps where these charts will be
311:09 - presented in a great looking layout
311:11 - appropriate for a dashboard we are going
311:14 - to use syncfusion's sf dashboard layout
311:17 - component to implement the layouts for
311:19 - our dashboards
311:21 - let's create a razor component named sr
311:24 - dashboard the sr stands for sales rep
311:44 - let's create an appropriate route
311:46 - directive at the top of the razor file
311:49 - using the at page directive
311:54 - let's include an appropriate link within
311:56 - the nav menu razer component
312:47 - if we navigate to this syncfusion web
312:49 - page
312:50 - that can be found at this location a
312:52 - link to this location has been included
312:54 - below in the description
312:56 - we have the source code for a layout
312:58 - that would be appropriate for our
313:00 - requirement
313:05 - so if we click the source tab here
313:14 - let's copy this code
313:37 - and paste it into our sr dashboard razer
313:39 - file
313:53 - we don't have a sample base component
313:55 - class
313:56 - and we don't need this inherits sample
313:59 - base component line of code here so
314:02 - let's remove it
314:03 - for our requirement we don't need the
314:05 - using theme helper line of code either
314:08 - so let's remove it
314:11 - and you can see that we need to install
314:13 - syncfusion's sf dashboard layout
314:15 - component
314:27 - so let's invoke the new get package
314:30 - manager window from within visual studio
314:38 - let's search for
314:39 - syncfusion.blazer.layouts
314:46 - and this is the package that we want to
314:48 - install let's install version 20.1.0.58
315:23 - let's run the code
315:39 - great
315:40 - so these are obviously not our charts
315:43 - but are the ones that are provided in
315:44 - the syncfusion demo documentation so the
315:47 - next step is to replace the charts
315:49 - currently displayed within the sr
315:52 - dashboard razer component with our
315:54 - charts
315:56 - so let's appropriately copy the chart
315:58 - related code from our charts razer
316:00 - component
316:01 - over to the sr dashboard razer component
316:08 - let's first override the uninitialized
316:10 - async method and copy and paste the code
316:13 - for retrieving the relevant data from
316:15 - our database ie of relevance to the
316:18 - sales reps analytical data
317:39 - right so let's appropriately replace
317:42 - the code for the charts with our charts
317:45 - code
317:50 - let's start with the bar chart
319:01 - okay so we have a few chart references
319:03 - in the sample code here
319:05 - let's include a reference to chart 1
319:07 - within our bar chart component to fix
319:10 - this issue
319:24 - great
319:27 - let's modify the heading in our layout
319:30 - pertaining to the bar chart to something
319:32 - more appropriate
320:03 - let's copy and appropriately paste the
320:05 - code for the donut chart into our sr
320:08 - dashboard razor file
320:42 - great
321:06 - and lastly the line chart
322:06 - let's include a reference within our
322:08 - line chart to chart two
322:10 - as the sample code that we have copied
322:13 - from the syncfusion demo documentation
322:15 - uses a reference to chart 2 in code
322:32 - excellent
322:34 - if you have missed a step during this
322:36 - section of the course
322:38 - and something isn't working as expected
322:40 - please refer to the code in the relevant
322:42 - github repository
322:44 - and look at how easy it has been to
322:46 - generate a sophisticated dashboard using
322:48 - the appropriate sync fusion components
322:52 - and we can now watch our charts change
322:54 - appropriately as we place more orders
322:56 - through the system
323:34 - excellent
323:36 - and let's remove the data related code
323:38 - that is not relevant to our
323:39 - functionality that we copied from the
323:42 - syncfusion documentation
323:44 - we are now of course using the data from
323:46 - our database for our charts
324:33 - we have effectively created the
324:35 - dashboard functionality for our sales
324:37 - reps and we can now delete the
324:39 - chartsrazer component from our project
325:04 - great
325:10 - so we have removed the chart.razer
325:13 - component
325:14 - note that offline i have changed the
325:17 - employee management link label to admin
325:31 - so we have just created a dashboard for
325:33 - our sales reps let's create a dashboard
325:35 - for team leaders
325:37 - all of our dashboards will have the same
325:39 - layout but of course the charts will be
325:41 - different depending on whether the
325:43 - logged on user is a sales rep team
325:45 - leader or sales manager
325:47 - so each employee will only see one
325:50 - dashboard when the employee logs on to
325:53 - the system
325:54 - when a sales rep logs onto the system
325:56 - the sales rep will see a link presented
325:58 - within the main menu of the sales
326:01 - management application
326:03 - that points to the sr dashboard
326:05 - component when a team leader logs on to
326:07 - the system they'll see one dashboard
326:09 - link in the main menu but when their
326:12 - dashboard link is clicked the tl
326:14 - dashboard razer component will be
326:16 - invoked
326:17 - we are going to create the code for the
326:19 - tl dashboard raiser components in this
326:22 - section of the course
326:24 - we'll then create the sm dashboard which
326:27 - will only be made available to the sales
326:29 - manager
326:30 - so let's first create the data retrieval
326:32 - functionality for the reports relevant
326:35 - to team leaders
326:36 - let's open the i sales order reports
326:39 - interface and create a definition for a
326:41 - method named get gross sales per team
326:44 - member data which will be responsible
326:46 - for returning data containing the gross
326:48 - sales value for each team member
326:51 - the data retrieved by the relevant
326:53 - method will be displayed on a bar chart
326:56 - let's implement the code logic for this
326:58 - method definition
327:15 - so i'm just going to move this method to
327:17 - the bottom here
327:19 - so as to separate the team leader
327:20 - related data retrieval functionality
327:23 - from the sales rep data retrieval
327:25 - functionality
328:02 - so the reports pertaining to team
328:04 - leaders will relate to data related to
328:06 - their team members so let's firstly
328:09 - create a private method that returns a
328:11 - collection of employee ids pertaining to
328:14 - each team member that is a member of the
328:17 - logged on team leaders team
328:19 - let's name our method get team member
328:21 - ids
328:52 - and this link query simply returns a
328:55 - list of relevant employee ids to the
328:57 - calling code
329:11 - so let's call our get team member ids
329:14 - method from within our get gross sales
329:16 - per team member data method
329:43 - then we can filter the data so that the
329:46 - data is only relevant to the logged on
329:49 - team leaders team members in the where
329:51 - clause of our link query for now we are
329:54 - hard-coding the team leader's id to 3
329:57 - which pertains to the employee henry
330:00 - andrews so for now data will only
330:03 - pertain to the team members that belong
330:05 - to henry's team
330:08 - note that benjamin lucas is part of
330:10 - henry's team so when we create orders
330:13 - under benjamin lucas
330:15 - henry andrews will as it were be able to
330:18 - see the relevant changes to his
330:20 - analytical data
330:22 - let's group the team members by their
330:24 - first names
330:26 - i know that this is not ideal because
330:28 - you may have special cases where two or
330:31 - more team members have the same first
330:33 - name
330:34 - for the sake of the example we are going
330:36 - to assume that team members have unique
330:38 - first names
331:38 - let's go back to our i sales order
331:41 - reports interface and create a
331:43 - definition for a method named get qty
331:46 - per team member data responsible for
331:49 - returning the quantity of sales for each
331:51 - team member the data relevant to this
331:53 - method will be displayed on a donut
331:56 - chart
332:00 - let's implement the code logic for this
332:02 - method
332:46 - in the interests of clarity i'm going to
332:48 - copy the code for our new method just
332:51 - below the other team leader related
332:53 - method
333:00 - the code for this method is similar in
333:01 - structure to the previous method we
333:03 - wrote so let's copy the code from the
333:05 - previous method that we wrote related to
333:08 - team leader analytical data and paste it
333:11 - into our new method
333:14 - and then let's change the bits that are
333:16 - different
333:18 - the aggregated data in this case is
333:21 - based on the sales quantity rather than
333:23 - gross sales value the summed up quantity
333:26 - value is of type integer
333:28 - and not decimal
333:30 - so we can remove the code here where we
333:33 - are rounding off the relevant value to
333:35 - two decimal places
333:50 - lastly let's create a definition for a
333:52 - method named get team qty per month data
333:55 - this method will be responsible for
333:57 - retrieving the quantity of sales
333:59 - pertaining to the team itself overall
334:03 - and the data will be broken down by the
334:05 - months of the current year
334:07 - the data for this will be displayed on a
334:09 - line chart
334:42 - let's implement the logic for the get
334:45 - team qty per month data method
335:46 - let's create a razor component named tl
335:49 - dashboard
336:45 - we are going to use the same layout for
336:47 - all three of our dashboard razer
336:49 - components
336:50 - so let's start by copying the relevant
336:52 - code from the sr dashboard component and
336:56 - pasting it into our tl dashboard razor
336:58 - component like this
337:18 - then let's change the code so that the
337:20 - data for the team leader related reports
337:22 - data is retrieved using the sales order
337:24 - report service object
338:15 - the first two charts the bar chart and
338:18 - the donut chart are very similar to the
338:20 - first two charts that we created in the
338:23 - sr dashboard razor component so let's
338:25 - adapt the existing code for these charts
338:28 - for the data pertaining to a dashboard
338:31 - appropriate for team leaders like this
338:34 - for now let's focus on the two charts
338:37 - and we'll implement the code for the
338:39 - line chart the third chart in a bit
339:23 - so before we run the code
339:25 - so as to look at the bar chart in the
339:27 - donut chart for team leaders
339:30 - let's delete the line chart we'll deal
339:32 - with the line chart appropriately in a
339:34 - bit
339:35 - right let's run the code
339:51 - the last chart had a at ref attribute
339:54 - pointing to chart two so let's remove
339:57 - the reference to chart two from our code
339:59 - for now
340:03 - let's run the
340:12 - code great the charts are displaying
340:15 - data for only one sales rep at the
340:18 - moment because the data is reflecting
340:20 - the fact that only benjamin lucas has
340:22 - created orders in the system for the
340:25 - team leader henry andrews
340:28 - let's modify the data a bit within sql
340:30 - server management studio to reflect that
340:33 - other members of the team
340:35 - led by henry andrews have also created
340:37 - orders in the system
340:39 - so to do this let's go to sql server
340:42 - management studio and modify the data in
340:45 - the sales order reports database table
340:47 - accordingly
340:49 - if we look at the employees we can see
340:51 - that olivia mills
340:53 - benjamin lucas sarah henderson and noah
340:56 - robinson are members of the team led by
340:59 - henry andrews
341:00 - the report's two empire d field contains
341:03 - the value of three for these employees
341:06 - which is the id value pertaining to the
341:09 - employee record for henry andrews
341:12 - so let's open the sales order reports
341:14 - database table within sql server
341:16 - management studio and update the data so
341:19 - that it looks like the other team
341:21 - members have also created orders within
341:23 - the system
343:09 - great
343:19 - let's implement the code for the line
343:21 - chart here like this
343:23 - this is essentially the same code
343:25 - implemented for the line chart in the sr
343:28 - dashboard file the only difference is we
343:31 - need to change the data source property
343:34 - to point to the relevant team related
343:36 - data
343:37 - so let's change the data source property
343:40 - appropriately for the line chart
344:14 - let's run the code
344:33 - excellent
344:36 - let's create an order through our
344:38 - application and see how this affects our
344:41 - charts
345:08 - excellent
345:18 - let's create the data retrieval
345:19 - functionality for our sm dashboard razor
345:22 - component
345:23 - so we are creating the dashboard
345:25 - functionality for the sales manager so
345:28 - the bar chart and the line chart are
345:30 - going to be more complex for the sales
345:32 - managers dashboard we are adding another
345:35 - dimension to the data
345:36 - this means we need to create appropriate
345:38 - new model classes for the sales manager
345:41 - reporting functionality
345:43 - so let's create a model within the
345:44 - report models folder named location
345:47 - product category model
345:49 - so we are going to group by location and
345:52 - pivot the data
345:53 - so that the quantity of sales can be
345:55 - reflected
345:56 - on our bar chart for each product
345:58 - category
346:00 - so to do this we first include the
346:02 - column by which
346:04 - we are going to group the data
346:10 - then we can include columns denoted by
346:12 - properties for each of the product
346:15 - categories in our system
346:17 - so mountain bikes road bikes
346:20 - camping hiking and boots
346:24 - let's create a model named month
346:25 - location model
346:43 - so with this model we are shaping the
346:45 - data where the relevant collection of
346:47 - data is grouped by month of the date
346:50 - when the relevant orders were made
346:52 - and as it were pivoting
346:54 - on the location of where the orders were
346:56 - made
347:01 - let's open the i sales order reports
347:04 - interface and create the relevant method
347:06 - definitions
347:11 - let's create a definition for a method
347:13 - named get qty location product cat data
347:18 - this method will be responsible for
347:19 - retrieving the summed up sales order
347:22 - quantities by location and product
347:25 - category a bar chart will be used to
347:28 - display this data
347:30 - let's create a definition for a method
347:32 - named get qty per location data this
347:35 - method will be responsible for
347:37 - retrieving quantity of sales data
347:39 - grouped by location a donut chart will
347:41 - be used to display this data
347:44 - let's create a definition for a method
347:46 - named get qty per month location data
347:49 - this method will be responsible for
347:51 - retrieving quantity of sales data
347:53 - grouped by month and location great
347:56 - let's implement the logic for each of
347:58 - these methods
353:54 - great
353:56 - let's create a razor component named sm
353:59 - dashboard
354:46 - let's start by copying the relevant code
354:49 - from the tl dashboard component
355:00 - and pasting the code into our sm
355:02 - dashboard component like this
355:05 - let's remove the current chart related
355:07 - code from our sm dashboard.razer file
355:32 - let's appropriately update the data
355:34 - retrieval related code so that the
355:37 - appropriate data is retrieved for our sm
355:39 - dashboard component
356:31 - so you can access the code for the sm
356:33 - dashboard razer file on github at this
356:36 - location
356:38 - we are going to add the code for each
356:40 - chart one at a time
356:43 - so we can copy the relevant chart code
356:45 - from this github web page and paste it
356:48 - into the sm
356:50 - dashboard.razer file when appropriate
356:54 - let's start with the bar chart
357:12 - so let's paste what we have copied from
357:14 - the relevant github web page here
357:19 - please feel free to copy the code from
357:21 - the relevant github web page a link to
357:23 - the webpage has been included below in
357:26 - the description
357:28 - let's include a width property for our
357:31 - bar chart
357:59 - you can see here that each chart series
358:01 - for our first chart pertains to a
358:04 - product category
358:07 - so for each chart series element we are
358:10 - setting the xname property to location
358:13 - this is the property on which our code
358:16 - is being grouped the y name property is
358:19 - set to the relevant product category
358:22 - so we are declaratively telling the
358:24 - fusion chart component as it were about
358:27 - the dimensions of our analytical data
358:42 - we can adjust the maximum property
358:45 - so that it suits the sales quantity
358:47 - values that we currently have saved to
358:50 - our system
358:51 - we could bind this property to a
358:54 - calculated value so that the chart
358:56 - adjusts appropriately in response to
358:59 - greater quantities of sales saved to the
359:01 - system then we are also able to set the
359:04 - interval for the y-axis here
359:08 - again this property could be set to a
359:10 - property value that is calculated on the
359:13 - fly so that the chart automatically
359:15 - adapts appropriately in response to the
359:18 - values saved to the database
359:33 - i've appropriately altered the data
359:35 - through ssms a bit offline
359:38 - don't be afraid to play around with the
359:40 - data in the sales order report table to
359:43 - see how the data affects the charts
359:51 - the code for the donut chart is fairly
359:53 - basic
360:05 - the code for the donut chart is
360:06 - structurally the same as the other donut
360:09 - charts that we have implemented in this
360:11 - course
360:27 - great
360:45 - so i'm just going to paste the code in
360:47 - here for the line chart
360:48 - please feel free to copy the code from
360:50 - the relevant github webpage for the
360:53 - implementation of the line chart
361:37 - and look at that that is excellent
361:48 - let's alter the data a little bit so
361:50 - that the relevant order data pertains to
361:52 - more months of the year
362:17 - excellent
362:32 - please consult the sync fusion
362:34 - documentation for more details about the
362:37 - charts we are only scraping the surface
362:40 - here these charts are fantastic and can
362:42 - be customized in many ways to suit your
362:45 - requirements
362:46 - syncfusion has provided excellent
362:48 - comprehensive documentation on how to
362:50 - customize the charts there are also many
362:53 - other types of charts that can be used
362:55 - in your applications so please dive into
362:57 - the syncfusion documentation i think
362:59 - you'll be amazed as i am as to what can
363:02 - be accomplished using the syncfusion
363:04 - chart components
363:08 - and you can see that the syncfusion
363:10 - layout component and the chart
363:12 - components are fully responsive on
363:14 - smaller screens
363:36 - excellent
363:58 - in this section of the course
364:00 - we are going to integrate syncfusion's
364:02 - diagram component into our application
364:06 - through the syncfusion diagram component
364:08 - we are going to implement functionality
364:10 - so that the sales manager is able to see
364:14 - the hierarchical structure of the sales
364:16 - department each node in the diagram
364:19 - contains a profile picture of the
364:21 - employee as well as basic information
364:24 - about the employee
364:27 - to create this functionality we'll
364:29 - integrate the syncfusion diagram
364:31 - component into a razor component
364:34 - the sales manager will be able to invoke
364:37 - the relevant razer component
364:39 - from the main menu of the application
364:42 - and at a glance see basic information
364:45 - about each employee and the employee's
364:48 - position within the organization
364:51 - the sales manager has admin privileges
364:54 - so is able to access the employee
364:57 - management component
364:59 - and can use the syncfusion data grid to
365:02 - change employee details so the sales
365:05 - manager can use the data grid to shuffle
365:08 - around team members for example change
365:11 - who a particular sales rep reports to ie
365:15 - change the team members team leader
365:18 - the sales manager can then invoke the
365:20 - razer component containing the sync
365:22 - fusion diagram that displays the
365:25 - organizational structure and the change
365:27 - made to the organizational structure
365:30 - using the data grid will be reflected in
365:32 - the diagram component
365:34 - so let's start by creating a model named
365:38 - organization model within the models
365:40 - folder
365:58 - this model supports data for relevant
366:01 - employee details
366:03 - and provides a way for each object in a
366:06 - list of objects derived from this class
366:09 - to appropriately reference other objects
366:12 - of the same type
366:13 - in a way that a list of objects of this
366:16 - type
366:16 - can represent a hierarchical structure
366:20 - for example the reports2id property will
366:23 - either store an empty string or an
366:26 - employee id
366:28 - if the reports2id property stores an
366:31 - empty string this means that the
366:33 - employee that the relevant object
366:35 - represents is the head of the
366:37 - organization and doesn't report to
366:39 - anyone
366:41 - when the reports to id property for an
366:44 - object stores an employee id
366:46 - this means that the relevant employee
366:48 - that this object represents reports to
366:51 - the employee whose employee id is
366:54 - referenced by the reports to property of
366:57 - the relevant object so in this way each
367:00 - object of type organization model stored
367:03 - in a list of objects of this type can be
367:06 - appropriately related to one another to
367:08 - form a hierarchical structure
367:11 - in a bit you'll see how we are able to
367:13 - wire up a list containing appropriate
367:16 - objects of the organization model type
367:19 - to the sync fusion diagram component and
367:22 - the syncfusion diagram component does
367:25 - all the heavy lifting as it were to
367:27 - display an aesthetically pleasing
367:29 - hierarchical structure containing all
367:32 - the employees of the organization to the
367:35 - screen let's create an interface in the
367:37 - contracts folder named i organization
367:40 - service
368:07 - let's create a definition for a method
368:08 - named get hierarchy that will be
368:11 - responsible for retrieving data
368:13 - representing the employee hierarchy for
368:16 - the sales department ie will return a
368:20 - list of objects of type organization
368:22 - model
368:23 - let's implement the code for the get
368:25 - hierarchy method
369:26 - let's first write an appropriate convert
369:28 - extension method within the conversions
369:30 - class
370:14 - so to be explicit i'm going to name our
370:16 - extension method convert to hierarchy
371:07 - this extension method simply converts
371:09 - data retrieved from the employees
371:11 - database table
371:13 - which is appropriately joined with
371:15 - records retrieved from the employee job
371:17 - titles table to a list of objects of
371:20 - type organization model
371:37 - then the implementation for the get
371:38 - hierarchy method is this simple code
371:41 - here
371:59 - let's create a new razor component named
372:02 - organization
372:13 - let's provide the appropriate routing
372:15 - information at the top of the razer file
372:18 - and an appropriate link within the nav
372:20 - menu.razer file
372:38 - so let's navigate to this webpage
372:40 - in the syncfusion documentation
372:52 - here we have the organizational tree
372:54 - structure that we want to implement
372:56 - within our application
372:58 - so let's go to the source code for this
373:00 - demonstration and let's copy the
373:02 - relevant code to our clipboards
373:17 - let's appropriately paste the code
373:19 - copied to our clipboards into our
373:22 - organization.razer file
373:32 - so we can see lots of squiggly lines
373:35 - this is because we haven't yet installed
373:37 - the syncfusion.blazer.diagram
373:40 - nuget package so let's do that
374:05 - let's install version 20.0.1.58
374:09 - so as to be consistent with the versions
374:11 - of the sync fusion components that we
374:13 - have currently installed
374:15 - excellent
374:25 - let's write code so that an object of
374:28 - type i organization service
374:30 - is injected into our razor component at
374:33 - runtime
374:34 - let's make sure that we register the
374:36 - relevant eye organization service type
374:39 - for dependency injection
374:56 - let's write code to override the
374:57 - uninitialized async blazer lifecycle
375:00 - event handler method
375:04 - let's create a property for storing the
375:06 - data retrieved from our database that
375:08 - represents the organizational structure
375:11 - for the sales department
375:19 - then let's write code within the
375:20 - uninitialized async method
375:23 - using our organization service object to
375:26 - retrieve the relevant data from our
375:27 - database
375:35 - and now let's wire up the data source
375:37 - property appropriately in the data
375:40 - source settings element to the
375:42 - organization data property that stores a
375:44 - list of organization model objects
375:47 - retrieved from our database
375:59 - let's let the sf diagram component
376:02 - component know as it were
376:04 - which property in the data source
376:06 - contains the id value and which property
376:09 - in the data source contains the parent
376:12 - id value the parent id represents the id
376:15 - of the employee that the relevant
376:17 - employee reports to
376:19 - the id of the relevant employee in the
376:22 - data source is set to the employee id
376:25 - property
376:27 - so this is how the syncfusion diagram
376:29 - knows as it were about the parent-child
376:32 - relationship that represents the
376:34 - employees in the organizational
376:36 - structure which is of course essential
376:39 - information for displaying the relevant
376:41 - data structure as a hierarchical
376:43 - structure
376:44 - the next step is to define what
376:46 - information about the employee will be
376:49 - presented in each node on the
376:51 - hierarchical tree structure
376:54 - so within the node template element
376:56 - let's include the following information
376:59 - the employee's first name the employee's
377:01 - id
377:02 - the employee's job title
377:05 - we want each node to contain the
377:07 - employee's profile image
377:20 - we don't have a sample based component
377:22 - base class so let's remove this line of
377:24 - code at inherits sample base component
377:29 - then let's remove the code within the
377:30 - node template element
377:32 - that we brought over from the demo code
377:35 - provided in the syncfusion documentation
377:38 - that is not relevant to our requirement
377:40 - like this
378:29 - let's run the code
378:38 - that is awesome
378:40 - we are able to navigate around the
378:42 - diagram that represents our
378:43 - organizational structure
378:45 - and view the individual nodes more
378:47 - closely
378:48 - we can use the control plus and control
378:51 - minus keys to zoom in and out
378:54 - so that we can get a broader view of the
378:56 - organizational diagram or zoom in for a
378:59 - closer view of for example the
379:01 - individual nodes i.e the information of
379:04 - the individual employees within the
379:06 - organizational structure
379:08 - excellent
379:13 - we don't necessarily need to display the
379:15 - tree from top to bottom like this
379:18 - we are able to configure our sf diagram
379:20 - component component to display from left
379:24 - to right by adjusting the relevant
379:26 - setting like this
380:09 - and we can go over to the employee
380:11 - management razor component and pretend
380:14 - we're the sales manager and use the sync
380:16 - fusion data grid to change the
380:19 - hierarchical structure of our
380:20 - organization
380:40 - excellent
380:41 - let's clean up our code and remove the
380:44 - data related code that we brought over
380:46 - from the demo source
380:48 - code we are now using our own data
380:52 - within the organizational tree structure
380:54 - that is displayed through the sync
380:57 - fusion diagram component excellent
381:00 - we have been able to harness the
381:02 - sophisticated functionality provided by
381:05 - the syncfusion diagram component easily
381:08 - and efficiently
381:09 - all we needed to do was wire up an
381:11 - appropriate data structure as the data
381:13 - source to the syncfusion diagram
381:16 - component
381:17 - let the syncfusion diagram component
381:19 - know as it were about the specifics of
381:21 - the parent-child relationship in our
381:23 - data structure and customize the nodes
381:26 - presented by the diagram component to
381:29 - the ui
381:30 - we are just scraping the surface of what
381:32 - can be achieved using the syncfusion
381:34 - diagram component please check out the
381:36 - comprehensive documentation provided by
381:39 - syncfusion to further explore what can
381:42 - be achieved
382:30 - so let's say we want to integrate
382:31 - functionality for the employees of the
382:34 - sales department so that they can for
382:36 - example schedule appointments with other
382:39 - employees or for example schedule client
382:42 - meetings
382:43 - to implement this functionality we are
382:45 - going to integrate syncfusion's
382:47 - scheduler component into our application
382:50 - let's start by creating a razor
382:52 - component named appointments
383:07 - let's install the syncfusion scheduler
383:09 - component
383:10 - so to do this let's install the
383:12 - syncfusion.blazer.schedule
383:15 - nuget package
383:31 - let's install version 20.1.0.58
383:36 - so that it is consistent with the
383:38 - versions of the other nuget packages
383:40 - that we have installed
383:41 - great
383:44 - let's navigate to this url in our
383:46 - browsers
383:53 - here you can see we have demo source
383:55 - code provided by syncfusion that
383:57 - demonstrates some of the core
383:59 - functionality that we can leverage using
384:02 - the syncfusion scheduler component
384:04 - let's go to the source code of the demo
384:07 - and copy the relevant code like this
384:09 - into our clipboards
384:15 - let's paste the code copied to our
384:17 - clipboard appropriately into our
384:20 - appointments.razer file let's open the
384:22 - navmenu.razer file and include an
384:25 - appropriate link to our appointments
384:27 - razor component
384:47 - and when we run our code and navigate to
384:49 - our appointments razor component we can
384:52 - see that right out of the box we have
384:54 - sophisticated functionality already
384:56 - operational
385:00 - we are already able to add appointments
385:02 - to our scheduler at a date and time of
385:04 - our choosing
385:12 - we can of course edit and delete the
385:14 - appointments too
385:40 - let's modify the current date for our
385:42 - scheduler to today's date
386:21 - so you are able to add an appointment to
386:23 - the scheduler by invoking the most basic
386:26 - dialog by clicking an appropriate cell
386:29 - representing a date and time i.e a date
386:32 - and time at which you wish to schedule
386:34 - an appointment you are able to
386:36 - double-click a cell to invoke a dialog
386:39 - where you are able to enter more
386:40 - detailed information about the relevant
386:43 - appointment
386:44 - you are able to easily change the view
386:46 - of the scheduler for example you may
386:48 - wish to see all your appointments for
386:50 - the week you may wish to view your
386:52 - appointments in an agenda format
386:55 - you may wish to view only appointments
386:57 - for the work week monday to friday or
386:59 - for the month
387:02 - so right out of the box we can harness
387:04 - some very useful functionality
387:07 - at the moment however
387:09 - we are only able to save our
387:11 - appointments
387:12 - to the scheduler component where the
387:14 - data only exists in memory
387:29 - we need a way that we can save our
387:31 - appointments to our database
387:34 - through the functionality provided to us
387:36 - by the syncfusion scheduler component
387:39 - we are able to apply our own custom code
387:42 - that will execute when certain events
387:44 - are fired based on user actions
387:46 - performed by the user using the
387:48 - syncfusion scheduler component
387:50 - so we can for example implement code
387:52 - that handles crud operations
387:56 - so for when a user performs certain crud
387:59 - operations
388:01 - our code can hook into certain events as
388:03 - it were triggered by user actions and
388:06 - ensure that our custom code runs when
388:08 - these events are triggered
388:11 - in this way we are able to persist any
388:14 - changes made regarding appointments on
388:16 - the user's scheduler component
388:18 - appropriately to our database
388:22 - so to do this let's start by creating an
388:24 - appropriate table within our database we
388:27 - are of course going to use codefirst
388:29 - migrations to achieve this
388:31 - so let's start by creating an
388:33 - appropriate c-sharp class within the
388:35 - entities folder
388:36 - let's create a class named appointment
388:48 - let's create the relevant properties for
388:51 - our appointment class
388:53 - these properties are appropriately
388:55 - included for our appointment database
388:57 - table based on the structure that is
388:59 - used by the syncfusion scheduler
389:01 - component to represent an appointment in
389:04 - the scheduler component
389:41 - so we want our code to be able to easily
389:43 - retrieve the data for an appointment
389:46 - created by the user through the
389:47 - scheduler and save the relevance data to
389:51 - our appointments database table
389:54 - note that some of these properties are
389:56 - nullable
389:57 - this is important because this gives the
389:59 - user the ability to fill in data for the
390:02 - relevant fields regarding a particular
390:04 - appointment
390:05 - and other fields that are not relevant
390:08 - to a particular appointment can be set
390:10 - to null
390:11 - let's include the appropriate db set
390:13 - property within our sales management db
390:16 - context class
390:36 - let's create a migration
391:05 - and let's run the update dash database
391:08 - command
391:40 - great
391:42 - let's create a class within the models
391:44 - folder named appointment model
391:59 - we can simply copy the properties from
392:01 - the appointment entity to our
392:03 - appointment model class
392:09 - let's create an interface named i
392:11 - appointment service
392:28 - let's create a definition for a method
392:29 - named get appointments responsible for
392:32 - retrieving all of the appointments for
392:35 - the logged on employee
392:43 - let's create a definition for a method
392:45 - named add appointment responsible for
392:48 - adding an appointment created using the
392:50 - scheduler component to the database for
392:53 - the logged on employee
392:58 - let's create a definition for a method
393:00 - named update appointment responsible for
393:03 - updating the data for an appointment
393:05 - modified using the scheduler component
393:07 - in the database for the logged on
393:09 - employee
393:11 - let's create a definition for a method
393:13 - named delete appointment responsible for
393:16 - removing the data for an appointment
393:19 - removed using the scheduler component
393:21 - from the database for the logged on
393:23 - employee
393:25 - let's implement the logic for a method
393:27 - definition in a class named appointment
393:29 - service
393:56 - let's include a constructor in the
393:57 - appointment service class and ensure
394:00 - that our constructor includes a
394:01 - parameter of type sales management db
394:04 - context
394:06 - so that an object of this type is
394:08 - injected into our constructor at runtime
394:11 - let's also create a private read-only
394:14 - member variable that references the
394:16 - injected sales management db context
394:19 - object
394:26 - oops we have a typo here let's remove
394:28 - the extra e from delete appointment
394:32 - first from our i appointment service
394:34 - interface and then from the appointment
394:36 - service class
394:41 - let's first implement code for the add
394:43 - appointment method
394:51 - firstly let's create a convert overload
394:53 - extension method within the conversions
394:55 - class that as it were converts an object
394:59 - of type appointment model to an object
395:01 - of type appointment
395:42 - then let's write code within the add
395:44 - appointment method to first convert an
395:47 - argument passed into this method of type
395:50 - appointment model to type appointment
396:06 - and then let's write code to add the
396:08 - converted object to the database through
396:11 - ef call functionality like this
396:20 - before we create the code for the get
396:22 - appointments method let's write a
396:24 - convert overload extension method that
396:26 - as it were transforms the list of
396:28 - objects of type appointment to a list of
396:31 - objects of type appointment model
398:17 - then the code that we need to implement
398:18 - for our get appointments method is
398:21 - simply this line of code
398:28 - then let's implement the following code
398:30 - for the update appointment method
399:38 - and the delete appointment method
400:35 - note that we have not yet implemented
400:37 - the login functionality for our
400:38 - application so for now let's hard code
400:41 - the employee id to nine
400:44 - which relates to the sales rep benjamin
400:46 - lucas to simulate that benjamin lucas is
400:49 - the current logged on user we need to
400:51 - update the convert extension method that
400:54 - converts as it were an object of type
400:56 - appointment model to an object of type
400:59 - appointment
401:00 - this will ensure that when an
401:02 - appointment is added to the system that
401:04 - at the moment the appointment will as it
401:06 - were be made by benjamin lucas
401:09 - we must also include a wear filter like
401:11 - this
401:12 - within the get appointments method to
401:14 - filter the retrieved appointments by the
401:17 - employee id of benjamin lucas
401:37 - let's open the appointments.raiser file
401:45 - let's write code to override the
401:46 - uninitialized async blazer lifecycle
401:49 - event handler method
401:51 - let's write code so that an object of
401:53 - type i appointment service is injected
401:56 - into our razor component at
402:02 - runtime let's make sure that we
402:05 - appropriately register the appointment
402:07 - service type for dependency injection
402:21 - let's create a property that will serve
402:23 - as the data source for our scheduler
402:25 - component
402:29 - let's write the code within our
402:30 - uninitialized async method to retrieve
402:33 - the relevant appointment data from our
402:35 - database
402:42 - let's appropriately set the data source
402:44 - property for our scheduler component
402:50 - let's set the t value property of the sf
402:53 - schedule element to tell the syncfusion
402:56 - scheduler component as it were about the
402:58 - type of objects stored in the relevant
403:01 - data source
403:03 - let's also update the t-value property
403:06 - of the schedule events element to the
403:08 - appointment model type
403:22 - let's remove some of the code that we
403:24 - don't need for our requirement
403:26 - and tidy up the code a little bit
404:24 - so now how do we hook into an
404:26 - appropriate event so that our
404:27 - crowd-related code fires
404:30 - when the relevant event is raised by the
404:32 - scheduler component
404:34 - this is actually very simple within the
404:36 - schedule events element we can set the
404:39 - on action begin property to an event
404:42 - handler method
404:43 - that we are going to create
404:45 - our method will of course contain the
404:47 - code that we want to execute when the
404:49 - relevant event is raised
404:52 - we can also write code that we want
404:55 - executed when our code within the method
404:57 - that handles the on action begin event
405:00 - has completed
405:02 - we can do this by setting the action
405:04 - completed property to an event handler
405:06 - method that we are going to write
405:09 - so let's first write the code for the
405:12 - method that handles the on action begin
405:14 - event
405:25 - firstly let's write an if statement to
405:27 - check what type of action has been
405:30 - executed by the user of the syncfusion
405:32 - scheduler component
405:34 - so if
405:35 - args.actiontype
405:37 - equals to the
405:39 - actiontype.eventcreateenum value
405:42 - we know that the user is adding an
405:44 - appointment
405:45 - so we are able to retrieve the
405:47 - appointment data entered by the user
405:49 - with this line of code
405:51 - and then we can add the relevant
405:52 - appointment data to the database using
405:55 - our appointment service object like this
406:00 - then let's create the code for the
406:02 - method to handle the event
406:04 - that is fired when the code within the
406:06 - on action begin async method completes
406:14 - so we only want code in this method to
406:16 - fire when the user creates an
406:18 - appointment
406:29 - let's set the at ref attribute to a
406:32 - property that we'll create
406:34 - so that we are able to reference the
406:36 - syncfusion scheduler component in our
406:38 - code using the relevant property
406:42 - let's create the relevant property
407:05 - then let's write code
407:07 - to retrieve all appointments for the
407:09 - logged on employee
407:11 - and let's also write code to refresh the
407:14 - scheduler component
407:28 - let's run the code
407:42 - and add an appointment firstly through
407:44 - the basic dialog
407:46 - we can launch this basic dialog by
407:48 - clicking on one of the cells
407:59 - let's check our database
408:05 - excellent
408:48 - so now let's write code so that when a
408:50 - user updates an appointment that the
408:53 - changes are saved to the database
408:56 - the code for this is really intuitive
409:15 - let's test the code
409:43 - excellent
410:27 - we are able to update any of the fields
410:29 - associated with an appointment and our
410:32 - changes are now saved to the database
410:43 - let's implement code so that we are able
410:45 - to delete an appointment from the
410:46 - database using the scheduler component
411:32 - excellent
411:33 - and you can see that we are now able to
411:35 - perform crud operations through our
411:38 - syncfusion scheduler component and any
411:40 - changes we make are persisted to our
411:42 - database
412:50 - so at this point we have written all the
412:53 - functionality for our application
412:55 - however for certain functionality we
412:58 - have hard-coded the logged on employee
413:00 - id to imitate a particular employee
413:04 - being logged onto the system
413:08 - we want certain functionality in our
413:09 - application to be available
413:12 - based on the context of who is logged
413:14 - onto the system
413:15 - we want certain razor components in our
413:17 - application to be available to certain
413:20 - employees when they are logged into the
413:22 - system conversely we want certain razor
413:25 - components to not be available to
413:27 - certain employees when they are logged
413:29 - into the system
413:30 - for example we only want an
413:32 - administrator to be able to access the
413:35 - data grid whereby an administrator can
413:38 - perform crowd operations on employee
413:40 - data
413:41 - the sales manager has been given
413:43 - administrative privileges in our system
413:46 - so the sales manager is therefore able
413:48 - to perform crowd operations on employee
413:50 - data through the use of the data grid
413:53 - component
413:54 - we only want sales reps to be able to
413:57 - create orders in the system on behalf of
413:59 - clients
414:00 - so only sales reps will be able to
414:03 - access the product catalog razer
414:05 - component
414:07 - we want a dashboard displayed to the
414:09 - logged on user
414:11 - based on the relevant user's position in
414:13 - the sales department i.e based on
414:15 - whether a user is a sales rep team
414:18 - leader or the sales manager for example
414:21 - we want sales reps to only see those
414:24 - charts in their dashboard that are of
414:26 - relevance to sales reps
414:29 - the diagram that displays the
414:31 - organizational hierarchy will only be
414:34 - available to the sales manager
414:38 - the scheduler is available to all
414:40 - employees
414:41 - but only the appointments added by the
414:43 - logged-on employee will be available to
414:46 - the logged-on employee
414:48 - so how can we achieve this contextual
414:51 - behavior for users logged on to our
414:54 - application
414:55 - the answer is through providing
414:57 - appropriate login functionality
415:00 - where our application can authenticate
415:02 - the user when the user logs onto the
415:05 - system and authorization can be granted
415:08 - for the logged on user to be able to
415:10 - access certain functionality in the
415:12 - application conversely the logged-on
415:15 - user may be unauthorized to access other
415:18 - parts of the application
415:20 - so to achieve this we are going to
415:23 - integrate microsoft identity
415:24 - functionality into our application
415:28 - very basically microsoft identity
415:31 - provides an infrastructure for
415:33 - registration and login functionality
415:36 - using the microsoft identity technology
415:39 - will make it easy to add login and
415:42 - registration functionality to our
415:44 - application and provide the
415:46 - authentication and authorization
415:49 - functionality
415:50 - that we have just discussed
415:52 - so at the point at which we created our
415:54 - blazer server project we could have
415:57 - chosen to integrate microsoft identity
416:00 - into our application
416:01 - we chose not to integrate microsoft
416:03 - identity into our application at that
416:05 - point but we are still able to integrate
416:08 - microsoft identity into our application
416:10 - even if we choose not to do so at the
416:13 - point of creating the initial project
416:15 - for our application
416:17 - in this section of the course that is
416:18 - exactly what we are going to do
416:20 - we are going to go through each step
416:23 - that needs to be performed in order to
416:25 - integrate microsoft identity into an
416:28 - already existing blazer server
416:30 - application that does not yet have the
416:32 - microsoft identity technology integrated
416:35 - for the performance of login
416:37 - registration authentication and
416:39 - authorization functionality
416:43 - let's go through this step by step
416:45 - so the first step
416:47 - is to make our sales management db
416:49 - context class inherit from the generic
416:53 - identitydbcontext class which accepts
416:56 - the identity user type as a type
416:58 - argument we are doing this because we
417:02 - are going to house the microsoft
417:04 - identity database tables within the same
417:06 - database as where the database tables of
417:09 - our application reside
417:11 - we could create an entirely new
417:13 - dbcontext class for our microsoft
417:15 - identity functionality but our
417:17 - application is self-contained and
417:19 - monolithic so in the interests of
417:21 - simplicity let's simply create the
417:23 - microsoft identity tables within the
417:25 - database we are already using for our
417:28 - application
417:29 - as you can see we have a red squiggly
417:31 - line here
417:33 - if we position our mouse pointers
417:35 - appropriately and press ctrl period
417:38 - we can see that we are missing the
417:40 - installation for an essential nuget
417:42 - package
417:44 - microsoft dot asp.net core dot identity
417:47 - dot entity framework core
417:50 - we can install the latest version of
417:51 - this nuget package at this point by
417:54 - clicking on the find and install latest
417:57 - version menu option presented to us
417:59 - through visual studio
418:01 - so let's do that
418:11 - and visual studio has done the
418:12 - appropriate installation
418:14 - and has also included the appropriate
418:16 - using directive to the relevant
418:19 - namespace at the top of our code
418:22 - microsoft.asp.net core
418:24 - dot identity dot entity framework core
418:27 - great
418:29 - the next step is to add the identity
418:32 - templates representing the functionality
418:34 - that we wish to integrate into our
418:36 - application for example login
418:38 - registration and logout functionality
418:42 - so to do this let's right click on the
418:44 - project node in our solution explorer
418:47 - window and select add new scaffolded
418:50 - item select identity on the left here
418:55 - click add
419:09 - you can see that we are presented with a
419:11 - variety of files that we can integrate
419:14 - into our application
419:16 - identity provides a suite of rich
419:17 - functionality but we are currently only
419:20 - interested in registration and login
419:22 - functionality
419:24 - so to include the appropriate identity
419:26 - features into our application
419:28 - let's check the check boxes next to
419:30 - account slash login accounts log out and
419:34 - account slash register
419:38 - the next step is to click the plus
419:40 - button next to data context class
419:45 - our application has a monolithic
419:47 - architecture
419:48 - it is a self-contained application so we
419:51 - are going to integrate the identity
419:52 - database tables into the same database
419:55 - as the database where our application
419:58 - database tables reside
420:00 - so in the dialog that has just popped up
420:03 - let's enter the name of our already
420:05 - existing dbcontext class
420:09 - sales management db context
420:12 - let's click the add button on this
420:14 - dialog
420:17 - then let's click the add button on the
420:19 - main dialog
420:20 - at this point if you haven't followed
420:22 - the steps
420:23 - where we made our sales management db
420:25 - context class
420:27 - inherit from the identity db context
420:30 - class an exception will be thrown
420:32 - we have made our sales management db
420:35 - context class
420:36 - inherit from the identity db context
420:39 - class so we have no problems
420:42 - we must however make some adjustments to
420:44 - our program.cs class
420:47 - so let's go to the program.cs class
420:50 - visual studio has added in code add db
420:53 - context which is causing duplication of
420:56 - code so let's remove this add db context
421:00 - code here
421:01 - let's paste our original connection
421:03 - string related code over the connection
421:06 - string code that visual studio has added
421:09 - to program.cs
421:11 - then you can see here that visual studio
421:13 - has added code to program.cs that is
421:16 - appropriate for integrating microsoft
421:19 - identity into our application
421:22 - we must have the add default identity
421:24 - method being called here for simplicity
421:27 - let's modify this code here
421:29 - options.signin dot require confirmed
421:32 - account equals true
421:34 - to read
421:35 - options.signin dot require confirmed
421:38 - account equals false
421:40 - by setting this to false we are telling
421:43 - the identity system as it were not to
421:45 - include functionality
421:47 - where the user has to confirm the user's
421:49 - identity by clicking a link sent to the
421:52 - user's email address great so let's
421:54 - create a migration that will generate
421:56 - the necessary code for generating the
421:59 - identity tables in our database
422:41 - great
422:42 - let's run our migration code by running
422:45 - the update database command
423:16 - excellent
423:21 - the next step is we are going to create
423:24 - code to register certain employees with
423:26 - the identity system whose records exist
423:29 - within the employees table
423:32 - through our code these employees will be
423:35 - put into certain roles for example the
423:38 - sr identity role will contain employees
423:42 - who are sales reps the tl role will
423:45 - contain employees who are team leaders
423:48 - the sm role will contain the sales
423:50 - manager the admin role will contain
423:53 - employees
423:54 - who are able to perform cred operations
423:57 - on employee details the sales manager
424:00 - will be included in both the sm role and
424:03 - the admin role
424:05 - so firstly let's generate a migration
424:43 - notice that this migration class doesn't
424:45 - contain any code logic but just the
424:48 - structure for a migration class
424:50 - so we are going to create the code for
424:52 - this migration class to register certain
424:55 - employees with the identity system and
424:58 - add the employees to their appropriate
425:00 - identity roles in the interests of time
425:03 - i've already prepared the code for this
425:05 - off screen so we are going to copy the
425:07 - code from this github location
425:10 - a link to this location is available
425:12 - below in the description of this video
425:15 - and paste the code appropriately into
425:17 - our migration class here
425:20 - so each user and each role in the
425:23 - identity tables must be associated with
425:26 - a unique gurd global unique identifier
425:30 - in the identity tables guides are used
425:33 - as primary key values
425:50 - so let's generate new goods for these
425:52 - constant string values
425:56 - let's replace the goods that i generated
425:58 - for this sample code with newly
426:00 - generated goods
426:02 - an easy way to do that is to navigate to
426:05 - this url
426:06 - we can then type in the number of goods
426:09 - we would like to generate so we want 11
426:12 - goods
426:13 - we can then generate the goods and copy
426:15 - them to our clipboards
426:20 - let's paste the goods into our code here
426:23 - and comment them out
426:31 - then let's replace the existing goods
426:33 - assigned to our constant values with the
426:36 - new goods
426:38 - that we have just generated
427:43 - great
428:02 - let's paste the code in for the up
428:04 - method like this
428:08 - notice that for the sake of simplicity
428:10 - the password for each of the employees
428:13 - that this code will register with the
428:15 - identity system will be password one
428:18 - with the p capitalized and an
428:20 - exclamation mark character so password
428:23 - one exclamation mark is the password
428:29 - let's bring in the microsoft dot asp.net
428:32 - core dot identity namespace
428:35 - let's copy the code for the private
428:37 - methods that are being called from
428:39 - within the up method and paste these
428:42 - private methods appropriately into our
428:44 - migration class
429:33 - let's copy the code for the down method
429:44 - and appropriately paste the code into
429:46 - our down method here
429:49 - let's paste in the code for the private
429:51 - methods that are being called from
429:53 - within the down method
430:27 - let's invoke the package manager console
430:29 - window
430:38 - and run the update database command
431:01 - let's view our database within sql
431:03 - server management studio
431:15 - excellent
431:17 - so in order to include identity role
431:19 - based functionality in our application
431:22 - we need to include the add roles method
431:24 - like this here within our registration
431:27 - functionality regarding identity
431:37 - we must also include a call to these
431:39 - methods in our program dot cs class so
431:42 - that our application knows as it were to
431:45 - include this identity middleware in our
431:48 - application so please appropriately
431:50 - include the following code app.use
431:55 - dot authentication
431:55 - authorization
432:02 - the next step is to ensure that an
432:04 - anti-forgery token is passed to the
432:07 - client
432:08 - this anti-forgery token can then be
432:10 - passed to the server with each client
432:13 - request
432:14 - the benefit of this is that our code
432:17 - will be able to verify that the client
432:19 - accessing our code is a trusted client
432:22 - we don't want just any client to be able
432:25 - to access our code
432:27 - we only want trusted clients accessing
432:29 - our code
432:30 - one of the ways that hackers can
432:32 - overcome our security is through
432:35 - cross-site scripting
432:37 - so the next step is we need to include
432:40 - anti-forgery token functionality in our
432:42 - application
432:44 - to do this let's first add a class named
432:47 - tokenprovider to our data folder
433:07 - let's include string properties within
433:09 - our token provider class
433:12 - the xsrf string property
433:14 - and the refresh token property
433:27 - so let's open the underscore host dot cs
433:31 - html file and write code so that an
433:34 - object of type microsoft
433:36 - dot asp.net core
433:38 - dot anti forgery dot i anti forgery is
433:42 - injected into this page at runtime
433:45 - this is where we are going to generate
433:46 - the token and pass the token into our
433:49 - application
433:51 - let's write code to use the injected
433:54 - object to request a token
433:57 - let's create an object named tokens
434:00 - derived from our tokenprovider class
434:04 - and then assign the returns token to the
434:07 - xsrf token property of our tokenprovider
434:11 - object
434:16 - within the component element
434:19 - let's add a property named param
434:22 - initial state
434:23 - and set its value to the tokens object
434:27 - this is how we are passing our token to
434:29 - our application
434:30 - we are passing the tokens object to the
434:33 - app razer component let's appropriately
434:35 - update the app razer component
434:38 - let's write code to inject an object of
434:41 - type token provider into our appraiser
434:44 - component at runtime
434:53 - let's include a using statement
434:55 - that references the namespace of where
434:58 - our tokenprovider class resides within
435:00 - the
435:02 - underscoreimports.razer file
435:11 - the cascading authentication state
435:13 - element wraps the router element
435:21 - we need to change the root view element
435:24 - to an authorized root view element
435:31 - we can remove this line of code here
435:34 - so when the appraiser component loads up
435:37 - we want to assign the initial state
435:39 - parameter that we are passing down from
435:42 - the underscore host dot cs html page and
435:46 - we are going to set
435:47 - the xs rf token property of the token
435:51 - provider object injected into this razor
435:54 - component at runtime
435:55 - to the xsrf token property of the
435:58 - tokenprovider object passed into the
436:01 - initial state parameter
436:13 - next let's create our own login display
436:15 - component note that if we had included
436:18 - identity functionality at the point when
436:20 - we created our blazer server project a
436:23 - file for the login display component
436:25 - would have been generated for us by
436:27 - default
436:29 - in our particular scenario we are going
436:31 - to create our own login display
436:33 - component
436:34 - so let's create a razor component named
436:37 - login display
436:39 - let's write the code for our login
436:41 - display component
438:03 - so here we have code that is responsible
438:06 - for injecting a token provider object
438:10 - into our component at runtime our html
438:13 - code is wrapped in an authorized view
438:16 - element
438:17 - if the relevant user is authorized a
438:20 - welcome message
438:21 - and a logout button are shown to the
438:24 - user
438:24 - if the user is not authorized a register
438:28 - button and a login button is presented
438:30 - to the user notice that we have a hidden
438:33 - input field included in the html code
438:36 - our token provider object's xsrf token
438:40 - property is stored within the hidden
438:43 - text field
438:45 - then we need to reference the log and
438:47 - display eraser component appropriately
438:49 - within the main layout raiser file
439:07 - next let's add a razor component to our
439:10 - shared directory named redirect to login
439:24 - let's include this code within the
439:26 - redirect to login raise a file
439:58 - as the name suggests this code is used
440:02 - to redirect a user to the login page
440:06 - and that is basically it
440:08 - let's see if we can log into our
440:10 - application
440:20 - oops what have we done wrong
440:23 - we have not registered our token
440:25 - provider type for dependency injection
440:29 - let's go to the program.cs file and
440:32 - write the code for this
440:39 - let's run the code
440:53 - great we are presented with the default
440:55 - login screen
440:56 - provided by identity let's log in as one
441:00 - of the employees who is a team leader
441:03 - henry andrews
441:14 - great
441:16 - but we haven't created any authorization
441:19 - functionality in our application yet
441:22 - so by default
441:24 - anyone can just access any functionality
441:27 - within the system
441:28 - so we can click the log out link to log
441:31 - out of our application like this
441:34 - let's write code so that the links to
441:36 - our razer components are only accessible
441:39 - to relevant employees
441:42 - so let's restrict the visibility of the
441:44 - link to the tl dashboard razor component
441:48 - within the nav menu razer component
441:51 - so that it can only be seen by members
441:54 - of the tl role
441:56 - tl of course stands for team leader
441:59 - we can achieve this by wrapping the
442:01 - relevant link in the authorized view
442:03 - element
442:04 - we can then set the elements
442:06 - roles property to tl like this note that
442:10 - if we wanted to include more than one
442:13 - role value within the roles property all
442:16 - we would have to do is separate the
442:19 - relevant values by a comma so we would
442:22 - provide a comma delimited string
442:24 - containing the relevant roles
442:27 - let's run the code
442:30 - you can see that the tl dashboard is not
442:33 - visible when we first launch the
442:35 - application however if we log in as
442:38 - henry andrews who is a team leader and
442:41 - therefore a member of the tl role
442:46 - we can now see the link to the tl
442:48 - dashboard razer component in the main
442:50 - menu
442:51 - excellent
442:53 - the moment we log out the link to the tl
442:56 - dashboard razer component is no longer
442:59 - available
443:00 - if we log in as benjamin lucas who is a
443:03 - sales rep
443:04 - and not a team leader
443:13 - once he has been authenticated
443:15 - we still can't see the link to the tl
443:18 - dashboard component
443:20 - because he is not a team leader and
443:22 - therefore not a member of the tl
443:24 - identity role
443:27 - let's restrict the link to the sr
443:29 - dashboard razor component so that only
443:32 - sales reps ie members of the sr roll can
443:36 - see this link
443:45 - so if we launch the application
443:50 - we can no longer see the link to the sr
443:53 - dashboard razer component
443:55 - if we log in as a sales rep
444:08 - there it is
444:10 - great
444:14 - if we log in as henry andrews a team
444:16 - leader
444:20 - he is not able to see the link to the sr
444:23 - dashboard raise a component
444:26 - because he is not a sales rep and not a
444:28 - member of the sr identity role so in
444:32 - order for the correct data to be added
444:34 - to the system and the correct data to be
444:38 - retrieved from the system pertaining to
444:40 - the logged on employee
444:42 - let's write code to replace the
444:44 - hard-coded employee ids for relevant
444:47 - functionality with the employee id of
444:50 - the logged on employee so how can we do
444:54 - this
444:55 - so the data we have registered in the
444:57 - asp.net users identity table contains
445:01 - employee email addresses which of course
445:04 - are unique
445:05 - and they match up to the relevant email
445:08 - addresses saved for employees in the
445:11 - employees table
445:12 - our code is going to use the email
445:14 - address retrieved through identity when
445:18 - a user logs on to the system to query
445:21 - the employees table in order to as it
445:24 - were retrieve the logged on employees
445:26 - employee object
445:29 - then the employee's id
445:31 - can be read from the relevant employee
445:33 - object and we can use the employee id
445:36 - value appropriately in our code rather
445:39 - than a hard-coded value
445:43 - to do this let's create an extension
445:45 - method within the conversions class
445:47 - named getemployee object
446:05 - this first parameter is of type
446:07 - system.security.com
446:10 - principle this will allow our code to
446:13 - call the get employee object extension
446:16 - method on the user object of type
446:21 - system.security.claims.claims principle
446:23 - that will be available to our code once
446:26 - a user has been authenticated after the
446:28 - user logs onto the system we'll look at
446:31 - the user object in just a bit
446:43 - so we can use the user objects
446:46 - identity.name property which returns the
446:49 - email address registered in the asp.net
446:52 - users identity table for the employees
446:55 - that we registered through running the
446:58 - relevant migration that we created
447:00 - earlier
447:01 - we can use this email address which is
447:03 - also the user's username to query the
447:07 - employees table and return the
447:09 - appropriate employee object to the
447:12 - calling code like this
448:04 - great
448:05 - so let's first change the code in the
448:08 - order service class so that the relevant
448:10 - employee id
448:12 - is no longer hard coded to the employee
448:15 - id pertaining to benjamin lucas
448:19 - so we need to be able to access the user
448:22 - object which is an object that will be
448:24 - available once a user is authenticated
448:28 - to gain access to the user object
448:31 - let's first create a parameter within
448:34 - the constructor of the order service
448:36 - class of type authentication state
448:39 - provider
448:53 - let's create a member variable to
448:55 - reference the injected object
449:08 - let's create a private method
449:17 - that first gets a reference to the user
449:19 - object like this
449:47 - and then we can call our get employee
449:50 - object extension method on the user
449:52 - object and return the relevant employee
449:56 - object to the calling code like this
450:10 - within the create order method let's
450:12 - call the get logged on employee method
450:15 - to reference the employee object of the
450:17 - logged on employee and replace the
450:19 - hard-coded value of 9
450:22 - with the logged on employees employee id
450:26 - great
450:27 - let's create the same logic for the
450:29 - sales order report service class like
450:31 - this
453:36 - and let's do the same for the
453:38 - appointment service class
455:04 - when we ran our migration that
455:06 - registered certain employees
455:08 - we registered the following employees
455:10 - within the identity system
455:13 - we registered bob jones the sales
455:15 - manager as a member of the sm role
455:18 - and the admin role
455:20 - we registered henry andrews who is a
455:23 - team leader and a member of the tl role
455:27 - we registered all the members of henry's
455:29 - team
455:30 - i.e the sales reps benjamin lucas olivia
455:34 - mills
455:34 - sarah henderson and noah robinson so now
455:38 - if we log in as henry andrews
455:52 - great the hard-coded employee id 3 is no
455:55 - longer used to retrieve the relevant
455:58 - data the id for the logged on employee
456:01 - is instead used excellent
456:04 - the same is true for benjamin lucas
456:16 - excellent
456:17 - let's login as olivia mills
456:29 - and we don't have much data for olivia
456:31 - mills
456:32 - but the system is reflecting the correct
456:34 - data for olivia mills who is a sales rep
456:38 - let's login as sarah henderson
456:53 - great and you can play around with the
456:55 - data in the sales order reports table
456:58 - to create more interesting data for the
457:01 - sales reps
457:04 - let's go to the nav menu razer component
457:07 - and appropriately write code so that
457:09 - only the functionality appropriate to
457:12 - the logged on user is available to the
457:14 - relevant user
458:03 - excellent
458:04 - let's log in as bob jones the sales
458:06 - manager
458:15 - and operate the application from his
458:18 - perspective
458:28 - excellent
458:29 - and you can see we have now
458:31 - appropriately integrated microsoft
458:33 - identity into our application where
458:36 - appropriate authentication and
458:38 - authorization functionality has now been
458:40 - implemented
459:09 - we are currently appropriately making
459:10 - the relevant links
459:12 - in the main menu visible to logged on
459:15 - users based on the roles to which they
459:18 - belong
459:19 - at present however a user could
459:21 - currently still access any razor
459:24 - component despite not having the
459:26 - appropriate privileges
459:28 - by simply typing in the url of the
459:31 - relevant razer component
459:33 - so to prevent this
459:35 - we can also restrict access within the
459:38 - razer components themselves
459:41 - one way of doing this
459:42 - is by appropriately including the
459:44 - authorized attribute within the relevant
459:47 - razor component like this
460:02 - and now access to these razor components
460:05 - are prohibited for unauthorized users
460:09 - excellent
460:31 - just to add an air of authenticity to
460:34 - our fictional company i've created a
460:36 - basic logo very quickly in photoshop for
460:40 - our fictional company outdoor excellence
460:42 - or oexl for short
460:46 - you can download the image from this
460:47 - location
460:48 - of course you're welcome to create your
460:50 - own company and company logo for the
460:53 - application but if you'd like you can
460:55 - download the one i created from this
460:57 - location on github
460:59 - to present the logo to the user when the
461:02 - user first launches the application
461:04 - let's include this code within the index
461:07 - raiser component please feel free to
461:09 - copy the code from github
461:20 - let's also include the logo within the
461:22 - nav menu razer component
461:37 - let's open the login display razer
461:39 - component and style the buttons for the
461:42 - login logout and registration
461:44 - functionality
462:09 - let's remove the about link from the
462:12 - main layout razer component
462:14 - let's include the login display element
462:16 - appropriately within the nav menu razer
462:19 - component so that the login and
462:22 - registration related buttons are
462:24 - available on mobile screen sizes within
462:27 - the main menu note we are including the
462:30 - d
462:30 - sm
462:32 - none bootstrap class in the container
462:34 - element that contains the login display
462:37 - razor component reference so that the
462:39 - relevant buttons only show up in the nav
462:42 - menu razor component when the app is
462:45 - running on mobile devices i.e when the
462:48 - app is only being presented on small
462:50 - screens
463:20 - let's add some meaningful icons provided
463:22 - by font awesome to the links in our main
463:25 - menu ie in the nav menu razer component
463:30 - let's include an appropriate font
463:31 - awesome link element within our
463:35 - underscorelayout.cshtml page which will
463:37 - give us access to the font awesome icons
463:41 - font awesome cdn is the easiest way to
463:44 - get font awesome on our web application
463:55 - let's search the font awesome website
463:57 - like this for some appropriate icons and
464:01 - appropriately include them within our
464:03 - nav menu razer component for our links
465:09 - great
465:50 - and lastly i want to import the
465:52 - quicksand google font from within the
465:55 - site.css file and reference this font in
465:59 - the font-family css property for our
466:02 - pages html and body elements
466:08 - excellent
466:09 - and that's it
466:10 - that is our application finished
466:23 - [Music]
466:25 - [Applause]
466:32 - [Applause]
466:38 - [Music]
466:46 - i've thoroughly enjoyed creating this
466:48 - course and i hope you've enjoyed going
466:49 - through it with me
466:51 - if you have gone through the whole
466:52 - course congratulations you are now able
466:55 - to build a sophisticated blazer server
466:57 - application using sophisticated
466:59 - syncfusion components and microsoft
467:02 - identity i hope to see you again soon
467:04 - thank you and take care

Cleaned transcript:

learn how to build a sales management application in this comprehensive sync fusion course from gavin lawn gavin has decades of experience that he brings to his courses and think fusion provided a grant that made this course possible hi i'm gavin lon i've been developing software professionally for over 20 years and i'm especially excited to bring you this free course where we are going to use the sophisticated sync fusion components and we are going to build a blazer server application on net six the components are highly customizable and are finetuned for performance when dealing with high volumes of data so please join me as we develop a blazer application where we'll integrate the sophisticated syncfusion components into our application and we'll also integrate microsoft identity into our application syncfusion provides a ui component suite for building powerful web desktop and mobile apps essential studio is a software package provided by syncfusion that provides stateoftheart solutions for startups and enterprises it includes more than 1700 components and frameworks for winforms wpf asp.net web forms mvc core uwp win ui xamarin flutter blazer javascript angular vue and react that make developers work easier please join me in this free course where we are going to build a real world sales management application using blazer during this course we are going to integrate some of the most popular syncfusion components in our blazer application like the data grid the list view the charts the diagram the scheduler and more laser is a web framework for building web ui components razer components that can be hosted in different ways razer components can run server side in asp.net core blazer server versus client side in the browser on a web assembly for the application that we are going to develop we are going to use the blazer server hosting model we will first develop the logic for each razor component where we will learn how we are able to harness the power and sophistication of the sync fusion components that we'll integrate into our application through the implementation of minimal amounts of code toward the end of the course we'll integrate login registration authentication and authorization functionality into our blazer server application using microsoft identity when an employee logs on to the sales management application they'll be able to access a personalized dashboard where these beautiful sync fusion charts will be displayed presenting the user with data of relevance to the logged on employee for example a sales manager will see sales metrics related to overall performance for the sales department a team leader will see sales metrics related to the sales performance of each of the team leaders team members the sales rep will see metrics related to the sales reps personal sales performance so if you go through this course with me i can guarantee you you are going to learn a tremendous amount about creating a sophisticated web application using blazer sync fusion components and microsoft identity so let me tell you more about the application that we are going to build using blazer server and the sync fusion components i've created a fictional company that i've named outdoor excellence or oexl for short this company sells outdoor and sporting goods to retail outlets situated around the united states the application is specifically for the sales department that consists of a sales manager team leaders that report to the sales manager and sales reps that report to their team leader the sales reps are on the road most of the time visiting clients and facilitating orders made by the clients for products sold by outdoor excellence our application will provide an ordering facility where a sales rep can for example order multiple products from the outdoor excellence product catalog displayed through our blazer application using the sync fusion list view component the sales rep could for example order multiple products through our application using a mobile device while in a meeting with a client a team leader or the sales manager can view their own personal dashboards and view analytical data displayed using syncfusion charts through our application so bob jones the sales manager could log in for example from his office on his desktop computer and view metrics beautifully displayed to him in the relevant sync fusion charts that have been integrated into our application bob jones can then use these sales metrics for decision making and strategic planning if for example olivia mills a sales rep places a large order through the system bob jones can see in real time the effect that the order has on current sales metrics through his personalized dashboard each sales rep can view their own personal dashboard when they log on to the system custom reports regarding their personal performance is available through the data expressed on these sophisticated charts provided by syncfusion a team leader is interested in the performance of the team leaders team members and is able to log on to the application perhaps at a desktop computer in the team leader's office and can see in real time how each team member is performing these charts communicate at a glance how the team is performing overall as well as how each individual team member is performing relative to the other team members bob jones the sales manager has administrative permissions and is able to perform crud create read update delete operations on employee data this functionality is facilitated using the syncfusion data grid bob jones is also able to view the employee organizational hierarchy of his sales department this display is facilitated through the use of the syncfusion diagram component so through the system bob jones can for example using the syncfusion data grid change which team leader a sales rep reports to and the change is reflected immediately within the syncfusion diagram depicting the employee organizational hierarchy bob can of course also add new employees to the system using this facility you can also change basic information associated with employees like for example changing someone's last name if for example the relevant employee gets married the data grid provides bob with conveniences like for example a search facility sorting functionality for each column and he can also easily export the data displayed on the data grid into other common application formats for example he can export the relevant data to an excel spreadsheet or a pdf document each employee is able to create appointments within the sales management application using this functionality implemented through the integration of the sync fusion scheduler component for example a sales rep can create an appointment in the system to meet a new client at a specific date and time and for a specific duration extra information about the meeting can also be saved for each appointment a team leader for example is able to create appointments within the application for meetings with team members as with all the syncfusion components the scheduler is highly customizable all of the technologies that we'll use to build our sales management application for outdoor excellence can be downloaded free of charge links have been included in the description of this video to the locations of where you can download and install the relevant technologies we'll be using visual studio 2022 community edition for windows as our ide integrated development environment to develop the application we'll develop the application on.net 6. you can download and install visual studio from this location free of charge we'll be using sql server 2019 as our backend storage facility you can download sql server 2019 from this location on occasion we'll be using sql server management studio or ssms to update our data and you are able to download ssms from this location note that even if you don't have a sync fusion license you'll be able to follow along with this course but if you want to use the syncfusion components to develop commercial applications you will need a valid license you are able to claim a free syncfusion community license by clicking this link here and then following the appropriate steps in order to claim your free community license you'll need to have a valid linkedin or zing account the community license allows you to use syncfusion's entire product line free of charge in your commercial applications if you own the intellectual property of the relevant applications the community license is a complimentary license model that is reserved for organizations earning up to 1 million us dollars in revenue and employing fewer than 5 developers if this does not apply to you you will need to get a paid license please navigate to this url to learn more about syncfusion's hasslefree licensing model in order to install the syncfusion components during the development of our application we'll use the new get package manager from within visual studio to download and install the relevant syncfusion packages when we are ready to integrate the relevant syncfusion components into our application although we are developing the application on a windows os our application will be crossplatform and we'll be able to run on most browsers i will be using the chrome browser for running the code interactively through visual studio so let's fire up visual studio 2022 and get started with the development of our sales management blazer application let's click the create new project option here so we can already see the project template we are going to use but visual studio does allow us to filter our project templates if we need to search for a specific project template so for our purposes we are going to select blazer server app let's name our project sales management app and make sure we are saving our project to an appropriate local directory let's click the next button here we have dot net 6 already selected as our version of dot net so we don't have to change the setting for the authentication type we could at this point choose for example individual accounts and at this stage in the development of our project integrate microsoft identity into our application for the purpose of the facilitation of login registration authentication and authorization functionality for now we are going to leave this setting at none and toward the end of the development of our application we'll integrate microsoft identity into our blazer server application we are going to start with the integration of the datagrid syncfusion component into our blazer server application we can use the sophisticated functionality within this component to perform crowd operations paging grouping sorting filtering searching exporting the data displayed in the data grid to an excel spreadsheet and much more so let's install the syncfusion data grid component we can do this by installing the appropriate new get package like this so let's rightclick the dependencies node within our solution explorer window click manage new get packages we can then enter text that will help the search facility find the sync fusion grid nuget package that we can install for a blazer application this package contains the syncfusion data grid component and there it is the package that we want to install syncfusion.blazer.grid so at the time of the creation of this video for this section of the course the latest version of the syncfusion.blazer component is version 20.1.0.58 so let's click the install button and we have successfully installed the syncfusion.blazer.grid new get package excellent if you'd like to read more about getting started with the syncfusion blazer data grid component please navigate to this url where syncfusion provides comprehensive information regarding getting started with the syncfusion blazer datagrid component i will of course also take you through the getting started process step by step in this course we also need to install the syncfusion.laser dot themes new get package so let's do this and the other new get package that we need to install is the syncfusion.blazer.core nuget package excellent so next let's open the program.cs file within our sales management app project and let's include the necessary registration code here for using blazer sync fusion components within our blazer application we have a red squiggly line under add sync fusion blazer to get rid of this let's bring in the syncfusion.blazer namespace great we can register our community sync fusion license using this line of code within the program.cs class like this you will need to of course replace the your license text here with your personal license key note that you will be able to follow along with this course without a license but in order to use the syncfusion products commercially you will need a valid license so next we need to open our underscorelayout.cshtml file that resides within the pages folder we need to add this line of code that references a bootstrap 5 css file and we also need to add this line of code that references a javascript file so we are ready to use the syncfusion blazer datagrid component within our blazer application as stated syncfusion provides comprehensive documentation for example the getting started section of the documentation pertaining to the syncfusion blazer data grid contains the instructions that we have just carried out for the integration of the syncfusion blazer datagrid component on.net 6. instructions regarding other versions of net are also available within the pages directory let's create a new razer component named employeemanagement.razer let's provide routing information at the top of our razer file using the add page directive within this shared directory let's open the nav menu razer component which houses the functionality for our applications main menu the nav menu razer component is provided to us by default through the blazer server app project template let's add a navigation link to our application's main menu that when clicked invokes our employee management razer component and of course now when we run our code interactively through visual studio we are able to invoke the employee management razer component by clicking the appropriate link that we have created within the nav menu razer component let's create a using directive at the top of our file that references the syncfusion.blazer.grids namespace we can now directly reference the types that reside within this namespace within our razor component without flagging a compile time error so let's include the data that we are going to wire up to our syncfusion datagrid component to quickly get started using the datagrid i've prepared a list of employee records that we can include within our razer component in a bit we'll create a sql database through ef core code first migrations and then we'll wire up the relevant data retrieved from the relevant database table to our syncfusion datagrid component let's first create a class named employee model that represents the shape of the data for an employee record to save time i've prepared this class off screen you can either type out the class or to save time you can simply navigate to this url where you can copy the employee model class from the relevant github web page and paste the class into your razer file a link to the relevant github web page is available in the description of this video so the employee model class consists of seven properties id as integer first name as string last name as string job title as string gender as string date of birth as date time and reports to empid as a nullable integer the question mark at the end of the int data type definition denotes that this integer property can store a null value let's declare a private variable to store a generic list that is strongly typed with our employee model userdefined type let's override the blazer builtin lifecycle event handler method named uninitialized this method is invoked when the component is ready to start having received its initial parameters from its parent in the render tree so off screen i've prepared the code for populating our list of employee model data you can copy the code that populates the relevant list of employee records from the relevant github web page as stated a link to this github web page is available below in the description of this video the data consists of made up employee records so now we are ready to create the code for displaying our data to the screen from within our razer component so let's create the bare minimum code we need to achieve this so let's include a syncfusion data grid component within our razor component by adding a sf grid element that represents our data grid here now all we need to do is wire up the data in our employee data list to the sf grid component to do this we can include a property within the sf grid element named datasource and set its value to the variable named employee data that has been assigned the list of employee model data let's run the code and look at that right out of the box our employee data is neatly displayed within our syncfusion datagrid component it is that simple we have achieved this through a tiny amount of code that is both easy to implement and easy to read and the datagrid component adapts its size based on the html element in which it is contained we can include or exclude the properties we want displayed on our data grid by including the grid columns element within the sf grid parent element and then including certain grid column elements within the grid columns element each grid column element represents a property within the class that represents an employee record i.e denoted by the employee model class we can use the field property within each grid column element to map employee model properties to their appropriate grid column element so the data grid will now only include those fields within the relevant data source that have an appropriate grid column element declared as a child element within the grid column's parent element so you can already get a feel for how easy it is to customize the sync fusion data grid we can set the width of each column by adjusting the width property of the relevant grid column element we can then customize the heading text for each column by appropriately including a header text property within the relevant grid column elements excellent we can customize our sync fusion datagrid component so that the data displayed is displayed over a number of pages to achieve this we simply set the sf grid elements allow paging property to true and include a reference to the grid page settings element within the sf grid element like this we can then assign a value representing the number of rows per page we want displayed within our data grid by assigning the relevant value to the page size property like this so we are telling the syncfusion data grid as it were that we want to display five rows of data per page on our data grid the sophisticated functionality is created with a few lines of declarative code that is innately easy to read to customize the maximum amount of rows we want displayed on each page it is as simple as appropriately assigning our custom page size value to the relevant page size property excellent if we had for example thousands of rows of data we would definitely need a way to search the relevant data we just need to tell the syncfusion data grid component as it were to include search functionality in order to achieve this we simply create a list which contains the string value of search so let's create a private variable named toolbar then assign the private variable a list of objects of course a string is an object so we can include a list item that is the string value search we can then let the datagrid component know as it were what functionality we wish to include on the datagrids toolbar to do this we can assign our list of objects stored in our toolbar variable to a property named toolbar within the sf grid element it's that simple we now have search functionality excellent if we want to allow the user the ability to group by any column all we need to do is set the allow grouping property within the sf grid element to true in order to group by a particular field the user can simply drag the column header that represents the column by which the user wishes to group the data grid to this panel that is now available on the data grid and our data is appropriately grouped by our chosen column and look at that we have grouped by the reports column and the data grid shows who each employee reports to in the organizational structure you can group by many columns so let's also group the data by gender great we are able to filter each column by appropriately setting the allow filtering property to true we could run the code and we would be able to filter each column by a text input field provided for each column we can include more sophisticated filtering functionality for each column by including a grid filter settings element within the sf grid element we can then include a type property within the grid filter settings element and set the type property to for example syncfusion.blazer.grids.filtertype.menu this provides a user the ability to filter each column using a variety of different types of criteria for example a user can filter a column by a value that the user specifies for field values that start with a userspecified string value a user can specify that the user wishes to filter the data based on field values that are equal to a value that the user specifies a user can filter the data based on values in the data that are greater in value than the user's specified value for example the user may wish to filter the data by employees born after 1990. with this functionality the user can filter the data in a variety of different ways where a combination of filters can be applied to multiple columns the user is able to clear filters from certain columns and try various combinations of userspecified filtering criteria very powerful indeed and look at how simple the code is for achieving such powerful results in order for the user to be able to sort by the columns in descending or ascending order all we need to do is set the allow sorting property within the sf grid element to true like this we are going to delve deeper into using the syncfusion data grid to facilitate crowd operations but at this point i'll demonstrate the very basics of how to customize the syncfusion data grid so that it provides the user with a facility whereby the user is able to perform crowd operations on the relevant data of course we haven't yet created a database in which we can store our data so we are not able to persist data to a database we can however at this point superficially demonstrate the relevant crud operations within memory data so to allow for the facilitation of crowd operations using our syncfusion data grid component let's include the grid edit settings element within the sf grid element like this to allow for add operations or in crud terminology create functionality we set a property within the grid edit settings element named allow adding to true then to include the appropriate toolbar buttons we can add the appropriate items to our toolbar like this so here we are telling the syncfusion datagrid component as it were that we wish to include the add update and cancel buttons within the datagrids toolbar and we can now add records to our data grid by clicking the add button the user is then able to enter the relevant data for the fields for the record that the user wishes to add to the data grid then the user can press the update button to save the data to the data grid and we can now see that a new row containing the data that we have just added is present within the data grid of course we are only dealing with inmemory data at this stage so if for example we navigate to another component and then back to our employee management component the data that we added to the data grid is no longer present within the data grid to achieve the functionality of persisting the added data to a database through the data grid we will need to further customize the data grid and of course implement code to save the data to a data storage facility like for example sql server and this is exactly what we are going to do in just a bit once we have pressed the add button the update button and the cancel button are enabled so we could press the cancel button to cancel the add operation or once we have entered valid data into the relevant fields we can press the update button to save the relevant data to the data grid we can allow the records denoted by the rows of employee data in our data grid to be edited by including the allow editing property within the grid edit settings element and setting the allow editing property to true let's also include an appropriate edit item within the toolbar list so a user can now select the row in the data grid that the user wishes to edit then press the edit button on the toolbar carry out the relevant edit operations and then press the update button to save the relevant changes to the data grid and the update functionality is currently not working in order for the edit operation to run correctly we need to ensure that one of the columns serves as a primary key value so let's add the is primary key property to the grid column element that is wired up to the id field and let's set the is primary key property to true this allows for each record to be uniquely identifiable within the data grid note that the user is also able to put a particular row within the data grid into edit mode by simply double clicking on the relevant row we can also as it were tell the sync fusion data grid to include delete functionality within the syncfusion data grid by including the allow deleting property within the grid edit settings element and setting the allow deleting property to true we can then include a delete button within the datagrids toolbar by including the delete item within the toolbar list like this right so let's build the sales management application let's take a brief look at a depiction of the relational database design for our applications database i've designed the structure of this database based on a process called normalization let's look at a brief explanation of what normalization is here is a brief description provided by wikipedia regarding the process of normalization database normalization is the process of structuring a relational database in accordance with a series of socalled normal forms in order to reduce data redundancy and improve data integrity a link has been included below in the description if you'd like to learn more about database normalization so if we look at a relational database design depiction for our sales management application you can see that our database will contain the following database tables our database will contain the employees table the employee job titles table a products table a product categories table an orders table and order items table a clients table a retail outlets table and lastly we have a table named sales order reports the sales order reports table will be the table that is used for storing analytical data the data stored in this table will be used for the charts that will be presented to the users of our application on their dashboards in terms of design this table can be seen as different from the other tables because this table has been deliberately denormalized i discuss why this table is denormalized and what it means for a database table to be denormalized when we write the syncfusion charts related functionality very basically denormalized database tables are often used to store analytical data and normalize database tables are used to store transactional data transactional database tables are generally written to more often than the tables used to store analytical data the denormalized tables are designed to increase the retrieval speed of the data stored within them this increased speed is made possible because of the elimination of the need to join tables together when retrieving the relevant data so a major part of the denormalization process is eliminating the need for joins so let's look at the normalized tables and their relationships the employees table has a manytoone relationship with the employee job titles table many employees can have a particular job title for example many employees can have a job title of sales rep the products table has a many to one relationship with the product categories table many products can fall under a particular product category for example a tent falls under the camping product category and an air mattress also falls under the camping product category the orders table has a onetomany relationship with the order items table and order consists of many order items the orders table has a manytoone relationship with the employees table each order is created through a sales rep a particular sales rep can create many orders the orders table has a many to one relationship with the clients table many orders can be made by a particular client the clients table has a onetoone relationship with the retail outlets table the retail outlets table contains details about the retail outlet itself for example information about the retail outlets location each retail outlet has a person who serves as a contact within the relevant retail outlet the clients table contains information like for example contact information about the person that serves as a sales reps contact a particular product can be associated with many orders so that was just a brief explanation of my thinking behind the design for the database that we are going to use for our sales management application as we get further into building our application more details regarding how the database design underpins the logic for our application will emerge so we are going to use ef core code first migrations to build our database at this stage we are focusing on integrating the syncfusion datagrid component for the purpose of facilitating cred operations so at this stage we only need to create the employees table and the employee job titles table so let's create a folder to house the entities that will represent our database tables let's name the new folder entities let's add a csharp class to this new folder named employee this employee class can be viewed as a template that represents a row in the employee's database table each property that is defined within the employee class and each property's data type will correspond to a column within the employees database table let's create an auto implemented property named id an easy way to create a property within visual studio is to type prop then hit the tab key twice and a default property definition is generated for us by visual studio we can then adjust the property definition for example the properties data type and the property's name according to our requirement for convenience you are able to navigate to the elements of the property definition using the tab key so we are able to for example change the property type and then use the tab key to move the cursor to the property name and we are then able to modify the property name so id as int first name as string last name as string email as string gender as string date of birth as date time and reports to empid as a nullable integer the question mark character following the ins data type definition means that this property can store a null value the employees table supports a parent child relationship the reports to empid field will contain either a null value or one of the values stored in the id field which is the primary key for the employees database table the relationship between the id field and the reports to empid denotes the following if for example an employee with an id of 2 has a report to empid value of 1 this means the employee with the id value of 2 reports directly to the employee with an id value of 1. this denotes that the employee with the id of 1 is the immediate boss of the employee with the id of two within the organizational structure an employee with a report to empid of null does not report to any other employee and is therefore at the top of the organizational structure in this case that employee is the sales manager bob jones team leaders reports directly to bob jones and sales reps report to a team leader so we are able to express the hierarchical structure of the organization for the employee data stored in our employees table by including a column that can store a null value and can also store a value that corresponds to the table's primary key which in this case is the id field if this concept is not clear to you don't worry this will become clearer to you when we integrate the syncfusion diagram into our application later on in this course in order to express our employee data in a hierarchical depiction i.e a structure that represents the organizational structure of our fictional sales department let's create a string property named image path its corresponding field in the database will store a path to a profile image of the relevant employee i've prepared a profile image for each employee i'll supply the relevant details of where you can download the profile images a little bit later when necessary we'll add data for each employee to the employees database table and employee job titles database table a little bit later lastly let's create an integer property named employee job title id this field will serve as the foreign key field from the employee job titles database table the employee job titles for our application are as follows the sales manager or sm for short the team leader or tl for short and the sales rep or sr for short so each employee will have one of these three job titles in our fictional sales department let's create a class that will correspond to the employee job titles database table let's name this class employee job title let's create the first field which must be named employee job title id this is the primary key field that joins this table with the foreign key field of the same name in the employees table let's create a string property named name and let's create a string property named description great right let's create our database using entity framework core code first migrations in order to do this through visual studio we need to install two nuget packages let's include the nuget package named microsoft dot entity framework core dot sql server great and let's install the new get package named microsoft dot entity framework core dot tools by installing the microsoft dot entity framework core.tools nuget package we'll be able to for example create our database migrations by running the relevant commands within the new get package manager console window from within visual studio we wouldn't need to install this package if we were to run the relevant migration commands through the.net sdk note that when using the.net sdk for running ef core migration commands the commands are different to when running the commands for the same purpose through visual studio for this course we are going to run the relevant migration commands directly through visual studio which means an installation of the microsoft dot entity framework core.tools new get package is necessary in order to build our database using ef core we must include a db context class within our application this dbcontext class is essential for when we need to retrieve or modify data in our database using code within our application so let's create a class to represent our db context within the data folder let's name our class sales management db context this class must inherit from the db context base class the red squiggly line under db context is visual studio indicating to us that we are missing a using directive an easy way to include the relevant namespace directive is to press ctrl period and then visual studio presents us with a context menu we can select the top menu item in this case and the relevant using directive is added to the top of our code so the db context type resides within the microsoft dot entity framework core namespace great let's create a constructor for our dbcontext class an easy way to generate a default definition for a constructor for a csharp class from within visual studio is to type in ctor and then press the tab key twice this constructor must accept an argument of the generic type db context options that is strongly typed with our sales management db context type we must pass this argument down to a constructor within the db context base class by using the base keyword like this and now all we need to do is tell ef core as it were about the classes that we wish to use as definitions for our database tables so to do this we include a property of the generic data type db set for each table that we wish to generate within our database we must strongly type each db set property with the appropriate user defined type that we have used to define the relevant database tables in our entities folder so the first property is defined with the generic db set type that has the employee user defined type passed to it as a type argument so the second property is defined with the generic db set type that has the employee job title userdefined type passed to it as a type argument each of these property names will be used as the database table names for the corresponding tables in the database so when we create a migration and update the database the database will be created and two database tables will be created within our database one named employees and the other named employee job titles the next step is to ensure that we have an appropriate connection string defined within the appsettings.json file so to do this let's create a connection string setting within our appsettings.json file and create a connection string named sales management db connection so we need to set the server property of our connection string to the server name on which our database will be created my server name is gavinlon's pc we must then set the database property of the connection string to the name of the database we wish to create sales management db seems like a sensible name then set the trusted underscore connection property to true this basically means that the windows account under which our application runs will be authenticated against the relevant sql server database great the next step is to register our sales management db context type for dependency injection we can do this by including the appropriate code within the program.cs file so let's open the program.cs file let's first write code to read the relevant connection string from our appsettings.json configuration file into memory let's then use the add db context method to register our db context class ie our sales management db context type for dependency injection here we are configuring our db context type to use a sql server database and the necessary details of the relevant sql server database have been defined within the relevant connection string that we are passing to the use sql server method here great so we are now ready to run the relevant ef core commands to generate our database to do this let's invoke the package manager console window like this to create a migration we can type the add dash migration command and then follow this command with the name of our migration class let's name this migration initial create let's press the enter key to run the command and our migration class has been generated for us you can see that the up method contains code that builds the database and the database tables that we have defined within the sales management db context class the down method contains code to undo the effects of the code that resides within the up method so we have created our migration but we have not yet run the code within the up method that will generate our sql server database with the database tables that we have defined within our sales management db context class ie through the properties defined as the db set generic type so in order to run our migration we must type in the update database command let's open sql server management studio to see if our database has been created excellent our sales management db database has been created successfully and we can see that the employees database table has been created and the employee job titles database table has also been created within the sales management db sql server database so i've prepared data for our employees and employee job titles tables off screen we are going to seed these database tables by using the code that i've prepared off screen to do this let's create a static class within the data folder named seed data let's create a static void method within our seed data static class named add employee data as stated i've prepared code that will add the relevant employee data and employee job title data to the relevant database tables and this code can be copied from a github web page at this url let's copy the code from the relevant github web page and paste the code within our add employee data method let's bring in the sales management app dot entities namespace let's include a parameter within the add employee data method named model builder which is of the type model builder we must also bring in the microsoft.entity framework namespace which is where the model builder type resides so in order to seed our employees table and employee job titles table with the data we have defined within the seeddata.addemployeedata method we must first override a method defined in the dbcontext base class an easy way to override a method within visual studio is to type override then hit the spacebar key a list of overrideable methods is presented to us by visual studio and on model creating is the list item we want so let's select on model creating then within the on model creating method let's call the seed data dash add employee data method and pass in the relevant model builder object to the add employee data method like this great so to seed our database tables with data we can now open the package manager console window we can clear the screen by typing the clear command and pressing enter and we can then type in the add dash migration command followed by a sensible name for our migration so let's name our migration seed employee data and you can see ef core has generated the code for seeding our database tables so to run the code against our database we can type in the update database command and press enter let's look at our data in sql server management studio excellent let's create functionality to retrieve data from within our employees database table and return the relevant data to eraser component we don't want to expose our entity classes directly to the razer components that are responsible for presenting the relevant data to the user so we are going to create appropriate model classes that will store the data that is directly handled from within the relevant razer components so by doing this we are creating a separation of concerns the entity classes interact directly with the database the ef core functionality the model classes are only concerned with the presentation layer and are handled by code within the relevant razer components so let's create a folder named models let's create a class named employee model let's copy the properties from the employee entity class and paste the properties into our employee model class so at this stage we could implement the repository pattern and wrap our database related functionality in specially created repository classes in the interests of simplicity for this code example we are going to abstract the database handling code in our service classes we are not going to implement the repository pattern in this course you can of course implement the repository pattern if you'd prefer i do encourage creating distinct separation of concerns and code but this course is focused on the integration of syncfusion components into a blazer application so in the interest of time i want to keep the backend related code fairly simple let's create a new folder named services so let's create our first service class which will be responsible for handling employee data within the services folder let's create a folder named contracts let's create an interface within the contracts folder named i employee management service let's create a definition for an asynchronous method named get employees that will be responsible for returning a generic list that is strongly typed with our employee model userdefined type let's write code to implement the i employee management service interface so we need to bring in the sales management app dot services dot contracts namespace then with our mouse pointers positioned appropriately we can press control period again and generate code stubs for the methods that must be implemented like this so at this point we only need to implement code for one method the get employees method before we do this let's create a constructor for our employee service class let's add a parameter to the constructor of type sales management db context to indicate to.net as it were that we want an object of type sales management db context injected into this constructor at runtime so whenever an object is instantiated from our employee management service class an object of type sales management db context will be injected into the relevant employee management service object so let's position our mouse pointers appropriately press ctrl period and select create and assign field sales management db context from the menu that is presented to us within visual studio and this action results in visual studio generating an appropriate private member variable to store the object of type sales management's db context that will be injected into this constructor at runtime during the instantiation process of the employee service class we can now use the relevance dbcontext object to retrieve employee data from our database with this line of code so we have a red squiggly line so we must bring in the microsoft dot entity framework core namespace so that we can include the to list async extension method within our code here but we still have a red squiggly line this is because we want our method to return a list of employee model objects but we are currently attempting to return a collection of employee objects through our get employees method so to solve this we could write link transform code that converts our collection of employee objects to a collection of employee model objects within the get employees method and that would be fine but in the interests of cleaner code let's create a convert extension method for this purpose this means that we will be able to call a method named convert on the code that returns a collection of employee entities and the code we are about to implement for the convert extension method will perform the appropriate conversion functionality so let's first create a folder named extensions within the extensions folder let's create a static class named conversions within the conversions static class let's create a static async method named convert that returns a list of employee model objects in order to make this method an extension method that can be called on an object of type i queryable that is strongly typed as employee we need to include a parameter that is of type i queryable that is strongly typed with the employee type and this parameter must be preceded by this keyword an extension method must contain at least one parameter and the first parameter in an extension method must be of the type on which the extension method is called the first parameter must also be preceded by the this keyword if this isn't clear to you at this point this will become clearer when we call the extension method on the i queryable object returned by our efcor code in the get employees method so let's implement the code for our convert extension method so we can now use the employee's object passed as an argument to the convert method and through a link query we can perform the appropriate transform operation ie where we convert the i queryable object that is strongly typed with the employee type i.e this is a collection of employee objects returned from the database into a list that is strongly typed with the employee model type this is the list that we want to return to the relevant razor component that we'll create in a bit and now that our extension method is created we can perform the necessary conversion operation within our get employees method cleanly like this and of course we have a red squiggly line because we need to bring in the sales management app dot extensions namespace and that's it our get employees method is ready for use excellent so now we want to write codes to wire up our syncfusion datagrid component to the employee data returned from our database so let's open the employeemanagement.razer file let's remove the code related to the static data that is currently wired up to our sync fusion datagrid component we now have a red squiggly line under the employee model type because that was a reference to the employee model class that has now been removed from our razor file so let's bring in our newly defined employee model type by pressing control period and selecting the appropriate menu item represented to us by visual studio great and we need to change the field property value within our syncfusion data grid code here because the name in the newly defined employee model for the job title field is not job title but is employee job title id and for now let's remove code from our data grid relating to crud operations data filtering sorting grouping and paging and for now we also don't need our data grid to have a toolbar let's write code to override blazers builtin uninitialized async lifecycle event handler method within our uninitialized async method let's include code that gets the employee data from our database using our employee management service class and we must first write code so that an object of type employee management service is injected into our razor component at runtime great so let's write code to call the get employees method on our employee management service object and assign the returned list of employee model objects to our variable that we have named employee data the employee data variable is the data source for our data grid syncfusion component let's run the code and we have an error okay and i know exactly what has caused that exception it is because we haven't registered the employee management service type for dependency injection so let's open the program.cs class and write the code to register the employee management service type for dependency ejection so to do this we can simply include this line of code within the program.cs class let's run the code again and now the data stored within the employees table within our newly created sql server database is being neatly displayed within our syncfusion data grid component excellent let's explore the datagrid component further so we don't want the integer value displayed for the employee job title id field like it is being displayed at the moment within our data grid the employee job title id value is great for the unique identification of job titles but is not ideal for presentation purposes we want the name of the job title to be displayed here because it is more human readable than the employee job title id value we also want an administrator to be able to change the job title for an employee if necessary so we want this field to be able to display a drop down list containing all job titles as list items when an administrator puts a row displayed within the data grid in edit mode so when in read mode we want the name of the job title displayed to the user but when an administrator needs to change the job title for a particular employee we need the administrator to have access to a dropdown list containing all employee job title names the job titles that exist in the system at the moment are sales manager team leader and sales rep in the name field in the employee job titles table we are storing an abbreviation of these job titles sm for sales manager tl for team leader and sr for sales rep so for example if a sales rep is promoted to a team leader we want an administrator to be able to change the employee's job title from sr to tl from within a drop down list in the appropriate row in our data grid so to achieve this let's first go to our i employee management service interface let's create a definition for a method that returns a list of employee job title objects in the interests of time i'm going to use the employee job title class for the model and not create a model dedicated for presentation purposes like we did with the employee model class so let's go to the employee management service class and implement the code for our get job titles method great let's go to our employee management.razer file let's create a variable to store a list of employee job title objects let's write code to call our get job titles method on the employee management service object from within our override method of the uninitialized async blazer lifecycle method handler and we are assigning the returned value to our employee job title data variable so the employee job titles table has a onetomany relationship with the employees table and we are able to as it were let the sync fusion data grid component know about the relationship through appropriate declarative code that we are about to create the employee job title id field within the employees table is a foreign key from the employee job titles table the employee job titles table has a field that serves as its primary key named employee job title id we can as it were let the syncfusion data grid component know about this relationship between the employee job title id primary key field in the employee job title data data source and the employee data data source through appropriate declarative code that we are about to write so to establish the relationship between the employee data data source that we have already wired up to our data grid and the employee job title data data source that we are going to wire up to the relevant drop down list we are going to appropriately include a component within the data grid named grid foreign column instead of using the grid column component that we are currently using to represent our columns so this will mean that when a user selects a new value from within the employee job titles drop down list that the employee job title id foreign key value will automatically be changed appropriately in the employee data data source so when the user changes an item within the employee job titles drop down list the employee job title id value mapped to the selected drop dropdown list will become the value reflected in the employee data data source which is the data source wired up to our data grid through the declarative code that we are implementing for our data grid we are telling the syncfusion data grid as it were about the onetomany relationship between the employee job titles data source wired up to the relevant dropdown list and the employees data source wired up to the sf grid component so let's create the code for this let's delete the grid column component that is currently implemented to represent the employee job title id field let's include a component named grid foreign column to represent the employee job title id field as well as include the relevant dropdown list that will contain the employee job titles let's set the header text property value to designation let's set the t value property to employee job title we are doing this because we want the relevant drop down list to contain items of type employee job title we want the value of each item in the dropdown list to have its primary key value employee job title id mapped to the foreign key value also named employee job title id which is a foreign key field included in the employee model class we must set the foreign data source property to the data stored within the employee job title data variable this variable stores a list of employee job title objects we can then set the foreign key value property to the property that we want displayed to the user within the drop down list which is the name property let's make the fields width 100 pixels so when a row is in edit mode we want our drop down list to appear to the user to let the sync fusion grid component as it were know about this we must appropriately include the edit template component in our code like this within the edit template element we must include the sf dropdown list component let's bring in the appropriate namespace for the sf dropdown list type which resides in the syncfusion.blazer.dropdowns namespace let's use the at bind dash value attribute to bind the appropriate employee model object's employee job title id value to the value selected within the relevant dropdown list each row in the data grid corresponds to a list item of type employee model stored within the employee data data source for the data grid we are able to access each rows list item object through an object named context provided to us by the sync fusion data grid we can type cost the context object into its underlying type in this case the employee model type using the c sharp as keyword like this and then we can access the property that we wish to bind to let's set the id property of the sf dropdown list component to employee job title id let's set the data source property to the variable that stores the relevant list of type employee job title let's set the t item property to the employee job title type the relevant data source for our drop down list contains a list of items of type employee job title the value that will be bound to the employee data data sources employee job title id property must be of type int so let's set the t value property to end and then within the sf drop down list element let's include a component named drop down list field settings let's set its text property to name and its value property to employee job title id so the name property of the selected item will be displayed to the user in the drop dropdown list and the value of the selected item in the dropdown list will be the selected objects which is of type employee job title employee job title id value let's run the code great so the name of the employee job title is now appropriately displayed within the relevant column so we need to indicate that we want to allow for a user to be able to edit rows within the data grid so to do this we simply include the grid edit settings component within the sf grid element and include a property within the grid edit settings element named allow editing and set its value to true let's run the code and now when we double click a row within our data grid which puts the relevant row into edit mode we are able to change the value for an employee's job title through the use of an appropriate drop down list excellent you'll see later when we perform certain cred operations on the data that the drop down list values are automatically mapped to the employee data data source through the relationship between the employee job titles employee job title id field the employee job titles database tables primary key and the employees employee job title id foreign key field so let's also create a drop down list for the gender field we can implement the code for this using an enum so for this field we don't need to bind a primary key value from one data source to a foreign key value of another data source as we have done for the employee job title id field let's create an enum named gender val and include the appropriate enum list items let's modify the grid column component for the gender field so that a drop down list containing the gender items can be accessed from within the data grid when a row is in edit mode so let's first include the edit template element within the relevant grid column element so before we set the data source property for the relevant sf dropdown list element let's write code that converts the gender enum list items to an array of string values we can use the enum types get names method for this purpose like this then we can set the data source for the relevant sf dropdown list component to the variable that stores the appropriate string array values we can then tell the sync fusion data grid as it were about the type of collection that we want contained within the relevant dropdown list so in this case each item contained within the dropdown list is of type string so we set the t item property to string and the value for each item will also be a string so we can set the t value property to string as well lastly we must set the at bind value attribute to the correct property within the employee model type which is of course the gender property we can access the relevant employee model object pertaining to the relevant edited row through the context object that is made accessible to us by the sync fusion datagrid component let's run the code great we also want to include a drop down list for the report to emp id field in the relevant dropdown list for this field we want to present a list of employees that are either a team leader or the sales manager so in effect we are excluding sales reps from this list because no one in the organization reports to the sales reps firstly let's create a special model within the models folder that represents an employee that can be reported to as it were let's name the csharp class report2model so the first property is named report to amp id and is a nullable integer the reason this field is nullable is because an employee might not necessarily report to another employee like for example bob jones who is the sales manager and is the head of the sales department therefore doesn't report to anyone in the sales department then let's include a string property named report to name let's create a method definition for a method named get report to employee within the i employee management service interface for an asynchronous method that will be responsible for retrieving a list of objects of type report to model let's implement the code for the get reports to employee method within our employee management service class so let's create a link query that returns a list of employee objects so to do this we can join the employee entities employee job title id foreign key field to the employee job title entities employee job title id primary key field so that we can explicitly filter the data based on the names of the relevant job titles in this case the names of the job titles are sm and tl yes we could just use the report to id key for this purpose but i want it to be explicit regarding the employees that need to be included in the returned list based on their job title then we can assign the relevant returned values to the appropriate properties of the report to model type so i'm assigning the report to name property the employee's first name followed by the first character of the employee's last name just for clarity then the way we wire up the code so that the drop down list appropriately appears for our reports to empid field is very similar to the way in which we implemented the code for the employee job title id field so let's first write the code to retrieve the relevant data now let's comment out the code for the current grid column element that is currently representing the report to empid field let's make a copy of the grid foreign column element that we created for the employee job title id field and paste it appropriately above the code that we have just commented out then let's change the settings appropriately for our new grid foreign column element let's run the code and we have an exception thrown and why is that it's because our scenario here is slightly different to the implementation for the employee job title id field with the employee job title id field the value can never be null so the t value property here must be set to end for the report to empi d field the value can be null which means we need to let the syncfusion data grid know as it were that this field can be null so we need to set the appropriate t value property here to nullable end like this remember employees don't necessarily report to anyone as is the case with bob jones who reports to no one he is the sales manager the head of the department so we must make this field nullable so this field can either be set to null or an integer value so that is why we are setting the t value property here to c sharp's nullable end data type let's run the code and that's great but how does an administrator set the drop down list to a null value so to achieve this we want to make a slight modification for this special case so let's go to the get report to employees method within the employee management service class and add a list item that represents a null value to the list of report 2 model items returned from this method let's ensure that the null item appears as the first option in our drop down list so let's order the list by the report to empid property let's run the code excellent so the null value is represented by the text none which is wrapped in angle brackets great the syncfusion data grid is highly customizable for example we can include an image for each employee record that can be displayed within the data grid we can also style the image appropriately using css so i've prepared some image files for this part of the course the image path field in the employees table of our database has been seeded with the appropriate image path for each employee add points to the appropriate image which must reside within the www root slash images slash profile folder so let's create the images folder within our www root folder and then let's create the profile folder within the images folder please download the images from this location on github and then copy the images into the www root slash images slash profile folder great so to include the employees profile image within the data grid let's add a grid column element let's set the header text for our column to profile and let's set the width of our column to 120 pixels we can include an image within this grid column using the template element like this we are now able to appropriately include html code within the template element that will in effect display the appropriate image within the relevant data grid column note how we are able to use razor code here to access the employee model object for each row in the data grid we are able to access the context object for this purpose we can then include the image path field for the relevant employee model object as the value for the src attribute of the image html element that we are including within the template element and that's great the image is displayed within the data grid but it could look a lot better we are able to customize the images displayed within the relevant grid column of our data grid using css so you can see that i've included a css class within the div element that wraps the image element that is used for displaying the relevant employee profile image here we are able to style the image appropriately with basic css code so to do this let's create a style tag here and let's add the dot profile dash image dash container class here let's set the width of the image container div element to 80 pixels and let's also set its height to 80 pixels let's target the image element that is responsible for displaying the profile image and set its width and height properties so that the image fills its container 100 percent let's say that we want our image to be displayed within a circle we can achieve this by setting the image elements border radius property to 50 pixels let's run the code excellent and when we put a row in edit mode our image does not display which is what we want great this is because we haven't wired up the relevant grid column responsible for displaying the employee profile image using the field property to a property within the employee model type we are only displaying a small amount of data within our data grid but if we were displaying thousands of records it is a good idea to display a spinner to the user while the records are loading this provides a better user experience ux to the users of our application to achieve this we can appropriately add the sf spinner component to our data grid like this we can set the spinner components at bind dash visible attribute to a boolean property that we will create in a bit then we can control through this property that we have named visible prop when the spinner is displayed to the user and when the spinner disappears let's set the visible prop property to true before code runs to retrieve relevant data and then to false once the execution of the relevant code has completed our code here is only retrieving a small amount of data so let's introduce an appropriate amount of latency to simulate the delay for the retrieval of a much larger amount of data so let's create a delay of two thousand milliseconds or two seconds great we are just using the default spinner style here but please check out the sync fusion documentation regarding the sf spinner component and you can see how you are able to customize the style of the spinner in many ways to suit your requirement so we can now remove the artificial latency that we have introduced within the uninitialized async method so earlier on in this course we looked at the performance of crud create read update delete operations facilitated by the sync fusion data grid component we can include such functionality by simply adding a toolbar to the data grid like this we must also ensure that we have included the grid edit settings element within the sf grid element then we can set the allow adding property to true so that a user can add employee records to the system through the use of the data grid the allow editing property has already been appropriately included and is already set to true which will enable a user to edit employee records through the use of the data grid we must also appropriately include the allow deleting property and set its value to true so that a user can delete employee records from the system through the data grid so a user can now perform crowd operations through the use of our data grid but as we demonstrated earlier on in this course when we were only dealing with inmemory data we were able to perform the relevant crat operations and the changes made through our crud operations were reflected in the data grid which is excellent but in order to sustain the changes that a user makes through the relevant crud operations done through the use of the data grid we need to customize our data grid a bit further so for example when a user adds a new employee record to the data grid we want the new employee record to be inserted into the employees database table so we have now created our database so we are now working with persistent data which means we can create functionality for our application so that when a user performs crowd operations through the use of the data grid the effects of the crad operations are both reflected in the data grid as well as appropriately persisted to our database sync fusion makes it easy for us to hook into events that are triggered by user actions performed on the data grid and therefore we are able to include our own custom code appropriately within relevant event handlers so that changes made by the user through the use of the data grid are appropriately saved to our database so for example if a user clicks the add button on the data grids toolbar then fills in values for the relevant fields and then clicks the update button on the toolbar which means the user is saving the relevant data to the data grid our custom code can run at this point and save the relevant data to a database table so how do we hook into the relevant data grid events firstly let's create the custom code necessary for adding a new record to our database so let's go to the i employee management service interface and add a definition for a method that will be responsible for adding a record to the employees database table let's implement the logic for this method within our employee management service class so before we do that let's create a convert extension method so that the employee model object passed into our add method can easily be converted into the employee type that can then be added to our employees database table using appropriate ef call functionality notice here for the image path field i'm setting the image for a newly added employee to a default image which is based on the employee's gender then we can simply call the convert method on the employee model object passed into our add method we can then use entity framework core functionality to save the newly created record to our employees database table excellent so now how can we run our code that we have just created to add a new employee to the employees database table based on a user's action performed to add a new employee record to the data grid to achieve this we are able to include a component named grid events within the sf grid element then within the grid events element we can set the on action begin property to an event handler method that we'll create in a bit where we can implement code to call the add functionality that we have just created within the employee management service class so let's create the method that will run when a user performs an action on our data grid note that we are able to use intellisense like this where we can see the method signature or method definition if you like that we need to implement for our action begin handler method ie the method that we have assigned to the onactionbegin property we are able to use the args argument passed to our event handler method when a relevant action is performed by the user on the data grid to assess the exact nature of the user's action so we want to capture the event as it were when a user clicks the update button on the toolbar in order to save new data to the data grid so we can do this by checking the data available in the args argument like this we can check the request type value on the args object we also want to further evaluate the args data to check if the save action occurred after the user performed an ad operation we can do this with this line of code where we are checking if the args argument action value is equal to add so if these two conditions are met our code knows as it were that the user is performing a create operation the user is adding data to the data grid so we can include our create functionality here where we can save a newly added employee record to the employees database table so let's use our employee management service functionality appropriately to add a new record to the employees database table note that the data inputted by the user is accessible through the args arguments data value here so we can pass this value to our add employee method like this before we act as a user and add a record to the database let's include the email field within our data grid we have not allowed this field to store null values in our employees database table so a value for the email field must be supplied when adding a new employee record to the employee's database table so let's adjust the data grid size to accommodate our new column so let's add a record to our database through the data grid so let's say a new sales rep named greg ross has just joined the company so let's add his details to the system and he will report to team leader jenny marks great and greg ross has been successfully added to the system notice that the id value is zero at the moment and no image is displayed for greg ross at present this is because we need to refresh the data in the grid in order for the id value related to the new employee greg ross to be appropriately displayed on the data grid this is also true for greg ross's profile image to make sure our data grid is refreshed with the latest data saved to the database we can hook into another event that fires once the code to add an employee record has completed so to achieve this let's set the on action complete property to a method handler that we are going to create in just a bit let's name our event handler method action complete handler you can use intellisense to see what the method signature or method definition of our event handler method must be so let's create the relevant event handler method we only want our custom code in this case to execute when the user has added a new record let's use the appropriate if statements to check the nature of the user's actions i am currently just checking the request type value for the save action here but we should also include code to check that the action value is set to the literal text add as we have done in the action begin handler method we only want the grid to refresh as it were once a user has added a new employee record through the use of the data grid for the functionality of refreshing the data grid we need to reference our sync fusion datagrid component in our code to do this we can use the at ref attribute and set its value to a property that will store a reference to our syncfusion datagrid component so let's create the property that will reference the data grid in our code here let's apply code to refresh the datagrid's data source with the latest employee data saved to the database by assigning the data source property a list of employee model objects returned by the get employees method that is called on the injected employee management service object and we can call the refresh method on the property that references our syncfusion data grid component like this so currently when we put the data grid into add mode the id field is editable we can explicitly disable this field by including the allow adding property within the appropriate grid column element and set its value to false this is an autoincremented field and we don't want the user to edit this field let's enable sorting for our data grid we can achieve this by including the allow sorting property within the sf grid element and setting its property to true so if we add a new employee named david brown to the system the record has been added and because our code is now refreshing the data once the record has been added the id for the employee that we have just added will have the highest id value in the data grid so the data grid is currently being sorted by id in ascending order the newly added employee record for david brown will currently occupy the last row in the data grid so because we have enabled sorting the user can sort the id column in descending order so we can now see the newly added record at the top of the data grid the employee id saved to the employee's database table is displayed in the data grid and a default image is also displayed for the newly added mail employee and you can see here that i've added a few other records to the system offscreen so let's create the data handling functionality for when a user updates details for an employee record within the data grid and let's also create the functionality for deleting an employee within our employee management service class let's create a method named update employee and implement the logic like this let's create the logic for the delete employee method like this if at any point you get stuck and are struggling to follow along please reference the code on github you are of course welcome to copy the code from the relevant github page great so within the action begin handler method we can include a check to see if an edit has occurred and then apply our database related code appropriately here so for the scenario where a user action triggered the action begin handler method and a save has not been initiated by the user but rather a delete has been initiated by the user we can include an appropriate else if condition in the top if block to check for a delete action we can then apply the appropriate code to delete the relevant record from the database like this we only need the refresh functionality to run when an ad action occurs so please make sure that an if condition is appropriately included within the action complete handler method to check that an ad action has been initiated so that the data is only refreshed within the data grid when a create operation has been completed let's run the code and test that our update functionality has been implemented correctly excellent and we are now able to create employee records within the system and update employee records within the system using our sync fusion data grid we can also delete records from the system like this the effects on the employee data caused by user cred related actions are now not only reflected in the data grid but are also persisted to the employees database table great so one thing of course we need to discuss along with the subject of credit operations is validation so how can we enforce validation rules for the fields of our data grid for when a user is either attempting to add a new record to the system or update an already existing record in the system this is very simple to do those of you familiar with asp.net core razer pages or mvc will no doubt already be familiar with the code that can be implemented here for this purpose to enforce a specific validation rule on a model's property a developer is able to decorate the relevant models property with a specific attribute that indicates to.net as it were which validation rule should be applied to the relevant models property so let's look at this with an example so each row of data in our data grid is of type employee model so if we go to the employee model class we can for example apply the required attribute and therefore the required validation rule to the first name property like this the validation attributes reside within the system.component model dot data annotations namespace so we must ensure we include an appropriate using directive at the top of our code and if when we edit this field in our data grid and we violate the required rule a red border appears around the relevant input field and we are presented with an appropriate error message let's apply the required validation rule for the last name field the email field and the gender field let's apply a special rule for the first name property where the user must enter at least two characters for this field and not be allowed to enter more than 100 characters into this field we can use the string length attribute to enforce this rule let's apply the same rule for the last name property let's declare the email address attribute against the email field to ensure that the user enters an email address that conforms to a valid email address format you can of course create your own custom validation attribute by creating classes that inherit from the validation attribute base clause this functionality is beyond the scope of this course but it is easy to implement you can then apply your own custom validation attributes to the relevant properties so you are able to apply whatever validation rules that are required to any input field within the syncfusion data grid the sync fusion data grid allows a user to export the data displayed within the data grid to an excel spreadsheet you are able to automatically export the data displayed within the syncfusion data grid to an excel spreadsheet or a pdf document with minimal additional code so to enable the user to export the data in the data grid to an excel spreadsheet let's first add an appropriate toolbar button to our datagrids toolbar like this then within the sf grid element let's include the allow excel export property and set its value to true then we are able to hook into an event that is fired when the user clicks a button on the toolbar by setting the on toolbar click property within the grid events element to an event handler method that we'll create in just a bit the implementation for our event handler method is really simple so if the user clicks the excel export button run the sync fusion data grids export to excel async method and look at that excellent let's allow pdf export and let's implement the appropriate code in our toolbar btn click handler event handler method let's of course include a pdf export button on the datagrits toolbar great let's say we wanted to include a button on the data grids toolbar that when clicked executes custom functionality let's say for example we wanted the data in the grid to be exported to a special xml format we can easily achieve this we can create our own custom buttons on the datagrids toolbar using the item model type which resides within the syncfusion.blazer.navigations namespace like this in the interests of time i'm not going to write such xml custom functionality but i'll demonstrate how we are able to include a custom button on the datagrid toolbar and how custom functionality can be executed when the relevant custom button is clicked by the user great we are able to create columns that contain command buttons within our data grid say for example we wanted to execute the edit and delete operations from buttons that appear at the end of each row within our grid rather than through the relevant buttons on the data grids toolbar we can include the grid command columns element within an appropriate grid column element to achieve this we can then include the appropriate grid command column elements within the grid command columns element and style them appropriately like this so now we are able to use these buttons to edit and save our data and we can use this button to delete relevant data excellent we are also able to include our own custom command buttons within the data grid like this we must of course wrap the grid command column elements within the grid command columns element like this excellent and if we choose to handle our updates and delete operations using the command buttons we can remove the relevant buttons from the toolbar great the default mode for our grid is normal mode in normal mode when we edit a row of data in our data grid we edit the relevant fields directly within the data grid itself when we add a new record to our data grid while in normal mode a blank new row appears at the top of the grid and we can input the values for the relevant fields directly within the data grid we are able to edit or add our data using two other modes dialog mode and batch mode let's first discuss dialog mode using dialog mode when a user edits a row in the data grid or adds a row to the data grid a dialog is presented to the user with the relevant editable fields so the user is able to perform the edit or add operation using a separate dialog rather than applying the relevant changes directly to the data grid so to indicate that we want the user to add and edit data using a separate dialog rather than performing these actions directly on the grid for this purpose we must set the mode property of the grid edit settings element to the edit mode dot dialog enum value now when a user adds a record or editor record a new dialog pops up and the relevant operation is done using this dialog we are able to customize the dialog for example we can disable certain fields for add or edit operations like this we can customize the header for example we may want a heading on the dialog to reflect the action that is being performed to customize the header for the dialog we must add the header template element to the grid edit settings element like this then we are able to implement our code to handle the relevant customization functionality great we are also able to customize the footer of the dialog and for example change the captions on the buttons based on the operation being performed then we can hook into the relevant button events and ensure that the appropriate functionality is executed like this the cancel button simply closes the dialog the save button executes the relevant save functionality and then closes the dialogue great you are also able to include the template element within the grid edit settings element to customize the fields and layout of the fields displayed to the user within the dialogue please consult the sync fusion documentation for comprehensive information on how to do this batch mode so let's look at what we are able to achieve using batch mode when our data grid is in batch mode we are able to perform more than one operation on multiple rows of data before saving our data for example a user can add a new record edit a different existing record and delete a record before pressing the update button to save the effects of all three actions at once in batch mode the user's add edit and delete operations can be executed in a batch all at once so to run our data grid in batch mode we simply set the mode property here to the edit mode dot batch enum value let's include the update and cancel buttons within the toolbar of the data grid once again because in batch mode we are going to be able to edit multiple rows so performing the save operation once a batch of operations have been performed by using the appropriate toolbar button seems more appropriate you can see that once we have edited a field and the field loses focus that the background color of the relevant cell is set to green so at a glance the user is able to see which fields in the data grid have been modified before the user saves the relevant data then once the user has finished the batch edit the user can press the update button on the toolbar to save all of the user's changes however this action at the moment will only save the changes to the data grid and will not make the relevant changes to our database so to propagate the changes through to the database we are able to hook into an event triggered by the user's action to save a batch of changes made to the data grid so to do this within the grid events element let's set a property named on batch save to the name of a method that we are going to write which will handle the on batch save event and you can see via intellisense the method definition or method signature if you like of the event handler method that we need to write to handle the on batch save event so let's create this method and let's appropriately name it on batch update handler so through the args argument passed to the on batch update handler method we have access to the records that have been added changed and deleted the logic for our code simply traverses these records and executes the appropriate operations excellent and then of course as demonstrated earlier we are easily able to include functionality like paging in our syncfusion data grid like this if we want to include a maximum of six rows of data per page let's adjust our page size to five we can also easily include grouping functionality into our data grid by including this code in our datagrid component we can include basic filtering functionality for each column in our data grid by including the allow filtering property within the sf grid element and setting its value to true great and we can include more sophisticated filtering functionality for each column in our grid by including the grid filter settings element within the sf grid element and setting the type property for example to syncfusion.blazer then we are able to filter our data by either filtering on one column or a combination of columns in a variety of useful ways excellent so in this part of the course we have demonstrated how we are able to use the data grid for providing sophisticated functionality to the user and we've been able to integrate the sophisticated functionality with ease into our sales management application with clean and easy to read code we have been able to customize the data grid to suit our application's requirement please explore the comprehensive documentation and demo source code provided by syncfusion on their website where you'll be able to delve even deeper into the vast amounts of functionality that can be leveraged through the use of the syncfusion datagrid component so the developer is able to provide extremely rich and powerful functionality with minimal declarative code through the integration of the datagrid into an application please see the code on github for what the code should look like for our particular requirement so in this section of the course we are going to create a facility where sales reps can for example log on to the system when they are on site with a client and order products for the relevant client from a product catalog so for example an outdoor excellence sales rep regularly visits clients of outdoor excellence a client could be a buyer for a retail outlet that specializes in selling outdoor and sports products the sales rep presents a product catalog to the client and the client is able to instruct the sales rep on which products the client wishes to purchase from the product catalog the sales rep can then using the sales management app simply check the check boxes next to the products that the client wishes to order through the app and press a button to order the checked products details of the order are then processed by the system and data is captured regarding for example the order price products date of the order the employee id of the sales rep responsible for the order the client id of the client that instructs the sales rep to make the particular order the location of the retail outlet etc a little bit later in the course we are going to use syncfusion charts to display useful metrics gleaned from the order data that is captured when a client makes an order or multiple orders through the sales management application so in this section of the course basically we are going to create functionality for displaying a product catalog and also facilitate a basic ordering system so that a sales rep can create an order directly from the product catalog for the relevant client so let's first create the display product catalog functionality so let's first create a razor component named product catalog let's use the at page directive to set up the appropriate routing information for the product catalog razer component let's include a link to our new razor component within the nav menu razer file great before we write the frontend code to display the products to the user let's create a products database table and a product categories database table using ef core code first migrations as we have already discussed the products table has a manytoone relationship with the product categories table for example the product category named camping can contain different types of tent products as well as different types of air mattresses the mountain bikes product category can contain many types of mountain bikes so the relationship is one product category too many products or conversely many products to one product category okay so let's create the product entity within the entities folder great let's create the product category entity great let's add the appropriate db set properties to our sales management db context class great let's create a migration and name it add product tables let's run our migration by typing in the update database command and pressing the enter key excellent so let's seed our product categories table and products table with data i've already prepared product related data offscreen so that we can see that database with appropriate product category data and appropriate product data please copy the relevant product seed data code from the github web page at this location a link to this webpage has been included below in the description so let's open the seed data class from within the data folder and let's add a static method named add product data then let's copy the relevant code from the relevant github web page and paste it into our new add product data static method then we can call the add product data method from within the on model creating method of our sales management db context class let's add a migration named seed product data great let's update the database by running the update dash database command excellent so you can see we have an image path for each product row stored within the products database table i've prepared images for each of the products off screen please download these images from this location on github a link to the location is available below in the description of this video then let's create a folder within the www root slash images folder named products and paste the images that we have just downloaded from github within this products folder great so we can now create the database related functionality to retrieve the data related to our products before we create a service for this purpose let's create a product model class this class will serve as the type for each product object displayed on the ui in our product catalog razer component let's create an interface within the contracts folder named i product service let's create a definition for a method that will be responsible for retrieving product data from our database let's create a class named product service where we'll implement the logic for the method definitions defined within the i product service interface let's create a constructor that accepts an argument of type sales management db context an object of type sales management db context will be injected into this constructor at runtime let's generate a field to reference the relevant sales management db context object so before we implement the logic for our get products method let's create an appropriate convert extension method for the purpose of transforming a collection of product objects to a collection of product model objects great we can pass in the sales management db context object to our extension method so that we can join to the product category entity in the relevant link query by doing this we are able to include the product category name in our list of product model data that will be returned to the calling code oops we have a little typo to fix here so let's go to the product model class and fix the issue not decryption but rather description then the code for the get products method is simply this great we want to use the syncfusion list view component to display our product data on the user interface to do this we first need to install the dot syncfusion.blazer.list new get package i see during the development of this application a new version of the syncfusion components has been released we have currently been using version 20.1.0.58 of the syncfusion components so to be consistent let's install version 20.1.0.58 of the syncfusion.blazer.lists nuget package we can always update our installation of our syncfusion components to the latest version at a later time great let's include a using directive that references the syncfusion.blaser.lists namespace at the top of our code in this razor component our code is going to refer to types within the sales management app.entitiesnamespace the salesmanagementapp.services.contracts namespace and the sales management app dot services namespace so let's cut the relevant directive code from the employee management razer component and paste this code within the underscore imports.razer file this means that these directives will now be applicable to all of our razor components let's write code so that a product service object is injected into our product catalog razor component at run time let's create a parent div tag that contains a bootstrap class so that this div represents a row within the bootstrap grid system let's create a div element that contains a bootstrap class to indicate that the content within this div should take up all 12 columns of the bootstrap grid within this div let's create declarative code to include the sf list view component appropriately within our razer component let's write code to override blaze's uninitialized async lifecycle event handler method let's create a variable that will reference the data that we'll use as a data source for our syncfusion list view component this data source will of course contain items of type product model to store the product data retrieved from our database then we can use our product service functionality to retrieve our products data from the database and assign this returned value to the private variable named product data that we will wire up as the data source for our syncfusion list view component so let's appropriately set the data source property of the sf list view element to the product data variable actually let's change our products data variable into a property and capitalize the p in product data great let's not forget to register our product service type for dependency injection great let's include a list view field settings element within our sf list view element like this let's set the t value property within the list view field settings element to product model let's set the id property to id and the text property to name so here we are telling the sync fusion list view component as it were which property denotes the value of a list view item and which property of the list view item which remembers of type product model should be displayed on the ui and there it is our products are displayed neatly within our list view component so of course we are able to customize our sync fusion list view component so that it suits our particular requirement firstly let's say we want our products displayed so that they are grouped by product category we are able to do this by setting the grouped by property in the list view field settings element to the property of the product model type by which we want our list of products grouped so we want to group our products by product category so we can achieve this by grouping by the category name property of the product model type like this great we are able to customize the look of the grouped field through the use of the list view templates component so let's include the list view templates element within the sf list view element let's set the t value property to the type of objects stored in the data source that we have wired up to the syncfusion list view component then we can include code to specifically target the field by which we are grouping the data to do this we can include the group template element within the list view templates element then we can use the context object to reference a particular list item and of course each list item is of type product model we are able to include basic html like this to style the category name property of the product model type and that looks pretty good we can include the template element within the listview templates element to style the list items within the template element we can use html and css to style the fields we want to display to the user for each list item in the list view the sync fusion list view component makes each product model list item available to us in code through the context object so we are able to include which fields from the product model type we want to display in our template using the context object notice that we are using certain sync fusion css classes to style the list view items so before we continue let's use the tostring and net globalization functionality to force the currency to be displayed as u s dollars like this let's set the css class property of the sf list view grid component to sync fusion's elist dash template css class for more detail on the css structure in the blazer list view component please check out syncfusion's documentation regarding this topic at this location a link to this webpage has been included in the description of this video let's also include a class named list view dash template we can customize the style for our list view using appropriate css code let's run the code and i think that looks pretty good so i want to include a checkbox next to every list item so that the user can easily select the products from the product catalog before placing an order to include this functionality all we need to do is add the show checkbox property within the sf list view element and set its value to true excellent with each order made on behalf of a client by a sales rep we also need to include relevant client information so we want to include a combo box that is populated with a list of clients the sales rep can then choose the client on whose behalf an order is created from the combo box before placing the relevant order so firstly let's create a csharp class named client within the entities folder like this to represent the client entity great let's also create a csharp class named retail outlet and include these properties within the retail outlet class this csharp class represents the retail outlet entity the client entity has a onetoone relationship with the retail outlet entity a client works for a retail outlet and serves as the point of contact for an outdoor excellence sales rep let's include the relevant dbset properties so that ef core will include code within our next migration to create the corresponding database tables within our database let's generate the migration code and let's update the database great let's seed our clients and our retail outlets tables with data please copy the relevant code for seeding these tables from the github web page found at this location a link to this page has been included in the description of this video so within the seed data class let's create a static method named add clients let's paste the appropriate code that we have copied from the relevant github web page into the add clients method ok so to be consistent let's rename our add clients method to add client data let's then call the add client data method from within the on model creating method within the sales management db context class let's create a migration named seed client data great let's update the database with our client data by typing in the update database command and then pressing the enter key excellent before we create a service responsible for our client functionality let's create a csharp class named client model within the models folder great let's create an interface named i client service let's create a definition for a method that will be responsible for retrieving client data from the database let's implement the logic for the get clients method within a new class named client service before we do this let's create an overload for the convert extension method that converts a collection of client objects to a collection of client model objects we want to join our client entity to the retail outlet entity within our convert extension method so we must also pass in the sales management db context object within our link query let's join the clients collection to the retail outlets collection so that we can include location related information within the returned list then our code logic for our get clients method is very simple great let's go to our product catalog razor component let's write code to include a syncfusion combo box within the product catalog razer component let's create a property that will reference the data source that we are going to wire up to the combo box let's write code to retrieve the client data from our database within our override method of the uninitialized async laser lifecycle event handler method in order to access an object of type i client service we must write code to inject an object of type i client service into our razor component at runtime we must of course remember to register our client service type for dependency injection within the program.cs class like this then let's set the data source property within the sf combobox element to the client data property let's set the t value property to end and the t item property to client model the t value property setting tells the syncfusion combobox component as it were what data type is used for the value of each item included within the combo box the t item property setting tells the syncfusion combo box as it were the type of each item that is included within the combo box then we can use the at bind dash value attribute to bind the value of the selected combobox list item to a property that we are going to create so let's create a property for this purpose named client id and initialize its value to one we must include an element named combo box field settings within the sf combobox element and then we can define which property of the client model type we wish to display to the user by appropriately setting the text property we can also declare which property denotes the value of the items contained within the combo box by setting the value property to an appropriate property in the client model type let's run the code great and the user is able to type in text that alludes to a particular retail outlet into the combo box and the sync fusion combo box will navigate to a matching item in the list great let's appropriately style our layout and our combo box great let's create a csharp class within the entities folder named order great let's create a csharp class within the entities folder named order item great the order entity has a onetomany relationship with the order item entity one order can contain one or many order items let's add the necessary dbcontext properties so that the order entity and the order item entity are used for creating the corresponding database tables in our database let's create an appropriate migration and let's update the database by running the update dash database command great we don't need to see the data for these tables because we are going to generate the relevant order data through our application let's create a class named order model within the models folder let's create an interface named i order service within the contracts folder let's create a definition for a method that will be responsible for creating order data within our system let's create a csharp class named order service and implement the code logic for the create order method so firstly we need to add an order to the system so let's create an order object and get its property values from the order model object passed into this method as an argument for now we are hard coding the employee id for our orders to nine which is the id of the employee named benjamin lucas who is a sales rep one of the last things we are going to do in this course is integrate microsoft identity authentication and login functionality into our application as part of the login functionality we'll be able to retrieve the id of the loggedon employee so we'll be able to get the appropriate employee id field at this point based on the logged on users details for now while we test our functionality let's simply hard code the employee id field where necessary then we can create code to add the order to the system like this and the add async method returns the order entity saved to the system and this is how we are able to reference the id of the order that has just been added to the database the order entity has a onetomany relationship with the order item entity the order item entity has an order id property which is a foreign key from the order entity so we must insert the order entity into the database and reference the id of the newly added order entity that has just been added to the database this must be done before we add the orders relevant order items to the database each order item must reference the order's id before we add the relevant order items to the database each order item must contain an order id value pertaining to an order that has been added to the database let's create a private method that returns the order item collection where each order item contains the relevant order id value then we can use the add range method to add the relevant order items to the database we also need to sum up the price of all the order items pertaining to the relevant order and sum up the quantity of items that were included for the order like this great so these summing operations are done before the order is added to the database and subsequently the order items are added to the database so let's go to the product catalog.razer file and write code so that an object of type i order service is passed into the product catalog razer component at runtime let's register the i order service type for dependency injection let's include a button that a user can click to create an order in the system based on the product items that have been checked in the list view let's wire up an event handler method that we'll create in a bit for the purpose of handling the relevant button click event in this case the logic for the event handler method will entail collating a selected list of products i.e the products that have been checked in our list view and passing the list of products which denotes the order items in the client's order to the relevant order service functionality so let's create the create order event handler method so in order to get the selected product items from the list of products we need to be able to reference the sf list view component in code so we can use the at ref attribute for this purpose when the create order button is clicked by the user our code for creating the order is fired so let's write the code for the relevant buttonclickeventhandler method that carries out the task of creating an order in the system we are able to use a variable of the generic type selected items that is strongly typed with our product model type to reference the objects of type product model that pertain to the items in the list view that the user checks which means these products will become part of an order when the user clicks the create order button we can use our sf products lv object that is referenced within the sf list view element to get the checked list items by calling the get checked items async method on the sf products lv object each of the checked product items will become the basis for an order item we can use the order model type to create an object that contains relevant order information and the relevant order item collection note that each checked product is the basis for an order item then we can pass this data as an argument to the create order method like this let's test the code great but the order id in the order items table is zero for our order so it doesn't correctly relate to the order that we created which is incorrect let's investigate what went wrong here oh i can see what the problem is we must include a line of code to save our changes when we add an order to the system so this is ef core functionality whereby the save changes async method must be called after an entity is added to the database table so we must call the ef cause save changes async method like this after the code that adds the relevant entity to the database is executed so i'm going to delete the incorrect data that we have just inserted into the orders table and the order items table using the sql truncate table statement within sql server management studio by using the truncate table statement instead of simply deleting the data the primary key columns will be initialized back to zero so let's try again excellent we now have the correct order id value being inserted into the order items table however the date for the order dates time column is not correct so let's truncate the orders and the order items table again let's go to our order service class and we can easily correct this issue by setting the order date time property here to date time dot now which denotes the current date and time so that's great we are able to create our order but currently the user has no way of knowing if the user's order has been successful so we need a way to notify the user as to whether the user's order has been successful or unsuccessful let's use syncfusion's toast component for this purpose so once a user places an order we want a message to pop up like toast informing the user whether the user's order has been successful or unsuccessful so to install syncfusion's toast component let's rightclick the dependencies node in visual studio's solution explorer window and select manage new get packages in order to invoke the new get package manager window let's go to the browse tab and search for toast the syncfusion.blazer.notifications new get package appears in our list and this is the package we want to install so let's install version 20.1.0.58 there is a later version but we can always update our packages to a later version at a later stage let's keep our package versions consistent and install version 20.1.0.58 let's add a using directive that references the syncfusion.blazer.notifications namespace to our product catalog razer file so in the syncfusion demo documentation at this location i've found the functionality that i want to incorporate into our application so i'm simply going to copy the code from this syncfusion documentation and integrate it into our product catalog razer component let's copy the code for the sf toast component from the syncfusion demo code here and paste it into our code here let's include this code that has a variable that we'll use to reference our sf toast component and a variable used for positioning our toast object on the screen let's include the code here where a list is created containing various toast types for example for success and error scenarios let's grab all of this code used for the styling of our toast and appropriately paste it into our product catalog razer file then we can create the code for showing our toast within our create order method like this so if our code reaches this line here it means the order has been processed successfully so let's write codes to pop up the toast that represents success note that off screen i have changed the success message to a message more appropriate for our requirement so this message now reads your order has been created successfully let's test the code excellent let's include the code that represents that our order has failed within the catch section of our try catch block to test this error scenario let's include a line of code that forces an exception to occur and we are now handling the exception with our toast so we don't want to throw the exception here so let's comment out this line of code here let's test the code excellent let's remove the line of code that we have included to force an exception to occur the last piece of functionality i'd like to add for our product catalog razer component is so that the user is able to filter the products in the catalog while typing in text within a text box above the list view component so let's include a syncfusion text box in a row just below our syncfusion combo box here in our code like this let's bring in the namespace of where the syncfusion text box resides the syncfusion.blazer.inputs namespace to filter our list view by product name as the user types text within our sync fusion text box we can use the input property in the sf text box element and wire it up to an event handler method that we'll create in just a bit let's first create a variable named product collection filter that will be used to filter our product list let's write code to assign the list of products stored within the data source of our sync fusion list view component to the product collection filter variable within the uninitialized async method and the code for our on input event handler method should look like this our code is filtering the product collection filter list every time a user enters a character into the sync fusion text box then we are assigning the result of the filtering operation to the data source of the syncfusion list view component which is the list stored in the product data property and that's great all works as expected but there are certain layout and styling concerns that need attention so let's address these issues just a reminder the full code is available on github a link to the relevant repository is available below in the description of this video and that looks great and let's press f12 while using our chrome browsers to see how this looks on different screen sizes great our front end code is fully responsive excellent so at this stage in the course we have created functionality where sales reps can place orders on behalf of their clients this order data that is being captured can be very useful for sales reps team leaders and the sales manager for analytical purposes for example from the captured data a sales rep can see how well the sales rep is performing and see which products are generating the most sales a team leader can see how well each of the team leaders team members are doing relative to one another and see how well the team leaders team is doing overall the sales manager can see how well the sales department is doing overall the sales data can be aggregated by location and over a period of time as developers the challenge is to present the relevant analytical data in a human readable way to the user so the user can derive useful knowledge when analyzing the relevant data sync fusion has created excellent chart components that address the issue of presenting analytical data in an aesthetically pleasing and human readable way it's like the old adage says a picture speaks a thousand words these charts are highly sophisticated and easy to implement they are easy to integrate into our code so in the first part of this section of the course we are going to create a razor component that displays three basic charts using appropriate syncfusion chart components this is so that we first gain a basic understanding of how a developer can harness the power of the syncfusion charts in a razer component we'll then progress further and create a dashboard for each type of employee in the sales department each dashboard will be implemented as a razer component we'll create a dashboard for the sales reps that presents three sync fusion charts with data that is relevant to sales reps we'll create a dashboard for team leaders that presents three charts with data that is relevant to the team leaders and lastly we'll create a dashboard for the sales manager that presents three charts with data that is relevant to the sales manager we'll implement code for three different types of popular charts bar charts donut charts and line charts before we build the dashboards let's create a temporary razer component so that we can gain a basic understanding of how to use the relevant syncfusion charts in this razor component we'll implement the code for three types of charts a bar chart a donut chart and a line chart so let's create a razor component named charts let's create an appropriate link within the nav menu razer component before we implement code for our charts it would be a good idea to consolidate our order reports data into one database table so we are going to create a denormalized table in our database to store our analytical data i.e the data we are going to wire up to our charts let's see what wikipedia says about denormalization denormalization is a strategy used on a previously normalized database to increase performance in computing denormalization is the process of trying to improve the read performance of a database at the expense of losing some right performance so for the transactional database tables where the tables are written too frequently our database designed for these tables is based on the strategy of normalization which we briefly discussed earlier so basically by creating a denormalized table for storing the analytical data we are eliminating the need for creating a lot of joins when implementing our link queries for the purpose of retrieving the relevant analytical data from the database to be displayed within our charts by querying a denormalized table we eliminate the need for these joins and our link queries will be a lot simpler our code will be easier to read and the process of retrieving the relevant data will be a lot more efficient the technique of denormalization is often used in olap online analytical processing applications the details of olap are beyond the scope of this course very briefly in olap applications data can be organized into data cubes which makes the retrieval of aggregated data derived from multidimensional criteria efficient the data does not need to be retrieved from the transactional database tables that have been designed using normalization so basically this eliminates the need for including joins within the queries for retrieving the relevant analytical data from the database so our application is not an olap application but some of the principles that are used in the creation of an olap application are relevant to how we are going to implement our analytical functionality in our application we are essentially going to organize the data that will be displayed on our charts into appropriate shapes using appropriate link queries that will be used for querying our denormalized table i.e the sales order report database table the relevant results of the link queries will then be wired up to the relevant syncfusion chart components if this is unclear to you at the moment don't worry this will become clearer as we create the relevant code so say for example we want to create a report for total sales quantity broken down by state or location the aggregated data quantity of sales is derived summed up by the location dimension so within our data we have the concept of dimensions and measures the dimension here is the location and the measure is the quantity of sales which is aggregated summed up by location so if we add another dimension this will of course effect the aggregated data for example a period of time could be our other dimension for example we could further aggregate the data by the months of the current year displaying such data in a chronological order by months shows progress or lack of progress in terms of sales performance over a period of time per location so the aggregated data is the quantity of sales the measure and the dimensions of the data are the period by month and the location by state so let's create the code for generating our denormalized database table let's create a class within the entities folder named sales order report this model is going to have quite a few properties so just a reminder you can copy the relevant code from github if you'd prefer rather than follow along with me as i create the properties for this class and you can see that we are including fields from the relevant transactional database tables each row in the table we are about to create will denote an order item in each row in this table in addition to the order item information we are also including for example the relevant client information i.e the client responsible for the order the employee information i.e the sales rep responsible for creating the order in the system the order date time the location where the order was initiated etc any information that we may wish to include in our analytical data is being included in this table the table is denormalized a lot of the data is going to be redundant in other words the data is repeated in each of the rows whereas in a normalized structure the normalization process serves to eliminate data redundancy and increase data integrity great so we have created our class that represents the sales order report entity let's create the appropriate db set property within the sales management dbcontext class let's generate a migration and let's update the database the next step is to appropriately include code to add relevant order information to our sales order reports table when an order is created note that in an olap application relevant analytical data wouldn't necessarily be captured in the database in real time i.e as the order is created in an olap application the data may be collated from for example the relevant transaction databases and transferred over to a separate database in a separate process that runs for example once a day in the early hours of the morning the data for analytical purposes could for example be stored in a data warehouse for the sake of simplicity in our example we are simply going to capture the data into our sales order reports table at the time at which the order is processed let's create a private method for inserting the relevant data into the sales order reports table in the interests of time i'm going to paste the relevant code that i've prepared offline into our private method please feel free to copy the code for this method from the relevant github web page then we can call our update sales order reports private method after the order data has been inserted into the relevant transactional database tables i.e the orders table and the order items table so we could run this in an ef core transaction so all three processes i.e inserting data into the orders table the order items table and the sales order reports table are executed in one process i.e if one process fails then all processes fail i won't implement this code as a transaction at this point but this is something that can easily be done here using ef core functionality i have however included the relevant transaction code in the version of the code that resides in the github repository that stores the code for this application please see a link to this repository below in the description so let's run the code to see if our order data is being captured in our sales order reports table excellent before we create the code for our charts in our razor component let's remove the data from the sales order reports table the order items table and the orders table so let's create report related models that will serve as the types for the objects that store the data for specific reports let's first create a folder within the models folder named report models within the report models folder let's create a class named grouped field price model this model represents the type for an object that stores aggregated price data for a particular grouped field that will be specified in the relevant link queries used for querying and shaping the returned analytical data let's create an interface named i sales order report service let's create a method definition for a method named get employee price per month that is responsible for returning analytical data for a particular sales rep and show the employees gross sales broken down by month for the current year the first chart we are going to create will be a bar chart that displays the gross sales value per month for the logged on employee the sales rep we are only going to create the relevant login functionality toward the end of this course so for now we are going to hard code the relevant employee id to nine which is the id for the sales rep named benjamin lucas in our employees database table let's implement the code logic for our i sales order reports service interface in a class named sales order report service so in the get employee price per month method let's create a link query that returns the gross sales per month for benjamin lucas note that i haven't specified the year in this query we are going to assume that the data in our database only applies to the current year note that i have included the relevant filter code in the where clause in the version of the code that resides in the relevant github repository ie to filter the relevant data by the current year great and that is our query we are ready to create the code for our first chart which will be a bar chart so let's go to our charts razer component let's first install the relevant nuget package so in order to use the syncfusion charts we must install the syncfusion.blazer.charts nuget package let's choose version 20.1.0.58 to keep consistent with the versions of the other syncfusion components we can always update our components to the latest version at a later stage let's include an appropriate using directive at the top of our code to reference the syncfusion.blazer.charts namespace let's create a div container element where our sync fusion chart will reside let's override the uninitialized async blazer lifecycle event handler method let's create a list property that stores objects of type grouped field price model the grouped field price model type resides in the sales management app.models.report models namespace many of the types that we'll create within the sales management app dot models dot report models namespace will be used across other razor components so let's create an appropriate using directive that references the sales management app dot models dot report models namespace within the underscore imports.razer file let's write code so that an object of type i sales order report service is injected into our razor component at runtime let's appropriately call the get employee price per month data method on the sales order report service object and assign the returned data to the appropriate property let's register the i sales order report service type for dependency injection within the program.cs class let's create the code for our first syncfusion chart let's give the title property of the sf chart component a value of sales gross forward slash month let's include the chart primary x axis element within the sf chart element let's set its value type property to syncfusion.laser.charts.valuetype.category let's include the chart series collection element within the sf chart element let's include a chart series element within the chart series collection element we are about to set the data source property for the chart series element but before we proceed with this let's rename the property that stores the data source data to a more appropriate name right let's set the data source property of the chart series element to our grouped field price data property let's set the xname property to the grouped key field property name of the group fieldpricemodel type let's set the yname property to the price property name of the grouped field price model type lastly let's set the type of our chart to bar chart we can do this by setting the relevant type property like this let's run our code and that is what i would expect seeing as we don't yet have any data in the sales order report database table so we are now able to insert data into the sales order reports database table through our application so let's do that let's click the products nav menu link and let's use our ordering facility to place an order great and let's now invoke the charts razor component and the relevant data is now displayed on our bar chart we don't have a lot of data yet so our chart is not displaying a lot of information let's create a few more orders to generate more report related data in our database to make our data more interesting let's go into sql server management studio and modify our order data so that our data reflects that some of the orders were made in different months of the current year great and our bar chart looks a lot more interesting now great so we have created our first chart which is a bar chart let's create a donut chart i love these charts but in particular i love doughnut charts let's first create a model in our report models folder let's name this model grouped field qty model let's create a new method definition within our i sales order report service interface named get qty per product category that will be responsible for returning data reflecting the quantity sold by an employee for each product category let's implement the code logic for the get qt wiper product category method as you can see we are grouping the data by product category here in our link query we should include a where clause that filters the query by the employee id of 9 benjamin lucas's id but these sort of specifics don't matter at the moment because everything currently has been done by benjamin lucas as we have hardcoded this id for the order capture functionality so we are assuming benjamin lucas has logged onto the system and is viewing data pertaining to his sales let's go to our charts.razer file let's create a property that will be the data source for our donut chart let's use our sales order service object to return the data for our donut chart from the database to our razor component so let's create the code for our donut chart so in order to do this let's include syncfusion's sf accumulation chart element in our code like this as you can see the code is very straightforward we include the appropriate elements declaratively in our code with the appropriate settings regarding how we want our donut chart to look let's set the data source property to our grouped field qty data property we can then declaratively set the dimension for our analytical data we must set the xname property of the accumulation chart series element to the grouped field key property of our grouped field qty model type we must set the y name property to the qty property we are able to customize our chart through various settings please view the comprehensive documentation provided by syncfusion for more detail on the chart components we are just scraping this surface here you are able to customize your charts in various ways the functionality in the sync fusion charts is very sophisticated and as you can see syncfusion has made it very easy for developers to leverage the sophistication of the charts through the implementation of simple declarative code let's run the code and see what our donut chart looks like excellent and we can at a glance see how many products benjamin lucas has sold for each product category great let's create another type of chart a line chart so let's first create the functionality to retrieve the data for our line chart let's create a definition for a method named get qty per month data which will be responsible for retrieving data representing the quantity of products ordered through benjamin lucas and the data is broken down by months of the current year we can reuse our grouped field qty model type for the objects in the list returned by this method let's implement the logic for our new method so the code structure for our new method is very similar to the code structure for the get employee price per month method so let's start by copying the code in the get employee price per month method and pasting it into our new method so we are grouping the data by month and summing up the quantity of sales made for each month this analytical data applies to the sales rep benjamin lucas so we are filtering the data by his employee id of nine let's go to the charts razor component and wire up the line chart with the data retrieved using the sales order service object let's rename the data source for our donut chart to a name that is more descriptive and let's name the property that will store the data for the line charts data source qty per month data let's also change the name of the property that stores the data for the data source of the bar chart to a name that is more descriptive okay so let's write the code that retrieves the data for the line chart and assign it to our new property qty per month data so the code for our line chart is very similar to the code for our bar chart the first chart we created note however that we are setting the type property in the chart series element to chart series type dot line to make our data more interesting let's place a few more orders let's go into sql server management studio and alter the months of the order date time field for some of our captured data so we have a better spread of our data as it were across more months let's look at our charts and that data looks a lot more interesting let's look at our line chart excellent our line chart looks great you can see the quantity of sales made by benjamin lucas broken down by the months of the current year excellent so these charts look great but our layout for the charts could use some attention let's build our first dashboard for the sales reps where these charts will be presented in a great looking layout appropriate for a dashboard we are going to use syncfusion's sf dashboard layout component to implement the layouts for our dashboards let's create a razor component named sr dashboard the sr stands for sales rep let's create an appropriate route directive at the top of the razor file using the at page directive let's include an appropriate link within the nav menu razer component if we navigate to this syncfusion web page that can be found at this location a link to this location has been included below in the description we have the source code for a layout that would be appropriate for our requirement so if we click the source tab here let's copy this code and paste it into our sr dashboard razer file we don't have a sample base component class and we don't need this inherits sample base component line of code here so let's remove it for our requirement we don't need the using theme helper line of code either so let's remove it and you can see that we need to install syncfusion's sf dashboard layout component so let's invoke the new get package manager window from within visual studio let's search for syncfusion.blazer.layouts and this is the package that we want to install let's install version 20.1.0.58 let's run the code great so these are obviously not our charts but are the ones that are provided in the syncfusion demo documentation so the next step is to replace the charts currently displayed within the sr dashboard razer component with our charts so let's appropriately copy the chart related code from our charts razer component over to the sr dashboard razer component let's first override the uninitialized async method and copy and paste the code for retrieving the relevant data from our database ie of relevance to the sales reps analytical data right so let's appropriately replace the code for the charts with our charts code let's start with the bar chart okay so we have a few chart references in the sample code here let's include a reference to chart 1 within our bar chart component to fix this issue great let's modify the heading in our layout pertaining to the bar chart to something more appropriate let's copy and appropriately paste the code for the donut chart into our sr dashboard razor file great and lastly the line chart let's include a reference within our line chart to chart two as the sample code that we have copied from the syncfusion demo documentation uses a reference to chart 2 in code excellent if you have missed a step during this section of the course and something isn't working as expected please refer to the code in the relevant github repository and look at how easy it has been to generate a sophisticated dashboard using the appropriate sync fusion components and we can now watch our charts change appropriately as we place more orders through the system excellent and let's remove the data related code that is not relevant to our functionality that we copied from the syncfusion documentation we are now of course using the data from our database for our charts we have effectively created the dashboard functionality for our sales reps and we can now delete the chartsrazer component from our project great so we have removed the chart.razer component note that offline i have changed the employee management link label to admin so we have just created a dashboard for our sales reps let's create a dashboard for team leaders all of our dashboards will have the same layout but of course the charts will be different depending on whether the logged on user is a sales rep team leader or sales manager so each employee will only see one dashboard when the employee logs on to the system when a sales rep logs onto the system the sales rep will see a link presented within the main menu of the sales management application that points to the sr dashboard component when a team leader logs on to the system they'll see one dashboard link in the main menu but when their dashboard link is clicked the tl dashboard razer component will be invoked we are going to create the code for the tl dashboard raiser components in this section of the course we'll then create the sm dashboard which will only be made available to the sales manager so let's first create the data retrieval functionality for the reports relevant to team leaders let's open the i sales order reports interface and create a definition for a method named get gross sales per team member data which will be responsible for returning data containing the gross sales value for each team member the data retrieved by the relevant method will be displayed on a bar chart let's implement the code logic for this method definition so i'm just going to move this method to the bottom here so as to separate the team leader related data retrieval functionality from the sales rep data retrieval functionality so the reports pertaining to team leaders will relate to data related to their team members so let's firstly create a private method that returns a collection of employee ids pertaining to each team member that is a member of the logged on team leaders team let's name our method get team member ids and this link query simply returns a list of relevant employee ids to the calling code so let's call our get team member ids method from within our get gross sales per team member data method then we can filter the data so that the data is only relevant to the logged on team leaders team members in the where clause of our link query for now we are hardcoding the team leader's id to 3 which pertains to the employee henry andrews so for now data will only pertain to the team members that belong to henry's team note that benjamin lucas is part of henry's team so when we create orders under benjamin lucas henry andrews will as it were be able to see the relevant changes to his analytical data let's group the team members by their first names i know that this is not ideal because you may have special cases where two or more team members have the same first name for the sake of the example we are going to assume that team members have unique first names let's go back to our i sales order reports interface and create a definition for a method named get qty per team member data responsible for returning the quantity of sales for each team member the data relevant to this method will be displayed on a donut chart let's implement the code logic for this method in the interests of clarity i'm going to copy the code for our new method just below the other team leader related method the code for this method is similar in structure to the previous method we wrote so let's copy the code from the previous method that we wrote related to team leader analytical data and paste it into our new method and then let's change the bits that are different the aggregated data in this case is based on the sales quantity rather than gross sales value the summed up quantity value is of type integer and not decimal so we can remove the code here where we are rounding off the relevant value to two decimal places lastly let's create a definition for a method named get team qty per month data this method will be responsible for retrieving the quantity of sales pertaining to the team itself overall and the data will be broken down by the months of the current year the data for this will be displayed on a line chart let's implement the logic for the get team qty per month data method let's create a razor component named tl dashboard we are going to use the same layout for all three of our dashboard razer components so let's start by copying the relevant code from the sr dashboard component and pasting it into our tl dashboard razor component like this then let's change the code so that the data for the team leader related reports data is retrieved using the sales order report service object the first two charts the bar chart and the donut chart are very similar to the first two charts that we created in the sr dashboard razor component so let's adapt the existing code for these charts for the data pertaining to a dashboard appropriate for team leaders like this for now let's focus on the two charts and we'll implement the code for the line chart the third chart in a bit so before we run the code so as to look at the bar chart in the donut chart for team leaders let's delete the line chart we'll deal with the line chart appropriately in a bit right let's run the code the last chart had a at ref attribute pointing to chart two so let's remove the reference to chart two from our code for now let's run the code great the charts are displaying data for only one sales rep at the moment because the data is reflecting the fact that only benjamin lucas has created orders in the system for the team leader henry andrews let's modify the data a bit within sql server management studio to reflect that other members of the team led by henry andrews have also created orders in the system so to do this let's go to sql server management studio and modify the data in the sales order reports database table accordingly if we look at the employees we can see that olivia mills benjamin lucas sarah henderson and noah robinson are members of the team led by henry andrews the report's two empire d field contains the value of three for these employees which is the id value pertaining to the employee record for henry andrews so let's open the sales order reports database table within sql server management studio and update the data so that it looks like the other team members have also created orders within the system great let's implement the code for the line chart here like this this is essentially the same code implemented for the line chart in the sr dashboard file the only difference is we need to change the data source property to point to the relevant team related data so let's change the data source property appropriately for the line chart let's run the code excellent let's create an order through our application and see how this affects our charts excellent let's create the data retrieval functionality for our sm dashboard razor component so we are creating the dashboard functionality for the sales manager so the bar chart and the line chart are going to be more complex for the sales managers dashboard we are adding another dimension to the data this means we need to create appropriate new model classes for the sales manager reporting functionality so let's create a model within the report models folder named location product category model so we are going to group by location and pivot the data so that the quantity of sales can be reflected on our bar chart for each product category so to do this we first include the column by which we are going to group the data then we can include columns denoted by properties for each of the product categories in our system so mountain bikes road bikes camping hiking and boots let's create a model named month location model so with this model we are shaping the data where the relevant collection of data is grouped by month of the date when the relevant orders were made and as it were pivoting on the location of where the orders were made let's open the i sales order reports interface and create the relevant method definitions let's create a definition for a method named get qty location product cat data this method will be responsible for retrieving the summed up sales order quantities by location and product category a bar chart will be used to display this data let's create a definition for a method named get qty per location data this method will be responsible for retrieving quantity of sales data grouped by location a donut chart will be used to display this data let's create a definition for a method named get qty per month location data this method will be responsible for retrieving quantity of sales data grouped by month and location great let's implement the logic for each of these methods great let's create a razor component named sm dashboard let's start by copying the relevant code from the tl dashboard component and pasting the code into our sm dashboard component like this let's remove the current chart related code from our sm dashboard.razer file let's appropriately update the data retrieval related code so that the appropriate data is retrieved for our sm dashboard component so you can access the code for the sm dashboard razer file on github at this location we are going to add the code for each chart one at a time so we can copy the relevant chart code from this github web page and paste it into the sm dashboard.razer file when appropriate let's start with the bar chart so let's paste what we have copied from the relevant github web page here please feel free to copy the code from the relevant github web page a link to the webpage has been included below in the description let's include a width property for our bar chart you can see here that each chart series for our first chart pertains to a product category so for each chart series element we are setting the xname property to location this is the property on which our code is being grouped the y name property is set to the relevant product category so we are declaratively telling the fusion chart component as it were about the dimensions of our analytical data we can adjust the maximum property so that it suits the sales quantity values that we currently have saved to our system we could bind this property to a calculated value so that the chart adjusts appropriately in response to greater quantities of sales saved to the system then we are also able to set the interval for the yaxis here again this property could be set to a property value that is calculated on the fly so that the chart automatically adapts appropriately in response to the values saved to the database i've appropriately altered the data through ssms a bit offline don't be afraid to play around with the data in the sales order report table to see how the data affects the charts the code for the donut chart is fairly basic the code for the donut chart is structurally the same as the other donut charts that we have implemented in this course great so i'm just going to paste the code in here for the line chart please feel free to copy the code from the relevant github webpage for the implementation of the line chart and look at that that is excellent let's alter the data a little bit so that the relevant order data pertains to more months of the year excellent please consult the sync fusion documentation for more details about the charts we are only scraping the surface here these charts are fantastic and can be customized in many ways to suit your requirements syncfusion has provided excellent comprehensive documentation on how to customize the charts there are also many other types of charts that can be used in your applications so please dive into the syncfusion documentation i think you'll be amazed as i am as to what can be accomplished using the syncfusion chart components and you can see that the syncfusion layout component and the chart components are fully responsive on smaller screens excellent in this section of the course we are going to integrate syncfusion's diagram component into our application through the syncfusion diagram component we are going to implement functionality so that the sales manager is able to see the hierarchical structure of the sales department each node in the diagram contains a profile picture of the employee as well as basic information about the employee to create this functionality we'll integrate the syncfusion diagram component into a razor component the sales manager will be able to invoke the relevant razer component from the main menu of the application and at a glance see basic information about each employee and the employee's position within the organization the sales manager has admin privileges so is able to access the employee management component and can use the syncfusion data grid to change employee details so the sales manager can use the data grid to shuffle around team members for example change who a particular sales rep reports to ie change the team members team leader the sales manager can then invoke the razer component containing the sync fusion diagram that displays the organizational structure and the change made to the organizational structure using the data grid will be reflected in the diagram component so let's start by creating a model named organization model within the models folder this model supports data for relevant employee details and provides a way for each object in a list of objects derived from this class to appropriately reference other objects of the same type in a way that a list of objects of this type can represent a hierarchical structure for example the reports2id property will either store an empty string or an employee id if the reports2id property stores an empty string this means that the employee that the relevant object represents is the head of the organization and doesn't report to anyone when the reports to id property for an object stores an employee id this means that the relevant employee that this object represents reports to the employee whose employee id is referenced by the reports to property of the relevant object so in this way each object of type organization model stored in a list of objects of this type can be appropriately related to one another to form a hierarchical structure in a bit you'll see how we are able to wire up a list containing appropriate objects of the organization model type to the sync fusion diagram component and the syncfusion diagram component does all the heavy lifting as it were to display an aesthetically pleasing hierarchical structure containing all the employees of the organization to the screen let's create an interface in the contracts folder named i organization service let's create a definition for a method named get hierarchy that will be responsible for retrieving data representing the employee hierarchy for the sales department ie will return a list of objects of type organization model let's implement the code for the get hierarchy method let's first write an appropriate convert extension method within the conversions class so to be explicit i'm going to name our extension method convert to hierarchy this extension method simply converts data retrieved from the employees database table which is appropriately joined with records retrieved from the employee job titles table to a list of objects of type organization model then the implementation for the get hierarchy method is this simple code here let's create a new razor component named organization let's provide the appropriate routing information at the top of the razer file and an appropriate link within the nav menu.razer file so let's navigate to this webpage in the syncfusion documentation here we have the organizational tree structure that we want to implement within our application so let's go to the source code for this demonstration and let's copy the relevant code to our clipboards let's appropriately paste the code copied to our clipboards into our organization.razer file so we can see lots of squiggly lines this is because we haven't yet installed the syncfusion.blazer.diagram nuget package so let's do that let's install version 20.0.1.58 so as to be consistent with the versions of the sync fusion components that we have currently installed excellent let's write code so that an object of type i organization service is injected into our razor component at runtime let's make sure that we register the relevant eye organization service type for dependency injection let's write code to override the uninitialized async blazer lifecycle event handler method let's create a property for storing the data retrieved from our database that represents the organizational structure for the sales department then let's write code within the uninitialized async method using our organization service object to retrieve the relevant data from our database and now let's wire up the data source property appropriately in the data source settings element to the organization data property that stores a list of organization model objects retrieved from our database let's let the sf diagram component component know as it were which property in the data source contains the id value and which property in the data source contains the parent id value the parent id represents the id of the employee that the relevant employee reports to the id of the relevant employee in the data source is set to the employee id property so this is how the syncfusion diagram knows as it were about the parentchild relationship that represents the employees in the organizational structure which is of course essential information for displaying the relevant data structure as a hierarchical structure the next step is to define what information about the employee will be presented in each node on the hierarchical tree structure so within the node template element let's include the following information the employee's first name the employee's id the employee's job title we want each node to contain the employee's profile image we don't have a sample based component base class so let's remove this line of code at inherits sample base component then let's remove the code within the node template element that we brought over from the demo code provided in the syncfusion documentation that is not relevant to our requirement like this let's run the code that is awesome we are able to navigate around the diagram that represents our organizational structure and view the individual nodes more closely we can use the control plus and control minus keys to zoom in and out so that we can get a broader view of the organizational diagram or zoom in for a closer view of for example the individual nodes i.e the information of the individual employees within the organizational structure excellent we don't necessarily need to display the tree from top to bottom like this we are able to configure our sf diagram component component to display from left to right by adjusting the relevant setting like this and we can go over to the employee management razor component and pretend we're the sales manager and use the sync fusion data grid to change the hierarchical structure of our organization excellent let's clean up our code and remove the data related code that we brought over from the demo source code we are now using our own data within the organizational tree structure that is displayed through the sync fusion diagram component excellent we have been able to harness the sophisticated functionality provided by the syncfusion diagram component easily and efficiently all we needed to do was wire up an appropriate data structure as the data source to the syncfusion diagram component let the syncfusion diagram component know as it were about the specifics of the parentchild relationship in our data structure and customize the nodes presented by the diagram component to the ui we are just scraping the surface of what can be achieved using the syncfusion diagram component please check out the comprehensive documentation provided by syncfusion to further explore what can be achieved so let's say we want to integrate functionality for the employees of the sales department so that they can for example schedule appointments with other employees or for example schedule client meetings to implement this functionality we are going to integrate syncfusion's scheduler component into our application let's start by creating a razor component named appointments let's install the syncfusion scheduler component so to do this let's install the syncfusion.blazer.schedule nuget package let's install version 20.1.0.58 so that it is consistent with the versions of the other nuget packages that we have installed great let's navigate to this url in our browsers here you can see we have demo source code provided by syncfusion that demonstrates some of the core functionality that we can leverage using the syncfusion scheduler component let's go to the source code of the demo and copy the relevant code like this into our clipboards let's paste the code copied to our clipboard appropriately into our appointments.razer file let's open the navmenu.razer file and include an appropriate link to our appointments razor component and when we run our code and navigate to our appointments razor component we can see that right out of the box we have sophisticated functionality already operational we are already able to add appointments to our scheduler at a date and time of our choosing we can of course edit and delete the appointments too let's modify the current date for our scheduler to today's date so you are able to add an appointment to the scheduler by invoking the most basic dialog by clicking an appropriate cell representing a date and time i.e a date and time at which you wish to schedule an appointment you are able to doubleclick a cell to invoke a dialog where you are able to enter more detailed information about the relevant appointment you are able to easily change the view of the scheduler for example you may wish to see all your appointments for the week you may wish to view your appointments in an agenda format you may wish to view only appointments for the work week monday to friday or for the month so right out of the box we can harness some very useful functionality at the moment however we are only able to save our appointments to the scheduler component where the data only exists in memory we need a way that we can save our appointments to our database through the functionality provided to us by the syncfusion scheduler component we are able to apply our own custom code that will execute when certain events are fired based on user actions performed by the user using the syncfusion scheduler component so we can for example implement code that handles crud operations so for when a user performs certain crud operations our code can hook into certain events as it were triggered by user actions and ensure that our custom code runs when these events are triggered in this way we are able to persist any changes made regarding appointments on the user's scheduler component appropriately to our database so to do this let's start by creating an appropriate table within our database we are of course going to use codefirst migrations to achieve this so let's start by creating an appropriate csharp class within the entities folder let's create a class named appointment let's create the relevant properties for our appointment class these properties are appropriately included for our appointment database table based on the structure that is used by the syncfusion scheduler component to represent an appointment in the scheduler component so we want our code to be able to easily retrieve the data for an appointment created by the user through the scheduler and save the relevance data to our appointments database table note that some of these properties are nullable this is important because this gives the user the ability to fill in data for the relevant fields regarding a particular appointment and other fields that are not relevant to a particular appointment can be set to null let's include the appropriate db set property within our sales management db context class let's create a migration and let's run the update dash database command great let's create a class within the models folder named appointment model we can simply copy the properties from the appointment entity to our appointment model class let's create an interface named i appointment service let's create a definition for a method named get appointments responsible for retrieving all of the appointments for the logged on employee let's create a definition for a method named add appointment responsible for adding an appointment created using the scheduler component to the database for the logged on employee let's create a definition for a method named update appointment responsible for updating the data for an appointment modified using the scheduler component in the database for the logged on employee let's create a definition for a method named delete appointment responsible for removing the data for an appointment removed using the scheduler component from the database for the logged on employee let's implement the logic for a method definition in a class named appointment service let's include a constructor in the appointment service class and ensure that our constructor includes a parameter of type sales management db context so that an object of this type is injected into our constructor at runtime let's also create a private readonly member variable that references the injected sales management db context object oops we have a typo here let's remove the extra e from delete appointment first from our i appointment service interface and then from the appointment service class let's first implement code for the add appointment method firstly let's create a convert overload extension method within the conversions class that as it were converts an object of type appointment model to an object of type appointment then let's write code within the add appointment method to first convert an argument passed into this method of type appointment model to type appointment and then let's write code to add the converted object to the database through ef call functionality like this before we create the code for the get appointments method let's write a convert overload extension method that as it were transforms the list of objects of type appointment to a list of objects of type appointment model then the code that we need to implement for our get appointments method is simply this line of code then let's implement the following code for the update appointment method and the delete appointment method note that we have not yet implemented the login functionality for our application so for now let's hard code the employee id to nine which relates to the sales rep benjamin lucas to simulate that benjamin lucas is the current logged on user we need to update the convert extension method that converts as it were an object of type appointment model to an object of type appointment this will ensure that when an appointment is added to the system that at the moment the appointment will as it were be made by benjamin lucas we must also include a wear filter like this within the get appointments method to filter the retrieved appointments by the employee id of benjamin lucas let's open the appointments.raiser file let's write code to override the uninitialized async blazer lifecycle event handler method let's write code so that an object of type i appointment service is injected into our razor component at runtime let's make sure that we appropriately register the appointment service type for dependency injection let's create a property that will serve as the data source for our scheduler component let's write the code within our uninitialized async method to retrieve the relevant appointment data from our database let's appropriately set the data source property for our scheduler component let's set the t value property of the sf schedule element to tell the syncfusion scheduler component as it were about the type of objects stored in the relevant data source let's also update the tvalue property of the schedule events element to the appointment model type let's remove some of the code that we don't need for our requirement and tidy up the code a little bit so now how do we hook into an appropriate event so that our crowdrelated code fires when the relevant event is raised by the scheduler component this is actually very simple within the schedule events element we can set the on action begin property to an event handler method that we are going to create our method will of course contain the code that we want to execute when the relevant event is raised we can also write code that we want executed when our code within the method that handles the on action begin event has completed we can do this by setting the action completed property to an event handler method that we are going to write so let's first write the code for the method that handles the on action begin event firstly let's write an if statement to check what type of action has been executed by the user of the syncfusion scheduler component so if args.actiontype equals to the actiontype.eventcreateenum value we know that the user is adding an appointment so we are able to retrieve the appointment data entered by the user with this line of code and then we can add the relevant appointment data to the database using our appointment service object like this then let's create the code for the method to handle the event that is fired when the code within the on action begin async method completes so we only want code in this method to fire when the user creates an appointment let's set the at ref attribute to a property that we'll create so that we are able to reference the syncfusion scheduler component in our code using the relevant property let's create the relevant property then let's write code to retrieve all appointments for the logged on employee and let's also write code to refresh the scheduler component let's run the code and add an appointment firstly through the basic dialog we can launch this basic dialog by clicking on one of the cells let's check our database excellent so now let's write code so that when a user updates an appointment that the changes are saved to the database the code for this is really intuitive let's test the code excellent we are able to update any of the fields associated with an appointment and our changes are now saved to the database let's implement code so that we are able to delete an appointment from the database using the scheduler component excellent and you can see that we are now able to perform crud operations through our syncfusion scheduler component and any changes we make are persisted to our database so at this point we have written all the functionality for our application however for certain functionality we have hardcoded the logged on employee id to imitate a particular employee being logged onto the system we want certain functionality in our application to be available based on the context of who is logged onto the system we want certain razor components in our application to be available to certain employees when they are logged into the system conversely we want certain razor components to not be available to certain employees when they are logged into the system for example we only want an administrator to be able to access the data grid whereby an administrator can perform crowd operations on employee data the sales manager has been given administrative privileges in our system so the sales manager is therefore able to perform crowd operations on employee data through the use of the data grid component we only want sales reps to be able to create orders in the system on behalf of clients so only sales reps will be able to access the product catalog razer component we want a dashboard displayed to the logged on user based on the relevant user's position in the sales department i.e based on whether a user is a sales rep team leader or the sales manager for example we want sales reps to only see those charts in their dashboard that are of relevance to sales reps the diagram that displays the organizational hierarchy will only be available to the sales manager the scheduler is available to all employees but only the appointments added by the loggedon employee will be available to the loggedon employee so how can we achieve this contextual behavior for users logged on to our application the answer is through providing appropriate login functionality where our application can authenticate the user when the user logs onto the system and authorization can be granted for the logged on user to be able to access certain functionality in the application conversely the loggedon user may be unauthorized to access other parts of the application so to achieve this we are going to integrate microsoft identity functionality into our application very basically microsoft identity provides an infrastructure for registration and login functionality using the microsoft identity technology will make it easy to add login and registration functionality to our application and provide the authentication and authorization functionality that we have just discussed so at the point at which we created our blazer server project we could have chosen to integrate microsoft identity into our application we chose not to integrate microsoft identity into our application at that point but we are still able to integrate microsoft identity into our application even if we choose not to do so at the point of creating the initial project for our application in this section of the course that is exactly what we are going to do we are going to go through each step that needs to be performed in order to integrate microsoft identity into an already existing blazer server application that does not yet have the microsoft identity technology integrated for the performance of login registration authentication and authorization functionality let's go through this step by step so the first step is to make our sales management db context class inherit from the generic identitydbcontext class which accepts the identity user type as a type argument we are doing this because we are going to house the microsoft identity database tables within the same database as where the database tables of our application reside we could create an entirely new dbcontext class for our microsoft identity functionality but our application is selfcontained and monolithic so in the interests of simplicity let's simply create the microsoft identity tables within the database we are already using for our application as you can see we have a red squiggly line here if we position our mouse pointers appropriately and press ctrl period we can see that we are missing the installation for an essential nuget package microsoft dot asp.net core dot identity dot entity framework core we can install the latest version of this nuget package at this point by clicking on the find and install latest version menu option presented to us through visual studio so let's do that and visual studio has done the appropriate installation and has also included the appropriate using directive to the relevant namespace at the top of our code microsoft.asp.net core dot identity dot entity framework core great the next step is to add the identity templates representing the functionality that we wish to integrate into our application for example login registration and logout functionality so to do this let's right click on the project node in our solution explorer window and select add new scaffolded item select identity on the left here click add you can see that we are presented with a variety of files that we can integrate into our application identity provides a suite of rich functionality but we are currently only interested in registration and login functionality so to include the appropriate identity features into our application let's check the check boxes next to account slash login accounts log out and account slash register the next step is to click the plus button next to data context class our application has a monolithic architecture it is a selfcontained application so we are going to integrate the identity database tables into the same database as the database where our application database tables reside so in the dialog that has just popped up let's enter the name of our already existing dbcontext class sales management db context let's click the add button on this dialog then let's click the add button on the main dialog at this point if you haven't followed the steps where we made our sales management db context class inherit from the identity db context class an exception will be thrown we have made our sales management db context class inherit from the identity db context class so we have no problems we must however make some adjustments to our program.cs class so let's go to the program.cs class visual studio has added in code add db context which is causing duplication of code so let's remove this add db context code here let's paste our original connection string related code over the connection string code that visual studio has added to program.cs then you can see here that visual studio has added code to program.cs that is appropriate for integrating microsoft identity into our application we must have the add default identity method being called here for simplicity let's modify this code here options.signin dot require confirmed account equals true to read options.signin dot require confirmed account equals false by setting this to false we are telling the identity system as it were not to include functionality where the user has to confirm the user's identity by clicking a link sent to the user's email address great so let's create a migration that will generate the necessary code for generating the identity tables in our database great let's run our migration code by running the update database command excellent the next step is we are going to create code to register certain employees with the identity system whose records exist within the employees table through our code these employees will be put into certain roles for example the sr identity role will contain employees who are sales reps the tl role will contain employees who are team leaders the sm role will contain the sales manager the admin role will contain employees who are able to perform cred operations on employee details the sales manager will be included in both the sm role and the admin role so firstly let's generate a migration notice that this migration class doesn't contain any code logic but just the structure for a migration class so we are going to create the code for this migration class to register certain employees with the identity system and add the employees to their appropriate identity roles in the interests of time i've already prepared the code for this off screen so we are going to copy the code from this github location a link to this location is available below in the description of this video and paste the code appropriately into our migration class here so each user and each role in the identity tables must be associated with a unique gurd global unique identifier in the identity tables guides are used as primary key values so let's generate new goods for these constant string values let's replace the goods that i generated for this sample code with newly generated goods an easy way to do that is to navigate to this url we can then type in the number of goods we would like to generate so we want 11 goods we can then generate the goods and copy them to our clipboards let's paste the goods into our code here and comment them out then let's replace the existing goods assigned to our constant values with the new goods that we have just generated great let's paste the code in for the up method like this notice that for the sake of simplicity the password for each of the employees that this code will register with the identity system will be password one with the p capitalized and an exclamation mark character so password one exclamation mark is the password let's bring in the microsoft dot asp.net core dot identity namespace let's copy the code for the private methods that are being called from within the up method and paste these private methods appropriately into our migration class let's copy the code for the down method and appropriately paste the code into our down method here let's paste in the code for the private methods that are being called from within the down method let's invoke the package manager console window and run the update database command let's view our database within sql server management studio excellent so in order to include identity role based functionality in our application we need to include the add roles method like this here within our registration functionality regarding identity we must also include a call to these methods in our program dot cs class so that our application knows as it were to include this identity middleware in our application so please appropriately include the following code app.use dot authentication authorization the next step is to ensure that an antiforgery token is passed to the client this antiforgery token can then be passed to the server with each client request the benefit of this is that our code will be able to verify that the client accessing our code is a trusted client we don't want just any client to be able to access our code we only want trusted clients accessing our code one of the ways that hackers can overcome our security is through crosssite scripting so the next step is we need to include antiforgery token functionality in our application to do this let's first add a class named tokenprovider to our data folder let's include string properties within our token provider class the xsrf string property and the refresh token property so let's open the underscore host dot cs html file and write code so that an object of type microsoft dot asp.net core dot anti forgery dot i anti forgery is injected into this page at runtime this is where we are going to generate the token and pass the token into our application let's write code to use the injected object to request a token let's create an object named tokens derived from our tokenprovider class and then assign the returns token to the xsrf token property of our tokenprovider object within the component element let's add a property named param initial state and set its value to the tokens object this is how we are passing our token to our application we are passing the tokens object to the app razer component let's appropriately update the app razer component let's write code to inject an object of type token provider into our appraiser component at runtime let's include a using statement that references the namespace of where our tokenprovider class resides within the underscoreimports.razer file the cascading authentication state element wraps the router element we need to change the root view element to an authorized root view element we can remove this line of code here so when the appraiser component loads up we want to assign the initial state parameter that we are passing down from the underscore host dot cs html page and we are going to set the xs rf token property of the token provider object injected into this razor component at runtime to the xsrf token property of the tokenprovider object passed into the initial state parameter next let's create our own login display component note that if we had included identity functionality at the point when we created our blazer server project a file for the login display component would have been generated for us by default in our particular scenario we are going to create our own login display component so let's create a razor component named login display let's write the code for our login display component so here we have code that is responsible for injecting a token provider object into our component at runtime our html code is wrapped in an authorized view element if the relevant user is authorized a welcome message and a logout button are shown to the user if the user is not authorized a register button and a login button is presented to the user notice that we have a hidden input field included in the html code our token provider object's xsrf token property is stored within the hidden text field then we need to reference the log and display eraser component appropriately within the main layout raiser file next let's add a razor component to our shared directory named redirect to login let's include this code within the redirect to login raise a file as the name suggests this code is used to redirect a user to the login page and that is basically it let's see if we can log into our application oops what have we done wrong we have not registered our token provider type for dependency injection let's go to the program.cs file and write the code for this let's run the code great we are presented with the default login screen provided by identity let's log in as one of the employees who is a team leader henry andrews great but we haven't created any authorization functionality in our application yet so by default anyone can just access any functionality within the system so we can click the log out link to log out of our application like this let's write code so that the links to our razer components are only accessible to relevant employees so let's restrict the visibility of the link to the tl dashboard razor component within the nav menu razer component so that it can only be seen by members of the tl role tl of course stands for team leader we can achieve this by wrapping the relevant link in the authorized view element we can then set the elements roles property to tl like this note that if we wanted to include more than one role value within the roles property all we would have to do is separate the relevant values by a comma so we would provide a comma delimited string containing the relevant roles let's run the code you can see that the tl dashboard is not visible when we first launch the application however if we log in as henry andrews who is a team leader and therefore a member of the tl role we can now see the link to the tl dashboard razer component in the main menu excellent the moment we log out the link to the tl dashboard razer component is no longer available if we log in as benjamin lucas who is a sales rep and not a team leader once he has been authenticated we still can't see the link to the tl dashboard component because he is not a team leader and therefore not a member of the tl identity role let's restrict the link to the sr dashboard razor component so that only sales reps ie members of the sr roll can see this link so if we launch the application we can no longer see the link to the sr dashboard razer component if we log in as a sales rep there it is great if we log in as henry andrews a team leader he is not able to see the link to the sr dashboard raise a component because he is not a sales rep and not a member of the sr identity role so in order for the correct data to be added to the system and the correct data to be retrieved from the system pertaining to the logged on employee let's write code to replace the hardcoded employee ids for relevant functionality with the employee id of the logged on employee so how can we do this so the data we have registered in the asp.net users identity table contains employee email addresses which of course are unique and they match up to the relevant email addresses saved for employees in the employees table our code is going to use the email address retrieved through identity when a user logs on to the system to query the employees table in order to as it were retrieve the logged on employees employee object then the employee's id can be read from the relevant employee object and we can use the employee id value appropriately in our code rather than a hardcoded value to do this let's create an extension method within the conversions class named getemployee object this first parameter is of type system.security.com principle this will allow our code to call the get employee object extension method on the user object of type system.security.claims.claims principle that will be available to our code once a user has been authenticated after the user logs onto the system we'll look at the user object in just a bit so we can use the user objects identity.name property which returns the email address registered in the asp.net users identity table for the employees that we registered through running the relevant migration that we created earlier we can use this email address which is also the user's username to query the employees table and return the appropriate employee object to the calling code like this great so let's first change the code in the order service class so that the relevant employee id is no longer hard coded to the employee id pertaining to benjamin lucas so we need to be able to access the user object which is an object that will be available once a user is authenticated to gain access to the user object let's first create a parameter within the constructor of the order service class of type authentication state provider let's create a member variable to reference the injected object let's create a private method that first gets a reference to the user object like this and then we can call our get employee object extension method on the user object and return the relevant employee object to the calling code like this within the create order method let's call the get logged on employee method to reference the employee object of the logged on employee and replace the hardcoded value of 9 with the logged on employees employee id great let's create the same logic for the sales order report service class like this and let's do the same for the appointment service class when we ran our migration that registered certain employees we registered the following employees within the identity system we registered bob jones the sales manager as a member of the sm role and the admin role we registered henry andrews who is a team leader and a member of the tl role we registered all the members of henry's team i.e the sales reps benjamin lucas olivia mills sarah henderson and noah robinson so now if we log in as henry andrews great the hardcoded employee id 3 is no longer used to retrieve the relevant data the id for the logged on employee is instead used excellent the same is true for benjamin lucas excellent let's login as olivia mills and we don't have much data for olivia mills but the system is reflecting the correct data for olivia mills who is a sales rep let's login as sarah henderson great and you can play around with the data in the sales order reports table to create more interesting data for the sales reps let's go to the nav menu razer component and appropriately write code so that only the functionality appropriate to the logged on user is available to the relevant user excellent let's log in as bob jones the sales manager and operate the application from his perspective excellent and you can see we have now appropriately integrated microsoft identity into our application where appropriate authentication and authorization functionality has now been implemented we are currently appropriately making the relevant links in the main menu visible to logged on users based on the roles to which they belong at present however a user could currently still access any razor component despite not having the appropriate privileges by simply typing in the url of the relevant razer component so to prevent this we can also restrict access within the razer components themselves one way of doing this is by appropriately including the authorized attribute within the relevant razor component like this and now access to these razor components are prohibited for unauthorized users excellent just to add an air of authenticity to our fictional company i've created a basic logo very quickly in photoshop for our fictional company outdoor excellence or oexl for short you can download the image from this location of course you're welcome to create your own company and company logo for the application but if you'd like you can download the one i created from this location on github to present the logo to the user when the user first launches the application let's include this code within the index raiser component please feel free to copy the code from github let's also include the logo within the nav menu razer component let's open the login display razer component and style the buttons for the login logout and registration functionality let's remove the about link from the main layout razer component let's include the login display element appropriately within the nav menu razer component so that the login and registration related buttons are available on mobile screen sizes within the main menu note we are including the d sm none bootstrap class in the container element that contains the login display razor component reference so that the relevant buttons only show up in the nav menu razor component when the app is running on mobile devices i.e when the app is only being presented on small screens let's add some meaningful icons provided by font awesome to the links in our main menu ie in the nav menu razer component let's include an appropriate font awesome link element within our underscorelayout.cshtml page which will give us access to the font awesome icons font awesome cdn is the easiest way to get font awesome on our web application let's search the font awesome website like this for some appropriate icons and appropriately include them within our nav menu razer component for our links great and lastly i want to import the quicksand google font from within the site.css file and reference this font in the fontfamily css property for our pages html and body elements excellent and that's it that is our application finished i've thoroughly enjoyed creating this course and i hope you've enjoyed going through it with me if you have gone through the whole course congratulations you are now able to build a sophisticated blazer server application using sophisticated syncfusion components and microsoft identity i hope to see you again soon thank you and take care
