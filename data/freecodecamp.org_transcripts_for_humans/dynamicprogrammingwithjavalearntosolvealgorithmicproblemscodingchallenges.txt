With timestamps:

00:00 - dynamic programming is a method for
00:01 - solving complex Problems by breaking
00:03 - them down into simpler overlapping sub
00:06 - problems and storing solutions to these
00:08 - sub problems to avoid redundant
00:10 - computations it can help you solve
00:12 - complex programming problems such as
00:15 - those often seen in programming
00:17 - interview questions about data
00:19 - structures and algorithms Alvin zablin
00:21 - teaches this course about dynamic
00:23 - programming in Java he has multiple
00:25 - super popular algorithm courses and he
00:28 - is a great teacher
00:30 - hey programmers Alvin from structure
00:31 - here Welcome to our course on dynamic
00:33 - programming in Java this is one of the
00:35 - most highly requested topics from free
00:36 - code Camp students so I'm super excited
00:38 - to explore this material with you in
00:40 - Java so if you're looking for a really
00:41 - thorough exploration of dynamic
00:43 - programming exclusively in Java you're
00:45 - in the right place of course that means
00:46 - all of our code specific walkthroughs
00:48 - are going to be in the Java programming
00:50 - language as for the format of this
00:51 - course we're going to build our dynamic
00:53 - programming knowledge by exploring a
00:55 - sequence of problems the problems are
00:57 - going to start simple but it's really
00:58 - going to give us the foundation we need
00:59 - to eventually solve some very tough
01:01 - dynamic programming problems in this
01:03 - very course for every problem we work
01:05 - through we're going to solve it using
01:06 - two steps the first thing we're going to
01:07 - do is head to my whiteboard where we'll
01:09 - come up with a strategy and really try
01:11 - to visualize the dynamic programming
01:13 - nature Behind these problems so after we
01:15 - draw things out on the Whiteboard and
01:17 - get a really confident understanding of
01:19 - the structure behind a particular
01:21 - problem then we're going to head into my
01:23 - editor where we're actually going to
01:24 - code up a Java specific solution alright
01:27 - so that's enough introduction for now
01:28 - what I want to do is hop into our very
01:30 - for section on our exploration of
01:32 - dynamic programming we're going to work
01:33 - through and frame our Fibonacci problem
01:36 - through our dynamic programming lens
01:41 - hey programmers Alvin here right now I
01:43 - want to work through this FIB problem of
01:45 - course we're referring to the classic
01:47 - Fibonacci Sequence this is a really
01:49 - really important you know computer
01:50 - science problem and to me it serves as
01:52 - the foundation to really unlocking a few
01:55 - harder Concepts down the line so even if
01:57 - you've done this FIB problem before it
01:59 - helps to review it together right now
02:01 - we're gonna see this core pattern uh
02:03 - show up a lot during the course together
02:05 - and so let's start by understanding what
02:07 - we should do in this problem well we
02:09 - know that the Fibonacci sequence has a
02:11 - few certain seed values we say that the
02:13 - first number of the sequence is zero and
02:15 - the second number of the sequence is one
02:16 - and then to generate further numbers of
02:19 - the sequence we just take the sum of the
02:21 - previous two in other words I can take
02:22 - zero plus one and that gives me the next
02:24 - number one right so the sequence starts
02:27 - zero one one then from there I continue
02:29 - this pattern right I can take the one
02:31 - plus one that gives me two I can take
02:34 - the one plus two and of course that
02:35 - gives me three and so on so forth and of
02:39 - course I can generate uh the sequence of
02:40 - infinite length in this way and so
02:43 - overall in this rendition of Fibonacci
02:45 - what we want to do is actually return
02:47 - the number at the specified index of the
02:50 - sequence right and so a really key
02:52 - insight about the Fibonacci sequence is
02:54 - to generate any particular number of the
02:55 - sequence we must know some other numbers
02:58 - of the sequence right I can get eight by
03:00 - just doing the previous three plus five
03:03 - if I wanted to actually formalize this
03:05 - problem a little bit better what we'll
03:06 - have to do is understand that these
03:08 - numbers I have listed are really the
03:09 - elements of the sequence
03:11 - and of course I can assign some indices
03:13 - to those elements so up top I'll just
03:16 - label these increasing by one of course
03:18 - but starting at zero so I can say
03:20 - something like hey the zeroth number of
03:22 - the sequence is zero and the first
03:23 - number of the sequence is one and also
03:25 - the second number of the sequence is one
03:27 - and so on and so forth so kind of
03:31 - jumping ahead a little bit if I look at
03:32 - this particular position what I see is
03:34 - all right it seems to be that the
03:36 - seventh number of the Fibonacci sequence
03:38 - is exactly 13. that's going to be
03:41 - overall the shape of this problem
03:43 - all right so how can we go about solving
03:45 - this one and so for this particular
03:48 - approach what I want us to do is
03:49 - actually work through this one
03:50 - recursively I think the iterative
03:52 - solution is pretty straightforward but
03:54 - I'm going to force us to solve this one
03:56 - recursively because it's going to help
03:57 - us I'll learn some new topics along the
04:00 - way so we'll kind of stick to a
04:01 - recursive mindset and if you hate
04:03 - recursion you know too bad he'll learn
04:05 - to love it right now
04:06 - and so looking at a particular example
04:09 - let's say I wanted to figure out how I
04:11 - can come up with the solution for FIB of
04:13 - six in other words the sixth Fibonacci
04:15 - number is exactly eight
04:17 - and so what I can start to do is figure
04:19 - out how to break down this problem I
04:21 - know in general to generate the sixth
04:24 - number of the sequence I can take the
04:26 - fifth number and add that to the fourth
04:28 - number right it's exactly the rule of
04:30 - the Fibonacci sequence let me try to
04:32 - visualize this one a little bit better
04:33 - so I'll represent uh the problem FIB of
04:36 - six using somewhat of a tree and I'll
04:38 - represent an instance of the problem as
04:40 - a note of this tree so I have my top
04:42 - level problem of six that'll be the root
04:45 - of this tree and this is a really
04:46 - important way to actually visualize
04:48 - recursion because it really shows us how
04:50 - we're going to utilize our return values
04:52 - and reconstruct our final answer
04:54 - so if this is a new pattern for you
04:56 - don't worry we'll walk through it pretty
04:58 - slowly together
04:59 - and so now that I have this root of six
05:01 - I have to figure out how do I break down
05:03 - this problem well like we just said to
05:06 - solve above six what I need to do is
05:07 - break that down into fibbo five so
05:09 - that'll appear as a child of that sixth
05:12 - node in the same way for before also
05:15 - needs to be solved to solve our main
05:17 - problem over here and notice how I have
05:19 - these you know children nodes of course
05:21 - below the FIB of six right as I go
05:24 - downward in this tree I should be
05:26 - getting smaller and smaller numbers in
05:29 - blue right that would represent a
05:30 - smaller problem because I know once I
05:32 - have a small enough input in blue then I
05:35 - would have somewhat of a base case kind
05:37 - of inherent the Fibonacci sequence so
05:39 - let's take a closer look at this five
05:41 - note over here right this node
05:43 - represents the problem of FIB of five
05:45 - right what is the fifth number of the
05:47 - sequence and I know in general my
05:49 - pattern is all right if I want to
05:51 - calculate FIB of n then I take the sum
05:53 - of N minus 1 and N minus two so I'm just
05:57 - going to apply that pattern to this five
05:58 - node in other words on fives left it's
06:01 - going to have a node of four and a five
06:03 - is right it's going to have a note of
06:04 - three right doing a minus one and minus
06:06 - two respectively and it's a similar
06:08 - trend for the four node on the right
06:10 - hand side over here right it's going to
06:11 - have two children of course doing -1 on
06:13 - the left and minus two on the right
06:15 - giving three and two respectively
06:18 - so let's keep applying this pattern
06:20 - we're going to do is fill out the next
06:21 - level of the tree
06:22 - until we can't fill it out anymore
06:25 - we have to notice here is when it comes
06:27 - to actually building on the full tree we
06:29 - have to stop at certain nodes in other
06:32 - words once I have an instance like zero
06:34 - as my input to this little sub problem I
06:37 - can actually shrink that problem size
06:38 - any further let's all highlight all of
06:41 - these nodes whose input is zero right
06:43 - that represents the zeroth number of the
06:46 - Fibonacci sequence and something
06:48 - inherent in the problem is I can't
06:49 - really break that problem down any
06:51 - further I know that for those particular
06:54 - nodes they ought to return zero right
06:57 - because a zero number of the Fibonacci
06:59 - sequence is exactly zero so in green I'm
07:02 - going to represent the result or the
07:04 - answer to those sub problems right I'm
07:06 - going to put their answers above the
07:08 - problem itself right so I'm trying to be
07:10 - very very particular in my drawing I'm
07:12 - always going to write a return value
07:14 - above a node here
07:17 - and I have a similar case for all of my
07:19 - nodes who have an input of one those are
07:22 - also a base case right because the first
07:24 - number of the Fibonacci sequence is
07:26 - exactly one so we'll also fill in those
07:28 - ones above
07:30 - cool now that I have some floating
07:32 - return values I can start to reconstruct
07:35 - my larger problems at hand
07:37 - so let's stay focused on the left hand
07:39 - side of my tree let's look at this
07:41 - particular node so I'm looking at this
07:44 - node of two and I have a left hand value
07:47 - and a right hand value are ready to
07:49 - compute I know that if I look at this
07:51 - this node of 2 it's trying to figure out
07:54 - what's the second number of the
07:55 - Fibonacci sequence and so at this node
07:57 - of 2 in blue what I can do is just take
08:00 - the sum of its children right of those
08:01 - green values so 1 plus 0 gives me one
08:06 - and if I do a quick Sandy check that
08:07 - must mean that the second number of the
08:09 - Fibonacci sequence is exactly one and
08:12 - this pattern continues up the tree right
08:13 - at this node of three I take the sum of
08:16 - the one plus one and I get two if I do a
08:19 - quick Sandy check that must mean the
08:21 - third number of the Fibonacci sequence
08:22 - is two what we're doing right now is
08:24 - really stepping through how a recursive
08:26 - code would actually return right return
08:29 - means return to your caller right so
08:31 - return to your parent node
08:33 - and so I'll fill in the rest of the
08:35 - values over here
08:37 - and bear in mind you know as you kind of
08:39 - uh draw out these diagrams maybe for
08:41 - yourself hopefully on pen and paper or
08:43 - even on a whiteboard it's really
08:44 - important at least for me that you check
08:46 - for correctness as you build the tree so
08:48 - if you're in an interview it really
08:50 - helps to not just check for your top
08:52 - level answer being correct but at any
08:55 - points of your Trace you should have
08:56 - logical information in other words by
08:58 - just looking at this node right I have a
09:00 - blue note of three over here whose
09:02 - return value is two that logically
09:04 - implies that the third Fibonacci number
09:07 - is two and that's totally correct so I'm
09:09 - good to go for now right it would really
09:11 - be a drag if I kind of sketch through
09:13 - this entire drawing only to realize I
09:15 - had a little like typo or miscalculation
09:17 - somewhere Below in the tree so I highly
09:19 - recommend that you stay very aware of
09:21 - your sub results as you kind of Trace
09:22 - through a diagram like this
09:25 - so let's continue to build up these sub
09:27 - Solutions
09:28 - so I know that this node of 2 is going
09:30 - to take the sum of one plus zero that
09:32 - gives me one and finally at the parent
09:34 - of four it's also going to take the sum
09:36 - so two plus one is three and that must
09:38 - mean that the fourth of a notch a number
09:40 - is of course three so let's speed this
09:42 - up a little bit for every other uh node
09:45 - in the tree
09:46 - so we're gonna add all these up
09:49 - so on and so forth
09:52 - now at the tippy top we see that this
09:54 - note of six at the root is going to take
09:56 - the sum of five and three and of course
09:58 - that gives me eight which is exactly the
10:00 - punch line right the sixth Fibonacci
10:02 - number is indeed eight and so looking at
10:06 - this pretty large tree you might realize
10:08 - that hey you know our top level problem
10:10 - was asking for the sixth Fibonacci
10:12 - number not a very large number in the
10:14 - sequence however we have to use a lot of
10:16 - nodes to actually represent that problem
10:18 - how we broke it down that's something
10:20 - really important about this Fibonacci
10:22 - Sequence right it has a pretty
10:24 - interesting complexity a pretty large
10:25 - one at that so let's try to analyze the
10:28 - complexity of this we know that every
10:30 - node of this like visual tree represents
10:33 - a recursive call right and so the number
10:35 - of recursive calls I make over here or
10:37 - the number of nodes of the tree should
10:39 - roughly represent the time complexity of
10:42 - this solution you're probably already
10:43 - recognizing that it's going to be a very
10:45 - very large one
10:47 - let's go step by step over here and so
10:49 - to analyze the complexity of recursion
10:50 - like this I think it's really important
10:52 - to notice any patterns in the tree to me
10:54 - it's all about looking in the tree right
10:56 - I can kind of figure out at least the
10:58 - ballpark of the type complexity without
11:00 - even writing the code right just using
11:02 - this visual
11:03 - and so at first glance you might notice
11:05 - that this one is pretty hard to analyze
11:07 - because the tree is asymmetric in other
11:10 - words notice that it's a little taller
11:11 - or deeper on the left hand side then
11:13 - toward the right hand side of the tree
11:15 - it's actually much more shallow and that
11:17 - kind of asymmetry makes us feel a little
11:20 - uncomfortable when it comes to figuring
11:21 - out any patterns so here's what we'll do
11:23 - let's actually try to analyze this one
11:26 - by drawing an analogy so let's ignore
11:28 - this exact Fibonacci tree right now and
11:30 - go for a more symmetric example so let's
11:33 - say I had a similar recursive code that
11:36 - had a more symmetric recursion so let's
11:38 - say I had some top level call with a
11:40 - value of four and let's say that this
11:42 - top level call to four I actually made
11:44 - two more recursive calls but both on a
11:47 - minus one in other words the left child
11:49 - is the same as the right child which is
11:51 - different from our classic Fibonacci
11:53 - right Fibonacci our left was minus one
11:55 - and our right was minus two but now I'm
11:57 - just doing minus one on both sides if I
12:00 - continue that pattern that should give
12:01 - me a nice symmetric tree let's say I had
12:03 - some base case roughly when my value is
12:07 - one so I can stop building the tree from
12:09 - here
12:09 - and so this has a nice symmetry to it
12:11 - let's try to notice any patterns now
12:13 - if I look at the different levels of
12:15 - this tree let me look at how many nodes
12:17 - there are across a level so for example
12:19 - my very very top level and there's one
12:21 - note on that level on the next level
12:23 - there's two nodes and then four nodes
12:26 - and then eight nodes you can probably
12:28 - see how this pattern scales right if I
12:30 - drew more of this tree let's say I had a
12:32 - farther a base case it would be 16 nodes
12:34 - and then 32 nodes and so on
12:37 - and so you probably realize the obvious
12:39 - pattern here right the very top at the
12:41 - root of my you know recursive tree I
12:43 - have one note or one call and then from
12:46 - one level to the next I doubled I
12:48 - multiply by two right and I do this
12:51 - process basically for every level of
12:54 - this tree so that begs the question you
12:56 - know how many levels are there in this
12:58 - tree well just looking at this kind of
13:00 - particular concrete example there's
13:02 - definitely about four levels right and I
13:05 - can kind of understand uh how to
13:07 - designate each level by just looking
13:09 - along this left-hand path right so
13:11 - colored in yellow notice that I have
13:13 - four three two one that's just a
13:16 - decreasing pattern
13:18 - so when it comes to the number of levels
13:20 - it's pretty obvious to me that it's
13:22 - exactly n levels right if my top level
13:25 - problem at the root is where n equals
13:27 - four then I have you know four levels or
13:29 - in general n levels
13:32 - so it's pretty clear to me that when it
13:34 - comes to figuring out the total number
13:35 - of nodes in this tree which implies the
13:38 - total number of recursive calls we make
13:39 - for this kind of toy problem it looks
13:42 - like I would multiply two by itself n
13:45 - times over which is a definition of an
13:48 - exponential 2 to the nth power
13:51 - cool so maybe you're a little bit
13:53 - skeptical and here's where we can either
13:55 - you know really buy into kind of the Big
13:57 - O complexity or we can get bogged down
13:59 - by the finer details something that you
14:02 - might fall into sometimes but you have
14:04 - to kind of be very aware of it is Big O
14:07 - is really just an estimate so if you
14:09 - actually plug in some values here you
14:11 - might notice all right if I did 2 to the
14:13 - fourth power right because 4 is my n in
14:15 - this particular example that would be
14:17 - 16. and so if we actually counted the
14:20 - quantity of nodes in this visual tree it
14:23 - would not be exactly 16. I'll label them
14:26 - over here starting at one there's
14:27 - actually going to be 15 nodes so it's
14:30 - off a little bit but if we you know
14:32 - understand Big O complexity we know that
14:34 - if we have something that's of the shape
14:36 - of like 2 to the N minus 1 we can ignore
14:39 - the minus one what's more is even if it
14:42 - was off by like five right if it's a
14:44 - minus five that's still a constant that
14:45 - we're subtracting that still is dropped
14:48 - from the Big O notation so overall I
14:50 - would consider this particular example
14:52 - as having o of the 2 to the N Run time
14:56 - which would be exponential pretty pretty
14:58 - slow right
15:00 - so while we're here looking at this
15:02 - symmetric example before we hop back
15:04 - into FIB let's try to recognize what the
15:06 - space complexity is we know how the
15:08 - space complexity for recursive code is
15:11 - going to be more or less the number of
15:14 - Stack frames that we use right for our
15:16 - recursion because whenever we make a
15:18 - recursive call that information has to
15:20 - be stored on the call stack right so we
15:22 - kind of make different function calls
15:25 - and also return from function calls
15:27 - and so this is actually something I
15:28 - notice students have quite a difficult
15:30 - time uh analyzing and so what I'm going
15:33 - to do is really Trace through how we
15:35 - would make these recursive calls as well
15:37 - as how to visualize the call stack right
15:40 - so this top level call of four that
15:42 - would be added to the stack all right so
15:44 - stack will be just a little a little
15:46 - rectangular block right and then as I
15:48 - make recursive calls let's say now I
15:49 - call upon three that's my input that's
15:52 - also added to the stack notice that it's
15:54 - added on top of the four right and
15:57 - really we have to recognize here is
15:59 - every time we make a call we're adding a
16:02 - new stack frame and we only get to
16:05 - remove something from the call stack
16:07 - when it returns so so far none of my
16:10 - calls have returned right until I have
16:13 - one at the top of my stack right at this
16:15 - point I've kind of bottomed out at like
16:17 - a base case so I can return from that
16:19 - call which also means I remove it from
16:21 - the stack
16:23 - at this point I need to evaluate two's
16:25 - right child so I make another call to
16:27 - one
16:28 - and this process continues right now I'm
16:30 - done with both of twos call so it can
16:33 - return
16:34 - now I'm back at three but three has to
16:36 - call upon it's right
16:38 - and the same thing happens well you'll
16:40 - notice that at this point is although
16:42 - there are many you know different stack
16:43 - frames we would have to eventually push
16:46 - onto the call stack at any point in time
16:48 - there's only about a four different
16:51 - stack frames on the call stack right
16:53 - it's not as if that we store like all of
16:56 - these different stack frames
16:58 - simultaneously right it doesn't really
16:59 - make any sense to add certain stack
17:01 - frames you must have returned from other
17:03 - ones so it's actually the case that the
17:06 - space complexity due to the call stack
17:07 - would just be o of n overall we're
17:10 - looking at an exponential runtime and a
17:12 - linear space complexity alright so for
17:14 - this particular symmetric example it has
17:17 - an exponential runtime and a linear
17:19 - space complexity but how about for our
17:21 - actual Fibonacci tree we know our
17:23 - Fibonacci tree is more lopsided
17:26 - it's roughly going to be like half the
17:28 - size of that and you can take my word
17:30 - for it it would actually be the same Big
17:32 - O complexity right still 2 to the n and
17:35 - then just an O of n space complexity
17:38 - and so kind of taking a lay the land
17:40 - over here the space complexity seems
17:42 - reasonable right however whenever we
17:44 - have an exponential usually that's not
17:47 - good enough and there is actually a
17:49 - better or faster way to solve this one
17:51 - recursively which is what I want to
17:53 - expose this to uh right now so let's go
17:55 - back to the recursion tree for our FIB
17:58 - problem right and so what we can do is
18:01 - try to recognize any patterns within
18:04 - this tree do you notice any duplicate
18:06 - work right this is all about
18:08 - understanding you know what this diagram
18:10 - represents right every node I have drawn
18:12 - in here with its corresponding number
18:14 - represents a problem
18:17 - as you can see I have many duplicate
18:19 - problems so for example if I look at
18:21 - this subtree that sub tree represents a
18:24 - sub problem right rooted in four so I'm
18:26 - asking for the fourth Fibonacci number
18:28 - not only do I need to calculate that on
18:30 - the left hand side of the tree but at
18:31 - some other point down the line on the
18:33 - right hand side I need to calculate that
18:35 - same exact sub problem right these two
18:38 - subtrees are identical
18:40 - and they both represent the same problem
18:43 - the fourth Fibonacci number
18:46 - and this pattern actually applies
18:47 - recursively because the strategy is
18:49 - recursive right so you can notice
18:51 - probably some other different duplicate
18:52 - sub problems right if I root myself at
18:54 - three I have to calculate this sub tree
18:56 - three different times right and notice
18:58 - that that three subtree is also internal
19:01 - uh to the fit before so it's a really a
19:04 - really duplicate and there are a few
19:06 - other duplicate sub trees you can
19:07 - recognize over here so we have a lot of
19:10 - duplicate work in this kind of Brute
19:13 - Force recursion
19:14 - and if we actually store some sub
19:17 - results then we can forego having to
19:19 - recalculate any of these subtrees down
19:21 - the line
19:22 - and so really what we're looking to do
19:24 - is kind of prune out some branches of
19:26 - this tree to avoid some duplication so
19:30 - what I'm going to do is kind of ignore
19:32 - this right hand tree of four so I'm
19:35 - going to take that out because I would
19:36 - have calculated it on the left hand side
19:38 - somewhere I'll do the same thing for
19:40 - this kind of middle tree of three so I
19:43 - can ignore that as well
19:46 - cool likewise for this too
19:48 - and so at this point we don't really
19:50 - have any full duplicate sub trees right
19:52 - I kind of took them out of my drawing
19:55 - so if we actually store some results as
19:57 - we calculate these sub problems this
19:59 - really represents all of the recursive
20:01 - calls that we'll have to make right and
20:04 - so you're wondering how can I actually
20:05 - Implement you know that kind of pattern
20:07 - in my code well it's all about just
20:10 - storing some additional information so
20:12 - let's step through still FIB of six so I
20:15 - want the six Fibonacci number in the
20:16 - long run we should get eight and the
20:18 - strategy I'm introducing right now is
20:20 - called memoization and so when it comes
20:22 - to implementing memoization in your
20:24 - language of choice it's all about
20:26 - storing some additional data in a memo
20:28 - and your memo is typically going to be
20:30 - your like hashed data structure so it
20:33 - could be like a hash map or a dictionary
20:34 - or object depending on your weapon of
20:37 - choice here right it's really important
20:39 - that I choose some data structure that
20:41 - gives me an O of one lookup time right
20:44 - so usually that would be your hashed
20:45 - data structures whatever that is in your
20:47 - particular language
20:48 - and so let's step through this one again
20:51 - but now we're going to store some data
20:53 - inside of our memo so we have the same
20:55 - base cases as before right we know that
20:58 - the first Fibonacci number is one and
20:59 - the zero Fibonacci number is zero and
21:02 - when these values return to the parent
21:04 - of two we're still going to calculate
21:06 - the sum over here so 1 plus 0 is just
21:08 - one but now that I have this result I
21:11 - can store it in the memo so I'm going to
21:13 - make the key represent the input to that
21:17 - node or that recursive call and then its
21:19 - value is going to be that return value
21:21 - and so if I look inside of my memo it's
21:23 - a reminder that the second Fibonacci
21:25 - number is one
21:27 - so we'll continue this process I know
21:28 - that I have a basically server here
21:29 - still the case that the first Fibonacci
21:31 - number is one and I return to the parent
21:34 - I calculate that hey the third Fibonacci
21:37 - number is two and I'm going to store
21:38 - that in my memo as well and here's where
21:41 - things get a little more interesting if
21:43 - I look at this node of 2 over here I've
21:45 - actually calculated uh this sub problem
21:47 - before right I can check that by just
21:49 - looking inside of my memo my memo says
21:52 - Hey the second Fibonacci number is one
21:54 - so without having to recurse and build
21:57 - the full subtree once again I'll just go
21:59 - ahead and fetch on the stored value in
22:02 - my memo so I'm just going to jot down a
22:04 - one above this node of two I'm not going
22:06 - to return to my parent and I figure out
22:08 - that hey the fourth Fibonacci number is
22:11 - three and of course I want to be sure to
22:13 - return that but also store it in my memo
22:16 - for the future
22:18 - and same thing happens at this three
22:19 - note right this three note is again in
22:22 - my memo so without you know re-cursing
22:24 - through my tree I'm going to just fetch
22:27 - that value from my memo I already know
22:29 - that hey the third Fibonacci number is
22:31 - two and so I can calculate the value at
22:33 - my parent right fifth for Notch number
22:35 - is five be sure to store that in your
22:37 - memo and so on and so forth by the time
22:41 - we get to the very top of our tree of
22:43 - course we have the fact that the six
22:44 - Fibonacci number is indeed eight and I
22:47 - avoided a lot of the duplicate recursive
22:49 - calls
22:51 - so it's clear to me that we avoid a lot
22:53 - of duplicate work what exactly is the
22:55 - run time now right and so we'll try to
22:58 - notice uh some patterns so this visual
23:00 - tree represents our Fibonacci recursion
23:03 - after we implement this memoization
23:06 - strategy right I'll try to generalize it
23:09 - over here so I'll kind of tidy up these
23:11 - edges over here
23:12 - and let's say I increased the size of
23:15 - this problem so instead of FIB of six
23:16 - what if I asked you for FIB of seven
23:19 - that recursion tree would look something
23:22 - like this
23:23 - right notice that the root is now seven
23:25 - of course and it's still the case that
23:27 - the left child is -1 so a six and the
23:30 - right child of the seven is a minus two
23:32 - or a five right still being the rules of
23:34 - Fibonacci and I only added two more
23:36 - nodes if I increase the problem size to
23:39 - FIB of eight I would still add two more
23:41 - nodes
23:42 - so every time I increase my input by one
23:46 - I only add two nodes it's always adding
23:48 - a constant number of nodes at this point
23:51 - our problem scales linearly right
23:53 - in general we're going to notice that we
23:56 - have basically two times n nodes and
23:59 - notice that that's not 2 to the N where
24:00 - I'm saying 2 times n and so we can
24:02 - simplify that to a runtime of O of N and
24:05 - the space complexity is still the same
24:07 - right notice that the space complexity
24:09 - for this algorithm is really just going
24:11 - to be the height of the visual tree it
24:13 - still looks like a linear chain right if
24:15 - I go along the left-hand path it just
24:17 - goes eight seven six five four and so on
24:20 - so definitely an O of n space complexity
24:23 - and this is actually a pretty efficient
24:25 - solution for our Fibonacci and so I
24:29 - think from this point let's go ahead and
24:30 - implement this in some code now we can
24:33 - have this core pattern under our belts
24:35 - so I highly recommend that you try to
24:36 - implement this one in some code on your
24:38 - own but don't forget we also have the
24:40 - video walkthrough available if you get
24:42 - stuck or just want to code along
24:44 - now that we're done sketching out a
24:46 - strategy for this problem on the
24:47 - Whiteboard what you want to do is follow
24:48 - the link in the description for this FIB
24:50 - problem so you can follow along and code
24:51 - up our solution in Java with me
24:58 - hey programmers Alvin here what I want
25:00 - to do right now is go over the Java
25:01 - walkthrough for this FIB problem this is
25:03 - going to be our very first problem in
25:05 - the dynamic programming section now I am
25:07 - going to teach you to solve dynamic
25:09 - programming problems is using recursion
25:10 - plus memoization so we're going to start
25:12 - just by warming up here and solving this
25:14 - Fibonacci problem uh using recursion and
25:17 - then we're going to apply our
25:18 - memoization strategy on top of it and
25:20 - this is going to be a really great
25:21 - strategy that can scale to a lot of
25:23 - different dynamic programming problems
25:25 - obviously you might be thinking that you
25:26 - could solve a Fibonacci using some you
25:28 - know pretty classic iterative code and
25:30 - you definitely can however I'm going to
25:32 - show you how to solve this recursively
25:33 - with memorization because it's really
25:35 - going to set you up for harder problems
25:36 - later on so let's Jump Right In when it
25:39 - comes to setting up the recursive code
25:40 - here I want to start with my base cases
25:42 - and they tell us that the zeroth number
25:44 - the Fibonacci sequence is zero and the
25:46 - first number of the Fibonacci sequence
25:47 - is one so I'll turn those into base
25:49 - cases so I can just go ahead and check
25:52 - hey if n equals zero then I know I need
25:56 - to return zero like wise if n is equal
25:59 - to 1 I know I want to return one
26:02 - so to kind of combine those into a
26:03 - single base case here I can check if n
26:05 - equals zero or n equals one well there's
26:09 - return n itself right because the zeroth
26:11 - number of the sequence is zero and the
26:13 - first number of sequence is one and
26:15 - that'll give me my two base cases to
26:17 - start then from there I only need one
26:18 - more line of code the recursive
26:20 - definition of Fibonacci is to get some
26:22 - further a number of the sequence you
26:24 - just take the sum of the previous two
26:25 - right so I know that the previous number
26:28 - of the sequence would be Fibonacci of n
26:30 - minus one right because n represents the
26:33 - number I'm asking for so the number in
26:35 - the sequence that comes before would be
26:36 - n minus 1. I want to add that
26:40 - to Fibonacci of n minus two right so
26:43 - that would be the number two steps ago
26:45 - right take the sum of them and that
26:47 - would give me my current number
26:50 - so let's give that a test run
26:51 - this will be correct but it won't scale
26:54 - in terms of the time complexity like we
26:56 - said in the approach video the time
26:58 - complexity of this Fibonacci function
26:59 - although it's very short code is
27:01 - exponential right it's 2 to the n and so
27:04 - the growth of this function as we
27:06 - increase the input number n is very very
27:09 - large so you're actually going to get a
27:10 - timeout for this one
27:12 - and so to make this faster we're going
27:14 - to layer on a memoization strategy right
27:16 - and so what's really important in the
27:18 - way I teach monetization is we always
27:19 - start by solving the brute force and
27:21 - here I have the Brute Force right I can
27:23 - identify that I've correctly implemented
27:25 - The Brute Force when I get correct
27:27 - results for my method except it's slow
27:30 - right so it times out for some very
27:32 - large input for example if I take a look
27:34 - at the test case I'm feeling right now
27:35 - it would be calling Fibonacci with an N
27:38 - of 46 right it would give me some large
27:41 - value and because this has an
27:42 - exponential time complexity that's far
27:45 - too large for me to wait around for
27:47 - and so when it comes to creating a
27:49 - memoization around this Brute Force
27:51 - solution in Java what I usually do is
27:53 - create two separate methods I'll have my
27:56 - main method I also have my recursive
27:58 - helper method that also takes in a memo
28:03 - and so let me create another version of
28:05 - this method above
28:06 - that would be the main method and it's
28:08 - just gonna really call and pass control
28:11 - into my recursive method
28:14 - I'm going to overload it with an
28:16 - additional argument here right so FIB
28:18 - the recursive method is going to take in
28:21 - not only the integer n but my memo and
28:24 - for you in Java it'd be nice if you
28:26 - implement your memo using a fast lookup
28:28 - data structure right because you want to
28:30 - improve the runtime of this code so you
28:32 - want to store your sub results in a fast
28:35 - lookup data structure so for you that
28:37 - could be as simple as a hash map so I'm
28:39 - going to import up top
28:41 - Java util
28:43 - hashmap
28:45 - so I know that a hashmap has o of one
28:47 - insertion and ov1 lookup
28:49 - and I'll take in a hash mark over here
28:51 - and when it comes to how I design the
28:53 - structure of the hash map I know that
28:54 - the keys of my hashmap need to be input
28:58 - arguments to My Method here right so I
29:00 - know the input argument is a number or
29:02 - integer n so I'm going to make the key
29:04 - integer
29:06 - I make the corresponding value in the
29:08 - hash map the return value for my method
29:11 - it's going to have integer values as
29:12 - well I'll just call this argument memo
29:15 - so that means when I in my main function
29:17 - call my recursive method here I'll pass
29:20 - in the original n but I'll give it a new
29:22 - hash map
29:25 - nice I could just return whatever the
29:27 - recursive method returns so do bear in
29:29 - mind that this circus of method now line
29:31 - 9 is taking in my original argument n as
29:35 - well as this memo hashmap right and this
29:38 - memo hashmap is going to be shared for
29:40 - the entire recursion right so what I
29:43 - need to be sure to do is I'm taking in
29:45 - the memo that's an argument here when I
29:48 - call recursively on FIB I want to pass
29:49 - along the same memo
29:51 - right you're passing it by reference so
29:53 - you can have all of your recursive calls
29:55 - share the same memo object right think
29:58 - of it as if when you visualize like the
30:00 - recursion tree like we did in our
30:02 - approach video you want all of your
30:04 - nodes in the tree to refer to the same
30:06 - memo
30:08 - awesome
30:09 - so that's just me adding an additional
30:10 - argument into FIB but now I actually
30:13 - want to use that memo object
30:15 - and so what you should do is check if
30:19 - your argument is already a key in your
30:21 - memo right so I'm going to check it over
30:23 - here it kind of acts like another base
30:25 - case here so I put it at the top so I'm
30:27 - going to check if my memo already
30:30 - contains
30:32 - key of my argument n
30:34 - right
30:35 - what I can do is then just return the
30:37 - stored value of that key so I can do
30:39 - memo dot get n
30:41 - obviously this only works if I you know
30:43 - over time store values into my memo
30:46 - which I'll do in a moment right so I
30:49 - know my memo is going to map right
30:51 - arguments
30:53 - of my method to their return values so
30:55 - if I find an argument in the memo that
30:58 - matches my current argument I'm just
30:59 - going to return its stored value in the
31:01 - memo
31:03 - but that means I need to be storing
31:04 - things over time into the memo and so
31:06 - now you should locate wherever you
31:08 - return recursively for your method so
31:10 - that'd be the line 19 return right those
31:12 - are my recursive return values right I
31:15 - know that line 11 is not a recursive
31:16 - return value because it's literally my
31:18 - base case right so I know that this
31:20 - value here I know it's really composed
31:22 - of you know two separate or cursive
31:24 - calls but I know that this will
31:25 - ultimately evaluate to a number right
31:28 - and we're turning a number here that
31:29 - number is like the answer so what I'll
31:31 - do is I'll save it in a variable
31:32 - I'll just call it result
31:34 - and you know that this result is going
31:37 - to be the answer for Fibonacci of n so
31:40 - what I want to do is in my memo before I
31:43 - leave I want to store
31:45 - using the key of n
31:48 - I want to make the corresponding value
31:49 - this result again what I'm doing here is
31:51 - I'm making sure my memo Maps arguments
31:55 - of my method to their return values
31:58 - I know the answer for like FIB of n is
32:01 - this result
32:02 - and what you want to be sure to do is
32:03 - just complete the return value like
32:05 - before so I just want to return result
32:07 - so I'm still returning the same data as
32:09 - before I'm just additionally storing
32:12 - into a memo for later on
32:14 - and what's great is later on you know
32:16 - somewhere in your recursion when you
32:18 - encounter an N that you've seen before I
32:20 - mean you know that's going to happen in
32:21 - this problem because we you know demoed
32:22 - it in the approach video when you see an
32:24 - input and you want to evaluate an input
32:26 - and that you've seen before then you'll
32:28 - actually hit this base case on line 14.
32:31 - you're going to find that that argument
32:32 - is already in the memo and you're just
32:34 - going to return the stored value inside
32:36 - and that happens in constant time right
32:38 - because I know getting you know from a
32:41 - hash map is constant time so with that
32:44 - change let's go ahead and give this a
32:45 - test run
32:47 - really important thing to remember to do
32:48 - is be sure to pass your memo you know to
32:51 - your recursive calls over here that way
32:53 - you get that shared information across
32:55 - all of your recursive calls awesome and
32:58 - there we have it so by implementing this
33:00 - memoization strategy on top of our Brute
33:02 - Force we really improve the time
33:03 - complexity of this solution right like
33:06 - we said in the approach video now we're
33:07 - looking at an O of n runtime right space
33:10 - complexity is also going to be o of n
33:12 - because we have to store all of these
33:13 - calls on the call stack and even if we
33:15 - consider the size of our memo we know
33:18 - that our memo is just going to have a
33:20 - number of entries that could be at most
33:22 - equal to our input n right because I'm
33:25 - using my input n as the keys of my hash
33:28 - map and I know that keys are unique all
33:30 - right programmers so what I want you to
33:31 - do is take a moment really be sure to
33:33 - redo this problem and understand how we
33:36 - solved it in two steps right first I
33:37 - solve just the Brute Force recursion and
33:39 - then I apply my memoization on top of it
33:41 - this is going to be a really really
33:43 - important pattern moving forward we're
33:45 - going to scale it to solve some pretty
33:46 - interesting and difficult uh dynamic
33:48 - programming problems but I always
33:50 - follows this core pattern of solving a
33:51 - Brute Force recursion then additionally
33:53 - adding a memo hash map to it I'll do a
33:56 - variation of this in the next video I'll
33:58 - see you there
34:01 - hey programmers Alvin here right now I
34:04 - want to show you the approach for this
34:05 - Fibonacci problem and so I know you're
34:08 - thinking you know why is he having us do
34:09 - basically a ripoff of Fibonacci well I
34:12 - think it's really important that if you
34:13 - want to get good at these algorithm
34:15 - things then you have to have a certain
34:16 - level of repetition as the saying goes
34:19 - one is none right so even though you
34:21 - know we've just done another Fibonacci
34:23 - problem doesn't mean that it's
34:24 - completely something that we've mastered
34:26 - so if anything this should be a quick
34:27 - little review right of course I want you
34:30 - to solve this tribonacci problem uh
34:32 - recursively
34:33 - and so let's take a look at the sequence
34:36 - so here is a few numbers of the
34:38 - Fibonacci sequence all you'll notice is
34:40 - in this particular problem like before I
34:42 - want you to give me back a particular
34:44 - number of the sequence so imagine that
34:46 - we had corresponding indices for each of
34:48 - these numbers
34:49 - when it comes to the tribonacci sequence
34:51 - we're going to have three separate base
34:54 - cases right the zeroth number of the
34:56 - sequence is zero and also the first
34:58 - number of the sequence is zero and the
35:01 - second number of the sequence is one so
35:03 - with those three seed values we can come
35:06 - up with our general rule right just like
35:08 - before to calculate a number of the
35:10 - sequence or the next number of the
35:12 - sequence you just take the sum of the
35:14 - previous three numbers right or in
35:16 - general to calculate trip of n you do
35:19 - the sum of N minus one n minus two and N
35:22 - minus three and there you'll have your
35:24 - final answer right it's kind of jumping
35:26 - at a particular spot within the sequence
35:28 - if I took the sum of 4 plus 7 plus 13
35:32 - that would give me exactly 24. so you
35:35 - should feel red at home in this
35:37 - particular problem
35:39 - so let's start to draw this one now I
35:42 - don't want to skip any steps
35:44 - and so before we start building this one
35:46 - let's have some foresight and figure out
35:47 - how to visualize a problem like this
35:50 - right and what's great about visualizing
35:52 - it is at least if we spend some time you
35:54 - know sketching out you know a structure
35:56 - of the problem like visually it can also
35:58 - help us figure out the complexity of
36:00 - this particular problem
36:01 - so right now I want to step through
36:03 - calculating the fifth number of the
36:05 - sequence which should be four in the
36:07 - long run so like before I'm going to
36:09 - represent an instance of this problem
36:10 - just with a tree and so my top level
36:13 - problem will be the root of this tree I
36:15 - want to find a trip of five
36:17 - and I know that I have to break this
36:19 - problem down into three sub problems
36:21 - right in other words I can generate
36:22 - three children by doing a minus one
36:24 - minus two and minus three respectively
36:27 - I'm just going to carry over that
36:28 - pattern for as many nodes as I can and
36:32 - of course whenever I hit like a base
36:33 - case I can't break that node down any
36:36 - further we know that when it comes to
36:38 - our tribonacci problem we have three
36:40 - separate base cases right representing
36:42 - these particular return values so I'm
36:45 - just going to plug in these sub results
36:48 - so I should have all of these calculated
36:51 - values right zeroth number is zero first
36:53 - number is zero and also the second
36:55 - number is one
36:56 - now I can start reconstructing my sub
36:59 - Solutions right so if I take a look at
37:01 - the particular uh to the left the three
37:04 - node I take the sum of its three
37:05 - children one plus zero plus zero gives
37:08 - me one right so the third Fibonacci
37:10 - number is one and I'll just continue
37:12 - this pattern right every parent node
37:13 - just takes the sum of its three children
37:16 - return values
37:18 - so I get values that look like this and
37:20 - finally at the root I just take the sum
37:21 - of two plus one plus one which gives me
37:24 - a final answer of 4 right very similar
37:27 - to our classic a fib problem so this
37:29 - would be a working solution basically
37:31 - just doing the same a recursive code
37:33 - except we're going to have three
37:35 - recursive calls which makes sense
37:37 - because every call we make corresponds
37:39 - to a branch that we have in this visual
37:41 - tree however
37:43 - what's the complexity of this one it's
37:46 - pretty pretty slow for the same reasons
37:48 - our Fibonacci code was slow before right
37:50 - so take a look at this particular tree I
37:52 - can derive the time complexity of it
37:54 - because I know that for my recursive
37:56 - code the time complexity is at least
37:58 - going to be the number of recursive
38:01 - calls that I make And if every recursive
38:03 - call corresponds to a note of this tree
38:05 - I have to figure out what the long term
38:07 - pattern for the number of nodes is in
38:09 - this recursion tree so I know that the
38:11 - height of this tree is pretty obvious
38:12 - looks like it's going to be along the
38:14 - order of N and how do I know that well
38:16 - if you look along the left-hand path it
38:18 - just goes five four three two and in
38:21 - general that's roughly N Things right
38:24 - now just think about how many nodes are
38:26 - across on every level at the top level
38:28 - there's one node and to get to the next
38:30 - level I multiply it by three I continue
38:33 - this pattern right as a tree gets bigger
38:35 - and bigger from one level to the next I
38:37 - would continue by tripling the number of
38:39 - nodes right very similar to our
38:41 - Fibonacci problem and so you guessed it
38:43 - the complexity of this is 3 to the N so
38:47 - an exponential but with a base of three
38:50 - right and it is a case that our space
38:53 - complexity is a pretty reasonable o of n
38:55 - right of course we're referring to the
38:57 - space complexity due to the call stack
38:59 - right and in general we can figure out
39:01 - the space complexity from the call stack
39:03 - if we draw out the tree and we can just
39:06 - look at the height of the tree the
39:08 - height of the tree being basically the
39:10 - number of levels and there's roughly you
39:13 - know four levels here so I guess it's
39:14 - off by one even though our input was
39:16 - five right
39:18 - so to make this one a little faster of
39:20 - course we can just notice any duplicate
39:22 - sub problems right so same story like
39:24 - we're used to look at this sub tree
39:26 - rooted in three I have this sub tree
39:29 - appearing here as well and so I want to
39:31 - avoid resolving that sub problem we're
39:33 - going to use the same scratch as before
39:35 - but this I want to use a different word
39:36 - to describe it really what we're
39:38 - utilizing here is dynamic programming so
39:41 - dynamic programming is really a type of
39:44 - problem solving where we utilize any
39:46 - overlapping sub problems right in other
39:48 - words I have this sub problem of
39:50 - calculating the third tribonacci number
39:52 - and if I can store that information the
39:55 - first time I solve that problem I can
39:57 - utilize it later on because I'm probably
39:58 - going to encounter that same sub problem
40:01 - all right so this is in the family of a
40:04 - dynamic programming strategies and so
40:06 - far we've been working with memoization
40:08 - so really memoization is just one way we
40:11 - can Implement dynamic programming and so
40:14 - if we use dynamic programming wisely we
40:16 - should be able to forego that duplicate
40:18 - subtree right
40:20 - and overall we'd be looking at an O of n
40:23 - runtime and O of n space complexity if
40:26 - we implemented that correctly
40:28 - right and so to implement that of course
40:30 - we're going to use some hash data
40:31 - structure to build that memo so for my
40:34 - python people you're going to use like a
40:36 - dictionary for my JavaScript people
40:37 - you're going to use an object for my
40:38 - Java people I'm going to use a hash map
40:40 - right any fast lookup data structure and
40:44 - at this point we have a pretty optimal
40:46 - solution for this tribonacci sequence
40:48 - right it should be able to run in a
40:49 - pretty decent time and so with that what
40:52 - I want you to do is I give this code a
40:54 - shot on your own but don't forget if you
40:56 - get stuck we do have a Code walkthrough
40:58 - available as well so give it a go
41:00 - now that we're done sketching out this
41:02 - tribonacci problem on our whiteboard
41:03 - what you want to do is head down to the
41:05 - links in description and click on the
41:07 - tribonacci link that way you can follow
41:08 - along and code up the Java solution with
41:10 - me
41:15 - hey programmers welcome back right now I
41:16 - want to go over the Java walkthrough for
41:18 - this Fibonacci problem
41:20 - so it's going to be another dynamic
41:21 - programming problem just to kind of ease
41:23 - us into the core pattern that I'm trying
41:25 - to teach you guys in this course and
41:26 - that'll help you solve almost any
41:28 - dynamic programming problem
41:30 - and so this is going to be a variation
41:32 - Alpha Fibonacci just called Fibonacci
41:34 - it's really the same pattern except to
41:35 - generate a further number of the
41:37 - sequence you need to use the sum of the
41:39 - previous three numbers and here I'll
41:41 - start with my base cases right I know
41:42 - the Fibonacci sequence has some
41:44 - different seed values we see that the
41:46 - zeroth and first numbers are both zero
41:48 - right so I'm going to actually just go
41:50 - ahead and jump right in here I'll start
41:52 - with that as my base case I'm going to
41:53 - solve this one for now with a Brute
41:55 - Force recursion
41:56 - so I'm going to check hey if my n is
41:59 - zero or my n is one well the 0 and 1
42:03 - elements of the sequence how about zero
42:06 - so I return 0 in either case
42:08 - then additionally I need another base
42:09 - case if n is two I return the number one
42:13 - really just arbitrary values for this
42:15 - sequence here so if n equals two
42:17 - and return the value of one those would
42:19 - be my two base cases when it comes to
42:22 - creating the recursive
42:24 - case here you just take the sum of the
42:26 - last three numbers of the sequence so
42:28 - for me that's as simple as I take the
42:31 - tribonacci of n minus one and I add that
42:34 - to tribonacci of n minus 2.
42:37 - and also add a 2 triple Notch of n minus
42:40 - three
42:41 - cool so let's give that a test run this
42:43 - is a really important step never ever
42:45 - skip it right whenever you're solving a
42:47 - dynamic programming problem using
42:49 - memorization you ought to solve it Brute
42:51 - Force first and verify that your code is
42:54 - correct for me correct means that I
42:57 - always get a correct result for my
42:59 - method right a timeout is okay right
43:01 - eventually if we had more time all right
43:03 - to use up here you would be able to pass
43:05 - test k07 you will get the correct answer
43:07 - but this code is just far too slow as it
43:10 - is right so now that I've verified that
43:12 - okay this code is just a matter of speed
43:14 - right it's just slow I can add
43:16 - memoization on top of it so just like
43:18 - before
43:18 - for you and job I think the best way to
43:20 - solve this one the structure of code is
43:22 - to overload this method and your
43:25 - recursive method your brute force is now
43:27 - going to take in a new argument
43:29 - it's going to be a hash map and when it
43:31 - comes to how I set up the keys and
43:32 - values keys are going to be the
43:33 - arguments here method here I just have a
43:35 - single argument n so I'll make that an
43:37 - integer key
43:39 - the corresponding return value is going
43:42 - to also be an integer so it's going to
43:43 - have integer value
43:44 - I like to call it memo awesome from
43:47 - there in my main method you just want to
43:49 - delegate to your recursive Helper and
43:52 - you should pass in you know a new hash
43:54 - map instance here so at the top I should
43:56 - import the right
43:58 - thing here so I'll import Java util hash
44:02 - map
44:03 - and you can pass it in inline be sure
44:04 - instantiated here so new hash map
44:08 - awesome and now when it comes to my
44:12 - recipe for memorization I have the Brute
44:14 - Force I'll start by adding a base case
44:15 - that checks if my key or my input
44:18 - argument is already in the memo so I'll
44:21 - add over here along my base cases
44:23 - I'll say if my memo
44:26 - contains the key of n
44:29 - right and if it's there that means I
44:31 - would have also stored the value that is
44:33 - the answer for that input n
44:35 - I'm just going to return whatever that
44:37 - stored answer that stored value is I'll
44:39 - do memo dot get and in that case
44:42 - awesome so I have the logic that looks
44:45 - into my memory like my memo fetching
44:47 - logic now I need my memo insertion logic
44:49 - right so now I need to locate my
44:51 - recursive return value right this is
44:53 - where I return the final answer for n
44:56 - right this would be a number technically
44:58 - I'm going to store it to a variable
45:01 - call it result and before I leave and
45:03 - return the result I actually want to
45:05 - store that result into my memo so I
45:08 - actually do memo dot put
45:10 - and you should always
45:12 - use the key that's your current input
45:15 - argument right so this result is the
45:18 - answer for Fibonacci of n right because
45:20 - I'm returning it for a call to n and so
45:23 - n is going to be my key here right so
45:25 - I'll do n I'll make the value the result
45:28 - a very important design choice that we
45:31 - make when we solve our memoization this
45:34 - way is we're only going to memoize our
45:36 - current call right so in other words all
45:39 - of my memo keying happens with the
45:42 - argument n right I check if it contains
45:45 - n and if it doesn't then I put a new key
45:48 - of N I don't write any like awkward
45:50 - heavy-handed logic like doing memo dot
45:54 - put I try to Cache like n minus 1 with
45:57 - some subresult right that gets very very
45:59 - messy right because we're solving this
46:01 - recursively if we handle
46:04 - all of the memoization for our argument
46:06 - n then everything else will actually be
46:08 - memorized as well right because you know
46:10 - that for this particular call when we
46:12 - jump in and evaluate that call
46:14 - recursively this n minus one Whatever
46:16 - actual number that is that is an n in
46:19 - some other frame of reference right so
46:21 - you're only going to want to memorize to
46:23 - keep your code very clean adjust your
46:25 - current argument n right don't try to do
46:27 - any of like the the sub problems with
46:29 - the children here
46:30 - awesome
46:31 - and one final thing to do if I actually
46:34 - test this it's a very common mistake it
46:36 - won't actually be any faster that's
46:38 - because these calls are Fibonacci in my
46:40 - recursive case they need to actually
46:42 - refer to my overloaded method here which
46:45 - takes in my memo I obviously I want to
46:47 - share this memo hash map for the entire
46:50 - recursion tree here
46:51 - so I'm going to add that into the mix
46:52 - just pass along the memo
46:56 - and that should do the trick
46:58 - awesome and there we have it
47:02 - hey programmers Alvin here right now
47:03 - let's go over the approach for this some
47:05 - possible problem
47:06 - so this probably want to take in two
47:07 - arguments we're going to be given a
47:09 - amount as well as a array filled with
47:11 - numbers and we want to do is return true
47:13 - or false indicating whether or not we
47:16 - can use some numbers of the array to
47:18 - generate the amount by adding them
47:19 - together in this particular example I
47:21 - should return true because I can totally
47:23 - make 5 by adding up some numbers in the
47:25 - array there are a few different ways to
47:26 - do that I could have done two plus three
47:28 - or three plus one plus one we're also
47:31 - two plus one plus two and there are
47:32 - actually a whole bunch of other
47:33 - different ways you can sum up to five
47:35 - but since I have at least one way to
47:37 - generate five I'm going to return true
47:39 - so overall we're just looking for a
47:40 - Boolean return type for a function here
47:42 - it could be the case that based on the
47:44 - inputs we're given it might not be
47:45 - possible so if I gave you a Target
47:47 - amount of 15 and I gave you numbers to
47:49 - choose from like 6 4 and 10 that would
47:51 - actually be impossible so you should
47:53 - return false all right so how do we
47:54 - start attacking this one we'll step
47:56 - through an example where you want to
47:57 - generate a Target amount of four and we
47:59 - have numbers one two and three this
48:01 - should be a sufficiently large example
48:03 - to step through here my intuition tells
48:04 - me that smaller amounts are easier to
48:06 - calculate late than larger amounts so
48:08 - what I can do is try to shrink my amount
48:10 - as much as possible until I get to a
48:12 - trivially small amount for which I know
48:14 - the answer for so let's say I start with
48:16 - my amount of four what options do I have
48:18 - here well if I think about my first
48:20 - choice what I could do is take a one so
48:23 - this one is going to represent the first
48:25 - number I can choose right and what I can
48:27 - do from there is actually subtract that
48:28 - one from the four that would give me a
48:31 - new amount of three
48:33 - but still at the four note over there
48:34 - what I can do is also maybe consider
48:36 - taking a two
48:37 - if I do 4 minus 2 then my next minus 2.
48:40 - and the final option would be taking a
48:42 - 3. if I do 4 minus 3 that'd give me one
48:44 - and at this point I'm starting to shrink
48:46 - my problem size so inside of the nodes
48:49 - in blue we're going to have listed the
48:51 - amount that we're trying to break down
48:53 - and then the numbers in yellow on the
48:55 - edges represent the choice of numbers
48:56 - that we choose we're starting to shrink
48:59 - our problem size so let's say we took a
49:00 - look at the three note on the left we
49:01 - can break it down further right using my
49:03 - options of one two and three and that
49:05 - would yield two one and zero
49:07 - respectively if I take a look at this
49:09 - two note over here in the middle I have
49:10 - to watch out because I can only use some
49:12 - of my numbers for valid moves right in
49:15 - other words I can do two minus one or
49:17 - two minus two and that'll give me a one
49:19 - and zero respectively but what I should
49:20 - not do is 2 minus three right although I
49:23 - have a third option of doing a three
49:25 - that would be too large right now and
49:27 - that would actually bring me to a
49:28 - negative quantity so we're gonna need to
49:30 - watch out for that in our drawing as
49:32 - well as when we implement the code
49:33 - similarly for this right hand note of
49:35 - one I can only subtract one for it
49:36 - because using any of the other numbers
49:38 - would bring me to a negative quantity so
49:40 - I'll continue this pattern for all of
49:41 - our nodes until we can't break them down
49:43 - any further and this would be the
49:45 - complete tree really what we're
49:47 - describing is the decision tree for all
49:49 - of the options that we can possibly make
49:51 - right so although I'm saying tree here
49:53 - I'm really referring to the fact that
49:54 - we're breaking this problem down
49:55 - recursively we go ahead and implement
49:57 - this we're not going to have to build
49:58 - any like tree data structure but we're
50:00 - going to solve it using recursion right
50:02 - I use this tree as a way to actually
50:05 - understand all the options I can take
50:07 - so since we know that this tree
50:09 - visualizes the recursion or where can we
50:11 - locate the base case well that would
50:12 - really be just the leaves of this tree
50:14 - what we can do is recognize that we have
50:16 - a bunch of zero nodes over here and to
50:18 - me that would be a trivially small
50:20 - amount that I can always know the answer
50:22 - for so that's going to be my base case
50:23 - right in other words if someone gave me
50:25 - an amount of zero I'm just going to
50:27 - return true why does that make sense
50:29 - well I can always generate Zero by just
50:32 - taking no elements of the numbers array
50:35 - I can always return true regardless of
50:37 - what numbers you give me you can even
50:38 - give me no numbers and that'd be totally
50:40 - fine I can still generate Zero by taking
50:42 - none of those numbers and so what I'll
50:43 - do is jot down this return value above
50:45 - all of my zero nodes those are going to
50:47 - be my base cases right my base case
50:49 - calls and I know that if I see a single
50:50 - true anywhere in the tree then it should
50:52 - be possible to generate the amount
50:54 - obviously here we can't really go wrong
50:56 - and we have a lot of different ways to
50:57 - generate the amounts if you look within
50:59 - this tree not only do you know that
51:01 - there are a bunch of different ways to
51:02 - make our amounts of four but you can
51:04 - actually see what numbers you added to
51:06 - generate that amount for example if I
51:08 - look at this path
51:09 - this represents doing a one plus two
51:11 - plus one to generate four right I'm just
51:14 - adding the numbers that I have along the
51:16 - edges here so this tree tells you a lot
51:18 - of information and you can use it to
51:20 - solve a bunch of different variations of
51:22 - this problem so now let's start to look
51:23 - at how the values return here so given a
51:26 - parent note if it receives a true from
51:28 - any of its children then it's also going
51:30 - to return true so that would evaluate
51:32 - something like this
51:39 - until we get a true at the top as our
51:40 - final answer so far we've described The
51:42 - Brute Force way to calculate the answer
51:44 - here I think it's worth going through
51:45 - the complexity so here I have two
51:47 - arguments to my function if we say that
51:49 - a is the amount and N is the length of
51:51 - numbers you can see that the time
51:53 - complexity is going to be n to the a
51:55 - power so this is going to be exponential
51:58 - so we're doing here is putting n in the
52:00 - base of the exponent because we know
52:02 - given a node it's going to give at most
52:05 - n children because I have to Branch for
52:07 - every option of number in the numbers
52:09 - array and I'm putting a in the exponent
52:12 - because I know that the height of the
52:14 - tree is at worse going to be a you can
52:16 - easily see that in this particular
52:17 - example if you start at the root and
52:19 - just keep going to the left it goes four
52:21 - three two one zero which would mean that
52:24 - the height of the tree in the worst case
52:25 - is exactly a if I had to keep
52:27 - subtracting 1 from my node so overall
52:30 - I'm looking at an N to the a complexity
52:32 - which is an exponential and typically
52:34 - going to be too large to actually run
52:35 - for reasonably large inputs we talk
52:38 - about the space complexity it's just
52:39 - going to be o of a right now based on
52:41 - the heights of our tree right we know
52:43 - the height of the visual tree would give
52:45 - us the maximal stack depth so how can we
52:47 - do better well you should probably catch
52:49 - the drift by now take a look at this
52:50 - tree and notice if you see any duplicate
52:52 - work
52:55 - what I can notice here is I have some
52:57 - duplicate subtrees right I can see these
52:58 - sub trees rooted in two that are
53:00 - identical and even have smaller sub
53:02 - trees that are the same like the ones
53:03 - rooted in one and I know that if I have
53:05 - duplicate sub trees in this visual that
53:07 - means I'm trying to solve duplicate
53:09 - problems right if someone asks me is it
53:12 - possible to generate two for the first
53:14 - time then later on if someone asks me
53:15 - again I should have just memorized that
53:17 - answer right and so here we're going to
53:19 - use that memoization strategy just store
53:21 - some solutions and some cash that way I
53:23 - can fetch them later on if you
53:26 - implemented memoization like we've seen
53:27 - previously then you would be able to
53:29 - trim out some branches of this tree
53:31 - ending up with this smaller structure
53:34 - what would this memoized complexity be
53:36 - well we'll still say that a is the
53:37 - amount and N is the length of numbers
53:38 - what we did was actually remove the
53:41 - exponential nature of this problem now
53:43 - we'll say that the time complexity is O
53:45 - of a times n so it's no longer an
53:47 - exponent I'm simply multiplying them
53:50 - right so a still represents the number
53:52 - of levels within my tree right the
53:54 - height of the tree and then n represents
53:56 - the width of my tree right for every
53:58 - level I will have at most n nodes and it
54:01 - would still be the case that our space
54:03 - complexity is O of a we would still use
54:05 - a a stack frames on our call stack due
54:07 - to the recursion and in terms of storing
54:09 - our memo we know that's also going to be
54:11 - linear in a and when it comes to the
54:13 - hash map we use to store our memo the
54:15 - space complexity for that is still going
54:16 - to be o of a because we're just going to
54:18 - use every amount every possible amount
54:21 - as a key of that memo before I let you
54:24 - go let's step through an amount that
54:25 - would not be possible given some numbers
54:27 - so we'll step through a scenario that
54:28 - should return false so my amount is 15
54:30 - and I have numbers of 4 6 and 10. if we
54:33 - attack this one the same way we'll start
54:35 - with 15 in the root and we'll subtract
54:37 - each option of number giving us 11 9 and
54:40 - 5 and I'm going to carry this over as
54:42 - much as I can until I can't reduce my
54:44 - amount anymore so the full tree will
54:47 - look like this the nodes highlighted in
54:49 - red are the nodes that I can't break
54:51 - down any further because it would bring
54:52 - me to a negative quantity so if I have
54:55 - any remaining quantities in those red
54:57 - nodes then I know that that would mean
54:58 - those quantities are not possible to be
55:00 - generated so those should be a base case
55:02 - that return false now I can evaluate my
55:05 - returns in the same way as usual right I
55:06 - just bubble these up to their parents a
55:09 - parent is going to return true only if
55:11 - one of its children calls also returned
55:13 - true but everyone here is false so I'll
55:16 - get false all the way back up the tree
55:18 - all right programmers I think that's all
55:19 - I got for this approach video what you
55:21 - want to do is possibly give this one a
55:22 - shot on your own see if you can
55:24 - translate our visual diagrams into some
55:26 - code and then if you got stuck you can
55:27 - find me in the walkthrough videos I'll
55:29 - see you there
55:30 - now that we're done drawing up are some
55:32 - possible solution what you want to do is
55:34 - head down to the links in description
55:36 - below where you can find the link to the
55:38 - some possible problem because we're
55:39 - going to code up the Java solution right
55:40 - now together
55:46 - hey programmers Alvin from structure
55:48 - here what I want to do is go over the
55:49 - Java walkthrough for the some possible
55:51 - problem so you definitely want to make
55:53 - sure you watch the approach video for
55:54 - this one this is going to be what I
55:56 - consider like our first like actually
55:57 - difficult uh dynamic programming problem
56:00 - and so those previous toy problems of
56:02 - like fib and Fibonacci those have all
56:05 - been building up to a problem like this
56:07 - right what I really want to emphasize is
56:08 - we kind of write the code for this is
56:10 - try to compare the process for solving
56:12 - it similar to how we solved Fibonacci
56:15 - and Fibonacci right meaning that we're
56:17 - going to start by solving just some
56:18 - Brute Force recursion check that it
56:19 - works check that it's correct it's
56:21 - probably going to be too slow and then
56:22 - we add our memoization on top of it
56:24 - right we're going to scale out the
56:25 - solution here
56:26 - and so let's Jump Right In
56:29 - and so to solve this one I know I need a
56:31 - Brute Force recursion and with any
56:32 - recursion I like to think about my base
56:34 - cases right so when it comes to my base
56:36 - cases I have to think about all right
56:37 - what are some like trivially small
56:39 - inputs for which I automatically know
56:41 - the answer like we said in the approach
56:42 - video The Great base case here is going
56:44 - to be if your amount is really small so
56:46 - if my amount is zero
56:49 - if your amount to zero then what you
56:50 - want to do is kind of give back a
56:52 - Boolean representing all right is it
56:53 - possible to add up numbers such that
56:56 - their sum is zero and that's always
56:58 - possible right you're going to always
56:59 - get a sum of Zero by adding no numbers
57:02 - together right that's trivially true and
57:04 - so I'm going to return true here so if
57:06 - you hit an amount of zero just return
57:08 - true
57:09 - awesome but from there I know I have
57:12 - some positive amount and I need to break
57:14 - it down smaller and smaller toward this
57:16 - base case and I know that to shrink the
57:19 - amount I must subtract some value from
57:22 - the numbers list so I'm going to start
57:24 - iterating through the possibilities here
57:25 - so I'm going to iterate through every
57:26 - int I'll say none within the numbers
57:28 - list
57:29 - and I know that I'm going to take my
57:32 - current amount and subtract it by this
57:35 - number so just for some clarity I'm
57:37 - going to label this variable as my sub
57:39 - amount right because it's my original
57:40 - amount just with some number reduced out
57:44 - of it
57:45 - awesome and now what I want to do is
57:48 - keep solving this problem recursively so
57:50 - now I want to figure out is it possible
57:51 - to have a sum that adds up to this sum
57:55 - amount and I have a method to do that
57:56 - it's the current method I'm writing
57:58 - right so I'm going to call
57:59 - some possible and check if the sub
58:01 - amount is possible Right the second
58:03 - argument to this recursive method should
58:06 - be the same argument right numbers you
58:08 - can reuse the numbers as much as you
58:09 - want so I can pass in the same numbers
58:12 - awesome but now recursively have to
58:14 - think about all right what does this
58:16 - give back well I know that it definitely
58:18 - gives back a Boolean and that Boolean
58:19 - represents whether or not it's possible
58:21 - to create these sub amount right if it
58:25 - is possible so if this comes back as
58:26 - true then I know that it must be
58:28 - possible to sum up to the entire full
58:31 - amount so I'm going to return true here
58:34 - and why does that logically make sense
58:35 - well if it's possible to make my sub
58:38 - amount right it must also be possible to
58:41 - make my full amounts because to make my
58:43 - full amount I can just add one
58:45 - additional number to it right because to
58:47 - get the sub amount in the first place I
58:48 - took out one valid choice of number but
58:51 - on the flip side if it's not possible so
58:53 - if this a recursive call returns false
58:56 - then you want to keep looking and
58:57 - consider if another choice of number
58:59 - would be possible right so something to
59:02 - watch out for is you don't want to write
59:03 - like a else return false
59:05 - right because you would exit too early
59:07 - right you only want to return true if
59:09 - you find a valid amount right the place
59:12 - you should return false is only after
59:13 - you're done checking every possible
59:15 - amount and you don't find one right so
59:16 - you want to write a late return false
59:18 - here
59:19 - all right if I don't find any uh sub
59:21 - amount that's possible and I checked all
59:23 - of them so after my for Loop then you
59:24 - can return false hey it must not be
59:26 - possible to create my amount awesome so
59:29 - this looks like my Brute Force solution
59:31 - but we are missing a one kind of glaring
59:34 - case we'll want to pay special attention
59:36 - to our subtraction on line 10. right
59:39 - based on what our amounts and number is
59:40 - we could get like a negative value for
59:42 - sub amount imagine my amount is two and
59:44 - maybe my number is five well if I do two
59:47 - minus five I get negative three and
59:48 - things will get kind of nasty from there
59:50 - because at that point I've already
59:52 - overshot my base case of zero and so
59:55 - you'd get increasingly more negative
59:56 - numbers right as your amount
59:58 - and so we never really want to let our
60:01 - amount become negative so I like to turn
60:03 - that into a base case so if my amount
60:05 - becomes negative and I can return false
60:08 - right it's not going to be possible to
60:10 - create a negative amount using a sum
60:13 - because they tell us in the problem that
60:15 - our numbers are all going to be positive
60:17 - right you can never generate a negative
60:18 - quantity by summing up positive numbers
60:21 - awesome so now I'll make sure we don't
60:23 - overshoot right we'll get just return
60:25 - false here that'll help us complete
60:27 - The Brute Force recursive here so let's
60:30 - give that a shot
60:31 - always want to make sure that it gets a
60:33 - correct answer and it just times out
60:35 - right so now I know that this is a great
60:37 - candidate for applying memoization right
60:40 - we know that like we said in the
60:41 - approach video this currently has an
60:43 - exponential run time so it's far too
60:45 - slow
60:45 - so to structure the
60:48 - optimize solution here I like to split
60:51 - up into my main method and my recursive
60:53 - method that also takes in a new argument
60:55 - which like we're used to from our last
60:57 - two problems right it should be a hash
60:59 - map
61:00 - cool the keys of the hashmap are just
61:03 - going to be the argument of My Method
61:06 - but it's only going to be the argument
61:08 - that changes right so if I look at the
61:10 - recursion here I know that amount is
61:13 - really the argument that changes over
61:14 - time right the numbers argument or the
61:17 - list of numbers doesn't change right so
61:19 - I know that that list of numbers in my
61:21 - recursion doesn't really dictate the
61:23 - result right because another changes I
61:25 - always return based on what the amount
61:27 - is and so I'm just going to make the
61:30 - integer amount
61:31 - my key right the corresponding value is
61:34 - going to be just the return type of your
61:37 - method so Boolean here
61:39 - I know that corresponds with you know
61:41 - the return values online like 20 and 24
61:43 - and even in the base case
61:45 - awesome I'm going to call this my memo
61:47 - once again
61:48 - so let me go ahead and do some of the
61:50 - housekeeping here so I want to
61:51 - get the hashmap
61:54 - and when I I'm in my main method I'm
61:57 - just going to invoke my overloaded
61:59 - helper method give it the same amount
62:00 - give it the same numbers but you should
62:02 - give it a new hash map that's going to
62:04 - populate over time so it's nice and fast
62:06 - awesome at this point what I want to do
62:08 - now is add my base case to check hey
62:12 - maybe an input amount I've seen before
62:15 - right so I'm going to add as a base case
62:17 - here so if my memo
62:19 - contains a key
62:21 - that corresponds to the current amount
62:23 - I'm looking for I just want to return
62:24 - its stored value because I would have
62:26 - stored the answer there so return memo
62:28 - dot get amount all right very
62:31 - reminiscent of your Fibonacci and
62:33 - Fibonacci awesome other things I need to
62:36 - do is need to be sure to pass this memo
62:38 - by reference to all of my recursive
62:40 - calls and I know that there are actually
62:41 - multiple recursive calls here because on
62:43 - line 25 I have a recursive call and it's
62:45 - in a loop right so you make a recursive
62:46 - call for every num of the list
62:50 - I'm going to over here pass in the memo
62:52 - and now the only thing I'm missing is I
62:55 - need to find a way or find a location
62:56 - where I should add information into the
62:59 - memo right when do I put some keys and
63:01 - values into the memo like I said in the
63:03 - previous videos I always locate my
63:05 - recursive return values right so that
63:08 - would be line 26 and line 30 right to be
63:10 - safe you can memorize both of those
63:12 - return values right there's no points of
63:14 - memorizing your base case return values
63:16 - because those already occur in constant
63:17 - time right so there's no need to do it
63:19 - there
63:20 - so over here before I return true you
63:23 - want to store in your memo
63:25 - for the key of amount
63:29 - the same value would have returned right
63:31 - so if you return true then your stored
63:33 - value is true
63:34 - or if you return false
63:37 - then in that case your stored value is
63:39 - going to be false right and like we
63:42 - always say the key that you kind of
63:44 - refer to through your entire memo logic
63:47 - is going to be the argument amount right
63:49 - so I'm not writing any keys that have to
63:52 - do with the sub amounts to keep your
63:54 - code nice and clean you write about your
63:56 - current amount you're passed in right
63:57 - you know when you make your recursive
63:59 - call on the sub amount that will become
64:02 - its own like full amount and then it
64:04 - will get cached anyway in the memo so
64:07 - this should be good to go
64:08 - let's give this a test run
64:10 - see how we optimize our solution
64:12 - great and there we have it
64:17 - hey programmers Alvin here right now
64:19 - let's go over the approach for this Min
64:20 - change problem
64:21 - so in this problem we want to do is take
64:23 - in two things as input we're going to be
64:24 - given a Target amount as well as an
64:26 - array containing some coin values what
64:28 - we want to do is return the minimum
64:30 - number of coins required to create the
64:32 - amount so for example since my target
64:34 - amount is 5 one way I can give back five
64:37 - cents would be to do one plus one plus
64:39 - one plus one or I can do one plus two
64:41 - plus two or I could even do one plus one
64:43 - plus three and also two plus three in
64:46 - this problem what we want to do is
64:47 - choose the way that requires the least
64:49 - number of coins so that would be the two
64:51 - plus three that would use only two total
64:54 - coins and my function should just return
64:55 - that number of coins which would be two
64:57 - as my final answer all right so let's
64:59 - start attacking this one by visualizing
65:01 - it let's sketch out what we would do for
65:02 - an amount of four that way we can
65:04 - actually finish it because we're going
65:05 - to see that as we moderately increase
65:07 - the amount the size of our problem
65:09 - actually grows pretty large and so if
65:11 - you're doing all these problems in order
65:13 - and I always recommend that you do you
65:14 - should recognize this one as a dynamic
65:16 - programming problem so I'm going to try
65:18 - to do is shrink my problem size then
65:20 - also notice any overlapping sub problems
65:23 - in the long run and so I'm going to
65:24 - sketch things out as a tree what I'll do
65:26 - in the nodes of my tree is write down my
65:28 - current amount that I need to generate
65:30 - and I can break my current amount down
65:32 - into smaller sub amounts so let's say I
65:34 - start with 4 at my root to generate
65:36 - amount to 4 what I could do is use a one
65:39 - cent coin if I did that my remaining
65:42 - quantity would be three as my amount I
65:44 - could have also taken a 2 which case I
65:46 - need to generate two where I could have
65:48 - taken the three cent coin in which case
65:49 - my remaining amount would have been one
65:51 - so let's continue this pattern let's say
65:53 - I was at this three node this node would
65:55 - have three more children just branching
65:57 - for one cent two cents and three cent
65:58 - respectively
65:59 - if I take a look at this two note over
66:01 - here I can't actually use every option
66:03 - here I certainly Branch twice because if
66:06 - I took the three cent coin that would
66:08 - give me a remaining amount of negative
66:09 - one which I should probably avoid
66:11 - similarly for this note of one I can
66:13 - only Branch using the one cent coin so
66:15 - let's say we continue this pattern for
66:16 - the entire tree you would end up with
66:18 - this structure and what we see visually
66:20 - is the decision tree that represents
66:22 - every choice of a coin we can make until
66:24 - we hit zero and so this is a tree
66:26 - structure that we've seen a few times in
66:27 - the course what I'm going to argue is
66:29 - within the visual of this tree you
66:31 - should actually be able to recognize
66:33 - what the answer is for this amount of
66:35 - four so take a moment see if you can
66:36 - recognize any properties within this
66:38 - tree where can I find the answer to this
66:41 - problem
66:42 - what we should do is interpret each path
66:44 - of this tree so let's say I looked at
66:46 - this path
66:47 - that would represent the sum of one plus
66:50 - two plus one in other words I took a one
66:52 - cent coin and a two cent coin and then
66:54 - another one cent coin what I can say is
66:56 - that would represent the answer of three
66:58 - like a possible answer of three because
67:00 - I used three coins to generate my target
67:02 - amount of four that's only one
67:04 - possibility we know in this problem we
67:06 - really want the minimal a number of
67:08 - coins used so that should translate into
67:10 - one of these shortest paths like this
67:12 - one
67:13 - this would represent my sum of three
67:15 - plus one and that would have a length of
67:17 - two you could probably notice that there
67:19 - are a few other paths with a length of
67:20 - two that's okay we just want to return
67:22 - the smallest length possible which would
67:24 - be two and so what we're really
67:25 - recognizing here is the minimum number
67:27 - of coins required to generate our amount
67:30 - would really be the shortest path from
67:32 - the root to any Leaf within this tree
67:34 - assuming a leaf terminates at a zero so
67:37 - how can I do this more programmatically
67:38 - maybe we'll sketch this out as some
67:40 - recursion tree right so what I'll do is
67:42 - think of a return value for all of these
67:44 - zero nodes
67:45 - we can say is our base case if our
67:47 - amount is zero then I should return zero
67:50 - and so zero is a great choice because
67:51 - it's a small number and I can't break it
67:53 - down any further and I should also
67:55 - return 0 for that instance because the
67:57 - minimum number of coins required to make
67:58 - zero sense would be to use zero coins
68:01 - right just use no coins
68:03 - so above all of these base case nodes
68:04 - I'm going to jot down my result of zero
68:07 - and what I can do is start to evaluate
68:09 - these as return values so let's say I
68:11 - was at this node of 1 over here what
68:13 - I'll do is just receive Zero from my
68:15 - child call what I should also do is add
68:17 - 1 to it if I add one that would actually
68:20 - count the edge between myself and my
68:23 - child node because remember when it
68:25 - comes to counting the number of coins
68:26 - we're really counting the number of
68:28 - edges in a path through this visual tree
68:31 - so let's say I was at this two node now
68:33 - I was ready to evaluate it what I do is
68:35 - receive both of these values of 1 and 0
68:37 - for my children
68:39 - and because I want the shortest path or
68:41 - the minimum number of coins my nodeans
68:44 - to choose a smaller between the two so I
68:46 - do one versus zero I pick the smaller
68:48 - one of zero but then what I need to do
68:50 - is actually increment that by one to
68:52 - count the edge between us and what that
68:54 - would represent this one designates the
68:57 - shortest way I can make two cents which
68:59 - would represent this path highlighted in
69:01 - pink let's continue this pattern so
69:03 - let's say I was at this one node the
69:05 - zero would just bubble up then I add one
69:06 - to it because there's no decision to
69:08 - make but now it can be at this three
69:10 - node this three node is going to receive
69:12 - three options it's going to choose the
69:14 - smallest among them so just zero but
69:16 - then it needs to add one to it and at
69:18 - this point I should be able to check for
69:19 - correctness I have a green number of one
69:21 - above my three node which means the
69:24 - minimum number of coins I need to make
69:25 - three cents would be just using one coin
69:27 - which makes perfect logical sense
69:29 - because I have a three available in my
69:31 - coins array so I could just take a
69:32 - single three cent coin let's continue
69:35 - this pattern elsewhere in the tree
69:45 - at the root note of four in this tree
69:46 - it's going to receive a bunch of ones
69:48 - technically it would choose the smallest
69:49 - among them which would be a tie given
69:51 - one and what I should do is always
69:53 - increment it by one to count the edge
69:54 - between myself and the children nodes
69:57 - and this too represents the fact that I
69:59 - have a few different paths that could
70:02 - only take two coins or two edges it
70:04 - could represent this path
70:06 - or this path or even this path
70:10 - so as we evaluated this tree something
70:12 - really important we did was whenever we
70:14 - received multiple values from our
70:16 - children so when we received multiple
70:18 - sub Solutions what I do is choose the
70:20 - smallest among them right I know I need
70:22 - some Min value logic present in this
70:25 - implementation because I want to choose
70:27 - the minimum number of coins possible so
70:30 - I'll just keep that in mind when we
70:31 - implement the code
70:32 - we talk about the complexity of this
70:33 - we've seen the structure before right
70:35 - now we're going to describe the Brute
70:36 - Force complexity if we say that c is the
70:39 - length of the coins array and a is the
70:41 - target amount then the time complexity
70:43 - is going to be exponential right we know
70:45 - that the branching factor of this tree
70:46 - is going to be based on the number of
70:48 - coins so C right branching Factor refers
70:51 - to given a node at most how many times
70:54 - will it yield children and I know what
70:56 - my ratchet Factor here is three and in
70:58 - the worst case I have three branches
71:00 - coming out of a single node
71:01 - my exponent here is going to be a
71:03 - because that would be the height of the
71:05 - tree we'll say that the space complexity
71:06 - is going to be o of a due to the call
71:08 - stack because if you look at the height
71:10 - of this tree it would be in the worst
71:12 - case a we say the worst case would be
71:14 - the scenario where I keep taking a bunch
71:16 - of one cent coins giving me the deepest
71:18 - recursion possible so if you start the
71:21 - root node here and you just keep going
71:22 - left you're going to see a sequence like
71:24 - four three two one zero and that
71:26 - definitely is a linear pattern in a so
71:28 - overall we're looking at an exponential
71:30 - runtime and a linear space complexity
71:32 - for this solution the time complexity
71:34 - definitely needs some work there right
71:35 - we want to bring it down from an
71:37 - exponential so like we usually do we
71:39 - just want to memorize this one we'll try
71:41 - to notice any duplicate sub problems so
71:42 - looking at this tree there are some
71:44 - duplicate sub trees I can notice I can
71:46 - see these sub trees rooted in two so
71:48 - instead of recalculating that
71:49 - subsolution I can save it and just reuse
71:51 - it so I can trim out that piece of the
71:52 - tree I also have other sub trees rooted
71:55 - in one and I can also ignore those right
71:57 - the way I'll implement this is by using
71:59 - some constant time data structure like a
72:01 - hash map I can store sub results as I
72:03 - compute them in that hash map and then
72:05 - reuse them later on if that high level
72:07 - strategy seems confusing don't worry
72:09 - you'll want to wait until the
72:10 - walkthrough video will actually show you
72:11 - the details on how to implement this in
72:13 - some code
72:14 - so let's do a re-analysis of this now
72:16 - we're going to analyze this dynamic
72:17 - programming solution that uses
72:19 - memoization the time complexity is just
72:21 - going to be a times C so it's no longer
72:24 - exponential it's really a sort of
72:26 - multi-linear right just multiplying my
72:27 - two terms together we know that time
72:29 - complexity is going to be based on the
72:31 - number of recursive calls we make and in
72:32 - this visual diagram every node
72:34 - represents a recursive call we still
72:36 - have a tree of height a so that's where
72:38 - the a comes from what we're saying is
72:40 - across every level of this tree we have
72:43 - at most C nodes so I think of a as the
72:45 - height and C is the width that would
72:47 - give me a times C nodes overall it's
72:50 - actually pretty easy to spot in this
72:51 - particular example in the worst case
72:53 - scenario at a particular level we have
72:55 - only three nodes at most that's because
72:58 - our coin array only has three options
72:59 - inside of it the space complexity for a
73:02 - solution is just going to be o of a due
73:03 - to the call stack and we'd be storing at
73:05 - most a different keys inside of our memo
73:08 - hash map all right I think I'm ready to
73:10 - code this one up you want to join me in
73:11 - the walkthrough video now at this point
73:13 - we're done with the planning phase for
73:15 - our Min change solution what you want to
73:17 - do is head down to the links in
73:18 - description below where you can find the
73:20 - link to the Min change problem where you
73:21 - can code up the solution in Java with me
73:30 - hey programmers Alvin Constructor here
73:32 - what I want to do is go over the Java
73:33 - walk new for this Min change problem so
73:35 - you definitely want to make sure you
73:36 - watch the approach video first this is
73:38 - going to be another dynamic programming
73:40 - problem similar to our previous some
73:42 - possible problem like we said in the
73:44 - approach video what we want to do here
73:45 - is optimize for the number of coins that
73:48 - we take into our sum
73:50 - and so I'll Implement that strategy
73:52 - exactly what I want to do is start by
73:54 - laying out a base case we know that in
73:56 - this problem our base case should be
73:57 - about an input amount that is trivially
73:59 - small and for me the amount is going to
74:01 - be zero so I'm going to check if the
74:03 - current amount that I'm looking for is
74:05 - equal to zero then I want to return the
74:07 - answer for that amount of zero I want to
74:10 - return an integer representing the
74:12 - number of coins I need to create that
74:13 - amount so if someone asked you to
74:15 - generate zero cents what's the least
74:17 - number of coins you need to generate
74:18 - zero cents the answer there is zero
74:20 - coins so I'm just going to return zero
74:22 - then from there I want to start writing
74:24 - my recursive scenarios so I know that I
74:28 - need to take one of my choice of coins
74:30 - to reduce the amount so I'm going to
74:32 - iterate over all the possibilities so
74:34 - for me that means I'll iterate for every
74:36 - int coin within the coins list
74:38 - and what I'm going to do is I'm going to
74:40 - take the input amount and subtract this
74:43 - coin from it
74:46 - that smaller quantity that'll give me my
74:48 - sub amount we'll call it and from there
74:50 - I want to recursively find the minimum
74:51 - number of coins needed to make that sub
74:53 - amount so I can call my recursive method
74:55 - pass in that sub amount could pass in
74:57 - these same old coins in the problem they
74:59 - tell us that we can reuse a coin as many
75:01 - times as we need
75:02 - awesome
75:03 - but now from here I need to do some
75:05 - thinking I know that this method call
75:07 - should give me back a number
75:08 - representing the minimum number of coins
75:10 - needed to make the sub amount I'm going
75:13 - to save that number into a variable here
75:15 - just readability I'll call it sub coins
75:17 - because that's the number of coins
75:19 - needed to make the sub amount and I know
75:20 - I need to find the minimum subcoins for
75:22 - every choice of coin that I can take so
75:24 - I need to perform some Min value logic
75:26 - here you know generally A Min value
75:28 - logic means as we iterate over the
75:30 - possibilities we maintain some outer
75:31 - variable here I'll call it the mincoins
75:34 - I have to think about a good default
75:35 - value for it here well I know that in
75:37 - the context of the problem they tell us
75:39 - that all right if it's not possible to
75:41 - make the amount with the coins then you
75:44 - want to return negative one so I
75:46 - actually use that as an initial value
75:47 - here
75:48 - so I'm going to set this up as negative
75:49 - one and I know that after the foil at
75:51 - the end of my function if I never find a
75:55 - mount that works I'm going to return
75:56 - mint coins
75:59 - which should still be the negative one
76:02 - right but besides that what if it is
76:05 - possible to make the sub amount well if
76:08 - it's possible to make the sub amount
76:09 - that means that subcoins would be a
76:11 - non-negative number right so I'm going
76:13 - to check if
76:14 - subcoins is not equal to negative one
76:17 - that means it was possible to make the
76:20 - sub amount since subcoins is the number
76:22 - of coins needed to make the sub amount
76:24 - if I do subcoins plus one that should be
76:29 - the number of coins needed to make the
76:31 - full amount and why do I know that this
76:33 - additional plus one here is counting the
76:35 - single coin I took to get the sub amount
76:37 - I'll save it to a variable called int
76:40 - num coins
76:42 - so this is the number of coins needed to
76:44 - make the full amount over here and now I
76:47 - could compare this against the mincoins
76:49 - variable right so I'm going to check hey
76:50 - if this number of coins is less than the
76:53 - mint coins well then I can replace the
76:55 - mint coins with this new
76:58 - number of coins right but it's pretty
77:01 - obvious here that when we initialize the
77:02 - mint coins to negative one this negative
77:05 - one may persist over any valid number of
77:07 - coins here right because negative one is
77:09 - already a negative quantity right so
77:12 - this negative one just acts like a
77:13 - placeholder right to represent an
77:15 - invalid quantity or the fact that we
77:17 - haven't found any valid number of coins
77:19 - yet and so if the number of coins is
77:21 - less than Min coins or the Mint coin
77:25 - still contains that default value then I
77:27 - can replace that default value with this
77:29 - number of coins right so I'm performing
77:31 - A Min value logic over my minimum coins
77:35 - so this code is looking pretty good one
77:37 - thing we need to be aware of is when we
77:39 - calculate this difference here we do a
77:40 - mount minus coin that could give us a
77:43 - negative amount right sub amount could
77:45 - be negative so if we call Min change
77:47 - with a negative number we already
77:49 - overshot the Space Case here so what I
77:51 - can do is just cache that with the base
77:52 - case so if ever my input amount is less
77:55 - than zero
77:56 - then what I want to do is return some
77:59 - value I'll return negative one here
78:01 - because again negative 1 in this problem
78:02 - represents the the fact that the amount
78:05 - cannot be generated with the coins we're
78:07 - given right you cannot generate a
78:09 - negative amount when all of the coins
78:11 - that you're given are positive
78:13 - so that's going to be a good extra base
78:16 - case there
78:17 - so let's give this a test one this
78:19 - should be our Brute Force solution for
78:21 - Min change if all is well we'll add some
78:23 - memo into it and make it a little faster
78:25 - so I'm getting an area it looks like I
78:26 - have a random typo current subcoins that
78:28 - should just be subcoins plus one right
78:30 - let's give that a test once again
78:34 - nice and this looks like our Brute Force
78:37 - solution we know that an algorithm like
78:39 - this so far has an exponential run time
78:42 - just like we said in the approach video
78:43 - so to speed this up I'm going to use our
78:46 - memoization strategy
78:48 - so like I always love to do I'm going to
78:50 - separate it into a main function and
78:52 - then a recursive helper right
78:55 - so my main over here will just call my
78:58 - recursive helper it's going to take in
79:00 - the amount as well as the coins but also
79:03 - my memo which will be a new hash map
79:09 - I'll be sure to take that hash map as an
79:11 - argument here
79:12 - so it's going to be a hash map
79:15 - and I have to think about what the keys
79:16 - of this hash map are going to be they
79:18 - should just be the argument that changes
79:19 - during the recursion which is the amount
79:21 - notice that the amount is the only ARG
79:23 - that changes coins stays the same so I
79:26 - don't need to add it as a key into my
79:28 - map here so I'll say my keys are going
79:31 - to be integer and then the corresponding
79:33 - values are going to be just the return
79:35 - type of this method which is also
79:36 - integer I'll call that memo got to be
79:39 - sure to import hashmap above
79:43 - looking pretty good and be sure to pass
79:45 - along that memo through the entire
79:47 - recursion now I need to add an
79:49 - additional base case right I need to
79:50 - check hey if the memo already contains
79:54 - the amount well then I've solved this
79:56 - sub problem before just return the
79:58 - stored value in the memo so I'll return
80:00 - memo dot get the amount
80:04 - awesome but if it's not then I'll go
80:07 - ahead and actually perform the true
80:09 - logic and calculate recursively of the
80:11 - answer
80:12 - right and I know that now I need to
80:15 - actually add data into the memo where I
80:18 - return the result so I look for the
80:20 - literal return line in my recursive case
80:22 - and it's only one return statement here
80:23 - in the recursive case that's line 35. so
80:26 - literally what I should do is
80:28 - I ought to save this into my memo so I
80:32 - can do memo dot put
80:34 - I'm going to use the input amount as my
80:37 - key always use the original argument
80:39 - make the corresponding value mincoins
80:42 - and you still need to complete the
80:44 - return value so like before still
80:47 - logically return mint coins you're just
80:49 - making sure you store it in the memo
80:51 - before you leave this recursive call
80:54 - nice so with that logic built around my
80:56 - Brute Force by adding the memo we should
80:59 - get a better run time here
81:01 - awesome there we have it here we start
81:03 - to really see the power of this strategy
81:05 - of first solving a Brute Force recursion
81:07 - and then applying our memoization trick
81:10 - right around it really the hardest part
81:11 - of a situation like this is to solve The
81:13 - Brute Force recursion in the first place
81:15 - right but that lets you focus on just
81:17 - the correct logic and then afterwards
81:19 - you speed up that logic using this
81:21 - additional data structure all right
81:23 - programmers that's all I got for this
81:24 - one why don't you do is practice this
81:25 - and I'll see you in the next one hey
81:27 - programmers I just want to take a little
81:28 - break from our dynamic programming
81:30 - material to tell you about structi
81:31 - Shruti is a complete data structures and
81:33 - algorithm course that you can use to
81:35 - prepare for all of your technical
81:36 - interviews it's actually the course
81:38 - you've been seeing me use throughout the
81:40 - video tutorials I'm going to be your
81:42 - teacher through the entire instructed
81:43 - curriculum and in the structure course
81:45 - we cover all of those essential
81:46 - interview topics like graphs trees
81:49 - dynamic programming and more and like
81:51 - you expect for every single problem like
81:53 - you've seen in this dynamic programming
81:55 - course we're going to support it with
81:56 - animations as well as code walkthroughs
81:58 - and you'll be able to code up all of
82:00 - these Solutions on the platform tester
82:02 - code in Java C plus plus JavaScript and
82:05 - python so if you're enjoying this
82:07 - dynamic programming material I recommend
82:09 - you head over to structure where you can
82:10 - practice things further whether it's
82:11 - dynamic programming or those other
82:13 - essential topics and of course you're
82:15 - going to be joining me for all of those
82:16 - video walkthroughs so I'll see you there
82:18 - without any further Ado let's hop back
82:20 - into our course
82:23 - hey programmers Alvin here right now
82:25 - let's go over the approach for this
82:26 - count paths problem so in this problem
82:28 - we're going to be given a grid what we
82:30 - want to do is travel from the top left
82:32 - corner down to the bottom right corner
82:34 - and here we want to return the number of
82:36 - ways that's possible to Traverse through
82:38 - this grid the caveat is we can only move
82:41 - to the right or downward that means we
82:43 - can go up and we can't go to the left
82:45 - and so for this particular grid let's
82:46 - talk about the different ways we can
82:48 - travel through it one way would be to go
82:50 - right right down another way would be to
82:52 - go right down right and finally the last
82:55 - way would be to go down right right and
82:57 - since there are three possible ways to
82:59 - travel through this grid we should just
83:00 - return the number of three so this
83:02 - should be a counting problem for us
83:04 - however this problem is a little more
83:05 - nuanced they say that some positions are
83:07 - going to be occupied by walls and we
83:09 - can't travel through them so if I had a
83:11 - wall like this in the top right corner
83:13 - then one way to travel to the grid would
83:15 - be right down right and the only other
83:17 - way would be downright right so let's
83:19 - Trace through the strategy for this one
83:20 - by looking at a larger example if I was
83:22 - given this 3x3 grid I'll also put a wall
83:24 - in the top right corner let's start by
83:26 - labeling the indices for our rows and
83:28 - columns we know that we start in the top
83:30 - left corner so that would mean row 0
83:32 - column zero and what I want to start to
83:35 - do is try to give myself a way where I
83:37 - can denote every option I have right how
83:39 - can I Mark the decisions I can make by
83:42 - traveling through this grid so I'm going
83:44 - to visualize this one as a tree
83:46 - so if I start at position 0 0 I can make
83:48 - that the root of my tree if I'm at this
83:51 - position I'll think about my options
83:53 - that I have I can either move downward
83:55 - if I move downward that would increase
83:57 - my row by one but keep my column the
83:59 - same giving me one comma 0 or if I went
84:02 - to the right I keep my Row the same at 0
84:04 - and I increase my column by one and that
84:07 - would be the only two options I have
84:08 - from this root position and I can just
84:11 - apply this logic recursively so let's
84:13 - say I was situated at the zero one node
84:15 - right now so I'm over here I know that
84:17 - my options are more limited now I can't
84:19 - move to the right because I have a wall
84:21 - in my way so I'm going to need to make
84:22 - sure I code that one up and I can only
84:24 - move downward here and that would mean
84:26 - increasing my row by one and keeping a
84:28 - column the same and so let's carry over
84:30 - this pattern to draw out the rest of
84:31 - this tree we know that given a node at
84:34 - most it's going to have two children
84:35 - representing my downward or rightward
84:37 - movement and that would mean either
84:38 - incrementing the row by exactly one or
84:40 - incrementing the column by one however
84:43 - we should not do that move if we go out
84:45 - of bounds or run into a wall so the full
84:48 - tree would look something like this
84:50 - what's great about this tree is if I
84:52 - start at the roots and travel to a leaf
84:54 - node that would represent one of the
84:55 - paths I can take through my grid in
84:57 - other words if I look at this path in my
84:59 - grid I can represent that using this
85:02 - path in my tree which is a really nice
85:04 - way to interpret this problem
85:06 - and so let's start to realize how we can
85:08 - encode the base case in this problem
85:09 - what you should be realizing is we're
85:11 - visualizing this as a tree which usually
85:13 - gives us a nice way to implement this as
85:15 - recursion right so if I've got all the
85:17 - leaf nodes here I always terminate at 2
85:19 - comma two because that would represent
85:21 - the bottom right corner of my grid which
85:23 - is the goal and so if I'm at the bottom
85:25 - right position of 2 2 what should I do
85:27 - here well I have to think about the
85:29 - return value for my function here right
85:31 - they say they want a count and so what I
85:33 - should do is treat this to comma 2
85:36 - position as if it's its own input so if
85:38 - someone asks me in how many ways can you
85:40 - get from the bottom right position to
85:42 - the bottom right position the answer
85:44 - would be one right there's only one way
85:45 - to do that that would be to just stay
85:46 - there right because you're already at
85:48 - your goal point and so I'm going to make
85:50 - all of these Leaf nodes or all these
85:52 - base cases return one now having these
85:54 - calls return one seems useful because I
85:56 - know I need to tally up a count in this
85:58 - problem
85:59 - so how do we start reconstructing our
86:01 - larger Solutions here well I would just
86:03 - really Bubble Up these ones right
86:05 - so let's slow down at this one comma one
86:07 - node over here we know that this node
86:09 - has a little more work to do because
86:10 - it's going to receive two values
86:12 - and so what I should do is bubble up
86:14 - both of these values right and then this
86:16 - note should just add them together so
86:18 - one plus one gives me two and so what
86:20 - are we saying here if I pause I should
86:23 - have some logical information in the
86:24 - subtree what it should be saying is that
86:26 - there are two ways to get from the
86:28 - position one comma one to the bottom
86:30 - right corner I have this path or I have
86:33 - this path there are two different ways
86:35 - to get from one one down to your bottom
86:37 - right corner so I'll just carry over
86:38 - this pattern keep reconstructing all of
86:41 - my Solutions
86:43 - and as we get toward the top of our tree
86:44 - we are going to get the final count of
86:46 - all of the ways to travel from the top
86:48 - left to the bottom right giving us our
86:50 - final answer of five what's great about
86:52 - visualizing this one as a tree is it
86:54 - really describes the decisions we can
86:55 - make as we travel through the grid right
86:57 - we know that this gives us a binary tree
86:59 - because for the most part when we're on
87:02 - the inside of the grid we only have two
87:04 - options right you can either move
87:05 - downward or to the right that'll help us
87:08 - decide the complexity of this Brute
87:09 - Force algorithm so if we implement this
87:11 - algorithm as it is just with some
87:13 - baseline recursion we say that R is the
87:15 - number of rows and sees a number of
87:16 - columns this will give us an exponential
87:18 - runtime meaning they're an exponential
87:21 - number of nodes in this tree really it's
87:22 - 2 to the r plus C power so the base of 2
87:26 - comes from the fact that this is a
87:27 - binary tree and in the context of a
87:28 - problem that means I can only move
87:30 - downward to the right so you only have
87:32 - two options I'm saying that the height
87:34 - of this tree is R plus C right because
87:36 - you know you want to start in the top
87:38 - left corner 0 0 and travel to the bottom
87:41 - right corner what you have to do is
87:43 - actually Traverse a path that is exactly
87:45 - R plus C moves along right because you
87:48 - need to move through all of your rows
87:49 - and all of your columns for the same
87:52 - reason I can say that the space
87:52 - complexity is going to be R plus C just
87:54 - due to the stack depth right stack depth
87:57 - is equal to the height of this tree
87:58 - which we just said is roughly R plus C
88:01 - and so overall we shouldn't be too
88:02 - satisfied with the time complexity of
88:04 - this one right typically something
88:05 - exponential would be too slow for our
88:07 - liking
88:08 - and so what we should do is recognize
88:10 - that we actually have this visualized as
88:12 - a nice dynamic programming problem
88:14 - what you should do is take a moment look
88:16 - at our visual tree and notice if you can
88:18 - spot any duplicate sub problems right
88:20 - are there any overlapping sub problems
88:22 - here that I can memorize
88:26 - so we actually have a duplicate sub tree
88:27 - over here rooted in one comma one
88:31 - what I could do is just save the first
88:33 - time I calculated that way I don't have
88:34 - to fully recurse down my tree the second
88:36 - time around effectively memorizing my
88:39 - duplicate function calls which in the
88:40 - context is my tree visual just means
88:42 - that I prune out some branches there are
88:45 - some other subtrees here I can look at
88:46 - this two comma one subtree I can also
88:49 - memorize that away and we know as we
88:51 - grow the problem size in other words if
88:53 - someone gave me a larger and larger grid
88:55 - I would have more and more overlapping
88:57 - sub problems so I'd benefit more and
88:59 - more from memoization like usual for us
89:02 - the way we'll implement this is by using
89:04 - some hash map data structure I'll save
89:06 - that detail for the Code walkthrough
89:07 - though so what do we know about the new
89:09 - and improved complexity of this one
89:10 - right we're going to implement our
89:11 - dynamic programming using our classic
89:13 - memoization strategy so like usual R is
89:16 - the number of rows and C is a number of
89:17 - columns now would be the case that our
89:19 - time complexity is R times C right it's
89:22 - still the case that our time complexity
89:23 - is driven by the number of recursive
89:25 - calls we make and now we would be making
89:27 - roughly R times C different recursive
89:30 - calls right and how do I know that well
89:32 - in the context of what I'm going to
89:34 - memorize into my hatch map I'm going to
89:37 - put positions right notice that each
89:38 - node in this visual is a position of row
89:41 - and column and I know that there are
89:43 - exactly R times C different rows and
89:45 - columns so once I store a row and column
89:48 - into my memo I would never have to fully
89:50 - recompute it which gives me my time
89:52 - complexity of R times C likewise now is
89:55 - the case that my space complexities R
89:56 - times C taken mostly from the size of
89:59 - that memo right every position is going
90:01 - to be a key and so I have R times C
90:03 - different keys in my memo object all
90:05 - right programmers I'm sure itching to
90:06 - see how we actually implement this one
90:08 - in some code so right now you'll want to
90:09 - join me in the walkthrough videos I'll
90:11 - see you there
90:12 - now that we're done sketching out the
90:14 - solution behind this count pass problem
90:15 - what you want to do is head down to the
90:17 - links in description below where you can
90:18 - actually access the prompt and the test
90:20 - cases for this count pass problem and
90:22 - we'll code up the solution in Java
90:24 - together
90:29 - hey programmers Alvin from structure
90:31 - here what I want to do is go over the
90:32 - account pass problem in Java so like we
90:35 - said in the approach video we're going
90:36 - to frame this problem like a dynamic
90:38 - programming one this is going to be a
90:41 - little different compared to our very
90:42 - classic like graph like grid problems
90:44 - because in this problem you can only
90:46 - move rightward or downward that means
90:48 - that we can't get caught in any Cycles
90:50 - right so I don't have to do any visited
90:52 - logic or anything like that
90:54 - however what I will do is solve this one
90:56 - with a Brute Force recursion and then
90:57 - apply our memoization strategy on top of
90:59 - it to get a really fast dynamic
91:01 - programming optimized solution so to get
91:03 - the ball rolling on this one I know I
91:04 - need to start tracking like a current
91:06 - position as I Traverse uh through the
91:08 - grid so I'm going to split this one up
91:10 - into my main method as well as my helper
91:13 - and my helper is going to take in my
91:15 - current row and current column
91:16 - information and then in my main method
91:19 - I'll just pass control
91:21 - to my helper and I'll give it the
91:23 - starting point which is a top left
91:24 - corner which means row 0 column zero
91:26 - pass along the entire grid to reference
91:29 - then from here I'm going to structure
91:31 - this one as like a depth first recursive
91:33 - solution more or less so I'm going to
91:35 - start with the base case so what's my
91:37 - goal here well my goal is to find the
91:40 - bottom right corner of my grid so I can
91:42 - stop traversing if my row and column is
91:44 - the bottom right so be careful of the
91:47 - math here right to be in the bottom of
91:50 - most row that would mean that the row is
91:51 - equal to grid dot size
91:54 - minus one that means the bottom row
91:57 - similarly you want to check if the
91:59 - column is equal to the rightmost column
92:01 - so that would mean grid dot get 0 dot
92:05 - size minus one right so this is checking
92:08 - if I'm in the bottom right position then
92:10 - what do I want to do what I want to
92:11 - return overall the number of ways to
92:14 - reach the bottom right corner from this
92:16 - current position well if you're already
92:18 - in the Target position then you don't
92:21 - need to do anything so that's one way
92:22 - that you can get to the bottom right
92:24 - corner you just do nothing right because
92:25 - you're already there so I'll return one
92:27 - in this instance
92:28 - we have to think about some other
92:30 - scenarios right it could be the case
92:32 - that maybe my row and column is out of
92:33 - bounds so I want to avoid that and so
92:36 - I'll check very a very similar condition
92:38 - here
92:40 - I'm going to check if I'm out of bounds
92:42 - that would mean that my row is equal
92:46 - to grid size or
92:51 - my column is equal to
92:53 - grid.get0 dot size right notice that I'm
92:57 - turning this into an or right because if
92:59 - your row is too large or your column is
93:02 - too large well in the theater those are
93:04 - true or both of those are true then it's
93:05 - an invalid position so you're out of
93:07 - bounds right
93:08 - and if that's the case I still need to
93:10 - give a logical return value right I
93:11 - always want to have consistent return
93:13 - types so even in the space case if I'm
93:15 - out of bounds I want to return an
93:17 - integer and an integer needs to
93:18 - represent how many ways from this
93:20 - position I can travel to the bottom
93:22 - right corner well if you're out of
93:23 - bounds there's no possible way to ever
93:25 - get to the bottom right corner at that
93:26 - point so you want to return zero right
93:28 - there are zero ways to travel from an
93:30 - out of bounds position to the bottom
93:33 - right corner
93:34 - so I have my base cases looking pretty
93:36 - good but there's one more to capture
93:37 - here they also tell us that all right
93:39 - some positions of your grid are not open
93:41 - o stands for an open position if a grid
93:44 - position contains an X that's a wall
93:46 - that I cannot travel through so I'm
93:48 - going to actually add that into the mix
93:50 - here right it might be the case
93:52 - that if
93:54 - my grid dot get r dot get C so if my
93:58 - current position is equal to an X well
94:01 - then I can't Traverse through it right
94:04 - that's also a dead end kind of I like
94:06 - out of bounds so I'm similarly going to
94:08 - return zero awesome do note the
94:11 - important order of these two cases over
94:14 - here right I'm making sure that I only
94:16 - try to access like the innermost element
94:18 - of my a 2d grid after I check that the
94:22 - row and column are valid right I know
94:25 - that I'm using some valid RNC to get a
94:27 - position of my grid it's just that that
94:29 - position contains an X
94:31 - so these are all of my base cases here
94:33 - now I can start structuring my recursive
94:35 - case and I know that from any position
94:38 - that I'm at I have you know two options
94:40 - to take and those two options will turn
94:42 - into my two recursive calls right so I'm
94:44 - going to call account paths you could
94:45 - move downwards so you could
94:48 - move down a row keep the column the same
94:51 - but you can also move to the right so
94:55 - you can do count Paths of the same row
94:58 - but increase the column
95:01 - nice I have to think about what these
95:03 - two recursive calls return they return a
95:06 - number right this one on the left
95:07 - returns to me the number of ways I can
95:10 - get to the bottom right corner or get to
95:12 - the goal if I move downward this tells
95:14 - me the number of ways I can get to the
95:15 - goal if right now I move to the right if
95:18 - I take the sum of them that gives me the
95:21 - total ways I can get to the goal from
95:23 - this position because from this position
95:25 - you can only either move down or move to
95:28 - the right
95:29 - so this is looking like some core logic
95:31 - this looks like the shape of my brute
95:33 - force not much logic to it overall just
95:35 - some tricky edge cases here for my base
95:37 - case
95:37 - and so let me give this a test run
95:40 - I'm looking for some correct output so
95:42 - I'm passing some test cases but probably
95:44 - timing out for large inputs and there we
95:47 - see it
95:48 - so like I always love to do now I need
95:50 - to apply my memoization to it so I'm
95:52 - going to set that up you always want to
95:53 - use some fast lookup data structure to
95:55 - store your memo right
95:57 - and so for us use something like a
95:59 - hashmap and I'll pass along that hash
96:01 - map inline over here so new hash map
96:06 - and I'll take it as an argument and here
96:08 - where I design the hash map have to be a
96:10 - little more particular right so
96:12 - generally for the keys of my hashmap I
96:15 - always use the changing arguments into
96:18 - my recursive method here right so if I
96:21 - look at the arguments that change during
96:22 - my recursion it's the row and the column
96:25 - right the grid itself is always the same
96:27 - throughout the full recursion so I don't
96:29 - need to encode it into the keys of my
96:32 - hash map
96:34 - and so I really need to represent a row
96:36 - and column pair or like position as keys
96:38 - of my hash map because depending on
96:40 - their own column you get a different
96:41 - answer
96:42 - and so to actually store that key I'm
96:44 - going to use just a list of only two
96:46 - things of a row and column
96:48 - so it'll be a list of integer and I'll
96:50 - just guarantee that I'd make sure that
96:52 - those sub lists are always going to be
96:55 - of length two right just pairs of row
96:57 - and column
96:58 - and corresponding value is going to be
97:00 - the return type for my method which is
97:01 - just integer as well
97:03 - nice call this memo and now let's add
97:07 - our memo checking logic so pass these
97:10 - base cases what I like to do is form the
97:14 - key I'm going to use into my memo so
97:17 - create that key here it's going to be a
97:19 - list of integer let me just a pair I'll
97:22 - call it my position it's going to be
97:24 - just a list of the row and column
97:27 - nice and I can check hey if
97:30 - this position is in the memo so if memo
97:33 - dot contains key position and I can
97:37 - return the associated value with it
97:39 - because that means I've seen this not
97:41 - recursive call before so I can just
97:43 - instantly find the old result so return
97:46 - memo dot get position again the key
97:50 - trick here is I'm using this position
97:52 - because it contains the row and column
97:55 - arguments right so I'm using that entire
97:57 - entity as a key into my memo
98:00 - nice then from there like we're used to
98:02 - I should be sure to pass the memo to my
98:05 - calls here
98:09 - and whenever you see your recursive
98:11 - return value which is line 30 for me you
98:13 - want to store that result in your memo
98:15 - before you leave right
98:16 - so I'm just going to store this into an
98:18 - INT result
98:20 - be sure to put that in your memo so memo
98:23 - dot put
98:25 - this is uh put a key of position
98:28 - with the result
98:30 - and then just return the result
98:35 - nice so with those changes pretty
98:37 - classic changes to the previous problems
98:39 - that we've been doing except we're
98:41 - having a little more complex of a memo
98:45 - key here
98:46 - let's give that a shot
98:53 - awesome there's our solution for count
98:55 - paths
98:58 - hey programmers Alvin here right now
98:59 - let's go over the approach for this
99:01 - maxpath sum problem
99:02 - so in this problem we're going to be
99:03 - given a grid and we start in the top
99:05 - left corner and we want to make our way
99:07 - to the bottom right corner this grid is
99:09 - going to be populated with some numbers
99:10 - though we want to do here is return the
99:13 - path containing the maximal path sum
99:17 - in other words there are a few ways we
99:19 - can travel through this grid one way
99:20 - would be to use this path in which case
99:22 - there's sum would be 14. another way
99:25 - would be to use this path in which case
99:26 - your sum would be 12 and finally you can
99:29 - use this path in which case your sum
99:30 - would be 18. and between these three
99:32 - options I should choose the 18 right and
99:35 - so that would be the max path sum for
99:37 - this grid so let's cut to the Chase and
99:39 - describe the strategy for this one and
99:41 - we'll step through exactly this example
99:43 - so we'll label the row and columns and
99:45 - we also know that we start of course in
99:47 - the top left corner the SE are really
99:49 - just a spin-off of our last problem so
99:50 - hopefully you visualize this one as a
99:52 - tree right a binary tree because we only
99:54 - have two options at any point in time
99:56 - right you can either move downward or to
99:58 - the right and sometimes in just one of
100:00 - those directions depending on whether or
100:02 - not you're at the border of our grid
100:04 - right so we'll start at zero zero from
100:06 - this position I have two options if I
100:08 - went downward I would increase my row by
100:10 - one notice that each pair within a node
100:13 - here is a row and column or I could have
100:15 - moved to the right in which case I would
100:17 - be at zero comma one now to present my
100:19 - two moves let's say I was situated at
100:21 - this one comma zero node here I only
100:23 - have one move possible to make I must
100:25 - move to one comma one right that
100:28 - represents a move to the right if you
100:29 - look at my row and column indices that's
100:31 - because I can't go downward anymore
100:33 - because I'm already in the last row
100:36 - if I take a look at this position over
100:37 - here I do have two options right I can
100:39 - go downward or to the right giving me
100:41 - one comma one and zero comma two
100:43 - respectively we can build out the full
100:45 - tree from this point we know that we
100:47 - must terminate at position one comma two
100:49 - because that would be the bottom right
100:51 - corner so I know that that is our ending
100:53 - point right so that's going to be my
100:55 - base case I know in this problem I want
100:57 - to choose the maximal path sum so I want
101:00 - to Max some but how can I start
101:01 - accumulating a sum in the first place
101:03 - and so what you have to do is ask
101:04 - yourself if I'm already at the end
101:06 - position what is its Max path sum to the
101:08 - end position that would just be the
101:10 - value of 2 right that's exactly the
101:12 - number in that ending position so for my
101:14 - base cases I'm just going to return
101:16 - whatever number is in that final
101:18 - position
101:20 - then from here I know that these values
101:21 - are going to return so let's say we were
101:23 - situated at this one comma one node it's
101:25 - going to receive a value from its child
101:27 - call because we know we're visualizing
101:28 - this in a recursive way and what I
101:30 - should do here is note what position I'm
101:31 - at so 1 comma 1 would be this position
101:34 - containing a six I want to accumulate a
101:37 - sum here so I should do 2 plus 6 giving
101:40 - me eight so this node is going to return
101:42 - 8 to its parent so it's 8 it's going to
101:44 - Bubble up a little bit more if I think
101:46 - about this one comma zero node that
101:48 - represents my current value of 5 over in
101:50 - yellow and I would do my 8 plus 5 giving
101:53 - me 13. so that would be a partial path
101:56 - so far
101:57 - so we'll continue this process on our
101:59 - right hand side we know that these would
102:00 - just Bubble Up and we would add the
102:02 - respective values at those positions
102:05 - things came more interesting when we're
102:07 - at this zero comma one node though
102:09 - so for this note it's going to receive
102:11 - both 8 and 14 right it's just going to
102:12 - return back up like we always do and I
102:15 - have to make a decision here since I
102:17 - want the max path sum this node should
102:19 - choose the larger of those two values so
102:22 - 14 is bigger than 8. so I prefer the 14
102:25 - here but I should also still add the
102:28 - value stored at my current position so
102:30 - if I look at position 0 1 within my grid
102:33 - that would be this value of 3. so I add
102:35 - 3 to the 14 giving me 17.
102:39 - finally this takes place again at the
102:41 - root so if I'm at 0 0 I'm going to
102:43 - receive the 13 and the 17 for my
102:45 - children I choose the bigger value of 17
102:47 - and then I add my position itself which
102:50 - has a value of 1 inside that gives me a
102:53 - final answer of 18. so the way we
102:55 - reconstructed our sub Solutions into
102:57 - higher level Solutions was to choose the
102:59 - larger of our two children and then add
103:01 - ourselves to it that way I get some max
103:03 - value logic while also summing our path
103:07 - we talk about the Brute Force complexity
103:08 - of this algorithm we say that R is the
103:10 - number of rows and sees the number of
103:11 - columns then our time complex is going
103:13 - to be exponential just like we saw in
103:14 - the last problem the base of 2 comes
103:17 - from the fact that given any position we
103:19 - have two options right we can either go
103:21 - down or to the right and I make R plus C
103:24 - the exponent because that would be the
103:26 - height of this tree right that would be
103:27 - the length of any particular path I know
103:30 - any path that travels from the top left
103:32 - to the bottom right must cover all of
103:34 - the rows R and all of the columns C and
103:37 - so the entire path length would be R
103:39 - plus C in a similar way I'll say the
103:41 - space complexities R plus C due to the
103:43 - stack space required by this recursion
103:45 - right if the height of this tree is R
103:47 - plus C that means the stack space used
103:48 - by my recursion is also going to be R
103:51 - plus C but a keen Observer would know
103:53 - that I can do better because this is a
103:55 - dynamic programming problem so what I'll
103:57 - do is take a moment look at this tree
103:58 - see if you can find any overlapping sub
104:01 - problems
104:03 - and although this example was small I
104:04 - can already see some overlap if I look
104:06 - at this node rooted in one comma one I
104:08 - see it here and you also see it here I
104:11 - know the punch line is I should only
104:12 - have to calculate these nodes exactly
104:15 - once so I should be able to trim out a
104:17 - little bit of the tree by using some
104:19 - memoization
104:20 - and as we actually increase the size of
104:22 - our input as I get a larger and larger
104:24 - grid I would have more and more overlap
104:26 - that I'm able to kind of forego using
104:28 - some memoization like usual we're going
104:30 - to implement this using a hash map but
104:32 - I'll say those finer implementation
104:34 - details in the walkthrough video
104:36 - if we Implement memoization properly for
104:38 - this one we're going to bring our
104:39 - complexity down to linear right so we're
104:41 - going to have a Time complexity of R
104:43 - times C that's because there are R times
104:45 - C different nodes to actually cover now
104:48 - right I know I'm going to put the
104:49 - positions as the keys of my memo and
104:52 - there are R times C unique positions in
104:55 - a similar way it's now the case that my
104:57 - space complexity is taken over by the
105:00 - size of my memo which is also R times C
105:02 - because of the number of keys right I
105:04 - have R times C keys because I have R
105:06 - times C positions all right I think I'm
105:08 - ready to code this one up you'll want to
105:09 - join me in the walkthrough videos now
105:21 - hey programmers welcome back what I want
105:23 - to do right now is go over the Java
105:24 - walkthrough for this Max path sum
105:26 - problem so it's going to be a small
105:28 - variation of the previous you know grid
105:30 - dynamic programming problem except this
105:32 - time you want to find the maximum as we
105:33 - travel from the top left of our grid to
105:35 - the bottom right
105:36 - so I'm going to start by setting up the
105:38 - same initial structure so you'll want to
105:40 - track a position as you kind of Traverse
105:42 - through your grid
105:44 - and so I'm going to add additional
105:46 - arguments to this method so I'm going to
105:47 - track my current row as well as my
105:50 - current column
105:51 - nice and then from there what I want to
105:53 - do is start laying down my base cases
105:56 - right
105:57 - so for my base cases like you expect
105:59 - there are a few I need to check if I'm
106:01 - out of bounds so if my row is equal to
106:04 - grid dot size that means I'm just
106:08 - outside of the grid
106:12 - or
106:13 - maybe my column is equal to grid dot
106:18 - size
106:19 - or rather grid dot get zero dot size or
106:23 - I'm out of the column range right either
106:25 - case you want to return a sum integer
106:27 - right how can you represent an invalid
106:30 - integer meaning it's not possible to
106:33 - travel to the bottom right corner using
106:36 - this particular position well because I
106:39 - want to perform overall like a Max path
106:41 - logic or max value logic I know my logic
106:44 - is going to be preferring any larger
106:46 - integers and so whenever I encounter
106:48 - like an out of balance or invalid
106:49 - position I need to return some very
106:52 - small number right and so for me I think
106:55 - the best way to solve this one is going
106:56 - to be to use like a negative Infinity
106:57 - concept
106:59 - so in Java really your only choice for
107:01 - like a true negative Infinity is going
107:04 - to be in the double type so I'm going to
107:05 - say double dot negative Infinity which
107:09 - means I have to adjust some of my types
107:11 - here right so I guess I'm going to make
107:14 - this return a double that's totally fine
107:17 - I'll just be sure to cast it back in my
107:19 - main method here right so what am I
107:21 - saying well just so I can have access to
107:23 - like negative Infinity in my recursive
107:26 - over here
107:27 - in my main method it's going to call
107:29 - maxpath sum with the initial row initial
107:32 - column as well as the grid and I know
107:34 - that this is now defined to return a
107:36 - double you're going to get an error in
107:38 - Java if you try to return a double from
107:40 - an integer return method so I'm just
107:43 - going to cast into
107:45 - integer I'm just doing that really
107:47 - straightforward so I'm only going to
107:49 - convert at the very end which is fine
107:50 - all right so beyond that I need to just
107:52 - handle the case where I actually hit my
107:54 - Target in a base case so that'll be a
107:57 - similar condition right you want to
107:58 - check in English if you're in the bottom
108:00 - right position
108:02 - so if your row is the last row
108:05 - and
108:06 - your column is the last column
108:11 - and so you want to return
108:13 - some number here and overall you want to
108:16 - be adding up the values in your grid as
108:19 - you travel along them so in your base
108:21 - case you want to return an actual value
108:23 - you want to return the value of your
108:25 - current position so you want to return
108:26 - grid.get
108:28 - r
108:29 - dot get C so what am I really saying
108:32 - here so let's say that we're performing
108:34 - our recursion and we hit this base case
108:36 - meaning we're at the bottom right corner
108:38 - so that means I'm at this position what
108:40 - I'm going to do here is return the value
108:41 - at this position so I'm returning the
108:43 - value of one I'm going to return it
108:45 - because I need to eventually add up all
108:47 - the values along my winning path and the
108:49 - end goal is still part of my winning
108:51 - path here
108:52 - nice and so now that I have these base
108:54 - cases in line what I want to do is start
108:56 - forming my recursive case so I know I'm
108:59 - going to have two recursive calls right
109:00 - because at any position I have two
109:02 - options I can either go down or go to
109:03 - the right so I'm going to call maxpath
109:05 - sum going downward would be R plus 1 C
109:09 - grid and going to the right would be
109:11 - maxpath sum of the same row increase the
109:14 - column same old grid
109:16 - nice and here what I want to do is
109:19 - prefer the larger sub answer right
109:22 - because when I take a path through my
109:24 - grid you either go right or you go down
109:27 - right and I know that these recursive
109:29 - calls can be back a number they
109:30 - represent the sum of the a path if I
109:33 - travel through the right or if I travel
109:36 - downward and I want to choose whichever
109:38 - sub result is bigger right because right
109:40 - might give you a bigger sum or going
109:41 - down might be a bigger Sum It could only
109:43 - take one of them
109:44 - and so to choose just the maximal
109:46 - between these two numbers that I get
109:48 - back I'm just going to use the built-in
109:49 - math.max you can also write some
109:51 - conditional logic this is probably the
109:53 - easiest way to write this though
109:55 - so just choose the bigger value between
109:57 - these two methods but I should also be
110:01 - sure to add my current position into uh
110:04 - that answer right so I'm going to do
110:07 - grid dot get our
110:09 - dot get C
110:14 - add it into the bigger between my going
110:17 - down choice or my going rightward choice
110:20 - right this gives me the logic of summing
110:22 - up all the values along a particular
110:24 - path awesome so let's give this code a
110:28 - run this should be our Brute Force
110:29 - solution it looks like
110:31 - nice and if all is well we should start
110:33 - timing out and there we have it
110:35 - so let's improve the runtime of this one
110:38 - by adding in our memo so that's going to
110:39 - be a hashmap
110:42 - this is going to have us use a hash map
110:44 - where the keys are going to be positions
110:46 - right because the row and column is what
110:48 - determines the answer here because those
110:50 - are the arguments that change
110:51 - so I should have passed along a new hash
110:54 - map here
110:55 - and over here I'll Define the type so
110:58 - hash map
111:00 - keys are going to be positions so just
111:01 - kind of list pairs to integers
111:03 - corresponding value is going to be looks
111:06 - like double
111:07 - I'll call that memo
111:09 - so like we always do we want to add our
111:11 - memo checking logic as an additional
111:12 - base case so I'll start by forming the
111:14 - key first
111:16 - which is really just a position pair
111:19 - list of the row and column
111:21 - and then start by checking if it's in
111:23 - the memo so if memo
111:25 - contains
111:29 - the key of position then return its
111:33 - corresponding stored value so I'll
111:34 - return memo
111:37 - dot get position
111:40 - nice and then beyond that I need to be
111:43 - sure to pass along this memo so it's
111:44 - shared through the entire recursion so
111:47 - just pass it by reference here not a big
111:48 - deal and like I always say right the key
111:51 - is to now just find your recursive
111:53 - return value which is this thing over
111:55 - here you want to store it in your memo
111:57 - before you return right so this long
111:59 - expression just is a double it's like
112:01 - just a sum right so I'll save that as a
112:03 - result
112:06 - and this is going to be
112:09 - double
112:12 - how do I know it's double well it's
112:13 - obviously double because of this over
112:15 - here what I want to do is store it in my
112:19 - memo so memo dot put use your original
112:22 - arguments the original key
112:25 - here
112:26 - make the corresponding value the result
112:28 - and then like before still return the
112:30 - same old result the only additional step
112:32 - you took was to store it for a rainy day
112:35 - because I know later on if I ever
112:36 - encounter this position again I would
112:39 - hit this conditional and I can return
112:41 - that sub result in constant time
112:44 - which gives me a much better performance
112:46 - here
112:47 - give that a test run
112:49 - added our dynamic programming strategy
112:51 - there we have our very Snappy code
112:55 - hey programmers Alvin here right now
112:56 - let's go over the approach for this
112:58 - non-adjacent sum problem
112:59 - from this problem you're going to do is
113:00 - take in an array containing some numbers
113:02 - what you want to do is return the
113:04 - maximal sum of non-adjacent elements in
113:07 - this array so that means we can never
113:09 - take two numbers that are next to each
113:10 - other within the array for this
113:13 - particular input the answer should be 16
113:14 - because the max non-adjacent sum would
113:17 - contain the 4 plus 12.
113:20 - here we should notice that we can't take
113:21 - a sum like 12 plus 7 because those two
113:24 - elements are adjacent within the array
113:26 - let's take a look at another example
113:28 - let's say I was given 7 5 5 and 12. in
113:31 - this particular scenario the output
113:32 - should be 19 representing the sum of 7
113:35 - and 12 which is totally fine because
113:37 - they are non-adjacent in the array
113:39 - so let's come up with the strategy for
113:41 - this one we'll step through the example
113:42 - of 2 4 5 12 and 7. what I want to do is
113:45 - figure out a way I can come up with all
113:47 - the possibilities for numbers I take
113:49 - into my sum and numbers I exclude from
113:51 - my sum because we know that based on the
113:53 - numbers we take that would actually
113:55 - limit our options later on so let's say
113:57 - we started to encode this as a recursion
114:00 - tree right so I'm going to describe all
114:02 - the decisions that we could take as we
114:03 - come up with a sum for this problem
114:06 - so I'm going to start with my original
114:07 - array at the root what I have to do is
114:09 - come up with a decision right now let's
114:11 - say I was making a decision for the
114:13 - first element of this array so if I took
114:16 - 2 into my sum then I know my resulting
114:19 - elements I can choose from is really
114:20 - just 5 12 and 7. so notice how I did
114:23 - this left Branch over here right I'm
114:25 - writing 2 along the edge to represent
114:27 - that I'm taking 2 into the sum and
114:29 - notice how I make my array smaller in
114:31 - that left child I just have 5 12 and 7
114:33 - because I cannot include 4 in that next
114:37 - call right because including four would
114:39 - actually mean that we're giving
114:40 - ourselves the opportunity to take an
114:42 - adjacent sum right if you take two right
114:44 - now then you can never ever take four so
114:46 - that's why I exclude it however at the
114:48 - root we could have also just not taken
114:49 - two altogether in which case when you
114:51 - look at your next subarray that would
114:53 - just be 4 5 12 and 7 right if I don't
114:56 - take the two that means I'm excluding it
114:58 - along the edge on the right hand side
114:59 - then I can totally give myself the
115:01 - opportunity to take four in the future
115:03 - so I'm going to include it in the next
115:04 - array so let's carry this pattern
115:06 - further let's say we looked at this left
115:08 - note over here what I have to do is
115:10 - always make a decision about the first
115:11 - element of this array so for the five
115:14 - note if I decide to take it what I can
115:16 - do is then look at the remaining
115:18 - elements of just seven right I don't
115:20 - pass 12 until the remaining subarray
115:22 - because if I take 5 I cannot take 12.
115:25 - however I could have also just not taken
115:27 - 5 altogether which case my remaining
115:29 - elements are just 12 and 7. so by now it
115:31 - should be clear how we generalize the
115:33 - steps here right given any particular
115:35 - array what I can do is either take the
115:37 - first element or not take the first
115:39 - element and that would decide what
115:41 - remaining elements I can choose from
115:42 - either slicing off one or two elements
115:44 - from the front of my array
115:46 - let's say we evaluated this node over
115:47 - here if I take 4 then I would give me a
115:50 - remainder of 12 and 7. if I don't take 4
115:52 - then my remainder is 5 12 and 7.
115:54 - something interesting happens at the
115:56 - seven node right so in one scenario I
115:58 - can take the seven in which case I
116:00 - really just have an empty array left
116:01 - over right there's nothing else to
116:03 - choose for because that's my last
116:03 - element and the scenario that I don't
116:06 - take seven you would still have an empty
116:08 - array left over so notice how the seven
116:10 - node terminates and really two empty
116:13 - arrays finally we'll evaluate this 12
116:15 - comma 7 node if I took the 12 then I
116:18 - would have an empty array because if I
116:20 - take the 12 you cannot take the 7
116:22 - anymore and if I don't take the 12 well
116:24 - then I can totally take the 7 for my
116:26 - next decision
116:28 - at this point we would actually have a
116:29 - larger tree right there are still some
116:31 - nodes I need to evaluate here fully but
116:33 - what's great about this is I can
116:34 - actually notice that those are all
116:35 - duplicate nodes in other words I've
116:38 - noticed that this is a dynamic
116:39 - programming problem right if something
116:41 - has dynamic programming present in it
116:43 - then I should be able to recognize any
116:45 - overlapping sub problems in the context
116:47 - of this tree I just have to notice any
116:49 - duplicate nodes any duplicate subtrees I
116:51 - can notice a duplicate sub tree rooted
116:53 - in seven right so I don't need to
116:55 - re-explore the seven node again likewise
116:57 - I can notice a duplicate subtributed in
116:59 - 12 comma 7. there's even more than that
117:02 - I even have a very large subtree rooted
117:04 - in 5 12 and 7. and so I'm going to save
117:06 - a lot of complexity by saving some of
117:08 - these sub Solutions as I compute them
117:10 - so let's talk about how you can
117:12 - recompute our final answer from the
117:14 - problem now that we broke it down
117:16 - what we should notice is toward the
117:17 - bottom of our tree we're going to have
117:18 - leaves that represent empty arrays which
117:22 - does feel good because we know as our
117:24 - problem size gets smaller and smaller
117:25 - that would mean a smaller and smaller
117:27 - array right less and less numbers to
117:29 - choose from
117:30 - let's make our base case about the empty
117:31 - array in other words if someone gave me
117:33 - an empty array then the max non-adjacent
117:36 - sum would be zero right just take no
117:38 - elements of the array because you don't
117:40 - really have an option here so for all of
117:41 - these empty nodes or the empty arrays
117:43 - I'm going to have them return zero I
117:46 - know I'm going to make that a base case
117:47 - let's say we wanted to evaluate now at
117:50 - the seven node how will it use those sub
117:52 - Solutions well if I take a look at the
117:54 - left return value that's going to Bubble
117:56 - up but what I should also do is add the
117:58 - 7 along the edge right the yellow seven
118:00 - that represents the fact that I was
118:02 - taking and including 7 into that sum so
118:06 - I have a 7 on my left and for the right
118:07 - hand child that just bubbles up as it is
118:10 - right because I did not include seven
118:12 - for that particular sub problem and at
118:14 - this point I have this node choosing
118:16 - between seven and zero since I want the
118:18 - max non-adjacent sum I choose the larger
118:21 - between the two so I should return 7 in
118:23 - this instance
118:25 - so now let's evaluate this 12 comma 7
118:27 - node since I just evaluated the seven
118:28 - node into its result I'm just going to
118:30 - jot down that answer here and I know I
118:32 - would Implement that probably using some
118:33 - memorization
118:34 - but as I carry on my return values here
118:36 - the left-hand0 is going to Bubble Up but
118:39 - I add the value along the edge because I
118:41 - was including 12 to that sum so I have
118:43 - 12 on my left and 7 on my right I choose
118:46 - a large between the two and I should
118:48 - return 12. which makes sense because if
118:50 - you think about it given just the small
118:53 - sub array of 12 comma 7 the Max on
118:55 - adjacent sum would be 12 right just
118:57 - choose 12. definitely don't choose 7
118:59 - because that'd be smaller
119:01 - now that I've evaluated this 12 comma 7
119:03 - node I know I can save this result for
119:05 - later on so I'm going to jot it down on
119:07 - that duplicate node over here
119:09 - now let's evaluate a little higher up
119:10 - we'll carry over the same logic as
119:12 - before so I return these values and I
119:14 - add the 5 along the left hand Edge
119:16 - giving me 12. at this point I choose the
119:18 - larger between 12 and 12. it's really a
119:20 - tie here so I'll just return 12. so I've
119:23 - just computed the subsolution for the
119:25 - array 5127 and I actually have a
119:27 - duplicate node on the right hand side so
119:28 - I'm going to jot that down
119:30 - if I evaluate this node now things
119:32 - Bubble Up along the left hand Edge I add
119:34 - a 4 giving me 16. so I do 16 versus 12.
119:38 - I choose a larger one which of course be
119:40 - 16. finally at the ultimate root I
119:42 - return these two values but the left
119:44 - hand Edge gets a plus two I choose a
119:47 - larger between 14 and 16 giving me my
119:49 - final answer of 16 which would be the
119:52 - correct answer let's talk about the
119:53 - complexity for this one so if you say
119:55 - that n is the length of the numbers what
119:58 - we could do is analyze the Brute Force
119:59 - complexity of this right so if you did
120:01 - not optimize this by trimming out some
120:03 - duplicate nodes in your sub tree you
120:05 - would have an exponential runtime in
120:07 - other words your time complexity is 2 to
120:08 - the n and your space complexity is just
120:10 - o of n we can say that the time
120:12 - complexity is 2 to the N here because
120:14 - for every node of this tree it's going
120:16 - to give at most two children right so in
120:19 - the worst case from one level of the
120:21 - tree to the next I double the number of
120:23 - nodes and I also know that the height of
120:25 - this tree is going to be n right the
120:27 - height of the tree is going to be n
120:28 - because in some scenario I could just
120:31 - keep removing the first elements of my
120:33 - array again and again and that means
120:35 - that the deepest recursion would require
120:37 - n stack frames on the call stack like we
120:39 - said we can optimize this with some
120:40 - dynamic programming with some
120:41 - memoization if you did things correctly
120:43 - here you would get a runtime of just o
120:46 - event so linear and a space complexity
120:48 - of also o of n one thing to note for
120:50 - this one is if you really want to get
120:51 - the linear runtime out of this problem
120:53 - you're going to have to figure out a
120:55 - clever way to actually represent a
120:57 - logical shrinkage of your array in other
120:59 - words if you look at the nodes of my
121:01 - tree I'm representing the array and I'm
121:03 - chopping off some elements of the array
121:04 - at any point in time what you don't want
121:06 - to do is create many copies of the array
121:09 - because I know creating a copy of an
121:10 - array would itself run in a linear time
121:13 - if you're creating a copy within every
121:14 - recursive call it's going to be pretty
121:16 - inefficient I will actually save that
121:18 - detail for the implementation video and
121:20 - so if you're wondering how to exactly
121:21 - Implement that pattern you'll want to
121:23 - join me in the walkthrough video I think
121:25 - let's hop to it
121:36 - hey programmers Alvin here what I want
121:38 - to do right now is go over the Java
121:40 - solution for this non-adjacent sum
121:41 - problem so like we said in the approach
121:43 - video to solve this one we're going to
121:45 - solve it using some recursive Brute
121:47 - Force algorithm then apply some
121:48 - amylization on top of it
121:50 - and so to get the ball rolling here I'm
121:52 - gonna need a way to give myself the
121:54 - ability to look at different pieces of
121:57 - my input list here I know at any point
121:59 - in time I want to shrink my input list
122:01 - smaller and smaller toward my base case
122:02 - and so to set up that structure I think
122:05 - it's good to have access to like a
122:06 - starting index so I'm going to overload
122:09 - the method name here
122:11 - I'm going to give it another argument
122:12 - I'll say int I
122:15 - and this will represent the starting
122:17 - index of the sub list that I'm
122:19 - considering for example if I is the
122:22 - number two that means I should be
122:23 - analyzing the list starting at index two
122:26 - so index two all the way through the end
122:28 - that means top level over here when I
122:30 - call my helper method I'll call nine
122:32 - adjacent sum given the same nums list
122:35 - and then initialize I to be zero because
122:38 - you want to start considering the full
122:40 - list starting index 0 going through the
122:42 - end
122:43 - this will help us avoid any slicing or
122:45 - creating copies of the list as we go
122:47 - giving us a faster solution
122:49 - and so to get the ball rolling on our
122:51 - Brute Force let's consider some base
122:53 - cases here
122:54 - and so I know I want to check a base
122:56 - case if my list that I'm considering is
122:59 - empty right
123:01 - so I'm gonna check
123:02 - for me a logical like empty linked list
123:05 - would mean that my index I is at the end
123:07 - or past the end of the list here so I'll
123:10 - check if I is greater than or equal to
123:12 - num's dot size
123:15 - notice that here I'm technically
123:17 - checking if I is out of bounds of the
123:20 - nums list because I know the last valid
123:22 - index of a list would be size minus one
123:25 - so if that's the case what I want to do
123:26 - is return 0. for what I'm trying to be
123:29 - consistent with the return type of this
123:31 - method which would be of type integer
123:32 - and zero is definitely an integer and
123:34 - I'm returning 0 because it represents an
123:36 - empty sum because I know overall in the
123:39 - context of this problem I want to
123:40 - maximize the sum that I take
123:42 - and so with that let me also start
123:44 - forming my recursive calls and these
123:46 - recursive calls should really mimic the
123:48 - logic that we express when we drew the
123:51 - approach video tree right
123:53 - so we have really two options here I'll
123:54 - kind of lay them out
123:56 - well what you could do is take the
123:59 - number at the front of your list so for
124:02 - me the front of my logical list would be
124:03 - the item at index I
124:05 - so if you took that number you could say
124:07 - nums.get I
124:09 - and you want to recursively add it to
124:11 - the sum of the remaining part of the
124:13 - list that you can take from if you take
124:15 - the element at position I
124:18 - and when you call non-jacent sum
124:20 - they'll give him the same nums list but
124:22 - you want to manipulate I obviously I
124:24 - want to increase I giving myself like a
124:26 - smaller a logical list
124:28 - what you want to do is pass in I plus 2
124:31 - here
124:34 - and so it's pretty clear why we're not
124:36 - just passing in the same old I well for
124:38 - one we already took the element that
124:40 - index I into our sum and we're adding it
124:42 - to our recursive sum here
124:44 - we shouldn't pass in I plus 1 because
124:46 - that would be a number adjacent to I
124:49 - right and if we take I right now we know
124:51 - we can't take I plus 1 later on because
124:54 - the whole point of this problem is you
124:55 - can't take two elements that are
124:56 - adjacent in the list
124:58 - and so the earliest number we could take
125:00 - from there would be I Plus 2. and this
125:03 - is a very indicative of the logic we
125:05 - expressed when we drew the tree
125:08 - so that's only half of the pattern here
125:10 - could also be a scenario where I don't
125:12 - take my current element at index I and
125:15 - instead I just do non-adjacent sum of
125:17 - nums
125:19 - and then I pass in I plus 1 here right
125:21 - so now I do have the option of taking
125:24 - the element that's right after I
125:26 - nice and I know that these two variables
125:29 - over here are these two expressions they
125:30 - give me back a number right they
125:31 - represent a sum
125:33 - what I want to do is now work in my max
125:34 - value logic I want to choose the maximum
125:37 - answer between these two choices right
125:39 - the choices you make are either you take
125:41 - your element index I or you don't take
125:44 - your element in x i so I'm going to
125:46 - choose the maximum between them for me I
125:48 - could just use the built-in math.max
125:50 - just takes into arguments and Returns
125:52 - the bigger value between them and now
125:54 - that I'm choosing the maximum between
125:56 - these two quantities you just want to
125:58 - return whatever that maximum is
126:01 - so this code's looking pretty good let's
126:04 - give this a test run so far
126:06 - really short logic
126:09 - but we do want to optimize this in a
126:11 - moment so we're passing our initial test
126:13 - cases and we're timing out test case
126:15 - zero four so we're in good shape here we
126:17 - know that you know the problem like this
126:19 - does have an exponential runtime so it's
126:22 - too slow to run but I can add some
126:25 - memosization logic into the mix here to
126:26 - improve that
126:28 - so like we're always used to should know
126:30 - this formula by now I'm going to bring
126:31 - in the hash map
126:33 - I'm going to pass it into my recursive
126:35 - method here
126:40 - when it comes to the structure of this
126:41 - hashmap
126:42 - its keys are always going to be like the
126:45 - changing arguments to my recursor method
126:47 - so I'll pass in a hash map here
126:50 - for me the keys need to represent my
126:53 - integer's I right so I'll make the key
126:55 - type integer
126:57 - corresponding value is going to be the
126:59 - return type of the method which is also
127:00 - integer so this hashmap Maps integers to
127:04 - integers
127:05 - and let me add my base case to check if
127:07 - a key already exists in the memo and for
127:10 - me the key is really the argument I
127:12 - right so if the memo
127:15 - contains the key of I then just return
127:18 - the stored value because I would have
127:20 - stored the subsolution previously so
127:22 - return memo dot get I
127:25 - now on the flip side I have to locate my
127:27 - recursive return value which is this
127:28 - expression over here and I want to store
127:30 - it in the memo before I leave right so
127:33 - I'll just save this thing to a variable
127:34 - I'll call it result
127:36 - I'm still going to complete the return
127:37 - value that way we don't change any of
127:40 - the actual arithmetic in this evaluation
127:42 - but I do want to save this result so
127:45 - before I leave I'm going to do
127:46 - memo dot put use your argument I the
127:51 - plain old I as their key make the
127:53 - corresponding value
127:55 - the result
127:57 - and always be sure to pass along that
127:58 - memo by reference into your recursive
128:00 - method here
128:01 - does that mean right here
128:03 - pass along the memo so I have that
128:04 - shared data structure
128:06 - and so just by adding this layer on top
128:08 - of our Brute Force let's give that a
128:09 - test run
128:10 - we should get a much better run time
128:13 - here
128:14 - cool and there we have it
128:18 - hey programmers Allen here right now
128:20 - let's go over the approach for the
128:21 - summing squares problem so the first
128:23 - thing we'll want to do is review what a
128:24 - perfect square is you can create a
128:26 - perfect square by just taking some
128:27 - positive number and multiplying it by
128:29 - itself in other words I can do one times
128:31 - one to give me one two times two to give
128:34 - me four three by three to give me 9 and
128:36 - 4x4 to give me 16 and so on
128:39 - so in this problem we're going to take
128:40 - in a number as input and we want to do
128:42 - is figure out the minimum perfect
128:44 - squares that sum up to our Target number
128:46 - so for this input of 12 the least number
128:48 - of perfect squares I can use would be
128:49 - doing four plus four plus four notice
128:52 - that this is a valid perfect square sum
128:53 - because 4 is of course a perfect square
128:56 - another way that uses perfect squares to
128:58 - add up to 12 would be nine plus one plus
129:00 - one plus one however that would be a
129:03 - longer way right I want to use the
129:05 - minimum number of perfect squares and so
129:07 - here I should return the answer of three
129:09 - and the reason behind it is because I do
129:11 - 4 plus 4 plus 4 which is three perfect
129:13 - squares all right so how can we break
129:15 - down this problem let's step through the
129:17 - example as if our input was 10. we're
129:19 - going to start at 10 at my root and what
129:20 - I know I have to do is get this number
129:22 - to be smaller and smaller because
129:24 - decreasing the size of our input would
129:26 - mean an easier and easier problem to
129:28 - solve so what I have to do is subtract
129:30 - different perfect squares from this 10.
129:32 - so what I can do is subtract one that'll
129:34 - give me 9 or I could subtract 4 giving
129:36 - me six and finally I could subtract 9
129:39 - giving me one notice that there are no
129:41 - other perfect squares to try the next
129:43 - perfect square would be 16 but that
129:45 - would be too large for my 10. so I don't
129:47 - need to go over it over here let's say I
129:49 - now wanted to expand this nine node I
129:50 - would get children like this again
129:52 - branching for every perfect square that
129:55 - I can take out of that quantity
129:57 - and so on and so forth
130:00 - if we look at the right hand side of my
130:02 - tree I actually just discovered a way to
130:03 - create my input of 10. in other words I
130:05 - can look at this path since this path
130:07 - terminates in a zero that must mean that
130:10 - we have just found a way to sum up
130:12 - perfect squares such that we get 10. if
130:14 - I look at the numbers along this path
130:15 - I'm really saying nine plus one
130:18 - so let's expand this five node as well
130:20 - as this two node and we'll build the
130:22 - full tree for the subtree rooted in six
130:24 - that would look something like this
130:27 - so you can probably foresee that this
130:28 - tree grows very quickly and so we're
130:30 - going to avoid drawing the left hand
130:31 - side of the tree although now we know
130:33 - the core pattern that we can use to
130:34 - generate it so if I look at this sub
130:36 - tray I have a few different paths that
130:38 - terminate at zero right I can look at
130:39 - this path which represents another way I
130:41 - can create my input of 10 but I should
130:43 - obviously prefer a shorter path right if
130:46 - I count the number of edges within a
130:48 - path that would tell me the number of
130:51 - perfect scores I use to accumulate that
130:53 - sum and obviously the shortest path we
130:55 - should return here is two because we're
130:56 - using a nine and a one let's go through
130:58 - how we can actually code this one up so
131:00 - as always if I have this visualized as a
131:02 - tree I should be able to frame it as
131:04 - some recursion so in my base case if my
131:07 - number my input is zero then what I
131:09 - should do is return zero zero is a great
131:11 - return value because what we're saying
131:13 - is to create zero you need to sum up
131:15 - zero different perfect squares so I'm
131:18 - going to plug in that return value for
131:19 - all these Leaf nodes and as I return
131:21 - these values to their parents what I
131:23 - have to do is add one to them always
131:25 - that way I can start counting the number
131:27 - of edges so if I look at the very bottom
131:29 - right now the zero returns then I add
131:31 - one to it then it returns upward add one
131:33 - to it and one more time to get over here
131:35 - notice that I have a three over the
131:38 - three now which means that I need three
131:39 - perfect squares to create three which
131:41 - makes sense because you have to do one
131:43 - plus one plus one let's say we return at
131:45 - this four node since this node is
131:47 - receiving two different values what it
131:49 - should do is choose these smaller
131:50 - between the two right because this
131:52 - problem is asking us for the least
131:54 - number of perfect squares so I need to
131:56 - minimize here so I should prefer the
131:57 - zero what I should also do is add one to
132:00 - it to count the edge
132:02 - and so what I'm saying right now is
132:03 - there must be only one perfect square
132:05 - that I need to get a quantity of four
132:07 - which makes sense because 4 itself is a
132:09 - perfect square so I should be able to
132:11 - notice any correctness even as I
132:13 - evaluate these sub trees
132:15 - so we'll take some time to evaluate this
132:17 - further
132:22 - until finally at the sixth node we get a
132:23 - result of three and this three
132:25 - represents a few different paths we can
132:27 - take that are of minimal length
132:31 - so I think by now you understand the
132:32 - logic we need to evaluate this tree this
132:34 - tree is going to be a little large so I
132:35 - won't step through the full example we
132:37 - can already foresee the complexity of
132:39 - this though right whenever I have a tree
132:41 - structure like this I'm describing all
132:43 - the different recursive calls that I
132:45 - make so if I'm able to figure out the
132:47 - number of nodes in this tree that would
132:49 - tell me the time complexity that stems
132:51 - from the recursion what I know is the
132:53 - height of this tree is definitely going
132:55 - to be n right because the longest path
132:57 - from the root to a zero would be just by
133:00 - taking a minus one again and again right
133:02 - so the height of this tree is going to
133:04 - be n when it comes to the branching
133:06 - factor it's actually Dynamic so given a
133:08 - node we know that we Branch for every
133:09 - perfect square that we can fit inside of
133:11 - it we know that given a node n there
133:13 - would be square root of n different
133:15 - perfect squares so that'll tell us our
133:17 - total complexity
133:18 - we'll say that the time complexity is
133:20 - going to be the square root of n raised
133:22 - to the nth power
133:24 - like usual the branching factor of our
133:26 - tree is going to be the base of that
133:27 - exponent in this problem the base is no
133:30 - longer two right we were dealing with a
133:31 - lot of problems we just have a base of
133:33 - 2. now we have a branching Factor that's
133:35 - based on the square root of that number
133:37 - so that's why we say we have square root
133:40 - of n raised to the nth power the
133:42 - exponent of n of course represents the
133:44 - number of levels in this tree or the
133:46 - height of the tree
133:47 - in a similar way the spacing Plex is
133:49 - just linear o of n because of the height
133:51 - of our tree we know that we're going to
133:52 - need at most n stack frames in our
133:54 - deepest call stack
133:56 - and like you could probably guess this
133:57 - is actually going to be framed as a
133:58 - dynamic programming problem right what
134:00 - we can do is notice some overlapping sub
134:02 - problems looking at our tree you can
134:04 - capture a few I'll just point out this
134:06 - duplicate 5 node and of course as we
134:08 - grew our input larger and larger you
134:10 - would have more and more overlap
134:12 - so if you do things properly here and
134:14 - you implement memoization to capture the
134:16 - dynamic programming nature of this
134:17 - problem which you should be able to do
134:19 - is bring it to some sort of a
134:21 - multi-linear function overall your time
134:23 - complexity would be n times the square
134:25 - root of n interspacing Plexi would still
134:28 - be o of n I'm sure wondering exactly how
134:30 - we implement this one so maybe what you
134:32 - want to do is try to code it up on your
134:33 - own if you get stuck you can find me in
134:35 - the Code walkthrough I'll see you there
134:48 - hey programmers after construct be here
134:50 - what I want to do is go over the Java
134:51 - walkthrough for the summing squares
134:52 - problem so you definitely want to make
134:54 - sure you watch the approach video first
134:55 - and we'll Jump Right In Here we want to
134:57 - solve this one using a Brute Force
134:58 - recursion and apply some memoization on
135:01 - top of it
135:02 - so let's start with a base case here
135:03 - like we said in the approach video we
135:05 - know we want to deal with an input
135:07 - that's very small right for us we have
135:08 - integer inputs so we'll just check if
135:11 - our number n is equal to zero
135:13 - if our number n is equal to zero then we
135:15 - want to return zero because we know that
135:18 - generally our method should give us back
135:20 - the number representing the minimum the
135:22 - number of squares used to build up our n
135:25 - right if your n is zero that means you
135:27 - can use the empty sum right you can add
135:28 - up no perfect squares and you still get
135:31 - the correct answer of zero so that's the
135:33 - logic behind our base case here but now
135:36 - the recursive case is much trickier we
135:38 - know we want to have the logic of
135:40 - subtracting out some perfect squares
135:42 - from n that gives us a smaller and
135:44 - smaller argument
135:46 - so I'm going to give myself a loop that
135:47 - just iterates over some possible squares
135:51 - so what I can do here is I can iterate
135:53 - for it's I equals one and I'm starting
135:55 - at 1 because I know that one is the
135:57 - smallest perfect square right so I might
135:58 - as well start there
135:59 - I'm going to iterate
136:01 - up to I less than or equal to the square
136:04 - root
136:07 - of n
136:09 - and then hit every I in between I plus
136:11 - equals one
136:12 - cool that's because as I evaluate this
136:15 - Loop what I'm going to do is take my
136:17 - integer I
136:18 - am going to create a square number out
136:21 - of it a square is just the number
136:22 - multiplied by itself
136:25 - notice that on the last iteration of
136:26 - this for loop I know that I is going to
136:29 - be exactly the square root of n so when
136:31 - I do I times I I'm definitely going to
136:33 - get the full value of N and this could
136:35 - be the biggest number we ever subtract
136:37 - out of our argument n here
136:40 - nice and so with that out of the way we
136:43 - want to do is now build our recursive
136:45 - call so I'm going to call summing
136:47 - squares
136:48 - and I'm going to do n minus this choice
136:50 - of square that I have over here we know
136:52 - that this recursive call is going to
136:54 - give us back the minimum number of
136:55 - squares required to sum up to this
136:58 - quantity right
136:59 - I'll call that my int num squares
137:04 - however if I wanted to figure out the
137:07 - number of squares to build up for our
137:09 - argument n we need to add 1 to that sub
137:12 - quantity right that's because this one
137:14 - over here corresponds to the single
137:16 - Square I have on line 9. nice and then I
137:19 - know I need to find the minimal
137:21 - sum and so what I want to do is some Min
137:24 - value logic here so I'm going to do int
137:26 - I'll say Min squares
137:30 - and here it would be nice if I can use
137:31 - some like Infinity value because I want
137:34 - to do Min value logic overall and so
137:37 - unfortunately like integer type doesn't
137:38 - have a built-in infinity and so what
137:41 - I'll do is I'll actually create this as
137:43 - my recursive helper
137:45 - and so the main method will have the
137:47 - original
137:48 - signature
137:49 - but my recursive method I'll think I'll
137:51 - make it
137:52 - actually return double
137:54 - because then I can start defaulting
137:57 - these values over here right so for line
137:58 - 13
137:59 - I can make this default to double dot
138:03 - positive Infinity
138:07 - and I get some safe comparison over here
138:09 - right so I can say things like hey if
138:12 - this number of squares is less than the
138:15 - Min squares and on the first iteration
138:17 - this is guaranteed to be true because
138:18 - Min square roots is positive Infinity
138:21 - then you can go ahead and replace them
138:23 - in squares with that value
138:26 - then after that full loop is done
138:28 - running like you expect we return
138:29 - whatever Min squares is and since we're
138:32 - storing positive Infinity in this
138:34 - variable over here this should be of
138:35 - course type double
138:38 - which means that now we're summing
138:39 - squares recursive method is returning a
138:41 - double which is totally fine
138:43 - however when we actually call this
138:45 - helper method in our main method here
138:49 - we know that this call to summing
138:51 - squares
138:53 - that's actually going to give us a
138:55 - double I want to just cast it into an
138:57 - INT like so
139:00 - I'll pass along the same end here
139:02 - do bear in mind that right now because
139:05 - these methods of summing squares
139:08 - although I want to overload them they
139:10 - will probably get a conflict here
139:11 - because they both take in the same types
139:13 - of arguments and the return type is kind
139:15 - of ambiguous here so just for now I'm
139:19 - going to rename the helper method
139:21 - I'll call it underscore or something
139:23 - Square so that represents my recursive
139:25 - helper method
139:27 - nice and so with that let's give this a
139:30 - run
139:30 - here I'm just getting a little reference
139:32 - here for the typing this should be
139:34 - positive in fin it t
139:38 - and while I'm here I also noticed that
139:40 - when I add one to the results of the
139:43 - recursive method here that of course
139:45 - gives me back a double
139:47 - and that's because the method returns a
139:49 - double I'm adding one to it which should
139:51 - still give a double
139:52 - let's give that a test run
139:55 - nice and this looks like our Brute Force
139:57 - recursion is starting to time out though
139:58 - on test case zero six
140:01 - so you know the drill at this point we
140:02 - have our Brute Force let's add our
140:04 - memosization into it
140:06 - so I'm going to start by importing the
140:08 - hashmap
140:11 - and I'll pass it along to my cursor
140:14 - method here so it'll be a new hash map
140:17 - I'll take in this argument here
140:19 - so hashmap keys are going to be just the
140:22 - numbers n so integer corresponding value
140:25 - right now is going to be double
140:29 - I'll call that my memo
140:31 - and we'll add a base case like we always
140:33 - do if our argument n is in the memo so
140:35 - if memo dot contains a key of n then
140:38 - return
140:39 - ammo.get and right return the stored
140:42 - value for it then I need to locate where
140:44 - I call My Method recursively which is
140:46 - over here be sure to share the memo
140:49 - and then whenever you do your return
140:50 - value in the recursion you want to store
140:52 - that result before you leave right so
140:54 - here I return Min squares I'll want to
140:57 - save that in a variable I'll say result
140:59 - equals mint squares
141:01 - I'm going to still return that same old
141:03 - result but before I leave I store it in
141:05 - memo so memo dot put use the original
141:07 - argument as the key right so I just use
141:09 - n here
141:10 - make resolve the value
141:14 - nice and so now that the overloaded
141:16 - version of this method has a different
141:19 - argument of hashmap it should be
141:22 - unambiguous now so I'm going to actually
141:24 - change the name here
141:25 - it's just a summing squares right it's
141:27 - easily to identify now because there's
141:29 - two arguments for the recursive version
141:31 - right only one argument for the main
141:33 - version here
141:34 - so let's give that a test run
141:37 - always solving these dynamic programming
141:38 - problems and layers
141:43 - great there we have it
141:46 - hey programmers Alvin here right now
141:48 - let's go over the approach for this
141:49 - counting change problem so this problem
141:51 - we're going to be given two arguments
141:52 - we're going to be given a Target amount
141:54 - as well as an array filled with some
141:55 - coin values what we want to do in this
141:57 - problem is return the number of ways
141:59 - that's possible to make the amount given
142:01 - the coins in the array and we can reuse
142:03 - the coin value as many times as we want
142:04 - and so for this particular example let's
142:06 - go through the ways we can make an
142:07 - amount of four one way would be to use
142:10 - just a bunch of one cent coins or you
142:12 - could do a three plus a one you can also
142:14 - do a two plus a two and finally you can
142:17 - use one two cent coin and then two one
142:19 - cent coins
142:20 - and so that means there are four
142:22 - distinct ways to generate our amount
142:24 - so let's Trace through an algorithm you
142:25 - can use to solve this one we'll start by
142:27 - structuring the different decisions we
142:28 - can make when it comes to building our
142:30 - amounts of four so I'm going to use four
142:31 - at the root and like we're used to let's
142:33 - go ahead and Branch for every coin value
142:35 - that we have available in other words
142:37 - what I could do is take a one cent coin
142:39 - in which case I reduce my target amount
142:41 - from four to three or I could take a two
142:43 - cent coin in which case I have two cents
142:46 - remaining or I could take a three cent
142:47 - coin in which case I have one cent
142:49 - remaining you've seen this pattern a few
142:51 - times in the course already if we built
142:53 - out the full tree we'd end up with a
142:55 - structure like this notice that we
142:57 - terminate wherever we have zero because
142:58 - that must mean we actually successfully
143:00 - built our Target amounts we know that a
143:03 - zero Leaf would represent one of the
143:04 - ways to create our mount looks like we
143:06 - have too many zeros here you're going to
143:08 - see that we have seven zeros but we said
143:10 - that there are only four ways to create
143:12 - our Target amount let's start by
143:14 - interpreting one of these paths so let's
143:16 - say I looked at this path this path will
143:18 - represent me taking coins one plus two
143:20 - plus one and if I look at another path
143:22 - like this one in pink this is represent
143:24 - the way of taking two plus one plus one
143:26 - if we look at those two paths they
143:28 - actually represent the same coins right
143:30 - I'm using a single two cent coin and
143:33 - then two one cent coins I just took them
143:35 - in a different order and that's why we
143:37 - have a high count right now we're
143:39 - actually counting duplicate ways and so
143:42 - I don't want to return seven although my
143:43 - tree says that I should really return
143:45 - four so actually structuring our tree
143:47 - like this is not going to be the way to
143:49 - solve this problem so what would be a
143:51 - better way well we can still use our
143:52 - tree structure so we're going to break
143:53 - this one down recursively but we want to
143:55 - build it in a way where we don't have
143:57 - any duplicate paths right and so what
144:00 - we'll do is starting at the root of our
144:01 - tree we're going to make a decision for
144:03 - just a single type of coin so at this
144:06 - top level of my tree I'm only writing a
144:08 - decision for my one cent coins and so
144:11 - for this coin with a value of one what
144:13 - I'm deciding on is how much of this coin
144:15 - to take so I could take zero one cent
144:18 - coins in which case my quantity that I'm
144:20 - targeting my target amount still stays
144:22 - at four
144:23 - or I could take a single one cent coin
144:25 - in which case my amount is now three if
144:28 - I take two one cent coins then now my
144:30 - amount is two and this would just carry
144:31 - further until I've exhausted all the
144:34 - possibilities for my differing
144:35 - quantities of one cent coins so notice
144:38 - here along the edges of my tree now I'm
144:40 - denoting the quantity of the coin I'm
144:42 - taking and at this first level I'm
144:44 - taking coin one what I can notice
144:46 - immediately is I already have a node
144:48 - that terminates at zero so this must
144:50 - mean that represents one way I can
144:52 - generate my amounts of four and what
144:54 - this path represents is really me taking
144:56 - four one cent coins and on the next
144:59 - level of the tree I'll wanna do is make
145:00 - the same decisions but for our two cent
145:02 - coins so let's say I wanted to expand
145:04 - this note of four what I do is Branch
145:06 - for different quantities for my coin
145:08 - value too so I can take zero two cent
145:11 - coins one two cent coins or two two cent
145:13 - coins and that would give me four two
145:15 - and zero as my reigning amount
145:17 - respectively so we're gonna need some
145:19 - more room here our tree's getting a
145:20 - little wide what I can do is notice this
145:22 - amount of one since I'm trying to decide
145:25 - how many two cent coins to take I
145:27 - actually can't take any two cent coins
145:29 - out of that amount so this darkened node
145:31 - basically is going to be a dead end so
145:33 - we can effectively ignore it that's
145:35 - going to be true throughout this tree
145:36 - whenever we have an amount that we can
145:38 - no longer shrink we actually don't need
145:40 - to expand that node anymore
145:42 - and so let's reorganize things over here
145:45 - now let's expand this node of three and
145:47 - again I'm branching for different
145:49 - quantities of two cent coins right so I
145:52 - can take a zero two cent coin or I can
145:54 - take just one two cent coin which case I
145:56 - result in amount of three and are
145:58 - amounts of one I'll carry this further
146:00 - for the other nodes at this level
146:04 - notice at this point we've just
146:05 - encountered more zero amounts which
146:07 - means they represent other ways to
146:08 - create our Target so so far we've
146:11 - counted three distinct ways to create
146:12 - our initial Target amounts of four
146:13 - finally at the bottom level we choose
146:16 - different quantities for our coin value
146:18 - of three
146:30 - notice that some of the leaves here
146:32 - don't terminate in a zero which means
146:34 - that they don't represent valid ways to
146:36 - make my initial amount what I can notice
146:38 - at the bottom level though is I have an
146:39 - additional zero this would actually give
146:41 - me all of the four different ways I can
146:43 - create my target amount
146:46 - so the key pattern here is we want to
146:48 - make sure that up front we choose
146:50 - different quantities for a single coin
146:53 - value before moving to the next coin
146:55 - value altogether what I don't want to do
146:57 - is flip back and forth between different
146:59 - coin values because then I would end up
147:01 - looking at duplicate ways if you think
147:03 - about how we have the tree structured
147:05 - now we have a very short tree right this
147:07 - tree's height is just going to be the
147:08 - length of the coins array because at
147:10 - every level of this tree I'm choosing
147:12 - for a different coin value so although
147:14 - my tree is very short I actually have
147:17 - now a very wide tree because now I'm
147:19 - iterating through differing quantities
147:21 - it's like you can probably foresee we
147:23 - can totally structure this problem like
147:24 - a dynamic programming problem meaning
147:26 - you could spot duplicate subtrees here
147:28 - let's take into account the shape of our
147:30 - tree to come up with the complexity of
147:32 - this so if we implement this wisely with
147:34 - some dynamic programming via some
147:36 - memoization we should end up with a time
147:38 - complexity that's a multi-linear so just
147:40 - a times c and a space complexity that's
147:42 - also a times C we say that the time
147:45 - complexity is a times C because is a is
147:47 - the width of the tree and c is now the
147:50 - height of the tree and in general the
147:51 - number of nodes would be the height
147:53 - times the width the space complexity is
147:55 - also going to be a times C because of
147:57 - the different keys we're going to need
147:58 - to put inside of our memo hash map
148:00 - you're probably wondering exactly how we
148:02 - implement this and why the complexity is
148:03 - the way it is and to do that we're going
148:05 - to actually have to implement the code
148:07 - together so at this point you'll want to
148:08 - join me in the walkthrough videos I'll
148:10 - see you there
148:20 - hey programmers welcome back what I want
148:22 - to do right now is go over the Java
148:23 - walkthrough for this counting change
148:25 - problem
148:26 - so in this problem like we said it's
148:27 - going to be a variation of our you know
148:29 - coin changing problems and what we want
148:30 - to do is this time return a number of
148:32 - ways that we could generate our Target
148:34 - amounts like we said in the approach
148:36 - video the thing to watch out for here is
148:37 - to make sure that you don't count any
148:39 - duplicate ways and so the structure of
148:41 - this recurs is going to be a little bit
148:42 - different I'm going to need an
148:44 - additional argument into my recursive
148:46 - method here and so I'm going to Define
148:48 - it down below it's going to have mostly
148:50 - the same signature I'm still going to
148:51 - take in the amount as well as all the
148:53 - option of coins I'm also going to take
148:56 - in an index I'll call it coin index
148:59 - this is going to represent the index of
149:01 - the current coin I'm going to consider
149:03 - which means top level over here when I
149:04 - call my recursive method I'm going to
149:06 - give in the same old Target amount I'm
149:08 - going to give it an initial coin index
149:09 - of zero and of course pass along the
149:12 - original choice of coins here
149:15 - and so what I get to do now with this
149:17 - coin index is now vary the quantity that
149:19 - I'm going to take the coin of the given
149:22 - index like we said the approach video we
149:24 - want to count the number of ways to
149:25 - generate the amount
149:27 - so recursively I want to be reducing
149:28 - this amount over time toward my base
149:30 - case in other words once my target
149:32 - amount is zero I have to think about how
149:35 - many different ways can I give back zero
149:37 - cents and the answer there is one right
149:39 - there's exactly one way you can give
149:41 - back zero cents and that way is to do
149:43 - nothing right so this one represents me
149:45 - counting a valid way right there's one
149:47 - way to make zero sense
149:49 - good and then from there what I want to
149:52 - do is now iterate over the possibilities
149:54 - so I know that given this coin index if
149:58 - I use it to access some value out of the
150:02 - coins list I can do coins.get coin index
150:05 - and I'm going to create a variable to
150:08 - store it I'll call it int value so this
150:10 - is the value of the current coin I'm
150:12 - considering so if I take a look at the
150:13 - first example in the event that coin
150:16 - index is zero that means my value is one
150:19 - it's like a one cent coin in the case
150:20 - that my coin index is one that means the
150:23 - value I get is two
150:25 - what I want to do is take varying
150:27 - amounts of this coin value
150:29 - so I'm going to start iterating here and
150:31 - this Loop is going to be
150:33 - different from our previous coin prompts
150:35 - in that we want to iterate over a
150:37 - different quantity right so I'm going to
150:38 - say int quantity if I think about what
150:41 - the lowest quantity of a coin I can take
150:43 - is well the answer there is zero you
150:44 - could take no instances of a coin
150:47 - and I know I'm going to increase that
150:48 - quantity over time to go through the
150:49 - possibilities but I have to think about
150:51 - how far I need to go what I want to do
150:53 - is iterate this Loop while the quantity
150:55 - times value is less than or equal to the
151:00 - Target amount so here I'm checking that
151:02 - my quantity times value is less than or
151:04 - equal to the amount because I don't want
151:06 - to overshoot my amount so for example
151:08 - let's say that right now my coin index
151:11 - is 1 right so that means I'm looking at
151:14 - the element of 2 over here right if I do
151:17 - my quantity times the value I have to
151:20 - think about what's the most number of
151:22 - two cent coins I can take right now if
151:24 - my target amount is four right well in
151:27 - the first iteration this is going to be
151:28 - valid because I'm going to check if 0
151:30 - times 2 is less than or equal to 4 right
151:33 - and that's true so I keep running the
151:35 - iterations I'm going to check if 1 times
151:38 - 2 is less than or equal to 4. that's
151:40 - still true then I check if 2 times 2 is
151:42 - less than or equal to 4 and that's still
151:44 - true but on the next iteration when my
151:46 - quantity is 3 I'm going to do my 3 times
151:50 - 2 which is 6 and that's no longer less
151:52 - than or equal to my target amount of
151:54 - four because I don't want to take out
151:55 - six cents for my target of 4 cents
151:57 - that'll give me a negative quantity
151:59 - right so this condition ensures that I
152:01 - only iterate up to a valid point here
152:05 - so what I want to do now is generate my
152:06 - sub amount so I can do my int sub amount
152:10 - and I'll make that equal to the original
152:12 - amount but just minus the quantity
152:15 - times the value right I'm reducing the
152:19 - amount by the number of coins that I'm
152:20 - taking then from there I have this
152:22 - reduced quantity I want to call
152:23 - recursively on Counting chain now given
152:25 - that sub amounts
152:26 - and because I just made a choice for how
152:29 - many instances of this coin index I'm
152:32 - going to take what I want to do is now
152:33 - move to the next coin so here's where I
152:35 - increment my coin index
152:37 - so coin in X plus one right notice that
152:40 - this for Loop is going to iterate
152:41 - through all the possibilities for my
152:44 - given coin index and once I make a
152:46 - choice of that coin index I can never go
152:48 - back to it and so that's why I increment
152:49 - my coin index in the next recursive call
152:53 - along with that I can pass along these
152:55 - same coins right that doesn't change
152:57 - awesome now I have to think about the
152:59 - logic of my my problem here I know that
153:01 - in the approach video I wanted to have
153:02 - the effect of taking a total right I
153:04 - wanted to add up the sum of all of the
153:07 - branches through my tree so I know that
153:09 - counting change is going to return an
153:10 - integer that integer represents all of
153:12 - the ways that I can generate these sub
153:14 - amount
153:15 - so what I want to do is take the grand
153:17 - total of that so I'll say int
153:19 - total ways equals zero and I'm going to
153:23 - add
153:24 - the results over here
153:27 - nice so I'm getting the grand total
153:30 - number of ways and after my for loop I
153:32 - just want to turn the total ways
153:35 - just a little type over here I should be
153:37 - saying total ways so this looks mostly
153:40 - good except I should consider also
153:42 - adding a base case regarding my coin
153:45 - index in other words what if it's the
153:47 - case that you actually exhaust all of
153:49 - your different options for your coin
153:51 - index but your amount is still not zero
153:54 - so let's say after this if statement if
153:56 - I get past this if statement I know my
153:58 - amount is not zero right I also want to
154:00 - check hey if my coin index has no other
154:03 - options in it in other words if my coin
154:04 - index is greater than or equal to coins
154:09 - dot size then I have no more options
154:12 - right I know the last valid index of
154:14 - coins is coins.size minus one so if coin
154:16 - index is equal to coins that size I know
154:19 - I don't have any more coins I can
154:20 - possibly take so if you hit this case
154:22 - you want to return zero right there's no
154:24 - possible ways to generate your amount
154:26 - from this point because you already
154:27 - chose all of your quantities for your
154:29 - different coin indices
154:31 - nice the order of these conditions is
154:33 - really important right because I have
154:35 - this if statement of line 13 after line
154:37 - 9 this is technically checking all right
154:40 - if my amount is not zero and my coin
154:43 - index is out of bounds right and I'm
154:46 - able to accomplish that logically by the
154:48 - order of these two conditionals
154:50 - so what the let's give this a test run
154:52 - this could be our initial Brute Force
154:54 - solution
154:56 - looks like we're going to timeout
154:58 - nice because we get that not so great
155:00 - exponential runtime here
155:02 - so like where you see we'll go ahead and
155:04 - memorize this right
155:05 - so I'm going to bring in my hashmap
155:08 - and I'll be sure to
155:11 - pass it in over here
155:13 - it's our new hashmap
155:14 - when it comes to designing the hash map
155:16 - over here
155:18 - I have to think about what the keys need
155:19 - to be as always the keys need to be the
155:21 - changing arguments through my recursive
155:23 - method and here it's actually
155:24 - interesting that two arguments change
155:26 - right my amount changes because I have
155:28 - some reduced sub amount that I'm passing
155:30 - along and also my coin index changes
155:32 - because from one call to the next it
155:33 - would be increasing the coin index and
155:35 - because those arguments change during
155:37 - the recursion those are the ones I want
155:38 - to encode into my hash keys right so
155:42 - my keys here will actually be a list of
155:44 - integer
155:46 - I'll just make sure that that sub list
155:48 - or those sub lists just contain a pair
155:50 - of a Mountain Coin Index right
155:52 - corresponding return value is going to
155:54 - be integer so integer will be the values
155:56 - of my map I'll call that my memo nice so
156:00 - what I'm saying is I'll enter the base
156:02 - case and I'll form my key I'll just say
156:05 - list of integer it's going to just be a
156:07 - list of the amounts followed by the coin
156:10 - index I'm going to use this entire pair
156:12 - as the keys in my memo so I'm going to
156:15 - check if my memo contains a key a key
156:18 - then I want to return its stored value
156:20 - so return memo dot get key because that
156:23 - means I've seen this is a problem before
156:25 - so I can return the previously saved
156:27 - subresult
156:28 - and now what I want to do is make sure I
156:30 - pass along this memo by reference
156:31 - through the entire recursion
156:34 - and also be sure to store your recursive
156:36 - return value into the memo before you
156:38 - leave so that would be line 31 here what
156:41 - I do is I can say memo dot put you
156:44 - always want to make the key for your
156:46 - stored value the original key that
156:47 - encodes the arguments right so a
156:49 - Mountain Coin index are part of my key
156:51 - here so I use that in my memo
156:54 - and I store the total ways
156:56 - then just be sure to return the old
156:59 - value so return total ways all the same
157:00 - right that shouldn't change
157:02 - so with this let's go and give this a
157:04 - test run we should now be using our memo
157:07 - to solve this dynamic programming
157:09 - problem quite quickly
157:11 - see what we get
157:13 - awesome and there we have it
157:15 - hey programmers so you've reached the
157:16 - end of a dynamic programming crash
157:18 - course but the learning doesn't stop
157:19 - here if you head over to structney.net
157:22 - you'll be able to practice some dynamic
157:23 - programming problems further we have a
157:25 - full module on dynamic programming a lot
157:27 - of the problems that you've covered not
157:28 - in this video series for free code cam
157:30 - but I have a lot more in store as well
157:32 - so whether you're looking to really hone
157:34 - in on your skills of dynamic programming
157:36 - or you want to cover and go through all
157:37 - the other topics we have featured on
157:39 - structi I recommend you head to
157:40 - structie.net you're going to have access
157:42 - to video tutorials as well as animations
157:44 - with me for every single problem I'll
157:47 - see you there

Cleaned transcript:

dynamic programming is a method for solving complex Problems by breaking them down into simpler overlapping sub problems and storing solutions to these sub problems to avoid redundant computations it can help you solve complex programming problems such as those often seen in programming interview questions about data structures and algorithms Alvin zablin teaches this course about dynamic programming in Java he has multiple super popular algorithm courses and he is a great teacher hey programmers Alvin from structure here Welcome to our course on dynamic programming in Java this is one of the most highly requested topics from free code Camp students so I'm super excited to explore this material with you in Java so if you're looking for a really thorough exploration of dynamic programming exclusively in Java you're in the right place of course that means all of our code specific walkthroughs are going to be in the Java programming language as for the format of this course we're going to build our dynamic programming knowledge by exploring a sequence of problems the problems are going to start simple but it's really going to give us the foundation we need to eventually solve some very tough dynamic programming problems in this very course for every problem we work through we're going to solve it using two steps the first thing we're going to do is head to my whiteboard where we'll come up with a strategy and really try to visualize the dynamic programming nature Behind these problems so after we draw things out on the Whiteboard and get a really confident understanding of the structure behind a particular problem then we're going to head into my editor where we're actually going to code up a Java specific solution alright so that's enough introduction for now what I want to do is hop into our very for section on our exploration of dynamic programming we're going to work through and frame our Fibonacci problem through our dynamic programming lens hey programmers Alvin here right now I want to work through this FIB problem of course we're referring to the classic Fibonacci Sequence this is a really really important you know computer science problem and to me it serves as the foundation to really unlocking a few harder Concepts down the line so even if you've done this FIB problem before it helps to review it together right now we're gonna see this core pattern uh show up a lot during the course together and so let's start by understanding what we should do in this problem well we know that the Fibonacci sequence has a few certain seed values we say that the first number of the sequence is zero and the second number of the sequence is one and then to generate further numbers of the sequence we just take the sum of the previous two in other words I can take zero plus one and that gives me the next number one right so the sequence starts zero one one then from there I continue this pattern right I can take the one plus one that gives me two I can take the one plus two and of course that gives me three and so on so forth and of course I can generate uh the sequence of infinite length in this way and so overall in this rendition of Fibonacci what we want to do is actually return the number at the specified index of the sequence right and so a really key insight about the Fibonacci sequence is to generate any particular number of the sequence we must know some other numbers of the sequence right I can get eight by just doing the previous three plus five if I wanted to actually formalize this problem a little bit better what we'll have to do is understand that these numbers I have listed are really the elements of the sequence and of course I can assign some indices to those elements so up top I'll just label these increasing by one of course but starting at zero so I can say something like hey the zeroth number of the sequence is zero and the first number of the sequence is one and also the second number of the sequence is one and so on and so forth so kind of jumping ahead a little bit if I look at this particular position what I see is all right it seems to be that the seventh number of the Fibonacci sequence is exactly 13. that's going to be overall the shape of this problem all right so how can we go about solving this one and so for this particular approach what I want us to do is actually work through this one recursively I think the iterative solution is pretty straightforward but I'm going to force us to solve this one recursively because it's going to help us I'll learn some new topics along the way so we'll kind of stick to a recursive mindset and if you hate recursion you know too bad he'll learn to love it right now and so looking at a particular example let's say I wanted to figure out how I can come up with the solution for FIB of six in other words the sixth Fibonacci number is exactly eight and so what I can start to do is figure out how to break down this problem I know in general to generate the sixth number of the sequence I can take the fifth number and add that to the fourth number right it's exactly the rule of the Fibonacci sequence let me try to visualize this one a little bit better so I'll represent uh the problem FIB of six using somewhat of a tree and I'll represent an instance of the problem as a note of this tree so I have my top level problem of six that'll be the root of this tree and this is a really important way to actually visualize recursion because it really shows us how we're going to utilize our return values and reconstruct our final answer so if this is a new pattern for you don't worry we'll walk through it pretty slowly together and so now that I have this root of six I have to figure out how do I break down this problem well like we just said to solve above six what I need to do is break that down into fibbo five so that'll appear as a child of that sixth node in the same way for before also needs to be solved to solve our main problem over here and notice how I have these you know children nodes of course below the FIB of six right as I go downward in this tree I should be getting smaller and smaller numbers in blue right that would represent a smaller problem because I know once I have a small enough input in blue then I would have somewhat of a base case kind of inherent the Fibonacci sequence so let's take a closer look at this five note over here right this node represents the problem of FIB of five right what is the fifth number of the sequence and I know in general my pattern is all right if I want to calculate FIB of n then I take the sum of N minus 1 and N minus two so I'm just going to apply that pattern to this five node in other words on fives left it's going to have a node of four and a five is right it's going to have a note of three right doing a minus one and minus two respectively and it's a similar trend for the four node on the right hand side over here right it's going to have two children of course doing 1 on the left and minus two on the right giving three and two respectively so let's keep applying this pattern we're going to do is fill out the next level of the tree until we can't fill it out anymore we have to notice here is when it comes to actually building on the full tree we have to stop at certain nodes in other words once I have an instance like zero as my input to this little sub problem I can actually shrink that problem size any further let's all highlight all of these nodes whose input is zero right that represents the zeroth number of the Fibonacci sequence and something inherent in the problem is I can't really break that problem down any further I know that for those particular nodes they ought to return zero right because a zero number of the Fibonacci sequence is exactly zero so in green I'm going to represent the result or the answer to those sub problems right I'm going to put their answers above the problem itself right so I'm trying to be very very particular in my drawing I'm always going to write a return value above a node here and I have a similar case for all of my nodes who have an input of one those are also a base case right because the first number of the Fibonacci sequence is exactly one so we'll also fill in those ones above cool now that I have some floating return values I can start to reconstruct my larger problems at hand so let's stay focused on the left hand side of my tree let's look at this particular node so I'm looking at this node of two and I have a left hand value and a right hand value are ready to compute I know that if I look at this this node of 2 it's trying to figure out what's the second number of the Fibonacci sequence and so at this node of 2 in blue what I can do is just take the sum of its children right of those green values so 1 plus 0 gives me one and if I do a quick Sandy check that must mean that the second number of the Fibonacci sequence is exactly one and this pattern continues up the tree right at this node of three I take the sum of the one plus one and I get two if I do a quick Sandy check that must mean the third number of the Fibonacci sequence is two what we're doing right now is really stepping through how a recursive code would actually return right return means return to your caller right so return to your parent node and so I'll fill in the rest of the values over here and bear in mind you know as you kind of uh draw out these diagrams maybe for yourself hopefully on pen and paper or even on a whiteboard it's really important at least for me that you check for correctness as you build the tree so if you're in an interview it really helps to not just check for your top level answer being correct but at any points of your Trace you should have logical information in other words by just looking at this node right I have a blue note of three over here whose return value is two that logically implies that the third Fibonacci number is two and that's totally correct so I'm good to go for now right it would really be a drag if I kind of sketch through this entire drawing only to realize I had a little like typo or miscalculation somewhere Below in the tree so I highly recommend that you stay very aware of your sub results as you kind of Trace through a diagram like this so let's continue to build up these sub Solutions so I know that this node of 2 is going to take the sum of one plus zero that gives me one and finally at the parent of four it's also going to take the sum so two plus one is three and that must mean that the fourth of a notch a number is of course three so let's speed this up a little bit for every other uh node in the tree so we're gonna add all these up so on and so forth now at the tippy top we see that this note of six at the root is going to take the sum of five and three and of course that gives me eight which is exactly the punch line right the sixth Fibonacci number is indeed eight and so looking at this pretty large tree you might realize that hey you know our top level problem was asking for the sixth Fibonacci number not a very large number in the sequence however we have to use a lot of nodes to actually represent that problem how we broke it down that's something really important about this Fibonacci Sequence right it has a pretty interesting complexity a pretty large one at that so let's try to analyze the complexity of this we know that every node of this like visual tree represents a recursive call right and so the number of recursive calls I make over here or the number of nodes of the tree should roughly represent the time complexity of this solution you're probably already recognizing that it's going to be a very very large one let's go step by step over here and so to analyze the complexity of recursion like this I think it's really important to notice any patterns in the tree to me it's all about looking in the tree right I can kind of figure out at least the ballpark of the type complexity without even writing the code right just using this visual and so at first glance you might notice that this one is pretty hard to analyze because the tree is asymmetric in other words notice that it's a little taller or deeper on the left hand side then toward the right hand side of the tree it's actually much more shallow and that kind of asymmetry makes us feel a little uncomfortable when it comes to figuring out any patterns so here's what we'll do let's actually try to analyze this one by drawing an analogy so let's ignore this exact Fibonacci tree right now and go for a more symmetric example so let's say I had a similar recursive code that had a more symmetric recursion so let's say I had some top level call with a value of four and let's say that this top level call to four I actually made two more recursive calls but both on a minus one in other words the left child is the same as the right child which is different from our classic Fibonacci right Fibonacci our left was minus one and our right was minus two but now I'm just doing minus one on both sides if I continue that pattern that should give me a nice symmetric tree let's say I had some base case roughly when my value is one so I can stop building the tree from here and so this has a nice symmetry to it let's try to notice any patterns now if I look at the different levels of this tree let me look at how many nodes there are across a level so for example my very very top level and there's one note on that level on the next level there's two nodes and then four nodes and then eight nodes you can probably see how this pattern scales right if I drew more of this tree let's say I had a farther a base case it would be 16 nodes and then 32 nodes and so on and so you probably realize the obvious pattern here right the very top at the root of my you know recursive tree I have one note or one call and then from one level to the next I doubled I multiply by two right and I do this process basically for every level of this tree so that begs the question you know how many levels are there in this tree well just looking at this kind of particular concrete example there's definitely about four levels right and I can kind of understand uh how to designate each level by just looking along this lefthand path right so colored in yellow notice that I have four three two one that's just a decreasing pattern so when it comes to the number of levels it's pretty obvious to me that it's exactly n levels right if my top level problem at the root is where n equals four then I have you know four levels or in general n levels so it's pretty clear to me that when it comes to figuring out the total number of nodes in this tree which implies the total number of recursive calls we make for this kind of toy problem it looks like I would multiply two by itself n times over which is a definition of an exponential 2 to the nth power cool so maybe you're a little bit skeptical and here's where we can either you know really buy into kind of the Big O complexity or we can get bogged down by the finer details something that you might fall into sometimes but you have to kind of be very aware of it is Big O is really just an estimate so if you actually plug in some values here you might notice all right if I did 2 to the fourth power right because 4 is my n in this particular example that would be 16. and so if we actually counted the quantity of nodes in this visual tree it would not be exactly 16. I'll label them over here starting at one there's actually going to be 15 nodes so it's off a little bit but if we you know understand Big O complexity we know that if we have something that's of the shape of like 2 to the N minus 1 we can ignore the minus one what's more is even if it was off by like five right if it's a minus five that's still a constant that we're subtracting that still is dropped from the Big O notation so overall I would consider this particular example as having o of the 2 to the N Run time which would be exponential pretty pretty slow right so while we're here looking at this symmetric example before we hop back into FIB let's try to recognize what the space complexity is we know how the space complexity for recursive code is going to be more or less the number of Stack frames that we use right for our recursion because whenever we make a recursive call that information has to be stored on the call stack right so we kind of make different function calls and also return from function calls and so this is actually something I notice students have quite a difficult time uh analyzing and so what I'm going to do is really Trace through how we would make these recursive calls as well as how to visualize the call stack right so this top level call of four that would be added to the stack all right so stack will be just a little a little rectangular block right and then as I make recursive calls let's say now I call upon three that's my input that's also added to the stack notice that it's added on top of the four right and really we have to recognize here is every time we make a call we're adding a new stack frame and we only get to remove something from the call stack when it returns so so far none of my calls have returned right until I have one at the top of my stack right at this point I've kind of bottomed out at like a base case so I can return from that call which also means I remove it from the stack at this point I need to evaluate two's right child so I make another call to one and this process continues right now I'm done with both of twos call so it can return now I'm back at three but three has to call upon it's right and the same thing happens well you'll notice that at this point is although there are many you know different stack frames we would have to eventually push onto the call stack at any point in time there's only about a four different stack frames on the call stack right it's not as if that we store like all of these different stack frames simultaneously right it doesn't really make any sense to add certain stack frames you must have returned from other ones so it's actually the case that the space complexity due to the call stack would just be o of n overall we're looking at an exponential runtime and a linear space complexity alright so for this particular symmetric example it has an exponential runtime and a linear space complexity but how about for our actual Fibonacci tree we know our Fibonacci tree is more lopsided it's roughly going to be like half the size of that and you can take my word for it it would actually be the same Big O complexity right still 2 to the n and then just an O of n space complexity and so kind of taking a lay the land over here the space complexity seems reasonable right however whenever we have an exponential usually that's not good enough and there is actually a better or faster way to solve this one recursively which is what I want to expose this to uh right now so let's go back to the recursion tree for our FIB problem right and so what we can do is try to recognize any patterns within this tree do you notice any duplicate work right this is all about understanding you know what this diagram represents right every node I have drawn in here with its corresponding number represents a problem as you can see I have many duplicate problems so for example if I look at this subtree that sub tree represents a sub problem right rooted in four so I'm asking for the fourth Fibonacci number not only do I need to calculate that on the left hand side of the tree but at some other point down the line on the right hand side I need to calculate that same exact sub problem right these two subtrees are identical and they both represent the same problem the fourth Fibonacci number and this pattern actually applies recursively because the strategy is recursive right so you can notice probably some other different duplicate sub problems right if I root myself at three I have to calculate this sub tree three different times right and notice that that three subtree is also internal uh to the fit before so it's a really a really duplicate and there are a few other duplicate sub trees you can recognize over here so we have a lot of duplicate work in this kind of Brute Force recursion and if we actually store some sub results then we can forego having to recalculate any of these subtrees down the line and so really what we're looking to do is kind of prune out some branches of this tree to avoid some duplication so what I'm going to do is kind of ignore this right hand tree of four so I'm going to take that out because I would have calculated it on the left hand side somewhere I'll do the same thing for this kind of middle tree of three so I can ignore that as well cool likewise for this too and so at this point we don't really have any full duplicate sub trees right I kind of took them out of my drawing so if we actually store some results as we calculate these sub problems this really represents all of the recursive calls that we'll have to make right and so you're wondering how can I actually Implement you know that kind of pattern in my code well it's all about just storing some additional information so let's step through still FIB of six so I want the six Fibonacci number in the long run we should get eight and the strategy I'm introducing right now is called memoization and so when it comes to implementing memoization in your language of choice it's all about storing some additional data in a memo and your memo is typically going to be your like hashed data structure so it could be like a hash map or a dictionary or object depending on your weapon of choice here right it's really important that I choose some data structure that gives me an O of one lookup time right so usually that would be your hashed data structures whatever that is in your particular language and so let's step through this one again but now we're going to store some data inside of our memo so we have the same base cases as before right we know that the first Fibonacci number is one and the zero Fibonacci number is zero and when these values return to the parent of two we're still going to calculate the sum over here so 1 plus 0 is just one but now that I have this result I can store it in the memo so I'm going to make the key represent the input to that node or that recursive call and then its value is going to be that return value and so if I look inside of my memo it's a reminder that the second Fibonacci number is one so we'll continue this process I know that I have a basically server here still the case that the first Fibonacci number is one and I return to the parent I calculate that hey the third Fibonacci number is two and I'm going to store that in my memo as well and here's where things get a little more interesting if I look at this node of 2 over here I've actually calculated uh this sub problem before right I can check that by just looking inside of my memo my memo says Hey the second Fibonacci number is one so without having to recurse and build the full subtree once again I'll just go ahead and fetch on the stored value in my memo so I'm just going to jot down a one above this node of two I'm not going to return to my parent and I figure out that hey the fourth Fibonacci number is three and of course I want to be sure to return that but also store it in my memo for the future and same thing happens at this three note right this three note is again in my memo so without you know recursing through my tree I'm going to just fetch that value from my memo I already know that hey the third Fibonacci number is two and so I can calculate the value at my parent right fifth for Notch number is five be sure to store that in your memo and so on and so forth by the time we get to the very top of our tree of course we have the fact that the six Fibonacci number is indeed eight and I avoided a lot of the duplicate recursive calls so it's clear to me that we avoid a lot of duplicate work what exactly is the run time now right and so we'll try to notice uh some patterns so this visual tree represents our Fibonacci recursion after we implement this memoization strategy right I'll try to generalize it over here so I'll kind of tidy up these edges over here and let's say I increased the size of this problem so instead of FIB of six what if I asked you for FIB of seven that recursion tree would look something like this right notice that the root is now seven of course and it's still the case that the left child is 1 so a six and the right child of the seven is a minus two or a five right still being the rules of Fibonacci and I only added two more nodes if I increase the problem size to FIB of eight I would still add two more nodes so every time I increase my input by one I only add two nodes it's always adding a constant number of nodes at this point our problem scales linearly right in general we're going to notice that we have basically two times n nodes and notice that that's not 2 to the N where I'm saying 2 times n and so we can simplify that to a runtime of O of N and the space complexity is still the same right notice that the space complexity for this algorithm is really just going to be the height of the visual tree it still looks like a linear chain right if I go along the lefthand path it just goes eight seven six five four and so on so definitely an O of n space complexity and this is actually a pretty efficient solution for our Fibonacci and so I think from this point let's go ahead and implement this in some code now we can have this core pattern under our belts so I highly recommend that you try to implement this one in some code on your own but don't forget we also have the video walkthrough available if you get stuck or just want to code along now that we're done sketching out a strategy for this problem on the Whiteboard what you want to do is follow the link in the description for this FIB problem so you can follow along and code up our solution in Java with me hey programmers Alvin here what I want to do right now is go over the Java walkthrough for this FIB problem this is going to be our very first problem in the dynamic programming section now I am going to teach you to solve dynamic programming problems is using recursion plus memoization so we're going to start just by warming up here and solving this Fibonacci problem uh using recursion and then we're going to apply our memoization strategy on top of it and this is going to be a really great strategy that can scale to a lot of different dynamic programming problems obviously you might be thinking that you could solve a Fibonacci using some you know pretty classic iterative code and you definitely can however I'm going to show you how to solve this recursively with memorization because it's really going to set you up for harder problems later on so let's Jump Right In when it comes to setting up the recursive code here I want to start with my base cases and they tell us that the zeroth number the Fibonacci sequence is zero and the first number of the Fibonacci sequence is one so I'll turn those into base cases so I can just go ahead and check hey if n equals zero then I know I need to return zero like wise if n is equal to 1 I know I want to return one so to kind of combine those into a single base case here I can check if n equals zero or n equals one well there's return n itself right because the zeroth number of the sequence is zero and the first number of sequence is one and that'll give me my two base cases to start then from there I only need one more line of code the recursive definition of Fibonacci is to get some further a number of the sequence you just take the sum of the previous two right so I know that the previous number of the sequence would be Fibonacci of n minus one right because n represents the number I'm asking for so the number in the sequence that comes before would be n minus 1. I want to add that to Fibonacci of n minus two right so that would be the number two steps ago right take the sum of them and that would give me my current number so let's give that a test run this will be correct but it won't scale in terms of the time complexity like we said in the approach video the time complexity of this Fibonacci function although it's very short code is exponential right it's 2 to the n and so the growth of this function as we increase the input number n is very very large so you're actually going to get a timeout for this one and so to make this faster we're going to layer on a memoization strategy right and so what's really important in the way I teach monetization is we always start by solving the brute force and here I have the Brute Force right I can identify that I've correctly implemented The Brute Force when I get correct results for my method except it's slow right so it times out for some very large input for example if I take a look at the test case I'm feeling right now it would be calling Fibonacci with an N of 46 right it would give me some large value and because this has an exponential time complexity that's far too large for me to wait around for and so when it comes to creating a memoization around this Brute Force solution in Java what I usually do is create two separate methods I'll have my main method I also have my recursive helper method that also takes in a memo and so let me create another version of this method above that would be the main method and it's just gonna really call and pass control into my recursive method I'm going to overload it with an additional argument here right so FIB the recursive method is going to take in not only the integer n but my memo and for you in Java it'd be nice if you implement your memo using a fast lookup data structure right because you want to improve the runtime of this code so you want to store your sub results in a fast lookup data structure so for you that could be as simple as a hash map so I'm going to import up top Java util hashmap so I know that a hashmap has o of one insertion and ov1 lookup and I'll take in a hash mark over here and when it comes to how I design the structure of the hash map I know that the keys of my hashmap need to be input arguments to My Method here right so I know the input argument is a number or integer n so I'm going to make the key integer I make the corresponding value in the hash map the return value for my method it's going to have integer values as well I'll just call this argument memo so that means when I in my main function call my recursive method here I'll pass in the original n but I'll give it a new hash map nice I could just return whatever the recursive method returns so do bear in mind that this circus of method now line 9 is taking in my original argument n as well as this memo hashmap right and this memo hashmap is going to be shared for the entire recursion right so what I need to be sure to do is I'm taking in the memo that's an argument here when I call recursively on FIB I want to pass along the same memo right you're passing it by reference so you can have all of your recursive calls share the same memo object right think of it as if when you visualize like the recursion tree like we did in our approach video you want all of your nodes in the tree to refer to the same memo awesome so that's just me adding an additional argument into FIB but now I actually want to use that memo object and so what you should do is check if your argument is already a key in your memo right so I'm going to check it over here it kind of acts like another base case here so I put it at the top so I'm going to check if my memo already contains key of my argument n right what I can do is then just return the stored value of that key so I can do memo dot get n obviously this only works if I you know over time store values into my memo which I'll do in a moment right so I know my memo is going to map right arguments of my method to their return values so if I find an argument in the memo that matches my current argument I'm just going to return its stored value in the memo but that means I need to be storing things over time into the memo and so now you should locate wherever you return recursively for your method so that'd be the line 19 return right those are my recursive return values right I know that line 11 is not a recursive return value because it's literally my base case right so I know that this value here I know it's really composed of you know two separate or cursive calls but I know that this will ultimately evaluate to a number right and we're turning a number here that number is like the answer so what I'll do is I'll save it in a variable I'll just call it result and you know that this result is going to be the answer for Fibonacci of n so what I want to do is in my memo before I leave I want to store using the key of n I want to make the corresponding value this result again what I'm doing here is I'm making sure my memo Maps arguments of my method to their return values I know the answer for like FIB of n is this result and what you want to be sure to do is just complete the return value like before so I just want to return result so I'm still returning the same data as before I'm just additionally storing into a memo for later on and what's great is later on you know somewhere in your recursion when you encounter an N that you've seen before I mean you know that's going to happen in this problem because we you know demoed it in the approach video when you see an input and you want to evaluate an input and that you've seen before then you'll actually hit this base case on line 14. you're going to find that that argument is already in the memo and you're just going to return the stored value inside and that happens in constant time right because I know getting you know from a hash map is constant time so with that change let's go ahead and give this a test run really important thing to remember to do is be sure to pass your memo you know to your recursive calls over here that way you get that shared information across all of your recursive calls awesome and there we have it so by implementing this memoization strategy on top of our Brute Force we really improve the time complexity of this solution right like we said in the approach video now we're looking at an O of n runtime right space complexity is also going to be o of n because we have to store all of these calls on the call stack and even if we consider the size of our memo we know that our memo is just going to have a number of entries that could be at most equal to our input n right because I'm using my input n as the keys of my hash map and I know that keys are unique all right programmers so what I want you to do is take a moment really be sure to redo this problem and understand how we solved it in two steps right first I solve just the Brute Force recursion and then I apply my memoization on top of it this is going to be a really really important pattern moving forward we're going to scale it to solve some pretty interesting and difficult uh dynamic programming problems but I always follows this core pattern of solving a Brute Force recursion then additionally adding a memo hash map to it I'll do a variation of this in the next video I'll see you there hey programmers Alvin here right now I want to show you the approach for this Fibonacci problem and so I know you're thinking you know why is he having us do basically a ripoff of Fibonacci well I think it's really important that if you want to get good at these algorithm things then you have to have a certain level of repetition as the saying goes one is none right so even though you know we've just done another Fibonacci problem doesn't mean that it's completely something that we've mastered so if anything this should be a quick little review right of course I want you to solve this tribonacci problem uh recursively and so let's take a look at the sequence so here is a few numbers of the Fibonacci sequence all you'll notice is in this particular problem like before I want you to give me back a particular number of the sequence so imagine that we had corresponding indices for each of these numbers when it comes to the tribonacci sequence we're going to have three separate base cases right the zeroth number of the sequence is zero and also the first number of the sequence is zero and the second number of the sequence is one so with those three seed values we can come up with our general rule right just like before to calculate a number of the sequence or the next number of the sequence you just take the sum of the previous three numbers right or in general to calculate trip of n you do the sum of N minus one n minus two and N minus three and there you'll have your final answer right it's kind of jumping at a particular spot within the sequence if I took the sum of 4 plus 7 plus 13 that would give me exactly 24. so you should feel red at home in this particular problem so let's start to draw this one now I don't want to skip any steps and so before we start building this one let's have some foresight and figure out how to visualize a problem like this right and what's great about visualizing it is at least if we spend some time you know sketching out you know a structure of the problem like visually it can also help us figure out the complexity of this particular problem so right now I want to step through calculating the fifth number of the sequence which should be four in the long run so like before I'm going to represent an instance of this problem just with a tree and so my top level problem will be the root of this tree I want to find a trip of five and I know that I have to break this problem down into three sub problems right in other words I can generate three children by doing a minus one minus two and minus three respectively I'm just going to carry over that pattern for as many nodes as I can and of course whenever I hit like a base case I can't break that node down any further we know that when it comes to our tribonacci problem we have three separate base cases right representing these particular return values so I'm just going to plug in these sub results so I should have all of these calculated values right zeroth number is zero first number is zero and also the second number is one now I can start reconstructing my sub Solutions right so if I take a look at the particular uh to the left the three node I take the sum of its three children one plus zero plus zero gives me one right so the third Fibonacci number is one and I'll just continue this pattern right every parent node just takes the sum of its three children return values so I get values that look like this and finally at the root I just take the sum of two plus one plus one which gives me a final answer of 4 right very similar to our classic a fib problem so this would be a working solution basically just doing the same a recursive code except we're going to have three recursive calls which makes sense because every call we make corresponds to a branch that we have in this visual tree however what's the complexity of this one it's pretty pretty slow for the same reasons our Fibonacci code was slow before right so take a look at this particular tree I can derive the time complexity of it because I know that for my recursive code the time complexity is at least going to be the number of recursive calls that I make And if every recursive call corresponds to a note of this tree I have to figure out what the long term pattern for the number of nodes is in this recursion tree so I know that the height of this tree is pretty obvious looks like it's going to be along the order of N and how do I know that well if you look along the lefthand path it just goes five four three two and in general that's roughly N Things right now just think about how many nodes are across on every level at the top level there's one node and to get to the next level I multiply it by three I continue this pattern right as a tree gets bigger and bigger from one level to the next I would continue by tripling the number of nodes right very similar to our Fibonacci problem and so you guessed it the complexity of this is 3 to the N so an exponential but with a base of three right and it is a case that our space complexity is a pretty reasonable o of n right of course we're referring to the space complexity due to the call stack right and in general we can figure out the space complexity from the call stack if we draw out the tree and we can just look at the height of the tree the height of the tree being basically the number of levels and there's roughly you know four levels here so I guess it's off by one even though our input was five right so to make this one a little faster of course we can just notice any duplicate sub problems right so same story like we're used to look at this sub tree rooted in three I have this sub tree appearing here as well and so I want to avoid resolving that sub problem we're going to use the same scratch as before but this I want to use a different word to describe it really what we're utilizing here is dynamic programming so dynamic programming is really a type of problem solving where we utilize any overlapping sub problems right in other words I have this sub problem of calculating the third tribonacci number and if I can store that information the first time I solve that problem I can utilize it later on because I'm probably going to encounter that same sub problem all right so this is in the family of a dynamic programming strategies and so far we've been working with memoization so really memoization is just one way we can Implement dynamic programming and so if we use dynamic programming wisely we should be able to forego that duplicate subtree right and overall we'd be looking at an O of n runtime and O of n space complexity if we implemented that correctly right and so to implement that of course we're going to use some hash data structure to build that memo so for my python people you're going to use like a dictionary for my JavaScript people you're going to use an object for my Java people I'm going to use a hash map right any fast lookup data structure and at this point we have a pretty optimal solution for this tribonacci sequence right it should be able to run in a pretty decent time and so with that what I want you to do is I give this code a shot on your own but don't forget if you get stuck we do have a Code walkthrough available as well so give it a go now that we're done sketching out this tribonacci problem on our whiteboard what you want to do is head down to the links in description and click on the tribonacci link that way you can follow along and code up the Java solution with me hey programmers welcome back right now I want to go over the Java walkthrough for this Fibonacci problem so it's going to be another dynamic programming problem just to kind of ease us into the core pattern that I'm trying to teach you guys in this course and that'll help you solve almost any dynamic programming problem and so this is going to be a variation Alpha Fibonacci just called Fibonacci it's really the same pattern except to generate a further number of the sequence you need to use the sum of the previous three numbers and here I'll start with my base cases right I know the Fibonacci sequence has some different seed values we see that the zeroth and first numbers are both zero right so I'm going to actually just go ahead and jump right in here I'll start with that as my base case I'm going to solve this one for now with a Brute Force recursion so I'm going to check hey if my n is zero or my n is one well the 0 and 1 elements of the sequence how about zero so I return 0 in either case then additionally I need another base case if n is two I return the number one really just arbitrary values for this sequence here so if n equals two and return the value of one those would be my two base cases when it comes to creating the recursive case here you just take the sum of the last three numbers of the sequence so for me that's as simple as I take the tribonacci of n minus one and I add that to tribonacci of n minus 2. and also add a 2 triple Notch of n minus three cool so let's give that a test run this is a really important step never ever skip it right whenever you're solving a dynamic programming problem using memorization you ought to solve it Brute Force first and verify that your code is correct for me correct means that I always get a correct result for my method right a timeout is okay right eventually if we had more time all right to use up here you would be able to pass test k07 you will get the correct answer but this code is just far too slow as it is right so now that I've verified that okay this code is just a matter of speed right it's just slow I can add memoization on top of it so just like before for you and job I think the best way to solve this one the structure of code is to overload this method and your recursive method your brute force is now going to take in a new argument it's going to be a hash map and when it comes to how I set up the keys and values keys are going to be the arguments here method here I just have a single argument n so I'll make that an integer key the corresponding return value is going to also be an integer so it's going to have integer value I like to call it memo awesome from there in my main method you just want to delegate to your recursive Helper and you should pass in you know a new hash map instance here so at the top I should import the right thing here so I'll import Java util hash map and you can pass it in inline be sure instantiated here so new hash map awesome and now when it comes to my recipe for memorization I have the Brute Force I'll start by adding a base case that checks if my key or my input argument is already in the memo so I'll add over here along my base cases I'll say if my memo contains the key of n right and if it's there that means I would have also stored the value that is the answer for that input n I'm just going to return whatever that stored answer that stored value is I'll do memo dot get and in that case awesome so I have the logic that looks into my memory like my memo fetching logic now I need my memo insertion logic right so now I need to locate my recursive return value right this is where I return the final answer for n right this would be a number technically I'm going to store it to a variable call it result and before I leave and return the result I actually want to store that result into my memo so I actually do memo dot put and you should always use the key that's your current input argument right so this result is the answer for Fibonacci of n right because I'm returning it for a call to n and so n is going to be my key here right so I'll do n I'll make the value the result a very important design choice that we make when we solve our memoization this way is we're only going to memoize our current call right so in other words all of my memo keying happens with the argument n right I check if it contains n and if it doesn't then I put a new key of N I don't write any like awkward heavyhanded logic like doing memo dot put I try to Cache like n minus 1 with some subresult right that gets very very messy right because we're solving this recursively if we handle all of the memoization for our argument n then everything else will actually be memorized as well right because you know that for this particular call when we jump in and evaluate that call recursively this n minus one Whatever actual number that is that is an n in some other frame of reference right so you're only going to want to memorize to keep your code very clean adjust your current argument n right don't try to do any of like the the sub problems with the children here awesome and one final thing to do if I actually test this it's a very common mistake it won't actually be any faster that's because these calls are Fibonacci in my recursive case they need to actually refer to my overloaded method here which takes in my memo I obviously I want to share this memo hash map for the entire recursion tree here so I'm going to add that into the mix just pass along the memo and that should do the trick awesome and there we have it hey programmers Alvin here right now let's go over the approach for this some possible problem so this probably want to take in two arguments we're going to be given a amount as well as a array filled with numbers and we want to do is return true or false indicating whether or not we can use some numbers of the array to generate the amount by adding them together in this particular example I should return true because I can totally make 5 by adding up some numbers in the array there are a few different ways to do that I could have done two plus three or three plus one plus one we're also two plus one plus two and there are actually a whole bunch of other different ways you can sum up to five but since I have at least one way to generate five I'm going to return true so overall we're just looking for a Boolean return type for a function here it could be the case that based on the inputs we're given it might not be possible so if I gave you a Target amount of 15 and I gave you numbers to choose from like 6 4 and 10 that would actually be impossible so you should return false all right so how do we start attacking this one we'll step through an example where you want to generate a Target amount of four and we have numbers one two and three this should be a sufficiently large example to step through here my intuition tells me that smaller amounts are easier to calculate late than larger amounts so what I can do is try to shrink my amount as much as possible until I get to a trivially small amount for which I know the answer for so let's say I start with my amount of four what options do I have here well if I think about my first choice what I could do is take a one so this one is going to represent the first number I can choose right and what I can do from there is actually subtract that one from the four that would give me a new amount of three but still at the four note over there what I can do is also maybe consider taking a two if I do 4 minus 2 then my next minus 2. and the final option would be taking a 3. if I do 4 minus 3 that'd give me one and at this point I'm starting to shrink my problem size so inside of the nodes in blue we're going to have listed the amount that we're trying to break down and then the numbers in yellow on the edges represent the choice of numbers that we choose we're starting to shrink our problem size so let's say we took a look at the three note on the left we can break it down further right using my options of one two and three and that would yield two one and zero respectively if I take a look at this two note over here in the middle I have to watch out because I can only use some of my numbers for valid moves right in other words I can do two minus one or two minus two and that'll give me a one and zero respectively but what I should not do is 2 minus three right although I have a third option of doing a three that would be too large right now and that would actually bring me to a negative quantity so we're gonna need to watch out for that in our drawing as well as when we implement the code similarly for this right hand note of one I can only subtract one for it because using any of the other numbers would bring me to a negative quantity so I'll continue this pattern for all of our nodes until we can't break them down any further and this would be the complete tree really what we're describing is the decision tree for all of the options that we can possibly make right so although I'm saying tree here I'm really referring to the fact that we're breaking this problem down recursively we go ahead and implement this we're not going to have to build any like tree data structure but we're going to solve it using recursion right I use this tree as a way to actually understand all the options I can take so since we know that this tree visualizes the recursion or where can we locate the base case well that would really be just the leaves of this tree what we can do is recognize that we have a bunch of zero nodes over here and to me that would be a trivially small amount that I can always know the answer for so that's going to be my base case right in other words if someone gave me an amount of zero I'm just going to return true why does that make sense well I can always generate Zero by just taking no elements of the numbers array I can always return true regardless of what numbers you give me you can even give me no numbers and that'd be totally fine I can still generate Zero by taking none of those numbers and so what I'll do is jot down this return value above all of my zero nodes those are going to be my base cases right my base case calls and I know that if I see a single true anywhere in the tree then it should be possible to generate the amount obviously here we can't really go wrong and we have a lot of different ways to generate the amounts if you look within this tree not only do you know that there are a bunch of different ways to make our amounts of four but you can actually see what numbers you added to generate that amount for example if I look at this path this represents doing a one plus two plus one to generate four right I'm just adding the numbers that I have along the edges here so this tree tells you a lot of information and you can use it to solve a bunch of different variations of this problem so now let's start to look at how the values return here so given a parent note if it receives a true from any of its children then it's also going to return true so that would evaluate something like this until we get a true at the top as our final answer so far we've described The Brute Force way to calculate the answer here I think it's worth going through the complexity so here I have two arguments to my function if we say that a is the amount and N is the length of numbers you can see that the time complexity is going to be n to the a power so this is going to be exponential so we're doing here is putting n in the base of the exponent because we know given a node it's going to give at most n children because I have to Branch for every option of number in the numbers array and I'm putting a in the exponent because I know that the height of the tree is at worse going to be a you can easily see that in this particular example if you start at the root and just keep going to the left it goes four three two one zero which would mean that the height of the tree in the worst case is exactly a if I had to keep subtracting 1 from my node so overall I'm looking at an N to the a complexity which is an exponential and typically going to be too large to actually run for reasonably large inputs we talk about the space complexity it's just going to be o of a right now based on the heights of our tree right we know the height of the visual tree would give us the maximal stack depth so how can we do better well you should probably catch the drift by now take a look at this tree and notice if you see any duplicate work what I can notice here is I have some duplicate subtrees right I can see these sub trees rooted in two that are identical and even have smaller sub trees that are the same like the ones rooted in one and I know that if I have duplicate sub trees in this visual that means I'm trying to solve duplicate problems right if someone asks me is it possible to generate two for the first time then later on if someone asks me again I should have just memorized that answer right and so here we're going to use that memoization strategy just store some solutions and some cash that way I can fetch them later on if you implemented memoization like we've seen previously then you would be able to trim out some branches of this tree ending up with this smaller structure what would this memoized complexity be well we'll still say that a is the amount and N is the length of numbers what we did was actually remove the exponential nature of this problem now we'll say that the time complexity is O of a times n so it's no longer an exponent I'm simply multiplying them right so a still represents the number of levels within my tree right the height of the tree and then n represents the width of my tree right for every level I will have at most n nodes and it would still be the case that our space complexity is O of a we would still use a a stack frames on our call stack due to the recursion and in terms of storing our memo we know that's also going to be linear in a and when it comes to the hash map we use to store our memo the space complexity for that is still going to be o of a because we're just going to use every amount every possible amount as a key of that memo before I let you go let's step through an amount that would not be possible given some numbers so we'll step through a scenario that should return false so my amount is 15 and I have numbers of 4 6 and 10. if we attack this one the same way we'll start with 15 in the root and we'll subtract each option of number giving us 11 9 and 5 and I'm going to carry this over as much as I can until I can't reduce my amount anymore so the full tree will look like this the nodes highlighted in red are the nodes that I can't break down any further because it would bring me to a negative quantity so if I have any remaining quantities in those red nodes then I know that that would mean those quantities are not possible to be generated so those should be a base case that return false now I can evaluate my returns in the same way as usual right I just bubble these up to their parents a parent is going to return true only if one of its children calls also returned true but everyone here is false so I'll get false all the way back up the tree all right programmers I think that's all I got for this approach video what you want to do is possibly give this one a shot on your own see if you can translate our visual diagrams into some code and then if you got stuck you can find me in the walkthrough videos I'll see you there now that we're done drawing up are some possible solution what you want to do is head down to the links in description below where you can find the link to the some possible problem because we're going to code up the Java solution right now together hey programmers Alvin from structure here what I want to do is go over the Java walkthrough for the some possible problem so you definitely want to make sure you watch the approach video for this one this is going to be what I consider like our first like actually difficult uh dynamic programming problem and so those previous toy problems of like fib and Fibonacci those have all been building up to a problem like this right what I really want to emphasize is we kind of write the code for this is try to compare the process for solving it similar to how we solved Fibonacci and Fibonacci right meaning that we're going to start by solving just some Brute Force recursion check that it works check that it's correct it's probably going to be too slow and then we add our memoization on top of it right we're going to scale out the solution here and so let's Jump Right In and so to solve this one I know I need a Brute Force recursion and with any recursion I like to think about my base cases right so when it comes to my base cases I have to think about all right what are some like trivially small inputs for which I automatically know the answer like we said in the approach video The Great base case here is going to be if your amount is really small so if my amount is zero if your amount to zero then what you want to do is kind of give back a Boolean representing all right is it possible to add up numbers such that their sum is zero and that's always possible right you're going to always get a sum of Zero by adding no numbers together right that's trivially true and so I'm going to return true here so if you hit an amount of zero just return true awesome but from there I know I have some positive amount and I need to break it down smaller and smaller toward this base case and I know that to shrink the amount I must subtract some value from the numbers list so I'm going to start iterating through the possibilities here so I'm going to iterate through every int I'll say none within the numbers list and I know that I'm going to take my current amount and subtract it by this number so just for some clarity I'm going to label this variable as my sub amount right because it's my original amount just with some number reduced out of it awesome and now what I want to do is keep solving this problem recursively so now I want to figure out is it possible to have a sum that adds up to this sum amount and I have a method to do that it's the current method I'm writing right so I'm going to call some possible and check if the sub amount is possible Right the second argument to this recursive method should be the same argument right numbers you can reuse the numbers as much as you want so I can pass in the same numbers awesome but now recursively have to think about all right what does this give back well I know that it definitely gives back a Boolean and that Boolean represents whether or not it's possible to create these sub amount right if it is possible so if this comes back as true then I know that it must be possible to sum up to the entire full amount so I'm going to return true here and why does that logically make sense well if it's possible to make my sub amount right it must also be possible to make my full amounts because to make my full amount I can just add one additional number to it right because to get the sub amount in the first place I took out one valid choice of number but on the flip side if it's not possible so if this a recursive call returns false then you want to keep looking and consider if another choice of number would be possible right so something to watch out for is you don't want to write like a else return false right because you would exit too early right you only want to return true if you find a valid amount right the place you should return false is only after you're done checking every possible amount and you don't find one right so you want to write a late return false here all right if I don't find any uh sub amount that's possible and I checked all of them so after my for Loop then you can return false hey it must not be possible to create my amount awesome so this looks like my Brute Force solution but we are missing a one kind of glaring case we'll want to pay special attention to our subtraction on line 10. right based on what our amounts and number is we could get like a negative value for sub amount imagine my amount is two and maybe my number is five well if I do two minus five I get negative three and things will get kind of nasty from there because at that point I've already overshot my base case of zero and so you'd get increasingly more negative numbers right as your amount and so we never really want to let our amount become negative so I like to turn that into a base case so if my amount becomes negative and I can return false right it's not going to be possible to create a negative amount using a sum because they tell us in the problem that our numbers are all going to be positive right you can never generate a negative quantity by summing up positive numbers awesome so now I'll make sure we don't overshoot right we'll get just return false here that'll help us complete The Brute Force recursive here so let's give that a shot always want to make sure that it gets a correct answer and it just times out right so now I know that this is a great candidate for applying memoization right we know that like we said in the approach video this currently has an exponential run time so it's far too slow so to structure the optimize solution here I like to split up into my main method and my recursive method that also takes in a new argument which like we're used to from our last two problems right it should be a hash map cool the keys of the hashmap are just going to be the argument of My Method but it's only going to be the argument that changes right so if I look at the recursion here I know that amount is really the argument that changes over time right the numbers argument or the list of numbers doesn't change right so I know that that list of numbers in my recursion doesn't really dictate the result right because another changes I always return based on what the amount is and so I'm just going to make the integer amount my key right the corresponding value is going to be just the return type of your method so Boolean here I know that corresponds with you know the return values online like 20 and 24 and even in the base case awesome I'm going to call this my memo once again so let me go ahead and do some of the housekeeping here so I want to get the hashmap and when I I'm in my main method I'm just going to invoke my overloaded helper method give it the same amount give it the same numbers but you should give it a new hash map that's going to populate over time so it's nice and fast awesome at this point what I want to do now is add my base case to check hey maybe an input amount I've seen before right so I'm going to add as a base case here so if my memo contains a key that corresponds to the current amount I'm looking for I just want to return its stored value because I would have stored the answer there so return memo dot get amount all right very reminiscent of your Fibonacci and Fibonacci awesome other things I need to do is need to be sure to pass this memo by reference to all of my recursive calls and I know that there are actually multiple recursive calls here because on line 25 I have a recursive call and it's in a loop right so you make a recursive call for every num of the list I'm going to over here pass in the memo and now the only thing I'm missing is I need to find a way or find a location where I should add information into the memo right when do I put some keys and values into the memo like I said in the previous videos I always locate my recursive return values right so that would be line 26 and line 30 right to be safe you can memorize both of those return values right there's no points of memorizing your base case return values because those already occur in constant time right so there's no need to do it there so over here before I return true you want to store in your memo for the key of amount the same value would have returned right so if you return true then your stored value is true or if you return false then in that case your stored value is going to be false right and like we always say the key that you kind of refer to through your entire memo logic is going to be the argument amount right so I'm not writing any keys that have to do with the sub amounts to keep your code nice and clean you write about your current amount you're passed in right you know when you make your recursive call on the sub amount that will become its own like full amount and then it will get cached anyway in the memo so this should be good to go let's give this a test run see how we optimize our solution great and there we have it hey programmers Alvin here right now let's go over the approach for this Min change problem so in this problem we want to do is take in two things as input we're going to be given a Target amount as well as an array containing some coin values what we want to do is return the minimum number of coins required to create the amount so for example since my target amount is 5 one way I can give back five cents would be to do one plus one plus one plus one or I can do one plus two plus two or I could even do one plus one plus three and also two plus three in this problem what we want to do is choose the way that requires the least number of coins so that would be the two plus three that would use only two total coins and my function should just return that number of coins which would be two as my final answer all right so let's start attacking this one by visualizing it let's sketch out what we would do for an amount of four that way we can actually finish it because we're going to see that as we moderately increase the amount the size of our problem actually grows pretty large and so if you're doing all these problems in order and I always recommend that you do you should recognize this one as a dynamic programming problem so I'm going to try to do is shrink my problem size then also notice any overlapping sub problems in the long run and so I'm going to sketch things out as a tree what I'll do in the nodes of my tree is write down my current amount that I need to generate and I can break my current amount down into smaller sub amounts so let's say I start with 4 at my root to generate amount to 4 what I could do is use a one cent coin if I did that my remaining quantity would be three as my amount I could have also taken a 2 which case I need to generate two where I could have taken the three cent coin in which case my remaining amount would have been one so let's continue this pattern let's say I was at this three node this node would have three more children just branching for one cent two cents and three cent respectively if I take a look at this two note over here I can't actually use every option here I certainly Branch twice because if I took the three cent coin that would give me a remaining amount of negative one which I should probably avoid similarly for this note of one I can only Branch using the one cent coin so let's say we continue this pattern for the entire tree you would end up with this structure and what we see visually is the decision tree that represents every choice of a coin we can make until we hit zero and so this is a tree structure that we've seen a few times in the course what I'm going to argue is within the visual of this tree you should actually be able to recognize what the answer is for this amount of four so take a moment see if you can recognize any properties within this tree where can I find the answer to this problem what we should do is interpret each path of this tree so let's say I looked at this path that would represent the sum of one plus two plus one in other words I took a one cent coin and a two cent coin and then another one cent coin what I can say is that would represent the answer of three like a possible answer of three because I used three coins to generate my target amount of four that's only one possibility we know in this problem we really want the minimal a number of coins used so that should translate into one of these shortest paths like this one this would represent my sum of three plus one and that would have a length of two you could probably notice that there are a few other paths with a length of two that's okay we just want to return the smallest length possible which would be two and so what we're really recognizing here is the minimum number of coins required to generate our amount would really be the shortest path from the root to any Leaf within this tree assuming a leaf terminates at a zero so how can I do this more programmatically maybe we'll sketch this out as some recursion tree right so what I'll do is think of a return value for all of these zero nodes we can say is our base case if our amount is zero then I should return zero and so zero is a great choice because it's a small number and I can't break it down any further and I should also return 0 for that instance because the minimum number of coins required to make zero sense would be to use zero coins right just use no coins so above all of these base case nodes I'm going to jot down my result of zero and what I can do is start to evaluate these as return values so let's say I was at this node of 1 over here what I'll do is just receive Zero from my child call what I should also do is add 1 to it if I add one that would actually count the edge between myself and my child node because remember when it comes to counting the number of coins we're really counting the number of edges in a path through this visual tree so let's say I was at this two node now I was ready to evaluate it what I do is receive both of these values of 1 and 0 for my children and because I want the shortest path or the minimum number of coins my nodeans to choose a smaller between the two so I do one versus zero I pick the smaller one of zero but then what I need to do is actually increment that by one to count the edge between us and what that would represent this one designates the shortest way I can make two cents which would represent this path highlighted in pink let's continue this pattern so let's say I was at this one node the zero would just bubble up then I add one to it because there's no decision to make but now it can be at this three node this three node is going to receive three options it's going to choose the smallest among them so just zero but then it needs to add one to it and at this point I should be able to check for correctness I have a green number of one above my three node which means the minimum number of coins I need to make three cents would be just using one coin which makes perfect logical sense because I have a three available in my coins array so I could just take a single three cent coin let's continue this pattern elsewhere in the tree at the root note of four in this tree it's going to receive a bunch of ones technically it would choose the smallest among them which would be a tie given one and what I should do is always increment it by one to count the edge between myself and the children nodes and this too represents the fact that I have a few different paths that could only take two coins or two edges it could represent this path or this path or even this path so as we evaluated this tree something really important we did was whenever we received multiple values from our children so when we received multiple sub Solutions what I do is choose the smallest among them right I know I need some Min value logic present in this implementation because I want to choose the minimum number of coins possible so I'll just keep that in mind when we implement the code we talk about the complexity of this we've seen the structure before right now we're going to describe the Brute Force complexity if we say that c is the length of the coins array and a is the target amount then the time complexity is going to be exponential right we know that the branching factor of this tree is going to be based on the number of coins so C right branching Factor refers to given a node at most how many times will it yield children and I know what my ratchet Factor here is three and in the worst case I have three branches coming out of a single node my exponent here is going to be a because that would be the height of the tree we'll say that the space complexity is going to be o of a due to the call stack because if you look at the height of this tree it would be in the worst case a we say the worst case would be the scenario where I keep taking a bunch of one cent coins giving me the deepest recursion possible so if you start the root node here and you just keep going left you're going to see a sequence like four three two one zero and that definitely is a linear pattern in a so overall we're looking at an exponential runtime and a linear space complexity for this solution the time complexity definitely needs some work there right we want to bring it down from an exponential so like we usually do we just want to memorize this one we'll try to notice any duplicate sub problems so looking at this tree there are some duplicate sub trees I can notice I can see these sub trees rooted in two so instead of recalculating that subsolution I can save it and just reuse it so I can trim out that piece of the tree I also have other sub trees rooted in one and I can also ignore those right the way I'll implement this is by using some constant time data structure like a hash map I can store sub results as I compute them in that hash map and then reuse them later on if that high level strategy seems confusing don't worry you'll want to wait until the walkthrough video will actually show you the details on how to implement this in some code so let's do a reanalysis of this now we're going to analyze this dynamic programming solution that uses memoization the time complexity is just going to be a times C so it's no longer exponential it's really a sort of multilinear right just multiplying my two terms together we know that time complexity is going to be based on the number of recursive calls we make and in this visual diagram every node represents a recursive call we still have a tree of height a so that's where the a comes from what we're saying is across every level of this tree we have at most C nodes so I think of a as the height and C is the width that would give me a times C nodes overall it's actually pretty easy to spot in this particular example in the worst case scenario at a particular level we have only three nodes at most that's because our coin array only has three options inside of it the space complexity for a solution is just going to be o of a due to the call stack and we'd be storing at most a different keys inside of our memo hash map all right I think I'm ready to code this one up you want to join me in the walkthrough video now at this point we're done with the planning phase for our Min change solution what you want to do is head down to the links in description below where you can find the link to the Min change problem where you can code up the solution in Java with me hey programmers Alvin Constructor here what I want to do is go over the Java walk new for this Min change problem so you definitely want to make sure you watch the approach video first this is going to be another dynamic programming problem similar to our previous some possible problem like we said in the approach video what we want to do here is optimize for the number of coins that we take into our sum and so I'll Implement that strategy exactly what I want to do is start by laying out a base case we know that in this problem our base case should be about an input amount that is trivially small and for me the amount is going to be zero so I'm going to check if the current amount that I'm looking for is equal to zero then I want to return the answer for that amount of zero I want to return an integer representing the number of coins I need to create that amount so if someone asked you to generate zero cents what's the least number of coins you need to generate zero cents the answer there is zero coins so I'm just going to return zero then from there I want to start writing my recursive scenarios so I know that I need to take one of my choice of coins to reduce the amount so I'm going to iterate over all the possibilities so for me that means I'll iterate for every int coin within the coins list and what I'm going to do is I'm going to take the input amount and subtract this coin from it that smaller quantity that'll give me my sub amount we'll call it and from there I want to recursively find the minimum number of coins needed to make that sub amount so I can call my recursive method pass in that sub amount could pass in these same old coins in the problem they tell us that we can reuse a coin as many times as we need awesome but now from here I need to do some thinking I know that this method call should give me back a number representing the minimum number of coins needed to make the sub amount I'm going to save that number into a variable here just readability I'll call it sub coins because that's the number of coins needed to make the sub amount and I know I need to find the minimum subcoins for every choice of coin that I can take so I need to perform some Min value logic here you know generally A Min value logic means as we iterate over the possibilities we maintain some outer variable here I'll call it the mincoins I have to think about a good default value for it here well I know that in the context of the problem they tell us that all right if it's not possible to make the amount with the coins then you want to return negative one so I actually use that as an initial value here so I'm going to set this up as negative one and I know that after the foil at the end of my function if I never find a mount that works I'm going to return mint coins which should still be the negative one right but besides that what if it is possible to make the sub amount well if it's possible to make the sub amount that means that subcoins would be a nonnegative number right so I'm going to check if subcoins is not equal to negative one that means it was possible to make the sub amount since subcoins is the number of coins needed to make the sub amount if I do subcoins plus one that should be the number of coins needed to make the full amount and why do I know that this additional plus one here is counting the single coin I took to get the sub amount I'll save it to a variable called int num coins so this is the number of coins needed to make the full amount over here and now I could compare this against the mincoins variable right so I'm going to check hey if this number of coins is less than the mint coins well then I can replace the mint coins with this new number of coins right but it's pretty obvious here that when we initialize the mint coins to negative one this negative one may persist over any valid number of coins here right because negative one is already a negative quantity right so this negative one just acts like a placeholder right to represent an invalid quantity or the fact that we haven't found any valid number of coins yet and so if the number of coins is less than Min coins or the Mint coin still contains that default value then I can replace that default value with this number of coins right so I'm performing A Min value logic over my minimum coins so this code is looking pretty good one thing we need to be aware of is when we calculate this difference here we do a mount minus coin that could give us a negative amount right sub amount could be negative so if we call Min change with a negative number we already overshot the Space Case here so what I can do is just cache that with the base case so if ever my input amount is less than zero then what I want to do is return some value I'll return negative one here because again negative 1 in this problem represents the the fact that the amount cannot be generated with the coins we're given right you cannot generate a negative amount when all of the coins that you're given are positive so that's going to be a good extra base case there so let's give this a test one this should be our Brute Force solution for Min change if all is well we'll add some memo into it and make it a little faster so I'm getting an area it looks like I have a random typo current subcoins that should just be subcoins plus one right let's give that a test once again nice and this looks like our Brute Force solution we know that an algorithm like this so far has an exponential run time just like we said in the approach video so to speed this up I'm going to use our memoization strategy so like I always love to do I'm going to separate it into a main function and then a recursive helper right so my main over here will just call my recursive helper it's going to take in the amount as well as the coins but also my memo which will be a new hash map I'll be sure to take that hash map as an argument here so it's going to be a hash map and I have to think about what the keys of this hash map are going to be they should just be the argument that changes during the recursion which is the amount notice that the amount is the only ARG that changes coins stays the same so I don't need to add it as a key into my map here so I'll say my keys are going to be integer and then the corresponding values are going to be just the return type of this method which is also integer I'll call that memo got to be sure to import hashmap above looking pretty good and be sure to pass along that memo through the entire recursion now I need to add an additional base case right I need to check hey if the memo already contains the amount well then I've solved this sub problem before just return the stored value in the memo so I'll return memo dot get the amount awesome but if it's not then I'll go ahead and actually perform the true logic and calculate recursively of the answer right and I know that now I need to actually add data into the memo where I return the result so I look for the literal return line in my recursive case and it's only one return statement here in the recursive case that's line 35. so literally what I should do is I ought to save this into my memo so I can do memo dot put I'm going to use the input amount as my key always use the original argument make the corresponding value mincoins and you still need to complete the return value so like before still logically return mint coins you're just making sure you store it in the memo before you leave this recursive call nice so with that logic built around my Brute Force by adding the memo we should get a better run time here awesome there we have it here we start to really see the power of this strategy of first solving a Brute Force recursion and then applying our memoization trick right around it really the hardest part of a situation like this is to solve The Brute Force recursion in the first place right but that lets you focus on just the correct logic and then afterwards you speed up that logic using this additional data structure all right programmers that's all I got for this one why don't you do is practice this and I'll see you in the next one hey programmers I just want to take a little break from our dynamic programming material to tell you about structi Shruti is a complete data structures and algorithm course that you can use to prepare for all of your technical interviews it's actually the course you've been seeing me use throughout the video tutorials I'm going to be your teacher through the entire instructed curriculum and in the structure course we cover all of those essential interview topics like graphs trees dynamic programming and more and like you expect for every single problem like you've seen in this dynamic programming course we're going to support it with animations as well as code walkthroughs and you'll be able to code up all of these Solutions on the platform tester code in Java C plus plus JavaScript and python so if you're enjoying this dynamic programming material I recommend you head over to structure where you can practice things further whether it's dynamic programming or those other essential topics and of course you're going to be joining me for all of those video walkthroughs so I'll see you there without any further Ado let's hop back into our course hey programmers Alvin here right now let's go over the approach for this count paths problem so in this problem we're going to be given a grid what we want to do is travel from the top left corner down to the bottom right corner and here we want to return the number of ways that's possible to Traverse through this grid the caveat is we can only move to the right or downward that means we can go up and we can't go to the left and so for this particular grid let's talk about the different ways we can travel through it one way would be to go right right down another way would be to go right down right and finally the last way would be to go down right right and since there are three possible ways to travel through this grid we should just return the number of three so this should be a counting problem for us however this problem is a little more nuanced they say that some positions are going to be occupied by walls and we can't travel through them so if I had a wall like this in the top right corner then one way to travel to the grid would be right down right and the only other way would be downright right so let's Trace through the strategy for this one by looking at a larger example if I was given this 3x3 grid I'll also put a wall in the top right corner let's start by labeling the indices for our rows and columns we know that we start in the top left corner so that would mean row 0 column zero and what I want to start to do is try to give myself a way where I can denote every option I have right how can I Mark the decisions I can make by traveling through this grid so I'm going to visualize this one as a tree so if I start at position 0 0 I can make that the root of my tree if I'm at this position I'll think about my options that I have I can either move downward if I move downward that would increase my row by one but keep my column the same giving me one comma 0 or if I went to the right I keep my Row the same at 0 and I increase my column by one and that would be the only two options I have from this root position and I can just apply this logic recursively so let's say I was situated at the zero one node right now so I'm over here I know that my options are more limited now I can't move to the right because I have a wall in my way so I'm going to need to make sure I code that one up and I can only move downward here and that would mean increasing my row by one and keeping a column the same and so let's carry over this pattern to draw out the rest of this tree we know that given a node at most it's going to have two children representing my downward or rightward movement and that would mean either incrementing the row by exactly one or incrementing the column by one however we should not do that move if we go out of bounds or run into a wall so the full tree would look something like this what's great about this tree is if I start at the roots and travel to a leaf node that would represent one of the paths I can take through my grid in other words if I look at this path in my grid I can represent that using this path in my tree which is a really nice way to interpret this problem and so let's start to realize how we can encode the base case in this problem what you should be realizing is we're visualizing this as a tree which usually gives us a nice way to implement this as recursion right so if I've got all the leaf nodes here I always terminate at 2 comma two because that would represent the bottom right corner of my grid which is the goal and so if I'm at the bottom right position of 2 2 what should I do here well I have to think about the return value for my function here right they say they want a count and so what I should do is treat this to comma 2 position as if it's its own input so if someone asks me in how many ways can you get from the bottom right position to the bottom right position the answer would be one right there's only one way to do that that would be to just stay there right because you're already at your goal point and so I'm going to make all of these Leaf nodes or all these base cases return one now having these calls return one seems useful because I know I need to tally up a count in this problem so how do we start reconstructing our larger Solutions here well I would just really Bubble Up these ones right so let's slow down at this one comma one node over here we know that this node has a little more work to do because it's going to receive two values and so what I should do is bubble up both of these values right and then this note should just add them together so one plus one gives me two and so what are we saying here if I pause I should have some logical information in the subtree what it should be saying is that there are two ways to get from the position one comma one to the bottom right corner I have this path or I have this path there are two different ways to get from one one down to your bottom right corner so I'll just carry over this pattern keep reconstructing all of my Solutions and as we get toward the top of our tree we are going to get the final count of all of the ways to travel from the top left to the bottom right giving us our final answer of five what's great about visualizing this one as a tree is it really describes the decisions we can make as we travel through the grid right we know that this gives us a binary tree because for the most part when we're on the inside of the grid we only have two options right you can either move downward or to the right that'll help us decide the complexity of this Brute Force algorithm so if we implement this algorithm as it is just with some baseline recursion we say that R is the number of rows and sees a number of columns this will give us an exponential runtime meaning they're an exponential number of nodes in this tree really it's 2 to the r plus C power so the base of 2 comes from the fact that this is a binary tree and in the context of a problem that means I can only move downward to the right so you only have two options I'm saying that the height of this tree is R plus C right because you know you want to start in the top left corner 0 0 and travel to the bottom right corner what you have to do is actually Traverse a path that is exactly R plus C moves along right because you need to move through all of your rows and all of your columns for the same reason I can say that the space complexity is going to be R plus C just due to the stack depth right stack depth is equal to the height of this tree which we just said is roughly R plus C and so overall we shouldn't be too satisfied with the time complexity of this one right typically something exponential would be too slow for our liking and so what we should do is recognize that we actually have this visualized as a nice dynamic programming problem what you should do is take a moment look at our visual tree and notice if you can spot any duplicate sub problems right are there any overlapping sub problems here that I can memorize so we actually have a duplicate sub tree over here rooted in one comma one what I could do is just save the first time I calculated that way I don't have to fully recurse down my tree the second time around effectively memorizing my duplicate function calls which in the context is my tree visual just means that I prune out some branches there are some other subtrees here I can look at this two comma one subtree I can also memorize that away and we know as we grow the problem size in other words if someone gave me a larger and larger grid I would have more and more overlapping sub problems so I'd benefit more and more from memoization like usual for us the way we'll implement this is by using some hash map data structure I'll save that detail for the Code walkthrough though so what do we know about the new and improved complexity of this one right we're going to implement our dynamic programming using our classic memoization strategy so like usual R is the number of rows and C is a number of columns now would be the case that our time complexity is R times C right it's still the case that our time complexity is driven by the number of recursive calls we make and now we would be making roughly R times C different recursive calls right and how do I know that well in the context of what I'm going to memorize into my hatch map I'm going to put positions right notice that each node in this visual is a position of row and column and I know that there are exactly R times C different rows and columns so once I store a row and column into my memo I would never have to fully recompute it which gives me my time complexity of R times C likewise now is the case that my space complexities R times C taken mostly from the size of that memo right every position is going to be a key and so I have R times C different keys in my memo object all right programmers I'm sure itching to see how we actually implement this one in some code so right now you'll want to join me in the walkthrough videos I'll see you there now that we're done sketching out the solution behind this count pass problem what you want to do is head down to the links in description below where you can actually access the prompt and the test cases for this count pass problem and we'll code up the solution in Java together hey programmers Alvin from structure here what I want to do is go over the account pass problem in Java so like we said in the approach video we're going to frame this problem like a dynamic programming one this is going to be a little different compared to our very classic like graph like grid problems because in this problem you can only move rightward or downward that means that we can't get caught in any Cycles right so I don't have to do any visited logic or anything like that however what I will do is solve this one with a Brute Force recursion and then apply our memoization strategy on top of it to get a really fast dynamic programming optimized solution so to get the ball rolling on this one I know I need to start tracking like a current position as I Traverse uh through the grid so I'm going to split this one up into my main method as well as my helper and my helper is going to take in my current row and current column information and then in my main method I'll just pass control to my helper and I'll give it the starting point which is a top left corner which means row 0 column zero pass along the entire grid to reference then from here I'm going to structure this one as like a depth first recursive solution more or less so I'm going to start with the base case so what's my goal here well my goal is to find the bottom right corner of my grid so I can stop traversing if my row and column is the bottom right so be careful of the math here right to be in the bottom of most row that would mean that the row is equal to grid dot size minus one that means the bottom row similarly you want to check if the column is equal to the rightmost column so that would mean grid dot get 0 dot size minus one right so this is checking if I'm in the bottom right position then what do I want to do what I want to return overall the number of ways to reach the bottom right corner from this current position well if you're already in the Target position then you don't need to do anything so that's one way that you can get to the bottom right corner you just do nothing right because you're already there so I'll return one in this instance we have to think about some other scenarios right it could be the case that maybe my row and column is out of bounds so I want to avoid that and so I'll check very a very similar condition here I'm going to check if I'm out of bounds that would mean that my row is equal to grid size or my column is equal to grid.get0 dot size right notice that I'm turning this into an or right because if your row is too large or your column is too large well in the theater those are true or both of those are true then it's an invalid position so you're out of bounds right and if that's the case I still need to give a logical return value right I always want to have consistent return types so even in the space case if I'm out of bounds I want to return an integer and an integer needs to represent how many ways from this position I can travel to the bottom right corner well if you're out of bounds there's no possible way to ever get to the bottom right corner at that point so you want to return zero right there are zero ways to travel from an out of bounds position to the bottom right corner so I have my base cases looking pretty good but there's one more to capture here they also tell us that all right some positions of your grid are not open o stands for an open position if a grid position contains an X that's a wall that I cannot travel through so I'm going to actually add that into the mix here right it might be the case that if my grid dot get r dot get C so if my current position is equal to an X well then I can't Traverse through it right that's also a dead end kind of I like out of bounds so I'm similarly going to return zero awesome do note the important order of these two cases over here right I'm making sure that I only try to access like the innermost element of my a 2d grid after I check that the row and column are valid right I know that I'm using some valid RNC to get a position of my grid it's just that that position contains an X so these are all of my base cases here now I can start structuring my recursive case and I know that from any position that I'm at I have you know two options to take and those two options will turn into my two recursive calls right so I'm going to call account paths you could move downwards so you could move down a row keep the column the same but you can also move to the right so you can do count Paths of the same row but increase the column nice I have to think about what these two recursive calls return they return a number right this one on the left returns to me the number of ways I can get to the bottom right corner or get to the goal if I move downward this tells me the number of ways I can get to the goal if right now I move to the right if I take the sum of them that gives me the total ways I can get to the goal from this position because from this position you can only either move down or move to the right so this is looking like some core logic this looks like the shape of my brute force not much logic to it overall just some tricky edge cases here for my base case and so let me give this a test run I'm looking for some correct output so I'm passing some test cases but probably timing out for large inputs and there we see it so like I always love to do now I need to apply my memoization to it so I'm going to set that up you always want to use some fast lookup data structure to store your memo right and so for us use something like a hashmap and I'll pass along that hash map inline over here so new hash map and I'll take it as an argument and here where I design the hash map have to be a little more particular right so generally for the keys of my hashmap I always use the changing arguments into my recursive method here right so if I look at the arguments that change during my recursion it's the row and the column right the grid itself is always the same throughout the full recursion so I don't need to encode it into the keys of my hash map and so I really need to represent a row and column pair or like position as keys of my hash map because depending on their own column you get a different answer and so to actually store that key I'm going to use just a list of only two things of a row and column so it'll be a list of integer and I'll just guarantee that I'd make sure that those sub lists are always going to be of length two right just pairs of row and column and corresponding value is going to be the return type for my method which is just integer as well nice call this memo and now let's add our memo checking logic so pass these base cases what I like to do is form the key I'm going to use into my memo so create that key here it's going to be a list of integer let me just a pair I'll call it my position it's going to be just a list of the row and column nice and I can check hey if this position is in the memo so if memo dot contains key position and I can return the associated value with it because that means I've seen this not recursive call before so I can just instantly find the old result so return memo dot get position again the key trick here is I'm using this position because it contains the row and column arguments right so I'm using that entire entity as a key into my memo nice then from there like we're used to I should be sure to pass the memo to my calls here and whenever you see your recursive return value which is line 30 for me you want to store that result in your memo before you leave right so I'm just going to store this into an INT result be sure to put that in your memo so memo dot put this is uh put a key of position with the result and then just return the result nice so with those changes pretty classic changes to the previous problems that we've been doing except we're having a little more complex of a memo key here let's give that a shot awesome there's our solution for count paths hey programmers Alvin here right now let's go over the approach for this maxpath sum problem so in this problem we're going to be given a grid and we start in the top left corner and we want to make our way to the bottom right corner this grid is going to be populated with some numbers though we want to do here is return the path containing the maximal path sum in other words there are a few ways we can travel through this grid one way would be to use this path in which case there's sum would be 14. another way would be to use this path in which case your sum would be 12 and finally you can use this path in which case your sum would be 18. and between these three options I should choose the 18 right and so that would be the max path sum for this grid so let's cut to the Chase and describe the strategy for this one and we'll step through exactly this example so we'll label the row and columns and we also know that we start of course in the top left corner the SE are really just a spinoff of our last problem so hopefully you visualize this one as a tree right a binary tree because we only have two options at any point in time right you can either move downward or to the right and sometimes in just one of those directions depending on whether or not you're at the border of our grid right so we'll start at zero zero from this position I have two options if I went downward I would increase my row by one notice that each pair within a node here is a row and column or I could have moved to the right in which case I would be at zero comma one now to present my two moves let's say I was situated at this one comma zero node here I only have one move possible to make I must move to one comma one right that represents a move to the right if you look at my row and column indices that's because I can't go downward anymore because I'm already in the last row if I take a look at this position over here I do have two options right I can go downward or to the right giving me one comma one and zero comma two respectively we can build out the full tree from this point we know that we must terminate at position one comma two because that would be the bottom right corner so I know that that is our ending point right so that's going to be my base case I know in this problem I want to choose the maximal path sum so I want to Max some but how can I start accumulating a sum in the first place and so what you have to do is ask yourself if I'm already at the end position what is its Max path sum to the end position that would just be the value of 2 right that's exactly the number in that ending position so for my base cases I'm just going to return whatever number is in that final position then from here I know that these values are going to return so let's say we were situated at this one comma one node it's going to receive a value from its child call because we know we're visualizing this in a recursive way and what I should do here is note what position I'm at so 1 comma 1 would be this position containing a six I want to accumulate a sum here so I should do 2 plus 6 giving me eight so this node is going to return 8 to its parent so it's 8 it's going to Bubble up a little bit more if I think about this one comma zero node that represents my current value of 5 over in yellow and I would do my 8 plus 5 giving me 13. so that would be a partial path so far so we'll continue this process on our right hand side we know that these would just Bubble Up and we would add the respective values at those positions things came more interesting when we're at this zero comma one node though so for this note it's going to receive both 8 and 14 right it's just going to return back up like we always do and I have to make a decision here since I want the max path sum this node should choose the larger of those two values so 14 is bigger than 8. so I prefer the 14 here but I should also still add the value stored at my current position so if I look at position 0 1 within my grid that would be this value of 3. so I add 3 to the 14 giving me 17. finally this takes place again at the root so if I'm at 0 0 I'm going to receive the 13 and the 17 for my children I choose the bigger value of 17 and then I add my position itself which has a value of 1 inside that gives me a final answer of 18. so the way we reconstructed our sub Solutions into higher level Solutions was to choose the larger of our two children and then add ourselves to it that way I get some max value logic while also summing our path we talk about the Brute Force complexity of this algorithm we say that R is the number of rows and sees the number of columns then our time complex is going to be exponential just like we saw in the last problem the base of 2 comes from the fact that given any position we have two options right we can either go down or to the right and I make R plus C the exponent because that would be the height of this tree right that would be the length of any particular path I know any path that travels from the top left to the bottom right must cover all of the rows R and all of the columns C and so the entire path length would be R plus C in a similar way I'll say the space complexities R plus C due to the stack space required by this recursion right if the height of this tree is R plus C that means the stack space used by my recursion is also going to be R plus C but a keen Observer would know that I can do better because this is a dynamic programming problem so what I'll do is take a moment look at this tree see if you can find any overlapping sub problems and although this example was small I can already see some overlap if I look at this node rooted in one comma one I see it here and you also see it here I know the punch line is I should only have to calculate these nodes exactly once so I should be able to trim out a little bit of the tree by using some memoization and as we actually increase the size of our input as I get a larger and larger grid I would have more and more overlap that I'm able to kind of forego using some memoization like usual we're going to implement this using a hash map but I'll say those finer implementation details in the walkthrough video if we Implement memoization properly for this one we're going to bring our complexity down to linear right so we're going to have a Time complexity of R times C that's because there are R times C different nodes to actually cover now right I know I'm going to put the positions as the keys of my memo and there are R times C unique positions in a similar way it's now the case that my space complexity is taken over by the size of my memo which is also R times C because of the number of keys right I have R times C keys because I have R times C positions all right I think I'm ready to code this one up you'll want to join me in the walkthrough videos now hey programmers welcome back what I want to do right now is go over the Java walkthrough for this Max path sum problem so it's going to be a small variation of the previous you know grid dynamic programming problem except this time you want to find the maximum as we travel from the top left of our grid to the bottom right so I'm going to start by setting up the same initial structure so you'll want to track a position as you kind of Traverse through your grid and so I'm going to add additional arguments to this method so I'm going to track my current row as well as my current column nice and then from there what I want to do is start laying down my base cases right so for my base cases like you expect there are a few I need to check if I'm out of bounds so if my row is equal to grid dot size that means I'm just outside of the grid or maybe my column is equal to grid dot size or rather grid dot get zero dot size or I'm out of the column range right either case you want to return a sum integer right how can you represent an invalid integer meaning it's not possible to travel to the bottom right corner using this particular position well because I want to perform overall like a Max path logic or max value logic I know my logic is going to be preferring any larger integers and so whenever I encounter like an out of balance or invalid position I need to return some very small number right and so for me I think the best way to solve this one is going to be to use like a negative Infinity concept so in Java really your only choice for like a true negative Infinity is going to be in the double type so I'm going to say double dot negative Infinity which means I have to adjust some of my types here right so I guess I'm going to make this return a double that's totally fine I'll just be sure to cast it back in my main method here right so what am I saying well just so I can have access to like negative Infinity in my recursive over here in my main method it's going to call maxpath sum with the initial row initial column as well as the grid and I know that this is now defined to return a double you're going to get an error in Java if you try to return a double from an integer return method so I'm just going to cast into integer I'm just doing that really straightforward so I'm only going to convert at the very end which is fine all right so beyond that I need to just handle the case where I actually hit my Target in a base case so that'll be a similar condition right you want to check in English if you're in the bottom right position so if your row is the last row and your column is the last column and so you want to return some number here and overall you want to be adding up the values in your grid as you travel along them so in your base case you want to return an actual value you want to return the value of your current position so you want to return grid.get r dot get C so what am I really saying here so let's say that we're performing our recursion and we hit this base case meaning we're at the bottom right corner so that means I'm at this position what I'm going to do here is return the value at this position so I'm returning the value of one I'm going to return it because I need to eventually add up all the values along my winning path and the end goal is still part of my winning path here nice and so now that I have these base cases in line what I want to do is start forming my recursive case so I know I'm going to have two recursive calls right because at any position I have two options I can either go down or go to the right so I'm going to call maxpath sum going downward would be R plus 1 C grid and going to the right would be maxpath sum of the same row increase the column same old grid nice and here what I want to do is prefer the larger sub answer right because when I take a path through my grid you either go right or you go down right and I know that these recursive calls can be back a number they represent the sum of the a path if I travel through the right or if I travel downward and I want to choose whichever sub result is bigger right because right might give you a bigger sum or going down might be a bigger Sum It could only take one of them and so to choose just the maximal between these two numbers that I get back I'm just going to use the builtin math.max you can also write some conditional logic this is probably the easiest way to write this though so just choose the bigger value between these two methods but I should also be sure to add my current position into uh that answer right so I'm going to do grid dot get our dot get C add it into the bigger between my going down choice or my going rightward choice right this gives me the logic of summing up all the values along a particular path awesome so let's give this code a run this should be our Brute Force solution it looks like nice and if all is well we should start timing out and there we have it so let's improve the runtime of this one by adding in our memo so that's going to be a hashmap this is going to have us use a hash map where the keys are going to be positions right because the row and column is what determines the answer here because those are the arguments that change so I should have passed along a new hash map here and over here I'll Define the type so hash map keys are going to be positions so just kind of list pairs to integers corresponding value is going to be looks like double I'll call that memo so like we always do we want to add our memo checking logic as an additional base case so I'll start by forming the key first which is really just a position pair list of the row and column and then start by checking if it's in the memo so if memo contains the key of position then return its corresponding stored value so I'll return memo dot get position nice and then beyond that I need to be sure to pass along this memo so it's shared through the entire recursion so just pass it by reference here not a big deal and like I always say right the key is to now just find your recursive return value which is this thing over here you want to store it in your memo before you return right so this long expression just is a double it's like just a sum right so I'll save that as a result and this is going to be double how do I know it's double well it's obviously double because of this over here what I want to do is store it in my memo so memo dot put use your original arguments the original key here make the corresponding value the result and then like before still return the same old result the only additional step you took was to store it for a rainy day because I know later on if I ever encounter this position again I would hit this conditional and I can return that sub result in constant time which gives me a much better performance here give that a test run added our dynamic programming strategy there we have our very Snappy code hey programmers Alvin here right now let's go over the approach for this nonadjacent sum problem from this problem you're going to do is take in an array containing some numbers what you want to do is return the maximal sum of nonadjacent elements in this array so that means we can never take two numbers that are next to each other within the array for this particular input the answer should be 16 because the max nonadjacent sum would contain the 4 plus 12. here we should notice that we can't take a sum like 12 plus 7 because those two elements are adjacent within the array let's take a look at another example let's say I was given 7 5 5 and 12. in this particular scenario the output should be 19 representing the sum of 7 and 12 which is totally fine because they are nonadjacent in the array so let's come up with the strategy for this one we'll step through the example of 2 4 5 12 and 7. what I want to do is figure out a way I can come up with all the possibilities for numbers I take into my sum and numbers I exclude from my sum because we know that based on the numbers we take that would actually limit our options later on so let's say we started to encode this as a recursion tree right so I'm going to describe all the decisions that we could take as we come up with a sum for this problem so I'm going to start with my original array at the root what I have to do is come up with a decision right now let's say I was making a decision for the first element of this array so if I took 2 into my sum then I know my resulting elements I can choose from is really just 5 12 and 7. so notice how I did this left Branch over here right I'm writing 2 along the edge to represent that I'm taking 2 into the sum and notice how I make my array smaller in that left child I just have 5 12 and 7 because I cannot include 4 in that next call right because including four would actually mean that we're giving ourselves the opportunity to take an adjacent sum right if you take two right now then you can never ever take four so that's why I exclude it however at the root we could have also just not taken two altogether in which case when you look at your next subarray that would just be 4 5 12 and 7 right if I don't take the two that means I'm excluding it along the edge on the right hand side then I can totally give myself the opportunity to take four in the future so I'm going to include it in the next array so let's carry this pattern further let's say we looked at this left note over here what I have to do is always make a decision about the first element of this array so for the five note if I decide to take it what I can do is then look at the remaining elements of just seven right I don't pass 12 until the remaining subarray because if I take 5 I cannot take 12. however I could have also just not taken 5 altogether which case my remaining elements are just 12 and 7. so by now it should be clear how we generalize the steps here right given any particular array what I can do is either take the first element or not take the first element and that would decide what remaining elements I can choose from either slicing off one or two elements from the front of my array let's say we evaluated this node over here if I take 4 then I would give me a remainder of 12 and 7. if I don't take 4 then my remainder is 5 12 and 7. something interesting happens at the seven node right so in one scenario I can take the seven in which case I really just have an empty array left over right there's nothing else to choose for because that's my last element and the scenario that I don't take seven you would still have an empty array left over so notice how the seven node terminates and really two empty arrays finally we'll evaluate this 12 comma 7 node if I took the 12 then I would have an empty array because if I take the 12 you cannot take the 7 anymore and if I don't take the 12 well then I can totally take the 7 for my next decision at this point we would actually have a larger tree right there are still some nodes I need to evaluate here fully but what's great about this is I can actually notice that those are all duplicate nodes in other words I've noticed that this is a dynamic programming problem right if something has dynamic programming present in it then I should be able to recognize any overlapping sub problems in the context of this tree I just have to notice any duplicate nodes any duplicate subtrees I can notice a duplicate sub tree rooted in seven right so I don't need to reexplore the seven node again likewise I can notice a duplicate subtributed in 12 comma 7. there's even more than that I even have a very large subtree rooted in 5 12 and 7. and so I'm going to save a lot of complexity by saving some of these sub Solutions as I compute them so let's talk about how you can recompute our final answer from the problem now that we broke it down what we should notice is toward the bottom of our tree we're going to have leaves that represent empty arrays which does feel good because we know as our problem size gets smaller and smaller that would mean a smaller and smaller array right less and less numbers to choose from let's make our base case about the empty array in other words if someone gave me an empty array then the max nonadjacent sum would be zero right just take no elements of the array because you don't really have an option here so for all of these empty nodes or the empty arrays I'm going to have them return zero I know I'm going to make that a base case let's say we wanted to evaluate now at the seven node how will it use those sub Solutions well if I take a look at the left return value that's going to Bubble up but what I should also do is add the 7 along the edge right the yellow seven that represents the fact that I was taking and including 7 into that sum so I have a 7 on my left and for the right hand child that just bubbles up as it is right because I did not include seven for that particular sub problem and at this point I have this node choosing between seven and zero since I want the max nonadjacent sum I choose the larger between the two so I should return 7 in this instance so now let's evaluate this 12 comma 7 node since I just evaluated the seven node into its result I'm just going to jot down that answer here and I know I would Implement that probably using some memorization but as I carry on my return values here the lefthand0 is going to Bubble Up but I add the value along the edge because I was including 12 to that sum so I have 12 on my left and 7 on my right I choose a large between the two and I should return 12. which makes sense because if you think about it given just the small sub array of 12 comma 7 the Max on adjacent sum would be 12 right just choose 12. definitely don't choose 7 because that'd be smaller now that I've evaluated this 12 comma 7 node I know I can save this result for later on so I'm going to jot it down on that duplicate node over here now let's evaluate a little higher up we'll carry over the same logic as before so I return these values and I add the 5 along the left hand Edge giving me 12. at this point I choose the larger between 12 and 12. it's really a tie here so I'll just return 12. so I've just computed the subsolution for the array 5127 and I actually have a duplicate node on the right hand side so I'm going to jot that down if I evaluate this node now things Bubble Up along the left hand Edge I add a 4 giving me 16. so I do 16 versus 12. I choose a larger one which of course be 16. finally at the ultimate root I return these two values but the left hand Edge gets a plus two I choose a larger between 14 and 16 giving me my final answer of 16 which would be the correct answer let's talk about the complexity for this one so if you say that n is the length of the numbers what we could do is analyze the Brute Force complexity of this right so if you did not optimize this by trimming out some duplicate nodes in your sub tree you would have an exponential runtime in other words your time complexity is 2 to the n and your space complexity is just o of n we can say that the time complexity is 2 to the N here because for every node of this tree it's going to give at most two children right so in the worst case from one level of the tree to the next I double the number of nodes and I also know that the height of this tree is going to be n right the height of the tree is going to be n because in some scenario I could just keep removing the first elements of my array again and again and that means that the deepest recursion would require n stack frames on the call stack like we said we can optimize this with some dynamic programming with some memoization if you did things correctly here you would get a runtime of just o event so linear and a space complexity of also o of n one thing to note for this one is if you really want to get the linear runtime out of this problem you're going to have to figure out a clever way to actually represent a logical shrinkage of your array in other words if you look at the nodes of my tree I'm representing the array and I'm chopping off some elements of the array at any point in time what you don't want to do is create many copies of the array because I know creating a copy of an array would itself run in a linear time if you're creating a copy within every recursive call it's going to be pretty inefficient I will actually save that detail for the implementation video and so if you're wondering how to exactly Implement that pattern you'll want to join me in the walkthrough video I think let's hop to it hey programmers Alvin here what I want to do right now is go over the Java solution for this nonadjacent sum problem so like we said in the approach video to solve this one we're going to solve it using some recursive Brute Force algorithm then apply some amylization on top of it and so to get the ball rolling here I'm gonna need a way to give myself the ability to look at different pieces of my input list here I know at any point in time I want to shrink my input list smaller and smaller toward my base case and so to set up that structure I think it's good to have access to like a starting index so I'm going to overload the method name here I'm going to give it another argument I'll say int I and this will represent the starting index of the sub list that I'm considering for example if I is the number two that means I should be analyzing the list starting at index two so index two all the way through the end that means top level over here when I call my helper method I'll call nine adjacent sum given the same nums list and then initialize I to be zero because you want to start considering the full list starting index 0 going through the end this will help us avoid any slicing or creating copies of the list as we go giving us a faster solution and so to get the ball rolling on our Brute Force let's consider some base cases here and so I know I want to check a base case if my list that I'm considering is empty right so I'm gonna check for me a logical like empty linked list would mean that my index I is at the end or past the end of the list here so I'll check if I is greater than or equal to num's dot size notice that here I'm technically checking if I is out of bounds of the nums list because I know the last valid index of a list would be size minus one so if that's the case what I want to do is return 0. for what I'm trying to be consistent with the return type of this method which would be of type integer and zero is definitely an integer and I'm returning 0 because it represents an empty sum because I know overall in the context of this problem I want to maximize the sum that I take and so with that let me also start forming my recursive calls and these recursive calls should really mimic the logic that we express when we drew the approach video tree right so we have really two options here I'll kind of lay them out well what you could do is take the number at the front of your list so for me the front of my logical list would be the item at index I so if you took that number you could say nums.get I and you want to recursively add it to the sum of the remaining part of the list that you can take from if you take the element at position I and when you call nonjacent sum they'll give him the same nums list but you want to manipulate I obviously I want to increase I giving myself like a smaller a logical list what you want to do is pass in I plus 2 here and so it's pretty clear why we're not just passing in the same old I well for one we already took the element that index I into our sum and we're adding it to our recursive sum here we shouldn't pass in I plus 1 because that would be a number adjacent to I right and if we take I right now we know we can't take I plus 1 later on because the whole point of this problem is you can't take two elements that are adjacent in the list and so the earliest number we could take from there would be I Plus 2. and this is a very indicative of the logic we expressed when we drew the tree so that's only half of the pattern here could also be a scenario where I don't take my current element at index I and instead I just do nonadjacent sum of nums and then I pass in I plus 1 here right so now I do have the option of taking the element that's right after I nice and I know that these two variables over here are these two expressions they give me back a number right they represent a sum what I want to do is now work in my max value logic I want to choose the maximum answer between these two choices right the choices you make are either you take your element index I or you don't take your element in x i so I'm going to choose the maximum between them for me I could just use the builtin math.max just takes into arguments and Returns the bigger value between them and now that I'm choosing the maximum between these two quantities you just want to return whatever that maximum is so this code's looking pretty good let's give this a test run so far really short logic but we do want to optimize this in a moment so we're passing our initial test cases and we're timing out test case zero four so we're in good shape here we know that you know the problem like this does have an exponential runtime so it's too slow to run but I can add some memosization logic into the mix here to improve that so like we're always used to should know this formula by now I'm going to bring in the hash map I'm going to pass it into my recursive method here when it comes to the structure of this hashmap its keys are always going to be like the changing arguments to my recursor method so I'll pass in a hash map here for me the keys need to represent my integer's I right so I'll make the key type integer corresponding value is going to be the return type of the method which is also integer so this hashmap Maps integers to integers and let me add my base case to check if a key already exists in the memo and for me the key is really the argument I right so if the memo contains the key of I then just return the stored value because I would have stored the subsolution previously so return memo dot get I now on the flip side I have to locate my recursive return value which is this expression over here and I want to store it in the memo before I leave right so I'll just save this thing to a variable I'll call it result I'm still going to complete the return value that way we don't change any of the actual arithmetic in this evaluation but I do want to save this result so before I leave I'm going to do memo dot put use your argument I the plain old I as their key make the corresponding value the result and always be sure to pass along that memo by reference into your recursive method here does that mean right here pass along the memo so I have that shared data structure and so just by adding this layer on top of our Brute Force let's give that a test run we should get a much better run time here cool and there we have it hey programmers Allen here right now let's go over the approach for the summing squares problem so the first thing we'll want to do is review what a perfect square is you can create a perfect square by just taking some positive number and multiplying it by itself in other words I can do one times one to give me one two times two to give me four three by three to give me 9 and 4x4 to give me 16 and so on so in this problem we're going to take in a number as input and we want to do is figure out the minimum perfect squares that sum up to our Target number so for this input of 12 the least number of perfect squares I can use would be doing four plus four plus four notice that this is a valid perfect square sum because 4 is of course a perfect square another way that uses perfect squares to add up to 12 would be nine plus one plus one plus one however that would be a longer way right I want to use the minimum number of perfect squares and so here I should return the answer of three and the reason behind it is because I do 4 plus 4 plus 4 which is three perfect squares all right so how can we break down this problem let's step through the example as if our input was 10. we're going to start at 10 at my root and what I know I have to do is get this number to be smaller and smaller because decreasing the size of our input would mean an easier and easier problem to solve so what I have to do is subtract different perfect squares from this 10. so what I can do is subtract one that'll give me 9 or I could subtract 4 giving me six and finally I could subtract 9 giving me one notice that there are no other perfect squares to try the next perfect square would be 16 but that would be too large for my 10. so I don't need to go over it over here let's say I now wanted to expand this nine node I would get children like this again branching for every perfect square that I can take out of that quantity and so on and so forth if we look at the right hand side of my tree I actually just discovered a way to create my input of 10. in other words I can look at this path since this path terminates in a zero that must mean that we have just found a way to sum up perfect squares such that we get 10. if I look at the numbers along this path I'm really saying nine plus one so let's expand this five node as well as this two node and we'll build the full tree for the subtree rooted in six that would look something like this so you can probably foresee that this tree grows very quickly and so we're going to avoid drawing the left hand side of the tree although now we know the core pattern that we can use to generate it so if I look at this sub tray I have a few different paths that terminate at zero right I can look at this path which represents another way I can create my input of 10 but I should obviously prefer a shorter path right if I count the number of edges within a path that would tell me the number of perfect scores I use to accumulate that sum and obviously the shortest path we should return here is two because we're using a nine and a one let's go through how we can actually code this one up so as always if I have this visualized as a tree I should be able to frame it as some recursion so in my base case if my number my input is zero then what I should do is return zero zero is a great return value because what we're saying is to create zero you need to sum up zero different perfect squares so I'm going to plug in that return value for all these Leaf nodes and as I return these values to their parents what I have to do is add one to them always that way I can start counting the number of edges so if I look at the very bottom right now the zero returns then I add one to it then it returns upward add one to it and one more time to get over here notice that I have a three over the three now which means that I need three perfect squares to create three which makes sense because you have to do one plus one plus one let's say we return at this four node since this node is receiving two different values what it should do is choose these smaller between the two right because this problem is asking us for the least number of perfect squares so I need to minimize here so I should prefer the zero what I should also do is add one to it to count the edge and so what I'm saying right now is there must be only one perfect square that I need to get a quantity of four which makes sense because 4 itself is a perfect square so I should be able to notice any correctness even as I evaluate these sub trees so we'll take some time to evaluate this further until finally at the sixth node we get a result of three and this three represents a few different paths we can take that are of minimal length so I think by now you understand the logic we need to evaluate this tree this tree is going to be a little large so I won't step through the full example we can already foresee the complexity of this though right whenever I have a tree structure like this I'm describing all the different recursive calls that I make so if I'm able to figure out the number of nodes in this tree that would tell me the time complexity that stems from the recursion what I know is the height of this tree is definitely going to be n right because the longest path from the root to a zero would be just by taking a minus one again and again right so the height of this tree is going to be n when it comes to the branching factor it's actually Dynamic so given a node we know that we Branch for every perfect square that we can fit inside of it we know that given a node n there would be square root of n different perfect squares so that'll tell us our total complexity we'll say that the time complexity is going to be the square root of n raised to the nth power like usual the branching factor of our tree is going to be the base of that exponent in this problem the base is no longer two right we were dealing with a lot of problems we just have a base of 2. now we have a branching Factor that's based on the square root of that number so that's why we say we have square root of n raised to the nth power the exponent of n of course represents the number of levels in this tree or the height of the tree in a similar way the spacing Plex is just linear o of n because of the height of our tree we know that we're going to need at most n stack frames in our deepest call stack and like you could probably guess this is actually going to be framed as a dynamic programming problem right what we can do is notice some overlapping sub problems looking at our tree you can capture a few I'll just point out this duplicate 5 node and of course as we grew our input larger and larger you would have more and more overlap so if you do things properly here and you implement memoization to capture the dynamic programming nature of this problem which you should be able to do is bring it to some sort of a multilinear function overall your time complexity would be n times the square root of n interspacing Plexi would still be o of n I'm sure wondering exactly how we implement this one so maybe what you want to do is try to code it up on your own if you get stuck you can find me in the Code walkthrough I'll see you there hey programmers after construct be here what I want to do is go over the Java walkthrough for the summing squares problem so you definitely want to make sure you watch the approach video first and we'll Jump Right In Here we want to solve this one using a Brute Force recursion and apply some memoization on top of it so let's start with a base case here like we said in the approach video we know we want to deal with an input that's very small right for us we have integer inputs so we'll just check if our number n is equal to zero if our number n is equal to zero then we want to return zero because we know that generally our method should give us back the number representing the minimum the number of squares used to build up our n right if your n is zero that means you can use the empty sum right you can add up no perfect squares and you still get the correct answer of zero so that's the logic behind our base case here but now the recursive case is much trickier we know we want to have the logic of subtracting out some perfect squares from n that gives us a smaller and smaller argument so I'm going to give myself a loop that just iterates over some possible squares so what I can do here is I can iterate for it's I equals one and I'm starting at 1 because I know that one is the smallest perfect square right so I might as well start there I'm going to iterate up to I less than or equal to the square root of n and then hit every I in between I plus equals one cool that's because as I evaluate this Loop what I'm going to do is take my integer I am going to create a square number out of it a square is just the number multiplied by itself notice that on the last iteration of this for loop I know that I is going to be exactly the square root of n so when I do I times I I'm definitely going to get the full value of N and this could be the biggest number we ever subtract out of our argument n here nice and so with that out of the way we want to do is now build our recursive call so I'm going to call summing squares and I'm going to do n minus this choice of square that I have over here we know that this recursive call is going to give us back the minimum number of squares required to sum up to this quantity right I'll call that my int num squares however if I wanted to figure out the number of squares to build up for our argument n we need to add 1 to that sub quantity right that's because this one over here corresponds to the single Square I have on line 9. nice and then I know I need to find the minimal sum and so what I want to do is some Min value logic here so I'm going to do int I'll say Min squares and here it would be nice if I can use some like Infinity value because I want to do Min value logic overall and so unfortunately like integer type doesn't have a builtin infinity and so what I'll do is I'll actually create this as my recursive helper and so the main method will have the original signature but my recursive method I'll think I'll make it actually return double because then I can start defaulting these values over here right so for line 13 I can make this default to double dot positive Infinity and I get some safe comparison over here right so I can say things like hey if this number of squares is less than the Min squares and on the first iteration this is guaranteed to be true because Min square roots is positive Infinity then you can go ahead and replace them in squares with that value then after that full loop is done running like you expect we return whatever Min squares is and since we're storing positive Infinity in this variable over here this should be of course type double which means that now we're summing squares recursive method is returning a double which is totally fine however when we actually call this helper method in our main method here we know that this call to summing squares that's actually going to give us a double I want to just cast it into an INT like so I'll pass along the same end here do bear in mind that right now because these methods of summing squares although I want to overload them they will probably get a conflict here because they both take in the same types of arguments and the return type is kind of ambiguous here so just for now I'm going to rename the helper method I'll call it underscore or something Square so that represents my recursive helper method nice and so with that let's give this a run here I'm just getting a little reference here for the typing this should be positive in fin it t and while I'm here I also noticed that when I add one to the results of the recursive method here that of course gives me back a double and that's because the method returns a double I'm adding one to it which should still give a double let's give that a test run nice and this looks like our Brute Force recursion is starting to time out though on test case zero six so you know the drill at this point we have our Brute Force let's add our memosization into it so I'm going to start by importing the hashmap and I'll pass it along to my cursor method here so it'll be a new hash map I'll take in this argument here so hashmap keys are going to be just the numbers n so integer corresponding value right now is going to be double I'll call that my memo and we'll add a base case like we always do if our argument n is in the memo so if memo dot contains a key of n then return ammo.get and right return the stored value for it then I need to locate where I call My Method recursively which is over here be sure to share the memo and then whenever you do your return value in the recursion you want to store that result before you leave right so here I return Min squares I'll want to save that in a variable I'll say result equals mint squares I'm going to still return that same old result but before I leave I store it in memo so memo dot put use the original argument as the key right so I just use n here make resolve the value nice and so now that the overloaded version of this method has a different argument of hashmap it should be unambiguous now so I'm going to actually change the name here it's just a summing squares right it's easily to identify now because there's two arguments for the recursive version right only one argument for the main version here so let's give that a test run always solving these dynamic programming problems and layers great there we have it hey programmers Alvin here right now let's go over the approach for this counting change problem so this problem we're going to be given two arguments we're going to be given a Target amount as well as an array filled with some coin values what we want to do in this problem is return the number of ways that's possible to make the amount given the coins in the array and we can reuse the coin value as many times as we want and so for this particular example let's go through the ways we can make an amount of four one way would be to use just a bunch of one cent coins or you could do a three plus a one you can also do a two plus a two and finally you can use one two cent coin and then two one cent coins and so that means there are four distinct ways to generate our amount so let's Trace through an algorithm you can use to solve this one we'll start by structuring the different decisions we can make when it comes to building our amounts of four so I'm going to use four at the root and like we're used to let's go ahead and Branch for every coin value that we have available in other words what I could do is take a one cent coin in which case I reduce my target amount from four to three or I could take a two cent coin in which case I have two cents remaining or I could take a three cent coin in which case I have one cent remaining you've seen this pattern a few times in the course already if we built out the full tree we'd end up with a structure like this notice that we terminate wherever we have zero because that must mean we actually successfully built our Target amounts we know that a zero Leaf would represent one of the ways to create our mount looks like we have too many zeros here you're going to see that we have seven zeros but we said that there are only four ways to create our Target amount let's start by interpreting one of these paths so let's say I looked at this path this path will represent me taking coins one plus two plus one and if I look at another path like this one in pink this is represent the way of taking two plus one plus one if we look at those two paths they actually represent the same coins right I'm using a single two cent coin and then two one cent coins I just took them in a different order and that's why we have a high count right now we're actually counting duplicate ways and so I don't want to return seven although my tree says that I should really return four so actually structuring our tree like this is not going to be the way to solve this problem so what would be a better way well we can still use our tree structure so we're going to break this one down recursively but we want to build it in a way where we don't have any duplicate paths right and so what we'll do is starting at the root of our tree we're going to make a decision for just a single type of coin so at this top level of my tree I'm only writing a decision for my one cent coins and so for this coin with a value of one what I'm deciding on is how much of this coin to take so I could take zero one cent coins in which case my quantity that I'm targeting my target amount still stays at four or I could take a single one cent coin in which case my amount is now three if I take two one cent coins then now my amount is two and this would just carry further until I've exhausted all the possibilities for my differing quantities of one cent coins so notice here along the edges of my tree now I'm denoting the quantity of the coin I'm taking and at this first level I'm taking coin one what I can notice immediately is I already have a node that terminates at zero so this must mean that represents one way I can generate my amounts of four and what this path represents is really me taking four one cent coins and on the next level of the tree I'll wanna do is make the same decisions but for our two cent coins so let's say I wanted to expand this note of four what I do is Branch for different quantities for my coin value too so I can take zero two cent coins one two cent coins or two two cent coins and that would give me four two and zero as my reigning amount respectively so we're gonna need some more room here our tree's getting a little wide what I can do is notice this amount of one since I'm trying to decide how many two cent coins to take I actually can't take any two cent coins out of that amount so this darkened node basically is going to be a dead end so we can effectively ignore it that's going to be true throughout this tree whenever we have an amount that we can no longer shrink we actually don't need to expand that node anymore and so let's reorganize things over here now let's expand this node of three and again I'm branching for different quantities of two cent coins right so I can take a zero two cent coin or I can take just one two cent coin which case I result in amount of three and are amounts of one I'll carry this further for the other nodes at this level notice at this point we've just encountered more zero amounts which means they represent other ways to create our Target so so far we've counted three distinct ways to create our initial Target amounts of four finally at the bottom level we choose different quantities for our coin value of three notice that some of the leaves here don't terminate in a zero which means that they don't represent valid ways to make my initial amount what I can notice at the bottom level though is I have an additional zero this would actually give me all of the four different ways I can create my target amount so the key pattern here is we want to make sure that up front we choose different quantities for a single coin value before moving to the next coin value altogether what I don't want to do is flip back and forth between different coin values because then I would end up looking at duplicate ways if you think about how we have the tree structured now we have a very short tree right this tree's height is just going to be the length of the coins array because at every level of this tree I'm choosing for a different coin value so although my tree is very short I actually have now a very wide tree because now I'm iterating through differing quantities it's like you can probably foresee we can totally structure this problem like a dynamic programming problem meaning you could spot duplicate subtrees here let's take into account the shape of our tree to come up with the complexity of this so if we implement this wisely with some dynamic programming via some memoization we should end up with a time complexity that's a multilinear so just a times c and a space complexity that's also a times C we say that the time complexity is a times C because is a is the width of the tree and c is now the height of the tree and in general the number of nodes would be the height times the width the space complexity is also going to be a times C because of the different keys we're going to need to put inside of our memo hash map you're probably wondering exactly how we implement this and why the complexity is the way it is and to do that we're going to actually have to implement the code together so at this point you'll want to join me in the walkthrough videos I'll see you there hey programmers welcome back what I want to do right now is go over the Java walkthrough for this counting change problem so in this problem like we said it's going to be a variation of our you know coin changing problems and what we want to do is this time return a number of ways that we could generate our Target amounts like we said in the approach video the thing to watch out for here is to make sure that you don't count any duplicate ways and so the structure of this recurs is going to be a little bit different I'm going to need an additional argument into my recursive method here and so I'm going to Define it down below it's going to have mostly the same signature I'm still going to take in the amount as well as all the option of coins I'm also going to take in an index I'll call it coin index this is going to represent the index of the current coin I'm going to consider which means top level over here when I call my recursive method I'm going to give in the same old Target amount I'm going to give it an initial coin index of zero and of course pass along the original choice of coins here and so what I get to do now with this coin index is now vary the quantity that I'm going to take the coin of the given index like we said the approach video we want to count the number of ways to generate the amount so recursively I want to be reducing this amount over time toward my base case in other words once my target amount is zero I have to think about how many different ways can I give back zero cents and the answer there is one right there's exactly one way you can give back zero cents and that way is to do nothing right so this one represents me counting a valid way right there's one way to make zero sense good and then from there what I want to do is now iterate over the possibilities so I know that given this coin index if I use it to access some value out of the coins list I can do coins.get coin index and I'm going to create a variable to store it I'll call it int value so this is the value of the current coin I'm considering so if I take a look at the first example in the event that coin index is zero that means my value is one it's like a one cent coin in the case that my coin index is one that means the value I get is two what I want to do is take varying amounts of this coin value so I'm going to start iterating here and this Loop is going to be different from our previous coin prompts in that we want to iterate over a different quantity right so I'm going to say int quantity if I think about what the lowest quantity of a coin I can take is well the answer there is zero you could take no instances of a coin and I know I'm going to increase that quantity over time to go through the possibilities but I have to think about how far I need to go what I want to do is iterate this Loop while the quantity times value is less than or equal to the Target amount so here I'm checking that my quantity times value is less than or equal to the amount because I don't want to overshoot my amount so for example let's say that right now my coin index is 1 right so that means I'm looking at the element of 2 over here right if I do my quantity times the value I have to think about what's the most number of two cent coins I can take right now if my target amount is four right well in the first iteration this is going to be valid because I'm going to check if 0 times 2 is less than or equal to 4 right and that's true so I keep running the iterations I'm going to check if 1 times 2 is less than or equal to 4. that's still true then I check if 2 times 2 is less than or equal to 4 and that's still true but on the next iteration when my quantity is 3 I'm going to do my 3 times 2 which is 6 and that's no longer less than or equal to my target amount of four because I don't want to take out six cents for my target of 4 cents that'll give me a negative quantity right so this condition ensures that I only iterate up to a valid point here so what I want to do now is generate my sub amount so I can do my int sub amount and I'll make that equal to the original amount but just minus the quantity times the value right I'm reducing the amount by the number of coins that I'm taking then from there I have this reduced quantity I want to call recursively on Counting chain now given that sub amounts and because I just made a choice for how many instances of this coin index I'm going to take what I want to do is now move to the next coin so here's where I increment my coin index so coin in X plus one right notice that this for Loop is going to iterate through all the possibilities for my given coin index and once I make a choice of that coin index I can never go back to it and so that's why I increment my coin index in the next recursive call along with that I can pass along these same coins right that doesn't change awesome now I have to think about the logic of my my problem here I know that in the approach video I wanted to have the effect of taking a total right I wanted to add up the sum of all of the branches through my tree so I know that counting change is going to return an integer that integer represents all of the ways that I can generate these sub amount so what I want to do is take the grand total of that so I'll say int total ways equals zero and I'm going to add the results over here nice so I'm getting the grand total number of ways and after my for loop I just want to turn the total ways just a little type over here I should be saying total ways so this looks mostly good except I should consider also adding a base case regarding my coin index in other words what if it's the case that you actually exhaust all of your different options for your coin index but your amount is still not zero so let's say after this if statement if I get past this if statement I know my amount is not zero right I also want to check hey if my coin index has no other options in it in other words if my coin index is greater than or equal to coins dot size then I have no more options right I know the last valid index of coins is coins.size minus one so if coin index is equal to coins that size I know I don't have any more coins I can possibly take so if you hit this case you want to return zero right there's no possible ways to generate your amount from this point because you already chose all of your quantities for your different coin indices nice the order of these conditions is really important right because I have this if statement of line 13 after line 9 this is technically checking all right if my amount is not zero and my coin index is out of bounds right and I'm able to accomplish that logically by the order of these two conditionals so what the let's give this a test run this could be our initial Brute Force solution looks like we're going to timeout nice because we get that not so great exponential runtime here so like where you see we'll go ahead and memorize this right so I'm going to bring in my hashmap and I'll be sure to pass it in over here it's our new hashmap when it comes to designing the hash map over here I have to think about what the keys need to be as always the keys need to be the changing arguments through my recursive method and here it's actually interesting that two arguments change right my amount changes because I have some reduced sub amount that I'm passing along and also my coin index changes because from one call to the next it would be increasing the coin index and because those arguments change during the recursion those are the ones I want to encode into my hash keys right so my keys here will actually be a list of integer I'll just make sure that that sub list or those sub lists just contain a pair of a Mountain Coin Index right corresponding return value is going to be integer so integer will be the values of my map I'll call that my memo nice so what I'm saying is I'll enter the base case and I'll form my key I'll just say list of integer it's going to just be a list of the amounts followed by the coin index I'm going to use this entire pair as the keys in my memo so I'm going to check if my memo contains a key a key then I want to return its stored value so return memo dot get key because that means I've seen this is a problem before so I can return the previously saved subresult and now what I want to do is make sure I pass along this memo by reference through the entire recursion and also be sure to store your recursive return value into the memo before you leave so that would be line 31 here what I do is I can say memo dot put you always want to make the key for your stored value the original key that encodes the arguments right so a Mountain Coin index are part of my key here so I use that in my memo and I store the total ways then just be sure to return the old value so return total ways all the same right that shouldn't change so with this let's go and give this a test run we should now be using our memo to solve this dynamic programming problem quite quickly see what we get awesome and there we have it hey programmers so you've reached the end of a dynamic programming crash course but the learning doesn't stop here if you head over to structney.net you'll be able to practice some dynamic programming problems further we have a full module on dynamic programming a lot of the problems that you've covered not in this video series for free code cam but I have a lot more in store as well so whether you're looking to really hone in on your skills of dynamic programming or you want to cover and go through all the other topics we have featured on structi I recommend you head to structie.net you're going to have access to video tutorials as well as animations with me for every single problem I'll see you there
