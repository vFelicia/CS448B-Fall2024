With timestamps:

00:00 - I'm going to talk about the focus of our course
mastering Python for beginners in data science.
00:05 - So let me explain what kind of areas in this
particular course we are focusing the most.
00:13 - In fact, because this is a course, for beginners,
that's a beginner level course, we are not
00:20 - assuming the the course taker to have any
experience whatsoever about any computer programming
00:29 - language before, not even not even the problem,
problem solving paradigm that lies in computer
00:35 - science. So, we will, we will focus on problem
solving for a bit. And we will actually start
00:43 - from the very beginning what problem solving
is, particularly in computer science. The
00:49 - second focus of this particular course, is
mainly telling you why we are choosing Python,
00:55 - why Python is so important, particularly for
data science problems. The third focus and
01:02 - the main core focus is to learn Python, obviously,
once we know what is what what are the techniques
01:10 - to solve a problem. And once we know that
Python might be a very good language to go
01:15 - with, then what is Python, how to learn it?
Well, the Python is the main core and main
01:21 - focus of this course, obviously, we will start
from the very beginning, very, very beginning,
01:27 - which means we will start from how to install
Python for example, we will start from there,
01:33 - and then we will see what are variables, I
mean, very, very beginning, and then progressively
01:39 - we will be moving on and on and on to data
structures to complex structures, but that
01:45 - transition from 02 onwards, that transition
will be very, very smooth. I mean, whatever
01:52 - you know, so far, in the course, that will
be helping you to gain more complex structures
01:57 - very, very easily getting the understanding
of a lot of structures very, very easily.
02:01 - So in this Python, we will include all concepts
of Python in general. And, and one more thing,
02:11 - after I mean learning, despite on the way
we the way we organize this course of learning
02:17 - this Python, you will be having an understanding
of other languages as well. I mean, the contents
02:23 - here are explained in so general way all over
the Python syntax, but the general but but
02:30 - but the concepts are expressed in so general
way, the problems that we picked to solve
02:34 - for practice are so generic that you will
after this particular Python course, you will
02:40 - be having understanding of programming languages
in general. So data science is one other focus
02:47 - of this course, actually, the whole course
is organized in a way that it teaches you
02:56 - about Python, it teaches you problem solving,
it teaches you something about overall programming
03:02 - languages and how computer can be used to
achieve the solution of different problems.
03:08 - And and using Python, of course, and then
we will be introducing the data science packages
03:14 - that are available in Python, because they
are really, really fast, really fundamental,
03:19 - very easy to use, and very, very powerful
to handle large amount of data very quickly
03:24 - for data understanding for visualization,
for cleaning, processing, and a lot of stuff,
03:30 - what we are not focusing at because that's
important. Knowing that what kind of things
03:36 - are are are the things that we are not covering,
for example, we are not covering object oriented
03:41 - programming, we are not covering exception
handling, we are not doing web development,
03:47 - or any general kind of tasks that are doable
in Python, we are not focusing on those things.
03:54 - Everybody solves different problems every
day. Some problems are easy to solve, and
04:01 - some are difficult. And yet some are impossible
to solve. They are called unsolvable problems.
04:10 - But think about different instances of the
same problem one needs to solve again and
04:14 - again. For example, sorting the sale records.
And let's say we are sorting the sale records
04:23 - with respect to the sale value. And we have
to do it after every eight hours. If the number
04:31 - of instances if that number is huge, the optimal
choice is to automate the solution if the
04:38 - automation is possible, but how how to come
up with the automated solution to come up
04:46 - with a general solution that works for every
instance of some problem. That is one thing.
04:54 - But to get that solution running on a computer
is yet another thing
05:00 - Problem Solving deals with formalizing a general
solution for that works for every instance.
05:09 - And programming languages, like Python deals
with the running of that solution on a computer.
05:19 - Python, as, as we will see, makes the transition
from problem solving to the running solution
05:28 - much easier and quicker. And that's one big
plus of Python. A lot of words, I know a lot
05:38 - of words. Let me take an example to clarify
what I said, Hold on till the end of this
05:45 - video. And I will make everything what I said
so far, crystal clear. So let's take an example.
05:53 - Let's dive into an example to see what I just
said. Let's say your a, and your friend is
05:59 - B. And your friend B is always willing to
help you. Let's say you found such a friend.
06:10 - And then a just said, I want off just for
some days. But be said, but what ghobadi enjoy.
06:22 - He said, someone have to do my job in my absence.
And then be said, That's it? Is that your
06:33 - problem? I'm available? As always go buddy,
enjoy. Man. He said, great. You're a true
06:39 - friend. Okay, I'm leaving, wow. And be just
said, Hey, wait, what do I have to do? What's
06:50 - your job? At the end of the day, I'm going
to do your job. What's your job? What do you
06:55 - do? And then he said, after every eight hours,
pick the email of the customer when the maximum
07:03 - sales. So that's what you have to do. He said,
Okay. But from there, I mean, I have to pick
07:11 - that email of the customer from where, where
are the records? He said, Well, there are
07:17 - sales records. I mean, at the job place, there
are sales records. And you have to pick the
07:22 - email of the customer with maximum sales.
We said, Oh, okay. But wait, what, what should
07:29 - I do with the email that I just picked? Then
he said, oh, there is an other record called
07:36 - priority records, just write that email after
eight hours, just write that email in purity
07:42 - records. And then be said, that's it. That's
all your job. And he said, after so relaxed,
07:50 - he said, Yes, that's my job. That's all. No,
think he leaves and later that day receives
08:01 - a call from B. And B said, I don't really
know what to do. Can you tell me step by step?
08:10 - What to do? Focus on again, I'm reading this
particular sentence again. Can you tell me
08:19 - step by step what to do? I have sales records
with me having all the records for the last
08:27 - eight hours, what to do, I just messed everything
up. I don't know what to do. And then at the
08:34 - call, he just described a procedure to be
for his job. That procedure or a general solution,
08:46 - let's see the solution. He said number one,
start from the first record, there may be
08:53 - several columns of the record, the customer
name, the customer phone number, the customer
08:58 - email, the customer products that he buys
and the total sales. And in the point one
09:05 - said, he said, start from the first record,
and focus just on the sales column. Okay,
09:12 - then, then after that, go to each next record
one by one, and find the record with a maximum
09:19 - sales. Obviously, once you have focused on
the sales column, you're just comparing sales
09:26 - of different records with each other and will
eventually come up with a record that have
09:30 - maximum sales. Number three.
09:33 - If there are more than one records with maximum
sales, it is possible that the maximum sales
09:39 - value let's say is 100, whatever the units
are, and there may be two or three or maybe
09:45 - five records with the maximum sales 100. Then
which one to pick, as described here in Step
09:51 - three, that if there are more than one records
with maximum sales, then pick the first one
09:57 - from top to bottom and ignore the rest I mean,
whichever is the sole. So let's say you have
10:03 - five records with maximum sale value, which
record appears first from top to down, just
10:10 - pick that one and ignore the rest. That might
be a policy that might might be a tie breaking
10:15 - policy, but just do that. And then the fourth
step is focus on the email column of the record
10:23 - you found in step three. In Step three, you
found a column with maximum sales. Step five,
10:32 - see the email address and write that address
in the priority records. So that's for the
10:40 - eight hours, then repeat this process, see
the step six, then repeat this procedure,
10:46 - after every eight hours, I'm gonna repeat
this procedure, I mean, you'll see the the
10:52 - solution a is communicating to be in in this
in these kind of steps. It it gives me It
11:00 - gives a precise idea of what to do. Still,
there may be some, there may be some questions
11:06 - to be is maybe asking, for example, B may
ask how to find out a maximum, B might be
11:13 - that person who don't know how to find out
the maximum. And third, for example, another
11:19 - question we might may ask is that when when
I'm going to write the email address in the
11:24 - priority rock records, where should I write
at the very top or at the end or somewhere
11:30 - or, but at the end of the day, a solution
a step by step solution is required for communication,
11:39 - this kind of if you see the solution, although
it has some it may be explained in there may
11:44 - be more steps that should be added, but if
you see the solution, the step by step solution,
11:51 - this is a general solution. This is a general
solution, much more general solution for every
11:57 - instance, but every instance I mean, after
every eight hours, you will be having some
12:02 - records, and you have to do this procedure
on the records for that eight hours. And then
12:07 - after that, that after that eight hours, you
will be having more records to work on. So
12:12 - after every eight hours, you have the same,
the problem is the same, but the instance
12:17 - is different, because the records after eight
hours are different. But but the but the solution
12:22 - says whatever the instance you are right,
right now, whatever the instance is that you're
12:28 - in, just perform these, these steps, a step
by step solution, coming up with a step by
12:34 - step solution is is one module of the one
module of the problem solving. And there's
12:42 - step by step solution is called algorithm.
12:47 - algorithm. Obviously, the step by step solution
is not always required to be communicated
12:57 - in plain English or in natural language, you
may come up with shorthands or shortcuts to
13:04 - explain these step by step solution. So, the
the more shortcuts the more precise and unique
13:14 - meaning keywords you use in your step by step
solution, the more better communication of
13:20 - your solution takes place. And going from
this step by step solution, which is just
13:27 - in plain English, going from this to a more
concise and unique kind of procedure, that
13:39 - that can that kind of work that one step that
will take us from there to there, that we
13:44 - will see in the next video will be called
a pseudocode. And from that pseudocode there
13:49 - will be few steps that will take us to the
second major problem that the problem problem
13:55 - languages will solve the get the solution
running on a computer. So I'm just just in
14:02 - this video i i wanted to explain you that
solving a problem may not be that hard, I
14:09 - mean, coming up with a coming with coming
up with a solution of a problem may not be
14:13 - that hard, but communicating that solution
or, or writing that solution in a form of
14:19 - procedure that can solve every instance of
that problem that that requires a step by
14:27 - step treatment of the procedure. And those
those steps they should be linked in a sequence
14:34 - and they should be unambiguous. And if a particular
step requires more elaboration, that step
14:41 - might be broken down to further steps. But
that step by step solution at the end of the
14:45 - day is called algorithm. Now that algorithm
might be in English, but we will see in the
14:52 - later video that there are better ways of
expressing algorithms better than English
14:58 - or better than natural languages. So, so,
if you have another problem come up with a
15:05 - step by step solution of that, though, every
instance of that problem should be solved
15:09 - by that step by step solution, which is called
algorithm. And in the next video, we will
15:14 - see how to actually how to actually eliminate
the need of having English with us and how
15:23 - to incorporate the uniqueness of understanding
of these steps or algorithm using using the
15:31 - concepts of pseudocode. And after the pseudocode,
we will see it will be very quick to jump
15:36 - to any programming language and we will see
that the Python is very close to what humans
15:43 - generally think, I mean, it's very easy, the
transition will be very, very easy. So, hope
15:47 - to see you in the next video and I'll be explaining
algorithms in in, in a in a more kind of keyword
15:56 - way. And, and in the same video we'll be focusing
on pseudo codes which are basically pre step
16:05 - off of the actual core of any programming
language. So, hope to see you in the next
16:12 - video. Okay, in in the last video, we were
talking about the algorithm what an algorithm
16:18 - is and how to express that any any algorithm
and we saw that algorithm is just a step by
16:25 - step procedure. But, but how to express an
algorithm may vary, I mean, you need not always
16:33 - to have plain English to or any natural language
to express algorithm. The reason is that the
16:40 - natural languages are normally so expressive,
and each and every sentence they may have
16:46 - multiple meaning. So, it is it is a good idea
to come up with a structured way to express
16:51 - an algorithm such that each and every statement
is completely unambiguous. And one such way
16:57 - is is to express algorithms using flowcharts
flowcharts are our graphical ways of expressing
17:04 - algorithms. Here we are taking. The problem
here we are discussing is is computing PE
17:11 - of different employees of some company. And
the procedure of I mean, if there are several
17:16 - employees, let's employ one employee to employ
three and so on. Let's say there are several
17:22 - employees in a company and having each employee
has name, phone number, email and all the
17:31 - credentials. And then let's say the pay is
computed on hourly basis, and each employee
17:37 - has worked certain hours for example, eight
hours and each employee has an hourly rate
17:43 - might be let's say 100 units, whatever the
units are
17:48 - employed to might have worked for example,
seven hours, but the hourly rate of this employee
17:53 - might be 200 different employees, they might
have worked for different number of hours,
18:00 - and each employee can have a different hourly
rate depending upon the capacity of the employee
18:05 - or the or the job nature the employee is doing
and so on. So, so, so, if we want to compute
18:12 - pay of all employees, one by one, the procedure
of computing pay is stays the same, the instances
18:20 - they differ for employee one, the value of
our is eight the value of Raiders 100 for
18:26 - employee to the procedure will stay the same
the values of our end rate they will differ
18:32 - so what should be the procedure, the procedure
might be that you take the take the input
18:40 - of let's say employ one or whatever employee
you are going to compute salary for take the
18:47 - hours hours value in a in a placeholder call
that place or call that placeholder as ours
18:56 - placeholder or a variable y this is called
a variable because for different employers
19:01 - this value will different will be different,
ours will take value eight for each one employee
19:06 - one this this variable, this placeholder will
take value seven for employee two and so on.
19:14 - Similarly, once whatever employ whatever employ
for which you are going to compute the pay,
19:20 - if you have taken the hours from some records
from some working records, then take the rate
19:27 - for the same employer as well. So input this
that step one in Purdue that is step two,
19:33 - the steps the sequence of these two steps
may change for example, you take the you take
19:37 - the rate value first and ours value later
than that, but either way, that's one way
19:42 - of that's one way of expressing this this
procedure. And then you compute the pay by
19:50 - this formula. So hours multiplied by rate.
So maybe this is confusing writing a star.
19:58 - Maybe maybe We should write this cross symbol
because that is more common in mathematics.
20:04 - Or maybe this whole line can be replaced by,
by this particular line, maybe. So pay is
20:14 - equal to multiply hours. And rate. Maybe this
is more expressive, but it completely depends,
20:27 - I mean, when you start writing pseudocode,
or whatever pseudo codes you're writing, what
20:33 - kind of keywords begin is a keyword and is
a key word, what kind of keywords you're using,
20:40 - and stay with those keywords for example,
if the keyword input is to use to take to
20:46 - get the values to to process on then the input
should stay everywhere wherever we want to
20:53 - do such kind of operation. If you if you're
using for example, the value get rather than
20:59 - input then use get always but come up with
some set of keywords that are expressive,
21:06 - as well as concise and then take the sequence
of those statements, each and every statement
21:12 - should be should have a unique meaning, it
should not be ambiguous, and the sequence
21:17 - should be in the sequence describe the flow
of what is happening, what is going on. So,
21:24 - first we take hours, then we take rate these
two values for for for any kind of employee,
21:30 - and then we will just multiply them and after
multiplication, whatever the scene we want
21:35 - to make, based on this pay, we will do that,
we may we may record this value, display value
21:43 - at at some other records register, we may
we may print that value on a print slip, we
21:51 - may have emailed this value to some other
department or whatever to see and we want
21:55 - to make, but the procedure really is still
here, then based on pay whatever action we
22:02 - are going to do that that may differ. Similarly
if we go this is this is I mean, some kind
22:10 - of structured example of, of the, of the expressiveness
of an algorithm which is called pseudocode.
22:18 - And what kind of keywords you're going to
use, there are no general keywords, I mean,
22:24 - some people may use get some people may use
different kinds of keywords for it, but it
22:30 - is good to come up with a set of keywords
to to describe the describe the solution of
22:36 - the solution of the problem in flowchart for
example, everything every every statement
22:43 - here, that is here in in pseudocode every
statement is described as a shape different
22:50 - shapes for different kinds of statements.
If you want to take input, then you have to
22:55 - describe that action using a parallelogram.
If you're going to do some computation, you
23:00 - have to express that using a rectangle the
start symbol and end symbol the start and
23:07 - end of any procedure in flowcharts they are
described by the ovals For example, this oval
23:14 - in that oval normally the flowchart sequences
from top to down, but it is always good to
23:18 - just print the arrows to describe the flow,
because in complicated flowcharts there are
23:27 - there are loops there are if conditions there
are so many things. So it is good always to
23:32 - describe the flow using using arrows. So,
now the question is flowchart or pseudocode
23:40 - because flowchart also looks like a very cool
way of writing. expressing an algorithm and
23:48 - pseudocode is also a way of expressing an
algorithm. Well, converting flowchart to actual
23:55 - programming code is somewhat tedious, writing
a pseudocode beforehand, which is readable,
24:01 - which is precise, concise, as well as unambiguous
then converting that pseudocode to code of
24:11 - any programming language, that is not that
hard, that is simple in writing flowcharts
24:17 - for very complicated problems is somewhat
tedious, because then it It also requires
24:21 - another transition from flowchart to reactive
programming code. That's why writing pseudocode
24:27 - is more feasible, if the goal eventually is
to convert that pseudocode to some core of
24:32 - programming language. So, you can go with
flowcharts you can go with pseudocode either
24:38 - one is fine, but more feasible way of expressing
algorithms is a pseudocode. That was just
24:45 - a very simple example. I mean computing, computing
salary of an employee writing a procedure
24:50 - for that. I mean, this is so simple, nobody
make your writing that kind of writing solution.
24:59 - have this kind of problem as a as an algorithm
or as a pseudocode as a flowchart. But the
25:05 - basic idea is, is is is the same, even if
you have a complicated problem if even if
25:11 - you have a problem with maybe many more steps,
the idea is still the same. In the in the
25:17 - next video, we will we will see a procedure
how to how to make tea for example, that might
25:25 - that may look look to you funny, I mean, do
we really want do we really want to know the
25:31 - procedure to make tea? Well, the idea is not
to learn how to make tea, the idea is to learn
25:37 - how to express the solution of this problem
making tea that's a problem, the solution
25:44 - of this for how to how to express solution
of that problem as as a pseudocode. And we
25:49 - will see one more example of flowchart as
well. So hope to see you in the next video.
25:55 - Okay. In the last video, we saw flowcharts
and pseudocode, we just took an example of
26:02 - we took a very simple example computing salary
or pay of employee of a company given hours
26:10 - and rate. And I also described weatherflow,
the the comparison between flowchart and pseudocode.
26:16 - And I said that pseudocode is closer to the
core of some programming language, which eventually
26:22 - we need, because eventually we need automation
of of a solution of a problem. And for that,
26:29 - we need a code of the digit the code for the
solution, the general solution in some programming
26:36 - language, so flowchart and pseudocode, and
then the core of some programming language
26:43 - like Python,
26:45 - it is somehow in sometimes handy to to break
the problem or to devise a general solution
26:52 - of any problem for in first step in a flowchart
because that is more expressive, and more
26:59 - generic, more general, maybe in a graphical
way. And then once the proof of concept is
27:04 - clear, once it is clear that this is indeed
a general solution, it has no bugs inside
27:09 - it has no errors, it will work always, then
we can take another step to convert that flowchart
27:16 - to pseudocode. And then pseudocode can be
converted to the the code of any the code
27:23 - in some programming language. But writing
pseudocode right away, I mean, from the very
27:29 - beginning without flowcharts is also a common
practice. Either way, whichever way suits
27:34 - you. In this particular video, I'm going to
talk about problem the problem is making tea.
27:43 - You might be thinking, what are the different
instances of this problem I'm in making tea
27:47 - is making tea. What what kind of different
instances are there? Well, one person may
27:53 - be liking tea with, for example, 1.5 units
of sugar, whatever the units are, and another
28:03 - person may want a tea with, let's say, two
units of sugar, one person maybe, maybe needing
28:12 - a D with, for example, point five units of
milk, and another one, maybe a different units
28:17 - of milk, and so on. So the procedure of making
tea should stay same. And the instances which
28:24 - means the different people want tea in a different
kind of combination that may vary. So let's
28:31 - let's like let's see a procedure first and
flowchart. And then in pseudocode, for for
28:37 - making a tea, for making tea. So let's start
that that might look like that might look
28:43 - you look to you a kind of funny kind of problem.
But that's a genuine problem. For example,
28:50 - if you want to make tea, what is algorithm
for this? So first we start and then the first
28:59 - step we do is we put teabag in a cup, that
might be a first step. You can argue should
29:07 - this be a first step should that be the second
step and so on the sequence of By the way,
29:15 - solving one problem, you can have multiple
algorithms for that. And do different algorithms
29:21 - may just vary because of the sequence of statements
even if you have the same statements. So I'm
29:26 - not talking about that the algorithm or the
general solution is unique. You can have multiple
29:31 - different general solutions or procedures.
So for example, putting a teabag in a cup
29:37 - that might be first step, or the first step
might be the boil, boil the water and pour
29:42 - the water and pour the water in the cup and
then put the tea back. Both are fine, I mean
29:48 - this way or that way. So let's start with
putting a tea bag in a cup. So that's an that's
29:54 - an input. We take the tea bag from somewhere.
That's our input last time, I do You that
30:00 - input is taken as parallelograms put a teabag
in a cup and then forget about that cup and
30:09 - boil the water somewhere there is a water
I mean take the water from somewhere and boil
30:15 - it and see if after let's say five or six
or seven time units whatever the time units
30:23 - are, see if the water is boiled or not assume
that there is a test that tells you that the
30:29 - water is boiled or not. So, there is a test
available to you. So, you apply that test
30:34 - and check that the water is boiled or not
if it is not oil then keep on boiling. So
30:39 - boil it again. And assume there is a procedure
of boiling of water in in in normal case,
30:47 - boiling water is just happened by I mean keeping
the temperature high or putting that thing
30:54 - putting the pot of water on fire or something
like so, but that that itself is a procedure.
31:01 - So,
31:03 - while the water again and boil the water again
check if the water is boiled if no then boil
31:09 - it again. If not boil again then check if
no then boil it again this is called a loop
31:17 - this is called a loop or repetition you are
doing the same kind of stuff again and again.
31:22 - Until there is a particular condition that
is that is met. So in this case, the condition
31:27 - is when while the water is not boil, keep
on doing the same procedure again and again.
31:33 - This is called repetition or loop. So you
boil the water again, check the condition
31:40 - if the condition is true, for example, the
water boil Yes, then come out. Then you're
31:45 - then you can exit this loop and come out.
Then pour the water pour the water in in the
31:51 - cup. Here we should hear we should describe
that is that the same cup or a different cup?
31:57 - Well, this see you pick up here is acting
as as a placeholder where this tea bag and
32:06 - the water is going in. So we have a cup, we
put teabag in it, then we put the boil water
32:12 - in it, but before pouring the boiled water
in it. We just boiled the water. Okay, and
32:19 - then after we have water in a cup and a tea
bag in a cup, what should we do next? We actually
32:26 - we actually first test one sugar or need more
sugar? If yes, then then add sugar. So let's
32:37 - apply some arrows. If yes, add them add sugar.
And then again ask do you need do you need
32:45 - more sugar? Or one sugar now? Yes, add sugar.
One sugar. Yes, add sugar that is again a
32:54 - loop that is again a loop while while the
while you want sugar. I mean you test that
33:01 - the sugar is okay or not. Here you test that
the sugar is okay or not or whatever sugar
33:07 - you need. If Is that okay or not? Until that
condition is not met, you keep on adding the
33:13 - sugar, add a teaspoon again, then test out
a teaspoon that is again a loop or repetition.
33:20 - Once the condition is met once you know then
exit this loop and ask what milk because some
33:26 - people just take tea without milk. Maybe somebody
wants a milk maybe somebody don't. So want
33:34 - milk? Yes. So add milk. So that's that's a
mistake this this loop should go there. There
33:41 - right there. And this line shouldn't be there.
That's that's wrong. Add milk and then ask
33:50 - what milk? Yes, admin, that's again a loop.
Once you exit the loop, then you ask need
33:58 - to steer. Yes, steer, then ask again. This
line again shouldn't be there. So that that's
34:08 - another loop. Once you exit this loop, then
the T is ready, you serve that D finish you're
34:14 - done with the procedure. Now let's see the
same procedure in pseudocode program is the
34:20 - keyword and that's what program name is program
make D what is a keyword put teabag in a cup
34:29 - while water not while while is a key word,
while this is not while this condition is
34:38 - not satisfied, keep on doing this. Whatever
written in while and while is is the body
34:45 - of this repetition are called loop. So while
water is not boil, boil water. Then again
34:52 - check water boiler not know what again. I'm
in keep on boiling. So this is repetition.
35:00 - Once the water is boiled, which means this
condition is becomes false what not oil becomes
35:06 - false so water boil, then you exit this loop,
you pour that water in cup, that's again a
35:14 - key word, you in a cup, and then you ask,
okay, need sugar? Yes, add sugar, need sugar,
35:22 - yes, add sugar. So you keep on doing this
until you don't need sugar anymore. So, that's
35:30 - again a loop. So, so, you might be thinking
that why we are writing this add sugar and
35:37 - this boil water to writer to this this why
we are really indenting this that style of
35:45 - pseudocode to just display that this is inside
this this is this particular statement or
35:50 - set of statements are called the body of the
loop and this end Oil should be here in this
35:56 - alignment here in this line and so, there
is a there is a bug in this slide this should
36:01 - be
36:02 - here okay once this condition is false sugar
needed no then you can exit this loop and
36:09 - you go here while milk needed yes add milk,
check again milk needed yes add milk milk
36:17 - needed yes add milk. Once this condition becomes
false milk needed no then you can exit this
36:24 - loop, you can just go to here. While latest
here need to steer steer D need to steer yes
36:30 - sturdy he was there yesterday, once this condition
is false get out and your tea is ready Do
36:38 - whatever you want to do. This example was
so simple, but it expresses a very powerful
36:45 - tool in in the pseudocode as well as in flowcharts.
And that tool is sometimes called loop which
36:52 - is there to repeat a particular procedure
whatever procedure you want to repeat again
36:58 - and again to until there is a particular condition
that is met that is loop loop is there. So,
37:06 - the The purpose of this slide is was just
to just to make you make you convinced and
37:15 - make you comfortable with the pseudocode and
flowchart we will not be talking about flowcharts
37:22 - any further from here on we will we will be
just talking about pseudocode in just one
37:28 - or two more videos. And then we will be directly
going towards from we will be we will be comfortable
37:34 - enough with pseudocode for solving certain
kinds of problems that we will then eventually
37:39 - be moving from pseudocode to actual Python
code. And and I bet you I'm going to tell
37:45 - you that the pseudocode in the next video
I'm going to explain that will be very, very
37:51 - easily will be converted to the actual exact
Python code. So in the next video, we are
37:57 - going to actually solve a problem of finding
out minimum value from a list of values, sometimes
38:06 - called the searching problem, we're going
to solve it by first using pseudocode. And
38:11 - then in a later video, we will see how to
write the actual Python code for that problem.
38:17 - So hope to see you in the next video. Okay,
let's dive into real problem. Let's say you're
38:26 - given, you're given a list of numbers, let's
say, let's say l is some list. with numbers,
38:34 - let's say we define list by these, these square
brackets, let's say the list contains 23.
38:42 - Let's say that's a value minus four, that
value is zero, that's a value 73. That's a
38:48 - value, and maybe maybe minus 10. That's a
value, maybe 13. That's a value. So let's
38:56 - just take an example that we have 123456 values
in a list. So and that list is basically we
39:08 - took the list here as L and we just describe
that let's say the list is declared by or
39:16 - expressed by the square brackets, and the
elements of the list, they are separated by
39:21 - comma. That is just our convention for this
kind of problem for this problem just for
39:26 - this code. And And I'm not talking about any
particular programming language yet. This
39:33 - is just a list of numbers. And let's say we
want a procedure that finds out the minimum
39:42 - value of any list. Well, first of all, why
this problem has multiple instances. Well,
39:49 - we need to come up with a solution that works
for any list for example, if the list is if
39:56 - the list has these six values, then the procedure
should find out the minimum In this list,
40:01 - the minimum value in this list out of all
the values is minus 10.
40:06 - Because minus 10 is smaller than every other
value. 23 is bigger minus four is smaller
40:11 - than 23. Zero is bigger than minus four, because
the, the value with negative sign, it is smaller
40:20 - with the value of a positive sign. But if
you have two values with negative signs, the
40:27 - value with a bigger number, in terms of magnitude
is actually smaller in negative sense. So
40:32 - if you compare minus four and minus 10 minus
10 is smaller. In minus in minus domain, in
40:39 - positive domain, the result is different.
So I was talking about why this problem has
40:46 - multiple instances, why you need a general
solution for that, that's less just go and
40:51 - find out the minimum that is minus 10. Go
home happy? Well, we need a solution that
40:56 - works for another list. Another list with
different numbers. And maybe different number
41:02 - of numbers. Maybe in this list, we have six
numbers, another list may have 74 numbers,
41:06 - another list may have 1 trillion numbers,
we want to come up with a procedure that always
41:11 - finds out the minimum value in that list.
Obviously, the minimum value may repeat, I
41:20 - mean, the minimum value may occur more than
once in a list. So what is a minimum value
41:27 - rather than knowing how many times that occur,
what is the minimum value, that's a problem
41:31 - finding out a minimum value, and we want to
find out, we want to come up with a procedure
41:35 - that finds out the minimum value, regardless
of the list, whatever the list is, this procedure
41:41 - should actually return or end up finding out
the minimum value. So, in this particular
41:48 - case, again, for this particular example,
the minimum value is minus 10. And we will
41:52 - take example of this list, and we will see
how to code a procedure for that. So but but
41:59 - before starting this procedure, what kind
of things we really need to to, to write a
42:07 - pseudocode. For this kind of problem, we may
start by writing that program, like in the
42:14 - previous video, program name as search. And
then we take input or input list, then we
42:25 - take input, the number of values in the list
the total number of values, and then we move
42:33 - on as as we want to move on. But writing out
a procedure in terms of pseudocode, it is
42:40 - always good to to avoid these input statements
inside the pseudocode. And always supply whatever
42:47 - whatever needed, always supply the instance,
from outside and assume that the instance
42:54 - is supplied and then just work on that instance.
Rather than reading the instance. Rather than
42:59 - taking the values of instance, a particular
instance from inside the code, it is always
43:04 - a good practice to, to, to supply the instance
from outside, so supply the list from somewhere,
43:10 - and this n is really the size of the list.
In this particular case, let's say if this
43:15 - is the list, then that list will be there,
supplied from somewhere, but we'll see how
43:21 - to supply that. And this n value here, in
this particular case, the N value is six the
43:26 - total number of values in the list 12345,
and six, these are six values. So it is a
43:33 - good practice to rather than writing program
and then this, just write the name of the
43:40 - problem you're going to solve in this particular
case the name is search minimum from list.
43:45 - And then this particular we are talking about
this list l with total number of elements
43:51 - as n whatever the values inside the L is we
do not know and and this n may take different
43:59 - values, l can be different, this n can be
different for different instances. But it
44:05 - is not a good practice to take input from
inside here. Then, one more convention is
44:12 - that, let's say list of two represents the
second element in the list. In this particular
44:19 - case, L of two is basically L of two is basically
the second element in the list, which is minus
44:27 - four, L of let's say three is the third element
in this list, which is a zero, and so on.
44:37 - So let's let's take a convention, that whenever
we want to access the elements of the lists,
44:43 - whatever whenever you want to read the elements
from the list, we will read the element number
44:50 - by giving the element number here let's say
whatever the if we write L of AI, that means
44:57 - it means the ayat element of the list.
45:01 - So, first we take a variable, we are assuming
here that the list is supplied to us the total
45:11 - number of elements in the list is supplied
to us. So we first take the minimum value,
45:16 - we, which we really want to compute the minimum
value we want to compute, but any list can
45:22 - be supplied in this procedure. So what's the
procedure, the minimum value that we want
45:26 - to compute, we just consider the very first
value of the list in this case, the very first
45:31 - value is 23, we consider that is the minimum
value. Obviously, that is wrong, this is not
45:36 - minimum value, minimum value may be somewhere
else, or maybe this one may be somewhere else,
45:40 - but we are not sure that the first value in
the list is the minimum value. But let, let's
45:45 - just hold on for a moment and move on. Let's
say the minimum value is this here, this is
45:51 - called the assignment assignment. This min
value is a placeholder or a variable, and
46:02 - I have assigned this value l one to it. Now,
from here onwards, the min value will be will
46:10 - be will be having a value which is 23. In
this particular case, okay, so min value is
46:18 - this, which is 23. Now, let's declare, let's
declare another variable, which is called
46:25 - counter, we may need this counter. And let's
declare this with two, why we are declaring
46:30 - this with two it will become clear later on.
So now we so min Valley right now, for this
46:37 - particular list, the min value takes the value
23. So and counter takes the value two, these
46:44 - are two things for these two variables. Now,
we apply a loop while counter is smaller than
46:51 - n smaller equal to n. Remember the value of
n for this particular example is six, and
46:58 - counter here is two. So because counter has
value two, while two is less than or equal
47:04 - to six, first check whether this condition
is true or false, because if this condition
47:10 - is true, then you will go to the body of the
loop, then this whole box will execute. If
47:21 - this condition becomes false, then you will
exit the loop and we'll go out. So now counter
47:27 - is to the so two is smaller or equal to six.
true false. That is true. So the condition
47:36 - is to two is indeed smaller than or equal
to six, that is true. So we will go inside
47:41 - to the box and see what happens. Then what
we will do, we will pick and pick a value
47:48 - from at the index counter. Right now the counter
has value to L off counter means pick the
47:57 - value, because the counter has value to pick
the second value, which is minus four and
48:02 - pick that value minus four from the list,
pick that value and copy that value or assign
48:08 - that value to a variable v. That's a new variable
we maybe needed somewhere okay. Previously
48:15 - the min value which is a variable, it was
containing the very first value which is 23.
48:20 - Now we have picked the second value the counter
value is two. So we have picked the second
48:25 - value from the list, which is minus four.
Now we compare if the value now which is minus
48:32 - four is that value smaller than our minimum
value. So far, the minimum value so far is
48:41 - is 23. So minus four is smaller than 23. Yes,
the condition is true, if the condition is
48:50 - true, we will go into this block, otherwise
we will go into this block. So right now the
48:58 - condition is true. So we will go in this block
and minimum value will just be replaced by
49:03 - the new value. And the new value right now
is minus four. So because a minus four is
49:10 - smaller than 23, so we are here in this body,
the if condition becomes true, you're in this
49:17 - body, and the minimum value becomes whatever
the value is in V and right for this example,
49:24 - the value in V is minus four. Okay? So if
if if you go into the if condition, then you're
49:31 - not going into the else part, either you're
going to F part or in the else part one of
49:35 - them. Okay, so then we move back Oh, there's
a bug here we need to add the counter. We
49:44 - need to increment the counter here after after
this. Before this. There is another statement
49:50 - increment the counter. increment counter.
That's another statement increment counter.
49:59 - So Now increment the counter after this if
part increment the counter, and the counter
50:04 - will become three. Now, we will repeat the
procedure and check three is smaller than
50:09 - six, yes, we will go inside, and we will pick
now the counter value is three, we will go
50:15 - and pick the third entry. And now the third
entry will be in V, the V will now contain
50:21 - zero. Previously it contained minus four now
it will contain zero min value is containing
50:28 - minus four now, so zero is smaller than minus
four, no, if zero is smaller than minus four,
50:36 - then do this. But zero is not smaller than
minus four, then go to the else part. And
50:40 - as far as just saying just go on do nothing,
I mean don't do anything. So when you're here
50:47 - don't do anything except if condition increment
the counter again. Now, you increment the
50:52 - counter the counter value will become four
and the value add for is 73. First of all
50:58 - check for is smaller equal to six Yes, we
will contain the value at index four which
51:04 - is 7373 is smaller than minus four no do nothing
and given the counter check the if condition
51:13 - check the while condition now counter will
be five five is smaller or equal to six Yes,
51:18 - pick the fifth entry because country's fifth
the fifth entry is minus 10
51:24 - minus 10 is smaller than minus four yes okay.
Replace min value with the new value. Now
51:31 - the min value will contain minus 10 okay because
if has executed else will not execute, you
51:37 - exit the if condition and then you increment
the counter the counter will become six. Now
51:42 - six is smaller equal to six Yes, because six
is equal to six hence the condition is true.
51:49 - Now, you go and pick the sixth entry which
is 13. Check 13 is smaller than minus 10 because
51:57 - min value is containing minus 10. So far,
no that is false go to else condition, the
52:02 - two else part just go on to nothing, increment
the counter, now the counter will become seven
52:08 - and you go back and check the condition seven
is smaller equal to six false exit the loop.
52:14 - Okay, exit the loop, go to this condition,
go to this statement. Now Now you're out of
52:20 - the loop and return the min value. And see
the min value here is containing the actual
52:25 - min value which is minus 10. So that's how
we search the minimum, this return is also
52:33 - a keyword. So which means if we if we just
if we just if we just use that function, if
52:40 - we if we just use that pseudocode with if
we just use that pseudocode for this different
52:46 - kind of lists with with its sizes, whatever
the list, this is this was just one example
52:51 - if we chain the list, the procedure will work
one one bug in in the code was the increment
52:59 - counter statement was not there, it should
be there after the end F and before this end
53:05 - while here. So this that was the pseudocode
of searching a minimum. In the next video
53:11 - we are going to use this pseudocode and we
will we will see how to rearrange the values
53:18 - of a list or sorting the values of lists such
that all the values that are smaller they
53:23 - become earlier than the bigger values. And
the problem is called sorting. So in the in
53:30 - the next video we are going to talk about
one more problem, very famous problem called
53:36 - the sorting problem. And after that problem,
we will be going towards Python. Because after
53:43 - that problem, you will be having a fairly
good idea how to solve a problem how to write
53:48 - a pseudocode for a problem. And the way we
are writing the pseudocode is very close to
53:52 - the actual Python code which will become so
clear to you. So hope to see you in the next
53:58 - video. Okay, in the last video we talked about
we talked about this how to find out minimum
54:03 - value from a list of values. And we came up
with an algorithm with name search men from
54:10 - list. Here we have just made a little modification
that rather than just returning the minimum
54:18 - value, we are also returning the position
of the minimum value in the list. So for example,
54:24 - if the list is 17024, let's say in nine letter
that's our list. There are seven numbers in
54:35 - the list, the minimum value is zero. so the
value the minimum value itself is zero, but
54:42 - that appears in position three. So when when
this procedure will end, the min value will
54:49 - contain zero and the ID x which is the position
at which the value the minimum value was achieved
54:58 - that will contain three So, not only we are
not only we are finding out the minimum value,
55:04 - but also we are finding out the position of
the minimum value.
55:08 - This procedure, our pseudocode actually describes
a very simple, very simple concept, you consider
55:16 - the very first value as a minimum value and
the very first position as a position of the
55:20 - minimum value, and then traverse the list
element by element and, and see if you find
55:27 - any value that is smaller than the minimum
value so far, if that is found, then replace
55:34 - your minimum value with the new minimum value
and update your position number. And then
55:40 - keep on moving till the end of the list. So,
so that's what, that's the concept behind
55:46 - the behind this algorithm searching minimum
from the list. And to traverse the list we
55:52 - use this loop while loop. So next we solve
a problem called sorting problem very, very
55:58 - famous problem in computer science. So the
problem really is let's say we have a list,
56:05 - let's say 14035. And seven, let's say and
the sorted order the ascending sorted order
56:15 - is the order in which the list is presented
so that the minimum value occurs first, then
56:22 - the second minimum, then the third minimum,
and so on. So the sorted order for this particular
56:26 - list will be this, so this is the result,
this should be the result of this sorting
56:32 - procedure. So let's see how can we solve this
problem, we named this algorithm as sorted
56:39 - list and sorted list contains this L. In this
particular case, the L is simply this. And
56:48 - this n is the size of the list. In this particular
case, the size of the list is six, so six,
56:55 - and right now l two is empty. So although
we have to populate l two, but right now it
57:00 - is empty. And counter again, we initialize
the counter with one. And as as long as the
57:06 - Conqueror is smaller than six, we keep on
we keep on moving inside this, this block,
57:16 - that's the that's the body of the loop. So
what we do is we pass the list and the size
57:21 - of the list. And we use the previous algorithm
to find out the minimum from the list. So
57:28 - the minimum from the list will be found as
zero and its position will be found as three.
57:33 - So min value will contain zero, and Id x will
contain three, then what we do, we pick this
57:39 - minimum value and insert in L two l two was
initially empty. So we insert in L two, we
57:46 - insert the minimum value, which is zero so
far. And then just in the original list l
57:52 - we delete the value at the position index.
So for example, the index position is three,
57:59 - so we delete this particular value. So what
we really do is we delete this value, we delete
58:05 - this particular value. And the list now becomes
with size 1234 and five, so what we do is
58:11 - we decrement the size with with one and then
we move on now the country is one again, the
58:18 - N value rather than six. Now the N value is
five, so one is smaller than five, but the
58:23 - list has no zero now in it because it was
deleted, we searched the minimum again, and
58:29 - we insert the minimum in the list. Now the
minimum will be one in the new list. And we
58:34 - delete that value from the list. And we decrement
the size we keep on moving, eventually the
58:40 - list l two will be populated like so. And
once. And once this value of n becomes negative,
58:49 - which is minus one with we will exit the loop
and we will return the sorted list. But see
58:55 - how this sorting procedure actually uses the
algorithm that we that we defined in in RPB
59:02 - previous video.
59:04 - I'm not talking about that this kind of sorting
algorithm is the most famous sorting algorithm.
59:09 - There are efficient algorithms very great
kind of algorithms for sorting. But the idea
59:15 - here is not to actually teach sorting the
idea here to actually come up with the pseudocode
59:22 - for this sorting problem. And also to show
you how you can use the pseudocode how you
59:28 - can use existing pseudo cores as as instructions
in in other pseudo codes. So that's all about
59:35 - problem solving. If you really understand
the selection sort and all that procedure
59:40 - really well, you're actually very good in
problem solving, at least the problem solving
59:45 - is that we encounter in the logic that we
need to solve different kinds of problems
59:50 - in computer science. In the next video, I'm
going to actually convert these pseudo codes
59:57 - to Python codes. What do you need? Doo doo
doo, right this sortlist procedure in actual
60:04 - python programming language, and how will
you change the search minimum from list in
60:10 - actual python programming language, we will
see the Python details bit by bit in detail,
60:16 - starting from right zero and ending at the
very high details of Python. So, in the next
60:23 - video, I will just be showing you how to convert
this code. But when we will start learning
60:26 - Python, we will start from zero and we will
see each and everything of, of Python in in
60:32 - detail. So don't worry. In the next video,
if you see, I mean, things like lengthy chords
60:41 - in a very beginning, these are just because
we have arrived at a pseudo code. It is very,
60:46 - I'm just want to show you how the pseudo codes
which are very across expressible, how they
60:53 - can be easily converted to Python programming,
just to show you the power of and simplicity
60:59 - of Python programming language. So in the
next video, I'll be converting these pseudo
61:03 - codes to Python code actual programming code.
So hope to see you in the in the next video.
61:09 - Okay, in the previous video, we just get a
flavor of problem solving by using this selection
61:16 - sort called the sorting procedure. The idea
was just to use this procedure to solve this
61:24 - kind of problem. And we saw in detail, not
in that detail, we just just brushed up but
61:30 - we saw how to write a pseudocode for solving
a problem of sorting, which requires actually
61:36 - a list to be sorting in ascending order. For
example, in this video, I'm going to convert
61:42 - first this code search minimum from list,
you see that code, you know that code completely,
61:47 - we're first going to convert that code in
Python code, and then we will convert this
61:51 - code in Python code. So see step by step,
what changes are there. First of all, in Python
61:57 - that we will see in detail. When you define
procedures, different kinds of procedures,
62:03 - they are called functions in Python. And rather
than writing this, we have to write a def
62:10 - statement before it and then whatever name
we want to write out, the rest of the thing
62:14 - stays the same, except at the very end, we
have to write a colon. That's the syntax of
62:19 - Python. So the changes from here to here is
a def statement, which defines that is used
62:27 - for defining def for define. And then at the
end, we write a colon. Next thing that we
62:33 - will see in detail, don't worry if you
62:36 - if you're if you just see that why we're messing
up with lips. So early, we will see that things
62:41 - in detail. But just to compare the in pseudocode.
Normally the lists are indexed the indexes
62:48 - of the list start from one. But in Python
programming language, the first index of the
62:53 - list usually starts from zero. So they are
the minimum value was the first value of the
62:58 - list here, the first value is actually the
index and Python is zero, rest of the things
63:02 - are same, you declare the variable as in pseudocode.
The same goes exactly in Python. They're the
63:11 - because the index was one. And so the counter
was one more than whatever the index was.
63:18 - Here, the counter is simply one, we need to
right here ID x ID x equals to zero that we
63:28 - just missed. In the previous the ID x is one,
so here the ID x is zero, that's okay. Okay,
63:34 - then next, we write while counter is less
or equal to n. Same thing while counter is
63:41 - less or equal to n here. So here we just write
the, the colon at the end, we might have written
63:50 - this equal sign here, this equal sign, we
just missed the equal sign the equal sign
63:57 - is there. So now, but see that see the difference
here, the violet goes that way, here we have
64:04 - a colon at the end, rest of the things are
exactly the same. Now, v is equal to L counter
64:10 - v is equal to L counter the same thing if
v is less than the minimum value, same thing
64:16 - if v is less than the minimum value in the
pseudocode. Python is exactly the same. Just
64:20 - see the colon at the end, we have colon at
the end of the while statement, we have colon
64:25 - at the end of the definition, we have colon
at the end of the if statement. The other
64:30 - statement in pseudocode. In Python exactly
the same. Now, in pseudocode, we have l statement.
64:36 - In Python, we have l statement. If we want
to write an else statement, we have write
64:40 - a colon at the end of that. Then in Python
in pseudocode, we have a past statement Python
64:46 - in our past statement, same things in pseudocode.
We have n def, just to describe that this
64:51 - f ends. In Python, everything is described
by the indentation style. So if this indentation
64:58 - goes on, if we have If you're here, then this
is goes if this if goes out, so we need not
65:05 - write ends every day. Similarly, the vile
body has this indentation style, this is all
65:13 - the while body, whatever that is, that is
earlier than this is not in the wild body.
65:19 - So, rather than writing the tokens and while
and if the Python handles everything using
65:25 - indentation, so no need of end if no need
of end while Oh, we haven't, right, we haven't
65:32 - written a counter here. So we have to write
a counter plus plus here, so counter. So the
65:38 - same statement, we missed this statement in
the Python code. So the same statement, exactly
65:42 - the same statement goes here. That's it. The
rest of the story is same, we do not need
65:48 - an end search here. The goal here is to show
that the pseudocode is, I mean, the way you
65:58 - write the pseudo codes, they are they're highly,
66:01 - they highly resemble with the actual code
in Python, Python is that expressive Python
66:08 - is very, very high level language. I mean,
the way the you the way you think the problem
66:14 - in the pseudocode, the actual Python code
is much similar to it. So learning the Python
66:20 - is very, very simple. The simplicity of Python
is really a great property of Python. And
66:25 - that's one big reason of popularity of, of
Python. Now the return statement is same and
66:31 - everything is same, then we move toward the
sorting. Again, we have sortlist, we have
66:36 - to write the Define def define, and then we
have this colon out there, we have to write
66:43 - the colon there, then let's do is defined
like empty, it's empty in Python as well.
66:49 - Counter starts from zero, because they are
the list starts from index one. In Python,
66:57 - the list starts from zero, so we are at zero,
while same as this one. Here we have this
67:03 - colon, maybe, maybe an equal sign, maybe an
equal sign should appear here. I guess we
67:09 - are missing an equal sign. But either way,
the code is more or less the same rest this
67:16 - statement exactly same as this statement,
we have insert in L two, here, we write a
67:22 - band append function, I'm in Python, here
with ID lead this in Python, we have a Dell
67:30 - statement, rest of the story is exactly same.
So you see converting pseudocode to Python
67:35 - code is, is way more easier. This is this
is not a this is not a formal introduction
67:43 - to Python. I mean, the the goal here in this
video in these kind of session videos is just
67:49 - to introduce you with problem solving. But
I I found this, I mean, I found this beneficial
67:58 - to show you that the pseudocode actually resembles
to the actual Python code a lot, although
68:03 - we will be dealing with variables lists, while
loops, if conditions, all these kind of stuff
68:10 - in them in a in a big and huge detail. When
we in the upcoming videos, when we will introduce
68:18 - the Python syntax and variables and all that
kind of stuff. Actually, you will be mastering
68:23 - each and everything in Python. And, and further,
you may not write these lengthy chords to
68:29 - do stuff in Python, I mean, the whole dad
thing is just you write l dot sort and you're
68:36 - done. I mean, you need not write a lot of
lines of codes in Python. Here, I just here
68:43 - I just showed you that if you have a procedure,
you can, if you have a pseudocode it looks
68:48 - like much like the same as Python, which,
which actually tells you the expressive power
68:55 - of Python and simplicity of Python, and how
it is closer to what you think. But the actual
69:01 - problem solving
69:03 - in Python does not require so many lines of
codes, I mean, there are so many functions,
69:09 - so many powerful procedures. For those you
just write one line and a huge amount of work
69:16 - is done for you. And there are very good one
liners for Python I mean in for for for for
69:23 - programming in Python, you did not write a
lot of lines of code to do some stuff. I mean
69:28 - a few lines of code even a single line of
code does a lot for you. And for that you
69:33 - need to know the features of Python the feature
of the features and the different kinds of
69:39 - syntax and features and libraries and the
packages and what what is available with Python.
69:45 - I tell you almost each and everything is available
just you need to know what is available. Once
69:51 - you know the what what what what are the things
that are available. You need not to write
69:55 - lengthy codes you need now to build a lot
of logic on yourself. Things are prepared,
70:00 - they're waiting for you, you just have to
figure them out what are these things to do
70:05 - what what kind of features are there in Python,
if you know that you are done. So you need
70:11 - not to be writing these kinds of codes and
lengthy kind of codes. Although knowing that
70:15 - all knowing that is a is a is a huge advantage,
but doing a bigger and bigger and bigger stuff.
70:23 - Python will give you a lot of features a lot
of functionality that you need not to go into,
70:29 - and you need not write a lot of code for it.
And that's the second power of Python. One
70:34 - is simplicity. Second, it gives you a lot
of features a lot of functionality, a lot
70:40 - of built in stuff ready for you, you want
to do something, it will be probably there
70:46 - in Python, you need to know where it is. And
for that we have whole future series on Python
70:52 - to know Python each and every step in Python,
and to know important packages in Python.
71:00 - Because knowing important packages and knowing
how to code in Python will save a lot of time
71:05 - for you. So spending some time on learning
Python will be saving a lot of your time.
71:10 - To solve the actual pure problem. Whatever
problems you're doing, you're going to solve.
71:16 - And Python is a real programming language
granting programming language, knowing this
71:20 - language is almost enough. So hope to see
you in in the next videos where we will start
71:27 - Python from exactly zero. And we will see
each and everything of Python in detail. Hope
71:34 - to see you in the next video. If you're new
to data science, you may stuck in choosing
71:41 - the best language for data science. And in
this video, I'm going to I'm going to talk
71:47 - about Python, which is the greatest language
so far for data science. To explain the features
71:55 - of Python, let me first go back to a little
bit history of Python from where it started.
72:01 - It basically starts in 1980s. It was introduced
first in 1980s. But with constant improvements
72:09 - and a lot of bug fixes. It was officially
launched in 1989. Nine years later. It was
72:16 - created by Guido van Rossum and it is open
source which means it is accessible to everyone.
72:23 - Even though it's open source. It can be used
for commercial purpose. The main goal of Python
72:30 - was to keep the code easier to use and understand.
Its huge library enables data scientists to
72:37 - work faster with the ready to use tools it
is dynamically typed. So the variables that
72:46 - you are defined that you are defining that
they are defined automatically, you need not
72:50 - to set the type whatever the contents in bring
in, the type will be defined automatically.
72:56 - It is more readable and uses lesser code to
perform the same task as compared to other
73:01 - programming languages. It is flexible, portable,
and can run on any platform easily. It is
73:09 - scalable, and can be integrated with other
third party software easy. Python programming
73:16 - is easy to use, and has a simple and fast
learning curve. new data scientist can easily
73:24 - understand Python, but it's easy to use syntax
and better readability. So so that's what
73:32 - this point is basically it's it's really a
beginner friendly if you if you're new to
73:36 - programming. Well, Python offers you a very
easy environment to go on. It also provides
73:43 - plenty of data processing tools that help
in better handling the data. Python is important
73:50 - for data scientists, because it provides a
vast variety of applications used in data
73:55 - science, it also provides more flexibility
in the field of machine learning and deep
74:00 - learning.
74:02 - It has, it has a lot of packages like TensorFlow,
Kara's tiano. That is helping data scientists
74:10 - to develop specifically the trending deep
learning algorithms very, very quickly. So
74:17 - basically, the sport, the sport of machine
learning and deep learning is huge in Python.
74:24 - That's huge. As, as is the case with many
other programming languages? It's available
74:34 - libraries that lead to Python success around
around 72,000 available packages. In Python
74:48 - package index, sometimes called by pi, Python.
Why? Python package index by by around 72,000
74:56 - packages are available and they are good Constantly.
So huge number of packages mature packages
75:04 - are available. It is free open source and
consequently, any Can anyone can write a library
75:13 - package to extend its functionality. Data
Science has become an early beneficiary of
75:19 - these particularly ponders The Big Daddy of
all of them. The other great thing about Python
75:28 - is there are millions of users who are happy
to offer advice or suggestions. When you get
75:37 - stuck in something, chances are someone else
has been stuck there first. So a lot of community
75:45 - is there, a lot of packages are there, it's
open source it it's easy to use, it's easy
75:51 - to learn. It's simple, it's readable, more
close to human language, it's high level language,
75:58 - you code less you do more, I mean, you write
a very few lines of codes, and you achieve
76:03 - a lot of work. So, I mean, I've spoken a lot
of verbs here, too, too. I mean, explain that
76:13 - Python really is best suited language for
data science. But let me let me introduce
76:19 - you some statistics about Python, the popularity
of Python with respect to big with respect
76:24 - to its use, and with respect to the job opportunities
that are there in Python. So for example,
76:32 - if you see this chart, in the ranking of top
10, languages, Python stays at the top. So
76:40 - that's the latest statistic, collected in
2019, February 2019. And out of the out of
76:50 - the total share of the languages, I mean,
around 26%, just goes for Python, and the
76:56 - trend is moving up, which means the people
are more interested in Python, I mean, the
77:02 - trend of using Python is getting larger and
larger, as compared to several other languages
77:06 - like Java, JavaScript, C, sharp, bhB, C, our
objective c, swift and MATLAB. I mean, many
77:15 - of them are used for data science, but Python
stays at the top. I mean, this is that popular
77:21 - language. And further, if you see, for example,
the job opportunities in Python so so that
77:30 - says, I'm in a different companies like Facebook,
Julia, and I'm in Google and several different
77:35 - companies. This actually graph shows from
2014 onwards, that the job opportunities and
77:43 - job postings are in different languages are
at what amount, and you can see the graph
77:49 - of Python, although starting a bit low, but
then stays up and stays up, which means the
77:57 - 80 if you see the numbers 85% of the total
jobs, there are just for Python. And not only,
78:07 - I mean, Python is not just for data science,
it's a general purpose programming language,
78:13 - it's open source, it can be it can be used
to perform any kind of task for embedded programming
78:20 - for, uh, for for posting, I mean, codes or
embedding code on Raspberry Pi for web development
78:28 - and whatnot. You can you can, you can do the
desktop development on it, you can use the
78:33 - web developer knowledge you can use the data
science, I mean, I mean, this is general purpose
78:36 - programming language. In other disciplines
do it is performing very well. But data science
78:42 - for data science, it is almost the default
language today.
78:46 - So, I mean, if you're going to learn data
science, really, we need Python. I mean, Python
78:54 - really is the choice, the default choice,
and we need it. And in this particular course,
79:00 - we are going to, we are going to introduce
Python to you with all aspects, I mean, we
79:06 - will start from the very beginning level.
And we will gradually move towards the very
79:13 - advanced programming in Python, including
the introduction to the data science packages,
79:19 - like pandas and matplotlib, for visualizations,
and NumPy, for handling numeric data and stuff
79:26 - like so. So, in this particular course, we
are really going to teach you Python, and
79:32 - we are not assuming you have any programming
experience before. So and this is one plus
79:38 - of Python. I mean, whether you're an engineer,
you're coming from health sciences, you're
79:42 - coming from biology, you're coming from arts,
humanities, or from wherever. Python is something
79:48 - that is very easy to get hands on. So if you're
not assuming that you have any programming
79:55 - background, you have any data science background
nothing. So we will start from the zero and
80:00 - And we will gradually move to 200. So, and
including the introduction to the data science
80:08 - packages. So Python is the best, it is a default.
If you're going to work in data science, Python
80:15 - is the default. And we are going to, we're
going to introduce you Python from the very
80:21 - beginning to the very professional. So hope
to see you in this course. Okay, before actually
80:29 - discussing the best ID for Python, and particularly
for data science, let's first discuss what
80:39 - an ID he is, as you start your coding journey,
many of you prefer coding in a text editor
80:44 - maybe like notepad plus plus, where you write
the code and then open a terminal window to
80:50 - execute your code. When there is an error
detected in your code, you switch back to
80:56 - the text editor, correct your errors, typos
and run the code again in the terminal, everything
81:01 - is fine. Typically, for large scale problems,
however, you not only have to code but you
81:07 - also need to make sure your code works in
all scenarios, which means you also need a
81:12 - testing module. Many times you have multiple
coding and testing files, and switching between
81:18 - editor and terminal often becomes both confusing
and efficient. So, an environment is needed,
81:28 - where you can write you can run and play with
your code all at one place. So the one that
81:37 - provides you with the capability of not just
coding, not just writing the code, but but
81:44 - also testing your code, running your code
highlighting your syntax, bracket matching,
81:51 - auto completion, debugging your code, code
suggestions, and and many more features. That
81:58 - is called an ID II or integrated development
environment. Now, there are several ID is
82:08 - for different languages for for Python, there
are several ideas for example, Jupyter Notebook
82:12 - is an ID IE by charm is an ID IE spider is
an IP ID and thought cannot be whim atom and
82:20 - there are a lot more there are several of
them. Now the question is for data science,
82:25 - in particular, what Id E is is the best or
are what people suggest to be the best. So
82:34 - before actually showing you the statistics
that which one is the best before actually
82:39 - showing you the actual numbers, the statistical
numbers that shows which one is better, what
82:43 - are the other let me just go through a few
of them few of it ease and their features
82:48 - and stuff. And then we will move to move to
statistics and some numbers that will show
82:54 - that which one is better over the other. So
let me start with with this Jupyter Notebook.
83:02 - For the past couple of years Jupyter Notebook
has been gaining a lot of popularity in terms
83:07 - of coding and debugging. notebooks have been
redefining the concepts of an ID E and are
83:13 - adding more and more features on to it. Jupiter
was introduced in 2014 after its predecessor
83:21 - ipython and from that date, it is really considered
to be a bless in the coding community.
83:28 - Jupiter stands for I'm in some people say
Jupiter stand for Giulia Python r but that
83:35 - I come in that acronym does not mean just
this. I mean Jupyter Notebook today is supporting
83:43 - more than Giulia, Python and R and by the
way, this Giulia Python, R and R all these
83:48 - are open source languages for and they are
best suited for data science. This Jupyter
83:57 - Notebook, it has markdown editor. It allows
you to write HTML code, it allows you to write
84:02 - latex in it. I'm in a lot more. Further this
Jupyter Notebook. It's a web application based
84:09 - server client structure, which is easy to
use and allows you to create, analyze, and
84:15 - manipulate documents. And all these documents
are in the form of notebooks. Since it's a
84:21 - web web interface, it can integrate with many
of the existing web libraries. For example,
84:27 - for data visualization. Jupiter has so many
functionalities you can write formula using
84:34 - labtech run a Python code and visualization.
For example, a raw audio signal using matplotlib
84:42 - plotting library, all in the same notebook.
Jupyter Notebook is not just an idea he but
84:50 - it's widely used and an educational tool for
presentation and even for writing blogs. You
84:58 - can export your notebook from iPython Notebook
formats to PDF or to HTML or even to.py, which
85:06 - is the Python file. The user interface of
Jupiter makes it a favorite tool, especially
85:13 - amongst the data science community. And one
plus of this Jupiter is, it's it's very quick
85:21 - to start, I mean, very easy and very quick
to start, I mean, not much rocket science
85:26 - to write your first goal, you want to write
your HelloWorld it's very, very quick. And
85:31 - you're better to go and do that. By charm,
if I discuss pi charm, however, if I discuss
85:40 - some of its properties, and let me just discuss,
first that the pipe the PI charm is by the
85:50 - company JetBrains. And if you have never used
japin JetBrains other IDs like Java ID, then
85:59 - running your first code successfully can eat
up a little bit of your time, actually, a
86:05 - large amount of your time maybe such as I
mean, setting an interpreter by charm. By
86:12 - charm, however, is, is much better for, for
working with multiple scripts, handling multiple
86:19 - files and linking them together and huge large
scale coding products. The good thing about
86:26 - Python is it supports Anaconda. And as a result,
all the packages that fall under Anaconda
86:33 - are supported by char pi charm as well. And
those packages in including NumPy, Sai, pi
86:38 - matplotlib, and so on. Just like other IDE
ease pi charm has a powerful debugger. With
86:44 - a graphical interface. It offers jet integration,
it has skills, shell terminal and worryin
86:51 - control system. Python, it is customizable,
which allows you to choose between different
86:58 - themes, color schemes, and key binding and
whatnot. Additionally, Python lets you add
87:05 - plugins for non pythonic files. And these
plugins take care of indentation highlighting
87:10 - the errors and keywords just on the fly. So
Python is also providing I mean, a huge support
87:19 - for coding Python. But, I mean, the one bad
thing about Python, which is not that bad,
87:27 - but one bad thing is it is memory intensive.
It eats up a lot of memory. It's a heavy thing.
87:33 - And secondly, I mean getting getting getting
started with PI charm is not that quick. I
87:41 - mean, it takes a lot of time to just go with
that. Spider however, is a lightweight, open
87:48 - source ID Oh by the way, this by but this
by charm is is is not I mean it has Professional
87:54 - Edition and and Community Edition and it does
not open source completely. Spider however,
88:01 - is a lightweight open source, ie that comes
pre installed with Anaconda. And it was built
88:07 - mainly for data science practitioners and
engineers. Its look and feel is much like
88:15 - MATLAB. So if you're a MATLAB programmer,
if you've used MATLAB before, you switch to
88:19 - Spyder and you get a mean much look and feel
the same cannot be by the way the unthought
88:26 - cannot be also has roughly the same look and
feel as MATLAB
88:30 - So, but spider was built for data science
community, it is integrated with essential
88:38 - data centric libraries like NumPy, Sai, pi,
matplotlib, pandas, ipython, and whatnot.
88:47 - The built in capabilities can be extended
further by plugins and API's Spyder contains
88:52 - features like text editor with syntax highlighting
code completion, static code analysis, debugging
88:58 - variable exploring, it also has profiler that
recursively determines the runtime and number
89:06 - of calls for every function and methods call
in a file. And I mean, there's no thought
89:14 - cannot be there is a vendor's atom there are
a whole lot of it is just for Python language.
89:21 - But But the question really is being a data
scientist, which one is which one should you
89:27 - choose being a beginner? which one should
you choose? Even even for professionals, if
89:32 - you want to stay in data science, which ID
he will you prefer over the other? I mean,
89:37 - there are so many of them. I have just described
three or four of them. So let's see some stats
89:43 - based on popularity of different IDs for data
science, and then decide which one is better
89:48 - over the other. So for example, this data
this this analysis, that the chart I'm showing
89:55 - here, this analysis by was was done by Katie
nuggets and The link for that and it shows
90:01 - that the most popular Python editors till
December 2018 and you can see that the Jupiter
90:12 - is at the top, the second is pi charm, then
spider then Visual Studio code and sublime
90:18 - tags, then add on atom women there are so
many others, but Jupiter is at the top and
90:24 - this is for I mean, these all are listed with
respect to the data science community. So
90:32 - in the data science community which Python
ID he is best over the other and, and Jupiter
90:39 - Jupiter is at the top I mean it is it is way
out. And one reason to this is its simplicity.
90:48 - It's it's supporting to so many different
formats. It's it makes an interactive document
90:54 - it makes it makes a web page that is interactive,
you can just change the code you can make
90:59 - another web page and so on. You can you can
run it on a local system you can run it an
91:04 - online survey system and whatnot I mean it
has so much flexibility and very quick start
91:10 - and easy to use. If you for example see the
popularity of Python IDs with respect to the
91:19 - employment then then you can see overall the
the Jupiter has been a winner as compared
91:26 - to pi charm spider also your code and sublime
if you see company or self employed still
91:33 - the Jupiter is V out it has been if you see
for in a student perspective, Jupiter is the
91:38 - choice. If you go to academia or university,
Jupiter is the choice if you are working with
91:45 - government or nonprofit Jupiter is the choice
I'm in Jupiter is I mean Jupiter is kind of
91:52 - outlier it is it is staying at the top everywhere.
Further if you if you analyze the popularity
92:00 - of Python, it is with respect regions for
example, again, overall, Jupiter is a winner.
92:06 - If you see US or Canada Jupiter's most popular
mostly used Europe, Jupiter is the winner
92:13 - Asia, Jupiter is the winner, America use Jupiter
sevinor effect Africa and Middle East Jupiter,
92:19 - Australia, New Zealand Jupiter. I mean, these
numbers are suggesting that Jupiter is is
92:27 - at the top, not just at the top. It's easy,
I mean, and maybe that's one reason why Jupiter
92:35 - stands on the top for the data science. So
these numbers and these all statistics suggest
92:42 - that we should use Jupyter Notebook for Python.
And we will be doing that. In fact, for this
92:49 - particular course we'll be working on Jupiter
for all kinds of coding. And in the in the
92:56 - next video, I will be just showing you how
to install
93:01 - Jupiter environment how to install basically
Python and how to run Jupiter for the first
93:06 - time from it. So I hope to see you in the
next video. Okay, in this video, I will show
93:13 - you how to install Python. There are multiple
ways of installing Python you can go to python.org
93:19 - and install Python from there I would recommend
to use Anaconda distribution it has Python
93:27 - it has a lot of packages pre installed it
has Jupyter Notebook as well. So installing
93:33 - through Anaconda is easier as well. So if
for example if you are working on a Windows
93:37 - system you should download the executable
for Windows we will be working with Python
93:42 - three rather than Python two. So you should
be installing you should be downloading Python
93:47 - three point whatever the latest version is.
Further if your system is 64 bit you should
93:55 - be installing 64 bit version otherwise you
will be installing 32 bit version. So let's
94:00 - say you have downloaded the executable file
for Windows then after the download you just
94:07 - from that xe file and follow the steps and
you'll be able to install Anaconda once the
94:12 - Anaconda is installed then in the search bar
you just type Anaconda prompt and the Anaconda
94:18 - prompt kind of symbol that my mouse is pointing
at this will appear in front of you, you just
94:24 - run it you will see a command prompt like
so. Then in that just type Jupyter Notebook
94:31 - and press enter and you will be having Jupiter
running in front of you. Let me let me show
94:37 - you that on my on my system. How to do that.
Let's see. For example, this is my search
94:44 - bar. Let me type and conda prompt so this
is the Anaconda prompt. So if I click it,
94:51 - it runs then I just typed for example, Jupiter
note book Then I just press enter. For the
95:03 - first time it will take some seconds to run.
So let's wait for it. So yes, it runs and
95:11 - it will show you kind of browser in front
of you. And that's what the Jupiter into interface
95:18 - is. We will see then how from this Jupiter
how to write the code how to make the code
95:24 - files and stuff but that's how from Anaconda
installing after installing Anaconda that's
95:30 - how you will launch the Jupiter. So this is
that easy, no problem. Then, for example,
95:38 - you can install you can install Python if
you're working on Linux and just download
95:43 - the version for Linux. And then rather than
For example, let's say your your your file
95:52 - is downloaded in the Downloads folder then
run this command bash and this.sh that's the
95:58 - file name. The installer prompts in order
to continue installation process this I'm
96:02 - in these kinds of commands will will appear
Press Enter to Continue then press Yes, and
96:08 - the installer will finish with the thanks
message. After that, you just go to downloads
96:13 - folder and type Jupyter Notebook and the Jupyter
Notebook. interface the browser based interface
96:19 - will appear in front of you. You can have
if you're if you're working on Mac, you can
96:26 - you can in you can download the Anaconda distribution
for Mac, then you'll find an anaconda Anaconda
96:35 - navigator, the launchpad you can launch that
and then just click there's a Jupiter icon
96:41 - in front of you just press the Launch button
and you'll be having your Jupiter running
96:45 - in front of you. So in this video, we just
talked about how to install Python. If you
96:52 - install Python using Anaconda you will be
having Jupyter Notebook as well. In the next
96:57 - video, we will see how to actually use that
Jupyter Notebook interface for example, I
97:04 - work on Windows, so I'll be having this kind
of interface although the interface looks
97:09 - like same because it's a browser based web
based interface. In the next video, I will
97:14 - show you how to get comfortable with Jupiter
and we will be also writing our first HelloWorld
97:21 - program in Python. So hope to see you in the
next video. Okay, so in this video, I will
97:29 - show you
97:31 - how to write the first program in Python basically
the HelloWorld program. Before that, in the
97:38 - previous video, I show you I showed you how
to launch Jupyter Notebook. So once you launch
97:45 - Jupyter Notebook, whether you are working
on Windows, whether you're working on Linux
97:49 - or Mac, whatever, when you will launch the
Jupyter Notebook, you will see this web based
97:55 - interface. And here you are in the right corner
you can see the button new, you just click
98:03 - it, you will select Python three, and you
will see a beautiful interface in front of
98:09 - you that will allow you to go here, there
are a lot of file edit view there are a lot
98:16 - of parents kernel and a lot of controls here
we will see them as we move on. But this is
98:22 - how you this is this is what the coding environment
is this is kind of editor as well as I mean
98:27 - this is complete, ie interface in front of
you. So let's see this interface a little
98:33 - bit. Step by step at least the controls that
that we need. First of all, you are seeing
98:41 - where my cursor is moving. That's the file
name or the notebook name. You can change
98:48 - the notebook name or you can just write for
example. Whatever the name of the notebook
98:55 - you want, for example, mastering by Thorne
99:03 - for
99:05 - beginners. Okay, so let's say that you're
mastering Python, let's say let's say zero
99:16 - to hero, maybe. So let's say this is your
filing, you just create that file and you'll
99:23 - see this mastering Python zero to hero that
file is created with this file is renamed.
99:31 - Second. This is a cell in which you are going
to type your code. The code, I mean, the two
99:39 - modes of writing is one is you can write the
Python code. Another way is you can write
99:46 - the markdown. The markdown is important in
in a way that if you want to describe your
99:53 - code, if you want to write other stuff other
than Python code, you can use these markdown
99:58 - cells and they We will be helping you. For
example, if I select this markdown, and I
100:07 - just select this markdown, and I type here,
for example,
100:16 - this is by THON directorial. And then I press
Shift Enter, it will appear as a heading.
100:35 - And a new cell will be graded down. This is
also a cell. But this is a markdown cell.
100:39 - As you can see, now in this cell, that's a
code cell, you can switch a cell from code
100:45 - to markdown by just pressing an escape key,
when you press an escape key, you will see
100:52 - the color will change here, you can press
Escape key, then if you press M, it will change
100:58 - to markdown. And if you press Y, it will change
to a code cell. There are several I mean shortcuts
101:07 - that are available keyboard shortcuts, if
you if you just see, if you go to help and
101:12 - see this keyboard shortcuts, there are several
shortcuts that will be available in front
101:17 - of us. For example, if you press escape, and
then press F, you can do the Find and Replace
101:24 - operation. And if you press enter, then that
will go into Edit Edit Mode, if that's important,
101:30 - if you press Shift, enter, the cell will run
and the new the cursor will go into the new
101:37 - cell. And there are a lot of controls you
should be seeing most of them, I mean, getting
101:43 - a good grip on these controls will help you
moving in this Jupyter Notebook very quickly.
101:50 - So for example, this is a Python tutorial
that's a markdown cell, you can also create
101:55 - this, this cell also as a markdown cell. And
then you can type here for example. This is
102:05 - our first program in Python. It there it is
just started here, for example, and it just
102:22 - appears like like a description. And again,
a new cell is created down and there you can
102:28 - write your code. So let's write the first
Python code HelloWorld. So first of all, you
102:36 - will write Brent Brent command will allow
you to print anything on the screen. brantas
102:44 - says double codes, starts ends. And in the
double code, you write whatever you want to
102:52 - be printed on the screen, for example. Hello,
102:58 - world.
103:00 - And once you have written that code, just
press Shift and enter, and this code will
103:06 - execute in front of you. So that's HelloWorld
printed in front of you. And that's our first
103:14 - program, I mean, writing the very first program
in Jupyter Notebook. is is that easy. Not
103:22 - only that, this Jupyter Notebook will be created,
you can you can just I mean describe anything,
103:29 - you can write the headings, you can write
HTML in it, you can write math, using lattic.
103:37 - And for example, let me let me write lattic,
or mat in front of you just just let's say
103:42 - you're making a notebook that requires some
mathematics in it. And it allows you to write
103:49 - mathematics as well. For example, A equals
B plus C, Shift Enter, and that appears like
104:00 - a mathematical equation, not just this, you
can write very complicated equations. I mean,
104:07 - and and, and this whole notebook will contain
your descriptions in terms of HTML or latech,
104:14 - or descriptions, and code and all that mixed
up, whatever. And at the end, you will, you
104:21 - can, you can just download this. You can just
download this, this notebook, as if you want
104:31 - a PDF file PDF file. If you want a notebook
file, it's an output file if you want to latech
104:35 - if you want just a Python file if you want
slides, for example. I mean, you can download
104:40 - the same thing as slides. It will make slides
for you. So there are a lot of ways of using
104:45 - this notebook. And that's a ready made document.
I mean, you end coding, the document is ready
104:50 - for you. So this notebook is really, really
powerful Jupyter Notebook and coding in it
104:57 - is not just the coding. I mean, it is Preparing
a document. If you want to prepare a document,
105:03 - you want to describe anything you want to
add images, and at the end of the day, it
105:07 - will be an HTML document for you. It can be
shared on web. I mean, it's ready. Nothing
105:14 - we we want to further finish it. So that was
our HelloWorld program in Python. We will
105:21 - continue to build this byte mastering Python
zero to hero notebook, we will continue coding
105:28 - in that we will describe the headings we will
write the markdown cells and all that stuff.
105:33 - And we will at the end of this course, you
will be having one notebook with all kinds
105:38 - of descriptions and code in it. You can use
that notebook afterwards, we will be building
105:44 - well one notebook, one complete notebook for
Python. So that's about it. That's the hello
105:50 - world. In the next video, we will see how
to what are what are the constructs in in
105:59 - Python, what are variables and other stuff.
But before that, I also wanted to show that
106:05 - this notebook is an enhanced worryin are the
upgraded version of ipython shell. And I also
106:12 - want to show you ipython shell as well. So
in the next video, we will just see the ipython
106:19 - shell and we will see how can we how can we
view Python as just as a calculator by using
106:26 - ipython shell. So hope to see you in the next
video. Okay, so in this particular video,
106:31 - I'm going to show you the ipython shell just
open up the Anaconda prompt as as before,
106:40 - like you want to open a Jupyter Notebook,
then you just type here Jupyter Notebook.
106:46 - And you will be you will be in the in the
notebook word Jupyter Notebook word. But if
106:52 - you just type in ipython and press enter,
then a prompt is open for you in a colored
107:01 - way. And this is perfectly fine to write any
kind of Python code in here. Actually, the
107:09 - Jupyter Notebook is more enhanced and more
featured the use of ipython. Basically everything
107:15 - that I bought, that is there in ipython is
there in Jupyter Notebook as well. But it
107:20 - has more features more documentation and stuff.
So for example, if I just write a Python code
107:28 - here,
107:29 - hello world, let's say it will work in ipython
shell as well. But remember, previously in
107:36 - in Jupyter Notebook, we type Shift Enter to
run a particular command here, we just press
107:41 - enter and everything will work. If you want
to clear the screen here, whatever the whatever
107:47 - we typed here, if you want to clear that,
just press Ctrl l if you're on Windows Ctrl
107:53 - l will work on Windows. Now ipython is just
like, you can use the Python in this particular
108:01 - shell just like a calculator, for example,
you want to plus three, press enter, that's
108:06 - five, let's say it's nine multiplied by seven,
the answer is 63. You can write a complicated
108:16 - statement as well, for example, 45 minus eight
is static, or multiplication, static is achieved
108:26 - by multiplication is achieved by a static
symbol seven. And then you can have this minus
108:35 - then divided by two and just press Enter.
And that's the answer 16.0. If for example,
108:45 - by the way, I have just press the up arrow
key and last command just appears. I have
108:51 - pressed up arrow key again. And the second
last command appears. I press the up arrow
108:56 - key again and the third last command appears
and now I'm pressing the down arrow keys.
109:01 - So for example this and you may have whatever
the result is, you may have that multiplied
109:11 - by 10 and minus or or maybe plus plus 15.
So the result is minus 145, and so on. So
109:26 - this Python ipython shell, you can write very
complicated are almost I mean, the complete
109:34 - Python coding can be written in ipython shell.
And you can use this shell just for a calculator.
109:40 - Now let let's see, for example, you you compute
this result, let's say 45 minus 45 minus nine
109:51 - and let's say you compute this result, whatever
the result is, and you save that result in
109:55 - a symbol, let me call that symbol as a variable.
In here the variable is So let's say you save
110:01 - that in a, and then you have another variable,
let's say B, and three static 45, or maybe
110:10 - three steric 2.6, that is saved in B. Now,
you have you have done this particular calculation,
110:18 - you know that 45 minus nine is in a, the result
is in a, and then you have this particular
110:25 - result that is in B. And now, you just want
to add the two results together, and you want
110:30 - to print the
110:35 - what what normal calculators does not have
the support of saving the results and reusing
110:41 - them. But here in Python, even if you just
want to use the Python, just as a calculator,
110:48 - you can declare as many variables as you can
and you can save the previous results, you
110:53 - can retrieve the previous results. And you
can use the previous results, save new results
110:59 - and so on. These kind of symbols that are
used to save the results, and then they can
111:06 - be just used afterwards, these are called
variables. And our next video will be on variables,
111:13 - what are these variables, what are the types,
what kind of variables the Python supports
111:18 - one way or the other, if you want to go beyond
calculators, you need certain results to be
111:22 - saved and retrieved retrieved afterwards.
And the variables are are the constructs the
111:28 - variables are the features that actually do
that. So the calculator is fine, you can use
111:34 - this ipython shell just as a calculator. But
if you want to do interesting programming,
111:41 - complicated programs, I mean, you want to
achieve a task that involves much more calculations
111:45 - one way or the other, you have to save certain
results in somewhere. And then you have to
111:51 - combine the results together because the longer
problems in normally are broken up into smaller
111:56 - piece of problems. And each smaller problem
has a result that should be saved somewhere
112:01 - and afterwards the several results they should
be combined to achieve the result that we
112:07 - are after. So these variables are required
if you are going to do some interesting or
112:11 - complicated calculations or computations.
So you, by the way before, before having these
112:20 - Jupyter Notebooks spit out just the enhanced
version of this ipython shell, the iPod ipython
112:25 - shell just people used to write a lot of Python
programming just in ipython shell. And even
112:32 - even today is several people are writing their
code complete code in ipython shell. But the
112:40 - the Jupyter Notebook is more enhanced for
the enmore documented more, I mean, it has
112:47 - better interfaces and several features that
are better than just using ipython shell.
112:53 - So you have seen this ipython shell, it's
very powerful, great, everything is fine with
112:59 - it. But we will be using Jupyter notebooks,
which are just the enhanced variants of this
113:06 - ipython for our upcoming coding. So the purpose
of this video was just to was just to introduce
113:14 - you with ipython shell and just to tell you
that you can use Python just as a calculator
113:19 - and even more than that, and in the next video,
we will be introducing variables in Jupyter
113:25 - Notebook and we will see the Python or Python
is really really much more powerful than just
113:31 - a calculator. So hope to see you in the next
video. Okay, in this video, we will talk about
113:37 - variables and operators the operations that
you can perform on on variables. A variable
113:45 - in a very layman term is basically a symbol
that stores some data that can be used later
113:53 - on. So for example, this x is a symbol corrector
or a symbol y is a symbol x y is a symbol
114:02 - normally, and these are called names of the
variables. For example, this is a variable
114:07 - name x, y is a variable name y, x y is a variable
name itself. Now, these variables, they can
114:15 - store different kinds of data, I mean, whenever
you want a particular data to be used again
114:21 - and again, it is better to save that data
or label that data by a symbol by a descriptive
114:29 - name so that you can retrieve that team retrieve
that data by using that label or symbol. So
114:37 - one way or the other. This this variable actually
is a description of the data that you want
114:42 - to use our store and you want to use later
on in your program. Different types of data
114:50 - are there, for example, the integer type data.
114:55 - For example, if the data you want to store
is integer type, it's a number And the number
115:01 - is just the integer number it does not have
a decimal point expansion that is a type of
115:08 - data and that can be stored in a variable
in that in that case, the variable type itself
115:14 - will be integer, you need not to specify the
type of variable when you are storing the
115:21 - data to it the storing data to a variable
is sometimes called assigning data to a variable
115:26 - or assignment. For example, if your variable
is x, and you are assigning a value let's
115:33 - say two, then two is integer value its integer
it does not have a decimal expansion and when
115:40 - to is assigned to x, based on the content
to that to basically is an integer type value,
115:49 - automatically this the type of x is set to
be integer. And that is sometimes called the
115:55 - dynamically typed Python is dynamically typed
language or dynamic typing, you need not to
116:01 - specify the type of the variable the contents
that you are assigning to a variable, they
116:07 - will define the type of the variable on the
fly. And the assignment for example, in here
116:13 - I'm storing two insight x and next time if
I want to print for example, what is there
116:20 - in x the the print value will be two. Now,
this kind of symbol is hot right there is
116:27 - no keyboard symbol that looks like so, so
rather than writing this symbol for assignment,
116:34 - normally an equal sign symbol is used for
assignment for example, x is equal to two
116:39 - that means two is assigned in x five is equal
five is equal to five means five is assigned
116:44 - in y 7.2 equal x y equals 7.2x y is completely
a new variable, it has nothing to do with
116:52 - x or y. And it is handy sometimes to to to
suggest the name of the variables that are
117:00 - too descriptive that are very, very descriptive
to increase the readability and management
117:05 - of the code, because later on you will you
will be seeing when you will be working in
117:09 - data science and other stuff. The programs
that you will be writing might not be very
117:15 - short programs, they might be lengthy programs.
So readability of a program and management
117:20 - of a program becomes an issue if you if you
if you do not assign the names of the variables
117:28 - carefully. However, if you write the names
very in a very descriptive way, by just writing
117:35 - the name of the variable by just creating
the variable symbol or or or the name, it
117:40 - tells a better look and feel of what kind
of data inside and what should I do with that.
117:45 - So, I was talking about this equal sign this
equal sign is used for assignment. Here for
117:51 - examples when 7.2 is assigned to a variable
x y, automatically the type of x y variable
117:58 - is set to be a floating point integer floating
point number a float is a data type in in
118:04 - Python that describes that the particular
data is a real valued it may have a decimal
118:11 - expansion as well not just integer and floats
are the only data types in Python, there are
118:18 - several others for example, you can define
complex numbers if you if you want to you
118:24 - can for example, defining a complex number
might be for example, you write the name of
118:29 - C and you write two plus four j if you write
the symbol j here, it automatically becomes
118:37 - complex. And now you can you can use this
see the way the complex numbers should be
118:43 - created. Similarly, there are other data types
like fractions decimals, there are there are
118:50 - further data types, the objects called strings.
For example, if you if you if you assign let's
118:59 - say s equals double quotes Hello
119:05 - then that S is also a variable and the type
of this variable a string string is just a
119:12 - sequence of a lot of collectors, where he
is a collector is a collector L is a collector
119:17 - L is a collector always a collector W is a
vector. And when we will define anything,
119:23 - any sequence of characters inside the double
quotes and then ended the double quotes here,
119:28 - or the single quotes, single quotes and double
course either way, then the type of this is
119:33 - become strings. And these characters should
be created as it is. Like for example, if
119:39 - we have another variable s two and we just
say one, two, in double quotes. Now this s
119:45 - two is no longer 12 as an integer. It is a
sequence of characters where first character
119:50 - is one and other graduates two, we will talk
about strings in detail in the upcoming videos
119:57 - but just to give you a look and feel that
Python actually supports a lot of data types,
120:03 - a lot of interesting data types including
the most important data type is integer float
120:08 - and string as well that we will see in detail.
Further you can assign you can assign more
120:15 - than one values to more than one variables
in in a single line there is sometimes called
120:20 - multiple assignment. For example, if you write
a comma b equals four comma 5.00, then four
120:27 - will be assigned to a and 5.0 will be assigned
to B. notice one thing although 5.0 looks
120:34 - like an integer, but when you when you write
a decimal expansion, it automatically becomes
120:39 - float. So, if you Now type the type, if you
now check the type of a it will be integer
120:45 - and if you check the type of B it will be
float. Once you have declared a lot of variables,
120:51 - they stay in the memory they occupy a particular
space inside the memory. For example, x is
120:59 - just a label to a memory inside the memory
that is to located somewhere. Similarly, y
121:05 - is also located somewhere in memory. And similarly
x y is also located somewhere in memory. And
121:12 - this is the data inside that memory. These
will stay in the memory and the occupy the
121:18 - memory. If you if you decide to no longer
use a particular variable and future in the
121:23 - in the program, then you can call this function
d l space, whatever the variable name, and
121:29 - it will delete the it will delete the variable
from the memory like it was never there. And
121:36 - once the variable is no longer in memory,
it is it is not accessible. If you now access
121:40 - the variable again, you will get an error.
Let's see all these concepts. Let let's see
121:46 - most of these concepts in Jupyter Notebook
and let's let's actually, let's let's actually
121:53 - define certain variables, use them, print
them, do some multiple assignment and see
122:00 - a lot of stuff in in Jupyter Notebook. So
let's go to Jupyter Notebook. So that was
122:07 - our notebook that we were doing, that we were
actually working on the last time. So let's
122:14 - say I define a variable X, let's say x is
two. Why not? Why not? I should describe this.
122:24 - as what we are doing here is let's say variables.
So just to give a heading that we are now
122:38 - in variables, so variables, notice that now
I'm in a code cell. Previously I was in a
122:44 - markdown cell, notice this change in this
particular cell, this is markdown in this
122:48 - particular cell, this is code cell, C that
goes, Okay, x is equal to let's say, three,
122:56 - let's into this. Now x is assigned a value
three. If you want to know how many variables
123:06 - right now are there in the memory, we can
write this command whose This is a percentage
123:13 - symbol, if you write percent a symbol and
then just type a command, w h o s, it will
123:18 - tell you all the variables that are on right
now that are there in the memory. And right
123:23 - now the memory has a variable with name x,
its type is integer, and the data inside the
123:30 - variable is three, that's the memory view
that you're now seeing. Okay, if you want
123:36 - to explicitly check the type of x, you can
print type x. So for example, this function
123:43 - type will will actually find out the type
of whatever variable you give inside and then
123:50 - this print function will help you printing
that on on the notebook. So if you see the
123:56 - type of x, the type is basically its integer
type. Now,
124:03 - if you for example, change the value of x
as three to let's say, 5.7. So you have same
124:11 - variable, but you just change the value from
three to 5.7. So let's see what happens now.
124:20 - So if we call us again, we have now the variable
name is still x, but its type automatically
124:30 - it's type automatically change to floating
point number, because of because we assign
124:35 - a floating point number to it. And this is
the data if we want to explicitly check the
124:39 - type of this x, that would be class float
now, further. Let's say we have another variable
124:51 - ABCD. That's a variable name, let's say and
we assign a value 55 six Point, three, two,
125:02 - that's that's the value. If we now called
whose function whose command, we will be having
125:09 - two particular values, one variable as ABCD,
its type is float. another variable is x,
125:16 - its type is float, and that is there. If we,
for example, do a multiple assignment, for
125:23 - example, a comma, when you write comma, first
variable finishes, second variable starts
125:27 - A, B, C, D, F, let's say these are five variables.
And if you assign five values to five variables,
125:36 - again in a comma separated list, 356, point
07, point two, and let's say minus three.
125:52 - So if you enter that, and you now check the
status of the memory, because now all these
125:57 - values are assigned to the respective variables,
if you now check the memory view, a is an
126:06 - integer type variable with value three ABCD,
the old variable that we assigned earlier,
126:12 - it's already float B is also integer, it has
value five sees float, sees float all those
126:18 - 6.0 looks looks much like integer. But when
you when you write a point explicitly, it
126:23 - becomes it becomes a floating point number.
So D is again, float with 7.2, f is integer,
126:31 - it's minus five. And x is the old old variable
that we know already. Now, if we, for example,
126:36 - delete a particular variable, if we for example,
we we no longer want to use ABCD variable
126:41 - ABCD. That's one variable that we don't want
to use in future. And now if we see again,
126:48 - the view of the memory, we don't have this
and if we now want to access this, for example,
126:56 - if we want to print this ABCD, we will get
an error, we will get an error and we should
127:01 - we should get an error because this particular
variable does not exist in the memory, it
127:06 - points to no data, it has gone, it has gone
like it was never, it was never there. So
127:14 - that's about the variables. We just talked
about integer and float, there are several
127:21 - other variable types as well. For example,
let me just give you an example of an example
127:28 - of a complex number, if you are really interested
in that's a complex number if you print its
127:33 - type so that the type is complex. Similarly,
you can have a string variable, let's say
127:45 - hello, how are you? That's a string variable,
if you bring the type of this you will get
127:56 - a string we will we have a whole set of videos
just on string data type, because this is
128:03 - very important data type we will we will see
that in detail. But the purpose here is just
128:07 - to tell you that there are a lot of data types
that Python supports and Python is dynamically
128:12 - typed whatever content you are assigning to
a variable the that content decides the type
128:18 - of the screen you need not to specify.
128:21 - So I end this video here. In the next video,
we will be talking about operators basically
128:31 - what kind of so once we have decided once
we have declared once we have defined a lot
128:38 - of variables, what we can do with these variables,
can we add two variables together and get
128:44 - the result stored in another variable can
we multiply two variables together, can we
128:49 - have an operation like addition or mixed types
for example, one variable is a floating by
128:55 - number and other variable is integer number
integer type, can we mix up those can we add
129:01 - two different types of variables together
and get a result then what will be the type
129:06 - of the result and so on. So a lot of these
discussions on operators the very basic arithmetic
129:12 - operators on these variables, particularly
the integer and float variables, we will see
129:16 - that in the next video, so hope to see you
in the next video. So in the last video, we
129:22 - saw variables and we particularly saw integer
type variable and floating point, variable
129:29 - type. We also saw very briefly on Jupyter
notebooks are complex, and string as well.
129:37 - So in this video, we are going to talk about
operators, basically the arithmetic operators.
129:43 - Obviously, if you are defining variables,
you're not defining the them the variables
129:48 - just to just to view them later on. Most probably
you will be storing data to the variables
129:54 - and then you are you're applying some computation
on a set of variables together. Comparing
130:00 - new results saving that and doing some stuff,
most probably you will be adding to variables
130:05 - some one way or the other in inside a program,
you may have to add two variables, you may
130:10 - have to subtract a variable from the other,
you may have to divide a variable you may
130:15 - have to compute for example, these are arithmetic
operators, let me let me just this this plus
130:20 - symbol is used to add to variables. This minus
symbol or subtraction is used to subtract
130:25 - a variable value from the other variable value.
Obviously, these all are operated on values,
130:31 - not the names. Division, it like like the
name suggests, it's if you want to divide
130:37 - this this person to a symbol when it is applied
to two different variables, if x is on left
130:44 - and y is on right, what it does it, it actually
divides x by y, and checks what the remainder
130:52 - is, for example, if x is 27, and y is five,
then what's the remainder? What do you think?
131:01 - If we divide 27 by five, what's the remainder
the remainder will be? Two Yes, so the result
131:07 - will be two here. So this computes the remainder.
This multiplication this star symbol is used
131:13 - as multiplication like in mathematics, we
normally write this cross symbol. But in in
131:19 - Python, and in most of programming languages,
Star symbol is used to achieve multiplication.
131:25 - This double slash is like the division, but
it is division with the result flow to the
131:33 - quotient. What I'm saying is the following.
For example, if you divide, let's say 10.
131:42 - by three, the result will be a floating point
number, and the result will be 3.33. Something
131:48 - like so. But if you want just the quotient,
not the remainder, if you want the integer,
131:55 - that's the quotient value, then you write
the double slash three, and it will return
132:01 - just the value that is that is there before
the decimal expansion. So this value will
132:09 - be returned. So this is kind of the integer
division or floor division, this double star
132:14 - is used to compute the power. For example,
if you want to compute to the right doublestar,
132:20 - four, that means two raised to the power four
in mathematics, we write this as following.
132:26 - And the result will be 16, you can save that
result in another variable, or you can just
132:32 - print it or you can write that in a file of
whatever. So these are most important. operators.
132:41 - One thing that I want to tell you that these
operator are not just for integers and floating
132:46 - point numbers, the applications of these operators
is much broader than these later, we will
132:53 - see the objects or the data types that are
collections. And very, I mean, the data types
132:59 - that are beyond these integers and floats,
and still there, this plus minus division,
133:05 - and all some of these are all of these, they
have their meanings there. Even even even
133:10 - this plus is used for strengths. Now think
for example, if you have a string, let's say
133:17 - hello.
133:19 - And you have another string, for example,
let's say this is string s one, and you have
133:23 - another string, let's say s two, which is
why then Python allows you even to add these
133:32 - kind of data types, although some doesn't
make any sense with these kinds of string
133:39 - variables, but we will see four different
kinds of data types. The the definition of
133:45 - these operators, they actually changed or
adapted accordingly. For example, in mathematics,
133:51 - we are much more fluent a four with plus with
Debian with subtraction, and it makes sense
133:56 - to add two integers to subtract a floating
point number from another floating point number
134:01 - and stuff, but with data type that is unfamiliar
to you right now, these operators may not
134:08 - make that sense to you. But there are definitions
there, there are ways to use these variables.
134:14 - For the data types that are even there or
even beyond an integer and floating point
134:19 - numbers, we will see all these details as
we move on, as we move on to as we move on
134:25 - to the videos. And I mean, as in later on,
we will see all these things in detail, but
134:31 - just to tell you that these operators are
not just limited to integers and floating
134:34 - point numbers or complex numbers, they can
be applied to several different data types.
134:39 - So a lot of words, I guess you were born Now,
let's go to Jupyter Notebook and have fun
134:45 - with these kinds of concepts that we are dealing
with. So yeah, here. So let's first press
134:54 - escape, then m just to change it to markdown
and then good scape one for heading begetting.
135:03 - And here I write, let's say operators, and
shift enter its runs and automatically then
135:10 - go to code. Okay, now let's say I have a variable.
So let's say what kind of variables I already
135:16 - have. In the previous video, we use that.
So we already have these kinds of variables
135:21 - with us. Now, what is let me define a new
variable, let's say sum of sum of A, B, that's
135:33 - a new variable sum underscore AB, that's a
variable name, you can have a better way you
135:39 - will name maybe some of A and B, that might
be a variable name. It is good to have the
135:50 - variable names that are descriptive that describe
what data is inside. Because in in programs,
135:57 - the programs become manageable, readable,
and a lot of benefits are there. So Sum of
136:02 - a and b, let's say that's a variable name.
And you add a, b, you just write a plus b.
136:12 - Let me make the zoom level a little high so
that you can see it clearly. So a plus b,
136:18 - let's say that's there. If you press Shift,
enter, and now your brand. Some of By the
136:28 - way, if you have written some of you need
not write everything, just press tab, and
136:34 - it will automatically complete the remaining
part of the variable and press Shift Enter
136:40 - and you have eight. If you check the type
of this variable, some of tab automatically
136:49 - completes tab complete that is called tab
completion, while it's integer, the type of
136:55 - this particular variable is integer, that's
a new variable and why and the type is integer
137:00 - because a was integer, B was integer. And
integer plus an integer is an integer. What
137:09 - if we add an integer with a floating point
number? What do you think? What should be
137:14 - the result? If I just type type? A, that's
an integer plus d with some floating point
137:25 - number. So a plus d, the result will be here,
and type of that result. What will be the
137:31 - type of that result? What do you think? Let
me pause here for a few minutes, and oh, no,
137:36 - no, no, not for a few minutes. For a few,
maybe seconds, maybe two or three seconds,
137:42 - what will be the result? What will be the
type of an integer and a float combined?
137:48 - Well, the types are up costed, which means
the floating point number, the result will
137:53 - be a floating point number. And the reason
is, every integer by default is a floating
137:57 - point number, a floating point number is a
is an upper class, or you can say a superset.
138:03 - So in Python, in Python, by default, the types
are up costed to super super sets. So here
138:10 - integer plus a float, the result will be a
floating point number. And that's a result,
138:16 - you might be thinking why we have why we haven't
stored the result in another variable. Well,
138:20 - if we want to store the result in another
variable, we can, or if we just compute the
138:25 - result and apply some operation on that, we
can do that. For example. We could do the
138:31 - following, for example, a plus d. That's whatever
the result is raised to the power three, whatever
138:43 - the result is, whatever the result is, divided
by maybe four. And we just save that in a
138:55 - new variable. Let's say. Let's say the new
variable is V. Let's say we save that value,
139:02 - and V. And now we print we, and we have the
result for me. Wow. So we can do a lot of
139:11 - stuff with these kinds of variables. Let me
show you a fancy stuff that we will see later
139:15 - on. Don't worry if you don't get it just as
one, for example, as one is Hello. Hello,
139:22 - and let's say s two is world. And we have
another variable, let's say s, which is s
139:31 - one plus s two. What it will do is it will
just concatenate them together. We will see
139:39 - strings a lot later on. But just to tell you
this plus is not just for not just for numbers,
139:47 - it is for other data types, very fancy data
types that are there. One more thing, let's
139:54 - say we define 10 and we divide it by Three,
and we want a quotient, the quotient is three.
140:04 - However, if we have 10 divided by three, Shift
Enter, the result actually is 3.33, and so
140:12 - on, you might be wondering we have not saved
that result in a particular variable. So where
140:18 - the result is saved, actually, if you do not,
if you do not save the result, if you do not
140:23 - assign the result, for example, in this way,
the result will be assigned to a variable
140:28 - or, but if you do not assign if you do not
store the result in a particular variable
140:34 - explicitly, by default, there is a variable
in Python, which is underscore underscore
140:40 - contains the last result that you did not
store in a particular variable explicitly.
140:47 - So, that underscore is basically one default
variable for for the result, if you want,
140:55 - don't try to update this underscore, just
just read it Do not assign anything to underscore.
141:03 - For example, if you assign something to underscore
assignment will be done, but then the properties
141:10 - of underscore will no longer be there as they
are in in Python built in properties. Okay,
141:18 - so, that's about it, I guess. So that was
the operators, we will see the operators more
141:28 - and more later on. But before ending this
video, I leave you with a question. So the
141:34 - question is, we saw the variable names like,
Sum of a and b X, Y variable name can be can
141:43 - be lengthy can be descriptive can be short
anyways. So the question really is, can a
141:48 - variable name start with a digit? For example?
Is it possible that the variable name really
141:54 - is is starts from the variable name starts
from for example, a digit? is a 3x? valid
142:04 - variable name? Or, for example, at the rate
of at the rate of Why is that a variable name?
142:12 - Or, for example, this symbol times two times
x, is that a variable name? What are the conventions
142:22 - to for variable names? can we can we write
anything? In the left hand side? The right
142:28 - let's say 3x? Is equal to four? That means
3x is now a variable name. Is that true in
142:33 - Python? Or are there conventions to define
the variable names? So?
142:40 - Yeah, think about it. See you in the next
video with the answer to this. So I hope you
142:47 - will, you will be having answer for this question.
Hope to see you in the next video. Okay, so
142:53 - in the last video, I asked you a question
about the naming convention of the odd variable
143:01 - names. In particular, I asked you whether
3x is a proper variable name or not in Python?
143:08 - So what's your answer? Yeah. What do you think?
How many of say, how many of you say no? How
143:15 - many of you say yes? Well, by the way, you
might have tried that, declaring that variable
143:24 - name and Jupyter Notebook, and then you might
have got this answer one of these? Well,
143:30 - let me tell you, the answer is no. A variable
cannot start with a digit. Not with, not with,
143:39 - at the rate of not with hash symbol, not with
I mean, there are several
143:44 - other special characters are not there except
a few factors. One of those is underscore.
143:50 - Let's go to let's go to Jupyter Notebook and
and check this. So, for example, 3x equals
143:59 - five error, invalid syntax, let's say activate
of y equals four. Invalid star d equals four
144:21 - error. Well, an exception is underscore underscore
E equals six, that's allowed. Starting a variable
144:35 - name with underscore is allowed, it is different
than the underscore that is built in underscore
144:40 - this underscore E is different than simply
underscore. So it is good to not declare the
144:47 - variable names that start from these because
you will be getting errors further. variable
144:54 - names should be descriptive. They should give
you a look and feel of the data what they
144:58 - are containing and you're free to define variable
names, as as descriptive as you want. So it
145:05 - is a good practice to, to start writing the
variable names in a better way. One, one better
145:11 - notation, one better notation of defining
these variable names, even the function names,
145:17 - we will see the functions later on. One way
to defining those is to use camel notation.
145:23 - camel notation camel notation is you start
with the variable name with for example, lowercase
145:31 - letters, let's say your variable is starting
time of the course. Let's say that's your
145:40 - variable name. So you write starting, that's
one word finishes, then the next word should
145:46 - start from capital T, starting time of the
course, let's say. So this kind of notation
145:56 - is called camel notation. And very famous,
particularly the Java developers, they normally
146:00 - follow this and several other developers.
But you should come up with a notation that
146:06 - is one notation, there are other ways of keeping
consistently keeping the consistent strategy
146:13 - of defining variables. There are several other
ways this is one way. So starting time of
146:19 - the course is let's say 2.0. That's it. So
that's a variable name, if you if you now
146:27 - check, that's a variable name. But now, if
you see this variable, just just the name
146:33 - suggests the data inside is doing what? So
the names should be descriptive, I mean, and
146:41 - make that as a habit. So, yeah, I guess we
have now answered our question very concretely,
146:50 - that variable name cannot start with a digit
not with any special character other than
146:56 - underscore, okay. In the next video, I will
be introducing comparisons with with variables.
147:07 - For example, what if you want to compare whether
one variable is smaller than the other or
147:11 - not? What if you want to compare whether the
two variables they are containing values they
147:15 - are same or not? What if you want to do comparisons
of the of the data that is stored inside the
147:24 - variables, and based on the result of the
comparison, you want to do something else.
147:29 - So in the next video, we will see a bool data
type that is very, very famous, and it is
147:35 - used in a lot in decision making. And we will
see the comparison operator sometimes called
147:40 - the relational operators in the next video,
so hope to see you in the next video. Okay,
147:46 - in this video, we are going to talk about
a data type which is called bool. That's very,
147:54 - very famous data type. Actually, it's the
most famous data type because it is used in
147:59 - decision making all the control flow most
of the controls, so depends on this data type.
148:06 - Although it is very, very famous, very much
applicable data type, it is very simple. It
148:14 - is a data type with just two states with just
two values. By the way, there are capacities
148:19 - of different data types. For example, in T
integer, the
148:24 - different kinds of values that you can store
are huge, you can store any negative number
148:27 - in it, you can store zero, you can store any
positive number, the capacity of floating
148:32 - point number or the number of values that
it can save is is even higher than even higher
148:37 - than integer and the complex number is even
higher than that and so on. But the bool data
148:43 - type, it has just two states one state is
true. It has just two values. True is a value.
148:51 - And false is a value just these two straights
true or false. In some programming languages,
148:58 - the true is denoted by one, and the false
is denoted by zero. But in Python, the true
149:04 - is just t ru e true that thing and false is
false. That's it. If you For example, define
149:11 - a variable let's say any variable name, whatever
the name is, let's say B and you assign true
149:18 - then it's its default data type will become
bool. And if you have another variable, let's
149:24 - see which is false. Then C is also bool. One
thing that is important, there are other operations
149:34 - other than arithmetic operators that we saw,
adding subtraction division and stuff, there
149:40 - are other operators that we can apply on bool
datatype. For example, a true and and is a
149:48 - keyword combining true and true. If if there
is a variable, let's say a with a There is
150:00 - a boolean variable a with data true. If there
is a boolean variable b with data true, then
150:05 - a and b is also true. So let's say I've used
this variable D, in storing this A and B,
150:14 - the D will also be true. So true and true
is always true. Further true and false, this
150:28 - is always false. And this is committed if
for example, true and true is true, true and
150:35 - false is false, false and true is false, false
and false is false. So, if you apply an operator
150:43 - and keyword to combine the two Boolean variables
together, if both are true, then and will
150:51 - result a true otherwise and will result of
false other than this and there are there
150:59 - is there is another, there is another operator,
keyword or so, this results false. If both
151:11 - are false, false, false, false or false is
false. If any one of these is true, then the
151:22 - result is true. Remember the difference between
n and R and will result false if any one of
151:32 - the two operands at least one of the two operands
is false,
151:35 - then the result is false. If both are or are
anvisa true, if both of the operands are true,
151:42 - otherwise it is false
151:43 - or will result false if both of the options
is false or false. Otherwise it is true. So,
151:51 - you now know and you now know are there is
another operator called not. This is not so
151:59 - not for example, returns not true. Results
false and not false. returns true. Great.
152:12 - So knot is a unary operator. unary means it
just takes it just takes one variable and
152:18 - operate on that, and is a binary operator
like plus is a binary operator. It takes two
152:24 - variables to operate on, or is a binary operator
it operate, it takes two operators, it takes
152:30 - two variables to operate on and so on. So
remember, remember these things, one, and
152:38 - we'll return true if both of the variables
are true, otherwise the result is false, or
152:45 - will result false. If both are false. Otherwise,
it will return true and not is not just flips
152:53 - the the state. So not true means false, not
false means true. So these are basic, that's
153:01 - how you can combine the Boolean variables
together. In the next video, we will be seeing
153:06 - how to apply these comparison operators and
the result will be Boolean types. And how
153:12 - can we combine the Boolean types together
to to build a better decision making. So in
153:18 - this particular video, I just, I just introduced
the boolean data type for you with you. In
153:23 - the next video, we will see where the boolean
data type actually appears, and how it impacts
153:30 - our, our our programming style or thinking
style or coding style. So hope to see you
153:36 - in the next video with comparison operators
that actually produces the Boolean variables.
153:42 - Hope to see you in the next video. Okay, in
the last video, I discussed boolean data type
153:47 - and I discussed that a boolean variable takes
either a true or a false and we can combine
153:53 - these Boolean variables together with and
our operators. And then we can apply a knot
154:01 - operator on a particular variable. And we
we saw that a true and true returns true and
154:08 - and otherwise it also returns false. Similarly
false or false is false. Otherwise, or always
154:16 - returns of a true before before actually discussing
these comparison operators. Let's do let's
154:24 - just go to Jupiter and just just play with
a boolean data type. Just Just for just for
154:30 - a moment. Let us just convert this to markdown
cell and just cried. Both that's a word Boolean
154:45 - variable. So let's say A is true and B is
true and C is false. False. And okay, so these
155:03 - are variables. Let's press those to see what
are the states of. So, a is a boolean variable
155:12 - with value true B is a boolean variable with
value true C is a boolean variable with value
155:17 - false. So, now it is true B is true, C is
false. So that means, let me print print a
155:25 - and b, what do you think? What is what will
be the result? Let me print a and see what
155:34 - will be the result. And let me Brent? C and
A. So because a and b both are true, the first
155:46 - result will be true, because C is false, false,
true and true is true. The the other two statements
155:55 - they will result false. So first value will
be true, then false false. So yes, true, false
156:01 - false. Let's, let's check the or print. And
by the way, let's store that are in another
156:09 - variable, let's say A is true, or C is false.
So what do you think what will be the result
156:16 - here, because or gives false when both are
false, here is true. So the value of d will
156:24 - be true
156:26 - for the not a, because A is true, not a will
be false. Similarly, not B, B is true. So
156:39 - not B will be false. Not C, C is true, C is
false, and not c will be true. Similarly,
156:48 - not D, we can save the result in another variable,
let's say D. and we can just check the type
157:00 - of D if we want, that's a Boolean, we can
also check the value inside D and that is
157:07 - false. So, yes, not only that, I mean, we
can we can we can we can combine at a higher
157:15 - level for example, A and A and B, whatever
the result is, or C or D, whatever the result
157:26 - is, and whatever the result is not of that.
I mean, we can we can combine them in a very
157:34 - complicated way. If we want a and b the result
will be some Boolean, that Boolean and that
157:40 - Boolean there
157:41 - are the
157:42 - result eventually will be a Boolean, and then
not have that. So let's check what if that
157:47 - is the result is false, well, why the result
is false. figured out why the result is false,
157:55 - let me go to comparison operators. So, the
comparison operators, let me just go through
158:04 - comparison operators. This equal equal to
it compares whether two variables whether
158:09 - whatever the variables are whether they are
integer floating point, whatever, whether
158:13 - two variables are are, they have same data
or not, for example, x equals equals two y.
158:22 - That will be true if x and y, they both have
same data. So for example, if X has value
158:31 - four, and y has value four, then we are just
checking x equals equal to buy or not, the
158:36 - result will be Boolean. Because an X may not
be a boolean variable y may not be a boolean
158:43 - variable. If we want to compare the values
of x and y, then we write w equal without
158:48 - a space inside. Remember, if we write single
equal that will be an assignment operator.
158:54 - If we write w equal that means we are checking
whether the two values are same or not. Similarly,
159:00 - if we write this particular symbol that checks
whether two values are not equal or not, for
159:06 - example, x is not equal to y, the result will
be true if x and why they both have different
159:14 - values, otherwise the result will be false.
Remember, the result of comparison is always
159:18 - a Boolean, it is either true or false. Okay,
next we check whether less than So for example,
159:25 - if x is less than y, the result will be true.
If x indeed has a value that is smaller than
159:33 - y, let's say x is two and y is 10. In that
case, the result will be a true otherwise
159:38 - the result will be false. Similarly, we can
compare the two variables using greater than
159:43 - we can compare the two variables by less or
whether whether the whether one variable less
159:49 - or equal to the other. For example, if X is
less or equal to y, the result will be true
159:55 - of this comparison the result will be true
if X has a value that is not larger than why
160:02 - as long as x and y are equal or x is smaller
than y In any case, the result will be true
160:07 - otherwise false. Similarly, greater than or
equal to. Okay, so I end this video here in
160:15 - the next video, we will be, we will be moving
to Jupiter and playing with these operators,
160:21 - and seeing the return types of Booleans. And
then combining them together with ands and
160:27 - ORS and doing doing interesting stuff with
that. In this particular video, I just talk
160:34 - about the comparison operators, the boolean
data type and combining them by and or not.
160:40 - In the next video, we'll be first moving to
Jupiter, we will see the comparison operators,
160:45 - we will write all these statements in Jupiter
and just get a good hands on grip on that.
160:50 - And then we'll be moving on verse. So hope
to see you in the next video. So in the last
160:55 - video, I talked about comparisons, w equal
to not equal to less than, greater than, less
161:03 - than or equal to, greater than or equal to.
So let's go to Jupyter Notebook and see how
161:08 - they actually work. So let me just first enter
a markdown cell and type comparisons. Shift
161:23 - Enter comparisons. So we can we can compare
different values by first assigning them to
161:34 - variables. And then comparing those variables
or we can we can compare the values directly
161:41 - or for example, rent. Two is less than three.
What do you think two is lesson three, the
161:52 - result will be what Remember, the result of
a comparison operator is always Boolean, it
161:57 - is either true or false. So in this case two
is smaller than three. So the result will
162:03 - because this statement is true. So the result
will be true and true will be counted. Further,
162:10 - we can store that result in in another variable
for example to is smaller than three, whatever
162:16 - the result is, the result will be true, the
result will be saved in a variable, see, if
162:21 - we check the type of see
162:26 - reject the type of seeing as long as let's
print the value of C. So you can see the type
162:37 - of C is Boolean, and C in this particular
case is true. Moreover, for example, let's
162:45 - have three equals to four. Is that true or
false? What do you think three equals to four,
162:56 - three, w equals to four, that is false, three
is not equal to four. And let's save this
163:03 - result in D, remember three double equals
to four, that's an operation the result is
163:09 - false. This equal is an assignment operator
that the false value will be assigned to the
163:17 - variable D. and here we can see Brent D. Burn
it is false. Similarly, what do you think?
163:28 - Three double equal to 3.0? What will be the
result? Remember, three is integer. 3.0 is
163:41 - a floating point number. And I'm comparing
three double equals to 3.01 is integer, and
163:48 - other is a floating point number. So what
will be the result? Let's say the result is
163:53 - true, because they are comparing the values
by discarding the decimal position. Further,
164:02 - let's see. Three is smaller or equal to so
let's say x is equal to four, y is equal to
164:13 - nine. And z is equal to let's say 8.3. And
r is equal to minus three, let's say and these
164:28 - are our variables. Let's see. So what do you
think what will be the result here x is smaller
164:36 - than y. What will be the result of that x
is smaller than y, the result will be true
164:44 - and z is smaller than z is smaller than y.
The result is again true because the smaller
164:57 - than y or r r is r is equal to for example,
x. So what do you think what will be the result
165:14 - at the end after this, so, let's see first
first this will be true, this will be again
165:22 - true, and that is false. Okay. So, this true
and true will return true and true or anything,
165:35 - the result final result is true. So, this
will return or it's returning true. But, if
165:44 - I just do if I just switch the order, for
example, if I just write this statement, which
165:54 - is false, this particular statement here and
then I do this, what will be the result now,
166:03 - Now see, x is smaller than y it is true, r
is equal to x that is false. So, this result
166:14 - will be false eventually, and z is smaller
than y, that result is z is smaller than y,
166:23 - let me just say z is larger than one, let
me just check z is larger than y, z is larger
166:31 - than I just just do just to tell you. So,
this is true, this is false. Both of these
166:40 - are let me let me switch the let me switch
the listing r equals to x, I just want to
166:48 - show you the precedents of r and x is smaller
than y. So now, if you see this is false,
167:02 - this is true, false and true is true, true
or false and true is false, this is also false.
167:15 - And the result overall is false. It should
happen, but what if, what if this goes first,
167:23 - if this goes first, I mean, I want to show
you whether and an AR, which one of them will
167:29 - operate first. So, in this particular case,
the result is false, but it can happen let
167:35 - me let me tell you this in more and two, or
false and true or false. And
167:51 - true,
167:54 - what do you think what will be the result
here, true or false and true, if true or false
168:01 - operate operate First, if true or false operate
First, the result will be true, true and true,
168:07 - the result is true. If however, let me let
me just write a false here. If all operates
168:16 - First, if all operates first, then false or
false is false and false and true is the result
168:24 - eventually is false. And if and operates first,
then false and true is false, false or false
168:34 - the result in both cases here is is false.
So, a better way of representing these kind
168:43 - of sometimes sometimes they can make confusions,
sometimes they can make confusions, for example,
168:50 - if we have a true here, if you have a false
here for example, false and true
168:56 - How can I so, false, false and false or true.
So, in this case, if in this case, if false
169:23 - or true that operate First, the result will
be true and false and false, false and true
169:32 - the result will eventually be false. However,
if n operates First, the result will be false
169:39 - here, false or true the result will be true.
So, here if and applies if you apply if n
169:47 - is applied first, then the result overall
result will be true. But if all is applied
169:53 - first, then the overall result will be false.
So it is it is good to know whether and will
169:58 - be applied first or off will be applied first
in this particular case and will be applied
170:03 - first even if you even if you change this
even if you change this order for example,
170:07 - if you even if you pick this thing and apply
here still the result is and will be applied
170:22 - first and or will be applied after, it is
always good rather than to one way is to remember
170:29 - the precedents and will be applied first then
or, I mean it is good to think about the precedents.
170:35 - Another good thing is to specify the order
using parentheses. For example, now, we specify
170:41 - this first our will be applied and then four
and will be applied. So, it is good for readability
170:46 - to always apply these parentheses and and
check the order in which ands and ORS and
170:51 - the combination will be applied. So, the in
any way the result of these comparisons will
170:58 - be bullions. Question, what will be the result
here? So, not to not equal to three and true
171:11 - or false and true. See this slide for a while.
Even if you want to pause the video, pause
171:17 - the video, see it? and answer the Brent will
return true or false. okay with this question,
171:26 - I end this video. In this particular video,
we just saw the comparisons on Jupyter Notebook.
171:31 - Just see how the comparisons return true or
true or false. We combine the different tools
171:35 - and different Boolean values using ands and
ORS. And here is a question for you. Okay,
171:43 - I will see you in the next video with answer
of this question. So I left you with a question
171:49 - in the last video. So that was the question
if you remember. So the question really was,
171:55 - what's the what's the result here? So what's
your answer? True or false? The result, either
172:03 - will be true or false, because these are all
comparisons and combination of Boolean values.
172:10 - So let's see step by step. First of all, let's
see this two is not equal to three The result
172:17 - is two is not equal to three Yes, it is true,
two is not equal to three That's true. So
172:24 - not true not true is false. So, this is false.
So, this whole thing is false. Now false and
172:43 - true false and true that is false. So, this
whole thing here till here is false. Now we
172:55 - have or or and then we have false and true
false and true is false. So, this whole thing
173:09 - is false this whole thing is false and or
between false or false it is false. So the
173:16 - result of this. So the So the answer to this
question is is false. Let me let me just convince
173:24 - you by typing the statement in in Jupyter
Notebook. So, if you remember we have Brent.
173:34 - Brent, not two is not equal to three and then
we were having I guess and false and yeah,
173:49 - that was a different one. And true, sorry,
that was and true. So this was and true, then
173:59 - we were having our
174:01 - and then we were having these false and true.
So the front ends here and the result is Oh,
174:12 - I have some I have some parenthesis mismatch.
So not true and this okay, I should have this
174:21 - one I guess this goes to there and this goes
to there and I guess Yes. So the result is
174:31 - false. The result is false. The purpose of
this question was not just to the purpose
174:40 - of this question is to appreciate actually
the fact how we can combine different Boolean
174:46 - values to to to achieve the final boolean
value and these kind of combinations will
174:51 - become very, very helpful further in in control
flow and we will see the if conditions and
174:57 - decision making and stuff so The answer to
this question is false. Yeah, and I end this
175:05 - video here. In the next video, we are going
to see some useful functions of Python. And
175:14 - after seeing the some some kind of useful,
there are a lot of functions, we will see
175:19 - just a few of them very useful of them. And
after seeing those functions, then we will
175:25 - directly jump to control flow basically the
if conditions and stuff where you will see
175:30 - these comparisons, these Boolean values in
a much more applicable sense, then then earlier.
175:36 - So hope to see you in the next video. Okay,
so let's have a very quick tour over some
175:43 - some useful functions in Python. Obviously,
there are a lot of functions in Python, but
175:49 - I will be covering just a few of them. That
I think with the passage of time, we will
175:55 - be covering more and more but let's start
a function are sometimes, particularly a built
176:01 - in function is is basically a feature from
the language that is supplied for the users
176:09 - to achieve particular task. For example, around
function. If you give round for example, around,
176:18 - let's say 4.6. This 4.6 is a floating point
number, and rounding means make it as integer.
176:27 - And what round does is it finds the nearest
integer to 4.6. And the nearest integer in
176:34 - this case is five, because five is more closer
to 4.6, then four. However, if you call round,
176:40 - for example, on four point, let's say three,
then the result will be four, because four
176:48 - is more closer to 4.3, than five. So that's
one use of round eight rounds, basically rounds
176:53 - a floating point number to the nearest integer.
Another use of round is if you give another
177:03 - argument that that is called an argument to
the function. For example, when you write
177:07 - Brent. Brent, let's say a, this a is called
argument to a function Brent. Similarly, round
177:17 - is a function 4.6 is an argument round is
function 4.3 is an argument, we will see functions
177:23 - in details, and we will be writing our own
functions as well. But for now, just just
177:29 - bear that just bear with me that functions
are these kinds of features that are available.
177:34 - However, we we will be writing our own functions
later on. So this particular function accepts
177:42 - two arguments surround has two different kind
of implementation. One is when it accepts
177:48 - only one input argument, it returns the nearest
integer to that, if it accepts a floating
177:54 - point number as well as another argument like
here we have three, that means after after
178:00 - point, after decimal, go to three places only,
and then round up, then round, for example,
178:07 - this 4.55 and then eight will be rounded based
on its next value. If the next value is larger
178:15 - than five, then eight will go to nine and
stop. If the next value is smaller than five,
178:20 - then it will stay as eight and the result
will be three decimal places after this. So
178:27 - let's practice this round function just on
a Jupyter Notebook very quickly. Let's see.
178:33 - So here we are. So let's see rent around,
let's say 4.556. And in this case, the result
178:51 - will be 4.5. And the reason is 4.5. And it's
rounded up, it stays to five and the reason
178:59 - is this 4.556, it is more closer to five then
179:03 - than four. However, if you if you just print
round, four point, let's say 345. Let's see,
179:14 - and the result will be for the reason is 4.345
is more closer to four. However, if you call
179:22 - this round function with more than one argument,
for example 4.556789 let's say or with argument,
179:33 - let's do that means the result should be only
two decimal places after the after the decimal
179:40 - point. So in this case, the result is 4.56.
And the reason is, this five is rounded based
179:49 - on the next digit and the next digit is larger
than five. Hence it is rounded up. So 4.56
179:55 - If however, I call this function for three
Then what do you think what will be the result
180:02 - it will be 4.55. And the six will be rounded
up based on the seven, and it will become
180:07 - 4.557. Yes. However, if, for example, there
will be a value at at the place of seven,
180:17 - if there is a value, let's say three, then
you call this function, then 4.556. And then
180:25 - based on the next value three, the six will
stay as six rather than going to nine, and
180:29 - the result will be 4.556. Yeah, so that's,
that's the, that's the round function. Basically,
180:37 - another function is diff mode, diff mode function
basically divides and returns quotient, and,
180:44 - and remainder. So in the next video, we will
be seeing this diff mode in detail how it
180:52 - actually works and how, how it is useful.
So in this particular video we saw around
180:59 - function in the next video, we will see diff
mode, and there are a couple of more functions
181:03 - that we will see in the upcoming videos. So
hope to see you in the next video. So in the
181:07 - last video, we saw round function that sometimes
accepts one argument and sometimes accept
181:13 - two arguments and behave accordingly. In this
particular video, we are going to see another
181:18 - function dev mode. And it accepts two arguments,
two different arguments, but maybe same or
181:25 - different arguments. And it it returns two
outputs, two numbers, two terms basically
181:32 - quotient and remainder. For example, in this
particular case, the quotient is five, and
181:38 - the remainder is two, because if five is divided
by if 27 is divided by five, the result is
181:44 - five, but then the remainder is two. And the
result is returned in a kind of an ordered
181:50 - pair. And these kind of collection in which
we have two or more elements, we call these
181:58 - collection as tupple that we will see in detail
when we will see the data structures module
182:05 - of this course. But right now just bear with
me that it returns two numbers, two elements,
182:11 - and the two elements are ordered in an ordered
pair, which is called a tupple. A tupple is
182:17 - not just an ordered pair, it can have three
more three, four, or five or seven, or maybe
182:21 - several elements. But right now we will a
tupple is just an ordered list, which we will
182:27 - see in detail. So let's see the working of
the stiff mode function in in Jupyter. notebook.
182:35 - Let's see. So let's say we have dev mode.
Let's say for example, we have 34. And then
182:48 - we have lots of them. Or maybe let's say nine,
so what do you think what will be the quotient
182:54 - and what will be the remainder. So 918 27
So three, three is the quotient. And the remainder
183:02 - is remainder is seven. So three is quotient
and salmon is the remainder. So and if you
183:10 - save the result, for example, if you save
the result in a variable, let's say G. So
183:15 - if you see the G the type of G if you if you
just type the type of if you just find the
183:21 - type of ci it's a tupple, which we'll see
in details, and if you see the contents of
183:26 - G if you see the contents of G the contents
of gr three and salmon, and if you want to
183:32 - access each element independently, then you
can access the element first element, because
183:38 - the if there are multiple elements in in a
variable normally that that kind of variables
183:44 - are called collections that we will see in
detail later on. And these are the indexing
183:50 - the positioning is start by zero rather than
one. So g zero means the first element of
183:56 - G which is three in this case, and the second
element of G is one
184:02 - at one, which is seven. So, this is basically
this is called the index or position of of
184:10 - elements or data in this particular collection,
we will see these indexing and all these kinds
184:16 - of collections in detail in in the in the
data structure scores, and we will see arrays
184:22 - and strains and different kinds of structures.
But and default sometimes is, is basically
184:31 - sometimes it is helpful. By the way you can
achieve dev mode by by another by another
184:37 - thing. For example, if you want to achieve
a more 34 nine, you can do the same thing
184:43 - by let's say 34 divided by double divided
by nine that will give you a quotient. And
184:49 - the question is three and further if you write
34, remainder nine and that will give you
184:54 - the remainder that you need. So you can call
that function Dave mode. Or you can use these
185:01 - two there are multiple ways of doing the same
stuff. Okay? So, yes, so, I mean, sometimes
185:08 - it's useful when you're going and knowing
this kind of function that returns quotient
185:13 - and remainder. Okay, next function that is
more useful is is in stance, and we will see
185:21 - this function in the in the next video. So
hope to see you in the next video okay, this
185:28 - function is in stance, it actually returns
either true or false. And it just checks that
185:37 - particular given data value belongs to this
type or not. For example, if you want to check
185:43 - whether one has type integer, so, you can
check that using this function by the way,
185:50 - you know that one is of type integer then
you may think that why on earth one should
185:57 - be interested in checking the type of one
if somebody no it is in teacher, sometimes,
186:03 - we have certain variables and certain data
is stored in it, and we want to check the
186:08 - data inside it belongs to which kind of type
and in several cases the value to this variable
186:16 - is not assigned by us It may be read from
some file or maybe through input a user give
186:23 - some number or something like so. So, sometimes
it becomes important to check the type of
186:29 - a particular way if we are if we are expecting
a particular type of the input and the input
186:35 - is different than this function might be helpful.
somewhere. Either way, this is a function
186:41 - available in Python and it checks whether
the given value has a particular type of not.
186:48 - So is instance one int returns true is instance
1.0 integer that returns false maybe, because
186:56 - this is a floating point number, and you can
check a particular value belongs to one of
187:02 - the several types or not, you can give several
types in a in a tupple. And you can check
187:07 - whether it belongs to this, this or not. So,
let's go to Jupyter Notebook and see, actually
187:14 - how it works. So, by the way, this is the
same notebook that we have, that we are populating.
187:21 - So, hold on with me, at the end of the day,
we'll be having one notebook complete. So,
187:28 - is in stance is instance, let's say three
is that instance of integer The result is
187:38 - true in this particular case, if for example,
we check whether is in stance 3.4 is that
187:51 - nmt? Is that an end user? The answer is no
it does not end in Deezer. If for example,
187:58 - we check if this is not in nature, then maybe
it is a float? The answer is yes. Or maybe
188:04 - we check that. For example, if that value
is either float or integer, if it is one of
188:13 - these, then I mean check that particular value
in this particular case 3.4 whether it belongs
188:21 - to one of these types, we can increase these
types, for example. So, let's say we we gave
188:29 - a complex number here and check is in stance
let's say two plus three j that's a complex
188:38 - number. And let's say we asked whether it
is an integer or float or not, the result
188:42 - is obviously false. And the reason is, it
is neither integer nor float or even if we
188:48 - give string there str, so, it will still say
no it is not
188:54 - not any of these, but maybe there is a complex
data type if you see that, that says yes,
189:00 - because it is complex. So sometimes this is
instance becomes really useful. Next function
189:08 - is power. So power you can you can compute
power by the way using using for example,
189:14 - if you want to compute x raise to the power
y, you can use double star and that computes
189:20 - exactly x raised to the power y or equivalently
you can call the function POW x comma y and
189:27 - that will give you the same result as this
one. But power sometimes take three arguments
189:33 - as well. And in that case, it it a it performs
the power function in a different behavior.
189:40 - So for example, if you supply three arguments
what it does it it raise y to equate x raise
189:48 - to the power BI whatever the result is, then
it takes the remainder by z and gives the
189:54 - result. So let's see the functioning of this
power function in Jupyter Notebook. So let's
190:02 - say Baba, I want to compute to raise to the
power for the result is 16. No problem. To
190:09 - raise to the power four, I can compute the
result 16 this way as well. But here is another
190:14 - way, how can we use this to raise to the power
for whatever the result is, then I want to
190:19 - take the remainder, by let's say, I want to
take the remainder by seven, or two, so we've
190:26 - got four is 16, then if we take the remainder
by seven, the result will be two. And that's
190:31 - the result two. So that's how you can use
this power function. I'm just introducing
190:36 - you some built in functions that are available,
there are so many functions that are available,
190:41 - I'm just getting you comfortable with these
kinds of functions so that in future if you
190:46 - see another function that he had not seen
here, you'll be able to use it and apply it.
190:54 - So in this particular video, we saw this is
in stance function and this power function.
191:02 - In the next video, we will see one more function
that will allow you to take input from the
191:06 - user. So far, we are supplying values or assigning
values to variables directly, what if on the
191:13 - fly, we want to give the values and those
values should be assigned to the variables.
191:17 - So in the next video, we will see the function,
we will see a function that will allow you
191:22 - to give input from the keyboard, hope to see
you in the next video. So in this video, we
191:27 - are going to see a very important function
called input. This function is I mean, this
191:35 - is beneficial for taking input from the keyboard
from the user. And the way to call this function
191:42 - is you type input. And then you type a message
that actually describes the expected entry
191:51 - that for example, into something if you want
somebody to or tell somebody to just incur
191:57 - let's say, a number, you can write into a
number, or any specification to help the user
192:02 - to enter whatever input the user want to interest
properly. One thing is that no matter what
192:09 - the user will enter, the variable a will be
having type string, str. So even if you enter
192:19 - a number, let's say 12, or 34, or whatever,
that will be received as a string. And then
192:26 - there are ways to convert string to number
if that really was a number. So whatever you
192:31 - receive using input function will be a string.
And then there are ways to deal with that
192:37 - string, if that was a number, how to convert
that string to a number, and, and so on. So
192:43 - for example, let's see, let's see on the Jupyter
Notebook, how it works. So let's see, for
192:51 - example, x is equal to input, enter a number.
Let's see. And then then if I press Shift
193:04 - Enter, a prompt will appear in front of you,
that will require you to enter a number for
193:10 - example, if I enter, let's say 56, and then
I press enter, not Shift Enter, Enter, then
193:18 - x will receive 56. Now, you might be thinking
this 56 is an integer, so the type of x should
193:24 - be an integer. But this is not the case the
type of x will be a string. And the reason
193:31 - is, whatever you enter is received as characters
five and six, even if you have entered something
193:37 - else that would have been received as a sequence
of characters. So this is no longer a five
193:43 - as a digit five, six as a digit six. These
are some characters sequence of characters.
193:48 - Now, if you want to,
193:49 - I mean, there are ways to convert this x,
for example, maybe you want, let's say, y
193:57 - or x as int x. So this means you have now
converted this string to integer and then
194:08 - whatever the result is, you have stored that
result in x again, if you now see the type
194:12 - of x type of x, the result is integer. And
you can for example, print x minus 34. And
194:24 - the result is 22. Because X was X was 56.
So this input function is I mean, it is an
194:36 - one way by the way, if you if you're expecting
an integer or a float value, for example,
194:40 - let's say you're expecting a float value,
then it is good to write input, let's say
194:47 - enter a real number, maybe or any message,
any message and then at this particular time
194:55 - at the time of import, then it is okay to
convert that thing to float and it will become
195:03 - a float. Yeah, that's it. So, now, for example,
you enter 12.5 if you see the type of a now,
195:14 - type of a will be float okay. But there are
problems for example, if you are if you are
195:21 - expecting float and somebody enters into something
that is not float for example, a or let's
195:29 - say B equals load, input enter are real number,
let's say and then you press Shift Enter and
195:41 - somebody just interest let's say ABC. So,
now, this is not a float ABC cannot be converted
195:48 - to a real number no matter what. So, you will
catch an error there are ways to avoid these
195:55 - kinds of errors and programming program breaks
using exception handling and there are other
196:01 - ways, but be careful I mean the user is not
I mean the one who is going to enter the the
196:10 - enter the input if that that user is not restricted
enough, then you can get errors. So, I mean,
196:20 - this is not the case that whatever you will
enter it will be converted to a float if it
196:23 - really, if whatever you have entered is really
to convert it is really convertible to a float
196:28 - then it can be convertible to a float, not
otherwise. And at the input time, there is
196:33 - no restriction you cannot restrict the keyboard
to enter water or whatnot, although there
196:37 - are ways although there are ways to do that.
So that's about the input function. So, we
196:46 - have seen some of the functions, let me just
let me just go through quickly we have seen
196:53 - input we have seen is in stands, we have seen
diff mode, we haven't we have seen power function,
197:00 - we have seen the round function and there
are several others. Yes, so from now on, we
197:07 - will be actually moving towards basically
decision making based sometimes we will use
197:15 - these kind of functions, mostly you will be
using input function, but sometimes we'll
197:18 - be using maybe other functions like these
functions. And sometimes we will be doing
197:25 - decision making based on the ease and and
stuff like so, one thing that I want to tell
197:29 - you is if for example, you know the function
name, some function, let's say like power,
197:35 - you know, that POW power is a function, but
you do not know how to use that function.
197:41 - One way is to just type question mark in front
of it, and then just press Shift Enter,
197:48 - and in front of you, the documentation of
the power will open up so it will tell that
197:54 - this is power, that's how it should be called
and then some description will be in front
198:01 - of you that equivalent to x raised to the
power y with no arguments, the two arguments
198:07 - are equivalent to x raised to the power y
remainder with z with three arguments and
198:11 - so on, if you want to see implementation of
this function as well. We will see the functions
198:18 - later on but if you want to see more about
the help, you can type the double Sam equal
198:24 - a double question mark and more things should
be open up in front of you. So, in this particular
198:37 - case, the small function does not have an
implementation in Python. So, the single question
198:44 - mark and double question mark are the same
at one more way is to use the help function
198:53 - help out and you will get a lot of information
about the power how for example, help on built
199:02 - and function power in module built in. So
this is power this is equivalent to this some
199:06 - key types and stuff like so, or for example,
you want to know how can I use the input function
199:13 - for example, so you can write help on input
and this is how this can be used. So sometimes
199:21 - it is okay if you know the if you know the
name of some function, and you know how to
199:25 - use it, you can just open up the documentation
right here in Jupyter Notebook by either using
199:30 - a help function or you can use just a question
mark in front of the name and so on. So, that's
199:39 - about the functions. In the next video, we
will be seeing the power of comparisons and
199:46 - the decision making or sometimes called the
control flow. So the real fun will begin from
199:53 - the next video because we will be actually
deciding which part of the code should run
199:59 - and which part should Not run based on based
on certain conditions. So hope to see you
200:04 - in the next video. Okay, we are in control
flow, the most interesting part of any programming
200:13 - language will assume that you have two numbers,
you have taken two numbers from the user a,
200:21 - you've taken that number from the user using
input, I have not supplied the input message
200:29 - here, the message is optional. It's a description
if you supply that that's okay, if you don't
200:34 - supply even that, that's okay. So A is some
number the user will supply when the code
200:39 - will run B is some number the user will supply
when the code will run. Now, once you have
200:44 - a and b in front of you, obviously the user
will supply that on the fly, you don't know
200:49 - what the value of a and b are. Because when
the program will run, only at that time, the
200:54 - A will be populated and B will be populated.
Your task is whatever the value of a is that
201:01 - is that you don't know whatever the value
of b is that you don't know, the user will
201:04 - supply that value those values, your task
is to print the value that is bigger than
201:09 - both. So for example, if a is bigger than
B, then print a if b is bigger than a, then
201:15 - print B. So whatever the bigger value is,
print that value. Let's say that's your task.
201:21 - How can you do that? So the question is how
does Python allows us does Python allow us
201:30 - to do that, for example, if a is bigger than
we should print a, if b is bigger than we
201:37 - should print B, remember again, and again
we are we are talking in terms of if A is
201:43 - bigger, if so this is this is this is what
if a is larger than B, then this condition
201:51 - will be true. This is like the comparison.
So this is true, but then we must have an
201:56 - F condition as well. If A is bigger than to
what, so if a is bigger than B, then do certain
202:05 - things. Otherwise, don't do that. Those kinds
of things. So this if condition is really,
202:10 - really powerful, and is available in all programming
languages. In here, for example, let's see
202:18 - if a is an input B is an input, writing an
if condition, that's if is a keyword. That's
202:25 - a comparison that we have done earlier as
well. And then the syntax required a colon
202:30 - in front of that. So if this condition is
true, if this result, if this comparison results
202:36 - to remember the comparisons, they return Boolean
values, if this comparison, if this, whatever
202:44 - the result of this operation is if that is
true, then you go into this block. And whatever
202:51 - the statement inside is do that, for example,
print b is greater than a.
202:56 - Now my question is, is that is that done?
Are we done with the task, the task was to
203:03 - print the bigger number. If b is greater than
a, then B will be printed then or they might
203:11 - have printed, for example, we might have printed
rather than writing this we might have might
203:15 - have printed, let's say just print B because
b is bigger. If b is not bigger than a, what
203:24 - will? What we will do them. So yeah. If b
is bigger than a then B will be printed? Yes.
203:33 - Because then you will be inside here. If b
is not bigger than if this condition is false.
203:39 - We will do what then? So that's a question.
So right now I'm just coding this in Jupyter.
203:46 - notebook. And then we will see how can we
deal with that if b is not bigger than a kind
203:51 - of condition? So let's first see the blessings
of if condition and Jupyter Notebook. Yeah,
203:58 - so let's say a is an integer. Let's say you're
expecting an integer input. input, let's say
204:08 - and then you write if, let's say B is again,
an integer input maybe. And let's say if a
204:20 - is greater than b, then print a. That's it.
That's your program. Remember, this indentation,
204:30 - I have not written this print here. This is
the indentation that defines the block of
204:37 - a let's say if I want to print a, then I want
to print, let's say, I am still inside. If
204:47 - condition, condition, and so whatever that
starts from this, whatever that starts Form
205:01 - whatever that starts from this alignment,
if I write something here, let's say x is
205:09 - equal to five, all that block all that block
is called the body of the if condition, if
205:15 - it starts from this alignment, If however,
I I typed a statement, but I typed that statement
205:24 - in that kind of alignment, the alignment like
this, this is no longer inside the if condition.
205:30 - So, for example, here I type I am outside
the if condition. So, the purpose of writing
205:40 - these multiple lines is just the if condition
does not require to contain only one line
205:45 - of code, it can contain a whole block of code
multiple lines of codes. So, this is no longer
205:52 - inside the if condition. So, now we will take
input a input B, whatever the numbers will
205:57 - be, if the value in a will be larger than
B, then this will be printed and this will
206:03 - be printed. Once these two are printed, then
this has to be printed regardless of the values
206:09 - of a and b, because this does not this last
sprint statement, it does not depend upon.
206:15 - This does not depend upon the values of a
and b, it has the if condition has no impact
206:20 - on that, that is just a sequence of statements.
the if condition, the statement inside the
206:24 - if are just these two. For example, if a is
not bigger than B, then neither this will
206:30 - execute, nor this will execute. But this will
still execute because this is this has nothing
206:36 - to do with the condition. So let's run this
code and see how it works. So let's set the
206:43 - value of a see the power of descriptions.
If we could have written a description, then
206:48 - the description could have been could have
appeared here. But let's say this is the value
206:52 - of a let's say 12. The value of b let's say,
let's say 10. In this particular case, because
207:02 - the value of b is 10, the value of a is 1212
is bigger than B if this condition is true,
207:07 - this statement becomes true. Whenever this
condition becomes true, you're inside the
207:12 - prints you are inside the if condition. Now
this print executes and you're you get well
207:19 - this print executes and you get I am still
inside the if condition, and this has to execute
207:27 - no matter what the values of NBR so now let
me read on this and give other values of a
207:33 - and b let's say the value of a is 10. And
the value of b is let's say 45. Now, this
207:41 - can this condition becomes false because 10
is greater than 45 this is not true, this
207:47 - is false. So whenever this condition is false,
you never land inside the if condition
207:52 - and you go out from the if condition. So these
are the statements that are inside the if
207:57 - condition
207:58 - they cannot execute because because you never
visit them, they can only be executed if condition
208:03 - becomes true. So then once you're out the
if condition that's the statement there is
208:08 - going to be executed anyways. So yeah, so
that's the flavor of if condition on the see
208:15 - and making and this is the comparison operator
that returns a Boolean value. You may have
208:21 - different kinds of comparisons here or combination
of comparisons here No, no problem depending
208:26 - upon your logic. But the question is, are
we done we are going to print only the bigger
208:32 - number we have, we have printed the one that
is if a is bigger, we have printed that what
208:37 - if if b is bigger, we have not solved the
task yet. This is the task we have not solved
208:42 - the task yet. So how to do it. Okay. So yeah,
it looks like complicated. How to print only
208:54 - that number that is bigger. So if b is bigger
than a, then we will print B. Maybe Maybe
209:02 - we should make maybe we should apply another
if condition. If b is bigger than a then print
209:08 - B. If A is bigger than B, then print eight,
maybe. Yeah, why not? So
209:17 - um,
209:20 - so for example, let's go to Jupyter Notebook
and, and write the following. Let me let me
209:27 - write a whole new program here. A equals and
import. Okay, let's do not have a message
209:40 - and input and then if A is bigger than B,
then print a. Okay. However, if B is bigger
210:01 - than a then print B, I guess we are done.
If this condition becomes true, then we are
210:11 - here and we know if this condition becomes
true, then this condition cannot become true,
210:18 - because it cannot happen there is because
then B as well as B is bigger than a This
210:22 - cannot happen. So, whatever the bigger number
will be that will be executed further you
210:27 - can see I have this if condition and this
if condition they are aligned in a way that
210:32 - this if condition is not this the second if
condition is not inside the body of the first
210:40 - if condition, we will see such cases such
cases when this is required. But right now,
210:46 - I guess we are done. If A is bigger than B,
then print a, if b is bigger than a then print
210:52 - B and only one of these if conditions will
become true, because A is bigger than B B
210:57 - is bigger than a, these two statements cannot
be true at the same time. So, let's see. So
211:04 - A is 10, b is 45. So the answer is 45. Well,
because 45 is bigger. So let's run it again.
211:11 - So A is let's say 22. b is let's say four
and the result is 22. Because 32 is bigger,
211:20 - I guess we are done with the task, we have
used this if condition twice to achieve the
211:26 - task to print the number that is bigger and
both the numbers we we took both the numbers
211:33 - from the keyboard Yeah, I end this video here.
And in the next video, I will tell you more
211:41 - features of this if condition particularly
the L statement, whatever what we have done
211:47 - recently with another if could could be achieved
through an L statement that is more powerful
211:54 - and more readable. So in the next video, I
will talk about ELS statement which is a part
212:00 - of F so hope to see you in the next video.
Okay, in the last video, we saw if condition
212:07 - and we actually had an example in which we
wanted to know we wanted to just print the
212:15 - greater number. So we input a number a we
input a number B and if b is greater than
212:22 - a we printed the is greater than eight, then
we applied another if condition to check if
212:29 - a is greater than b, then paint a the else
clause or the else part of f is as as the
212:40 - name suggests, if this condition is true.
So, if this condition is true, this particular
212:47 - condition is true, then go there. If this
is not true, which means else if this is true,
212:53 - then go there, else go there. So if this is
true, then you learned here, if this is false,
213:01 - then you learn else part for sure. And this
else is I mean, if b is greater than a if
213:08 - this condition is true, then you print this
thing. Otherwise, a might be greater than
213:13 - B or A might be equal to b either way you
learn in else part. So this if and else they
213:19 - both have this alignment, but then the block
of ELLs started from this particular alignment,
213:26 - maybe you have more statements here, the alignment
of this if block structure from here, and
213:33 - you may have more statements here. So let's
go to the Jupyter Notebook and see the else
213:41 - running. So let's say a equals and input and
B is 
213:59 - B is int input and we say okay, if a is greater
than b, then brand a
214:15 - else else rent else brand be elsewhere outspent
B. Now B will be printed, even if it is equal
214:35 - to A or if it is greater than a either way,
B will be printed. So let's just see. Let's
214:46 - just run this and see what happens. So Shift
Enter. So input a number. So A is let's say
214:55 - 10, and B is let's say, 12. So what do you
think when I will press enter what will be
215:03 - printed, B or A, B, B is printed, that's what
B is printed. Now, if I run this again, and
215:13 - a is done, and B is done, still the 10 will
be printed. So let's modify it, let's, let's
215:21 - just say, print. If part. So that means we
landed in if part. Otherwise, we landed in
215:37 - Ellsberg. So just to be more elaborated, let's
say so 10 and 10. And we landed in L sport.
215:49 - And the reason is if a is greater than b,
so 10 is greater than b 10 is greater than
215:53 - 10. False. So you got two L's, and the LS
block, the whole block just executed. So that's
216:00 - what else is, it's really very nice to have
an L state or whatever this whenever the,
216:07 - if this is false, whatever that condition
is, if that is false, then you learn in else.
216:12 - So yeah, that's the health part simply now,
okay. So, we have this f l structure, we can
216:35 - have one more power with this F, what if we
want, if a if b is greater than a, then you
216:43 - print B. Else, if A is equal to b, then you
print they're equal. And if this is false,
216:53 - and this condition is false, if both these
conditions are false, then you go to else
216:58 - part. So basically, if else if else if else,
if else, so, you can have really deep structure
217:06 - for example, in this particular example, if
b is larger than a, then you land in this
217:14 - part else, if this L is just short form of
else, else means B is not greater than a else,
217:24 - you can have another check elsif A is equal
to b, then do what?
217:33 - l
217:34 - l, if we can have one more check, we can have
one more check, we can have several checks,
217:40 - and then else else will only execute if all
if conditions or elsif parts on top. Their
217:47 - conditions, they are false, and only then
else will be execute. So let's see these l
217:53 - diff running on Jupyter. notebook. Okay, so
let's say a is and so rather than taking inputs,
218:06 - let's say is one, B is let's say five. Let's
say we have taken these inputs is one B is
218:16 - five, if A is if a is equal to b, then the
word rent equal l l F, which means else if
218:33 - now, because this is if you should you have
to write a condition here, which will be either
218:39 - true or false. If A is larger than B, then
do what? then print, let's say, a. And else,
218:54 - let's say your brain be okay. So that's it.
And this statement, rent is not in if condition
219:07 - Not, not in if this is outside complete, this
is complete if condition with all its L's
219:16 - and LDAP parts, and this is no longer inside.
So let's run this. What do you think what
219:23 - will be the result if A is one B is five,
then else bar is going to be run because A
219:29 - is not equal to B, A is equal to b that's
false is larger than B that is also false.
219:34 - So you will learn in export and B will be
printed and then a statement will be printed
219:40 - which is not an F. So yeah, so B is printed
and not an F. If b is 10, then what will happen?
219:49 - A equals to B that is false, so you will not
land here. Else if A is larger than B true.
219:55 - You will land here because you land here else
will not execute. So He will be printed and
220:01 - then not enough. If A is 10 and b is also
banned, let's say, then you have equal. Yeah,
220:10 - so that's elsif. Okay, so that's about if
else if else if or short form is lf l structure.
220:24 - In the next video, we will be talking more
about this if else if else structure in a
220:30 - bit more detail. And we will also be giving
you a short form of this this guide of ELLs
220:36 - if elsif elberfeld of structure. So hope to
see you in the next video. Okay, one way of
220:44 - writing this, if elsif else kind of structure
there is a short form as well, which is written
220:50 - down here in a in this green color, for example.
This is kind of a same code that we saw in
220:58 - the last video, but that's the short form,
let's say a equals nine and B equals 10, then
221:03 - print a if A is larger than B, else print
this particular thing, if A is equal to b,
221:13 - l sprint that this is exactly the same kind
of structure, for example, print a, if A is
221:19 - larger than B, so you just read that if a
is larger than B, then print a else if A is
221:25 - equal to b, then print equal, else print that.
So that is kind of a short form of writing
221:33 - this if Elif else kind of structure. But I
will, I will recommend to to to use, I'm in
221:41 - the structure in this particular horizontal
form. Rather than writing that in this particular
221:47 - way. Because this kind of structure, that
horizontal kind of structure is much more
221:52 - readable, much more manageable. And this might
be this structure might be confusing some
221:57 - time for for some kind of readers or, and
also if this structure goes on and on and
222:03 - on, which we'll see in a in an example today.
Writing that writing very deep and lengthy
222:09 - structures in short form is not very feasible.
So although but but this feature is there
222:16 - if you like to write if elsif else kind of
structure in this way, this is available in
222:21 - Python. Okay, let's let's get a good grip
on this f LS f l structure on Jupyter. notebook.
222:28 - Let's move on to Jupyter Notebook. To see
an example, just an example. So let's say
222:35 - the example is user will input a number, let's
say int input, let's say and enter marks,
222:49 - let's say enter marks for a particular subject,
let's say user with enter some some marks.
222:56 - And our goal is if the marks are larger than
85, then we will print a grade. If the marks
223:06 - are larger than larger than 80, but smaller
than smaller, so if the marks are larger equal
223:14 - to 85, then we will print a grade. Else if
marks are larger equal to 80, but smaller
223:25 - than 85, then we will print a minus grade.
And if else if if marks are larger than larger
223:35 - equal to 75, but smaller than 80, we will
paint we will print for example, b grade for
223:45 - example, b grade, and so on, let's print this
whole nested structure that let's let's make
223:50 - this else. if else if elsif kind of structure
a little empty, let's let's get comfortable
223:57 - with it. So if a is larger than or equal to
85 to enhance readability, it is good to include
224:07 - a space is a space after the variable and
space but don't actually write the space inside
224:14 - there because larger and equal to the combined
without space is an operator. So if a is larger
224:21 - than 85, then print let's say a grade rate
l if A is a is larger or equal to a D and
224:46 - E is smaller than 85. So let me let me write
this in a more readable form. Else if A is
224:56 - smaller than 85 and is larger or equal to
80 then we should do what it is sometimes
225:06 - good to include these kind of parentheses
sometimes it is good just to make these things
225:13 - more readable that this is one block. This
is one this is one Boolean, this is one Boolean,
225:20 - this is one to see and this font is E and
although not writing the parenthesis is also
225:26 - okay. But writing the parenthesis make code
a little more readable. So, for example, if
225:35 - a is smaller than 85 and a is larger than
80, if that is true, So, remember and is true
225:42 - only when the left side is true and right
side both are true, then this whole condition
225:47 - becomes true. And I promised you that I will
show you the power of comparisons and actually
225:54 - combining the Boolean variables using ands
and ORS and stuff like so. So here you're
226:00 - seeing the one. In that case, let's say brand.
Let's say a binary sprayed and Elif if he
226:19 - is if he is smaller than if he is smaller
than 80. And a is bigger or equal to 75. If
226:42 - that's the case, then what should we do? Let
me omit the parentheses just to show that
226:46 - whether writing parenthesis or not writing
parentheses is perfectly okay. I just recommend
226:52 - right parenthesis, so the code becomes much
more readable than otherwise. Okay, then we
226:59 - have Brent, let's say, b grade. And let's
say one more lF lF. If A is smaller than 75.
227:16 - And a is larger or equal to let's say
227:22 - 70. samedi, then Brent b minus grade, let's
say. And let's just finish this let's else
227:43 - print. below. Average, for example, let's
say that's it, that's our, that's our record.
227:55 - So, we will we will enter numbers, if the
number is greater than 85, then a grade if,
228:02 - when this condition becomes true, then this
print will execute. And we will out of the
228:09 - structure right there. If this condition is
false, then this condition will be checked.
228:16 - If this condition becomes true, then this
print will execute. And we will be out of
228:21 - this structure. If this is false, and this
is false, then this will be checked. If this
228:28 - is true, then we print degrade and we are
out. But if this is false, then this will
228:34 - be checked. And if this is true, then we'll
print b minus grade. And we will be out. If
228:40 - this is also false, then we will dive into
L sport and we will say okay, below average.
228:47 - So let's see, for example, let's say the marks
are at two. So a minus grade. That, that that
228:57 - that makes sense, a minus grade because the
marks are smaller than 85 and larger than
229:01 - larger or equal to 80. So a minus grade. Let's,
let's run this again. And we have let's say
229:11 - marks let's say 64 below average. Okay, great.
So you see this if Elif, Elif Elif else this
229:20 - can go as long as you want, depending upon
your logic. So great. And further, you can
229:28 - combine several comparisons several billions,
together with ands and ORS, and nots, whatever
229:34 - you whatever you like to like to do. Let me
give you one more or one more beautiful thing.
229:42 - let's let's let's create an L without writing
an else or let's let's just let's just write
229:48 - lF and implement ELS completely so we are
not going to write ELS explicitly, but we
229:56 - are going to write a program that actually
simulates ELS So let's see, if a equals let's
230:02 - say, three. If A is larger than 10, then Brent
let's say larger than that. Now, we are not
230:17 - going to write else, but we are going to achieve
the aerosport.
230:22 - Tell If
230:25 - not,
230:26 - a is bigger than 10. To see, then print you
see that I mean, that's beautiful. If this
230:41 - condition is true, then go there. If this
condition is false, then not have false is
230:48 - true, then you learn here. And you need not
to write an expert if you want just I've implemented
230:54 - I have implemented l spark using l f. So see
that. So l sparks so we are right now Spark.
231:03 - If A is let's say 13, then we will think okay,
rather than just for fun, just for fun, okay.
231:13 - Okay, great. So, we saw if condition it's
shorthand and LDAP structure in in a bit more,
231:23 - lengthy way. So in the next video, we will
see if condition inside or in the body of
231:29 - another if condition, which is called a nested
F. So hope to see you in the in the next video.
231:35 - In the last video we saw if lF structure,
in this particular video, we will see nested
231:42 - F, or are simply called if inside the body
of another F. So let's take an example to
231:49 - understand what nested if condition is simply
we can understand if condition inside another
231:55 - if condition, that's all rest of the story
is same. The way it works, it works even if
232:02 - it is inside the body of another if or or
anywhere, actually. So let's say we have input
232:08 - a number, and then we check if x is larger
than 10, then you move inside the if condition.
232:15 - If that is true. If that is false, then you
are here, whatever you write here, it will
232:20 - work from here. But let's say x is greater
than 10, then you print your number is greater
232:25 - than 10, your number is above 10. Let's say
let's see Brent that now after this, after
232:32 - this statement, you move to the statement,
and you just make another check if x is larger
232:39 - than 20. Now you see this if condition. This
particular statement is inside this particular
232:47 - if condition, if this, this condition becomes
true only then you dive in, otherwise you're
232:55 - not. So here you're checking if x is larger
than 10, then you move inside and inside you're
233:00 - making more checks. So for example, if x is
larger than 10, then you print or do some
233:05 - stuff here, then you apply Further more, more
checks more graduality more, whatever your
233:11 - logic is. So let's say here you're checking
if x is larger than 20. Now, if this condition
233:16 - is true, then you move here else now this
else is of this if if x is not larger than
233:24 - 20, then you move to this else l squat and
you're here. So and we can have another if
233:31 - inside this particular F or an F inside this
L sport and so on. So if inside an F is called
233:38 - nested if and we can have I mean deep structures,
for example, if then something then if then
233:47 - something then if so maybe we can have a very
lengthy structure if nested if structure depending
233:54 - upon the logic. So let's get ourselves comfortable.
As always, by writing the code on Jupyter
234:03 - Notebook because that makes much more sense.
When we see things running on, on on the notebook.
234:10 - So let's say a is let's say again, and let's
say we take some number and if a is larger
234:24 - than 10, then we say okay, Brent, larger than
10 and do more stuff, Brent. That's inside.
234:42 - If condition, okay, then then maybe we have
another check if A is larger than 20 then
234:53 - say rent greater than
20 Yeah, greater than 20. And you can rent
235:08 - now rent inside the nested if, okay. Else
rent l sprint, smaller or equal to 20, smaller
235:31 - equal to 20. And then brand, for example,
inside the L spark of nested if that's it,
235:46 - and you can print here, brand outside all
it's fine. So that's it that's that that's
236:00 - the structure. So let's see, let's give an
input which is larger than, by the way, if
236:05 - input is not larger than 10, this if condition
is false, then you directly dive to this print
236:10 - statement and all this structure is not going
to be executed, this is this complete thing
236:16 - is called the body of this if condition, and
the body will only execute if the condition
236:21 - becomes true, whether that condition is just
a single condition, or you have a combination
236:26 - of a lot of comparisons and a lot of Booleans
whatever, if this condition becomes true,
236:32 - whatever that condition takes form of, then
Then and only then you dive into this part.
236:37 - And when you are in this part, then that's
a whole new universe, then you're on its own
236:42 - in the new part, in the new part, for example,
if this condition becomes true, then you are
236:50 - in this part, that's the body of this particular
if condition, and that's the body of the else
236:55 - part, see the the body of the top if condition
has this kind of alignment, all the statements
237:02 - that are in the body of if condition, they
start the same alignment, and all the conditions
237:08 - all the statements that are in the body of
this particular if condition, they have their
237:12 - own alignment, and this indentation is necessity
just to define, for example, which statement
237:18 - is in what kind of block for example, if I
just press a tab, then another tab, then this
237:26 - print statement is in this L sport and this
is the indentation that is defining the placement
237:33 - of this print, if for example, I press I align
this with this, this particular structure
237:41 - here, then this print statement is inside
this if condition, this is the indentation
237:47 - that is defining the placement of different
statements. And if the print starts from here,
237:54 - then it is completely outside of all if conditions
it is like this way. So let's run this board
238:01 - and see what happens. Let's say we brand let's
say we just cried a equals let's say 12. So,
238:07 - what do you think what should be printed,
if A is 12 then first of all this condition
238:12 - is true. So greater than 10 will be printed
inside the top if that will be printed, then
238:17 - this check will be executed and this condition
will become false because 12 is not larger
238:23 - than 20 then you will go to the else part
and less or equal to 20 this number this string
238:28 - will be printed and then inside the else part
of nested if that will be printed and then
238:32 - you will be out of all if condition then outside
of all F's that will be printed. So let's
238:37 - see whether whatever we have said is correct
or not. So yes, greater than 10 inside the
238:45 - top if less than or equal to 20 inside the
else part of the nested f outside all F's
238:51 - Yeah. So that's what the nested F is. And
by the way, you can have you can have for
238:58 - example, more if conditions inside the nested
ifs for example, you can have one more condition
239:04 - here, if A is larger than 30 for example,
then do what then print it is larger than
239:16 - 30 as well. And for the brand, maybe not necessarily
that you always write print statements you
239:25 - can do any interesting stuff
239:26 - inside inside the nested if of nested if find
and then you can write the else part of this
239:42 - particular if condition here if you want to
or or whatever I mean you can have as hilarious
239:51 - structure as you want, but that completely
depends upon the logic or you may have an
239:56 - if condition inside that l spot here for example,
You can write an if condition here, if whatever
240:02 - that is also, that is also perfectly fine.
So, if a is larger than 20, then you print
240:10 - this if A is larger than 30, then this, for
example, and literally write the else part
240:15 - here else, print less than or equal to 30.
And we can print inside the nested inside
240:35 - the else for all of nested if of nested if,
okay, so, while you see that program, let
240:49 - me let me just scale it down so that you can
see that completely see that program. I mean,
240:56 - yeah, it makes perfectly sense to me, for
example, you take an input, if that is larger
241:02 - than 10, then you're here. If it is larger
than 20, then you are here. If it is not larger
241:11 - than 20, then you're here. Okay. So let's
say it is larger than 20. If it is larger
241:16 - than 20, then you are here further, if it
is larger than 30, then you are here. Otherwise,
241:21 - you are here. And once and by the way, if
A is not larger than 10, then you are directly
241:28 - here. Wow. So let's run this code. Let me
just scale it down so that you can see it
241:35 - more. You can see more text. Let's see. So
let's run this. No errors. Great. So let's
241:42 - say the number is let's say 25. So, what do
you expect the result. So the number is 25
241:49 - is greater than 10 inside the top if it is
greater than 20 inside the nested if it is
241:54 - smaller than or equal to 30. So inside the
else part of nested if off nested if and then
241:59 - outside all the hips conditions. Great. Yeah.
You enjoyed that. I enjoyed that. rate. Okay,
242:07 - so that's about the nested if one more thing
that I have already told you, but just let
242:13 - me tell you the power of indentation. You
are here for example, in this particular if
242:19 - condition, that's the if condition and that's
the nested if, and that's the else part of
242:24 - this if if you move this L sport in in the
indentation or the alignment with this if
242:33 - then this is else part of this if and this
is not the else part of this If so, remember
242:40 - the power of indentation the this is the indentation
that defines which part belongs to what what
242:46 - kind of block or structure in Python. In other
languages. Sometimes, for example, in c++,
242:52 - they they normally use to write these curly
brackets to define a block and their indentation
242:59 - doesn't really matter. But in Python, this
is the indentation that actually defines each
243:03 - and everything. So, for example, this is a
crucial example if this else just moves backwards
243:09 - and aligned with this f you get this else
with this if these two if an L structures,
243:17 - this is still nested if without an L sport.
And if this else move somewhere in between
243:23 - I mean this is not aligned with this if this
not aligned with this if you get a syntax
243:28 - error because that is not a proper indentation.
So focus on indentation that is really really
243:33 - important. Yeah, so although i have i've told
you that the indentation has already told
243:39 - you but I just I just found to make a slide
over this elsewhere because that's important.
243:47 - Sometimes you may get confused whether this
else belongs to this F or that F Well, the
243:53 - indentation defines this LS belong to what?
Okay, I end this
244:00 - control flow indentation here. So from next
video we are jumping toward loops. But before
244:12 - loops, I just want to I just want to write
a lengthy program in F LS f there are combinations.
244:20 - I just want to write a Jupiter program for
you to to get comfortable with F nested f
244:30 - the conditions that are ands and ORS and nots
are stuff like so. So So in the next video
244:35 - we will be practicing more on Jupiter for
if conditions and then from the next to next
244:41 - video. We'll be jumping toward loops, the
very very powerful structure. Okay. Hope to
244:48 - see you in the next video. Okay, so let's
just practice this if condition a little bit
244:54 - more in this particular video and we are going
to achieve particular tasks. So let's design
245:01 - some task here. By the way, this has comment,
comment, comment is, it starts from a hash
245:09 - symbol. And that's a statement that will never
be executed. This just describes your code,
245:15 - for example. So like it, like, it is not there.
But it is there as a text, but not as a code
245:22 - file. Like hash sometimes represents. Comment
or description with a single line. If your
245:32 - comment goes on multiple lines, it is good
to write a multi line comment. So that's single
245:39 - line comment, for example, single line comment,
the multi line comments, they start with three
245:47 - quotes, and then end with three chords. So
whatever you write inside, in these, in this
245:52 - particular block, that's a multi line comment.
So let's describe our problem in this modal
245:57 - line comments, because that's the problem
in form of text. And then we will be solving
246:05 - that problem using using the code. So that's
just description of the problem, let's say
246:11 - user will enter of loading point number. Number,
let's say 230 8.915. Let's see. Okay, your
246:32 - task is, is to so let's just adjust more readable,
your task is to
246:42 - find out the teacher integer, portion, integer
portion, before the decimal before the point,
247:00 - let's say for the for the point, in this case,
in this case, it is 238. And then,
247:10 - and
247:15 - and then check whether if that teacher portion
is and even number or not. So just print yes
247:41 - or no. So print even if it is even number,
otherwise, print odd. So that's the that's
247:48 - the problem statement. That's the problem
that we are going to solve. And this is just
247:53 - to commit now we are outside the command that's
a multi line comment. Yeah, so how to how
248:03 - to solve that problem? How to solve that problem?
So let's start solving this problem. I'm going
248:11 - to spend some time on this program just to
get comfortable with the if conditions, let's
248:16 - say let's say that number is x is input, let
me convert that input
248:24 - into our
248:27 - real number. That's it. Okay, we're just assuming
that the user will enter a real number. It's
248:41 - real number. real number might be I mean to
38.0, that's a real number or 238 itself,
248:48 - that's also real number. That's okay. But
we're not assuming that the user will enter,
248:52 - let's say some characters like ABC or stuff
like sort of just just assuming that. Okay,
248:57 - now, assume that x contains real number, it
may be an integer. By default, maybe user
249:04 - just enters 10. And that's it. So it may be
already an integer, then we have to check
249:09 - whether that 10 is whether that 10 is even
or not, or the user may enter 11.7, or the
249:21 - user may enter minus 34.7. Or the user may
enter just zero or user may enter just zero
249:29 - point 30 535. There are a lot of possibilities
that a user come up with this exe can contain
249:36 - any kind of number, and we have to check according
to. So how can we move let us just see, whether
249:45 - that number let us just extract the decimal
portion, the portion before point. Let's just
249:54 - extract that how can we extract that there
are two conditions First of all, let's see
250:01 - if x is positive, then do what else do what?
So let's try this structure first. The facts
250:12 - is positive, then what we have to do? And
if x is negative, then what we have to do?
250:19 - So if x is positive, then what we do? We,
we just so, what should we do? I'm just stuck
250:31 - here. How can we extract the, the decimal
portion, the portion without this particular
250:38 - thing? How can we extract that? That's, that's
tricky. That's kind of tricky. Yeah. So any,
250:49 - any ideas? I guess this? The the structure
I have, I'm using the let us just first think
250:56 - that x is positive, just make our life easier.
And then if x is positive, it's a positive
251:02 - number. How can we extract this portion out?
Just the number that is below? That is before
251:09 - the decimal point, but what should we do?
can we can we can we apply apply around function?
251:16 - Will that help? x? Will that help? helps.
Yes. But no round function? So let's say y
251:28 - contains the rounded value of x then, so what?
Then how can extract How can we extract the
251:42 - the the decimal portion, the portion the integer
portion? Or maybe there is a function that
251:46 - actually round down? Let me check whether
there is a function float or not? No, float
251:52 - is not a function, I guess. So let's say round
x. Okay, now y contains the rounded vol value
252:01 - forever the Xs we are now assuming that x
is positive, okay, then what? Now, if, if
252:08 - y is larger than x, that means we moved up.
Okay, we moved up, the round goes up. In that
252:17 - case, what we do is we just subtract. So the
let me so we just subtract the integer portion.
252:29 - So the let me in teacher portion, let's say
that's our variable name, then the integer
252:37 - portion is simply y minus one is that correct?
Is that correct? If y is larger than x, then
252:44 - integer portion is simply y minus one. For
example, for example, just Just think about
252:50 - it, if When, when, for example, if the value
was 29.6, and the rounded value will become
253:02 - 30, so 30 minus one will be 29. There is what
we are what we are interested in. So, yeah,
253:10 - so otherwise, if for example, else, else,
if y is not larger than x, then y itself is
253:20 - an integer portion.
253:22 - Y itself is an integer portion. Is that correct?
I mean, is that making sense to you? That
253:31 - if for example, if if x is larger than effects,
larger than if the rounded value of x is larger
253:41 - than larger than x itself, then we just subtract
one and we get the proportion. Otherwise,
253:49 - the rounded value itself is the portion, just
just let's just run this, run this code for
253:55 - now and check whether what whatever we have
done so far is correct or not. So after that,
254:01 - just print, let's say the integer portion.
And teacher portion, let's just print that.
254:08 - Okay. So enter a number. Let's say the number
is, let's say 25.3 45.367. Let's say, obviously,
254:20 - the integer portion here is 25. So let's say
let's see our program returns 25. And now
254:26 - Oh, the result is 25. magically Oh my god.
We found 25. Let's run it again. Let's run
254:35 - it again. Just to see. Okay, let's run this
again. And order this time let's give it to
254:52 - 45.8. Okay, the integer portion is 45. But
when we will round We will get to 46 and 46
255:02 - minus one, we will dive into this particular
if condition. Let's see. All the result is
255:07 - 45. We are we are still moving very bill.
Great. That's, that's great. So, okay, let's
255:16 - play with it. Let's, let's give, let's give
0.2 the result should be zero, it is zero,
255:26 - right? Let's run it again and give it let's
see, let's say four. That's it, the result
255:32 - should be four now, it is four. Great. So,
we are working very well we have extracted
255:37 - the integer portion as long as the number
was positive. Okay, right. What if the number
255:44 - will be negative? Let's say that was true,
if that was true, so, that whole logic works,
255:57 - if x was positive, so if x is positive, then
whole this logic just works okay, then else
256:13 - What should we do? If x is positive, then
this logic works effects is not positive,
256:18 - then what will happen? Then how can we find
out the integer portion because first we have
256:24 - to find out the integer portion and then we
have to find out whether they are integer
256:28 - portion is even or not finding out whether
they are indeed a portion is even or not might
256:32 - be simpler. But first, we have to find out
the integer portion. So for example, let's
256:38 - check the behavior of round function on negative
numbers, let's say around minus 9.3. So the
256:46 - result is minus nine. Okay? If we say okay,
round, minus 9.6, the result will be minus
256:58 - 10. So it looks like the same as working in
the positive numbers. So round function is
257:04 - actually working roughly the same way it should
work in the positive numbers. Okay. So what
257:11 - should we do here? Any idea? Maybe, maybe
we first convert? Maybe you first convert,
257:21 - by the way? Yeah, maybe first convert the
number, let's say y equals around x again,
257:31 - like before, but then what? Then what? So
maybe this rounding helps the same way? Maybe
257:39 - the rounding helps the same way. We should
extract this out from this here, because it
257:48 - is going to work in the else part as well,
why to compute it, why white write this redundant
257:52 - code? So why is round x let's say then if
y is greater than x, what should we do? If
258:04 - it is negative y is greater than then what
would what will be the portion? It will be
258:13 - the integer portion will be portion will be
what?
258:18 - y minus one or one? y plus one? Yes, you got
the answer? That's y plus one. Great. And
258:27 - else I guess we have in future portion. Equals
Whitesell, I guess, yes, I guess that's the
258:44 - that's the good. That's cool. I guess that's
checked, by the way, but I guess that's the
258:49 - code. By the way, this else part is, this
else part is same in both of these conditions.
258:56 - So maybe, maybe we can combine this code and
write a more elegant code, but I guess this
259:02 - would work. Let us just print the integer
portion, just to check whether we are working
259:08 - well, so far or not. So let's enter let's
see 12.3 The result is 12th grade. So it did
259:19 - not change our previous I guess our previous
logic. So let's say there is minus 9.8. Now
259:25 - the integer portion should be minus nine,
oh, it is returning 10 Why is that? Why is
259:32 - that? Oh my God, this should be changed when
it is round. It may go that way or when it
259:40 - rounds it actually becomes lesser than 10.
Because when it rounds it goes up and it becomes
259:47 - lesser than a negative word. This condition
should flip. Yeah. So we are making an error
259:54 - here. Let's fix that. Okay, let's run this
again. And see Let's say minus nine point
260:02 - minus nine d 3.2. Minus 93. Great. So then
we have let's see, let's run it again. Minus
260:11 - 8.9. minus eight. Yes, we are working perfectly
fine. Once we have integer portion with us,
260:21 - we just right here. At the very end if integer
portion is your portion, remainder with two,
260:31 - if that equals to zero, if that equals to
zero, Brent, even, otherwise, else, brand.
260:49 - Art. That's it. That's the whole program.
Let's see. And let's see, how is it running?
260:55 - Let's say 22.6. It's even, let's say minus
87.3. That's odd rate. So you see the power,
261:09 - if condition and, and how can we think in
writing these programs and stuff like so?
261:16 - That was a lengthier video, I know. But I
guess you get a very good look and feel of,
261:21 - of if conditions and thinking and building
logic and all that stuff. So in the next video,
261:27 - we will start loops. So that's a beautiful
structure, hope to see you in the next video,
261:33 - the best way to understand loops is to think
about in a repetitive structure or repeating
261:40 - structure. Let me let me give you an example.
And they will, we will dive into this code
261:46 - in a while. The example is let's say a user
gives you a number, let's say integer number.
261:54 - And you want to print all the numbers till
that number, let's say you start from one,
262:00 - and you keep on moving and printing all the
numbers, as long as you reach that number.
262:06 - So for example, if user enters, let's say,
five, your goal is to print one, then print
262:13 - two, then print three, then print four, and
then stops, then stop just or, let's say if
262:23 - user print, if user enter, let's say, three,
then you print one, you print two, and then
262:33 - you stop. This is easy. If user enters in
n, we can just print, we could have written
262:41 - this thing, print. Brent, I, let's initialize
a variable by with one, Brent I, and then
262:51 - I equals two i plus one, or in Python, we
can write this quickly as i plus equals to
263:00 - one that means I
263:03 - that means in I store a plus one, this is
the short form of writing this. And then after
263:10 - that, you just apply an if condition. For
example, here, you can apply an if condition
263:16 - and say, Okay, if I is smaller than n, you
keep on printing, and after printing, you
263:22 - just increment again this, then check the
if condition and keep on moving. Well, that
263:28 - is visible if n is five, or n is three, what
if if n is let's say, if t 1000. In I mean,
263:36 - you're writing all that structure again, and
again. And again. I mean, that's a lot of
263:41 - code. Well, the loops are just a solution
for this kind of structure when you want to
263:46 - perform the same kind of task again, and again,
the loop gives you the facility to do that.
263:53 - For example, let's just consider the VI loop.
This is again a condition similar like a condition
264:01 - in if condition like an if condition, you
evaluate this Boolean expression, then that's
264:07 - an expression that results a boolean value.
While this condition is true, you will stay
264:12 - in this block and after executing whole block
once you check this condition again, if this
264:20 - condition is again true, you will dive into
this block again. Then check the condition
264:25 - dive into the block then check the condition
dive into the block. As long as this condition
264:29 - stays true, you stay in the block you you
move inside the block. Once this condition
264:35 - is false, then you exit this while loop then
the loop terminates and you move on to the
264:42 - further processing just like an if condition
just like if conditions if if the condition
264:46 - becomes false, you accept that if condition
and you can move on, moved on. So in this
264:52 - particular case, for example, if n is five,
let's say if n is five, user give an integer
264:58 - number that is five I is equal to one, now
one is smaller than five, the condition is
265:02 - true, we move inside, you print I, the value
of i is one. So that's what you print, you
265:08 - print one, then you change a, you increment
i with one, that means i equals i plus one,
265:13 - so I becomes two. Now the body of the loop
finishes, that's whole body of the loop, the
265:18 - body of the loop can have many, many statements,
a whole block of code. Once I becomes two,
265:25 - you move on and you check, okay? Two is smaller
than five, yes, it is true, you move inside
265:32 - the block again, you print two, then you update
I, the loop body finishes. Once the loop body
265:39 - finishes, you go and check the condition again,
whether that condition is still true or not,
265:43 - it is still true i is three i is three is
smaller than five, yes, you move inside, you
265:48 - print three, you update, I, you check the
condition four is smaller than five, yes,
265:54 - you move inside you print four, and then you
update I and then you move on now five is
266:00 - smaller than five false. Once the condition
is false, you will not dive into the body
266:06 - of the loop, you will exit the loop and you
will print done. And that's it done. So this
266:12 - loop becomes very, very, very handy. In in,
in, in applications that have representative
266:19 - structures. And in most of the interesting
programs, most of the interesting problems,
266:24 - these are the loops that play a very huge
role. So let's go to Jupiter just to get our
266:32 - hands, get our hands on this loop. For example,
let's say x is again, that's the end or n,
266:42 - let's take n and is in input. Let me make
this a little bigger, just do. Let's say that
266:57 - input and input is a number, let's say n i
is your surgeon, let's say let's say one,
267:07 - while I is smaller than n, you may have written
this parenthesis just to just to create the
267:19 - readability just to make readability. And
otherwise I mean, this is also Okay, that's
267:27 - perfectly fine. If as long as I is smaller
than n, keep doing the following you what
267:34 - you do is bring, for example, the square of
I paint the square of I, that the square of
267:41 - it, let's say, and then you say, Grant, for
example. This is a question number. And then
267:55 - you just print I, that's the iteration number
I have the loop.
268:02 - That's the equation number I this is just
the spring, this is just a string. And that's
268:10 - our variable, its value will be printed. This
print function takes as many arguments as
268:16 - you pass. So you can you can write a comma
here and continue whatever you want to print.
268:22 - That's very flexible function. Okay, then
what you do you say, Okay, I plus equals to
268:28 - one. By the way, this i plus equals to one
is the same as i equals i plus one. You see,
268:35 - I have just commented here just to explain
what this is doing. If I just write i equals
268:42 - i plus one that is also that is also correct
in Python, but that's kind of shorthand. Okay.
268:49 - And that's it. Now, again, when I de indent,
I'm outside the loop, let's say sprint. Loop
268:57 - done, for example. So that's the code for
example. So let's run this code. Let's run
269:08 - this code. For example. Let's say n is equal
to five, then we have five. So this is one,
269:20 - this is the aggression number one, then two
square is four, this is the aggression number
269:24 - two, then three squared is nine, the aggression
number three, then four square is 16. This
269:29 - is the iteration number four, and then the
loop finishes. That's it. That's the first
269:34 - snapshot of the loop. We will continue from
here onwards in the next video and I will
269:40 - show you more and more flavors of this loop.
So hold on and wait for the next video. Okay,
269:49 - in the previous video, we saw a while loop
and we saw one. One program related to while
269:57 - loop, just printing Just printing a bunch
of numbers till a particular number. Well,
270:06 - when you are inside the body of the loop,
that's a whole new you can write whatever
270:12 - you want to write, for example, you can you
can apply an if condition inside the body
270:16 - and check that an at each iteration a particular
decision should be made or not. For example,
270:23 - in this particular case, I'm going to print
I whenever I is an even number, so, I is some
270:31 - number if it is even then printed, else pass
this pass statement for example, is just a
270:37 - statement of saying that do nothing It is
just a shortcut of writing do nothing we could
270:45 - have we could have omitted the whole else
part along with this pass and still the code
270:52 - is equivalent but sometimes writing this past
make the code readable just so so writing
270:59 - this boss statement just means do nothing
and just move on. If we omit else statement,
271:05 - and we omit this boss, that's perfectly okay.
So, for example, let's try it on the score.
271:12 - Let's say n is let's say n is five i equals
one one is less than five Yes, one is not
271:21 - an even number. So go to the else part else
means boss, which means go on and then increment
271:27 - i this print statement is outside the loop
this is this is aligned with this while it's
271:33 - not inside the body of the loop otherwise,
it should have been intent indented inside
271:39 - now i is incremented I becomes to now move
back to is smaller than five years. Two remainder
271:45 - two is zero Yes. So brand two, so two will
be printed. Because if executed else will
271:51 - not execute and I will increment because I
is not inside the if condition it is inside
271:57 - the body of the loop. So I incremented I becomes
three you go back, three is smaller than five
272:04 - years. Three, remainder with two is zero false.
So pass i i plus one, so I becomes four, four
272:13 - is smaller than five years for remainder two
is zero, yes, so Brent four. So else will
272:19 - not execute now increment i, once you increment
i you get, for example, I equals five, now
272:28 - five is smaller than five false, so you go
out of the loop and you print down. And that's
272:35 - what this code is. So, you can have if condition
inside the loop, you can have nested if inside
272:42 - the loop
272:46 - you can have loop inside the loop nested loops,
we will see examples of nested loops as well.
272:51 - I mean, that's that's all allowed are sometimes
rarely required. Okay. So, next there are
272:59 - two important statements that are there, one
is break one is continue, I want to focus
273:05 - these statements because they have a deep
link with loops. A break statement where ever
273:12 - written inside the body of the loop tells
that exit the loop immediately whenever this
273:19 - brake is encountered, whenever this brake
executes, it exits the loop immediately and
273:25 - brings you outside the body of the loop. That's
what it does break. So for example, if I becomes
273:34 - if I becomes divisible by 17 and the remainder
becomes zero, you will print a break and then
273:41 - when this break statement will execute you
will exit the loop immediately regardless
273:46 - of what is the value of AI What are other
states wherever break exits the loop Okay
273:53 - great. Now, the continue continue statements
continue statement wherever encountered continue
274:01 - brings the next iteration loaded regardless
of the remaining remaining statements in the
274:10 - loop for example, when this continue will
be executed, no matter how many statements
274:15 - are there onwards that are there, in the body
of the loop, the loop will not finish its
274:21 - iterations iteration by going through all
the remaining statements, but it will start
274:26 - another iteration immediately. So continue
basically skips the remaining body of the
274:33 - loop and starts another iteration. Here I
have written this. true true means while true
274:40 - means always run. You might be thinking always
run it's an infinite loop will it will it
274:47 - when we will exit the loop because this true
statement will always stay true. We're not
274:52 - changing this true anymore. There is no condition
here. That's true. While true means always
274:56 - go inside the loop but once where whenever
this Break his encounter, you're outside the
275:01 - loop right away. And this break exists, the
loop does continue skips the remaining remaining
275:09 - portion of the loop body and starts the new
iteration starts another iteration. So this
275:14 - continue means start another iteration immediately
skip the rest of the stress of the statements.
275:23 - So the rest of the statements inside the loop
body. Okay, so let's just practice this break
275:29 - and continue with just just in Jupyter Notebook
to get a better look and feel of the loop.
275:36 - So let's say we have, let's say again, let's
say n equals let's say 10. Or we might have
275:45 - taken that as an input, let's say n is equal
to 10. While true, which means keep moving,
275:55 - it might have taken some value here, I equals,
let's say one, while true, if I remainder
276:05 - with, let's say, nine, if that is equal to
zero, then just break the loop tells ELS.
276:21 - Else, what you do is really you increment
a else what you do is, if I is if I is not
276:32 - divisible by nine, then what you do is i equals
i plus one, that's true. By the way, previously,
276:41 - we we have written this way. So either way
is fine, whether you write a short form or
276:45 - this form, so else this okay. And that's,
that's it, the loop finishes. That's the loop.
276:54 - After the loop, you just write Okay, print,
the loop is done. So let's see, what's the
277:02 - output? The output is done straightaway. And
the reason is, why it is Oh, one is not one
277:12 - is divisible by nine, only then you could
have break. While true. Why? Why the loop?
277:18 - Oh, it does not print anything, we could have
printed some statements so that we know that
277:23 - we went inside the loop or not. Okay, so inside,
if so, for example, Brent.
277:36 - Inside else. So let's run this again. Oh,
okay, great, inside sales, inside sales inside
277:43 - sales inside rails, the first time it go inside,
if that time it breaks, and it goes out and
277:50 - pants down. That's what this break statement
does. So let's see an application of continuous
277:56 - statement. That's for example, just copy and
paste that code into another cell and see
278:06 - how this continue works. So, let's say we
have a loop like so. So, what we say is like
278:18 - this, if I is nine is not equal to zero. If
this is the case, if I is not divisible by
278:33 - nine, what you do is you get take i plus equals
to one and then continue continue to the next
278:46 - statement. And whatever else you write here
for example, brand something brand something
278:59 - else something else whatever that is going
to be printed and what wants to continue will
279:08 - will be encountered whenever this eye is whenever
this I divisible by nine is not true. If I
279:18 - is then you continue once this AI is divisible
by nine for example, then you will not follow
279:26 - then you will not dive into this if condition
only then these two statements will be printed.
279:34 - Because this this continue will not allow
anything further that should happen. And once
279:41 - these are printed, let's say we break our
loop right there, let's say so if for example
279:48 - for the very first time one is not divisible
by nine, so I equals two. So continue these
279:55 - three statements will not be executed the
next loop the next loop. The next one If condition
280:00 - becomes false, this continue will not operate,
and then we print this statement, then only
280:06 - then we will print this statement, and only
then we will break and we'll exit the loop
280:11 - and print the data. So let's print here. Brent
inside, if so, let's run this code, let's
280:22 - run this code and see what happens. That's
the good
280:25 - I should I should just yeah, NASA better font,
let's run this code. So, when the code is
280:35 - run inside if inside if you see when you when
you are inside if when you continue when when
280:41 - this is the body of if condition when if condition
completes, it should print these two things,
280:48 - but continue is telling the cursor to go back
to the next iteration and move on. And once
280:56 - this if condition becomes false, only then
you get this distinct printed this thing printed
281:02 - if this break was not there, you do you then
again was going to the while loop and you
281:08 - will be running an infinite loop and then
you have done so that's what this continue
281:13 - and break does. So, in the in the in the very
next video we will see another kind of loop
281:22 - here we saw the while loop in the next video
we will see a for loop very powerful and very
281:29 - famous kind of loop for it does almost the
same stuff as while loop while the while loop
281:36 - runs based on a condition they fire the for
loop it runs based on contracts a counter
281:41 - loop that many times it should run and so
on. So we will see the details of for loop
281:47 - and the application The for loop in the next
video hope to see you in the next one. Okay
281:52 - in this video we are going to discuss for
loop and other kind of loop in the previous
281:57 - video we saw while loop although most of the
stuff almost all of the stuff can be achievable
282:03 - through while loop and sometimes it becomes
handy to apply for loop. In this particular
282:09 - example, I'm going to populate a list. So
before actually moving towards for loop let's
282:17 - see very shortly what a list is, although
we are going to be or we are going to explore
282:25 - this lesson in much more detail when we will
discuss the data structures module but just
282:30 - for the sake of example, a list is a collection
of different kinds of elements for example
282:34 - 234, that's a list of three elements. So two
three and four the list can contains different
282:42 - type values, for example two 3.4 and stuff
like so, we can access different elements
282:49 - for example, L of zero means the very first
element the indexing This is called the index,
282:54 - the index starts from zero then index one
is so if we print for example, Brent Elif
283:02 - zero the result will the result that will
be printed will be two similarly we can append
283:07 - more values inside a list append let's say
53 and list after this append operation, the
283:17 - list will be having these values 234 53 we
can remove delete, update and do a lot of
283:26 - stuff we will see lists in detail, but just
for this example, just think that list is
283:31 - collection of a lot of elements and we can
add insert more elements we can delete elements,
283:37 - we can change elements and so on. Or we can
just initialize the list with just an empty
283:41 - list and start inserting elements one by one
and expanding that list. Okay. Now, this is
283:48 - an empty list for example, and four is just
a variable for i in this range isn't it greater
283:56 - range then means sequentially give a number
one by one starting from zero start from zero
284:03 - a gift num give numbers one by one for example,
first time give zero I will contain zero second
284:09 - time give 1/3 time give two and so on after
every equation the range will give another
284:14 - number as long as the numbers they are smaller
than 10. So, the last number that this range
284:21 - will return will be nine. So whatever this
is written inside is not included and it starts
284:26 - from zero. So as long as I is in this range
is lower than 10 as long as that you that
284:35 - the body of the loop just like the body of
the while loop. So first time I will be zero
284:40 - and zero is smaller than 10 Okay, you print
i i plus one and abandon the square of that
284:47 - in a list. Then next time this range will
automatically return the next number into
284:52 - I. Now next time I will contain one next time
I will contain two Next time I will continue
285:00 - In three, four or 5678 and nine, once the
value of AI becomes nine, that's the last
285:06 - iteration of this body of the loop. And after
that the loop finishes. So let's just write
285:12 - on this very very first time I will be zero
when the loop enters its body very first time
285:19 - I will be zero and one will be printed because
we are printing i plus one, at that time the
285:24 - list and the empty list will be having one
number which is zero square. So list will
285:30 - be having just one number zero, because zero
square, so, next time I will be one and we
285:37 - will print two and the list will contain one
square which is one, next time I will be three
285:43 - we will I will be two we will print three
and we will be having a square of two which
285:50 - is four, and so on till so until 10 here,
when I will be nine we will print print 10.
285:59 - And in this list, we will be having nine square
which is 81, I guess, and after that the loop
286:07 - finishes and we will be out of this loop.
286:10 - Okay, let's see this. Let's see example of
this in, in Jupiter just to get more comfortable
286:16 - with with list as well as the for loop. So
let's see, let's say we have an empty list,
286:24 - let's say an empty list. Just to consider
a list like this L is just a variable, you
286:31 - can write another variable a name, that's
a variable name L. Okay. So for i in range,
286:39 - in is a keyword range is a function in is
a keyword, i in range. For example, let's
286:46 - say then, what you do is you brand, your brand
i plus one or whatever you want to do, that's
286:56 - the body of the loop, and Eldad a band, that's
a function of the lists, we will see that
287:02 - in detail in the data structure sessions.
Okay, and that's it, the loop finishes. When
287:10 - you finish the loop, just print the whole
list. So let's print the list. And you can
287:17 - see the result 1-234-567-8910. And that's
the these are the values in the list. As as
287:25 - I mentioned earlier, all the little the values.
By the way, this range function actually,
287:31 - if What if we want it to jump more than just
one, for example, b we want it to start from
287:39 - zero, it reaches 10. And let's say we want
two jumps to be taken as two rather than one
287:45 - and one. So the very first time so that's
the start location. That's the end location
287:51 - which is not included start location is included
and location is not included. And that's a
287:55 - step size. So very first time I will be one
you move inside, then a jump of two will be
288:01 - taken the next time I will be so very first
time the AI will be zero, then you move inside
288:08 - then the jump of two, then you move inside
then a jump of two then you move inside as
288:13 - long as you stay smaller than 10 you will
move inside the loop body of the loop. So
288:19 - let's see what now printed let's print just
I rather than i plus one there was an error
288:27 - was the error 00 the range function does not
have colons, it has actually commas. Sorry,
288:36 - my mistake. I was just a MATLAB user one.
So MATLAB actually has this colon things.
288:44 - So I was just confusing MATLAB notation with
this. Okay, great. So so first time i was
288:51 - zero, next time a jump of two, I becomes two.
Next aim to jump off to AI becomes four, then
288:56 - I become six, then I becomes eight. And next
time I becomes 10. But 10 is not included.
289:01 - So you're out of the loop. And that's the
squares that you got. It is not necessary
289:10 - that you always start from zero, you can start
from one and you can j take a jump for example
289:16 - the jump of three. And it's not necessary
that you just reach them you can reach for
289:21 - example 20 it's up to you it's completely
your choice. And in that case, you have this
289:26 - kind of vibrations. So this range function
really is helpful for creating over over a
289:33 - loop body or a structure. Okay, great. So
that was introduction of for loop and we have
289:40 - iterated here on on our list we just have
actually populated a list using for loops.
289:49 - Okay In the next video we will see more details
of this for loop and more fun stuff. Okay,
289:56 - hope to see you in the next video. Last time,
we saw four In the last video, and magically
290:03 - this else has something to do with for loop
in Python. Well this else clause makes sense
290:10 - for F. But in for loop it hardly makes sense.
But let me let me let me try to make sense
290:18 - of else clause for follow there is an else
part of for loop as well in Python, not in
290:24 - other languages. I don't know any other language
that has this L spark maybe there is some
290:29 - but I don't know.
290:32 - So this else part in Python, particularly
in follow, this else part or else that was
290:39 - blocked will only execute if four completes
its iterations. For example, this is a set
290:48 - a set like a list is is a collection list
is defined by square brackets set is defined
290:55 - by curly brackets, the set is just similar
like the set in mathematics, we will see the
291:01 - set lists tuples dictionaries and many of
these data structures in detail in data structures
291:08 - portion, but just I have introduced this,
just consider this set has three elements
291:12 - Apple 4.9, and Jerry. Apple is one object
or one data. 4.9 is one data, which is a floating
291:20 - point data and Jerry is one data which is
a string data. Okay, so this S has three elements,
291:25 - three different elements. So now for x in
this set, as long as x is in the set, the
291:31 - very first time the x will be Apple, so it
will print Apple, next time x will contain
291:37 - a 4.9 as long as so I create over this set,
as long as x is inside the set big elements
291:45 - one by one, and just print them all. Okay,
we expect that when x is Apple, when the very
291:52 - first time x will be Apple, it will print
Apple next time x will be 4.9 it will print
291:57 - 4.9. Next time x will be cherry it will print
cherry, and the loop ends because there is
292:02 - no item in sets to iterate over. Because the
loop finishes it's complete iteration there
292:09 - are expected three iterations and the loop
finishes those now the else part will execute
292:14 - and you will say okay, loop completed. So
iterations. Well, you will be wondering in
292:19 - what case the else will not else will not
execute. If you apply any brake statement
292:26 - inside the loop body, which means you forcefully
you forcefully remove some of the iterations
292:33 - that were going to be executed but the loop
did not complete it did not complete citations,
292:40 - then the L spot will not run. So let's see
an example in in in Jupiter to get a good
292:48 - grip on this else. Okay, let's define a set
S. S is a variable name. You can have any
292:57 - variable name that say it Apple, or let's
say 4.9 I guess and then we was having, let's
293:08 - say, Sherry, if if these Spelling's are correct,
I guess jelly. Okay, then for x in PES, as
293:17 - long as x is ns Brand X. Fine ELLs rant, when
you finish the law terminates with success,
293:34 - or all iterations it completed all its iterations.
And this is a statement that is completely
293:39 - outside the loop. side the loop, so let's
run this. So you can see Apple 4.9 cherry
293:52 - loop terminates with success outside the loop.
Okay. Now you might be thinking in what case
293:59 - this else will not execute. Okay, if, for
example, as long as x is an N, if I say okay,
294:09 - let's say I take a counter here, I equals
one, that's a counter, let's say, and every
294:16 - time I just increment i, i plus equals one,
and then I check if i is equal to three. If
294:31 - y is equal to three, then just break. Let's
say
294:37 - else just for readability else was now this
else is else of this four. And this else is
294:47 - else of this if and this POS statement is
just a statement for doing nothing. Now what
294:53 - you do when is equal to one you Brent this
i plus equals I becomes two two is equal to
295:00 - three false, so you pass you move on. Next
time, x will print 4.9, I will become three
295:07 - and three is equal to three, that's correct,
the break will execute, which means the loop
295:11 - should have one more iteration, but the break
just disrupt that one more iteration that
295:17 - should be there, because the loop could not
complete its iteration due to this certain
295:23 - condition, this else part of the loop will
not execute, and you will go directly outside
295:28 - this loop. So let's run this code and see
the result. So you can see this apple four
295:33 - by nine outside the loop. I would recommend
although this else is there for for loop,
295:41 - but I would recommend to avoid using ELS in
the beginning, I mean, you may be confusing
295:49 - this else By the way, there is a there is
a mistake here, this l should be ended with
295:54 - a colon here, okay. So I would recommend to
not use LS clause for a for loop in the beginning
296:00 - until you you really need it. Because you
may confuse this else with the with the L
296:07 - of F condition. And you may think something
else and the program behave in a different
296:11 - way. So either way, if you want to use LS
LS for a for loop is there in Python. Okay,
296:20 - just one more example of for loop. And here
we use dictionary, I'm introducing some data
296:27 - structures here just for fun, we will see
these data structures in detail later on.
296:31 - So dictionary, that's a key value period like
set, but one item is consists of two numbers,
296:37 - that's called a key. And that is called a
value. That's a key. And that's a value like
296:42 - a dictionary, we have key and values. So now
as long as x is an X, X represents two key
296:51 - and d is our dictionary and D off x represents
to whatever value that x points to, for example,
296:59 - Apple is a key that points to 44. Cherry is
a key that points to gain. For example, if
297:04 - we're ID, apples, apple, the result will be
44. Similarly, d of Jerry, the result will
297:15 - be game. Okay, so let's I create over this
dictionary using this for loop. All am I showing
297:21 - you that this for loop is very, very handy
of creating over different data structures
297:27 - and a lot of data and stuff. Whereas file
while loop is more handy and checking the
297:34 - conditions and stuff. Although you can do
all the stuff using while loop you can always
297:39 - stuff using for loop but one is better over
the other insert in certain situations. So
297:46 - that's let's let's just run this for a dictionary.
Let's say I have a dictionary D. It's defined
297:55 - like a set, let's say my key is a and my value
is 10. Let's say my key is B and value is
298:04 - minus 19. And let's say my key is C and my
value is let's say ABC, let's say that's my
298:18 - dictionary. So for x in the Brent the key
as well as the value of that key. So now you
298:30 - can see the key is a the value of Stan The
key is B the value is minus 90 in the key
298:35 - of C the values ABC. So this far loop is really
really handy and iterated over a lot of data
298:43 - structures and stuff although it has other
applications as well but this is handy. Okay
298:50 - great. So that's about loops for loops. And
while loops These are two kinds of loops in
298:56 - important loop these are two important kind
of loops and they are in
299:00 - Python, in the next video I will directly
go to Jupiter and Jupiter notebook and we
299:08 - will be practicing for this for loops or while
loops. We will be practicing the loops we
299:14 - will be doing actually examples of nested
loops we will be actually solving a problem
299:19 - like we did in the if conditions we solve
the problem Previously, we wrote a code for
299:23 - it. Here we will also write a code and we
will be get a good grip on the loops. So hope
299:30 - to see you in the next video we will solve
a problem in Jupyter Notebook directly. Okay,
299:36 - hope to see you in the next video. Okay, welcome
back. In this particular video we are going
299:42 - to practice for loops are basically loops.
So let's have a problem statement. First,
299:47 - what problem we are going to solve let's have
comments. And the problem we are going to
299:52 - solve is let's define given a list of of numbers,
numbers. For example, I II, let's say 124
300:09 - minus five, a 7932, like this, make another
list making another list that contains all
300:30 - the items in sorted order from minimum to
maximum, ie, your result will be another list.
300:52 - Like, in this particular case, we will be
having minus five, which is smallest, then
301:00 - we will be having one, then we'll be having
two, then we'll be having two, then we will
301:06 - be having two, then we'll be having three.
So all items, but in minimum to maximum sorted
301:13 - order, then we having I guess, four, then
we'll be having seven, and then we'll be having
301:18 - nine. So that's your, that should be your
output in another list. So assuming this list
301:25 - is available to you, or any list is available
to you assume this list is available to you.
301:30 - So how to solve that problem? Let's start.
Okay, let's assume that the list is available.
301:36 - That's it, this is the list we are going to
sort. Let's say this is available. Okay. Okay.
301:47 - So, what should be the logic? What should
be the logic? How can we solve that problem?
301:55 - This is, this is an easy looking problem,
but it is not so easy. Let us first right.
302:05 - Let us just simplify this problem to just
finding out a minimum from the list. Let's
302:10 - say we are given a list and we just want to
find out minimum number one a minimum from
302:15 - the list. So how can we move that. So let's
say M is some number. So M is the very first
302:24 - value of the list, let's MSP our variable,
let's say that's the first value. And what
302:29 - we do is for i in the for i n L, as long as
I is an L, if I AI is smaller than m, then
302:47 - if AI is smaller than m, then m should contain
AI. Otherwise do nothing. That's it. So at
302:59 - the end, rentas m, then this m at the end.
So, Brent, the minimum number, that's great.
303:07 - So so that's the nasty, basically. So yeah,
that's the that's how we will find out just
303:22 - the minimum value. So let's run this code.
And the minimum is minus five available to
303:27 - us. What if we want to store the minimum value
as well as the position of that value? For
303:35 - example, we not only want to just find out
what is the minimum number, we also want to
303:42 - find out at what index for example, here 012,
and three, at the third index, we found the
303:48 - minimum, what if we're interested in the index
as well. So let's say for the very beginning,
303:53 - the index is zero. And then what we do is
303:57 - we moved on and we say, okay, we maintain
a counter, let's say a counter is C equals
304:07 - c equals zero, for example, right now, and
C, just plus equals to one, that's a counter
304:17 - and then this ID x is just that C, whatever
that c is. So whatever that index is, when
304:26 - we find this C, that index is also there.
So let's print the index as well as the minimum
304:34 - value. So okay, so at the position three,
at index three, we found the minimum value,
304:40 - okay, now we have written kind of a code block
that helps us finding out the minimum value.
304:49 - How can we actually how can we actually do
how can we act? So the basic logic is you
304:57 - find the minimum value and swap the that value
with the very first value, okay, great. And
305:05 - then move the loop next time find out the
minimum value from the remaining list and
305:12 - swap that minimum value with the second value.
Next time you find the minimum value, as long
305:17 - as the position and swap that with the third
value and so on. So do that stuff and just
305:23 - rearrange the same list using this but, but
how can the so that's the logic find out the
305:29 - minimum value. So happened with the first
value and then start from two till end start
305:35 - from start from the remaining values, find
the minimum so appid with the first value
305:40 - of the remaining list, then reduce the list
step by step and you will be having a sorted
305:46 - order, but how to start with how to find out
like this how to how to do that. So, any idea
305:55 - and we are going to so for example, in this
particular case, if I want to swap the list,
306:01 - what I will do is I will say okay, swap with
zero at the at the at the zero, so, I will
306:10 - contain a temporary variable, temporary variable
will contain the value of zero, this zero,
306:18 - so what I will do is at least zero, right
the minimum value and the minimum value. So
306:29 - at zero you write the minimum value, but at
this particular index, from there, we found
306:35 - the minimum value, just place the just place
the the value at the very beginning. So in
306:45 - after that, after that operation, the minimum
will be at the first position, or the zeroeth
306:50 - index, and that value will be some minimum
value will be swapped with the very first
306:54 - value. So let's run this code and see what
a list looks like after that good. So you
307:01 - see, for example, the minimum value is swept
by the first value, whatever the first value
307:07 - was, but we want to do that progressively
for for the rest of the list, we want to find
307:12 - out the minimum and follow up with the first
one for the rest of the list and keep on moving.
307:16 - How can we do that? So yeah, that's, that's,
so let me define four. So let me first in
307:27 - depth a bit, let's say control right bases
that will indent all my code. So for j in
307:39 - range, length of the list, whatever the length
of list, let's say for G is that so what I
307:47 - do is M is the gf value the index right now
is J and the C is also C is also the Convert
308:03 - C is also starts from J, okay, great. Now,
we want it to start with two now we want this
308:11 - I to start from J and move onwards here. So
let's say i in range, start from G and go
308:24 - till length of L, one by one, take the step
of one. Okay, great. So what next? Now the
308:33 - value will be L of I, rather than simply L
of I rather than simply I in that case, you
308:43 - do this.
308:46 - Okay, and the index is just C. Okay, great.
Keep on keep on introducing this index again,
308:54 - after this loop, what you do is you pick the
gf value, you slap the gf value with the minimum.
309:04 - And you do that. And that's it, you keep on
moving and offer after the outer loop finishes.
309:12 - If you branch your list, you will be having
the list sorted or at least we hope so. So
309:19 - maybe there is a bug in the code or maybe
there is a problem in the code. But we hope
309:23 - this will work. What we are doing progressively
By the way, this is a nested loop. This is
309:27 - a loop inside the loop and that's and then
we have an if condition inside the nested
309:33 - loop. Loop inside the loop. Great. Let's see
how it how it works. If there is no Oh there
309:42 - is an error length of range. Oh, we haven't
write a colon there. Don't forget this colon.
309:48 - That's a problem. Oh, we have a sorted order.
Oh my god. We have a result with us. You see
309:55 - the applications of this. Oh, one three is
missing. We were is three, we have two threes
310:02 - Oh, the output we have written here is wrong,
there is no two threes there is only one three.
310:07 - So you have sorted a list. If you remember,
we have written a similar kind of code in
310:14 - the problem. So problem solving session very
earlier, where we solve this problem using
310:18 - selection sort, but they are we just wrote
a pseudocode. And here we have a code much
310:25 - simpler than actually the Python code. If
the problem was just sorting there are built
310:31 - in functions to do that, but I'm just telling
you how these loops and if conditions and
310:36 - all that stuff can be used to communicate
with each other to match with each other to
310:43 - to actually perform a problem solving task
when given a problem. Although we will see
310:49 - later on in Python, most of the problem solving
tasks, I mean many more of them, there are
310:53 - a built in function for those that are available
functions for those you need not write all
310:57 - that stuff, but to mastering to to master
any programming language, you have to go through
311:02 - these constructs. So that for a new problem,
or for a very large, complicated kind of problem,
311:08 - eventually you you may need these kind of
structures with you. So mastering these structures
311:14 - is really essential for problem solving and
programming in general. So okay, that's about
311:20 - the loops and if conditions and control. So,
all of that, in the next video, I will I will
311:27 - start talking about functions. So you have
seen this L e m data function, you have seen
311:31 - this range, that's that's function idolater.
Although you have seen around function, you
311:37 - have seen def mode, you have seen print function,
what if we want to write our own function?
311:42 - How can we do that? From the next video, I'm
going to show you how can we write our own
311:47 - function? Wow, isn't that great? That's great.
So hope to see you in the next video. In this
311:54 - video, I will talk about functions. A very
powerful construct in almost every programming
312:02 - language. Python also supports functions.
What a function is, let me let me describe
312:08 - the let me describe the need of the function
by a scenario. Let me give you a scenario.
312:14 - The scenario is let's say you are writing
a very lengthy program, the program requires
312:21 - to print particular messages whenever needed,
for example, you need to print this particular
312:29 - message the task, the task was successful,
let's say you need to print this. And then
312:38 - you have to print moving to the next task
maybe to to inform somebody maybe in to inform
312:44 - your client. And then you have to ask, okay,
send me the next task. Because I am done with
312:49 - the previous task, let's say you want to print
this, or maybe you want to print more or do
312:54 - some more stuff. And let's say you want to
do this again. And again, whenever needed.
312:58 - Somewhere, whenever you complete a particular
task or something, you want to print all these
313:03 - messages, and then somewhere else, whenever
a particular event occurs, you need to print
313:09 - all these messages again. Now one way to do
that is to write just these print statements
313:15 - whenever needed in the program. One way is
if you want to perform a task and the task
313:21 - has a lot of coding, maybe maybe maybe a very
small amount of coding or maybe a very large
313:27 - amount or magnitude of the coding. In this
case, we have just three statements, but maybe
313:32 - we have a task that we want to perform again
and again and it is really a very lengthy
313:36 - task in terms of the coding.
313:38 - So, one way to do that is to just write all
the coding in coding somewhere and define
313:47 - a function and that function means the function
contain all the tasks that you need to perform,
313:54 - whenever you need to perform that particular
task. Just in your coding, just call this
314:00 - one statement, just this one statement, and
the whole task that is written under this
314:06 - under this content maintaining this as a heading
that will execute automatically I mean, however,
314:15 - I mean, that task that is under this heading
may be very lengthy may be short, may may
314:20 - be complicated, may be simple one or anything,
but the need is we want to perform this task
314:26 - whenever we need. And we do not write to code
this again and again we do not write to code
314:31 - we do not write to we do not want to write
the same lines of codes again and again and
314:36 - again. And again in our program. Just write
this particular lines of code once define
314:43 - a function, just like a task. Whenever you
need to perform that task, just call the heading
314:49 - or the name of the function. And the whole
task under that function will execute functions
314:55 - in almost all programming languages. They
do that even in mathematics. They do that
315:00 - In Python, the syntax of defining function
is you if you want to define a function, you
315:05 - have to first start with D E F meaning definition
or defining, then you need to write the name
315:13 - of that function the name of that function
name a function and name a variable has resemblance,
315:19 - I mean, the name of functions should be descriptive,
it should, it should portray what the function
315:25 - actually is doing. So, it is good to write
it is good to suggest the names of the functions
315:30 - that are very descriptive to make the code
readable and manageable. So, here I have written
315:35 - the function name is sprint success, you can
write any name, then you start parenthesis
315:40 - then you end parenthesis and then you write
a colon like you have written the colon for
315:44 - if conditions are for loops or any other constructs.
And then you do indent like the body of the
315:51 - for loop like the body of the if condition,
this is the body of the function, body of
315:54 - the function is all should all be aligned,
then you write all the tasks, all the coding
316:00 - that you need to be performed whenever this
function is invoked or called, this body can
316:05 - contain if conditions for loops inside, I
mean, this can have a whole lot of coding
316:11 - inside it. And whenever you will call this
function, whenever you will type this command,
316:16 - wherever in your coding, the whole task under
this will be executed automatically again
316:22 - and again whenever you like. So, let's take
a look of defining our first function in Jupyter.
316:28 - notebook. Let's just I guess, yes. So, yeah,
so, that's our notebook, we were populating
316:41 - that notebook. So by the way, if you if you
want to know where this notebook is located,
316:46 - if I want to, for example, invoke that notebook
again, when you will run your Jupyter Notebook
316:53 - from the Anaconda prompt, you will be having
all the files that you are working on. And
316:58 - one file is for example, this you just click
on that, and your file one or more files,
317:03 - whatever you want to open up that will open
up in the Jupyter. notebook. Yes, so it is
317:10 - opening up, it's a lengthy file, so it may
take may take a second. Okay. Let me just
317:17 - take a better zoom level, just to Okay, so
we were working on that notebook, let's define
317:25 - our first function, let's say D, F, define.
Let's say the function name is Brent. Success.
317:39 - That's a, that's a syntax, then press enter,
Brent, I am done. Then Brent, send me another
317:56 - task. Let's see. And that's it. Let's say
that's the, that's the body of the function,
318:04 - the body of the function here contains only
two statements, okay, then you run this, you
318:10 - run this command, just like Shift Enter, you
run this. So that
318:16 - it is it is reported in the symbol table,
there is a symbol table inside the Python
318:20 - maintaining Python is maintaining all the
variables all the function information inside.
318:25 - So once you run this cell, then the then this
print success function will be registered
318:31 - to Python. So that whenever you want to call
this function, again, it will be available.
318:35 - Now if you want to perform this task, let's
say you want to perform, let's say you want
318:40 - to perform this task whenever you want. So
you just call this function, this is called
318:46 - calling of the function. whatever I'm doing
now, when success and that's it, you press
318:52 - Shift Enter, and the all the statements that
are under this will be executed. And you do
318:59 - some other stuff, let's say three plus eight
that is that is 11 do some other stuff. And
319:07 - afterwards, if you want to do the same process
again, then you call this function again and
319:17 - all the coding inside the function will be
executed it is very, very handy. If a particular
319:22 - task if you want to perform that task repeatedly,
it is good to just write one code for that
319:28 - task in a function and then just invoke function
whenever you need. It supplies a lot of managing
319:35 - power, a lot of debugging power if you have
an error for example, inside the function,
319:41 - you just go to the code we just go to the
code of the function itself and fix the error
319:46 - and come back You need not to you need not
to go all over the code if you have not defined
319:52 - the function and you have called these lines
of codes everywhere inside your main code,
319:58 - then it will become very difficult to handle
And function actually provides a lot of a
320:04 - lot of simplicity of managing and readability
and, and a modular approach in that sense.
320:10 - So that was our first. That was our first
function. We will be talking about more, we'll
320:18 - be talking more about this functions in the
next video. So hope to see you in the next
320:23 - video. The function name should be descriptive,
that's okay. But it is further important sometimes
320:33 - to have a documentation of the function sometimes
called the doc string, the doc string allows
320:39 - you to write the description of the function.
But that description will never be executed,
320:46 - it will be available whenever you need help.
Or you need to know what this function does.
320:52 - Sometimes it happens your function can contain
a lot of code, for example, you have a particular
320:56 - function, let's say, fun, let's say it contains
def, fun, and it does a lot of a lot of complicated
321:07 - stuff inside. And it is sometimes required
to know what this function actually is doing.
321:15 - So this document string is one way of describing
what the function is doing. You might be thinking
321:21 - that if you're writing this document string
inside the where the where the coding of the
321:27 - function should be written, we should open
up that the coding file and see what the function
321:32 - is doing, or should we actually open up this
function implementation where the function
321:37 - code is written. And then we have to read
what the function is doing. Actually, Python
321:42 - gives you another power. If you have written
the document string inside, that should be
321:46 - a top statement before the first coding statement.
Whatever description you want, as a document
321:52 - string, it will be available without actually
opening up with without actually seeing what's
321:57 - inside the funk without actually opening up
the file that contains the implementation
322:01 - of this function. Let's see, let's see. Two
in Jupyter, notebook imore, completely whatever
322:09 - I'm saying right now. So for example, let's
define a function. def print success. to let's
322:19 - say the function name, this function is print
success to the function name is print success
322:27 - two, although it's not a very descriptive
name, but the specimens are also not correct,
322:33 - but that's fine. Print success to here I just
define a document Strank. The document string
322:39 - may contain maybe just in one line, or it
may be a multi line, it is like a multi line
322:45 - comment, or maybe a single line comment if
you want. But it starts with the three quotes
322:51 - and ends with three quotes. Let's say I write
here this function is doing nothing except
323:02 - renting. message, printing a message, let's
say full stop. And then I further define let's
323:15 - say I define more in saying that that message
is
323:23 - Hello, let's say, let's say are any description
you want for this function. Now, this is a
323:31 - document string, and it will be available
whenever you need. Now here are the coding
323:35 - starts, let's say you, right according here,
and again, hello, let's and you run this code.
323:42 - Now, let's say we are not seeing this function
we are we are not available with this function.
323:48 - We are not available with the code of this
function. And we want to know what this function
323:53 - actually does. First of all, we can just write
if we write pri, and just press tab, the tab
324:01 - will allow us to access all the functions
that are available with prefix pri. So let's
324:07 - say we go to print success, brand success.
Brain success here brain success, as should
324:18 - be capital, Brent success, let's say so print
success to let's say and we write a question
324:27 - mark in front of it, and then just press Shift
Enter, it will pull the document string it
324:34 - will pull the document strength whatever we
have written and we will get to know what
324:40 - actually this this is doing. So this document
string actually does a lot of job further
324:47 - if we I mean this is this is kind of whenever
we need to know what a function is doing.
324:53 - The document string is one way to just go
and check what is what is happening. Right
324:57 - now this function implementation is in front
of us But in several times, the function implementation
325:02 - will not be in front of us several times,
we will be accessing functions that other
325:06 - people have written in their libraries. And
we need to know what those functions are doing.
325:11 - So document string is one very, very healthy
way of describing our function. And I will
325:15 - recommend to make your habit writing document
strings, every time you write a function.
325:21 - I was telling you that if you write a double
question mark, then it will not only pull
325:26 - the document string for you, it will pull
the whole implementation as well. So now if
325:31 - you see you, they said the document string,
and that's the implementation. So whole implementation
325:37 - will be available, if you want. And this is
true for the functions that are that are,
325:42 - that are the functions that are third party
functions, or some other person have written
325:47 - that function and so on. For example, you
know, a function length, we call that function
325:52 - several times. So let's let let's, let's see,
also the document string is returned, the
325:58 - number of items in our container, that length
function is not written by us, somebody has
326:02 - written that function that's a built in function,
by the way. And we can, this document string
326:08 - tells us, okay, what this function is doing,
we don't have the implementation of that function,
326:13 - obviously, somebody have written that function.
And, and if we write the double, then we should
326:21 - get an implementation as long as the implementation
is not in c++, I haven't told you that a lot
326:28 - of a lot of implementation of Python itself
has been done in C and some other languages
326:34 - have C mostly. So several built in functions,
because of because of their speed, they are
326:40 - implemented in C, and if you, if you want
to get their implementation, they get their
326:45 - code, the code will not be available for most
of the functions. So that's so whenever you
326:50 - write a double question mark, and the answer
is the same as a single question mark, that's
326:54 - an indication that this particular function
is not written in plain Python, it is written
326:59 - in some other language and is used in Python.
That's, in other words, the diversity or flexibility
327:05 - of Python, you can engage multiple languages
inside, Okay, one more thing, I can write
327:11 - Help, help command and I can get this Brent
success
327:17 - success too. And the help of print success
to by just typing this help command. So, this
327:30 - help will tell us, you see the Help is telling
us the document strike I mean, this help on
327:37 - this function, if and this and this is the
function we have written, this is the function
327:41 - we have written, this function is doing nothing
except whatever description we are giving
327:46 - there. If, at some time, if we are supplying
this function to somebody, or making a package
327:52 - of a lot of functions, that we are writing
these documents, strings will help to get
327:56 - to know how to use these functions. By just
knowing the function name, we can, this document
328:02 - string actually tells us how the what the
function is doing. While great Oh, by the
328:08 - way, we haven't called this function yet,
we are just playing with the document string,
328:11 - let's call the function print. Now we know
what the function is doing. let's print, let's
328:17 - call this function. And whatever written inside
the function will be called See, this is only
328:22 - called this is just acting as a comment and
it is basically a comment. Yeah. Okay, great.
328:32 - Stay with us. There is much more about function
that we are going to tell you. Hope to see
328:38 - you in the next video. Okay, in the last video,
we saw document strength. Or you might be
328:45 - thinking, what is power of this function,
if it is doing some static task? Well, in
328:53 - this video, I'm going to tell you that the
function can the coding or the behavior of
328:58 - the function can be dynamic, based on based
on the arguments based on some properties
329:03 - that you will be defining at the call time.
For example, the function has in almost all
329:09 - programming languages, the functions, the
most interesting functions are the function
329:13 - that receives an argument. And an argument
is just considered an argument just as a variable
329:19 - and performs its task according to that to
that arguments. argument. Just take a single
329:26 - simple example. Let's say rather than having
a function print success, we have a function
329:31 - print message, and it it prints whatever message
it receives. And at the call time, for example,
329:37 - we call this function like so print message.
And let's say we call this as, let's say,
329:49 - success. Let's say now success will be printed.
Next time we call the function and we give
329:56 - another argument maybe in a string, let's
say so 74 errors, let's see, that will be
330:06 - that will be printed or anything, I mean,
anything that you supply will be printed.
330:11 - Wow, isn't that great? I mean one function.
And you might be thinking the plain print
330:20 - function does that what's the power of this?
Well, I'm just telling you the function of
330:25 - the function does not only contain one line,
I mean, it can be a whole task depending upon
330:30 - this input argument. And the whole task will
perform dynamically based on based on what
330:36 - input argument you are supplying there. You
are noticing one one thing that I that I just
330:42 - forgot, what is that thing I define this function?
I guess everything is fine. I just have just
330:50 - missed something Oh, document string, I should
have written document string. Although document
330:54 - string is not essential. If you do not write
document string, it's perfectly okay. The
330:58 - function will run but it's a good practice.
It's an it's a good habit to always write
331:03 - a document string. Okay, let's see the power
of input arguments by again, going to our
331:09 - good friend Jupyter Notebook. Okay, so let's
see. Let's say we define a function define
331:17 - Brent grant message, let's say, edit receives
an argument message. And this argument is
331:26 - just a variable, it's just a variable. And
let's say we say okay, print message or further,
331:35 - let's say you say, if is in stance message
spraying, if this is spraying, then simply
331:47 - then simply branded. If this is not a string,
then just say okay, brand, your input argument
332:18 - is not a string. And then you say, Okay, here
is what you have, slide. And then you say,
332:34 - okay, whatever you have slide, just see, okay,
message. And that's it, that's it, that's
332:42 - the function, we might have written a document
screen for it. The function rents the message
332:56 - supplied by the user, or brains, that message
is not in the form of strength. While Don't
333:17 - worry, we have to see the strings in detail,
we will see the sprint function in detail
333:22 - as well, because the sprint has a lot of lot
to do with strings. So so just for now, I
333:28 - mean, that's our function print message, let's
say if the message is of string type, this
333:35 - string does not good, this is this should
be simply str this should not be that is instant
333:39 - steak like this, your input argument is not
a string here is what you have supplied. Here
333:46 - is what you have. So here, we can, we can
say here is here is here is the type
333:56 - of what
333:59 - you have supplied. And then we can just print
the Type, Type MSC. So the goal here is to
334:12 - just create a function that prints a message
if that message is in plain string form. If
334:18 - it is not a string, then it prints that okay,
you're the whatever you have signed is not
334:25 - a string, it is not a proper message in string
form. Let's say this print message function
334:29 - receives a string, let's say that's our logic
or something. So let's run this. First of
334:36 - all, let's see what it does help rent message.
So the function prints the message supplied
334:46 - by the user. We can access the same help by
question mark if you want and it gives us
334:57 - the document string If however, we want The
implementation as well, then we write readable
335:03 - code and implementation is also available.
While grade Python is really great. Okay,
335:10 - let's call this function. Let's call this
function, Brent, message. And whatever you
335:22 - want to print, let's say, this is the message.
This is the message, let's say you want to
335:31 - print this. And this is the message that's
printed. Okay, now, let's say you call this
335:36 - function again some time, and you supply 23.
And it will say your input argument is not
335:43 - a string, here is the type of what you have
supplied, it's an integer type rate, you can
335:51 - you can have, you can have, you can call this
function in the following way, let's say you
335:55 - define a variable y, and the variable y contains
335:59 - Hello.
336:00 - Hello there.
336:03 - That's it, that's your, and then you called,
then you call this function on y. And it will
336:16 - print hello there, because y is also a string.
Great. So that's how you can you can you can,
336:24 - you can pass different arguments and instruct
the function, how should it behave without
336:29 - actually writing the whole logic of the task
again, and again, if written all the logic,
336:35 - once, actually, this is actually the logic
starts from here. That's what the task is
336:40 - to, that's what the task you want to perform.
And you need not write this again. And again,
336:44 - whenever you need this kind of stuff, you
just call that function supplied arguments,
336:49 - and it will behave accordingly you want. Great.
So you might be thinking, the function only
336:58 - receives one argument, maybe we want to supply
more than one arguments, maybe, maybe two
337:03 - arguments, maybe three, maybe four, maybe
five, and maybe we want to supply several
337:08 - arguments. And we want to do some task based
on the values of those arguments, or those
337:15 - variables. So in the next video, I'm going
to show you multiple arguments. Okay. Hope
337:23 - to see you in the next video. So in the previous
video, we saw we can define a function, and
337:29 - we can supply input argument to it. And in
this video, we are going to see that we can
337:34 - actually send more than one arguments to the
function these arguments are just variables,
337:40 - these are just variables, whatever value we
will supply to these dynamically, because
337:44 - Python is dynamic dynamically typed dynamically
they are type will be defined. And for example,
337:50 - here we have supplied just two variables,
and we just printed them, but based based
337:56 - on supplying more than one input arguments,
and based on what logic we are going to perform,
338:03 - we can do anything, we can do anything. So
guess by thumbs, allows us to supply multiple
338:12 - input arguments to a function and and we can,
we can just perform all the tasks according
338:20 - to whatever logic we are going to do with
that. So let's go to our friend Jupyter Notebook
338:25 - and see an example of a function with multiple
input arguments. Let's say the function the
338:34 - B define a function, let's say, my power,
let's say, my power, my power, let's say,
338:45 - you remember there is a POW function in in
Python that's a built in function. I'm going
338:49 - to write my own function, let's say it contains
a and b. Well, document string. My, this function
339:06 - computes
339:09 - power
339:11 - just like built built in power function. Great.
That's the document screen. Okay. Now what
339:22 - we want to do is we want to print Okay, let's
let's, let's create another variable, see,
339:29 - that is a power B. Okay, then we print this
C, and we are done. That's it. That's our
339:39 - goal. So we register that function by just
just calling the job by just pressing the
339:46 - shift enter in Jupyter Notebook. And now we
check what this function does. Well, this
339:55 - function can be horsepower, just like built
in power function. Okay, just to Just to remind
340:01 - you again and again, the importance of document
strength, I'm writing this again and again,
340:05 - let's run this function, my power, let's say
three ways to recover for illness. So the
340:15 - result is 81. Oh my god. So whenever, by the
way, if you don't have POW function with you,
340:22 - although you have, you can you can create
your function and whenever you want to use,
340:27 - you can use your function, not a big deal.
By the way, what if you? What if you What
340:38 - if, let's say, you can, you can define a function
with more than two arguments to find, let's
340:45 - say, display types. That's it, that's your
function display types. And all you know,
340:56 - is our check arguments, let's say, check our
x. That's it, that's your function, and A,
341:06 - B, C, D, let's say E, these are the input
arguments. And let's say, at some tasks, you
341:13 - want to know whether all the five variables
that you're working in somewhere, whether
341:19 - all of them are numeric values or not. If
they're not numeric values, you're not moving
341:24 - on, and you're doing something because you
were extra, let's say you're, let's say you're
341:30 - taking input from somewhere reading from a
file or whatever. And you need to, you need
341:35 - to check before moving on whether A, B, C,
D, and E, whether they are in sore floats.
341:41 - Otherwise, if if if any of them is not into
float, then you're not processing, then you're
341:47 - not moving on, and you're going to check the
input arguments again, and so on. These kind
341:52 - of functions are there because whenever you
call certain, whenever you want to do processing
341:57 - on data, sometimes it is required to check
the type of the data whether the data is supplied
342:01 - in a way that you were expecting and so on.
So let's have this function check Oryx. I'm
342:07 - not writing document string here, I guess,
I've told you enough to write document string
342:12 - again and again. So let's see. If is instance.
A, if is instance int float? If that is true?
342:30 - And 
342:40 - is it let's just have three variables just
to just to focus on if is instance, a then
342:49 - B. and 
is instance see if all of them are? If all
343:07 - of them are? If all of them are integers or
floats, then do something then let's say Brent,
343:20 - a plus b, plus C, maybe, or a plus b plus
c, raised to the power to just print their
343:32 - square, let's say else are if they are if
they are all integers or floats, then do some
343:42 - interesting task here some task. Otherwise,
you can say okay, print,
343:52 - air. The input arguments are not of the expected.
But it's fine. You have this function, let's
344:11 - say, let's call this function.
344:15 - The function was check arcs. So let's check
arcs, check. arcs, check arcs, let's say three,
344:25 - four, or five. So now you have all of them
are great. Let's say you have jet arcs. And
344:35 - you call this check ARDS.
344:38 - On,
344:41 - let's say, three, four, but this five is a
string, let's say, Gee. Now we'll be having
344:51 - an error. The input arguments are not all
of the expected types. One of them or more
344:57 - of them or whatever. Yeah one more thing the
this function is expecting three arguments
345:06 - if you call this function by less than three
or more than three arguments you'll be getting
345:12 - an error for example three four although this
function is accepting three arguments, you're
345:18 - calling it with just two you're getting an
error because you have not specified all the
345:23 - arguments that the function is requiring although
the the arguments that you have supplied they
345:28 - are of the type that it is expecting, but
you have not supplied the the number of arguments
345:33 - that the function is expecting. Similarly,
if you call this function by more than three
345:41 - arguments, although it requires three arguments,
you again will get an error, because it is
345:46 - expecting three arguments and you have not
supplied three arguments. later on. In later
345:55 - on, we will see how to write a function that
accepts a variable number of arguments, we
346:02 - will see that but right now, in this particular
way, if you write the function, if you define
346:06 - the function in this particular way, you have
to define the arguments the number of whatever
346:13 - the number of arguments it is expecting, you
have to supply exactly as many. Otherwise
346:18 - you are getting an error. Okay, so that's
about the multiple arguments. Okay, what next?
346:28 - Well, next time, in the next video, we will
see that what is the what's the importance
346:37 - of order of these input arguments? What will
happen if I just swapped message to win message
346:43 - one? Will that will that change the behavior?
Or is there any order? With the first mess?
346:50 - The first variable, the second variable, third
variable? Is there any ordering inside the
346:54 - input arguments? Yeah, there is. So let's
see in the next video, in the last video,
347:01 - we saw, how can we pass multiple How can we
define a function with more than one input
347:07 - arguments, it is important to know that the
order of the input argument is really, really
347:12 - important. So whatever argument at the call
time, for example, if you call this particular
347:18 - function, the name of the function is f, that's
not a great name, you should have a name that
347:23 - a descriptive but I recommend write good names,
let's say this is f, that's a function and
347:30 - the very first variable is C to the second
variable c one, the third variable is C three.
347:36 - Now you let's say call this function like
like this, let's say two, four and nine, what
347:43 - will happen is this too will be copied in
C two, this four will be copied in this C
347:50 - one and this nine will be copied in this C
three. Now, C two has a value two, c one has
347:59 - a value four and C three has a value of nine.
If you change the symbols or the variables
348:06 - order here, whatever order you have written
there, the first value that is passed at the
348:12 - call time will be passed to the first variable
whatever the name of the first variable is,
348:18 - the second value at the call time is copied
in the second symbol, whatever the name of
348:25 - the symbol is. So, this ordering is really
really important. One way to work one workaround
348:33 - for this is at the call time, you actually
define the variable names and their values.
348:39 - For example, you call you call F and you say
okay c one has this particular value, but
348:46 - this way you need to know that there is the
symbol name in definition is exactly c one.
348:53 - So, C one has this value, C two has this value,
C three has this value, once you at the call
349:00 - time, if you have defined your variable names
along with their values, then you are order
349:06 - free. Now you change whatever whatever if
for example, you call this way c two is b,
349:15 - c one is a now no matter in what order you
have called these,
349:24 - this C one is going to be copied in C one,
the C two is going to be copied in C two and
349:31 - C three is going to be copied in C three for
the functions that has many more arguments,
349:38 - it is it is good to it is good to call the
function in this particular way. If there
349:43 - is a chance that calling a function in a different
order may may may become confusing and stuff
349:50 - like so. This actually gives you more grip
on this ordering issue. if if if you're if
349:57 - you're happy with if you're very smart and
When you say Ok, I will always supply in a
350:02 - particular order, I will always read the document
string first, and then I will call that function,
350:07 - that's okay. Otherwise, this is also a feature
that is available at the call time, you assign
350:13 - the values of the functions that are there
at the definition time. And now no matter
350:19 - in what order you are calling that function,
see one occurs at third position c two occurs
350:23 - at first position, the relative values will
be copied according to their names. So and
350:30 - that's a good feature. That's a very good
feature. Let's see, for example, a running
350:34 - example of this in Python. In Jupyter, notebook,
okay, define, let's say function f, let's
350:43 - say it receives a, b, and c, let's say three
values. And let's say prints. A, is that's
350:55 - it, Sprint, a, is a. And you'll say okay,
B is B. And then it prints Okay. See, C, C
351:15 - is, whatever the value of c is, that's the
C, okay? Now, let's call this function f,
351:25 - with, let's say, two, three, and game. So,
they will say, okay, a is to B is three, C
351:36 - is game, fine, great. Now, this tool will
be copied in a no matter what if we if we
351:45 - change this, if we change this calling order,
for example, if we if we change this order,
351:51 - we just we just moved to we just moved to
this particular order, we just say okay, this
352:00 - is three, this is game, this is to be called
like, so now three will be copied in a game
352:11 - will be copied in B and two will be competency.
And that, if if if that is the behavior you
352:19 - want, then you are good to go. Otherwise,
it is it is handy to call the function in
352:24 - the following ways just fix, okay, a is a
is to fine. B is three. And C is let's say
352:40 - again, if you want these numbers, now, if
you call a function like so, that will happen.
352:45 - Now, if you change the order, no matter what
order of add the calling time you come up
352:53 - with, it will stay the same. For example,
you go and say okay, C is at the first position.
353:02 - And a is at the second position, let's say
two, and B is at the third position three,
353:10 - the output will stay the same. And that's
a, that's a beautiful, that's a beautiful
353:15 - thing. So that's one way of handling with
the order. If you if if you think at call
353:23 - time it is important to define the variable
names, but it has one problem that you need
353:29 - to know you need to know exact variable names.
If the variable name is C one there, you need
353:35 - to know what it's see one, you need not to
I mean the C one matches with C it must match
353:41 - with C one, C two must match with C two and
so on. So you need to know these names. Okay,
353:49 - great. In the upcoming videos, more features
of functions are are going to are going to
353:57 - be discussed. So stay with us hope to see
you in the next video. So we in the last video,
354:03 - we saw the ordering of input arguments in
a function.
354:09 - And we saw a fix to it. I mean, if you if
you if there is a chance that you may miss
354:15 - a proper order, there is a way to fix that
we saw that in the last video. Here, we have
354:21 - another another thing to discuss this x variable
x input argument This is the variable that
354:29 - is defined inside a function although the
value it receives is copied from somewhere
354:35 - else, but it is defined inside the function
that is also the function variable or the
354:40 - or the variable that is in the scope of the
function inside the function in the body of
354:44 - the function something like so it may be handy.
For example, let's say you want you you compute
354:50 - something you do some processing on your inputs.
And whatever the result is you save that result
354:56 - in another variable. And let's say now you
need the value of this variable. to do some
355:01 - further process, let's say, what you do is
let's say in a call time, that's let's say
355:06 - this is the this of the function and say,
This is the complete function. And let's say
355:11 - a is equal to 12. And B is equal to, let's
say seven. And let's say you call the function
355:18 - add a, b, now the value of a will be copied
in x, the value of d will be copied in Y,
355:26 - okay, and now, you need the Sum of a and b,
to be received here, in a variable, you want
355:35 - a variable in which the results should be
saved. For example, let's say a variable is
355:40 - D, let's say, and then you want to do some
more processing on D, let's say d doublestar
355:50 - five, mod three, and maybe you need to apply
an if condition on that if that equals to
355:58 - zero, then do some stuff otherwise, so let's
say you need this variable out, what will
356:05 - happen is this C variable is not accessible
outside this function. And the reason is the
356:11 - C is defined inside the function when the
function body completes its execution, the
356:16 - C is lost sees no more available, C is defined
when the function call has been made, when
356:23 - the when when you're executing the statement
C is defined and a memory location was created
356:31 - in a C sometimes called the function space
in the memory or process space that is created
356:36 - in memory. But once all the body of the function
executes all the functions that were inside
356:42 - the variable they are lost, what how can you
How can you receive this value? How can you
356:48 - receive the value inside see outside this
function? So, that is, that is question in
356:56 - this slide, how can we do that further,
357:00 - this particular function can access all the
variables that are not defined in this function,
357:08 - but that are available outside this function
and are defined already. For example, let's
357:13 - say I have a function, f. And the function
is let's say I have a function f. And so if
357:22 - this function is defined, like so f, let's
say F is your function, and it has to find
357:27 - like D, E, F, and that's it. And here it prints
let's say, some variable, let's say a. Let's
357:36 - now now you know this a variable is no longer
in F not even defined in F, but as long as
357:43 - this a variable is defined, before calling
F for example, that's the cell where we are
357:49 - writing the code and we say okay, a is equal
to seven, and then we just call this F, because
357:56 - a was available before calling f a will is
accessible here. So, the functions the variables
358:03 - that are available before the call, they are
available inside the functions, but the variables
358:10 - that are defined inside the functions, they
are not available outside. That's the problem
358:16 - further, if we define this ad here is equal
to two now, this a is sometimes called the
358:22 - local variable or the function where the variable
there is local to the function. Now, this
358:28 - a is is is defined inside the function and
all the accesses to a will access this value
358:35 - to rather than the sound considered sound
has a separate location in memory, and this
358:40 - too has a separate location and memory, both
have names a, but this a will only be referred
358:46 - to when the function is executing, after the
after the execution of the function completes
358:53 - this has gone from the from the memory and
this will still be available, the seven will
358:57 - still be available. So it is good to know
and by the way, if a was not defined here,
359:04 - and you still call F, then either you will
be getting an error, or this a might be a
359:10 - global variable or available in some package
that you have already loaded or stuff like
359:15 - so, in that case, this eight will be accessed
if it's a global variable or accessible. So,
359:20 - it is good to know the the scope of the variables
inside the function because when you're calling
359:26 - them what functions if this if x is already
defined, for example, if x is already defined
359:33 - like 34 and then this x is 34, as long as
this x is not defined here, if x is defined
359:42 - here, this is this x actually is the local
copy and that will be accessed inside the
359:46 - function. Once the function is gone again
x will be 34. So, it is good to know the local
359:52 - copies or or the function space itself. The
but but the problem here is how to access
359:59 - them. This variable the value of this variable
outside the function, because this is completely
360:03 - defined inside
360:06 - how to access that? Well, well, there is a
fix, and that fix is called the return statement.
360:13 - If you write the return statement, for example,
you return this value. So x plus y, you might
360:20 - have saved these values, you might have saved
these values, for example, C equals x plus
360:25 - y, that's okay. And then you say, okay, return,
see, what will happen is wherever you have
360:32 - called this function, d equals add, let's
do three. Now, this value, this value C, which
360:40 - in this particular case is five, that value
will be returned in D, and all the properties
360:46 - of this variables are returned in D. So just
like the C is copied in D, and this is available
360:52 - further, whatever you want to do with this
D. Okay, so yeah, so return statement is there.
360:59 - So, in the next video, we will actually code
this in Jupyter Notebook and see the return
361:05 - statement running and we will see the scope
of the variables and all that in Jupyter Notebook.
361:10 - So hope to see you in the next video. In the
last video, we saw a scope of a variable particularly
361:18 - if a function if a variable is defined inside
a function, is it accessible outside the function
361:24 - and if a variable is defined outside the function,
is it accessible inside the function and vice
361:31 - versa? and so on. So we discussed those kinds
of things, which is sometimes called school
361:35 - scope of a variable. And further, we discussed
what if we want, what if we want a value of
361:41 - the function that is computed value value
of some variable or some result that is computed
361:46 - inside a function? What if we want that to
be accessed outside, outside the function?
361:52 - So we discussed that in detail in the last
video, so let's see all those concepts in
361:59 - a running form in Jupyter. notebook. So let's
see how it works. So first of all, let's define
362:08 - variables, let's define a function, let's
say define, let's say, my ad. And let's say
362:18 - it receives two arguments, let's say a and
b. And then let's say C is a plus b, let's
362:29 - say that C are our c value, that's a c value
or some value, whatever, whatever you want
362:39 - to call that value, some value. That's it.
Let's say we did, we did that. Now we want
362:46 - to access that some value from outside the
function. paint some value. By the way, let's
362:58 - first call this function, let's say my app,
add four values, let's say two, three. So
363:06 - two will be copied in a three will be copied
in B. So then, let's access let's try to access
363:13 - this value, some value, it will throw an error.
And the reason is this variable, some value
363:21 - is not accessible outside this function. What
if we want to access because this is defined
363:25 - inside the function? What if we want to access
this? I mean, what if we want to compute some
363:32 - result and then use that result outside the
function? So the way out, as discussed in
363:37 - the last video is return statement. Return
Value. And now if we call that again, let
363:46 - me let me go if we call that again. Now, what
we haven't actually registered, by the way,
363:55 - remember this, that's, that's a common error
I got in that era, a lot of a lot many times.
364:00 - If you change the implementation of the function,
you have to rerun that cell, you have to register
364:05 - the updated copy of the function to the Python,
otherwise, you will be getting errors. Probably,
364:11 - yeah. What's the problem here? Now, when somebody
Oh, we, oh, there's somebody is still not
364:18 - still not accessible. Because some value is
not is not accessible it is it is a variable
364:24 - defined inside the function it is scope in,
its the scope of this variable, is just the
364:29 - body of the function. So let's receive this
output in a variable D. And then let's just
364:38 - print D and D is five. Great. So one more
thing. Let's say we define a variable here,
364:49 - of variable outside the function, let's say
that's a label name. That's a very lengthy
364:58 - name, but let's say that's the name variable.
Well outside the function that saves value
365:02 - is three. And then
365:07 - then let's define another function somewhere.
Let's see, let's define another function down
365:14 - somewhere, let's say define F, maybe G, and
it receives nothing, but it prints this, that's
365:29 - a variable. out side the function. And that's
it. That's it, that's a function. Now, when
365:37 - we call this function, this variable outside
the function that is accessible inside the
365:44 - function. So so and and, and if this function,
and if this variable is not defined inside
365:52 - here, and if there is this is defined somewhere
else, and it is global or accessible, it will
365:57 - still be accessible. However, if we define
a function with the same name, let's say variable,
366:06 - outside, outside the function, let's say five,
now, this function will print five, if we
366:15 - because that's the local variable, that's
the local variable in the function. Now, this
366:20 - will be accessed in this print statement.
Let's see. Now the result will be five. But
366:28 - if you print the variable outside, now the
value will be three, because this variable,
366:39 - this particular variable that was inside the
function, it got destroyed when the function
366:43 - finishes. And this is available again. So
yeah, so you need to know, by the way, it's
366:51 - a good practice whenever you want to, whenever
you want to access a particular variable inside,
366:57 - it is a good practice to pass that variable
as input argument to minimize the confusions
367:02 - because this can create a lot of confusions.
So it's a good practice, although the feature
367:07 - is available and sometimes useful as well.
But it is always recommended to pass the values
367:14 - as input arguments that whatever you want
to access inside the function. Okay, so one
367:20 - more thing, this, this function g is returning
nothing. For example, it is not returning
367:29 - anything, it is just printing, let's say something,
let's say it is not printing anything, let's
367:34 - say, let's say this is a comment, let's say
it is not printing anything. So this, and
367:40 - then we call this and that's it. So it has
no return value. By the way, in Python, even
367:47 - if you even if any function, even if a function
does not return anything, it still returns
367:53 - a value, which is called none, which you can
see here. So in Python, a function always
368:00 - returns a value. If you write a return statement
explicitly, it returns that if you do not
368:07 - write return statement, when the function
body finishes, it automatically returns none.
368:14 - Let's see the type of this output. What is
the type of this output? What is the type
368:18 - of this man, what kind of data type is this?
Let's see. It's an n type, I mean, that's
368:24 - a type in Python. So downs are non type, output,
how fancy Well, one more thing, the return
368:33 - statement is not only used to return a particular
value, if you for example, in a particular
368:39 - function, let me write a function here. Let's
say d f, that's the function is H. And then
368:47 - inside that function, you do something, let's
say print, a, let's say then you define a
368:55 - variable, let's say a equals to three, let's
say, then B equals let's say five, and then
369:02 - you add those values A and B. And then you
do some other stuff, let's say plant something.
369:13 - And then you just write a return statement
without any output or I mean it is not returning
369:19 - anything. You can still you can still I mean
continue writing the function body more and
369:27 - more. But what happens is whenever the first
return will be encountered,
369:34 - the function returns from there. So the effective
body of the function is just that the function
369:40 - returns right from there. If you return a
particular value for example C, you can receive
369:45 - that value outside the function. If you do
not return anything, just type a return statement.
369:50 - That means exit the function right away. It
works like the break statement and loop. Remember
369:57 - the break statement it It resembles to break
Excitement bulletin means just exit the function
370:02 - right away, no problem. And by the way, when
return is called the default return value
370:08 - that is returned is none type if the return
is called without, without an argument here,
370:13 - so for example, let's run this function. Let's
see. And let's call that function Ah, yeah.
370:23 - So it prints a, then it brings something and
then it returns. And it returns, for example.
370:30 - It returns nothing but anon. It returns or
not. And if you didn't see, for example, saying,
370:43 - then it returns
370:44 - a C, value of C, which is eight. And this
time this type, the return value is no longer
370:53 - none type, it is probably an integer type.
Let's see. Yeah, here. So it's indeed a type
371:03 - Make sense? Yeah. So return statement has
two purposes, one, you can return a value,
371:09 - two, you can return, you can just return the
control, you can just exit the function like
371:15 - the break and loops. Just Just one more thing.
return statement can return multiple values.
371:21 - For example, let's say we have defined a function,
let's say J. Let's say G, G, we already have
371:31 - defined, we can redefine it. But let's say
our is our function. And we just have a equals
371:37 - five, b equals seven, and D equals let's say
something. And then we just return them a,
371:50 - b, and A, D, and D. So return statement can
return multiple values in a sequence. Now,
371:58 - if you receive those values, let's say X,
Y and Z equals r, so a will be copied in a
372:07 - is a first return value, it will be returned
in X, it will be copied in x, b will be copied
372:14 - in y, and D will be copied in z just as a
sequence as you as you keep the sequence in
372:21 - the return statement, if you change the sequence
and return statement accordingly. So whatever
372:25 - the first value here is the first value here,
whatever the second value, here is the second
372:29 - value here, and so on. So let's run this and
just print all these things X, Y, and Z. So
372:38 - yeah, five salmon and something. So this return
statement is really powerful. I mean, it can
372:44 - return multiple, not all the languages, actually,
not all the languages, they have feature to
372:49 - return multiple values. But Python does have
feature to return more than one values. And
372:55 - more than one values of any type A can have
different types, you can have different types,
372:59 - you can have different type, and so on. So
that's about the that's about the return statement,
373:07 - as well as the variable scope. And whether
you can access a variable that is outside
373:13 - the function or inside the function, and so
on, and all that kind of things. In the next
373:18 - video, we will talk about what if we want
to access arbitrary number of input arguments.
373:24 - I mean, we do not know how many arguments
will be there inside. But no matter how many
373:29 - arguments a particular user is giving, let's
say we want to write an add function. Just
373:33 - Just to give you an example, let's say you
want to write an add function that says define
373:37 - add that say add to another function, add
two. Let's say it receives an arbitrary number
373:46 - of arguments. D in I don't know how many and
it has some implementation, then anybody who
373:53 - wants to call this add to it, if that person
gives two or two arguments, then just two
374:00 - should be added. If the person gives three
arguments, then three should be added. I mean,
374:05 - the person can give arbitrary number of arguments.
How can we handle that because because the
374:11 - caller the this is the call, this is the call,
the caller can give five arguments, six arguments,
374:17 - seven arguments. And earlier we saw in the
definition, the total number of variables
374:21 - when we specify, we have to pass those many
arguments for sure. If a single argument is
374:27 - missing, or a single argument is just more
than the specified number of variables, we
374:32 - will be getting an error. But how can we handle
the situation where we have an arbitrary or
374:36 - variable number of input arguments? How can
we handle that? So to answer this, or to get,
374:44 - how can we do that? See our next video? It's
coming. In the last video we were talking
374:50 - about how can we handle arbitrary number of
input arguments. For example, let's let's
374:56 - say we want to write an add function. That
should be a To add any number of let's say
375:02 - integer or floating point numbers that are
passed in. Remember last time, we discussed
375:08 - in an earlier video, that when you are defining
a function, the total number of variables
375:13 - that you are defining, you have to pause exactly
those many input arguments. Otherwise, you're
375:18 - getting an error. But but this may be required
some time that we want to add a universal
375:24 - kind of add function that has that has capacity
to receive any number of arguments. But no
375:30 - matter how many arguments it receives, it,
just add them all and return the result. Such
375:36 - a function, if available will be very, very
helpful. Because sometimes we might be calling
375:41 - that function by just two arguments. Sometimes
we might be adding might be calling that function
375:47 - with, let's say,
375:48 - three arguments, and sometimes more arguments
or less arguments and so on. How can we have
375:56 - this kind of feature available, but the implementation
is just one time implementation? Well, Python
376:03 - have a very, very easy way of handling this
arbitrary or variable number of inputs. And
376:09 - the way you do that is when you receive when
you are defining a function, you just write
376:13 - a star, and then just Brent let's say, one
variable name, let's say arcs. And then after
376:21 - that, this arts will act like a list. And
I mean, it will be having a lot of properties
376:27 - are this arts has a property, this this x
like list, so all the arguments that you will
376:34 - send in will be received like, like you're
receiving those in a in one list. And all
376:40 - elements, which are the arguments in the list,
they are accessed by different indices, we
376:46 - will see lists in detail later on. But right
now just think it is a collect all the collection,
376:52 - it is received by indices, for example, the
ARDS, the very first element is indexed by
376:59 - zero, it is at the zero location. At the zero
location, there is a three at first location,
377:06 - for example, the location index number one,
which is actually the second look, the four
377:11 - will be copied at this and so on. Now, no
matter how many arguments you pass a list,
377:16 - it will be of that size, and there is a function
length le n that is handy to just check how
377:23 - many arguments are there. Now if you pass
two arguments, the arcs will, the length of
377:28 - the arc will be two, if you have three, if
you have passed three arguments, the length
377:32 - of the arts will be three and so on. No matter
how many arguments you pass this arcs, it
377:37 - will receive all them in one by one and all
the elements in that arc will be indexed by
377:42 - 012, starting from zero until the length of
the arcs. So see, for example, here, they
377:49 - said the sum sum equals zero, let's, let's
say we want to add all these for i in range.
377:56 - And inside range, we just give the length
of arcs for this example 12345, the length
378:01 - of arg is five. So I will start from zero
till till four, because five is not included.
378:08 - So the very first time I will be zero, and
our eggs in subscript zero is actually the
378:14 - value value of the first variable, which is
three, so three is added to zero, then next
378:20 - time, I will be one and add the position one
four is located. So three plus equals four,
378:26 - which means three equals three plus four,
a sum equals whatever the some previous value
378:30 - of the sum plus for the next time, the value
of i will be four, you know how this loop
378:36 - works, we discussed the loop and loops in
detail. And as you move on, you actually explore
378:42 - all these numbers. And this variable sum actually
contain the sum of all the variables. Now
378:49 - you can return the sum and that at this particular
function acts like a universal guide a function
378:55 - that receives arbitrary number of arguments.
How cool is that? Let's see in Jupyter Notebook
379:01 - to get more convinced how it works. So let's
say we have define, let's say we have any
379:08 - function, my ad, they might add, let's say
that function might add powerful, that's universal
379:21 - or universal. Universal might add universal,
and it received receives star whatever the
379:28 - variable name is, that you can read, you can
write the name arcs or you can write any other
379:34 - other variable limits. This is this is just
this is just a name of a variable. Okay, then
379:41 - let's say we have let's say we have s equals
zero, which is some, then we just apply a
379:48 - loop. I guess you know, the loops we have
lengthy discussion on loops, in range, length,
379:57 - that's a built in function length arcs. Okay,
then what should we do s plus equals r x
380:05 - i, which means access all the elements one
by one. And this is again the same as S is
380:13 - equal to s plus r x i. Either way you write
this way or that way, both ways are fine.
380:21 - Then when the loop finishes, s contains the
Psalm, just return it, and you are done. Wow.
380:27 - Now, let's call this add function, my add
universal. And let's call this function as
380:34 - two, four and five for these, and let's just
print the result. Let's just print the result.
380:43 - Okay, the result is 11. Well, because two
plus four plus five is 11. Now let's call
380:50 - this function for let's say, for for, let's
say, five arguments. It works. It adds all
381:02 - these five numbers. Wow, that is great. I
mean, now we can add any, we have one function,
381:13 - we need not write a function for two arguments,
and then another function for three arguments,
381:19 - then another function for four arguments and
so on. Depending upon the number of arguments,
381:23 - we need not to write separate functions. We
have just one function working in all scenarios.
381:29 - While so, yeah. That's doable. I've done in
front of you. No problem. Yeah, Python allows
381:38 - this.
381:40 - Yeah. In the next video, we are going to see
how can we actually handle the same kind of
381:48 - scenario. But we want to handle the sequence
of the input variables in a very controlled
381:56 - way. Remember, in some of the previous this
this year, in this order of input arguments,
382:01 - remember that we receive three arguments and
we pass the three arguments in a very controlled
382:06 - way. And then whatever these are, we don't
care whatever the order here if we don't care,
382:11 - what if we want to fix the issue? Or we want
to become more careful for input argument
382:17 - orderings. But then we also want the arbitrary
number of arguments. How can we do that? Yeah,
382:24 - wait for the next video. And I will show you
how can you do that? In the last video, I
382:29 - promised you that I will show you how can
you achieve the ordering of the input variables,
382:36 - but still having the arbitrary number of them.
Remember, this looks like much familiar to
382:41 - you, that's a call that can be made to a function.
And remember, the function definition in some
382:48 - previous slide was like C one, C two, and
C three maybe. And then something. What if
382:54 - we want an arbitrary number of arguments to
be passed, but we want their control. For
382:59 - example, let's say this particular variable
symbol name that acts as a key, that's a variable
383:06 - name, and that's the value. So let me call
the variable name as a key. And let's This
383:11 - is the value that is copied in the variable.
That's another key that's a value, that's
383:15 - another key that's a value and so on, what
if we have a lot of key value pairs? What
383:19 - if we have a lot of them. And we also want
to check which value is of what key, let's
383:25 - say we want to specify those. But we want
to specify an arbitrary number of them. Let's
383:30 - say here, for example, there are only three,
let's say we want to pass five of them, six
383:34 - of them, and then we want our function to
perform accordingly. No matter how many input
383:41 - arguments it received. Yeah, and and maybe
inside the function, we may have applied a
383:46 - check that if the key value is C one, then
do this processing, if the key value is C
383:52 - two, then do that kind of processing and so
on, let's say, based on different variable
383:58 - symbol names, we want to process the value
differently, how can we achieve that, and
384:05 - still having the need that these number of
variables can be can can be in a variable,
384:11 - variable length, they can be an arbitrary
number of those. So Python gives you again,
384:16 - a very, very simple way. Rather than writing
a simple single star, you write a double star,
384:22 - and then you receive in whatever variable
name. And now in this double double star means
384:30 - you are receiving a key value pair list. It's
a list of key value pairs. We will see that
384:36 - that resembles two that resembles to a data
structure in Python called dictionary. We
384:41 - will see dictionary later on in detail but
right now just just consider that this input
384:46 - argument this input variable C, it contains
a, it contains a list of key values pairs,
384:53 - and then you just you can just iterate over
the sea you can just apply a for loop to check
384:58 - the contents of this Remember, we have actually
done that kind of thing in the, in the portion
385:05 - of loops. Yeah, here. Remember that was a
key. And that was a value that was a key that
385:11 - was a value. And we did that thing, we could
explore the we were able to explore the dictionary,
385:17 - just just using for loop. Yeah, it's the same
thing here. It's not exactly but you can think
385:25 - of that that's exactly the same thing. So
you can explore that, that see looks like
385:29 - a dictionary. Now this is key, this is value,
this is key, this is value. This is key, this
385:33 - has value, you can this x points, the first
key, then C of x point to the value based
385:42 - on the based on the key x, and then x point
to the second key, then the second value and
385:48 - so on you that that is very simple procedure,
you're just printing all the dictionary, but
385:53 - you can, you're printing all the variable
names and the values, but you can do very
386:00 - complicated processing, if you want to, let's
go to our friend Jupyter Notebook to just
386:05 - get convinced that this indeed works. Let's
see. So let's define a function first. So
386:12 - d f, that's the function name is Brent, all
386:18 - variable, variables, and values. So that might
be a function name. While that's lengthy one,
386:32 - but descriptor one, maybe we can make it more
descriptive, paint all the variable, variable
386:40 - names and values, while that's more descriptive
a guess. So it receives, let's say, doublestar.
386:48 - Any variable, let's say the variable name
is again, let's say arcs or anything, whatever
386:54 - you want, then what we do is for x in orgs,
just Brent, let's say, variable name is just
387:11 - Brent x, and then the sprint x and then just
continue, and value is value is our eggs of
387:34 - x. So let's say you, you done this, you did
this. So the variable name is this, and the
387:40 - value is this, okay, and you want to do this
for all, all the all the variable and value
387:48 - pairs that you that you send at the call time.
So now let's call this brand, all variable
387:58 - names and values. And let's call this let's
say the variable first variable name, let's
388:02 - say is a, and its value is three. The second
variable name is let's say B, its value is
388:10 - capital B, let's say the third Will you third
variable name is C, its value is CCC. And
388:20 - let's say the fourth variable name, I mean,
you can define an arbitrary number of arguments
388:24 - here. Wow, that's amazing. That's the fourth
variable name is why its value is 6.7. And
388:32 - further notice, you can you can pass variable
and value all have different types, I'm in
388:39 - different number of them. And and much more.
Yeah, you can do that. So let's call this
388:47 - function by just having four variables and
their values. Let's see what we got. So well,
388:53 - variable name is a and the value is three
variable name is B, and the value is B, variable
388:58 - name is C and the values CCC, variable name
is why and value is 6.7. You can give an arbitrary
389:06 - lampi list here if you want. And Python just
allows you to do that. And it allows you to
389:13 - do that in a very, very simple way. That's
amazing. That's amazing. I mean, that's, that's
389:18 - why a high level language or radio, a powerful
language should should have a feature. So
389:26 - Python does have this feature. I'm really
amazed. I'm really, really astonished by time.
389:31 - By the way, I'm not saying the other languages
don't have this. several languages actually
389:37 - support this kind of feature, but Python supports
it in a very easy way. It's very easy to do
389:43 - that. I mean, it's not not a rocket science.
Yeah. Okay, so now we have had an arbitrary
389:51 - number of arguments even when the ordering
is really controlled.
389:55 - We have one or two more videos on functions.
Just to explain a bit more than we will, then
390:02 - we will practice on Jupyter Notebook, we'll
practice we will play with these functions
390:06 - a lot. And we will be calling one function
inside the other function and so on, we will
390:11 - be having one better program just just program
and noodle Jupyter Notebook just to get comfortable
390:17 - with this functions. But before that, let's
have one or two more things to discuss about
390:21 - the functions. Yeah, let's see. So I hope
to see you in the next video. Okay, I really
390:27 - want to talk about these default values for
a function as well, because that's important
390:34 - and mostly needed. The default value is a
value of the input variable that you assign
390:42 - well, while you are defining a function, and
if the value is, for example, if you call
390:48 - this F, with let's say, the input value three,
then three will be copied in the sum and the
390:55 - print will be three. But if you call this
function without the input, then this value
391:00 - acts as as if you have passed this. So this
is the default value if you do not supply
391:05 - the value, this is the value that is going
to operate. And by the way, you can have multiple
391:09 - variables with default values, some variables
with default value is defined some variables.
391:14 - With default variables, a default value is
not defined, and so on. So you can have this
391:19 - one here must be taken here that the default
value, when you actually define the function,
391:25 - and you compile this function, actually, you
you run the cell shift enter in Jupyter Notebook.
391:30 - At that very time, this variable is assigned
this value at that particular time, it is
391:37 - not assigned at the call time. So sum equals
to zero is already there, when you actually
391:43 - press Shift Enter for a cell that contains
this code.
391:49 - Now later on, if you pass a value, that value
will be overwritten on some, if you don't
391:54 - pass the value zero will go on, it looks like
very easy, but one care that I want to mention
392:00 - here that I haven't mentioned earlier, in
Python, there are certain variables that are
392:06 - that are referenced rather than copied, I
will discuss the referencing in the copying
392:12 - data in detail in data structures. But let
me just tell you 111 example, let's say you
392:18 - define a list, let's say one, two, and three.
And then what you do you copy this list into
392:24 - another variable, let's say l two, what will
happen is in the memory, this list in a particular
392:32 - way, this is not the exact view of the memory,
I'm just showing you, let's say this is the
392:36 - particular memory layout for which this L
is pointing to this L is label for that l
392:42 - two is also labeled for that, which means
actually in memory, this is not the copy of
392:48 - the structure that is made, I mean this is
not like in variables. For example, if a is
392:52 - equal to three and b is equal to a, a will
be a will be a position in memory, and B will
393:01 - be a separate position in memory. That is
what a view of the memory in ordinary variables
393:05 - are. But there are certain variables in memory
just for memory efficient and cost efficiency
393:11 - and time. People have people have designed
these data structures in a way that when you
393:17 - copy them, when you just assign a variable
to another variable, the memory view doesn't
393:23 - change the just it's it's another name for
the same for the same for the same memory
393:28 - location. So what happens is if you change
any value, and let's say l two, let's say
393:34 - l two, at the very, the zeros and add the
zero index, let's say you change that by minus
393:40 - nine, the because it is the same view in memory
that changes minus nine. And now if you print
393:46 - the elements of L rather than l two, you will
get the changed value, you will see the change
393:51 - value. And that happens. Now why that is important
in terms of these default values here for
393:57 - the function. The reason is, if you are accepting
a list, let's say the default is a list, and
394:04 - you're accepting a list and you are also defining
some default value for the list. If that's
394:09 - your definition, let's say then this list
this default value is assigned at the ad the
394:15 - very first at the very first time, and this
L is really a local variable inside inside
394:22 - the inside the memory. Now when once this
cell is run, not the call time at the at the
394:31 - sowhat call the compile time, when the cell
is run this L is assigned this and that just
394:36 - happens once. Now if you call this list with
some other list let's say l to let's say two
394:42 - three and four. Then if you call this L two,
l two will go there it will be copied in L
394:49 - and everything is fine, but don't then expect
this the contents of L to to stay same as
394:56 - staying l because l is this default. values,
they are assigned just once. And they stay
395:03 - as it is, every time you call the function,
they don't change. They are not assigned at
395:08 - the call time they are assigned at the compile
time and they stay fixed. So that care must
395:13 - be taken. I will show you that example that
particular example, in Jupyter Notebook shortly
395:17 - at this, this might be confusing right now,
because we have not defined, we have not seen
395:22 - lists in detail. But I just want to make this
point. I just want to mention this because
395:28 - that's important difference with ordinary
variables that I mean default values, just,
395:33 - I mean, just like like a value. And if you
don't supply a value, the default value just
395:38 - works. But with the variable that are referenced
by variables, you may expect something else.
395:44 - And the Python function behaves maybe differently.
And that's because these default values they
395:50 - are assigned at compile time they are not
are compiled time. Actually, this is not a
395:55 - compiled language, I should not use the word
compiled compiled again. And again, just think
396:00 - when we define this function, and we run the
cell at that particular time, the default
396:05 - value is assigned. And the default value never
changes. It stays fixed. Yeah. So and I will
396:13 - show you that example. Why don't we move to
Jupyter Notebook and see that example? Yeah.
396:18 - So or why don't we do that in the next video?
What do you think? This video, okay, same
396:25 - with you. Okay, let's go to Jupiter and mode
notebook and see the default values. For example,
396:32 - let's see.
396:34 - Let's say we have define a function, let's
say GG, and the default value s is equal to
396:43 - four, let's say that's a default value. And
we want to print let's say s, if available.
396:51 - From the call time, if not available, then
four will be printed. Now we print now right
396:56 - now we are going to print, now we are going
to press Shift Enter at that time, S is assigned
397:04 - to for S has no value for it is assigned there.
Now we call GG, let's say and we call GG without
397:14 - input arguments. Now the four will be printed.
If we call this GG with some input argument,
397:20 - let's say 56. Now the 56 will be printed,
no problem, everything is fine. Let's see
397:26 - about the lists. For example, let's say the
list is, let's say 123, that list, and then
397:34 - l two is simply let's say l two is L, then
what we do is we change the contents of L
397:42 - two, let's say we change the very first value
in L two, and we place that values minus nine,
397:48 - and then we print L. Now, you might be expecting
that l is a different thing, l two is a different
397:55 - thing. Because l and l two, they both are
pointing to the same memory. This, the content
397:59 - through l two actually changes the memory
view and l also changes and that gives the
398:06 - result minus nine in L. Well, the behavior
that I want to show you is different in the
398:12 - default values. When we when we talk about
for example, let's say we define a function,
398:19 - f f and it accepts a list and the default
value is empty list, or the default value
398:26 - is let's say one, two, that's the default
value, let's say if, if no list is passed,
398:33 - the default list is one two. Now, in this
particular scenario, if we just print, so
398:41 - for example, for i in the list, brand, I let's
say we just print all the list. That's it.
398:50 - Now we will press Shift Enter, and at this
time this L is assigned this value, and that's
398:56 - a default value that never, that is not going
to change. Now let's say we have an L tool
399:02 - that is simply let's say two, three and four,
or let's say 12, three and four. And what
399:10 - we do is we call F and we just press Shift
Enter. Now, why don't we call f f without
399:21 - anything. So, the default list is printed,
if we call this f f with L to the L two will
399:31 - be printed. Now the notice that this L two
actually is copied in this L because we supplied
399:42 - it. So l and l two you may tend to think that
l is now also pointing to L to an L has also
399:51 - the same contents as l two. So if next time
because because of the behavior of these lists
399:58 - because they are by Reference. Next time you
make you make might be thinking that because
400:04 - l two is past there, so l two L is also L,
L two is copied in L in a memory view way
400:12 - layout. So l has also the same data as l two
and next time, if we call this function without
400:20 - input arguments, then l might be pointing
out to L two values. So, 12 three and four
400:25 - might be printed, but that is not going to
happen, the default values they never change.
400:30 - So, again, you will be getting one, two, so,
the behavior of these Reference Type variables,
400:38 - that is different ordinarily, but when you
do that in in the default value structure,
400:43 - that, that, that might work in a different
way. And the reason is, you, you must know
400:49 - that these default values they're assigned
at, at the time when the function is created,
400:55 - not at the function when the function is called.
And they are not going to change whatsoever.
401:00 - So, so that was about the default value. And
by the way, the default if it was a simple
401:05 - concept, I guess I have made it too complicated
by telling you layers and default values and
401:14 - creation of these variables, at what time
and at the call time, I made this complicated,
401:20 - I guess, I shouldn't have told you the list
values and all that stuff. But but that's
401:27 - true. And in whatever I have told you is true.
Maybe I have told you in a very complicated
401:31 - way, but it's true. Yeah. Okay.
401:37 - One more video on the functions and then we
will be practicing functions in detail on
401:43 - on Jupyter notebooks. So just be or one more
video with me. Hope to see you in the next
401:47 - video. Okay, this is probably the last video
on on the functions. Yeah, we will, we will
401:57 - be having one more video. But but that will
be like coding and practicing all the concepts
402:02 - that we learn about the functions not? Not
something not not new theoretical concepts.
402:08 - Yeah. So let me ask you a question to actually,
to actually make you understand about this
402:17 - slide. Let me go to the Jupiter and ask you
about a few questions. Let's say you have,
402:24 - let's say, let's say you have this particular
function, and you, let's say my ad, my ad
402:30 - universal, let's say we have written that
function, maybe two or three or three videos
402:34 - before, let's say you have this function,
you have written this function, and you are
402:39 - very, very excited, wow, what kind of masterpiece
you have generated, it can add an arbitrary
402:45 - number of values pass in it well, but this
particular function is written inside this
402:53 - particular file, which is mastering Python
zero to hero. Later on, let's say two or three
402:58 - months later, you are writing some code for
some, some project or you are doing something
403:04 - somewhere and you are writing code, and there
you just needed.
403:10 - You just needed a, you just needed a code
for adding a lot of a lot of values together.
403:15 - And then you just remember, oh, I have written
some function somewhere. How can you use that
403:21 - function? One way is to just go back to that
file mastering Python zero to hero, and just
403:27 - copy this function, this particular this code
and paste in the new file, run that, register
403:34 - that and then call that happy. What if you
want to use let's say, 100 different functions,
403:41 - let's say you have written a lot of functions
in a lot of different files. And now you want
403:45 - to use all of them. And, and let's say this
is a repetitive kind of demand several times
403:53 - you notice that this usually happens that
this particular kind of function, you require
403:58 - almost every almost in every project, let's
say a set of maybe 50, or 60 functions that
404:04 - are that are required always, one way to do
that, as I told you is to jump just copy paste
404:11 - those functions in every file, run them and
do that. Another way is to just just I mean,
404:17 - make a module a file of containing just those
functions. And whenever any of those functions
404:23 - is required, just import that module into
your coding file, which has one line of code
404:31 - and then access all the functions as if they
were they were they were actually available
404:36 - in in the port file that you are working on.
So that's about the that's about making modules
404:46 - of so module is basically a Python file that
contains functions that you want to use in
404:53 - several different coding projects or the functions
that you don't want to write in your the functions.
405:01 - Having the implementation that you don't want
to write in your grant coding file, so you
405:05 - can have several of those functions stayed
somewhere else in a different directory they
405:09 - are residing there, whenever you want to use
any of them, you just import the whole module
405:15 - and use the functions. So, so module is just
a Python file that can that can contain a
405:21 - code for you that whenever you want to use,
you can use it. Normally it contains functions
405:27 - maybe more than one function and several functions.
Normally, it contains functions that you repetitively
405:33 - use, and that you have written once in very
careful way. And then now you want to use
405:37 - it again and again in several different ways.
You need not to write the function definition,
405:43 - in every coding file you need, you just make
one coding file, or that that is the most
405:49 - important for you, that is called a module
where wherever you want to use any of those
405:54 - functions that are there in that module, you
can call it, you can use it. So that's about
406:01 - the modules we are going to make. I'm going
to show you one example of making module and
406:07 - how to use that. But but to use the module,
we need to actually specify the path where
406:15 - the module actually resides using this cess
module. So and then we have to do some this
406:24 - import kind of commands. And then I mean,
there is some work that we need to do to actually
406:30 - get this module running in our code. So in
the next video, I'm going to tell you what
406:36 - that extra work, very little amount of work
what that extra work you have to do. So here,
406:41 - for example, my funks.py, that's my Python
file, and it contains these two functions.
406:47 - And let's say I want to use one of these have
both of these functions in some other file,
406:52 - and that file contains this particular code.
So in the next video, I will show you how
406:58 - to how to actually make and use the modules.
Yeah, so hope to see you in the next video.
407:08 - Okay, in the last video, I told you about
modules module is just a Python file that
407:14 - can contain a code that can be used anywhere,
if you want normally, that module. Normally,
407:20 - the modules, they contain a lot of functions,
but they can contain variables and other values,
407:25 - and so on. So think about file myfonts.py,
that contain this, these two functions, and
407:36 - think about a different file, maybe Jupiter,
maybe you're working in a Jupyter Notebook.
407:41 - And now you want to use these two functions.
So you first have to import another module
407:46 - call the system module says you have to have
you have to make this path available. There
407:52 - are a lot of built in modules that are already
there in the path all the already there in
407:57 - the search path. When you want to call a function,
it is written in some module that is already
408:04 - in the search path. If you're making your
modules, you have to either
408:08 - either copy those, those modules into the
modules that are built in or if you want to
408:17 - maintain them separately somewhere else, then
you have to add the path of these in the search
408:22 - path as well. And the way to actually insert
this path is sis dot path dot append. And
408:29 - then you actually write the the path of the
directory where this module file one or more
408:35 - files are located. Once this is added to the
path, now you can write the import. And you
408:42 - can import your file and your file as it is
or you can import your file with some other
408:50 - name if you want, you can rename that on the
fly if you want. Once this is imported, now
408:55 - you can use all the functions like the built
in functions, the implementation of these
409:00 - functions are not there in your coding file,
you are just using those and you can now import
409:06 - this module into some other file and use their
and so on. for, for, for for very large kind
409:13 - of projects. It is good to make modules. Actually
it is better to make packages, which is actually
409:20 - the directory structures that contain modules.
But modules at least are really good too,
409:27 - for maintaining a large amount, of course,
or actually the functions that you want to
409:32 - use again and again. So let's just let's let's
make a module, why not? So let's make a module.
409:40 - Let's say let's go to Jupyter Notebook. Let's
create another file. Let's create another
409:45 - file, let's say new Python three and let's
let's name this file as my IE let's say let's
410:01 - let's name this file as my universal, let's
let's use underscores my universal functions.
410:11 - Let's classify the name. Let's create another
notebook. Right now it's just a notebook that's
410:17 - defined some functions. Let's say we want
to define one function as jack, all orgs.
410:25 - Let's say that's the function it receives,
let's say,
410:34 - let's say it receives a dictionary like input.
And then it checks the date, let's say check,
410:43 - set check type of all arcs. And let's say,
let's say you write a function check, if not
410:56 - numeric, let's say, let's say you want to
write a function that that just accepts a
411:08 - lot of arguments. And you want to check whether
any one thought, if any one of them is not
411:14 - numeric, you want to return let's say, a flag.
Otherwise, you want to return a true, let's
411:21 - say, so for example, you may you may need
this function in several places. Let's say
411:28 - in in your core, you're expecting numerical
inputs. And if the input is, and let's say
411:34 - there are a lot of variables that you are
working on if and if any one of them is not
411:37 - numeric, you might want to check all the all
the variables and their values. One way of
411:44 - doing that is just to create a list. And that's
it. I mean, that's and and you may have several
411:52 - of those, I mean, you can check all of them.
And maybe here, maybe here, we do not need
411:58 - the dictionary kind of argument. So maybe
we just are happy with just one. So let's
412:04 - say for so the output, let's say output is
let's say, R or the return value that value.
412:14 - Let's say that is already true. And we will
say okay, for x in ARDS, let's say for x in
412:24 - arcs. If x if is in stance, x is and float,
if that is true, then we are happy. But if
412:44 - that is not true, if that is not true, then
there is a trouble, then we say okay, if this
412:51 - is not true for any value, then we just return.
False. Okay, we just return false. I mean,
413:00 - we need not to break anything, we just return
false return means return, whatever. Otherwise,
413:06 - if we finish this loop, if the loop finishes
successfully, and there is no return statement
413:14 - that is called already, then we return, maybe
true, we need to do not need Actually, this
413:21 - variable. Let's see. So this function will
return true if all the variables are either
413:27 - int or float. If any of them is not of this
type, this function returns false. Well, we
413:34 - can have another we can have another function,
maybe we can write several function, the same
413:39 - cell or in different cells. Either way, define
let's say another function, universal. Or
413:49 - add all values, let's add all that's in Numerix,
and all numerix. And it also contains, let's
414:01 - say, arcs. And the goal of this function is
just to add all the values and return the
414:08 - sum. So let's say s equals zero for x in for
x in ogs, as plus equals to tax, and that's
414:21 - it, then return us, let's say these are two
functions. And maybe one more the name of
414:27 - this, or some some variable, let's say you,
I mean, these are two functions. Now we are
414:33 - out of the function we are writing something
else. Let's say my name let's say that's a
414:41 - variable, my name this, this does not this
my name variable does not belong to any of
414:47 - these functions. And my name is Python. Course
let's say that's my. So that's it. That's
414:56 - file with name my universal functions. So
what we do is we download this file as a.pi
415:04 - file.pi file. So what we do really is the
Go to File, let me just zoom this out so that
415:11 - you can see the download options. We go to
File Menu, we download this, as we download
415:18 - this as
415:19 - we download this as well as by file, so Python
file. So let's download this, or we can write
415:30 - this Python file as in some other editor if
we want. So open folder, there is a Python
415:37 - file here, copy it. Now copy that file. And
now you're free to go to any, for example,
415:46 - any, any folder if you want, just, for example,
you go to somewhere in your directory, and
415:55 - make a new directory, maybe, maybe you want
to make another directory. For example, go
416:00 - and make a directory, maybe in D, let's say,
or maybe an E, let's say or maybe in C somewhere
416:12 - and then make a module anywhere. For example,
in C, make a new folder, call that folder
416:18 - as my, or any name, whatever name you want,
for example, my module or let's say utils,
416:30 - for example, utilities or whatever name, I
mean, let's let's call it as, let's call it
416:36 - as ABC, for example, ABC, whatever. And you
just made that and just copy that Python file
416:45 - here, my universal functions.by. Now, if you
go back, if you go back to your there, there
417:00 - is a Jupiter, here is a Jupiter. Now you go
back to your code, this is your file, go back
417:08 - to your code, let's say this file is no longer
here. And what you do is you import Sis, that's
417:17 - a system module and says dot path dot bend.
Right the path here where the module is located.
417:27 - So the module right now is located at ABC,
this is the part of the module. Once done,
417:35 - you can import what what was the name of the
module, you need to know that that was my
417:41 - my word. So I just I just don't remember the
name, let's import my universal functions.
417:59 - How it appears, actually, when I when I have
Eric this part, then this import command and
418:06 - after the dab completion, just fetches that
file. So that that that name might be very
418:12 - lengthy. So you can rename that as let's say,
my apps or whatever name you want. So you
418:20 - import that once you have imported that. Now
you can use the functions if you want, for
418:25 - example, you can check the implementation
of my efs.if, you see dot add Numerix, you
418:33 - want to check the implementation of that.
Here, this remember this file is no longer
418:39 - in this particular file is located somewhere
else. And you can call this function like
418:44 - like the built in functions, my apps dot add
all numerix. And you can have for example,
418:55 - let's say accepts the input arguments, let's
say 234. All that says six. And that's it.
419:05 - That's the, that's the return value, you can
you can save the return value in some other
419:11 - variable, let's see. And then later on, you
can print this see our do some stuff with
419:16 - this. See, that's one thing. Another way of
importing the same thing is let's say you
419:24 - don't want to use all the functions, you just
need this add all the metrics, let's say that's
419:30 - that's the only function that you want to
use again and again. So you need not the other
419:34 - functions, let's say for this particular file,
you do not need the other functions, then
419:38 - what you can do is you can just say okay,
from my universal functions, import,
419:49 - add all Numerix and you can rename it rename
this function as something and you can call
419:56 - that function the same way. So you do that
now. You need Not to write any dot kind of
420:02 - thing, you just call add all Numerix because
it is important now, and you say, Okay 234567
420:10 - and you'll save that in let's a D, and then
you print the if you want, or do whatever
420:17 - with that. That's it are you can import several
multiple functions or you can import all of
420:24 - them. Other than modules, there are I mean,
for complex codes, I mean, this is not one
420:32 - module that is there, I mean, there are several
modules. And the several modules may be arranged
420:38 - in in a directory structure, where the directory
and the sub directory and the sub directory
420:43 - and so on. So the modules that are arranged
in directory structure, although they are
420:48 - accessed, much like the same way, that directory
structure is sometimes called package. And
420:53 - these are basically the packages that are
that are most useful. And we will be seeing
420:58 - some data science packages, like NumPy is
a data science package. Then, we will be seeing
421:06 - pandas, that's a data science package, we
will be seeing matplotlib that's a data science
421:13 - package for plotting and visualizations and
stuff. So packages, just the modules that
421:18 - are arranged in directory structures. So now
you know what module is. And the old one,
421:24 - Venus two, we actually missed to import the
name of have to see the name Vivi have saved
421:30 - a name there as well. So let's go back. And
let's go back and do that and see how, how
421:39 - many things are available. Let's go to some
other cell and empty cell. So my apps dot
421:46 - tab completion, my name is available. Remember,
there was a variable. Yeah, that's available.
421:54 - So the name is Python course. So this module
file does not require to only contain functions,
422:01 - it can contain any information, any data that
you want to use in other files, other coding
422:06 - and stuff, and so on. So, yeah, that's about
modules. In the in the next video, we will
422:13 - practice about these functions a little bit,
we will be seeing how to call a function inside
422:19 - another function, how to make a lot of functions
that are calling each other and so on. So
422:23 - we will be practicing more on about these
functions, not theoretically, just in Jupyter
422:29 - Notebook, just to get a better look and feel
of of functions more. And after that practice,
422:37 - we will be then jumping towards data structure
starting from strings. So hope to see you
422:43 - in the next video. Okay, before moving on,
let's just practice some, some some, I mean,
422:51 - let's get a good grip on functions and multiple
functions and handling those. And the best
422:56 - way to do that is to solve actually a problem.
Remember, we solved a problem when we when
423:02 - we, when we are done when we were done with
if conditions, then we solved another problem
423:07 - when we were done with loops just to get a
good grip on loops. Let's solve a problem.
423:13 - Let's just solve a problem using using the
functions just to get a good idea of functions.
423:21 - What kind of problems should be solved here?
Should we solve an older problem? Last time
423:26 - we solve a problem using loops that are sorting
a list? What Why don't we? Why don't we solve
423:32 - the same problem, but in a different way?
So let's go to Jupiter and see. See our file
423:39 - Jupiter file? We have actually solved a function,
which somewhere using loops, just let me just
423:47 - find that out. Oh yeah, they're here. So here.
So given a list of numbers, let's this make
423:53 - another list or maybe the same list that contains
all the items in the sorted order, from minimum
423:58 - to maximum, your result will be another list
like this. And we solve that using loops.
424:05 - Okay, let's solve the same problem. Exactly
the same problems that solve the same problem
424:13 - using a different way using a different user
using functions just to get a grip on functions.
424:19 - So let's say that's our problem we want to
solve. So that's the problem again, and we
424:25 - want to solve that. So how can we solve that?
To solve that, let's first define a function.
424:32 - Let's just make a function.
424:37 - Let's just make a function that let's just
make a function, let's say define, find minimum
424:46 - and the function accepts a list. And we're
times the minimum value in the list not only
424:52 - the minimum value of the list, but also the
position of that minimum value. So find minimum
424:58 - as well as find out Some minimum as well as
the position of the minimum in the list. So
425:04 - how can we how can we solve that problem?
That's that's one standalone function, no
425:09 - matter what list you pass in, it will find
the minimum. Okay? As long as the the minimum
425:15 - is defined for the items of the list, for
example, the list items, or let's say all
425:21 - the metrics, okay, how can we how can we do
that? Let's see, minimum value is the list.
425:27 - Zero, that's let's say, the minimum value.
And right now the index at the minimum value
425:32 - is, let's say, is zero. Okay? like we did
in the loops, like is, it is kind of the same
425:40 - goal, but let's try it a function for it.
Okay. So that's the function fine, man. So
425:48 - how can we how can we proceed? What should
we write here? Let's see a counter. Let's
425:54 - see. Concrete let's or it may be that city
counter right now is zero for x in L. K, if
426:07 - x is smaller than our minimum value, if that's
true, then the minimum value indeed is x.
426:16 - And the index where we found that is high,
okay, great. Else do nothing I mean, else
426:24 - just go away. And I plus equals one. So move
on. So AI is just the position so AI is moving
426:33 - on and on and on. As you follow the list,
and M contains the minimum value and Id X
426:39 - variable contains the position of the minimum
value. So that's the function for for readability,
426:45 - we might be adding an else clause just write
balls. And that means the if condition finishes,
426:53 - I'm in do if this condition holds true, do
that stuff, otherwise do nothing. That's just
426:59 - because of readability. If you want, even
if you don't write the else clause and pass
427:04 - statement, even then everything is fine. So
let's call this function just to test whether
427:08 - this function is working properly or not.
So let's just find, oh, we haven't returned
427:14 - anything. We need, we need the minimum value
as well as the index. So return a minimum
427:21 - value as well as the position so return that.
Okay. Oh, but we do view returning that inside
427:29 - the loop that becomes in the body of the loop.
Oh, no, no, no, no, no, that's bad. Because
427:34 - even in the first iteration, the return will
be called an even in the first iteration,
427:38 - the function will finish indentation, remember,
indentation. Now that's better. Now this is
427:44 - no longer inside the body of the loop. Great.
That was a bug. We fixed it, right? Okay.
427:51 - So let's go find, let's receive a B, so a
will contain the minimum value, and we will
427:57 - contain the index of the minimum value. So
fine men, for example. And the list let's
428:04 - let's give it the list. 13423409. Let's say
now the minimum value is zero. And that minimum
428:18 - value appears that 0123. That's the third
index. So b should be three a should be zero.
428:25 - So let's see, what's the value? What's the
result? So Brent? A, B? So A is zero? Yes.
428:35 - And the position of minimum is three, I guess
it is working fine. rate. So that's one function,
428:41 - find a minimum? Let's find another let's write
another function. Swap. So define. define
428:51 - another function, let's say swap values. And
what we do is it it actually accepts two indices
429:02 - index one that actually accepts list then
two indices, index one and index two. And
429:10 - what it does is it actually swaps the value
of index. So index, one value should go to
429:16 - index two position and index two value should
go to index one position in the same list,
429:21 - and then it returns the list. Okay, great.
So it would it so so that's, that's a good
429:26 - example it would, it accepts a list type variable,
it accepts index type variable which are integers.
429:35 - Great. So
429:38 - let's continue with let's define a variable
temp that contains l ID x index one, just
429:46 - store it in a temporary variable, then at
this particular index, next one, just copy
429:54 - this value. Don't worry, we'll see lists in
detail. Later on now list. Now at index one,
430:04 - the value of index two is copied. But it is
not overwritten, because we already have saved
430:10 - the value somewhere before that copying appears.
So l at ID x two is simply damp. And now return
430:22 - the list. So that's how you can swap the two
values if you want. Great. So let's just check
430:31 - it, whether the two values are swept or not.
So let's say list is 236. And seven, that's
430:38 - a that's list. And let's say we want alto
that is swept values. And let's say we pass
430:49 - the list and we want the values to be swept
at position one, and position three, which
430:57 - may add position one, the value is three,
because the position starts from zero, and
431:02 - at the third position, the value is seven.
So we want these to swap. So the result will
431:06 - be 276. And three, let's see what's the result?
So let's print out two. And yeah, it works
431:16 - great. What else? What else do we need? So
we have find a minimum function, we have swept
431:23 - values function. What else? So yeah, what
should we do? Now let's write the main function
431:31 - sorting. Let's write that function. And we
will call we will use these kinds of functions
431:37 - inside that function when you call these functions.
So let's define sort list. Let's say that's
431:44 - our function, it accepts a list and it returns
a sorted list. Okay, what should we do? What
431:53 - do you think? What should we do for the very
first time? Well, first of all, we should
431:58 - check whether all these list it contains the
list contains all the numeric values are not
432:07 - let's say we're just doing this for numeric
values. So, we should first check the all
432:11 - the arguments are are of numeric type or not,
for that, we should write a function that
432:16 - should do that oh, remember that function
is all written in in a module remember that
432:21 - module we made that module ourselves? So,
we can import that module if we want import?
432:30 - My remember that my universal functions and
we just need that function we just need that
432:38 - function one just from from my universal functions
import what import check if Numerix check
432:52 - if not numeric, as you can write that function
name something else, but justice. So you import
433:00 - that function. Now you may be able to use
that function. So after that, you can use
433:06 - that function. If check, if not, numeric list
or remember that function returns true if
433:22 - all the values are numeric, otherwise, it
returns false. So if it is true, then move
433:28 - on the if it is not true. If it is not true,
what should you do? If it is not true? If
433:35 - it is not true, then you might be printing
an error. Error. Last does not contain numeric
433:51 - values, maybe that and then you just return.
Return. That's it. I mean, return. Don't need
434:03 - to write anything in return. Fine. Great.
So else we need not to write else because
434:10 - this return will take care of that but it
is for readability. That's good, right health.
434:15 - If all are numeric, then what should we do?
Okay, what should we do? If all are numeric,
434:21 - what we do is we will be doing what we will
be fine minimum. We'll be finding out the
434:31 - minimum and then we will be swapping the minimum
from
434:39 - what should we do what we we have already
a function find a minimum that we can call
434:46 - just right away we have a function swap values
that we can call right away. We already have
434:50 - used this function. How can we combine all
these functions? How can we use all these
434:56 - functions just to achieve the problem sorting,
we want disorder list. How can you do that?
435:06 - Okay. Yeah, that's, that's, it looks like
it looks like a different thing. Maybe? Maybe.
435:20 - So, let's just write out, let's just for x
in the list, let's start thinking here for
435:31 - every element that is in list for x and list
what should we do? We should we should find
435:40 - out the minimum and slap the minimum with
x r. So, we should find out the minimum as
435:48 - well as the index of the minimum and should
slap it with with the value x and everything
435:54 - will become great. Yeah, I guess Yes. Okay.
So, what what we are going to do is we are
436:03 - going to maintain a counter right now, the
counter is zero, which is just the index,
436:08 - which we are going to do is we are going to
find out the minimum minimum and index where
436:15 - the minimum lies. So, by find minimum in the
list, so, it will return us the minimum as
436:24 - well as the index where the minimum lies and
then what we do is, we will say, Okay, okay,
436:34 - what we want to do is, L is actually L is
swap, swap values with index see swap values
436:53 - and list with index c. So, index c should
be swapped with ID x and C plus equals one,
437:04 - will that work with that work? So, after this
will the will the whole list be sorted. So,
437:15 - let's return the list is that true, I mean,
we are finding out the minimum value one by
437:22 - one, the only catch is the list is updated
here. And, oh, there was a problem. When we
437:32 - are finding out, when we are finding out the
minimum, we are finding out the minimum from
437:36 - the list. And every time the same minimum
will be returned. That's a big problem. So,
437:44 - looks like this fine minimum function is not
doing our job, what we need to do really is
437:50 - the, we should go to find min function and
give it that start your stock your final minimum
438:01 - from a particular index. So, don't don't search
the whole list to find the minimum, start
438:08 - finding out the minimum from the following
index, for example. So let's give a start
438:14 - index and maybe an end index. But let's give
a starting next. So start searching the minimum
438:20 - from right from there. How can we change all
the code right now? Oh, that's bad thing.
438:25 - Let's change the code. Let's say that's the
start index. Start index. That's it. This
438:36 - the index right now is start index and I is
also start up VB we may use a range function
438:51 - here, that might be much more feasible to
us. So let's use a range function. Rather
438:57 - than this let's change the coding a whole
lot. That's a bad thing we need to change
439:01 - the code for i in range
439:07 - starting from start index, starting starting
from start index, ending at length of the
439:17 - list and doing a step of one Okay. Now x really
is x is really list at the index i okay if
439:31 - x is smaller than m then this is that an index
is AI. Otherwise this we need not to do this
439:38 - because this is this is happening automatically.
And rest of the story is same, I guess Yes.
439:45 - That will work out. Okay, great. Oh, there
is a problem. Oh, we just missed this column
439:51 - here. Great. We fix it. Okay. Now, so if value
is there, maybe this works. Maybe Doesn't
440:00 - maybe there is a bug. Let's see, let's let's
just call this function. So let's call this
440:06 - function l two is sort list. And let's pass
the list as to 153. Minus 870. Let's see.
440:23 - That's boss this list and see what it returns.
If it returns fine, we might be happy. Otherwise,
440:31 - we will see where is the bug? If there is
a bug, oh, this does not contain numeric values.
440:37 - Why not? list does not contain numeric values.
Why is that happening? bliss actually contains
440:46 - all the American values. We read the problem,
check if not numeric, let's see the let's
440:53 - see the implementation of check if not numeric.
Let's see that. Check. If not numeric, let's
441:02 - see the implementation. And there is the bug.
Because all these are numeric. So check if
441:10 - not numeric x in arcs, if not is instance
then return false. So if everything is int
441:19 - or float, so if x is int or float, then return
otherwise return true. So it returns true
441:30 - if all our if all our numerix. So it returns
true if all our Numerix so not true means
441:44 - false. And why why does Why does returning
for us? So that is just was let us just see
441:52 - why it is returning false. That's that's the
bad news that something is happening wrong.
441:58 - Let us just see how this is working. So that
is just check. Check, if not numeric. And
442:16 - let's pass the list this list. And let's see
what is returned. Let's just print the return
442:22 - thing. But it is either true or false. So
it returns a false why it is returning a false.
442:32 - It is a bad thing. Why does they're turning
a false? Let's go to the File. Let's go to
442:41 - the File. Here. Sorry. Let's go to the File.
Here in this directory. Let's open up this.
442:51 - Maybe open this in simply an old bad. Maybe
an old bad, why not? Or maybe some other fancy
442:57 - editor. Let's open this up and see what is
happening. ad format font, let's have a bigger
443:11 - follow on and see what is happening.
443:16 - Self face one of 20 bugs are bad, they're
really bad for x and ogs. Okay? If not is
443:30 - in stance. So first of all is in stance this,
it will return true always okay. If not true,
443:39 - which means false. Then we'll move on and
the loop will be running if anywhere you where
443:44 - it is finding out where it is finding out
basically. So this this is working really
443:45 - fine. Let's, let's let's write this function
somewhere inside our notebook and see what
443:46 - is let's say rather than this. Let's say this
function like check the metric to check numeric
443:47 - to check it not numeric to let's call that
function and see what happens check numeric
443:48 - to it is returning false again. Why does returning
false? That's amazing. Where is the false?
443:49 - So two is integer? Yes. One is integer. Yes.
So true. True. True. True. All these are true.
443:50 - OH minus eight might be a problem. minus eight
might be a problem. Let's see. Maybe. I don't
443:51 - know. Well, well, there is still false. I
mean, I'm stuck here. Guys. I'm stuck here.
443:52 - I don't know what to do. I don't know what
to do. I have to debug this function, I have
443:53 - to go inside that function and see what is
happening. So what we really are eggs. Oh
443:54 - my god, the big trouble big trouble. Yeah,
I found the air. We are passing a list. And
443:55 - that list is just one argument. That is not
a lot of arguments we have to pass all these
443:56 - arguments in in a different way. I mean, if
you want to, you're getting you're getting
443:57 - the bug, the bug is we're passing one variable,
not a lot of them 2153 817 these are not all
443:58 - different variables. For example, if we just
go inside and print x, for just first x, it
443:59 - is the all it is all the it is all the list.
It is all the list. It is not the variables
444:00 - one by one. Let's see. Yeah, I found the bug.
Found the bug. Wait. Yeah, see, it is not?
444:01 - It is not a lot of it is not a lot of variables.
It is not a lot of arguments. It is just one
444:02 - argument that is in the form of placed variable.
That's incredible. What should we do? Should
444:03 - we go inside and add another function check
if not Americ for lists, rather than variable
444:04 - number of arguments. What should we do? Let's
write another function that check for the
444:05 - list. Let's write here check numeric to it
contains the list for exam just accepts list
444:06 - ello or maybe l or whatever x or art just
simply, you can call the or l list. And it
444:07 - goes through all the list. And does does the
same job as previous. So now this will work.
444:08 - So the function that was there in our module
is no longer working, and it will not work.
444:09 - So we are not going to use the function that
is in the module, we are going to write another
444:10 - function that will help us here. And we have
written that, and here we go. It just chained
444:11 - that function to that. And we just we just
throw that out again. And let's see what happens
444:12 - now. Oh, there was another error whichever.
Find a man missing one o v v did not find
444:13 - this fireman is missing the starting index.
So the starting index is C rate.
444:14 - Right? That's a problem. That's a huge problem.
Let's just sorted Oh, my god list finally
444:15 - is sorted. Oh, huge, huge, huge. So you see,
you can call the functions inside other functions,
444:16 - you can call the functions from modules. If
they are no longer working or no longer beneficial
444:17 - for you, you can write new functions, you
can call them you can. Yeah, all that stuff.
444:18 - I guess that that lengthy video taught you
a lot of lessons, how to how to code actually.
444:19 - And this actually happens when you are doing
tasks that are really big. You have to define
444:20 - different functions, you need to define different
functions for modular approach, and focus
444:21 - on each function as a separate entity. And
that that makes much simplicity in managing
444:22 - the code and bug fixing and all that stuff.
You see, I fixed the bug by just noticing
444:23 - that just by just focusing on this function.
I have not thought anything else, just focus
444:24 - on that function go and see the implementation
fix that everything else stays the same. Yeah,
444:25 - so too lengthy a swap here. Okay, now you
have done a lot of practice about functions,
444:26 - loops, and a lot of stuff. That was all the
basic programming in Python. In the in the
444:27 - next video, from the next video, we will see
the real power, a much more real power of
444:28 - Python where you need not write a lot of loops
and a lot of gold and still you will be able
444:29 - to achieve a lot of stuff. And for that we
need to go through the data structures that
444:30 - are available in Python. So from the very
next video, we will start seeing strengths
444:31 - that study or structure we will see less in
detail we will see set in detail we will see
444:32 - dictionary in detail we will see tuples in
detail. And after going through all these
444:33 - data structures and getting a good grip for
the data structures. Then finally we will
444:34 - move we will move to the packages that are
available for data science, particularly NumPy,
444:35 - pandas matplotlib. And we will see maybe I
include maybe I include one or two videos
444:36 - for psychic learn as well. So hope to see
you For the whole new phase in Python, the
444:37 - data structures, so we'll hope to see in the
next video. Okay, let's dive into the long
444:38 - awaited strings. string is basically just
a sequence of characters. And it's a data
444:39 - type, it's kind of a data type. In Python,
it's much more powerful. The reason, the reason
444:40 - of, I mean, making this a whole new data type
in, in almost every language is, the reason
444:41 - is that almost all the data all the text that
appears in sequence of characters, so making
444:42 - that sequence of corrector, the whole text
as one kind of data type, and writing special
444:43 - kind of functions to, to deal with that text
might be necessary. And that's what the string
444:44 - is. In Python, for example, you can declare
a string variable s, or any variable name,
444:45 - by just double quotes, let's say ABC, are
our equal monthly by a single quotes, either
444:46 - way is fine, d f. So either way is fine, you
can declare using double quotes, or single
444:47 - quotes, either way is fine. One thing is,
be careful, don't mix. I mean, don't start
444:48 - by a single quote, and think that now I will
end with double quote, and that will be fine.
444:49 - So don't mix them together. If you're using
single quotes, use single quotes, if you're
444:50 - using double quotes, use double quotes, don't
mix them together, that might be much more
444:51 - confusing later on. So let's say this S is
a string, Python is the best language for
444:52 - data science. That's a D is another string
that is defined by single quotes. In this
444:53 - course, we are going to learn Python, then
you can print s, different in a different
444:54 - way, let's say you will call you can call
a brand s, you can call a print to D. Or you
444:55 - can just by the way, you can you can add two
string variables s and D. And the result is
444:56 - a new variable. That's how the plus symbol
works in strings is plus in strings means
444:57 - just concatenate concatenate them together.
So first, you just copy this string, the whole
444:58 - string, and then you just concatenate the
other string with it. And the result is a
444:59 - new string. Now that's a new variable, you
can use that variable and do a lot of stuff
445:00 - with it. So let's go to Python and see actually,
the brains in in the strings in in the running
445:01 - form. So let's say S is
445:02 - string, let's say, right on is good language,
let's say. And let's have another string T,
445:03 - that is using single quotes. It's good for
data science, sci fi. Okay, it's good for
445:04 - data science, let's run these two, and see
the type of s was the type of s. The type
445:05 - is str string, str, that's what the type is.
And if you just print s, that will be printed.
445:06 - Python is a good language. Remember, so far,
we are using this sprint. And always we use
445:07 - this kind of Hello or something like that.
That basically is a string because by the
445:08 - way, the sprint function, actually, it takes
an arbitrary number of arguments, we can print
445:09 - hello, then we can print anything in another
type, then we can print another Hello, let's
445:10 - say hello to hello to that's a multi multi
variable argument function print, then we
445:11 - can have another string maybe Who are you.
And then maybe a floating point number 5.9.
445:12 - So we we have used these kind of, we have
used these kind of, I mean stuff a lot. We
445:13 - have used print function. And we were using
these double quotes again and again. But but
445:14 - these are actually strings that we will be
that we were using later there. So the spring
445:15 - function actually accept strings and all these
kind of Normally, the whenever you use print,
445:16 - normally you're using it normally you're going
to actually display some text, and maybe you're
445:17 - writing that text into some file and so on.
So this string is highly, highly useful. Most
445:18 - of the data is available in the text form
in the screen form. And we want to process
445:19 - the data we want to find the anomalies in
data, we want to fix them again, we want to
445:20 - stay in the text. So it is good to have a
data type that actually have a lot of functionality
445:21 - that handles all that stuff. So Let's see,
for example, another another, let's see how
445:22 - can we concatenate the two strings, for example,
SMT. Let's say we have B, that is s plus T,
445:23 - that's concatenated. B. And that's francqui.
And we is going to get an ad. While bicon
445:24 - is a good language. It's good for data science.
Well, it is concatenated. But there is no
445:25 - space between two because wherever the first
string ends, the second string starts right
445:26 - from there. What if we can get in a three
strings? s plus another string that just contains
445:27 - a space corrector? Then this string? Why do
we whatever that is there in double quotes,
445:28 - or single quotes, whatever, one corrector
to track character, all these things are called
445:29 - strings. So now we are concatenated, three
strings together as a space, one space string
445:30 - that contains just a space greater than T.
And let's see what happens now. So Python
445:31 - is a good language space, it's good for data
science and so on. Well, so
445:32 - yeah, so that's basically the introduction
of string. What if we want for example, to
445:33 - concatenate? What if we want, we have a variable
A, which is 12. And let's say we have variable
445:34 - b, which is the price of this book, let's
say the price of this book, and a is 12. So
445:35 - let's say this is our price. Now price is
in integer form S is in book form, let's say
445:36 - we want to make another string we, that contains
the following kind of thing, the price of
445:37 - this book is and then whatever the private
price is, that should be there. So what how
445:38 - can we do that? So let's say s, plus, maybe,
maybe another string is then maybe a space.
445:39 - So that after that the price appears? Now,
if we right plus and right price, price is
445:40 - no longer a string, it is an integer, and
an integer cannot be concatenated the string
445:41 - in a straightforward way, like plus, how can
we how can we make a message like the the
445:42 - price of this book is, whatever the value
of the price is, one way to do that is to
445:43 - convert the variable price, the Convert the
type of the variable of price, from integer
445:44 - to string, that means whatever the value,
in this case, 12 is written, that becomes
445:45 - a string of characters one and two. And now
it can be concatenated with with the rest
445:46 - of the string, and we will contain the message
that we want. For example, if we now see what
445:47 - is free, that is, the price of this book is
this book is 12. Oh, we don't have a space
445:48 - before. So let's let's type a space, their
space is also a corrector can be handled in
445:49 - strength, while so that's how we can convert
different types to string. We can have a float
445:50 - type, we can convert that to string, and so
on. Another way of doing the same or achieving
445:51 - the same kind of stuff is to write Brent,
the price of this book is I mean, we can use
445:52 - the power of the variable number of arguments
of then price, that's exactly the same thing.
445:53 - The price of this book is 12, the price of
this book, however, consider one thing, the
445:54 - print function automatically adds the space
for different kinds of arguments. You can
445:55 - see that here, yeah, you need not to specify
a specifier space, the space is automatically
445:56 - added if it is if it is considered to be a
different argument in the print function.
445:57 - Okay, great. So that's the introduction of
a string. We are going to explore string much
445:58 - in in much more detail in the upcoming video,
so stay with us, we are going to see a string
445:59 - in much more detail. Okay, hope to see you
in the next video. A string might be very
446:00 - lengthy, or may span I'm in very lengthy and
may span more than one lines. Or maybe the
446:01 - formatting is in a way that you want to even
if even if it is not very lengthy, you will
446:02 - still want the different chunks of the same
string to be appear in different lines. So
446:03 - there is a way to declare multi line strength
again using either three single quotes or
446:04 - three double quotes. And then three double
quotes or single quotes. Whatever convention
446:05 - you follow Then you write all the string in,
no matter how many lines you want, and that
446:06 - one variable actually contains a multi line
string. If you now print, for example, if
446:07 - you call the print function on this multi
line, that that's By the way, a variable name,
446:08 - multi line string that contains this data,
multi line, multi, multi line that now the
446:09 - spelling our Spelling's around here, I just
created multi line anyways, if you if you
446:10 - call that print function, this will the print
will display the string as it is like it is
446:11 - there. So let's see the and by the way that
the same multi line string kind of fashioned
446:12 - remember that that is used for comments as
well. If you have comments that span on multiple
446:13 - lines, you can use this. So this multi line
string really is if it is not saved in a variable
446:14 - and used as it is somewhere in the code, then
that acts as a multi line comment. Great.
446:15 - So let's practice the multi line string in
in Jupyter. notebook. Let's see. So let's
446:16 - say we have a variable A that is multi line
string. And let's say the spring is this is
446:17 - line one.
446:18 - Then we have this is line two, and then we
have this is last line. And this line is three.
446:19 - That's it. Okay, great. That's a multi line
string. Let's see. How can it Brent a, what
446:20 - happens? So this is line one, this is line
two, this is last line and this line is three?
446:21 - Why this? The first this is shifted one corrector,
right? Oh, there is a space here. Let's remove
446:22 - that space if not required. And run this again.
While because space is a corrector that will
446:23 - be printed if you want. Okay, what if you
really want really want the following kind
446:24 - of stuff, you have, let's say brand. So what
you really do is you want to bring the following
446:25 - the following options are available. And the
options are, let's say dab, dab, dab, let's
446:26 - see a hyphen, a. And that does play from a
that does nothing. And then we have let's
446:27 - say hyphen B and they're also also does nothing.
Let's say you want our message to be painted
446:28 - in in such a way, what will happen? Let's
see. Okay, the following options are available
446:29 - hyphenate has nothing hyphen B I mean, all
this is a string multi line string, these
446:30 - crackers that you think they are not there,
these are spaces and they are I mean the spaces
446:31 - are painted here, the spaces are painted here,
we are saying nothing is printed, these are
446:32 - the spaces that are printed there. So sometimes
this multi line string, it helps to format
446:33 - our message in a way that we like. So that's
how helpful in most of the cases further if
446:34 - you write this multi line, by the way, if
you write this multi line, comment in the
446:35 - start and end of any good script. That means
the if you write this multi line way of defining
446:36 - the strings at the start and end of any good
script, that code script is commented that
446:37 - we have seen several times earlier as well.
So, for example, in problem solving, remember
446:38 - that we define all? Oh yeah. So that's the
comment. That's a comment. Even if some code
446:39 - is written inside that will not be executed.
Right. Okay, so that's about the multi line
446:40 - string. In the next video we will see because
because the string really is, is basically
446:41 - a collection of all these characters. What
if we want to access a particular character?
446:42 - For example, this is the first graduate is
d here, the second Gregory is at the third
446:43 - correct? Is it the fourth record is S, the
fifth Gregory space and all? What if we want
446:44 - to access particular characters inside the
string? Because the string contains a lot
446:45 - of directors? What if we want to play with
some of the directors inside the string? How
446:46 - can we access different directors for example,
if we want to access seventh director of the
446:47 - string, how can we do that? So, let's see
in the next video, how can we index different
446:48 - characters inside a string, I hope to see
you in the next video. Okay, in this video,
446:49 - we are going to actually access different
characters inside the string, sometimes called
446:50 - indexing, the term slicing is basically more
relevant to arrays, lists are actually the
446:51 - immutable structures, but we will see,
446:52 - I'm just comparing, because you may listen
this term slicing again and again, but really
446:53 - this indexing but we will see the indexing
or slicing sometimes is you these two terms
446:54 - are used interchangeably, we will see the
examples of slicing in detail in lists. And,
446:55 - and in more detail in NumPy arrays. But here,
you just think that indexing and slicing are
446:56 - the same things. index. So for example, I
have this a let's say this is a array, and
446:57 - I want to access its fourth element here,
the fourth corrector element is E. By the
446:58 - way, this a is a variable, if I want to access
the very first corrector the the indexing
446:59 - the number, the positioning starts from the
integer zero, that's the first corrector.
447:00 - So if I want to print out of it, that will
print g if I access for example, if I write
447:01 - the index three, what do we mean that means
the fourth element, the fourth element is
447:02 - he what will be printed, what will be printed,
if I access the fourth element of the index
447:03 - for a fi access this thing or space will be
printed and you will be seeing nothing because
447:04 - when a space is printed, actually, nothing
colorful is printed there and you might be
447:05 - thinking Oh, nothing is printed, nothing,
nothing has been accessed, actually a space
447:06 - corrector have been accessed. So yeah, a more
we can we can we can actually access, we can
447:07 - actually access a substring inside a string
as well. For example, we want to access for
447:08 - example, a substring starting from index three,
and all the way up to index eight, but does
447:09 - not include the index eight. So it will include
the corrector at index three, which is he
447:10 - correctly at index four, which is space, let
me write space in this way. Director at index
447:11 - five, which is Oh, correct, read index six,
next record, which is F, then a space, which
447:12 - is seven, and then the correct read eight.
And so this is not included, to be accessed.
447:13 - This is included, this is inside, this is
included. This is not included. So we can
447:14 - access a substring. So starting from three
and ending at eight. Let's see, let's see
447:15 - an example. And you'll come back to this slide
again, after after a few minutes. So let's
447:16 - say we have a spring as let's say, how are
you? And who are you? That's it. So let's
447:17 - do that. So spring, okay. And what do we really
want is we want to access for example, the,
447:18 - we want to access the element to access the
elements, you have to write the square brackets.
447:19 - That's a standard notation. In Python. Whenever
you have a collection and you want to access
447:20 - different elements, that collection might
be a string that collection later on, we will
447:21 - see might be a list. Maybe a tupple dictionary
may be a set. Maybe a NumPy array may be a
447:22 - panda's structure, I mean, anything that is
a collection, normally it is accessed by It
447:23 - has different elements, and we want to index
them. The indexing division is square brackets.
447:24 - And indexing always starts from zero rather
than one. In Python. There are some languages
447:25 - in which the indexing starts from one for
example, MATLAB, the indexing starts from
447:26 - one but in Python and in several other languages.
The indexing starts from zero, which has some
447:27 - benefits or starting with one it has some
benefits. So starting with zero is okay is
447:28 - okay. So let's say we want to access element
at index five. The element at index five is
447:29 - actually the sixth element in the string starting
from zero. So first, second, third, fourth,
447:30 - fifth, sixth, so our will be printed. So let's
see. Our is printed. Let's check the let's
447:31 - check the type of this return value. Let's
check the type of this this one element which
447:32 - is our what is the type of it subtype of different
elements in a string different characters
447:33 - in a string? What are the types
447:34 - So what is the type of it. So the type is
also string. So each and every corrector is
447:35 - also of string type. In some other languages,
the type might be a corrector. corrector is
447:36 - another type, but in, in Python, each and
every one character is also a string. More
447:37 - than one. correctness is also string, as long
as they are accessed from a string. Okay,
447:38 - let's access for example, the element number
three to element number, let's say eight.
447:39 - So the result is our so element number three,
not three, actually starting from index three,
447:40 - which means the fourth vector, which is space,
and then e, r, e, and then space, and then
447:41 - we finish. if you for example, move to from
three to nine, let's say, and the the rally
447:42 - will be our why or we may move to from for
example, we may start from the very beginning.
447:43 - So for example, index zero, we may end at
the index 10, but not including the 10. So
447:44 - the result is, how are you and then I mean,
why Oh, and not the you included, because
447:45 - that's index number 10. And index number 10.
The last index is not included. Great. We
447:46 - can have negative indices in strings as well.
So a negative index is just just the indexing
447:47 - from the right side, not from the left side,
for example, on negative index. So minus one
447:48 - points to the last corrector. For example,
you similarly minus two points to the second
447:49 - last corrector, and so on. So minus one, that's
a success, you. And similarly, we have minus
447:50 - three, and that will access why, or we may
have start from let's say, minus, start from
447:51 - let's say, minus eight, and go till minus
three, that means go back to go back to minus
447:52 - eight index, and then move to minus three
index, okay? And minus three. In this case,
447:53 - let's see what was the result are, what is
that? Why are? Oh, this are, I guess this
447:54 - are? Let's check it out. So this is this,
you, this is minus one minus two minus three,
447:55 - that's an X number three. So three is not
included. minus three is not included. So
447:56 - it has to stop here. Okay. That's minus four
minus five minus six, minus seven and minus
447:57 - eight. Oh, great. So that should be printed,
it has printed. So let's say we have rather
447:58 - than minus eight, we start from minus 12,
and be raised to minus three. So we're okay.
447:59 - Great. So we have negative indices as well.
And by the way, this kind of fetching this
448:00 - kind of substring is sometimes called slicing,
I mean, we are just fetching the slicing,
448:01 - although the term slicing is much more popular
in, in in mutable data structures. What What
448:02 - is a mutable data structure? What is an immutable
data structure? Well, yeah, I should tell
448:03 - you right now, you can change, you can not
change any corrector in the spring. That might,
448:04 - that might look like a bad news for you. But
once the spring is created, the elements in
448:05 - the strings are not changeable. So for example,
let's say at position number one, you want
448:06 - to place a corrector. Let's see, that's not
possible. And the reason is, the string is
448:07 - a data structure, the string is a variable
type a data type that is immutable, immutable,
448:08 - are unchangeable. Once created, you cannot
change its contents, they stay fixed, you
448:09 - cannot change them, you cannot alter them,
you you cannot delete certain contents from
448:10 - it. I mean, once created, it stays as it is,
you can copy this into another string, you
448:11 - can copy and paste, but you can get a substring
and copy into another variable, for example,
448:12 - but the contents of s cannot be changed.
448:13 - So all the kinds of data types in Python that
are unchangeable, the contents are not changeable.
448:14 - They're called immutable. And string is immutable.
So so the the time slicing makes much more
448:15 - I mean sense or it is more popular in the
data structures that are mutable, that are
448:16 - mutable, although, you can use time slicing
indexing both interchangeably. But it refers
448:17 - to roughly in reference to fetching the sub
structure or substring. In this case, in the
448:18 - list, it will be a sub list or so on. So that's
what slicing is. Yeah. Great. Why don't we
448:19 - do some more fun with this spring?
448:20 - Yeah,
448:21 - let me show you more fun with this rank, more
indexing, let's say you start at index zero,
448:22 - you go to index 12, but not including 12.
And then you jump, you take a jump of two
448:23 - rather than one, what we'll do is, it will
fetch all the corrector starting from index
448:24 - zero, all the way to index 12, but not including
12. But it will take a jump of two rather
448:25 - than taking the jump of two. So first greater
than take a jump of two, then pick a corrector,
448:26 - then take a jump of two and then pick a corrector.
So it will actually pick every other characters
448:27 - starting from zero. So let's see that. So
for example, if you remember the string, that's
448:28 - the string. So it starts from h Fine, then
it skips Oh, and go to W, then it skips bass
448:29 - and go to a then it skips R and go to E then
a skip space and go to u and then it skips
448:30 - Oh, and go to a shoe and then the cloud achieved
and we stop there. Wow. So the general way
448:31 - of slicing or indexing the general way is
you have a starting next start, then you have
448:32 - an index and then you have a step size. If
you do not mention the step size. the step
448:33 - size by default is one that we were doing
already. If you do not mention the end, the
448:34 - default end is the building and the total
list size. If you do not mention the start
448:35 - the default start is zero. For example, let
me make that a comment and just practice a
448:36 - few for example. Let's start from zero we
do not mention the start let's start from
448:37 - zero and go to 12 if you do not mention the
starting index that starts from the very beginning
448:38 - zero go till 12 Okay great. If we do not mention
For example, we start from three and we do
448:39 - not mention the end that means go till the
end starting from index three including the
448:40 - last corrector Okay, if we do not mention
the step for example, if you start from one
448:41 - go till 12 and we do not mention the step,
the default step is one okay. There is one
448:42 - way of reversing the string, I mean very beautiful
way I mean, you do not you do not start the
448:43 - mention and you do not mention the start,
you do not mention the end, and then just
448:44 - take a step of minus one in this particular
way. The Start and End index they are they
448:45 - are just swept and you get the string reversed
way. While so that's the reverse great. Isn't
448:46 - that fancy? Yes, it is. Okay, a lot about
indexing, you can find out the length of any
448:47 - string by using l m function, you can find
out the length of any substring if you want
448:48 - to if you have a substring using again a lamp
function, alien, that's okay. Okay, and now
448:49 - you've seen how to access sub strings and
how we cannot change the elements of a string
448:50 - because it is immutable, but we can access
them, we can access them, we can just display
448:51 - them, we can analyze them and so on. In the
next video, we will see some functions that
448:52 - are supplied for string processing, what we
can do with strings, I mean how can we manipulate
448:53 - those strings, although we cannot manipulate
the contents of a string, but we may copy
448:54 - a string we may get explained, manipulate
it and save it to another variable and how
448:55 - what kind of functions that are available
in string in string data structure string
448:56 - data type. So let's see that in the next video.
Hope to see you in the next video. Okay, let's
448:57 - see different functions that are available
to play with the strings. In this dense string
448:58 - data structure, let's say you have the string
a a lot of spaces, these are a lot of spaces
448:59 - at the beginning and these are a lot of spaces
at the end there are some spaces in the middle
449:00 - as well. So, there is one function called
strip all the functions of the string they
449:01 - are called by taking a dot A dot something
These are called methods you can loosely call
449:02 - them functions, but those kind of functions
that are related to some data structure and
449:03 - called with dot, they are sometimes called
methods. The term method is more related to
449:04 - object oriented programming actually string
is a class. So all these are the methods But
449:05 - even without knowing that it's perfectly okay,
you can call it method or function that's
449:06 - perfectly okay. You can, I mean, it's okay.
It's okay without knowing what a class is
449:07 - without knowing what an object oriented programming
is, this a dot some function that operates
449:08 - on this a.
449:09 - One difference with method and function is
when you call a function with a dot, and you
449:10 - call some function that say, a dot strip.
Then inside the definition of the function,
449:11 - this a object or the a variable is available,
like, like you have passed that variable as
449:12 - an input argument. That's all you need to
know about the difference of matter and function,
449:13 - the rest of the story is perfectly okay. Even
if you don't know that that's fine. Okay,
449:14 - eight outstrip, it operates on a which means
that a is passed in this function as just
449:15 - as input argument or it is available there
inside the function implementation. And then
449:16 - the script function, what it does is it removes
all the spaces that are in the beginning,
449:17 - and removes all the spaces that are at the
end, and returns another string that has that
449:18 - has no spaces at the beginning and no spaces
at the end, and the new string is copied or
449:19 - created in a variable b, let's say whatever
that we believe we can, we can have another
449:20 - name of that variable. So let's see. Let's
see the running form of this script function
449:21 - in our friend Jupyter. notebook. So let's
say a is a string variable. That's a lot of
449:22 - spaces abcdef, a lot of spaces and hg gilwell,
whatever. And then a lot of space, and that's
449:23 - it, this is a and then we have B, let's say
a dot strip. Okay, and that's sprint B. So
449:24 - b is actually everything without spaces without
the starting spaces. And without ending spaces,
449:25 - it does not hurt the spaces inside. So that's
the script function, sometimes processing
449:26 - the data. When we when we read the data from
a file, it may have a lot of spaces at the
449:27 - beginning at the end, maybe due to formatting
issues or something like so and it is this
449:28 - function is available. If we want to remove
those spaces from beginning or from the end.
449:29 - Let's see more functions. Another function
is lower, like the name suggests it actually
449:30 - it actually converts all the string to lowercase.
For example, let's say we have a string, let's
449:31 - say, a B, A, let's say we have a string, a
equals A, B, C, D, E, F, G, and some directors,
449:32 - some other directors and Q f, let's say that's
a string. And now what we do is b equals a
449:33 - dot lower. What it does is it converts all
the string to lowercase. For the characters
449:34 - that are already in lowercase. It doesn't
hurt it. For the characters that has nothing
449:35 - to do with lower uppercase, it doesn't hurt
that all the characters that are not in the
449:36 - lowercase and can be converted to lowercase,
those are converted to lowercase. And this
449:37 - is available. Yeah. Great. So similarly, we
have another function called upper for example,
449:38 - C is equal to a dot upper that the like the
name suggests, it converts all the characters
449:39 - to uppercase. Well, let's see more functions.
Oh, there is a function replace the Replace
449:40 - function. What it does is it takes a substring
and replaces that substring with another substring.
449:41 - Okay, let's see. For example, let's say we
here we want to be have the same a, let's
449:42 - say the a is this thing. Let's say that's
a and what do we want to do is we want to
449:43 - replace the semi colons let's say with with
with the semicolon, we want to replace the
449:44 - semi colons with statics. So what we can do
is we can say okay, d equals a dot replace,
449:45 - replace the semi colon with with let's say
steric. Or, yeah, so let's see what D is.
449:46 - So each semicolon is replaced by a steric.
By the way, if you if you want to replace
449:47 - for example, a, a dark replace, if you want
to replace one is there one semi colon One
449:48 - semicolon with a string. For example, the
string is star star, and, and hashtag or some
449:49 - person. That means one semicolon will be replaced
by this, seek with this string, and the other
449:50 - semicolon will also be replaced by this screen.
And the result will be as expected, each semicolon
449:51 - will be replaced by the screen. And that's
the result what it is further if you want,
449:52 - for example, if you want, for example, let's
say d equals a dot replace, if you want this
449:53 - particular substring, that contains the two
semi colons, if you want the two semi colons
449:54 - to be replaced by another substring, let's
say two semi colons, let's say. And that is
449:55 - also possible I mean, you, you replace one
substring with another one. Right? There is
449:56 - one more function called split. That what
it does what what the split does is, for example,
449:57 - you have a string, for example, let's say
a equals a string, let's say, ABC, then you
449:58 - have this colon, then you have d f, then you
have semi colon, then you have ads g y, there's
449:59 - Dan semi colon, then you have y y 3223. That's
it. That's your string. Let's say you read
450:00 - that string from some CSV file and disappears.
And now what you want, you want all these
450:01 - values to be separated out that are that that
are separated by the semicolon, maybe these
450:02 - are different values, ABC is a different value,
then it is separated by a semicolon semicolon
450:03 - may be an indication or token that the next
value started and so on. Let's say you want
450:04 - to separate them, let's say you want to just
split them all of them with a particular splitter.
450:05 - And here, let's say the splitter is semi colon.
So what you can do is you can have a list
450:06 - and a dot split. And in the split, you can
specify the corrector that that is used for
450:07 - splitting after and before we split that.
And remember, the split function actually
450:08 - returns a list of strings, where this is the
first element of the list, this is the second
450:09 - element of the list, this is the third element
of the list, this is the fourth element of
450:10 - the list and so on. Because once you will
split, you will be having different elements
450:11 - that are split it out. So if your brand for
example, l we will be having a list of different
450:12 - strengths, ABC and all that, Oh, don't worry
about the single code, the single core and
450:13 - double core is the same thing. Now we can
access for example, the third element or or
450:14 - maybe the second element by index one. And
the second element here is D, E, F, and we
450:15 - can work more on that. Okay. Is that it? I
mean? Are these the only functions that are
450:16 - available? stripped function lower a birthplace
and split function? Or is that it? That's
450:17 - all the spring is about? Maybe there are more
functions? How many functions are there in
450:18 - string? How can we use them? What are the
what are the total number of functions? Where
450:19 - is the list? We visit documentation? Should
should we follow some book? Should we go to
450:20 - some tutorial and find all the string functions
and see how to use them? Well, if you want
450:21 - to do that, you can do that. But there is
another smart way. Let's say a is a string
450:22 - that you know, you write a dot and then a
press tab, and all the things that that are
450:23 - there in in string, they will they will appear
in front of you on several things. You can
450:24 - go to this, you can go to that you can go
to that and so on. So just you can check the
450:25 - documentation of a for example, if you if
you press a and what it does, let's see. It's
450:26 - a string object and all that stuff. Fine.
It's a string. So further what we can do.
450:27 - So let's say a.we, press A and then we press
tab. Is there anything that starts from a
450:28 - Nope? Is there anything that starts from B?
No. Is there anything that starts from C?
450:29 - Yes, capitalize case fold center count. These
are the functions that are available that
450:30 - starts from C.
450:31 - Okay, let's focus on capitalized. Okay, what
is that thing how to use it? That's press
450:32 - colon, question mark and see what this is
and what it does. Okay, so here is the documentation
450:33 - here is a doc string returns capital. I used
to worry enough the string capitalized version
450:34 - of the string. Is that the same as upper?
Maybe? So let's see. Now we know what it does.
450:35 - Let's just check it out, print a capitalized
and see what's the result? Oh, it's got Oh
450:36 - no, it does not get delays the whole screen,
does it? Did they the screen a was it does
450:37 - not capitalize the whole string? What What
is a? Let's see what is a? A is the following
450:38 - string is the following string, so it does
not capitalize the whole string. Oh, the difference
450:39 - between the capitalized maybe? And the upper?
Is that the capitalize when it encounters
450:40 - when it encounters? No, no, no capitalized
just capitalizes the first corrector. Let
450:41 - me let me read the doc string, again, returns
a capitalized version of the string, more
450:42 - specifically make the first corrector have
uppercase and the rest lowercase. Okay, that
450:43 - means if we have a string that has a mix of
values, the capitalized will do the following.
450:44 - It will convert the first character to uppercase
and all the rest of the characters the lowercase.
450:45 - Wow, that's awesome function. For example,
if you have string, abs D, A, B and GG, kill
450:46 - that say. And then we call capitalize, capitalize,
let's say. So what that does is it actually
450:47 - capitalizes the first director and all the
rest of the directors there as it is. And
450:48 - there are other functions as well, a dot A
dot, let's see count, what it does a dot count
450:49 - what it does not count. What is that thing?
Let's check it out. Or maybe we can check
450:50 - that out using help. What is zero count? So
let's see what is a load count. It's a built
450:51 - in function called matters is an instance
of and it returns a number of non overlapping
450:52 - occurrences of a substring. Sub in Oh my God,
if you I mean, that's what it what what is
450:53 - written there, non overlapping apprentice
of a substring. Great Oh my god. So basically,
450:54 - there are there are a whole lot of functions
of strings that are available, there are several
450:55 - use of the string, there are several ways
of molding and playing with the strings, some
450:56 - of the functions that are available, some
you can make your own, you can make your own
450:57 - modules on top of that, to customize your
written to customize according to your requirements.
450:58 - A lot of these are available, and you should
know how to use them. And first thing if you
450:59 - want to do something with strings, or with
any data type in Python, first check whether
451:00 - some method is available or not. And one way
to go that is just right away from here. And
451:01 - other ways to go to internet and see I want
to do this in Python. with strings, whether
451:02 - there is a function available or not the good
chances are there will be a built in function
451:03 - that is available. And in that case, I will
encourage to use that function rather than
451:04 - to write your own one because using the built
in function, or the method that is tied up
451:05 - there will be much more faster probably than
the function you will be writing at your end
451:06 - even if you're too smart in algorithms. So
yeah,
451:07 - so that's about the spring matters, there
are so many other methods that are available.
451:08 - In the next video, we will see some more some
more manipulation and processing and some
451:09 - more working with strings. And then we will
move to other data structures. Okay, hope
451:10 - to see you in the next video. In the last
video, we saw some methods of string. And
451:11 - these are just a few of them, a lot of them
are available. We just we just discussed some
451:12 - of them. In this video we are going to talk
more about strings in a particular way. For
451:13 - example, what if you want to find out whether
a particular substring is there in a string
451:14 - or not. Let's say you have a string and you
want to know whether a particular substring
451:15 - is there inside a string or not? Well, you
can easily find out that using the end keyword.
451:16 - And similarly not in means the reverse of
that, or the complement of that or not of
451:17 - that. And in keyword always will return either
true or Boolean or false. If it is inside
451:18 - the screen, it will return true if it is not
inside it will return false. So let's check
451:19 - this the implementation of that in, in, in
Jupyter Notebook. So let's see. So let's say
451:20 - we have a string ABC ABC. And we want to check
whether this string is there in this particular
451:21 - string or not. So the return value is false
because ABC as a substring is no longer there.
451:22 - A is there. For example, here, a B is here,
but ABC is no longer there. Yeah, so if we,
451:23 - for example, have an ABC somewhere, at least
once, then the result will be true. In the
451:24 - last, in the last video, or maybe in the very
first video for strengths, I showed you that
451:25 - you can use plus with strings, can you compare
two strings using less than or equal to? I
451:26 - mean, how to compare two strings, whether
they are same or not, for example, ABC, that's
451:27 - a that's a string ABC, I want to check whether
that string is the same as ABC or not, what
451:28 - will be the result? So so so the question
is, is this double equal to is used can be
451:29 - used for comparing two strings? Well, the
answer is yes. Or what will be the meaning
451:30 - of less than a string as less than the other?
Is that true? For example, ABC, is less than,
451:31 - let's say d f. Is that true? If it is true,
for example, what does it really mean? How
451:32 - can we define one string is I mean, this string
is less so than the other string, maybe this,
451:33 - maybe this operator is working based on the
length of the strings. But if even if that,
451:34 - then this length is the same as this length.
And to be more precise, we can change that
451:35 - length, for example, by just saying, okay,
ABC, D, F, G, H, I, and I guess this string
451:36 - will be still smaller than the right string.
So how this comparison is working? Well, I
451:37 - guess the comparison is working based on the
based on the alphabetic order, and you know,
451:38 - the alphabetic order, a B comes first and
B and C and all the alphabetic order that
451:39 - is there in English dictionaries. That's how
the strings are working here. And the alphabetic
451:40 - orders for all the special characters will
also be defined in Python, for example, that's
451:41 - a special graduate, for example, maybe this
string is this string smaller than the following
451:42 - string. Yeah, we've done for false, because
there is particular ordering. In, in Python
451:43 - that is defined for these characters that
this becomes first and there's like, a becomes
451:44 - first and B, B becomes first and C and so
on. So whatever the alphabetic order is, based
451:45 - on that, or you can compare the two strings,
no problem. So these are also available. And
451:46 - the third thing is in function that is also
available to check whether a particular string
451:47 - is inside a substring is inside or not to
in another string. One more thing that I want
451:48 - to talk about in that, for example, what if
your goal is to print the following, let's
451:49 - say let's say you want to print the following,
we are learning. And let's say you want to
451:50 - print the string in double quotes. We are
learning string here. Let's say you want to
451:51 - print this, you want this string to appear
in double quote, how can you do that in Python?
451:52 - Well, it looks like same. What's the difficulty?
Let's Let's call the print function. And then
451:53 - just like here, we are learning. Then write
the double quote here, scraping. And here.
451:54 - That's it. But there is a problem. The reason
is, the reason is when we call this, when
451:55 - we write this double code, actually, the string
ends here, exactly the string ends here. And
451:56 - when we write this single code, and this double
code, another string starts here. And this
451:57 - is no longer a string. I mean, what it has
no data type inside. Well, how can we then
451:58 - insert these double quotes inside? Well, there
are several ways. One way is to use escape
451:59 - sequence and escape sequences just like it
is you use a slash and then whatever you use
452:00 - is considered as a corrector. Inside the string
that is you're using it now if you want another
452:01 - double quote, you use a user corrector which
is the backslash or maybe a forward slash
452:02 - and if you use that That means that means
whatever that is coming in front of it should
452:03 - be used as it is, rather than, rather than
considering that that's a special string defining
452:04 - symbol. Now in this particular case, you'll
be having your double quotes available, and
452:05 - the backslash will be just out, it's justifying
that don't touch this double code, it has
452:06 - nothing to do with defining a string. It is
just because I want to highlight this word.
452:07 - Another more. Another more easy way is to
use the single quotes, for example, we are
452:08 - learning and use the double quotes as a corrector.
Inside that now the single quote, wherever
452:09 - it starts and ends, they defined the string,
everything else is correct. We do not need
452:10 - a escape cracker where we where we want, okay,
great. But there are a lot of escape characters,
452:11 - for example, we have V, our backslash n, that
means go to new line, we are now on an other
452:12 - line. So this backslash n actually puts everything
that comes after to a new line. That's an
452:13 - escape corrector. Similarly, we have an escape
corrector, backslash D, that actually inserts
452:14 - a tab. Whenever we want Sophie, then a tab
then now on another line, now on another tab,
452:15 - whatever. So there are a lot of escape characters.
I'm in backslash, N, backslash t there are
452:16 - other. So it is good to know those. One more
thing that is important. For example, let's
452:17 - say you want to print. Let's say you want
to print some address on the right, let's
452:18 - see, Mac's slash back slash forward slash
whatever that is called name, backslash Dr.
452:19 - Let's say you want to do that. And your goal
was to just print that box, what will happen
452:20 - is this backslash n will be treated as a newline
escape sequence. And backslash n will tell
452:21 - Okay, go to the next line and create the rest
of the things. But because backslash D is
452:22 - not any escape sequence, it is not listed
inside, it is treated as it is and that way
452:23 - this slash is also treated as a director.
But here because if this slash followed by
452:24 - this n, that's combination that is already
there for a new line that is treated in a
452:25 - different way. If you want this to be used
as a deus and you don't want these, you don't
452:26 - want this behavior, you just want that all
this should be greeted in a very literal or
452:27 - raw sense, then you should just apply and
are there in our will tell, okay, that's,
452:28 - that's a raw string, everything inside just
treat that as a raw string, there is no escape
452:29 - sequence inside. Great. So and there is much
more about strings, we can talk but that that
452:30 - was the most important that I that I told
you, at least to me, we can explore this more
452:31 - actually, you should now explore the smaller
What are other functions of string, how can
452:32 - we play with strings in another way and stuff
and
452:33 - so on. If I talk about strings, I can just
I mean, I can give a whole course on strings
452:34 - as well. But here I just give you a snapshot
of strings. If you need more about strings,
452:35 - I mean you should be searching on internet
of seeing documentations and seeing basically
452:36 - what you want according to your requirements,
search the functions probably they will be
452:37 - available. Okay. In the next video, we are
going towards list topples, sets and dictionaries
452:38 - some other data structures that we were talking
about earlier, we will be going to explore
452:39 - them in more detail from the next video. Hope
to see you in the next video data structure
452:40 - informally or in a very naive sense is basically
a collection of a lot of basic data types
452:41 - that contains data one structure contain a
lot of data. And we can define sometimes several
452:42 - methods and several specialized kind of functions
are customized and define just because of
452:43 - that data structure to perform efficiently
different kinds of I mean for different kinds
452:44 - of tasks, we may have to define or we may
have to choose different kinds of data structures.
452:45 - The basic data structures that are available
in Python is a list tupple set and dictionary.
452:46 - These are the basic data structures that are
available. We can create our own data structures
452:47 - if we want to. But most of the problems almost
all of the problems mostly they are solved
452:48 - by these four basic data structures. Although
a lot of these are not that efficient. There
452:49 - are efficient ways for customized kind of
problems, we will see that efficiency when
452:50 - we will deal with the package NumPy that is,
that is faster than all of these, but will
452:51 - but we will see what kind of constraints are
there to make it faster. Anyways, data set
452:52 - in a very loose term is collection, it is
a collection of a lot of values a lot of data
452:53 - inside. And all these data structures list
tupple set and dictionary, they they are a
452:54 - collection of data of heterogeneous types,
which means one value can be integer another
452:55 - element let me call an element, another element
or item, another item or element can be of
452:56 - string type, another element can be off, let's
say floating point number another element
452:57 - is a whole list itself another element is
a topple and so on. So different elements
452:58 - can be of different types. And that makes
this heterogeneity that makes these four data
452:59 - structures much more applicable and much more
abstract. And they can be applied to almost
453:00 - all the problems. So let's see one by one
and let's compare them together because the
453:01 - best way to understand four of these is just
to compare them which can do what as compared
453:02 - to the rest. So let's let's compare them and
learn how can we use those in detail. So list
453:03 - first is list list is ordered ordered here
means it is indexable which means there is
453:04 - a particular element number one is at position
one element, there is an ordering of elements
453:05 - first element second third 25th element, there
is an ordering of element with respect to
453:06 - their position. So that's what we mean by
ordered changeable or sometimes called more
453:07 - more reasonable term or more usable term is
mutable. mutable means once the list is created
453:08 - as contrast to string, once the list is created,
you can change its elements for example, you
453:09 - can change the third element with another
element and that's perfectly fine you can
453:10 - change it that what we mean by changeable
or more popularly called as mutable duplicates
453:11 - means the list can contain more than one one
element more than two, I mean, at the position
453:12 - number three, you can have the same item and
position number five you can have the same
453:13 - item that so the duplicates are allowed tupple
however, although ordered, there there is
453:14 - an ordering of elements there is there are
indices of different elements, this is immutable,
453:15 - you can once topple is created like strings.
Once the template is created, you cannot change
453:16 - different elements in the tupple you have
to create a new topple if you want to, but
453:17 - you cannot change the items in the tupple
and the duplicates are allowed again set on
453:18 - the other hand is unordered which means there
is no indexing there is no positioning, there
453:19 - is no first element there is no third element,
there is no Fifth Element, there is that's
453:20 - a collection without it without actually indexing
453:21 - because you cannot access a particular element
with index you cannot change it, but what
453:22 - you can do it you can insert more elements
and you can remove existing elements if you
453:23 - want to. Again, the set like in mathematics
sets does not contain any duplicates. So one
453:24 - item appears just once we will see the examples
Dictionary of very, very, very powerful data
453:25 - structure. Again, it is it is dictionary is
just like a set, it's a set it is unordered.
453:26 - Again, chancer bow, you can change them but
you can change the items you can and the dictionary
453:27 - the pocket and it does not have duplicates,
because it's it's basically a set it is just
453:28 - like I said, the power of dictionary is each
item consists of consists of a pair and one
453:29 - one value in the beer is called key and another
is called the value for example, well is key
453:30 - for 12 name is key for band and and so on.
So we have seen this dictionary before in
453:31 - loops and stuff in just a very loose way.
But then that's really a very, very powerful
453:32 - data structure. And later on we will see in
pandas basically all the data is basically
453:33 - managed, just like a dictionary if you if
you have a good knowledge of dictionary, you
453:34 - will be having a very good grip very quickly
on on a Big Data Science Library or Big Data
453:35 - Science package which is called pandas because
each and everything in pandas is handled just
453:36 - like you're handling a dictionary. So it's
it's a really powerful data structure to know
453:37 - about.
453:38 - So, so so
453:39 - list is mutable dictionary is mutable set
is mutable, in a sense that you can insert
453:40 - and remove elements. topple is not mutable.
And that's a comparison theoretically What
453:41 - is there, all these types, each and every
of them is a collection of different values.
453:42 - And the values can have different types. That's
the that's the abstract power of all these
453:43 - data structures. So, in the next video, we
will, we will, we will actually try to get
453:44 - a good grip on list topple set in dictionary
and we will actually define them code and
453:45 - access different methods of those and we will
be we will be trying to become comfortable
453:46 - with with these data structures by coding
them in Python. So hope to see you in the
453:47 - next video. Okay, continue in previous video
we were talking about data structures in the
453:48 - last video. So let's go to the Jupyter Notebook
and see how a list can be defined or declared
453:49 - how a tuple can be defined or declared set
and dictionary, let's see how can we make
453:50 - these data structures in Python? So then one
by one, we will compare how can we access
453:51 - elements of the list? How can we insert more
elements in lists tuples are in dictionary
453:52 - and and see the comparisons of all these one
by one operation by operation. So let's see.
453:53 - So let's go to Jupyter Notebook, our friend
this file is getting lengthy, lengthy, let's
453:54 - let's make multiple files. Let's say this
is part one. Just save it. And let's make
453:55 - another let's make another file. For example,
let's just close this file, or maybe state
453:56 - opened, let's close this file and make another
file. Python three. Yeah, so let's name that
453:57 - file as this part two, let's start a new file
that that file was on in that was okay to
453:58 - stay with that file as well. But just let's
make another file. Okay. So that's just have
453:59 - a markdown cell. And let's have a heading.
data structures. Remember the markdown cells,
454:00 - I just introduced them introduce those just
in the very beginning. And then we just forget
454:01 - them. Because writing these description again,
and again, we'll make the video length here.
454:02 - And the purpose is not to actually format
the notebook, the purpose is just to show
454:03 - you the power of Python. So I just omitted
writing these descriptions more and more,
454:04 - but just write a few descriptions in the star
and then we will forget again. Oh, that's
454:05 - it. That's amazing. Let's see, find a list.
So list. Any variable name, that's a variable
454:06 - in the list is, let's say this. You define
this by square brackets and different elements
454:07 - they are separated by comma, that's a 134,
point nine. Name anything I mean, or five,
454:08 - or maybe maybe three again. So that's the
list. Okay. ductile, on the other hand, is
454:09 - defined using parentheses. So let's say 134.
point nine. That's the name. And that's a
454:10 - three again, that's okay, that's a tupple.
A tupple is defined in. So when you write
454:11 - parentheses, that means by default that topple
the variable name has I mean, if you have
454:12 - written t that has nothing to do that it's
a tupple. That's because the Python is dynamically
454:13 - typed. When you will write the parentheses
that means the tupple is being defined. Let's
454:14 - define a set Let's call the variable as S,
the set is defined with with these curly brackets.
454:15 - So let's say 134.
454:16 - point nine, I want to tell you that all these
things they can contain each element can have
454:17 - a different type. But then, even if we include
this three again, because the set cannot contain
454:18 - the duplicates, later on, we will see only
one copy of three will be there in the set,
454:19 - the other will, even if we want to include
it will not be included. Okay? Then let's
454:20 - say a dictionary. dictionary is again defined
like a set, but but each element is a pair,
454:21 - separated by a colon. Let's say the key value
is 23 as a key value, that's the key and the
454:22 - value. Here is a string, let's say
454:23 - two,
454:24 - three, that's let's see the value. Now comma.
Now one element is there. This one element
454:25 - that consists of key and value pair, another
element, another element may have a key with
454:26 - string. So so the keys can be of different
types, the values can be of different types,
454:27 - and so abstract. So the key is, let's say,
let's say B. and the value for this is, let's
454:28 - say 43, then maybe we can have another key
value pair with key as, let's say, c. and
454:29 - the value is, let's say, cc. CCD. That's a
charge coupled device. Okay, anyways, so.
454:30 - So again, now you know how to define less
how to define a topper, how to define a set,
454:31 - and how to define a dictionary. The difference
is, is the main difference here is in dictionary,
454:32 - because one element consists of two values
rather than one. Okay, let's print that and
454:33 - see the types let's print all the types sprint
died off. So let's paint them. That type of
454:34 - L is. So the table L is just printed. That's
L, let's print that. Let's see the other types,
454:35 - let's print the rest as well. So just copy
them and B is the type of list L is that the
454:36 - type of topple is D. And that's a D, then
we have s and then we can just replace this
454:37 - to the s. And then we have, let's say, D dictionary.
And that's, that's D. Okay, so that's been,
454:38 - so the type of L is less the type of t is
topple the time of s is set. The dive of D
454:39 - is dictionary. Oh, great. So that's how you
can define these lists. You can define list
454:40 - you can find topple, you can define set, and
you can define dictionary, no problem. Next,
454:41 - let's see how to access different elements
from from these data structures. What are
454:42 - the way for example, to access an element
from a list, let's say the element number
454:43 - element that indexed with one remember the
element that index with one is element number
454:44 - two, because indexing starts from zero. So
you can access that using the square brackets.
454:45 - If you want to access from topple again from
the square brackets exactly like the list.
454:46 - In set, for example, you cannot index it because
the set has no ordering. First, second third
454:47 - element is no longer there. But you can you
can, you can check whether a particular element
454:48 - is there in the set or not using in keyword.
In dictionary, for example, if you want to
454:49 - check whether a particular element or if you
want to access value, for a particular key,
454:50 - you just create the dictionary variable name
and then write the key and it will return
454:51 - the value. Okay, so let's practice this in
in Jupiter. Let's just practice this in Jupiter.
454:52 - So let's say list value at index one. So that's
brand new, this list added next one, the value
454:53 - should be printed as three brand topple at
index one, again, the way of accessing the
454:54 - same Brent Brent, whether three in s or not,
the return value will be the return value
454:55 - will be true or false. So print will be true
or false. And then print the and just access
454:56 - the value with the key 23. So let's see what
happens. So l added index one is three tier
454:57 - index one is three s, three years in S Yes.
454:58 - And what is the value with the key 23? The
value is the value is two three. Let me just
454:59 - describe more about this D. What is the value
at index B for example, now we have to give
455:00 - the index B in the string format. That's 43.
Yeah, so that's how we can access that. Let's
455:01 - sprint s also let's see s because when we
have defined as we have defined this duplicate
455:02 - three But if you see the elements of s, there
are no duplicates. And it does not maintain
455:03 - even any ordering, I mean, we have defined
s in a different way, it is maintaining everything
455:04 - maybe in a different way, one three. Yeah,
oh, the ordering this way is the same, but
455:05 - there is no index for the first or second
or third element and so on. Okay, so that's
455:06 - about the defining, declaring or accessing
different elements. In the next video, we
455:07 - will see more about about the data structures
actually, actually want to spend some time
455:08 - on the data structures because that will be
a basic building block for for the data science
455:09 - packages, too. If we if we know very well
about these data structures, these data structures,
455:10 - we will be very fluent in the data science
packages and working with those. Okay, hope
455:11 - to see you in the next video. Okay, in the
last video, we define less topple set and
455:12 - dictionary and we actually access different
values. In this video, I'm going to actually,
455:13 - I'm going to actually introduce more indexing,
how to access list and topple in particular,
455:14 - because the both are very, very easily indexable
like strings. And I want to show you that
455:15 - all kinds of indexing that you have seen in
strings, exactly works and list as well as
455:16 - in tupple. So let's go to Jupiter, and see
what a list is, for example, a list, if you
455:17 - print the list, that's the list, it has these
kinds of values, if you just see the list,
455:18 - for example, starting from index one, ending
at index three, that that means the same big
455:19 - a slice for example. So index one value is
three, index to value is 4.9. And the last
455:20 - element is not included. So, if you get that
you get three and 4.9. So exactly the same,
455:21 - the same kind of indexing that you have seen
in strings, exactly there is working here
455:22 - as well. So for example, if I say list, start
from the beginning go to N but then I just
455:23 - give minus one it will reverse the whole list,
I mean the whole list will be reversed. I'm
455:24 - in all the same all the things that that we
saw in in string indexing stays exactly the
455:25 - same in list as well as in topple, so topple
For example, let's access element from let's
455:26 - say from the very beginning till the till
the third element, that's not the third element
455:27 - till index three, which is actually the fourth
element. So topple unless they are exactly
455:28 - they will be exactly index as as it as it
is. So all the slicing all the indexing all
455:29 - the sub sub listings, all all the sub topples,
they can be accessed exactly the same way
455:30 - as you as you've gone through through the
through the strings. One difference here that
455:31 - I will explain later on, because list is mutable
it is changeable, I will discuss one thing
455:32 - that one use when you slice it, when you get
a sub list then actually it refers to the
455:33 - same memory and if you change the sub list
contents, the actual list chord changes. That
455:34 - is that is true for list in slicing. And that
is true for sets and dictionaries, in the
455:35 - copying the references and so on. So I will
discuss that later on. But rest of the things
455:36 - are roughly the same as as they're in string
indexing. Actually, indexing is almost the
455:37 - same everywhere in Python, it has this kind
of slicing is almost the same if you know
455:38 - the index, how to index planes, you know how
to index lists, if you know how to index lists,
455:39 - you know how to index couples and strings
and, and everything. And by the way, if you
455:40 - know how to index strength lists, you will
be very fluent and NumPy. That's the very
455:41 - powerful data structure. That's very powerful
kind of array processing package. with with
455:42 - with some defenses that we will see but
455:43 - even the indexing is same in pandas when you
are working with large amount of data data
455:44 - file and stuff like so the indexing is more
or less the same that you've seen in instruments
455:45 - we will we will cover indexing, masking and
fancy kind of indexing in much more detail
455:46 - in NumPy. But this stays the same as, as you've
seen in in, in strengths Okay, so now can
455:47 - we can we expand the list can we add more
elements? Can we insert more elements to the
455:48 - list? The answer is yes. Because list is changeable.
New trouble you can insert more elements.
455:49 - One way of inserting there is just to call
an add operator, you can just add plus and
455:50 - you just insert in other lists like like two
strings are concatenated by plus two lists
455:51 - can be concatenated, or combined together
again by plus, but there is a faster function
455:52 - called append l dot append. That is sometimes
faster than using this operator we will see
455:53 - that topple because it is immutable. You cannot
touch any content of the double you cannot
455:54 - actually insert any element to a topple you
cannot delete any element to a tupple. There
455:55 - are workarounds for example, convert a tupple
to a last change it then convert the list
455:56 - to a tupple. There are ways to do that. But
tupple in its true sense, in the literal sense,
455:57 - it is immutable. You cannot insert any elements
you cannot delete any element you cannot change
455:58 - any element. However, you can combine two
tuples. Together, you can concatenate two
455:59 - tuples together again by plus operator and
save the result into a new double that's possible
456:00 - set. The you can insert elements using an
add function add function allows you to just
456:01 - insert one element. If you want to insert
more than one elements, then you can call
456:02 - an update function that actually accepts more
than one that accepts another set that need
456:03 - to be inserted. That's possible dictionary,
you can insert a new key by just the new key
456:04 - equals to that you just assign a new value
to a new key and key value pair is just inserted
456:05 - there great, you can delete or remove any
element from the list using D l Command D
456:06 - l l one that means the this particular element
is deleted from the list that is possible.
456:07 - Deleting particular element from the tupple
is not possible However, you can delete the
456:08 - whole variable whole topple that is possible,
you can remove elements from the set using
456:09 - remove function as dot remove, and then you
just give the element that you want to remove
456:10 - that as possible, it will be removed and you
can delete the whole delete the whole variable
456:11 - that is always available. Similarly, you can
delete a particular item from the dictionary
456:12 - by just deleting by just calling the D of
the value for example, whatever the key is,
456:13 - so you call with the key and call the Delete
and it will delete everything I want to mention
456:14 - here for to remove items from the list there
are other methods and functions that are also
456:15 - available that I mean there is a remove function,
there is a pop function, these are available.
456:16 - Similarly, from removing elements from the
dictionary, there are other functions that
456:17 - are available. But just to compare them together,
I am using this de l command, although there
456:18 - are other ways of doing the same stuff, as
well. So let's let's let's let's end this
456:19 - video here. And in the next video, I will
show you all these operations that concatenating
456:20 - together, inserting more elements, deleting
different elements, I will show you all these
456:21 - things in in Python. So So hope to see you
in the next video. Okay, in the last video,
456:22 - we saw how to insert different elements to
different data structures. And we for example,
456:23 - in the case of tuples, it is not possible.
And we also saw how to how to actually delete
456:24 - different elements wherever possible. So let's
go to our friend Jupyter Notebook and see
456:25 - all these concepts in a running form. So let's
go. Okay, so let's say for example, we have
456:26 - list, that's our list. Let's append an element
to the list or maybe more elements, that is
456:27 - L plus. Let's say we can have another list
for example, how
456:28 - are
456:29 - that's six, and then you that's and these
two lists will be appended and the new list
456:30 - will be as you can see this similarly we can
append an item using append function for example
456:31 - 6.8 that will also be appended and this will
contain these kind of values. So yeah, so
456:32 - both arrays are fine. This plus is this plus
can be used to append to append to lists and
456:33 - this append function can be used to simply
append a list with a with an element. Okay,
456:34 - great topples. You cannot change the topple,
you cannot change the topple. But what you
456:35 - can do is you can have two tuples for example,
T two is a different couple. Let's say a A
456:36 - and B, and let's say you have four or five,
that's it that's supposed to, then you can
456:37 - have a third double, that is just the combination
of double one and double two. And in this
456:38 - case, you have double three, which is this.
Yeah, so double one and double two are combined
456:39 - together, but you cannot actually insert into
the assembly, the tuple is immutable, you
456:40 - cannot insert another element, you cannot
delete existing elements, you cannot update
456:41 - any element and so on. Similarly, as the set,
let's see the state of the set, that's the
456:42 - set set God add function, you can add anything,
let's if the six that is added there, and
456:43 - the new state of assets this, or you can call
the update function. If you update method,
456:44 - if you want to insert more elements, for example,
if you have multiple elements to be inserted
456:45 - 23. Again, and let's say you wanted to insert
an element that is already there. So for example,
456:46 - one, then the duplicates will no longer be
there, but the new elements will be inserted.
456:47 - Now let's see the state of D, the state of
D is this. If you want to add another key
456:48 - value pair, you can add a key here, for example,
the key might be new key, for example, new
456:49 - key and the value might be the value might
be, for example, a new value. Well, and now
456:50 - if you see D, the D, the contents of the D
has changed. Well, that's simple. Yeah, great.
456:51 - Can you concatenate two dictionaries together
using a plus operator? Is it possible? Is
456:52 - it possible to concatenate two dictionaries
together? Let's see I have another I have
456:53 - another dictionaries dictionary D two. That
is that say the key is why. and the value
456:54 - is why why? And then we have another key letter
Z. and the value is. Let's sit down, can I
456:55 - can get an A D and D two together? Can I?
Can I just update my D and add these values?
456:56 - insert these values also there? Okay. I left
you with this question. You try to answer
456:57 - this. And in the next video will answer this
question. But try to answer this question
456:58 - yourself. And one way to try that is just
to go in Jupiter and just dive and check whether
456:59 - plus is working or not. Or maybe there is
another method and stuff like so. Okay, great.
457:00 - Hope to see you. Oh, I have not used the D
l delete and all that stuff, and so on. So
457:01 - this question is there, let me use the removing
the elements. So let's say l is this list.
457:02 - If I want to remove an element, let's say
element number three, if I want to remove
457:03 - element at index three, which is this string
name, I can use simply this delete. And the
457:04 - L is everything but without that element.
Similarly, I can remove if I want to remove
457:05 - any element from S, I can call the function
remove. And whatever I want to remove, let's
457:06 - say want to remove game, and the game will
no longer be there.
457:07 - Great. If I want to remove some element from
dictionary, again, let's say that's the that's
457:08 - the view of dictionary. I can call the Add
I can I can remove the element with key let's
457:09 - say C, whatever the element is with key C,
delete that element, and the dictionary has
457:10 - this particular state with this item, this
particular item is gone. Okay, great. I can
457:11 - do that. But But d L is not the only way of
doing that. There are so many methods. I mean,
457:12 - a lot of methods to do that. But just to just
to compare all these, I'm just giving you
457:13 - the most similarities and differences wherever
available. Okay, great. So I have asked you
457:14 - a question in this particular video. Can we
concatenate two dictionaries together, particularly
457:15 - with a plus operator? If yes, then we are
done. If not, then Are there other ways and
457:16 - stuff like so that's the question. So hope
to see you in the next video with more on
457:17 - these data structures.
457:18 - Okay, I asked you a question last time. Can
we concatenate this two dictionaries together
457:19 - with a plus operator? So what's your answer?
Yes or no? The answer is Nope, yeah, so we
457:20 - cannot concatenate them together, we cannot
insert another dictionary to this dictionary
457:21 - using a plus operator. Because this plus operator
is not defined for dictionary, what we can
457:22 - do is we can call an update function, because
dictionary is also a set, I mean, a set of
457:23 - key value pairs. But at the end of the day,
it's a set with specialized function, of course,
457:24 - but we can call update functions, and insert
the whole new dictionary inside dictionary
457:25 - as as as follows. Yeah, so the answer is using
plus operator No, but there is a way using
457:26 - update method. Right. So next, we focus on
the copy function, the copy function is available
457:27 - for less the copy function is available for
set, the copy function is available for dictionary.
457:28 - So let's see the need of this copy function
here, I want you to be very careful. Because
457:29 - that's, that's really important. Let's say
we have a list, let's say, That's list. And
457:30 - by the way, the same goes with set and dictionary
as well, whatever I'm going to do with list,
457:31 - let's see a list. Now, what you do is you
copy the list or you just make another variable,
457:32 - like you can assign the value of l to another
variable l two, what you do is that now l
457:33 - two is also has this, now these are two different
variables, L is this variable, l two is this
457:34 - variable. So you might be thinking l two is
separately a completely a new thing. And Alice
457:35 - new thing, you might be thinking that both
are independent. But Python internally manages
457:36 - the data structures, most of the data structures
in a way that because the data structure is
457:37 - a collection of a lot of data it has it is
consuming a lot of memory, what it does is
457:38 - when you assign a variable, or data structure
to to another variable, it does not actually
457:39 - copy all the contents, it does not actually
make a new memory, and store the contents
457:40 - in this. It actually this variable also actually
points to the same memory as this. and and,
457:41 - and and the consequence of that if you change
any value, for example, in L two, let's say
457:42 - you change the index to value from this, the
index to values 4.9. Now you're working in
457:43 - L two, let's say you change this L to value
from 4.9. To Let's 4.9. Let's see you do that.
457:44 - So you might be thinking that this happens
in L two, well, in L two, that has happened.
457:45 - But what it also does is it does the same
thing in L as well. So l also changes. The
457:46 - reason is L and L two, they both are pointing
to this structure in the memory. And whether
457:47 - you approach that structure through L, or
you approach that structure two l two, you're
457:48 - approaching the same memory anyway. And that
is called referencing I mean, it does not
457:49 - create the data, it actually create a reference
in the memory to actually create a new name
457:50 - for the same memory. And both are pointing
to or accessing to the same memory. And if
457:51 - you really want the behavior so that l two
becomes different than L and what I what I
457:52 - do with L two, that should not affect L, then
you should call copy function. l two is L
457:53 - dot copy. Yeah. So that's the function, I'll
copy. Now you have l two. Now you do whatever
457:54 - with L two, it will not affect L. So l two,
for example, index at index two, you again
457:55 - say okay, this is 4.9. So l two changes. Now,
l two changes, but l doesn't change, l doesn't
457:56 - change, l stays the same. Now this is different
copy, same concept, go with the set. And same
457:57 - concept go with with the dictionary. If you
if you just make another way will s two n
457:58 - equals two s, then if you change the contents
of s two s will change. If you don't want
457:59 - that, then copy it similarly copy the dictionary,
because the contents of the topple they are
458:00 - not changeable. The copy function is not available
for double. Because even if you assign this
458:01 - T to T two, you can now not change D two because
it is immutable. So having a copy function
458:02 - doesn't make sense in tupple. Wait.
458:03 - One more thing regarding slicing. Let's say
you have let's say you have Dell that's available
458:04 - to you like so that's L and let's say you
make l three another list by slicing Let's
458:05 - say a list from let's say one to five, let's
say. So you start from index one, which is
458:06 - three, and you go to five by not including
five, this way, the L three is automatically
458:07 - a copy, it is not a sub list, which is referencing.
So l three. So l three is a different l two
458:08 - is a completely new list, a new memory view,
if you change the contents in L, three, if
458:09 - you change the contents in L three, for example,
l three, or index zero, it should go from
458:10 - three to let's say, three, if you change the
contents in L three, these contents, these
458:11 - change will not reflect an L. So if you do
the slicing, slicing picks a copy by default,
458:12 - it does not pick a reference. And that's a
huge difference between this list and a NumPy
458:13 - array, when you end it, we'll see that when
we will see a NumPy array, the slicing actually
458:14 - also, again refers to the same memory location.
And that might be one difference in indexing,
458:15 - indexing in the whole Python, whenever you
do slicing, you get a copy. But in NumPy,
458:16 - when we'll see NumPy in detail, in NumPy,
when you do slicing, you get again a view
458:17 - not a copy, and if you change in the slice
torian anything the actual the actual contents
458:18 - also changed. And there is a reason to do
that there is a there are efficient reasons
458:19 - to do that and stuff like so, again, the dot
copy function becomes the copy function become
458:20 - much more applicable there as well. So, so,
so you need to know that even if you do if
458:21 - you do slicing in general in Python in any
collection in any array, in any, if you do
458:22 - select a collection for even for mutable objects
like list, you get a copy, but in NumPy array,
458:23 - the things the things these things, this particular
thing with with a lot of other things this
458:24 - but this indexing scheme actually changing,
changes with with this kind of slicing. Okay,
458:25 - so I am this video here, I mean, you can explore
much more functions of lists tupple, seven
458:26 - dictionary and what you can do with each of
them, and what you I mean, in which scenario,
458:27 - what kind of thing is more suitable for the
other that completely depends upon the problem
458:28 - at hand. But what we can do in what what we
will do what we'll be doing in the less next
458:29 - video, we will be seeing some using some functions
of just list. And then I will be just just
458:30 - letting you to explore the the tupple set
and dictionary and all their functions on
458:31 - your own. And to see what function or what
method is doing what for what, which kind
458:32 - of data structure. So in the next video, we
will be seeing some methods just for list
458:33 - data structure. Hope to see you in the next
video. Like in screens. Let's Let's explore
458:34 - a lot of functions in list. Although in, in
in sets and dictionaries and tuples tuples,
458:35 - as well. But many more functions are available
in list. And by the way, let's see how many
458:36 - things are there in this list. And let's say
l dot tab, and tab will open up a lot of things
458:37 - with me for me abanda we know already clear
copy, copy, we know already count, we don't
458:38 - know count, extend, index insert, pop remove
reverse some of these functions. They make
458:39 - sense by the adjuster name. But let's see
one by one. Let's see some of those. What
458:40 - they do. One way to do that is go to internet
and see some book or tutorial or something
458:41 - like So another way is just write this apply.
Maybe, maybe help function maybe apply a help
458:42 - function, it may help you how to use that.
Great this help function is great. So abandoned
458:43 - object method of building list in stance about
an object to end of the list. Oh, it appends
458:44 - an object to the end of the list. Which means
458:45 - we may be able to append another list to to
a list maybe. Have you thought about that.
458:46 - The append method just takes 111 object. Maybe
it takes a whole lot of list. But then it
458:47 - may be possible that a list is appended inside
another list and that whole list becomes becomes
458:48 - one element because list can contain other
lists as elements are that's a problem. Yeah.
458:49 - So let's see more functions. Yeah, so let's
see clear what this clear What is this clear
458:50 - what it does? Sometimes I use help, sometimes
it's used that remove all items from the list,
458:51 - oh my god, if you call the clear that the
list is empty, okay? If you just call clear
458:52 - function on a list will become empty. Be careful.
Okay, great. What else? So that see I have
458:53 - this function maybe, Bob, what does Bob does
watch. So let's see. So Bob removes and returns
458:54 - item at index defaulted the last, which means
if you also that's the default value remember
458:55 - the default value. So, if you call a part
function without an index, it will return
458:56 - it will remove the index it will delete the
last item and it will give you that it will
458:57 - return that are if you give an index, it will
remove that value at that index. And it will
458:58 - after removing it will return you that. So
you can use it wherever you want. So there
458:59 - are many more functions for example, you can
see all of them one by one remove function,
459:00 - for example, reverse reverse, like, like,
like the name suggests, if you call the reverse
459:01 - function, the list will be reversed. Yeah,
and remember, we have reversed the list in
459:02 - the following way as well, we have a way of
reversing any way, this way. So now if you
459:03 - see the list is again reversed. So I guess
both of them are working like so same. Similarly,
459:04 - you can explore several functions from a set,
you go and say add Clear. Clear might be working
459:05 - as same as intersection intersection and update
is destroyed is a subset of the other. Yeah,
459:06 - add by default or update by default, actually
take a union. So I'm not seeing update function.
459:07 - Here it is update. Oh, union is there update
is there, which means the list you're seeing
459:08 - is here is not a complete list you may be
writing, what are the functions that start
459:09 - from you. So here are the and and several
others. Similarly, you can go to dictionary
459:10 - and call for several functions clear copy
from keys get items. That item might be might
459:11 - be interesting. What is this item? what it
does? Oh, it has an error? What? So how can
459:12 - you use this? How can you use this function?
Let's see, oh, this is just an object, it
459:13 - is not a function? I don't know.
459:14 - Let's see again, are it is not listed anywhere?
Oh, it is items not item. Okay, items. That's
459:15 - a function maybe. So these are all the items
23 with this, be with that new key with that,
459:16 - and so on. Great. So actually, the purpose
here is not to tell you each and every function,
459:17 - what it does, it will take a whole lot of
time. You can go and explore all these functions.
459:18 - The purpose here is to tell you what kind
of data structure has, what kind of properties
459:19 - and what are the similarities and differences
in between. So if you remember this one slide,
459:20 - for list, double seven dictionary and some
text that is written out above, you'll be
459:21 - having very good knowledge of where to pick
what kind of data structure in practice. So
459:22 - in the next video, I'll be actually going
to Jupyter Notebook as our as our style and
459:23 - I will be coding or solving some problem for
you that will involve list topple set or dictionary
459:24 - are one of them or we will be choosing based
on problem what kind of data structure is
459:25 - well and what so we'll be doing that. But
before that, I just want to I just want to
459:26 - I just want to mention that list tupple set
or dictionary they can contain any items inside
459:27 - any kind of type, which means a list can contain
another list. A list can contain a set a list
459:28 - can contain a dictionary, a list of dictionary
can contain a list which itself contains a
459:29 - dictionary, I mean, this is all abstract,
this is all abstract, one thing can contain
459:30 - the other one thing can contain an instance
of I mean, a list can contain multiple lists.
459:31 - And those lists can contain more or less and
so on. So before actually going to problem
459:32 - solving, let me give you a flavor of that
how abstract these things are. Let me give
459:33 - you a flavor of that in in just just in a
couple of examples. So in the next video I'll
459:34 - be giving you a couple of examples based on
the abstract mess of these data structures.
459:35 - And from the next next video, we'll be probably,
we will be doing some problem solving based
459:36 - on that. So next two videos are completely
on Jupyter notebooks. So get ready, I hope
459:37 - to see you in the next video. Okay, let's
see the abstractness of all these data structures.
459:38 - Let's see just one example. Let's say we have
l as the list, we have all rich top all that
459:39 - stuff. So let's say we have set that set,
let's say n, we have dictionary, that's a
459:40 - dictionary. Okay? So let's say we have all
these things that say available somewhere.
459:41 - So let's make another dictionary. For example,
let's say D, D, Ma, that's a D tool. And that
459:42 - dictionary has key value pairs less The key
is a and the value is whole list l master
459:43 - value is possible. Let's say the key is B.
and the value is just to topple the whole
459:44 - topple, that's the value. Let's say the key
is C, and the value is the set. And let's
459:45 - say the key is D, and the value is the dictionary,
the whole dictionary D it is possible. I mean,
459:46 - you can just do that, that that is just one
example, oh, what's Oh sorry, I should have
459:47 - I should have incorporated this way. Okay,
so this is possible. Now, for example, if
459:48 - I access, if I access the element with, let's
say, a, I will, I will get the whole list.
459:49 - And not only that, I can again access the
whole element. And then after that, for that
459:50 - element, I can access for example, the third
element, the element at index three. So this
459:51 - particular, this particular first level will
extract the list. And that will in that is
459:52 - just the indexing or for that list. See, for
example, if
459:53 - I access D two, and inside the tool, if I
access the dictionary that is inside, and
459:54 - let's say I save that dictionary in k, then
it I can see the contents of K but I can just
459:55 - for example, this or I can just access all
elements of this dictionary, or k by just
459:56 - having 4x in gay brand, for example, x and
k of x, just do that i can i can just do that
459:57 - we have done that in loops as well. So I want
to tell you that the these even if for example,
459:58 - if you want to create a list l let's say l
three let's say you want to create a list
459:59 - that can contain a whole list that can contain
what will get Oh, I mean one element is the
460:00 - list another element is to pull another element
is the whole dictionary inside and then you
460:01 - have some other elements let's Lee's game
and that's perfectly fine i get i mean you
460:02 - can do that, these data structures are much
more abstract I mean now if you for example,
460:03 - access element at index two which is dictionary,
that is completely a dictionary if you if
460:04 - you check the type of that element that that
will be a dictionary object and you can extract
460:05 - that element and play the way you want to
play and whatever. One more thing if you can,
460:06 - for example lists we can let's say we want
to make a list list very quickly for example
460:07 - list off all the squares till till starting
from zero list of all the squares till till
460:08 - 10 for example zero square one square to square
let's say we want a list of that. So one way
460:09 - of doing that is a quick shortcut is to just
use the loops so in loops, for example, we
460:10 - right okay, x square for x in range. Then
for example, so it will start from zero go
460:11 - till nine, including nine and you will get
x one by one. And all this index is for making
460:12 - a list of x squares where x starts from zero
and go to go to including nine go to nine
460:13 - one by one and that's how you can make a list
and I'm in these kind of these are kind of
460:14 - shortcuts. Again, you can make a sale For
example, let's say you want to make a set
460:15 - of all the squares for x in range, let's say,
starting from starting from two, ending at
460:16 - 20. And you want to take a step of, let's
say three. So, start from index two go till
460:17 - 20 do not include 20, but take the step of
three, and you can now have a set, which is
460:18 - which is this. I mean, there are, there are
a lot of ways of working these working with
460:19 - these. One, one can explore more and more
about these things, but what what what the
460:20 - basic thing about these data structures are,
they are very, very abstract, they can I mean,
460:21 - a list can contain a dictionary, and that
dictionary can contain a topple and that will
460:22 - have an element which is another list and
so on. It is that abstract, it allows you
460:23 - to do each and everything in that way. Okay,
so I end this video here in the next video,
460:24 - we will actually solve a problem using these
one of these data structures or we will try
460:25 - to choose one of those. And that video naby
lengthy may be small, because we may have
460:26 - bugs inside. And we will we will play around
with these data structures in the next video.
460:27 - So do attend the next video because it's really
the practice and you will get your hands you
460:28 - will get a very good grip on the data structures
in the solving the next problem that we are
460:29 - that we are launching for you, okay, hope
to see you in the next video. Okay, let's
460:30 - see a problem just to get comfortable with
these data structures. So let's let's design
460:31 - some problem and solve that problem here using
using these data structures. So the problem
460:32 - that I'm thinking is, let's say the following.
Let's say let's say you are you a teacher,
460:33 - should I type all these things? Okay? Let's
say you're a teacher, you are a teacher. And
460:34 - you have
460:35 - different student records to learn records
containing containing ID of a student and
460:36 - the mark marks list in each subject, where
different students have taken different number
460:37 - of subjects. And all these records all these
records are in hardcopy. You want odd copy,
460:38 - you want to enter all the data in computer
and want to compute the average marks of each
460:39 - student. And display. That's the problem.
So the problem let's say is, you have for
460:40 - example, you have a hardcopy you have you
have some papers, upon which you have different
460:41 - students, each student have a different ID.
Some students may have taken seven subjects,
460:42 - some student may have taken three subjects,
some student may have taken eight subjects
460:43 - and so on different students may have taken
different subjects. Regardless there, you
460:44 - want to first enter each for each student,
you want to first enter the records, I mean
460:45 - all the data that is in and then you want
to compute from that data, you want to compute
460:46 - the average marks of each student. For example,
if a student have taken five subjects, then
460:47 - the marks for all the five subjects are available,
you just add all the marks and divide by five
460:48 - and that's, let's say, the average marks.
So first of all, let's ride away two way to
460:49 - compute for example, the to just collect the
data, how to collect the data. So let's write
460:50 - a function for that. So let's say define a
function, let's say get data From user or
460:51 - teacher, let's say, let's say that function,
and it returns data. Okay? So what I do really
460:52 - is I say, okay, while
460:53 - true,
460:54 - I made a loop while true, just take the data
from the from the user, and the data is in
460:55 - the form of you first say, okay, ID, student
ID, let's say that is inter, or actually input,
460:56 - enter student ID. So he enters the the person
enters the student ID. Yeah. So adopt, you
460:57 - might have define a dictionary, maybe a dictionary
D, that is empty right now. But you may, you
460:58 - may add and remove different values. So what
you do is, you add a student ID, you get a
460:59 - student ID, and in the string form, and then
you get the you get, for example, the input
461:00 - as the marks list. So marks list as input.
Enter the marks,
461:01 - by
461:02 - comma
461:03 - separated values. So enter the marks using
for example, if you have five subjects, just
461:04 - write the five subject marks by separating
each with the comma, okay, then this, let's
461:05 - see
461:06 - more
461:07 - students is equal to let's say input,
461:08 - enter,
461:09 - yes, or no.
461:10 - for
461:11 - adding more students, so if for example, you
have more data to insert, then press Yes,
461:12 - otherwise personnel. So that's, for example,
our setup. So we will keep on getting more
461:13 - and more, we will keep on getting more and
more data from the user user will keep on
461:14 - increasing the data. But one thing that we
must know is that if for example, a student
461:15 - ID, student ID is already in D, if that is
already in D, then we should give a message
461:16 - brand. brand that student ID is already inserted.
So that might be a message else. ls we want
461:17 - to do something else, what we want to do is
the following. What we want to do else is
461:18 - we will make a dictionary, we already have
a dictionary with a student ID as our key,
461:19 - that's our key. And at that key, what we do
is be the pick the marks list, and just split
461:20 - it using comma because you're expecting and
all the marks they will be saved as a list.
461:21 - So that will return a list. List of string
values. These are not indeed values, these
461:22 - are string values. But all these lists they
are tagged by this ID. So that is a dictionary
461:23 - that will be that we'll be getting populated
on and on and on. Further if we check F for
461:24 - example, more students dot lower, for example,
let's call the lower function because the
461:25 - user may interest at a lower form or if that
is equal to let's say no, that is equal to
461:26 - No, if this is the case, or if there is no
enter for example.
461:27 - No
461:28 - inter no inter Know, to quit when insertion,
insertion into node with insertion. So let's
461:29 - say that's your message. So wherever the user
inserted, if that's a no, then you return
461:30 - the and that's it. Otherwise, you keep on
moving. So that's the whole goal. So you keep
461:31 - on asking the, the, you keep on asking more
and more values. If whenever the teacher enters
461:32 - a no, then you just return. Otherwise, you
keep an up, you make another equation, you
461:33 - make another equation and keep on moving.
That's how you get the data. So the data will
461:34 - be available to you. Once you are done with
that, then after that, we will see how to
461:35 - once we have this data collected from the
user, then we will see how to compute marks
461:36 - for each student individually average marks
and so on. So let's just check whether this
461:37 - function works or not. So let's say we have
our dictionary that says student student data
461:38 - is equal to get data from user, let's just
call that function. Let's see what happens.
461:39 - Okay. Enter student ID, let's say ID is 12.
Okay, in remarks by comma separated values,
461:40 - let's say, well, one, let's say
461:41 - 24,
461:42 - comma 65, comma 87, let's say the first two
in just the first tool and just have these
461:43 - three subjects, then internode width, so I
will enter something else. And oh, what's
461:44 - the problem? There is a problem. If more students
taught lower is more student is not defined.
461:45 - More student that's, I guess, more students,
more student here, oh, the spelling mistakes.
461:46 - That's a huge mistake. So I just copy there,
these bugs are there. That's part of life.
461:47 - Part of programming life, actually. So I guess
now it will work. So let's do the process
461:48 - again. So 12, let's say, and the marks are
the six comma 45, comma, let's say a bad subject
461:49 - with let's say, 13. into no to quit. No, I
will intro something else, I will keep on
461:50 - moving. The other student is the student ID
is 45, let's say. And the marks that this
461:51 - student has gained, actually, let's say this
student has, has registered has already registered
461:52 - seven subject or let's say five subjects.
And the marks are, let's say 44 to five, six
461:53 - to 677. And let's see a bad subject, let's
say four. Okay, then internodal, quit. No,
461:54 - I want to insert one more, so do anything
else other than No. So student ID, let's say
461:55 - now the student ID is 12. Again, let's say,
let's say want to insert another ID again.
461:56 - And whatever the marks, let's say 45, and
45. Again, that's a now internode width, no
461:57 - something else. But now, the message is there,
the 12 is already inserted, because the ID
461:58 - the key value index, now you cannot repeat,
and so is the student value. So it does not
461:59 - inserted the because this may be my mistake,
so it asks again. So now let's say I enter
462:00 - ID, let's say 23. That's the ID or maybe a
different ID. That's the ID and the marks
462:01 - are let's say 45, comma, 45. That's it. And
internodal grid. So let's say I enter No.
462:02 - And that's it. So now I have received the
student data, if I show you the student data,
462:03 - that student data is student data. That's
a dictionary, that's a dictionary with the
462:04 - with key 12. And that's a list. But this list
contains all the values that are our string
462:05 - type, we will see how to handle that. That's
a 45 as a key value, that's ID and that's
462:06 - the marks list. And that's the ID in that
small list. Okay, great. Now we have student
462:07 - data. Let's write another function that helps
us working on the student data, basically,
462:08 - we want to find out the average marks of each
student. And then we want to print those.
462:09 - So let's define another function and get average
marks of each student. And that function actually
462:10 - receives this dictionary, let me call it as
D, any any variable, that's a local variable.
462:11 - Okay, so what we want to do with that is the
following. Average marks for each student's,
462:12 - so we will define another dictionary, let's
see everage marks dictionary, let's say that
462:13 - is empty in the beginning, maybe, and then
what we do for x in D, let's icreate over
462:14 - x and d, what we really do is we go to the
we find out the list of located at ELLs are
462:15 - located at x L is basically D sub x. So that's
it, that's our list. That's our list that
462:16 - is located there. So then what we do for i
in L. So for all i that is an L or let me
462:17 - call it for marks, marks in L. In this particular
list, what you do is you actually have this
462:18 - sum of sum is equal to zero right now,
462:19 - there is no marks. So what you do is s plus
equals two marks, but convert the marks to
462:20 - integer because they are already in string
format. We have we have saved everything instinct
462:21 - string format, so you populate all the list.
Once you are done with this loop, the S will
462:22 - contain the sum of all the marks, then what
you do is you compute the average and just
462:23 - save that average in ABG. Marks decked dictionary,
let's say on average marks, just just don't
462:24 - use the word deck, for example, you can but
let's stay gradual and add x, you just write
462:25 - the average marks. And the average marks can
can be computed by s divided by length of
462:26 - the list, whatever the list is. So that's
what the list is. Yeah, so that's the average
462:27 - marks. And once you have an N one by one,
all the average marks will be populated. And
462:28 - once we receive all these, we will then begin
then we can then just display by populating
462:29 - the average marks. So let's see, let's call
that function. So let's call that function.
462:30 - So ABG marks for example, equals to get a
VG marks, and let's bond these student data
462:31 - inside. And if there is no error, then it
will return everything. Then just print the
462:32 - average marks for each student for x in a
Vgm. brand, let's say student and Brand X
462:33 - God average marks as then you just Brandt
okay ABG m of x, x, and that will display
462:34 - everything Oh, if there is an error, non type
object is not equipped. I prefer nine type
462:35 - object why non time object? We have done some
mistake. Yes. Maybe. Let's see. Let's see,
462:36 - for example, when we run this, so let's run
this and create a cell Let's run using alt
462:37 - Enter to create a cell everage m What is that
thing? Oh, that's nothing. Why oh, we haven't
462:38 - returned anything. That's a bad programming.
Really bad programming. We have not returned
462:39 - actually. The the value that we need. So the
default value is none. raid actually not so
462:40 - great. Okay, great. You have this and now
we have something in Emirates marks. Yes,
462:41 - this is and now we can just populate that
and we have this student 12 got average marks
462:42 - 38 student 45 core average marks 90 49.2 and
student 20 He got average marks as 45.0 Okay,
462:43 - great. So that was just a review of split
function of string, type and marine through
462:44 - int, and functions in general input function,
and, and dictionary and list and all that
462:45 - stuff. So although it was a just a tiny problem,
but it gives a good flavor of the data structures
462:46 - and strings and all that stuff. Okay, that's
about the data structures. From the next video,
462:47 - we are actually diving into the data science
packages. And we will start from NumPy and
462:48 - we will spend some time on NumPy and then
we will be moving towards pandas, which is
462:49 - very, very powerful built on top of NumPy
and after that, we'll be moving towards matplotlib
462:50 - and we will also try to give you some snapshots
of psychic learn as well. So hope to see you
462:51 - in the next video. Okay, the next few videos
will I will discuss NumPy which is the which
462:52 - is the very very popular package for numerical
Python. Actually NumPy is like list but it
462:53 - is much much faster than list.
462:54 - One one restriction if we restrict the list
of Remember, a list actually is a collection
462:55 - of a lot of data objects. That was so abstract,
as we saw in previous videos, if for example,
462:56 - we restrict a list that all the objects they
must have same type all elements in the list
462:57 - for example, they have same type then that
list with all the same type, there is what
462:58 - the NumPy looks like, but NumPy is very, very
more faster. And the reason is, even if you
462:59 - define a list with all the elements that are
let's say of same type Yeah, but because list
463:00 - in abstract way can handle heterogeneous kind
of objects, the functions that we will apply
463:01 - on these items, they will no longer be faster
further to store each element we have to store
463:02 - that information or metadata for that element
in NumPy, it is both I mean, it is efficient
463:03 - with respect to memory, because if the type
is saying we need not to save information
463:04 - about each element, because we need just to
save the information about the type because
463:05 - the type is same for all elements further
when the type is same, we can write functions
463:06 - that are much more faster than then then a
list. So NumPy is very, very popular, it has
463:07 - very very fast universal functions available
the methods that are available in NumPy. And
463:08 - it's a package i mean it's it's a whole directory
structure containing a lot of packages inside
463:09 - a lot of modules and so much at the end of
the day, it's it's it's simply or in laymen
463:10 - terms, it is like a list with all the same
type objects and it is much more useful when
463:11 - all these objects are numeric type, although
you can have a NumPy array with with spring
463:12 - data types, I mean all the strings are all
general objects as well, but the the most
463:13 - the power mill the power of NumPy array will
be will become much more evident when we will
463:14 - be working on numeric type data. So in this
particular in this particular course we will
463:15 - focus more on numeric data then other kind
of data. So that's how you you write import
463:16 - NumPy is installed or if you if you have installed
Python using Anaconda NumPy is already installed
463:17 - there it is in the side packages kind of a
built in package. So import NumPy we can stay
463:18 - as it is but we can rename this NumPy just
NP that's most popular name, we can write
463:19 - any other name but if you see the books or
internet or somewhere this NP somehow becomes
463:20 - much more popular. Okay. Now we can define
an array for example NP dot array that array
463:21 - is just a method of NP kind of function. And
we can define an array using list this is
463:22 - the list of several numbers or we can define
array as as a topple as well. So whether we
463:23 - give a topple whether we give a list an array
is defined and then we can see the contents
463:24 - of this array, this NP array so let let's
just go to our friend Jupyter Notebook and
463:25 - get our hand Well dripped on, on this NumPy.
So first of all, we need to import NumPy package.
463:26 - And we may rename as for future use as NP.
So let's say that is imported. So now let's
463:27 - say a is an array, let's say NP dot array,
that's a function and we may have a list and
463:28 - say, let's say 12357. Let's say that that's
right, we can also define the array using
463:29 - a topple rather than a list, it's our choice.
Which way we define the array either way.
463:30 - 235 Let's, that's, that's another array for
example. So if we print for example, a it
463:31 - will give us a but if we just see the type
of a it will no longer be list it will be
463:32 - an ND array numpy.md array that n dimensional
array, okay, great. So, there are so many
463:33 - attributes of this a and this B. Same. Similarly,
if you see the type of B although we have
463:34 - defined this be using the tupple. But the
type is the same the it's a NumPy object rather
463:35 - than a list or a topple.
463:36 - So that's how you can create the the array
1111 more thing that is that is important
463:37 - is to check the attributes of a for example,
k dot d type, that will tell us the data type
463:38 - in a so for example, a stores all the data
that is integer 32. At defined time, for example,
463:39 - we can we can specify the data type if we
want we can specify the type if we want. For
463:40 - example, in teacher that means as in teacher
here, we can here we can define, for example,
463:41 - the type as float, for example, so data type
becomes float. There are several other other
463:42 - options that are available to define the data
type but, but even if we don't define the
463:43 - data type can be defined automatically based
on contents. That's what the dynamic typing
463:44 - means. So if we now define type that is, if
we, if we now check the type of a that is,
463:45 - again in digit 32, but if you check the type
of be the type that that might be a float
463:46 - number, yes, that's float 32. Again, there
are 64 bit support as well, I mean, we can
463:47 - define here there are several options here
available. So that's the that's how we can
463:48 - define the NumPy array that's just getting
started with NumPy array. In the next video,
463:49 - we will play with these arrays a bit more.
So hope to see you in the next video. Okay,
463:50 - in the last video, I introduced NumPy. And
we actually declared a NumPy array using a
463:51 - list as well as a topple. In this particular
video, we will be seeing some of the properties
463:52 - of the NumPy array variable or sometimes called
the object that variable there are several
463:53 - properties, but I will discuss for example,
last time I discussed one property which is
463:54 - d type a dot d type, and that store actually
the that actually stores the information of
463:55 - the data type of the elements of the array
of NP array, remember NP array, all elements
463:56 - of NP array they must have same data type
it cannot store heterogeneous arrays as it
463:57 - is. Okay. Now, there is another property sometimes
called the dimensions are n them. That tells
463:58 - actually, what are the dimensions of of the
array, I need to explain this term dimensions
463:59 - with the following example. Let's say for
example, that's, that's that's an array just
464:00 - consider that a list for example, 123, that's
one list. And if it is if it is an array,
464:01 - for example, if np.if this is NP dot array.
With that list, we will say that array as
464:02 - a one dimensional array, because we only need
one index to access that. For example, if
464:03 - you need to access any element in this array,
you only need one index either 01 or two,
464:04 - only one index, that's okay. So in this case,
we have just one dimensional array. On the
464:05 - other hand, for example, if you see here,
that's one array or one list, that's another
464:06 - array, another list. And that's another list
that contains lists inside for example. Let's
464:07 - say that array one, and that's array two.
And that is simply an array of two different
464:08 - arrays. That's, that's an array and that's
an array. For example, a One is this array
464:09 - and a two is this array. Now if we need to
access any element in this particular array,
464:10 - we need two indices. First of all, we have
to locate whether we are going to talk about
464:11 - a one or a two, we need one index for that,
for example, if we want to locate a one, that
464:12 - means we are going to access with elements
zero, let's say this, this whole array is
464:13 - a So first of all, we say okay, zero means
we are going to access from from a one and
464:14 - a to one of those. So zero means the first
one, okay, now a one. Now inside a one which
464:15 - element, this is the zeroeth element, this
is the first element, this is a second element,
464:16 - let's say we want to access the first element.
So that means we are going to talk about we
464:17 - are talking about this. So very loosely speaking,
the total number of indices that are required
464:18 - to access an element inside the array is called
dimension of the array. And m them that actually,
464:19 - that actually defines that that actually describes
the this property, the total number of dimensions.
464:20 - Consider, for example, this is a 2d array
or two dimensional array, let's head out to
464:21 - two dimensional array A one, and let that's
another two dimensional array a two, that's
464:22 - another two dimensional array, a three, for
example, and let's say this is an array of
464:23 - two dimensional arrays, let's say NP dot array.
Now, that's that whole array, whatever that
464:24 - array is a three dimensional array. And the
reason is to access any element, we need three
464:25 - indices. First index will define which one
of these we are selecting, for example, let's
464:26 - say you're selecting that. So one index is
needed that index is one for example, then
464:27 - inside this structure like so, we need two
more indices to locate a particular particular
464:28 - index. For example, because it is a two dimensional
array, it has two one dimensional array, so
464:29 - which one dimensional array you are, it has
more, it has many one dimensional arrays,
464:30 - so which one dimensional array you want to
pick, let's say the sixth one will index with
464:31 - index five, now you have located the fifth
or sixth array. Now in that array, what element
464:32 - let's say the eighth element. So we need three
indices to access a particular element. So
464:33 - the dimensions of this array is three. So
let's play with that in Jupyter, notebook
464:34 - just to get more comfortable with with the
term dimensions. So let's say for example,
464:35 - we have an array, let's say a is NP dot array.
And let's say it contains a list, let's say
464:36 - 123. And then we have another array, one dimensional
array, let's say four, five, and six, that's
464:37 - another array. And that is an array of these
two arrays. So that is basically a two dimensional
464:38 - array. It is array of arrays. list of lists,
equal entries. So that's a for example, oh,
464:39 - what's the problem? Oh, we haven't imported
NumPy, we should have. So import, import NumPy
464:40 - as NP? Okay, we need not to import that every
time. Actually, I'm recording this video after
464:41 - a few after a few hours. And I'm really I
have restarted all these things. So I have
464:42 - to import now for the first time. But once
imported in the notebook, as long as a notebook
464:43 - is running, you need not re import anything.
Okay, so a DOD for example, and then Iraq
464:44 - and them. So that is to hear because there
are two dimensions. For example, if I want
464:45 - to access element number three, this element,
so this element is located in the first array
464:46 - of the two arrays, which has so the first
array, there are two arrays with index zero
464:47 - or one. So I am going to look into the first
array, which is 123. And in that array, I'm
464:48 - going to look for the element number two element
with index two. So that's how you can access
464:49 - the elements of multi dimensional arrays are
arrays with more, more kind of dimensions.
464:50 - Let's say we have another array just to just
to get more familiar with NP array, let's
464:51 - say, and we have a list. And that list actually
contains that list actually contains three
464:52 - one dimensional arrays. Not only that, actually
Oh, I'm confusing you a lot. Let me know Let
464:53 - me just, let's say we have 123. Let's say
we have three one dimensional arrays. Let's
464:54 - say we have another 2459. The the sizes of
arrays, maybe, maybe, maybe, I mean, maybe
464:55 - different. Yeah. Is that true? maybe different?
Yes or no? Let's see, for example, the first
464:56 - array has size three, and the second array
has total size. Does that okay? I guess, yes.
464:57 - And now if we want to access, for example,
an element of an element with a, let's say,
464:58 - I want to access this element five, so that
is in the secondary index with one, and then
464:59 - in that array, it has index two. So I've accessed
this element, oh, we're not too many indices
465:00 - for an array. Why?
465:01 - Why is that? Why too many indices, for for
an array, B selects a B dot n dems. And then
465:02 - that is one y one dimensional, I have to,
I have this one dimensional array. And this
465:03 - is another one dimensional array. And I have
made a list out of it. I'm in this is 1d array
465:04 - and another 1d array of concatenate them together,
so I shouldn't have accessed this element.
465:05 - The problem is when you are going to define
multi dimensional arrays, the the number of
465:06 - elements for each dimension, they should stay
consistent. For example, if the first array
465:07 - has three elements, the second array must
have three elements, or if the secondary has
465:08 - four elements, and the first must have four
elements. If that is not the case, the array
465:09 - will not be defined like a multi dimensional
array. For example, if we, for example, extend
465:10 - our first array with let's say, minus one.
Now, B will be having two dimensions, no problem.
465:11 - And now we will be able to access for example,
this element five, like so. So we will go
465:12 - to B again, we will see okay, select array
number two, and in that array, select index,
465:13 - select the value indexed by two, which is
five. So accessed no problem. And that stays
465:14 - true if you if you're going to define for
example, a three dimensional array, let me
465:15 - just give you an example of three dimensional
array that's a C equals NP dot array. And
465:16 - let's say we have one, two and three. And
then we have another array, for example. 456,
465:17 - remember or so let's say that, that we can
have one more for example, we can have one
465:18 - more list, why not? So let's say we have a
00 minus one, let's say, and that is what
465:19 - that is. That is a two dimensional array.
That's a two dimensional array. Great. Let's
465:20 - say we have another two dimensional array.
Let's say we have another two dimensional
465:21 - array with same kind of consistency, the number
of elements and stuff. Let's say these elements
465:22 - are our minus of the, the other ones, let's
say there's minus, minus, minus and this is
465:23 - plus one. And now we have this, if you see
this thing, that's a 2d array. That's a two
465:24 - dimensional array, that is also a two dimensional
array. An array of two dimensional arrays
465:25 - is basically a three dimensional array. Now,
that's a three dimensional array. This one,
465:26 - C, so if you Oh, we have some, Oh, I should
have defined this with commas. Rather than
465:27 - rather than spaces. Actually. Yeah. The reason
I did that is MATLAB. I worked in MATLAB also.
465:28 - So MATLAB allows this space separated list,
but I just confuse the things with with Python
465:29 - as well. But Python requires comma, they're
okay. With MATLAB. By the way, just as a side
465:30 - note, MATLAB allows you to have commas as
well as spaces, but this Python is just restricts
465:31 - everything to comma. That's great. Okay, that
is C. So now, if you check c dot n them that
465:32 - is three, if you for example, want to access
this particular element, what should you do?
465:33 - First of all, you select the, the one of the
2d arrays, there are two 2d arrays. So this
465:34 - is the first 2d array and that's the second
2d array. And if you For example, want to
465:35 - access this particular element, this particular
element, which is minus three, if you want
465:36 - to access that, you first have to access one
of the two 2d, two dimensional arrays.
465:37 - So let's access the second one with the index
one. Now you are in this particular 2d array
465:38 - in that array with list which 1d array you're
talking about. So I'm talking about the very
465:39 - first 1d array, so the very first 1d array
is indexed by zero, and in that one D array,
465:40 - which element you are talking about. So I'm
talking about this element that has index
465:41 - two in this particular array. So now, if you
press enter, you will get minus three Wow.
465:42 - So that is basically how and by the way, you
can make a four dimensional array, a four
465:43 - dimensional array will be an array of three
dimensional arrays, and so on, you can make,
465:44 - you can make, for example, n dimensional arrays,
and that's one reason why we call this as
465:45 - nd array, n dimensional array, not the type
of C's nd array n dimensional array, you can
465:46 - add as many dimensions as you want. Great,
we will continue exploring this NumPy more
465:47 - and more in in the upcoming videos in particular,
I will talk about this shape property of this
465:48 - NumPy we have already discussed D type we
have discussed and then in the next video,
465:49 - we will talk about shape and we will discuss
more about about NumPy. So hope to see you
465:50 - in the next video. Okay, in the last video,
we discussed this number of dimensions or
465:51 - ending property of any any NumPy array. And
we also saw an example of defining a three
465:52 - dimensional array in Jupyter. notebook. Let
let's discuss another property which is which
465:53 - is the shape property. Let's see what what
this shape actually represents. So let's go
465:54 - to Jupyter Notebook and see what actually
this shape represents. For example, you have
465:55 - seen this C as in the last video, we define
the C as a three dimensional array that contains
465:56 - two arrays of 2d. And each 2d array contains
three 1d arrays, and each 1d array contains
465:57 - three elements. So what do we mean by shape?
So if we just say shape? What is that thing?
465:58 - So shape is 233. And let me tell you what
that means. The return is tuple. So that's
465:59 - a tuple. That is returned to three and three.
This two means how many two dimensional arrays
466:00 - are there? Here we have two. So in each two
dimensional array, how many 1d arrays are
466:01 - there? Well, three in each one, the array?
How many elements are there? Well, three.
466:02 - So basically, this C dot shape, zero, tells
you the total number of two dimensional arrays,
466:03 - that is too. And this shape. For example.
One tells you in each 2d array, how many 1d
466:04 - arrays are there, these many? And this shape,
for example, to tells you in each one the
466:05 - array, how many elements are there? Well,
three grade? That's awesome. Yeah. Can I tell
466:06 - you 111 screens kind of thing? You can you
can define a NumPy array, for example, a as
466:07 - NP dot array with just one element, let's
say two. That's an array raid. What's the
466:08 - number of dimensions here? What do you think?
What is that? Is that a 1d array? What are
466:09 - the number of dimensions? Strange? It's a
1d array. Yeah, it is. see another thing?
466:10 - For example, b is equal to NP dot array. And
you define it with let's say three. And what
466:11 - are the dimensions of B, it looks like the
same, the dimension of B should be one as
466:12 - as their the dimension of A is one, it looks
like the dimension of B is also one. No, it's
466:13 - zero. Because that's an array. If you pass
it as as a list. It's an array of one D if
466:14 - you just define just one number that can be
defined as an array NumPy allows you that
466:15 - but that one number is just as a yo D array.
Now if you can get in it, a lot of zero days,
466:16 - you get one day if you concatenate the last
one days, you get a duty. If you're getting
466:17 - a lot of duties, you get a 3d and so on. Get
a look and feel Yeah. So that's what it is.
466:18 - So yes, In this video, I discuss the shape
there is another There is there are so many
466:19 - properties, let me let me discuss some properties,
let's size that actually tells the total number
466:20 - of elements complete total number of elements
in the array. So, how many elements are there
466:21 - that is size. There is also I guess m bikes
property, that tells the how many total number
466:22 - of bytes that the destructor is taking inside
the memory. And there are several other I
466:23 - mean properties, if you just apply a tab and
get certain things, you will see a lot of
466:24 - functions. And you can you can check a lot
of properties that some of these functions
466:25 - we will explore later on. Sometimes they are
called the universal functions, we will see
466:26 - them because they are very, very fast. And
these functions the vectorized implementation
466:27 - of these functions. That is the reason why
NumPy is so so fast, and why it is so popular.
466:28 - Anyways, so in the next video, we will go
to explore the NumPy a bit more. And we'll
466:29 - show you more fun stuff with the NumPy. So
hope to see you in the next video. NumPy actually
466:30 - provides a lot of functions to create arrays,
special kinds of arrays just for testing.
466:31 - And sometimes just for. I mean, there are
a lot of ways to create arrays from scratch,
466:32 - for example, what if you want to create an
array containing all zeros, so there is a
466:33 - function in NumPy NP dot zeros that tells
you how to do that. Similarly, if you want
466:34 - to generate a lot of generate an array containing
a lot of ones or all ones, there is a function
466:35 - to do that and stuff like so, there are some
functions that are actually used a lot and
466:36 - I want to discuss those. One function is NP
dot arrange, actually, this is a single R,
466:37 - this is not a two Rs, this is single r NP
dot arrangement, one R and NP dot arranged
466:38 - function, what it does is it creates an array
for example, if you say NP dot arrange, it
466:39 - creates an array for example, if you say okay,
100. So it creates an array that it creates
466:40 - a 1d array that starts from the the values
in that array starts from 012, all up to 99.
466:41 - So that's an array. That's a quick way to
create an array with all the numbers till
466:42 - 100. Yeah, so let's see, let's see running
example of this NP arrange method in Jupyter
466:43 - Notebook just to get a better look and feel
of how it works. So let's see. So let's say
466:44 - we have a equals NP dot arrange. And let's
see 100. So that's it. If you want to see
466:45 - what is inside a, you can see this is an array
with all the values starting from zero up
466:46 - to 99. Maybe you want to create an array that
starts from a particular number ends at a
466:47 - particular number. Maybe those two numbers
are different. And maybe this arrange function
466:48 - actually allows that. Let's say I want to
start with 20. And I want to end at 100. And
466:49 - I want to create all the array that does that.
So let's say this. So that's okay, start from
466:50 - 20 and 100. But the last element last index
is not included. That's possible. Last but
466:51 - not the least, if you want for example, to
start from 20 and add 100. And let's say you
466:52 - want to take a jump of three. That's possible.
Remember, does this does this resemble with
466:53 - something that you know already? Remember
that? Yeah, let me pause for a minute, but
466:54 - not for a minute, just for some seconds. Let
me pause. Do you remember this arrange NP
466:55 - dot brains function? It looks like something
like what? Remember that for i in range? Yes.
466:56 - for i in range, for example, start from 20.
Go 200. Take example three. Remember that?
466:57 - So it has some resemblance with range function?
Yeah. Although range is an arbitrator.
466:58 - What's an arbitrator? why I'm telling you
that? Okay, let me tell you an arbitrator
466:59 - as well here, just just just just spend a
few seconds on on this range function. You,
467:00 - you might be thinking when we call this range,
let's say starting from, let's say range them,
467:01 - you might be thinking that it returns a list
of numbers, starting from zero to nine, but
467:02 - that doesn't happen. It returns nothing. Actually,
when you actually call it when you actually
467:03 - call it it returns just an object. When you
call it in a for loop or somewhere. It progressively
467:04 - do. rounds one by one element one by one.
So it returns an element, then it hydrates
467:05 - and return another element that it never creates
a list of elements, it now creates a list
467:06 - for you. That's awesome. Actually, it generates
numbers, it generates the next number and
467:07 - the next number as you move on. So it saves
a lot of memory and these kind of objects,
467:08 - they are called I craters that I played, they
they never played. But if you want, for example,
467:09 - to get a list, if you really want to get a
list, then what you can do is you can call
467:10 - the range, let's say in the same way, and
you can just write a list. So provide me a
467:11 - list don't just provide me an ID. And that
will give you a list. How cool is that? Right?
467:12 - Anyways, that was just a side note. It has
nothing to do with this arrange function anyways.
467:13 - So NP dot arrange, it actually returns an
array does not it is not like an iterator,
467:14 - it returns an array, complete array the way
you want. So that's what this arrange is it
467:15 - has resemblance with this built in range function
that mostly used in in for loops. Okay. Next,
467:16 - let's discuss this NP dot random dot permutation
NP dot random is a package. And P is a package,
467:17 - it has a lot of sub packages inside random
as a package. Random has a lot of modules
467:18 - one module is permutation. There are a lot
of other modules. So let's see this random.
467:19 - Let's see what it does. So for example, let's
say a equals NP dot random dot, permutation,
467:20 - let's say permutation. And what I do is I
say okay, np dot arrange, let's see 10 what
467:21 - it does is, this NP dot arrange will return
an array containing all the values zero to
467:22 - nine, these are 10 values, and then this permutation
function that resides in the package and P
467:23 - dot random that is in the random packet of
MP, it actually shuffles all the values and
467:24 - rearrange all the values in random fashion.
And he will now be an array containing the
467:25 - same elements, but in a different order in
a different random order. So let me know print
467:26 - this a, it will be having all the elements
from zero to nine bought in a really shuffled
467:27 - away. And that shuffling is completely random.
Yeah, you see that? Sometimes you may you
467:28 - may call some function, you may want to write
some function on arrays. And you may want
467:29 - arrays that are that that do not have a particular
ordering, there are just random arrays, just
467:30 - to test your code just to test how it works
on any kind of array. In that case, one way
467:31 - of getting shuffled kind of array. One quick
way is to just use NP dot random dot permutation
467:32 - function. The NP dot random package does not
only have this permutation, there are a lot
467:33 - of other functions and be random, for example,
np dot random random dot Rand int, for example,
467:34 - Rand int, that creates a random integer. That's,
for example, if I that's that, let me call
467:35 - this and we have, how can it be used? Okay,
you can give a low value from the very start,
467:36 - we can give a high value, I mean, and it creates
actually, random integers starting from low
467:37 - ending at high. So that's how it can be used.
For example, let me call it as NP dot random
467:38 - dot Rand int, create a random number between
20 and 30, create some random integer, and
467:39 - it will return some random integer between
20 and 30. If we call it again, it may return
467:40 - some other is it is returning 30 again, 29.
Again, and again. Now two turns 2932. Maybe
467:41 - we want to maybe want to generate random integer
between 20 and 30. So it creates a random
467:42 - integer. One thing that you might be noticing
what is the what is the return value? the
467:43 - return value? Is we for example, what should
be the type of E or do you think? Is this
467:44 - V is an array? No, it is a number. It's an
integer, the type of VA should be an integer
467:45 - because it is returning a random integer it
is returning an integer but it is selecting
467:46 - that integer randomly from 20 to 300. So it
should be integer and it is Yes. Wow.
467:47 - Yeah,
467:48 - so we will be exploring some more functions
in the random package of NP and then we will
467:49 - be moving towards this fascinating function
score function called V shape. So there is
467:50 - more to come for NumPy so hope to see you
in the next video. Okay in the last video
467:51 - we saw a range function that's a very useful
function to just create a test testing array
467:52 - and just see see the output of a particular
operation or algorithm, just on different
467:53 - kinds of arrays. Further we saw permutation
functions permutation function in NP dot random
467:54 - package. And we saw that this this permutation
function, actually, it reshuffles, it shuffles
467:55 - different kinds of odd if if array is applied
to this permutation function, it actually
467:56 - shuffles all the, all the elements of that
array in a random way in a completely random
467:57 - way. Today, we will explore this random package
a bit more, and then we will see a reshape
467:58 - function, but that reshape does basically
this reshape, for example, if you have an
467:59 - array, let's say, array, is let's say we have
an array with, let's say, 10 elements, and
468:00 - if we call a dot reshape, and we give, let's
say, two by five, so it will make a two dimensional
468:01 - array out of a, which is B, and that will
be a two by five matrix R, that will be an
468:02 - array, or a matrix with two rows and five
columns. And now we can, we can just work
468:03 - with this B, just like it's a two dimensional
array, and we can just, we can just treat
468:04 - this B as a two dimensional array and work
with that. It is it becomes handy sometimes
468:05 - if for example, we want to, we want to test
certain operations on on matrices. A quick
468:06 - way to make a matrix is just to call arrange
function, and then whatever the result is
468:07 - just reshape it into the desired order matrix
and test the algorithm. So let's go to the
468:08 - let's go to Jupyter Notebook and check this
random package a bit more and then see the
468:09 - reshape function. So let's go to Jupyter.
notebook. Yes, so there are a lot of ways
468:10 - to generate these random numbers. One for
example, we already have seen Rand int. And
468:11 - other way for example, array, an array can
be generated, like MP dot random dot RAND
468:12 - function. So now, if we create this, if we
create, let's if we pass let's say 1000, random
468:13 - value array will be generated in a and a each
value of a will be a random number between
468:14 - between zero and one. So all these numbers
are just random between zero and one each
468:15 - number is zero and one random number. And,
and this distribution basically is the distribution
468:16 - of this random number is all the distribution
is uniform. If for example, you want to plot
468:17 - the histogram, the histogram or the distribution
of a it will look like uniform. Let me just
468:18 - give you give you one or two plots, using
matplotlib package, although we will see matplotlib
468:19 - package later on. But let's assume that this
is just a plotting package. This is just a
468:20 - package that helps us plotting just import
that import mat plot lib.pi plot as PLT import
468:21 - that. And after importing that, you just plot
a histogram PLT dot hist, for example, and
468:22 - pass a and you can see the histogram is roughly
uniform. I mean, everything is equally likely
468:23 - we can make more bands, for example, we can
have bands, equals let's say 100. And we can
468:24 - see almost all events they are I mean just
look like uniform. If we make more and more
468:25 - data set, then they will all look uniform.
One more thing we can we can have, for example
468:26 - this. And let's say B equals NP dot random
dot Rand n, and that generates normal random
468:27 - numbers, or Gaussian random numbers, let's
say which which the distribution of the numbers
468:28 - are is the bell shaped curve, for example,
so let's just PLT dot haste B. And then let's
468:29 - say equal to 200. And we can see a bell shaped
curve because the distribution of this data
468:30 - is is Gaussian distribution looks like so.
So this this random packages, this NP dot
468:31 - random is really important package. It has
different, it can create different kinds of
468:32 - random numbers from following from different
distributions and doing in machine learning
468:33 - or in statistics, sometimes we need to generate
these kinds of random numbers for sometimes
468:34 - for testing purposes, sometimes for adding
noise of a particular type to test our model
468:35 - and stuff like so. So it's good to have a
good grip on NP dot random package. Okay.
468:36 - Next we see reshape function. One more thing.
For example, if you want to create, for example,
468:37 - a two dimensional array of just random numbers,
let's say you can call NP NP dot random dot
468:38 - Rand. And you can just call a, you can just
pass two arguments, for example, two by three,
468:39 - and the C will be a two by three matrix. If
you see the C, it will be a two by three matrix
468:40 - of four random values. If you see c dot, and
then it will be having the dimensions are
468:41 - two. And it's a two dimensional array. Further,
we can create, for example, a four dimensional
468:42 - array c equals NP dot random dot Rand, maybe
two by three by four by two. And that's a
468:43 - four dimensional array with this particular
order. So if you see this C dot m, then that
468:44 - will be level b, this. Yeah, so let me let
me just give you an interpretation of what
468:45 - that thing is. There are two arrays that are
three dimensional. And there are two of those.
468:46 - Okay? Now, each three dimensional array has
three two dimensional arrays. Wow.
468:47 - So each
468:48 - two dimensional array has four one dimensional
arrays, and each one dimensional array has
468:49 - two elements in it. So that's what the structure
is. Yeah, get a good look and feel. So let's
468:50 - see the reshape function. For example, let's
say we have d equals NP dot range. Let's say
468:51 - we have 100 values. And then we say reshape
these 100 values to let's say, let's say four
468:52 - by 25. So this D will be a four by 25 matrix.
So if we just get the shape of D, so that
468:53 - will be a four by 25 matrix or a two dimensional
array with four rows and 25 columns. Yeah,
468:54 - so sometimes we want to work on matrices,
and we just, we can just plug in these arrays
468:55 - function to generate a bunch of numbers. And
then we can reshape those and build a matrix
468:56 - quickly, and then just test the performance
of our algorithm or stuff like so. So, not
468:57 - only the reship not only returns the, the
I mean, you can you can reshape a matrix,
468:58 - and you can reshape an array into more than
two dimensional array if you want to, for
468:59 - example, arrange 100, let's say dot reshape,
maybe or as four by five by five, it's a three
469:00 - dimensional array. Now, this D will be a three
dimensional array containing different values.
469:01 - Yeah, so now you can access it and do whatever
you want to do. So not only the reshape, arrange
469:02 - and permit random, there are other functions
as well NP dot zeros. For example, if you
469:03 - press z, and you just see the zeros, and then
you just press the question mark, you will
469:04 - know what that function is how can we use
it and so on. Similarly, you can have several
469:05 - other function there is an important function
once for example, you can call that function,
469:06 - and that will generate an array of all ones,
you can see how to call that function here.
469:07 - There is NP dot empty, there is NP dot empty,
like there are so many functions just to create
469:08 - some matrices very quickly. And you want to
test your core algorithms based on those.
469:09 - So yeah, so there are a lot of functions that
we want to that we can work on. So next, so
469:10 - there are a lot of functions that can quickly
create a NP array and an n dimensional array.
469:11 - That we can quickly create an array test or
algorithm or use the array wherever we want
469:12 - to like we're everyone to use. And we can
move on just a few functions like arranged
469:13 - ones zeros, they are there are random dot
Rand random dot Rand n, and other functions
469:14 - they are available. For In the next video
we will be seeing we will be seeing the indexing
469:15 - or slicing inside NumPy array and we will
also be seeing the difference of that indexing
469:16 - with or slicing from the array In the list
or or are the ordinary data structures? What
469:17 - is the difference in? What is the difference
of slicing in NumPy? with for example, with
469:18 - the list, we will see that in the in the next
video, hope to see you in the next video.
469:19 - Okay?
469:20 - Here is my favorite topic in NumPy slicing.
Actually, indexing or slicing in NumPy is
469:21 - the way you access sub arrays is just the
same as the way you access sub strings or
469:22 - sub lists. And you already have seen, how
can we how can we use the slicing or indexing
469:23 - in lists and in strings, the difference here
in NumPy is in list for example, if you slice
469:24 - you get, for example, let's say B equals a
one colon five, if you slice that thing, from
469:25 - NumPy, then B is not a copy, it is actually
accessing the same memory view as an A. Now,
469:26 - if you change any element in B, the corresponding
element in a will change as long as as a NumPy
469:27 - array. However, if A is a list or any other
data structure, ordinary data structure, then
469:28 - the slicing this, this kind of slice gives
a copy rather than a view. So that's an important
469:29 - difference, we need to know that rest of the
indexing technique is almost the same. You
469:30 - do this kind of indexing that is how you can
reverse this a start and step all all the
469:31 - things are same, except How can play How can
we play with the two dimensional arrays. Let's
469:32 - let let's see that. Let's see some examples
of indexing one by one in in Jupyter Notebook
469:33 - and see how the slicing actually creates a
view rather than a copy. So let's go to our
469:34 - Jupyter Notebook and see how can we play with
different indices, let's say a is NP dot arrange,
469:35 - and B dot arranged, let's say 100. And let's
shuffle them. Let's say as it is, let's say
469:36 - that's a now a, let's say, let's bring some
certain things. Let's A B equals a big all
469:37 - the elements starting from index three, ending
at index nine, Sudan is not included. That's
469:38 - B, that's blank v. Let's see what's B. So
b is this array. Okay? Now what I'm going
469:39 - to do is I'm just changing the contents of
b, this NumPy array is mutable, you can change
469:40 - the elements inside, no problem. So I'm going
to change the elements, let's say one element
469:41 - in B, let's say, I'm going to change element
numbers zero, and B, which is three, and I'm
469:42 - just placing that element as minus 100 minus
1200. That's it. That's the case. Okay, now
469:43 - the contents of B has been changed. We are
but now let's see the contents of a the contents
469:44 - of a also has changed. That's a big difference
between slicing an ordinary Lester adini data
469:45 - structure or slicing a list, when you slice
a list, you get us you get another label,
469:46 - but that label or that variable is accessing
the same memory, the memory actually is not
469:47 - copied. There is one memory view. And these
two different names, whether you access those
469:48 - elements using B, or you access those elements
using a the same memory is being accessed
469:49 - if you change the memory using B or A you
will see the effect in both of the variables.
469:50 - So that's one difference. Now, after having
knowledge of this difference, if we really
469:51 - want this behavior to not happen, one thing
that we can call is we can say okay, a, for
469:52 - example, a, let's say three to 10. And then
we can call our famous function, remember
469:53 - that copy, you can copy that and now B is
completely a different array. It's it's a
469:54 - different memory view, if you change B now,
the effect will not be seen in a so copy function
469:55 - is there whenever you need copy. One thing
if you are not going to change elements the
469:56 - number is applies you very fast implementation
of slicing by not changing the memory view
469:57 - if if you are aware, your algorithm is not
going to change the elements slicing will
469:58 - give you much much efficient access to the
elements or the or the sub blocks or sub arrays
469:59 - without actually making the copies inside
the memory which can take time and space both.
470:00 - So this is one plus of NumPy Over the over
the other data structure that we have seen
470:01 - so far in Python, okay, let's play with indices,
470:02 - let's say what do you think? What is that
thing? colon, colon to what? Or colon colon,
470:03 - let's say five, what it will do, it will start
from the very first index, which is zero,
470:04 - it will go to the last index, but it will
pick every fifth element. So let's see. So,
470:05 - it picks zero then five then 10, then 15,
because the jump is five break, what do you
470:06 - think what this will do? Let me just let me
just teach you by example, what this will
470:07 - do. Yeah, what it will do remember, if you
apply a minus here, the end and the start
470:08 - and end they just get swept, and this becomes
a step from from the end. So, what will happen
470:09 - is the same kind of impact, you start from
the very end, then you take the step of minus
470:10 - one from the end, and you just based every
element, so this is kind reversing the array
470:11 - with with kind of step starting at the end
rate. So, another way of reversing the array
470:12 - is if you want to reverse the array as a whole
display minus one, which means start from
470:13 - the end and pick every element from the end
till the beginning and the end, and the array
470:14 - will be reversed. This element is there, remember
that this is there, let's chain that element.
470:15 - Let's chain that element. So, so a adds position.
So, I want to find out the index, where this
470:16 - minus 1200 is located. So Id x is equal to
a dot index I guess there is a function index
470:17 - Yes, he has a no index Oh, there is no index
there. Is there an MP dot index and P dot
470:18 - index? I want to find out the index where
so in DAX there is no index function indices
470:19 - or something, I want an index function is
there any index function I want to find out
470:20 - the index? Where minus 200 is located? There
are several ways but I want to find one. So
470:21 - for example, for example, let me see whether
there is an index function and not available
470:22 - in NumPy or not. No, it is no longer there.
But there is in the CS function, I guess.
470:23 - So in the CS, what that does, I guess that
does the same job. Let me see MPR indices
470:24 - returns an array representing the indices
of a grid, okay. So I have to give a grid
470:25 - and then it returns for example, the indices
of all that grid, how can I use that? Well,
470:26 - it becomes it becomes difficult, there may
be a find function, or how can you locate
470:27 - the index where the minus 200? Is, is located?
How can I How can I do that?
470:28 - Huh?
470:29 - Yeah, very difficult. Seems like very difficult.
Oh, why don't I rather than finding out a
470:30 - function? Why don't I just play with play
with the NumPy? Why not? So let's say a equal
470:31 - equals minus 1200. That gives me a Boolean
array comparing each and every element with
470:32 - minus 1200. So, the array the returning array,
let me call the index array or the Boolean
470:33 - array, let's be that array is true or false
array or zero or one array, wherever there
470:34 - is minus 1200, that index is one that value
is one otherwise it is zero, completely zero.
470:35 - And then what I do is, I just multiply that
with with NP dot arrange NP dot arrange with
470:36 - with saying that a dot A dot A dot size, so
whatever the size of A is, so because these
470:37 - are the indices Okay, then what that's point
wise multiplication grade. So, when I will
470:38 - multiply them together, what I will get is
is what I will get from multiplication, I
470:39 - will get, how can I How can I find out actually,
a train lost here literally, how can I find
470:40 - out how can I find out the index where Where
am I? So that will give me what? Let's see,
470:41 - what is B. Now, the B is B is just an array.
B is just an array, and there is this three.
470:42 - That is looking at it. So how can I find out?
Where is this three? How can I, again, the
470:43 - problem is finding out the index. Okay, that's,
that's really a bad thing. Can I call this
470:44 - aid dot indices? And just give a minus 1200.
And everything just worked out? No, there
470:45 - is an error, there is an error. Oh, I'm lost
here. Literally, I'm lost here, I need to
470:46 - know how to find out the index where this
particular element minus 1200 lies. So
470:47 - that's a
470:48 - question for you as well. I'm also lost. So
let's see you in the next video. And we first
470:49 - will solve this problem to finding out the
index of a particular element, or maybe a
470:50 - lot of elements. And then we will continue
from there onwards to see more indexing. Okay,
470:51 - great. So hope to see you in the next video
by first solving the problem, how to find
470:52 - out the index of a particular element in a
NumPy array, or maybe more than one elements
470:53 - in a NumPy array. And then we will be practicing
more about these slicing examples. Okay, hope
470:54 - to see you in the next video. Okay, let's
say this element is there. And let's say we
470:55 - want to, we want to locate that element in
the array, we want to just know where this
470:56 - element is in the array. So array has this
element. Let's let me paint array as it is,
470:57 - this array has this particular element, and
we want to know where what is the index of
470:58 - this element inside the array, there are several
ways of doing this. One way is to find out
470:59 - their index is simply you call the function
arc where arc where for example, org, where
471:00 - A is equal to minus 1200. And that will return
a 2d array. And if you just want any one index,
471:01 - then you return that kind of thing. So if
you write this thing, you will get the index
471:02 - exactly of the element that is there. So the
index is three, if you want to change that
471:03 - value, for example, the value should be three
here, if you want to change that value, what
471:04 - you can do is you can right, okay, ie x is
equal to three, and is reverse to its position
471:05 - wherever it was created, okay, great. Now,
let's play with the two dimensional indices.
471:06 - Let's do dimensional arrays, let's say we
have a equals NP dot random dot, Rand, let's
471:07 - say, let's say we have a five by four matrix,
let's say a two dimensional array, let's round
471:08 - all the values by multiplying them to 10.
What it does is because all the values this
471:09 - RAND function, all the values it generates
are the values between zero and one, what
471:10 - this multiplied by 10, what it does is, it
actually scales up all the values to 10. And
471:11 - then round function, actually, round downs
are actually rounds the values to the integers.
471:12 - Now a will be worse the problem round that
third round method is no longer there. Okay,
471:13 - maybe there is NP naught round, maybe that
NP dot round, maybe NP dot round is their
471:14 - Yes, and B dot round. So round function of
NP. So this a is a is this array, for example,
471:15 - that's five by four, a four, five rows and
four columns. So let's say I want to access
471:16 - the second row. First of all, let's say I
want to access this particular entry. This
471:17 - particular entry is second row and third column,
which means the index is one comma two, because
471:18 - second row means the row row first has index
zero. row two has index one. Similarly, column
471:19 - one has index zero, column two has index two,
a one and column three has index two. So that
471:20 - is what this particular entry is. What if
we want to access the whole second row, for
471:21 - example, we want the second row. So that's
how you call that's how you slice. A normal
471:22 - meaning of this is you the role should be
one and the columns, all the columns, so That's
471:23 - how you access the whole second row. If you
want to, for example, access the whole third
471:24 - row, for example, or a whole second column,
let's say that means you say this, okay, the
471:25 - column number second, and all the rows, which
means the whole second column that is accessed.
471:26 - That if you see, that's the whole second column
six, four to 10. And one, that's what the
471:27 - second column is. Further, once you have a,
you can, you can, for example, access a sub
471:28 - matrix, let's say you want, you want row number
one to rule number three, not including three.
471:29 - And then of these rows, you want column number
two to column number
471:30 - four, let's say. And if you do that, you access
the whole sub matrix. First, it actually picks
471:31 - row number two and row number three, because
row number two starts from one. And then of
471:32 - those rows, it picks these columns, and you
can just pick the pick the sub matrix inside
471:33 - more, you can, you can do a lot of processing
on these matrices. For example, this is matrix
471:34 - A, if you just type a dot transpose, that
these four transpose, the matrix just is taken
471:35 - transpose of it. Further, there is a complete
library, linear algebra library in NumPy.
471:36 - For example, if you just import NumPy NumPy
dot linear algebra, as a for example, then
471:37 - this linear algebra library in NumPy, has
a lot of functions, Eigen values, chelski
471:38 - decomposition, computing determinant of a
matrix, finding out inverse of a matrix and
471:39 - what not. For example, let's say we have la
dot inverse, and here is NP dot random dot
471:40 - Rand, let's say, some three by three matrix.
So what it returns is, it returns the inverse
471:41 - of this matrix, and this linear algebra library,
and there are other libraries as well. But
471:42 - this is one scientific library, that may be
most of data science experts who actually
471:43 - want to do research, they might be thinking,
this linear algebra library, that that specifies
471:44 - a lot of functions related to related to these
matrices or two dimensional arrays. So that
471:45 - is there. Okay, so that's about indexing.
We can play with these indices a lot if we
471:46 - want. One more thing, just just one. One last
thing, let's say this is our a. And what we
471:47 - want to do is let's say we want to sort this
A with respect to the columns, we want each
471:48 - column to be sorted individually, what we
can do is we can call sort function, and we
471:49 - can pause X's equals zero, access equals zero,
that means sort all the columns individually
471:50 - and the result will be if you see the result,
the result will be every column is sorted
471:51 - individually. If we want to sort for example,
every row individually, we will say okay,
471:52 - sort x is equals one, and every row will be
sorted individually. And if this is a multi
471:53 - dimensional array more than three more than
two dimensions, then x is can be two x's can
471:54 - be free. So which with respect to whatever
axes you want, your sorting can happen. It
471:55 - can do that, if A is one dimensionally, then
dot sort function without an access, just
471:56 - sorts just sorts the one dimensional array
from beginning to the end. And if you want
471:57 - to descending order a sword just sought them
sorted first and then reverse it using indexing.
471:58 - Great, I mean, there is a lot to discuss,
there is a lot to discuss, I'm ending this
471:59 - slicing here. In the next video, I'm going
to show you kind of masking or sometimes called
472:00 - the fancy indexing that is much more powerful
and useful in a lot of different contexts.
472:01 - So hope to see you in the next video with
more NumPy indexing. Okay, there is another
472:02 - way of indexing a NumPy array. In the last
video we saw we can, we can do slicing notation,
472:03 - for example, start from here and here and
stuff like so. There is another way of accessing
472:04 - a NumPy array as we have an array and we can
just give the give an index array inside for
472:05 - example. Let's say a is one dimensional array
and then we just give 146 that means big element
472:06 - at index one, pick the element at index four,
pick the element at index six. So this kind
472:07 - of array inside can be a list or an array.
That is called an index array. And you can
472:08 - just pick the elements that you want to pick,
for example, you want to pick all all elements,
472:09 - you want to pick first element, fifth element
and 17th element, you can just create an index
472:10 - array and pass it. And in an index your and
access your elements using that index array
472:11 - that's possible in NumPy array. Further, you
can access different elements using a Boolean
472:12 - mask as well. So Boolean array, for example,
true, true, false false, wherever there is
472:13 - a true pick that element wherever there is
a false, don't pick that element and return
472:14 - the elements that are picked. For example,
assuming here that you have an array, which
472:15 - is one dimensional array, let's say, assume
that has eight elements, 12345678 elements.
472:16 - Now you pass a Boolean mask inside, where
with with obviously, eight elements, a true
472:17 - or false values, wherever there is true. So
pick the very first value, pick the second
472:18 - value, pick the don't pick the third value,
don't pick the fourth value, pick the fifth
472:19 - value, pick the sixth value, pick the seventh
value, and don't pick the last value. So that
472:20 - is also possible in in NumPy. One thing that
is important is if you do this kind of indexing,
472:21 - which is sometimes called masking, if you
do that, if you do if you supply an array
472:22 - index, or index in a Boolean form, you by
default get a copy as as as compared to slicing
472:23 - in slicing, you get a view that's a separate
copy, you need not to call a dot copy function,
472:24 - it is by default, a different copy. And this
is a difference between the ordinary slicing
472:25 - that you do, for example, start from one go
till 50, take a jump of let's say two, if
472:26 - that is your indexing style, that is called
a slicing, the return value is a different
472:27 - view having the same memory. However, if you
do the, if you use the array index, or the
472:28 - Boolean array called masks, then you get a
copy of rather than also so which means if
472:29 - you if you get a new array, you change the
elements in the new array using the array
472:30 - indices. You're not getting that change happen
to the original array. So that's the difference
472:31 - between slicing and masking. Okay, this kind
of Boolean indexing becomes really handy.
472:32 - For example, what if you want to exit? What
if you want to get all elements that are smaller
472:33 - than eight, one way to do that is just write
a and then apply a condition is less than
472:34 - eight, well, a is less than eight, we'll create
a Boolean array. And everywhere where the
472:35 - element is smaller than eight, there will
be a true otherwise it will be false. Now,
472:36 - the inside array is a Boolean array, and you
access all the elements with respect to that
472:37 - condition. So it will return all elements
that are smaller than eight. How how fancy
472:38 - is that? Further, you can you can have these
conditions in a combined way. There is one
472:39 - difference there is an AND operator A and
D and, and there isn't an operating in a different
472:40 - way. So I'm going to discuss the difference
of this and this and as well in this in this
472:41 - whole in this video. So let's go to Jupyter
Notebook our fan and see how can we play with
472:42 - this masks.
472:43 - So let's say a is again and B dot arrange,
arrange, let's say 100. That's it. That's
472:44 - our a. And what we now do is we access the
elements of A, B access, for example, the
472:45 - third element and the fifth element and the
sixth element. Let's say we want to do that.
472:46 - And that's our B. So that happens, let's say,
so what B is B is this, something that you
472:47 - need to know is if you change the elements
of B now, because that's a copy, let's say
472:48 - minus four, that change does not happen in
eight that happens in B for sure. But that
472:49 - doesn't happen in a, a does not contain any
value that is minus four. Because using these
472:50 - kinds of indices, the array index By default,
the result is a copy rather than a view. Further,
472:51 - let's say you have this a and you want to
access all the elements that are smaller than
472:52 - let's say that are smaller than let's say
40, access all elements that are smaller than
472:53 - 40. So that is possible now even contain only
the elements that are smaller than 40. All
472:54 - the elements while further if you want to
access all elements that are that are smaller
472:55 - than 40 that are smaller than 40. And they
are bigger than they are smaller than 40.
472:56 - And they are bigger than 30. Let's say you
want to access all the elements that are between
472:57 - 30 and 40. You can just access those elements
like so there is a problem. A dot any a dot
472:58 - all what's the problem here? The truth value
of an array with more than one element is
472:59 - ambiguous use a.ne or a dot all. Okay, this
a is less than 40 is a Boolean array is greater
473:00 - than 40. That's a Boolean array. So what's
the problem? What, why can't we not use this?
473:01 - What's the problem? We should have used that.
So use and, and, yeah, I guess we were missing
473:02 - these, we were missing these brackets because
it might be confusing this 40 with this a
473:03 - and stuff like so. So use parenthesis rate.
Now, B contains only the elements that are
473:04 - between 30 and 40. Now, one thing, what's
the difference between this particular and
473:05 - and this symbol and the difference is this
and AMD an operator It is used when both of
473:06 - the sides of this end has what is one object
and it has one true value either true or false.
473:07 - And this particular symbol is used when the
left side and the right side can be arrays,
473:08 - and each element of that array can be true
or false. And so, so, you can think of this
473:09 - and is using arrays, however, this is used
when both the sides are single objects. So
473:10 - that's the difference. Other variants of and
I mean, the end is like this, that these are
473:11 - these are the same things, but remember the
use this is used for arrays, this is used
473:12 - for single objects. Similarly, there are other
symbols like
473:13 - or
473:14 - that is used this way or or that is used that
way. Similarly, there is a not not for arrays
473:15 - is used like this way and not for otherwise,
is used like that way. So remember these the
473:16 - left side, I have symbols, they are used for
arrays, the right kind of symbols, they are
473:17 - used for single objects that has true or false
values. So these, this kind of masking is
473:18 - really, really powerful. Later, we will see
in pandas accessing different kinds of data
473:19 - with particular kind of conditioning, that
becomes really handy if we if we are comfortable
473:20 - with these kinds of indexing. And that's really
powerful indexing. Okay. So, I've told you
473:21 - the difference here between Aaron and I've
told you that this is copy rather than a view.
473:22 - So just bear with me some more time on NumPy.
And I will tell you some more truths about
473:23 - NumPy. And then we will move towards another
package called pandas. So before pandas more
473:24 - NumPy is coming, I hope to see you in the
next video. Okay, in the last video, we saw
473:25 - masking, which is sometimes called the fancy
indexing as well. And here we are going to
473:26 - discuss one more feature of NumPy, which is
very powerful feature called broadcasting.
473:27 - I think, for example, you have an array, let's
say two, three, a matrix, that's a two dimensional
473:28 - array 235 and nine, and you want to add, in
every element, you want to add a number, let's
473:29 - say five. So one way to do that is create
another array with 5555. And just apply this
473:30 - add operator and you are done. Great. But
this NumPy allows you to just write let's
473:31 - say this is array, a NumPy allows you to just
do this particular thing. And this five is
473:32 - automatically broadcasted to match with the
dimensions of its other operand. And addition
473:33 - happens you need not to do this explicitly.
And this broadcasting is not just one scalar
473:34 - value. For example, if you have one variable,
let's say a is this and you want to add, for
473:35 - example, this particular column, let's say
one three, you want to add this particular
473:36 - column in the first column as well as in the
second column, but then you need this one
473:37 - three to be copied again and make a bigger
array and then you do that well, broadcasting
473:38 - allows you if you just write this as a plus
one three, it will be automatically broadcasted
473:39 - to match the size of the other operand, wherever
the book broadcasting is possible, there are
473:40 - certain rules to to know when broadcasting
is possible it is not possible each and every
473:41 - time. For example, if you have this matrix
239 and Jeff 421 Let's at this matrix and
473:42 - you want for example, two one and six two,
for example, if you want to do that, the broadcasting
473:43 - may not happen because in this way, if I want
to broadcast this structure, the structures
473:44 - should be if if the structure is broadcasted
to in horizontal way, the the two columns
473:45 - will be arrayed and the addition cannot happen.
If it expands to a vertical way still the
473:46 - addition cannot happen. So, this here you
will get an error because broadcasting is
473:47 - cannot happen, but in several cases when you
want to add for example, a scalar multiply
473:48 - with a particular thing wherever possible
this broadcasting is possible and broadcasting
473:49 - is just a I mean it just a feature of NumPy
that allows you to not repeat to match the
473:50 - dimension of the other operand to apply a
particular operator it does it by itself great.
473:51 - Next, we see some more important functions
to no one is horizontal stack. That means,
473:52 - if you want to concatenate two different array
two arrays that are that can be concatenated
473:53 - together horizontally, you can get out you
can call at stack function and that will concatenate
473:54 - the two arrays together and returns another
array. Similarly, V stack is if you want to
473:55 - concatenate two arrays vertically, if they
can be concatenated vertically, vertically,
473:56 - similarly, there, there is another powerful
function sort, and there are a lot of other
473:57 - functions, these kinds of functions, they
are called Universal functions. And they are
473:58 - very, very, very powerful, very, very fast
their implementation is vectorized, where
473:59 - Christ mean the implementation the all loop
kind of layer is deferred to at the compile
474:00 - time and the things are really faster when
you do a vectorized code. So, having said
474:01 - that, it is always recommended to not use
explicitly for loops to achieve these kind
474:02 - of,
474:03 - to achieve these kind of results, whenever
a universal function is available, use that
474:04 - because the efficiency of that universal function
will be way, way way more than then whatever
474:05 - loop loop or whatever function you will be
writing other than the universal function.
474:06 - So, and by the way, there is another function
concatenate as well, in which you can specify
474:07 - axes. And it will either act as horizontal
stack or either act as vertical stack, depending
474:08 - upon whether the x value is zero or one, whatever.
So, let's just get comfortable with these,
474:09 - these three functions, just quickly neural
Jupyter Notebook and see an example of, let's
474:10 - say, broadcasting as well. So let's say we
have a function, and let's say you have an
474:11 - array is let's say, np dot random dot Rand,
let's say that is two by three. And then I
474:12 - just multiply this with them. Remember the
last thing and then we just NP dot around,
474:13 - we just round everything. So that it becomes
it becomes whole, in this particular way.
474:14 - Okay, that's a, let's say, so that's our a,
that's the now if we say a plus three, three
474:15 - will be added everywhere in a, and that happens
through broadcasting. Well, if we if we do,
474:16 - for example, a plus, for example, np dot range,
let's say just do values, and then we just
474:17 - reshape it, reshape it, to reshape it to let's
say, a two by one matrix. If you do that,
474:18 - then still, what what will happen is just
apply the parenthesis just to show that this
474:19 - should happen. First, what what will happen
is there will, there will be a column that
474:20 - will be added to every column A, and that
again, will be happened through through the
474:21 - broadcasting. So broadcasting is that powerful.
Next, let's see the stats. So that's it, this
474:22 - is a, let's say we have the that's another
way, let's say NP dot random dot Rand. Let's
474:23 - say that new array is two by two. And again,
let's say it is multiplied by Dan and NP doc
474:24 - round just to avoid the decimal points. That's
it, this is B. Now a is two by three array
474:25 - D is a two by two array, if I just concatenate
them horizontally, I will get another array
474:26 - which will be two by five. So C equals np.at
stack horizontal stack, at stack, and I will
474:27 - call these A and B. One thing that you need
to know is if you if you want to call this
474:28 - x stack, horizontal stack or vertical stack,
these arguments in B that you want to concatenate
474:29 - you have to give them in a topple or you may
you may want to give several values to concatenate
474:30 - together maybe you have maybe you have 10
matrices to concatenate together horizontally.
474:31 - You have to give all these as a tuple inside
a All right. Now similarly, we can do a vertical
474:32 - stack if we want. I mean, one on top of the
other. And we can call it and getting it function
474:33 - as well, if you want. Third is sort function.
For example, if we want. If you want to use
474:34 - NP dot, let's say a is NP dot random dot permutation,
let's say NP dot range, let's say the 10 values.
474:35 - Let's say that our a, let's say, this is a,
and we want to sort this array. Oh, this is
474:36 - already sorted. Why is it sorted? No, it is
not sorted 1/4. It is not sorted? Yeah. Let's
474:37 - say we want to sort it a dot sort. One way
of doing that is just call a dot sort, and
474:38 - you're done. That's the value of a another
way, which is sometimes more readable, although
474:39 - exactly the same is to use a universal function,
using NP dot that thing that also is the same
474:40 - thing. Now sort by default sorts in ascending
order. If you want to sort in descending order,
474:41 - then what you can do is you can sort aid or
sought, for example, do that in ascending
474:42 - order, then what you do is you just reverse
it, minus one, and just copy that in a again,
474:43 - now he will be sorted. While sorted in descending
order. Yeah, great. Um, one more just just
474:44 - just just to give you one more flavor, if
you create an array, for example, np dot array
474:45 - of strings, for example, ABC, and another
string is, how are you and vai maybe we have
474:46 - another string? Whew, 785. And maybe we have
another string, one, three e r, that's it.
474:47 - That's a string. That is possible. As long
as all the objects have same type, you can
474:48 - create an empty array. Now, you might be wondering,
what we'll do this sort function on a because
474:49 - these are all strings? Well, the answer is
it will sort the strings according to the
474:50 - alphabetic order, whatever the alphabetic
order is, whatever string according to the
474:51 - alphabetic order should become first that
will become first and the other strings, they
474:52 - will they will just join. Yeah. So yeah, so
that's about something that is not that is
474:53 - not the numeric value. Okay, great. There
is a few more things to come about NumPy array,
474:54 - and then we will be moving towards panda's
library that is built on top of NumPy array
474:55 - for better processing of data, I hope to see
you in the next video. Okay, in last video,
474:56 - we saw horizontal concatenation, vertical
concatenation sort function, we also saw some
474:57 - broadcasting and stuff like so. Universal
functions, it should be speed here, sorry,
474:58 - it should be speed, speed. Universal functions
are really, really speedy, I always am talking
474:59 - about NumPy. Whenever I start NumPy, I said,
it is fast, it is fast as fast, I never show
475:00 - you how fast that is. So let me give you an
example. Let me let me just create an A NumPy
475:01 - array with a lot of numbers, and then just
apply an ordinary function, let's say want
475:02 - to add all the numbers in this array B, let's
apply an ordinary function that is not in
475:03 - NumPy. And then let's use universal function
dot sum, and see how speed differences there.
475:04 - If for example, we apply apply a universal
function to achieve a particular task how
475:05 - speedy that universal function is, because
a vectorized implementation, as I told you
475:06 - is much faster, how faster let's check that
out in new Jupyter Notebook. That's a magic
475:07 - command time ID that will tell us how much
time this particular task has, has taken.
475:08 - And if you run this command, it will it will
call this function again and again several
475:09 - times. And then we'll report an average value
that will be much more stable than just calling
475:10 - once. After that, we will also we will also
write our own sum function using loop. And
475:11 - we will see whether that is even closer to
a universal function speed or not. Let us
475:12 - just check the speed of universal functions
that will give you a look and feel of how
475:13 - much NumPy implementation is faster. So let's
say we have an array, let's say B and B dot
475:14 - random dot Rand. And let's say that array
is huge, really huge. Let's say that's the
475:15 - case. Now what we do is we let's say we we
call a function sum. So let's say we call
475:16 - a function sum. That's a built in function.
In Mumbai, that's a built in function that's
475:17 - a built in function in Python, not a NumPy
function. And then let's say we do the same
475:18 - task using NumPy universal function and P
dot sum, that's the same as NP dot sum is
475:19 - the same as if we if we write, for example,
b dot sum.
475:20 - So whether you write b dot sum, or you use
NP dot sum and be passed and passed, as an
475:21 - argument, both these things are roughly the
same. So let's run it, it will take a while
475:22 - It will take a time because, okay, the sum
function takes 307 milliseconds, that is not
475:23 - a universal function in NumPy. That's a Python
function. That is not written in NumPy. That
475:24 - is not a vectorized code, nothing. It takes
307 milliseconds to perform to take the sum
475:25 - of the elements of this array. And it does
that by applying seven rounds in in Santa
475:26 - loops. However, the universal function takes
just around three milliseconds, I'm assuming
475:27 - 2.7 milliseconds, how will how are you going
to compare this 307? With three? How much
475:28 - faster you are around? Around 100? times your
faster? I mean, yeah, I mean, this NumPy is
475:29 - literally faster NumPy, the universal function
will faster, maybe you attempt to know that,
475:30 - okay, the sum function might be too slow.
Let me write my own function. To do that,
475:31 - let me define my son, and my son just take
an argument, let's say something, let's say
475:32 - G. And what it does is for, let's say s equals
zero, what it does is for x in g, s plus equals
475:33 - 2x X plus equals to x and then just return
as nothing. That's your function. Let's say
475:34 - you think that this is really a great function.
Let's do that. Okay, let's compute the time
475:35 - for this time it my son. And let's pause the
rabee and see how faster this is. This is
475:36 - roughly the same as your calling the sum function,
but this NP dot sum or the universal function
475:37 - is very faster, fairly faster. So, use universal
functions, avoid for loops, avoid your own
475:38 - functions, if the same task has been a can
be achieved through universal functions, whenever
475:39 - possible, avoid loops when you are working
with NumPy. That serious suggestion, follow
475:40 - that, because the universal function written
in NumPy, they follow the vectorized code,
475:41 - all the interpreted slowness that is deferred
to the compilation layer. And the NumPy becomes
475:42 - really really faster and shows its power when
you are working on large arrays using the
475:43 - universal functions. So I can speak more about
NumPy. But I have told you some basics of
475:44 - NumPy. And we end the NumPy here and from
the next video, we will be moving towards
475:45 - a very, very fancy and beautiful kind of package
called pandas to handle data. And by the way,
475:46 - the pandas library the pandas package completely
is built on top of NumPy. Everything that
475:47 - is there in pandas is built inside is built
on top of NumPy as all the indexing and all
475:48 - kinds of stuff, slicing and speed. All is
there in pandas that is due to the NumPy.
475:49 - So we will see one more package after pandas
which is matplotlib for for plotting afterwards.
475:50 - And we'll do a project at the end using scikit
learn as well, just to wrap up all these things
475:51 - together. But for now I'm ending NumPy here
and in the next video, we will start pandas
475:52 - hope to see you in the next video. Okay, welcome
to pandas data science package that is very,
475:53 - very powerful of handling data, manipulating
data and used a lot in data munging and data
475:54 - cleaning and data pre processing and whatnot.
This pandas basically is built on top of NumPy.
475:55 - So most of the features of NumPy is also available
in pandas.
475:56 - Let's let's dive in. I mean, this pandas is
a very, very fancy library, very, very fancy
475:57 - package, that you can handle very large amounts
of data in CSV files or an Excel files. Wherever
475:58 - the data is located. The missing entries are
there. You can handle all the data you can
475:59 - manipulate all the data you can prepare all
the data in just a few lines of Using this
476:00 - pandas package, so let's just start pandas
package. There are two most important objects
476:01 - of pandas. One is series and other is data
frame that we will see later on, there is
476:02 - one more index. But the most important one
is, or the useful one is the series and data
476:03 - frames. So let's just define, first of all,
you need to import pandas package import pandas.
476:04 - And you can rename this as PD, that's a, that's
the most popular renaming, although you can
476:05 - rename it any. And then you just say okay,
PD dot series, and then just like a NumPy
476:06 - array, you pass the data that you want. And
you can create your own indices, for example,
476:07 - like, just like dictionary, this a is a key
value. This is a key or index for this point,
476:08 - two, five, this B is index 4.5, C is index
4.75. And these index four one, so you can
476:09 - you can, you can supply your explicit indices
as well. If you do not supply the indices,
476:10 - the default indices are 012, and three, but
you can define your own his own indices in
476:11 - the way you want. Now, once this data object
is created, you can call the data values and
476:12 - you will find out the values you can call
the dollar index and you will find out the
476:13 - indices let's see in the Jupyter Notebook
just to get comfortable with pandas. First
476:14 - of all, import pandas as PD, maybe or something
else. So okay, let's import it, maybe we can
476:15 - check what we're going to reveal working in
PD dot worryin. The version of pandas we are
476:16 - working in right now is 0.2 4.25. Read. So
let's create data or whatever variable let's
476:17 - say a as PD dot series buzy dot series and
there we just give a list of some values 2345
476:18 - let's say these are the values. And then we
can give index as another list. Let's say
476:19 - the indices are a maybe the indices need not
to be strings, anymore, anything AB, C, and
476:20 - let's say the index of fighters. Let's see.
So now the series object or the pandas object
476:21 - series is created. Series basically handles
one dimensional arrays, later on, we will
476:22 - see DataFrame handles multi dimensional arrays,
I mean more than one dimensions. Normally
476:23 - typically two dimensional arrays, but okay,
a dot values. So let's call the values, values,
476:24 - and you will get all the values inside the
series. And by the way, this values array
476:25 - that you get, let's check what's the type
of that array was type of battery? A dot values?
476:26 - What is that thing? That's a NumPy array.
Wow. And what's the type of a itself that
476:27 - will be a pandas object. Great. So everything
inside pandas, the NumPy is playing all the
476:28 - role inside pandas. Great. So now, let's check
the index a dot index. That's also a NumPy.
476:29 - That's also an array of index type, that's
a different actually index is also an object
476:30 - in pandas. That's an index type object with
these kind of indices, we can access for example,
476:31 - this a, just like we are working with dictionary
for example, a dat returns a value, we can
476:32 - change the values, we can add different, we
can add more key value pairs. So just think
476:33 - like these.
476:34 - Just think this data I'll just like the dictionary
object that we saw this, these are the keys
476:35 - and these are the values. And this is one
one very good way of remembering what the
476:36 - series does, and manipulating series The way
we want. Okay, one, we can access a z like
476:37 - this, we also can do slicing. Let's say we
want to access from A to let's say C let's
476:38 - say we want to access all these one difference
is when you access like this, in the normal
476:39 - slicing using implicit indices, for example
123 or zero, the final index is not included,
476:40 - but if you access like so, using explicit
indices that are there, the final index is
476:41 - also included. So that is one more fancy way
of indexing using in this pandas. Okay. Great,
476:42 - that's a serious object by the way, we can
create a serious object by first creating
476:43 - a dictionary for example. Let's let's go back
to our slides and see this example, let's
476:44 - create a dictionary. For example, of plates,
let's have a lot of students with Grade A
476:45 - grade A minus Grade B, red b minus, and let's
create that dictionary, then we can just create
476:46 - a series object or panda's object, by just
passing this dictionary inside, we can make
476:47 - another dictionary for example, and we can
make another series object. So a one way of
476:48 - defining the series object is just to is just
to pass the data as well as index in other
476:49 - ways to just first create the dictionary and
just pass the dictionary variable inside,
476:50 - and the series object will be created. Okay,
that was just an introduction to series, we
476:51 - will move on and see more features of pandas,
as we as we explore it more and more in the
476:52 - upcoming videos. Hope to see you in the next
video. Okay, let's say we have two different
476:53 - dictionaries, let's say we have a lot of students
and the a grade is defined to be four and
476:54 - a minus grades defined to be 3.5. The b grade
A has a number three, the B minus grade has
476:55 - a number of a numeric value that is 2.5. And
similarly b grade has an American value let's
476:56 - do and then we create just a series object
using this dictionary, let's say rather than
476:57 - just the numeric values as GPS or something
like so let's say a grade also is defined
476:58 - at 85 marks in total, a minus graders defined
at 80 marks in total, and similarly these
476:59 - and then we create another series object,
let's say named with Mark marks using these
477:00 - PD dot series. So let's go to Jupyter Notebook
and just play a little with these dictionaries.
477:01 - And build the series object, let's say marks,
or let's say grades. dictionary equals, let's
477:02 - say, a grade, is has has an eighth grade has
number value for RGB value for let's say,
477:03 - let's say we have a b grade with GPA value,
let's say B is let's say it's 3.5. Let's say
477:04 - we have C grade with GPA value, let's say
three. And let's say Finally, we have d grade
477:05 - with GPA value, let's say 2.5. Let's say that's
a dictionary. Okay? What we do now is we create
477:06 - a grades series object, let's say using PD
dot series, and just pass this grades underscore
477:07 - teched. Now this capital a capital B, capital
C and capital D, they will act as indices
477:08 - and this for 3.53. In 2.5, they will act like
values. So for example, if we call her and
477:09 - just now called grades dot v dot values, so
we will get, for example, what is that? That
477:10 - just values, let's say, beget this grade stock
values, and we get all the values that are
477:11 - available. Similarly, if we find grades or
index, we will find out A, B, C and D. Let's
477:12 - define another dictionary, for example, marks
dictionary dict. And there is let's say again,
477:13 - a while the total marks are 85. For the a
grade, let's say, for b grade, the total marks
477:14 - are let's say, 75. Let's say for C grade,
the total marks are
477:15 - let's say 65. And for D grade, let's say the
total marks are 55, let's say. So let's say
477:16 - that's another dictionary. Now, let's create
a series of objects, a series object PD dot
477:17 - series, series, let's say marks dictionary.
So now again, we have if you just write this
477:18 - marks, just like so, you will see the marks
is 85, b 75, c 65, D is 55. And all the values
477:19 - they are integer 64. Ghana values, now we
can access. Now we can play with this marks,
477:20 - for example, if we just want to access for
example, what are the marks? What are the
477:21 - marks between, let's say, for example, what
are the marks given a at a we can access that
477:22 - we can change that we can just play like a
dictionary. What if we rather than using the
477:23 - index In a, we use for example, slicing, we
want to start from the very beginning. And
477:24 - let's say we want to go to two what will happen?
Let's see. Yeah, so, the slicing is there
477:25 - for example, if you want these are explicit
indices A B, C, D, these are explicit indices
477:26 - and they are there. For example, if you can
slice the you can slice the data using explicit
477:27 - indices that you are given that you are given
or implicit indices that are the default indices,
477:28 - the first value index at zero, the second
value is index two one and so on. So, you
477:29 - can do that as well, one catch here for example,
that we will see later on, there may be a
477:30 - problem that your explicit indices they are
also numeric, and then you do the slicing
477:31 - like so, then the series object may be confused
whether I have to use the explicit indices
477:32 - or implicit indices inside we will see how
to resolve that issue, but by this pandas
477:33 - allowed to use explicit indices as well as
the implicit indices. Okay, we were here.
477:34 - So, he just so, yeah, so, we were here. So,
we have created these grades a series object
477:35 - This marks as a series object, these the series
object is good for one dimensional arrays
477:36 - or data with just one dimensional list or
dictionary, kind of with just one dimensions,
477:37 - later, we will see data frame that actually
is is actually the extension of curl can be
477:38 - looks like it can be looked like as an extension
of series towards more than one dimension,
477:39 - we may have, for example, two dimensional
arrays or two dimensional data structures,
477:40 - something like so. And we will be seeing this
data frame which is much more powerful, particularly
477:41 - for reading data from files and manipulating
it and stuff like so. We will see that in
477:42 - the next video data frame that running form
of data frame in the next video, hope to see
477:43 - you in the next video. Okay, in the last video,
we were discussing series, and I told you
477:44 - that data frame is basically if if the data
has if the data in the form of different columns,
477:45 - for example, a record as an array, then you
have another record, then you have another
477:46 - record. And each element in that record is
a different attribute. So this particular
477:47 - way of two dimensional data is very well handled
using data frame inside pandas rather than
477:48 - series. So but you can make these data frame
objects using different series objects. For
477:49 - example, you have a great object that grades
object that we created last time, you know,
477:50 - marks object that we created last time, let's
build a data frame using these two and see
477:51 - what it looks like in in Jupyter. notebook.
Let's see that. So remember, we have a marks
477:52 - series object, and we have a grades series
object. Let's now make grades. Maybe, maybe
477:53 - the name is rates, okay? The name is like
grades. Okay, so grades object, this one,
477:54 - let's make a data frame.
477:55 - Let's say D, or maybe whatever name you want
to do data frame with, again, that data frame
477:56 - can also be defined using a dictionary. Again,
now we have let's say, marks is the key for
477:57 - data marks. And grades is the key for data
grades. Let's say let's say we define a data
477:58 - frame like so. And now if you see if you just
display this D, we get a very beautiful look
477:59 - and feel of I mean this as the index is the
explicit index at index a, the marks, the
478:00 - marks is 85. The grades are for at index B,
the marks are 75, the grades are 33.5. And
478:01 - so on that that looks like so not only that,
you can just transpose it like you have transpose
478:02 - to a NumPy array, and you will get the flipped
version or the transpose variant if you want.
478:03 - Great. So that's how and you can have for
example, more dictionaries to concatenate
478:04 - together and more columns will be added here.
And that's what the real data looks like.
478:05 - I mean, it has a lot of columns, which normally
are attributes. And each row is basically
478:06 - one record or one sample of the data that
you want to work on. So this data frame is
478:07 - really, really ideal data structure for working
with files, having a lot of records and you
478:08 - want to manipulate the data and stuff like
so. So yeah, so one more thing, let's let's
478:09 - access the D, for example, that's brand D,
that's the, that's the D, let's access the
478:10 - values inside D, other than No, so what are
the values, so, the values inside D is completely
478:11 - again, a two dimensional array that is completely
like so. So for example, if we want to access
478:12 - this particular element 65, that is row number
three, and column number one, excluding the
478:13 - indices at row number three and column number
one. So we can access that particular value
478:14 - T dot values, just assuming that dimensional
NumPy array, row number three is to index
478:15 - with do and column number one is index with
that, and we will be able to access 65. Wow,
478:16 - great. So that is there. There are more things
that are available d dot for example, columns,
478:17 - d dot columns, columns, it will give us what
are the columns, the columns are marks and
478:18 - grades. There and there are other properties.
And there are other several properties that
478:19 - we need to know Rs, for example, this there,
we define this as di d dot index and stuff
478:20 - like so. Okay. One more thing that you need
to know is we can repeat right now we have
478:21 - that sub D, that is this one. That's the D.
Let's say we want to add another column here,
478:22 - just we want to add another column here. And
that is the name of that column is scaled
478:23 - marks. And the scale marks are what if we
have computed marks, rather than from 100?
478:24 - What if we have computed marks out of 90?
What are the scaled marks up 90? So one way
478:25 - to do that, and very quick way to do that
is just like a dictionary, again, like a dictionary,
478:26 - you just add a new key, let's say, scaled
marks, that's a new key. and the value is
478:27 - simply all the marks column divided by 90.
So is that true? No? divided by 90, if we
478:28 - have just completed all the marks by 90, and
then how can we? How can we compute the marks
478:29 - from 90? It is rather than 100. It is from
90, I guess? How can we compute the marks
478:30 - from 90? If you want to compute the marks
from 90, I guess they will look like and divided
478:31 - by 90. And maybe 100 is multiplied here. I
guess maybe the formula. I guess that that
478:32 - that's what it is, I guess let's see. So now
if you see D, there will be another column
478:33 - that is there. And oh, it does something else.
Anyways, it does something that Yeah, so something
478:34 - anyways, so we see we have just, I mean, we've
just computed this, we just
478:35 - we just found that we just inserted that column
inside that I'm in, there is a process for
478:36 - each of these kinds of values. Maybe we have
added this column in a very wrong way. And
478:37 - later on, we suggest that okay, we should
delete that column. Well, that's very simple.
478:38 - Again, using the concepts again, just like
the dictionaries, delete this, and this column
478:39 - is deleted from data. And you're again with
the data that you had. So you can add columns,
478:40 - you can delete columns, and indexing is really
fine. I mean, indexing like like masking,
478:41 - let's say, you want to bake for example, or
you want to bake the DataFrame such that you
478:42 - want to pick all the records such that the
marks are the marks are. The marks are greater
478:43 - than let's say, greater than, let's say 70.
You want to pick all the records where the
478:44 - bulk of the marks are greater than 70. This
is that simple. All the data will be will
478:45 - be copied into g with this condition. And
this condition can be arbitrarily complex
478:46 - using ands and ORS and combinations and all
that stuff. And you have seen this kind of
478:47 - stuff in NumPy as well. I mean, this is called
Okay, great. So that's available in pandas
478:48 - as well. Okay, so that's how you can index
in the next. In the next video, I'm going
478:49 - to basically show you one type of problem
that normally happens in real data that is
478:50 - the missing value problem. Sometimes you read
a data and some of the attributes or some
478:51 - of the row column p values they are just missing.
I mean, they are not available due to certain
478:52 - reasons. How can you How can you handle those
values? And how actually pandas suggest you
478:53 - to handle those kinds of missing values, which
are sometimes called Nan values or non type
478:54 - values. Also, they they mostly used interchangeably
in pandas. So in the next video, we are going
478:55 - to handle or see how to handle missing data
in pandas hope to see you in the next video.
478:56 - Okay, in the last video, we saw data frame
object. And we saw actually how to add and
478:57 - remove columns how to process data, how to
index how to actually mask or how to apply
478:58 - conditions and selections in in bond as we
saw that very briefly, but in this particular
478:59 - video, we are going to see one kind of missing
value, sometimes called name or not a number,
479:00 - or maybe not anything or sometimes this nun
type none, which is the default return type
479:01 - of any function. In Python. This non type
is also sometimes in pandas is treated as
479:02 - Nan or Nan is treated as none or interchangeably.
Any anything. Let me give you what do we mean
479:03 - by that, let's say we have two dictionaries,
let's say one dictionary is a with key value
479:04 - a and value is one, then B and the value is
two. Okay? The other dictionary is B and C.
479:05 - So for example, that is one record with columns
A and B. So a and b are the columns. On the
479:06 - first record, the value of a is one, and the
value of b is two. Now let's say we want to
479:07 - insert another record in the same data frame.
Now the value of b is available in the second
479:08 - time, well, if b is available, which is three,
and the value of c is available, which means
479:09 - a C column is added now. But for the value
c the first row value is not available. So
479:10 - we will say this value is missing here. But
in the second row, we have four similarly,
479:11 - the value of a is missing for for the second
row, and that is a missing value, which is
479:12 - sometimes called Nam. So these are missing
values. And they are typical. When you are
479:13 - working with data. And you're reading data
on you're getting data from, from out from
479:14 - somewhere or large files and stuff like so.
So pandas give some methods to handle these
479:15 - kind of
479:16 - these kind of I mean, this kind of situation,
let's say let's say a equals PD dot data frame,
479:17 - data frame, again, a dictionary, let's say
we have a,
479:18 - one and B, let's say four, that's the first
row or record. The second record, let's say
479:19 - is another dictionary, let's say B is minus
three, and C is let's say, nine. That's it.
479:20 - That's it. That's our data frame a. So now
if you bring this a if you see the data inside
479:21 - a, you will see Oh, what's the problem? Is
this and be heavy? Have you played something
479:22 - in a wrong way? Let's see. Oh, we have to
create a list. That's okay, we have to create
479:23 - a list of it, you have to create list of dictionaries,
that's the proper way of calling it. So we
479:24 - missed just this index list of that. Okay,
right. So now we have this A, B, just call
479:25 - that a and this value is missing and that
value is missing. And in large data files,
479:26 - this is typical, I mean, there are a lot of
values that can be missing. One way that pandas
479:27 - supplies to hell these missing values is to
just fill these missing values with some some
479:28 - fixed number for example, there is a fill
na function, fill any function and let's say
479:29 - you supply as zero that means wherever there
is a not available or not a number value,
479:30 - fill that with zero, or maybe any any value
you want to fill that with. So that is One
479:31 - way to do that, and now if you see the value
of a is all the non values are filled with
479:32 - that, another kind of function that is available
in pandas that is sometimes used a that is
479:33 - drop na that that function drop na, what that
does is it drops all the records that contain
479:34 - a missing value. Sometimes if that is visible,
I mean dropping all the records that contain
479:35 - missing values, if that is visible, then go
for that. But if if the if the missing values
479:36 - are a lot and they are spread over a lot of
rows, then dropping all those kinds of records,
479:37 - they will create a lot of I mean data loss
and and then it becomes really, really important
479:38 - how to how to handle these missing values.
However, you can fix you can fill the missing
479:39 - values using fixed value or you can drop them
and later on we will see in scikit learn that
479:40 - there are other ways of handling the missing
values as well, you can fill the each column
479:41 - missing values in each column using an average
or using for example, a regression there are
479:42 - ways to to handle these missing values. But
in pandas, these two functions are right away
479:43 - they are you can fill all them with a fixed
value for example or you can drop them and
479:44 - you are ready to go. Okay great. Next, we
are going to see oh as as I mentioned earlier,
479:45 - what is the what is the confusion between
what if there is a confusion between implicit
479:46 - and explicit indices. And that I will discuss
in the next video basically, just to give
479:47 - you a look and feel what if the explicit indices
you supply they are one three and five. And
479:48 - what if you call this this particular command
one colon three, will it call the implicit
479:49 - index or the explicit index, that's a problem.
So we will see because 1.1 colon three, one
479:50 - and three they are also explicit indices.
And whether this one colon three is referring
479:51 - to the implicit indices that are default indices,
or they're referring to these indices. So
479:52 - this confusion is there and we will see how
to handle that confusion. Using this lock,
479:53 - LLC function and index lock ilsc function,
we will see that in the next video, hope to
479:54 - see you in the next
479:55 - video. Okay, in the previous video, I mentioned
a confusion that can be there, if you have
479:56 - supplied the explicit indices that can conflict
with implicit indices. In particular, for
479:57 - example, if this is the series object, or
maybe a data frame object if you want to if
479:58 - for indices, let's just think about the series
object, it has these values ABC with index
479:59 - one three and five, if you for example, access
a particular element let's say data with index
480:00 - one that means the explicit index for sure,
but if for example, we slice the values for
480:01 - example, one colon three, the default behavior
of slicing if you give an American disease,
480:02 - that is to use implicit indices, and by implicit
indices, we mean by we mean that what is at
480:03 - index one at index one this is b, so B will
be printed for example, or B will be fetched,
480:04 - and then you move to do which is C then C
will be fetched, and these are the values
480:05 - that will be printed, but the behavior might
be different, you might be expecting to use
480:06 - explicit indices, which means access one colon
three, and when the explicit indices are used,
480:07 - the last index is also included. And in that
case, you might be expecting the index one
480:08 - is of a so as should be printed, and index
three is of B and B should be printed. And
480:09 - this configure might be there if if this is
there. So to handle that there is there are
480:10 - two functions one is called l OC. And another
method is called i l OC, whenever you call
480:11 - LLC, that means you are using explicit indices.
I mean, you're forcing to use explicit index.
480:12 - And whenever you call, I LSE that means you're
accessing elements using the implicit index
480:13 - what whatsoever. So let's, let's practice
this and see the confusion. See the detail
480:14 - of this kind of confusions in in here Jupyter
Notebook. So let's say we have a series object,
480:15 - let's say a equals PD dot series. And let's
say it has values as a, b, and c, NASA value.
480:16 - These are the values and index as let's say
One, three and five let's add these are the
480:17 - indices let's say this is eight Okay, let's
say we access a using one that means that
480:18 - means the explicit index and that is this
let's say B access and using the slicing operator.
480:19 - Now, this will use implicit indices and it
will access I mean it will access these B
480:20 - and C because one colon three using indices
implicit indices results that and we might
480:21 - be might be expecting that use this kind of
stuff. So, if we are really interested in
480:22 - using explicit indices, what should we do
is we should call the lat function a lock
480:23 - and then one colon three that means, use explicit
indices there is to remove the confusions
480:24 - now, it will use the explicit index one and
three and if for example, we are interested
480:25 - in using implicit indices, then it is good
to use ilok function Yeah, now, one one column
480:26 - three is to use implicit indices and the implicit
indices are like these. So, and like in series
480:27 - objects you can you can you can do the same
in data frame objects. Once you are using
480:28 - lock and ilok then the further indexing inside
these square brackets is exactly the same
480:29 - like NumPy. So, whether you use log or ILOG,
the indexing mechanism is exactly that the
480:30 - slicing mechanism is exactly the same like,
like you you you have used in in NumPy. I
480:31 - mean all indexing that stays the same log
means you're using explicit index ILOG means
480:32 - you are using explicit implicit index. Let's
say for example, we have our data frame, I
480:33 - guess D, that's our data frame available to
us. Let's say I want to access d dot ilok.
480:34 - Let's say I want to access the second row
completely the second record, oh, the record
480:35 - that is indexed at look at an index at two,
which is a third row completely, let's say
480:36 - I want to
480:37 - access that. Now this two is acting as this
two is acting as, for example, if you see
480:38 - the the second row or the or the row at the
second index, which is a third row that is
480:39 - completely this edit returns that once you
have used a lock, for example, and mostly
480:40 - people use ilok. Sometimes lock is also required.
But I log is just to explicitly mentioning
480:41 - that I'm using I'm going to use the implicit
indexing scheme. Again, you can consider hold
480:42 - that thing as a matrix. And once you have
applied this eye lock, then you're free to
480:43 - play with the indices, like you play with
two dimensional arrays, for example. I want
480:44 - to for example, I want to reverse, for example,
all the rows and I want to reverse all the
480:45 - all the all the structure, for example, let's
say I want to do that. And you can see everything
480:46 - is reversed. I mean all the indexing like
like nine by all indexing is there in, in
480:47 - pandas. I mean, once you have used ilok inside
is just just remember the NumPy indexing and
480:48 - everything like so. Okay, so that's the log
and I log function. In the next video, we
480:49 - are actually going to going to just practice
the pandas to actually to actually work on
480:50 - our data file that is saved as a CSV file.
So we will, we will show you how to how to
480:51 - actually add how to actually manipulate read
and write the data and play with the data,
480:52 - the data, the real data that is there in in
some CSV file, and how pandas will help you
480:53 - to to manipulate the data very efficiently
and very quickly. So hope to see you in the
480:54 - next video. Okay, in this particular video,
I will be talking about real data set. The
480:55 - data set I have chosen just to show you some
some functions that are available in pandas
480:56 - to work on real data set the data set I've
chosen as COVID-19 data set that was available
480:57 - on kaggle. And it's surreal data set that
contains information of victims recovered
480:58 - the total number of recovered people in per
country per province, the total number of
480:59 - died people and the total number of number
of reported people per date available that
481:00 - that data is available. Let's see the look
and feel of that data in a file. Just to just
481:01 - to see what kind of data we are talking about.
Let's say this is our data. This is the serial
481:02 - number column that contains just the record
number. That's, that's a column called observation
481:03 - date. That's a date, that's a province or
state. That's country or region that's last
481:04 - updated when the record is updated was the
time and how many confirmed cases were there
481:05 - at that date, and how many deaths at that
date and how many recovered at that date,
481:06 - as the date is moving on and on, you will
be seeing that the number of confirmed cases
481:07 - and the number of recovered cases they will
be increasing, maybe the number of deaths
481:08 - they also increase. So let's see this data.
Let's read that data using pandas and do some
481:09 - manipulation of this data and see the look
and feel of that data. In Jupyter, notebook.
481:10 - Let's go to Jupyter Notebook and see. So first
of all, I need this pandas library and pour
481:11 - it that maybe somewhere I need this NumPy
library as well. I'm also learning a psychic
481:12 - learn SK learn library because I want to,
I want to use impute function, just to handle
481:13 - the missing values, it is just more powerful
to use the I'm in the SK learn library there
481:14 - is also a Data Science Library package that
is particularly a machine learning library,
481:15 - or our package that actually gives a better
support or a larger support of handling missing
481:16 - data. Although here I have used this SK learn
function just for an example. And but but
481:17 - I could have used this data frame fill any
function or something like so but I'm just
481:18 - using that one. Okay, after importing all
these, what I did is I just call PD dot read
481:19 - CSV function, and I load that data and then
I did this stuff one by one. Let's, let's
481:20 - let's spend some time on all these commands
one by one. And let's see in Jupyter Notebook,
481:21 - what is happening, let's go to Jupyter Notebook
and actually read that file and do whatever
481:22 - we are doing here. So first of all, import
NumPy that is already imported. Import.
481:23 - For example, pandas that is also already imported,
then from SK learn dot impute import simple
481:24 - impurity. So let's let's use that or let's
Okay, let's do that. From SK learn dot impute
481:25 - SK learn dot impute import simple in pewter,
okay, import that because that's a new thing,
481:26 - we need to import that now read the data,
for example, data frame in df. So df equals
481:27 - PD dot read CSV. There is a CSV file read
CSV. And it contains the path of the file.
481:28 - The path is located in my directory, it is
located at this particular location COVID.
481:29 - And the name of that is COVID, underscore
19 ESCO data. So COVID underscore 19 underscore
481:30 - data dot c s v. So let's read that file, the
file will be read, if you just see that some
481:31 - of there is a function, let's say head that
gives the top records or the records that
481:32 - appear just the very top that's that's what
the data file that I was showing you in Excel,
481:33 - it is showing just the first five records,
I can show the first 10 Records, for example,
481:34 - just by calling the head function in this
particular way. Okay, great. Let's say I just
481:35 - want to remove this real number because I
think that is not required. And let's say
481:36 - I want to remove this particular column. Because
that is also not required. There are multiple
481:37 - ways of doing that. I can call an t l function
on this. And I can call the L function on
481:38 - that. But there is another way of doing that
by df dot drop df dot drop and in that you
481:39 - just give the columns that you want to drop
one column is serial number, I guess, what's
481:40 - the column name? That's s and No. So you want
to you want to drop that column and then you
481:41 - want to drop this particular column with herring
last update. So that is last update. So that
481:42 - is I guess what is there
481:43 - Xs one in place Drew. So Xs one is justments.
Mentioning, do do that stuff with columns
481:44 - in place, equals true. That actually is, is
telling that whatever this operation you are
481:45 - going to do reflect the changes in this df
frame. If we do not write in place to it,
481:46 - we'll do everything and return onto a temporary
variable or underscore variable or whatever
481:47 - we are saying, but the DF the data frame will
stay unchanged. So in place true means do
481:48 - that changing in df variable itself. So now
if we see df dot had flat say, it will no
481:49 - longer be showing us the serial number column
and the last updated column. What next we
481:50 - can do we may we may want to rename this,
this name to just date. For example, this
481:51 - to maybe another, let's rename all these columns,
using using the Rename function, df dot rename
481:52 - columns equals two and then we have that dictionary
again in place equals two. So let's use let's
481:53 - use this read in function, TF dot rename.
Let's do that. And here we have columns, columns,
481:54 - if I spell right columns, and then that is
dictionary what columns you want to change,
481:55 - I want to change observation date, I want
to change that to simply date, let's say and
481:56 - I also want to change province slash state
to simply simply state, our province province
481:57 - that say simply that and I also want to change
this country slash region to simply country.
481:58 - So, maybe I want to change this country slash
region to simply due to country cru and try
481:59 - country and I want all that should be happen
in place. So in place equals true. So after
482:00 - that, if you run that, on this particular
step, and now if you see the state of df,
482:01 - you will get like
482:02 - so. Okay, these many, so they province country,
confirm debts, and so on. So this is much
482:03 - nicer form than earlier. Moreover, we may
have a lot of missing values, oh, one way,
482:04 - this date format, the date format is not in
a format that pandas internal date format.
482:05 - So let's convert the date format into into
into the internal pandas date format, using
482:06 - to to PD to date time function. So let's say
df date equals to PD to date time, and convert
482:07 - this df date in that particular format. And
now if you run this TF dot had to might be
482:08 - seeing the date format in a different way.
See that that's the that's that's the date
482:09 - format that the pandas is expecting. Now,
we that that is just showing showing some
482:10 - records if you want to see more records, we
can see those let's say I want to just I want
482:11 - to just count or let's say let's just describe
all the data at TF dot describe there is a
482:12 - describe function that describe all most of
the statistics of the data, I mean, the total
482:13 - count of confirmed cases are these the deaths
are these recovered are these these many columns
482:14 - are there these many values are there. The
mean is that and standard deviation is the
482:15 - minimum 25. And these are the statistics.
Let's say there is another function info df
482:16 - dot d A dog info. If you call that function
info, it will give us the more information
482:17 - about the null increase and the nominal increase
and so on. For example, if you see the total
482:18 - number of data columns are six, the total
number of records are 6162. The date increase
482:19 - is always available. The province entries
are only 3700 available, the rest increase
482:20 - our null increase, so province increase most
of the increase or null increase and they
482:21 - are there, maybe we want to drop those or
maybe we want to impute those increase and
482:22 - stuff like so, but they are not increased
that are available in the province column,
482:23 - some of the province, some of the province
values are no longer available. Let's see
482:24 - that here. For example, this is not available,
this is not available, this is not available.
482:25 - And that's what the real state of the data
is this is not available, this is not available
482:26 - and so on. So this can happen. Okay, next,
what we do is, we actually be actually use
482:27 - the simple computer just to impute the missing
values. One ways to do that using simple mburo
482:28 - from SK learn. Another way is, as we already
know, just df dot fill na fill na with, let's
482:29 - say a bit let's say not available with let's
say a string, some string not available, that's
482:30 - it that string and with that, if you fill
that fill any using that now, after that,
482:31 - we will be having all that data, the missing
values will be filled according to Let's see
482:32 - some missing values because in the province
there were some missing values. Now you can
482:33 - see for example, let me go on and left Yeah,
so not available not available, we can we
482:34 - can use that or we can use a fancy kind of
thing that is available by a psychic learn
482:35 - and so on. Okay, after that, if you now see
the information info, now, you will not be
482:36 - seeing any null value, all the columns are
there, oh, this was not in place. So don't
482:37 - fill na that is let's change the DF with it.
So this doesn't happen in place, df just changed
482:38 - the DF. Okay, df changes. Now, if we now call
the info, there is no null value anymore.
482:39 - Yeah.
482:40 - So I am this video here. In the next video,
I will show you this group by command to just
482:41 - see these kind of stuff in a more detailed
way. Because this this particular video is
482:42 - getting lamp here lanthier. me I'm stopping
here in this particular location. Next time,
482:43 - I will show you the group by command in the
in the panda's data frame. And I will show
482:44 - you what that does. So, we will explore all
that code that is written here. And we will
482:45 - have in the in the upcoming videos when we
will see the plotting and matplotlib we will
482:46 - be using the same data file to work more.
And to get more insight how the how this pandas
482:47 - and matplotlib and NumPy in combination how
they can actually how they can actually play
482:48 - a very important role in analyzing a very,
very large real data files. Okay, so I end
482:49 - this video here. I will start the next video
right from this command. And I will tell you
482:50 - what is happening what is the scope baikman
so hope to see you in the next video. Okay,
482:51 - in the last video, we were discussing this
COVID-19 file, and we reached here but we
482:52 - didn't use this SK learn in pewter, we just
use the fill na function of data frame. Now
482:53 - let's discuss this group by command or a Curie
in in pandas that is much more visible. Let's
482:54 - say our goal is now for example, if you go
to go back to Jupiter, if you see your dear
482:55 - df dot head, or all, at the D f dot head,
let's attend records. If you want to see that
482:56 - there are so many records, let's just see
10. Let's see, what you want to do is you
482:57 - want to just see how many, how many total
confirmed cases are there in each country,
482:58 - regardless of their date. And, for example,
you want to just see all the all the all the
482:59 - confirmed cases, all the deaths, and all the
recovered cases in each country for all the
483:00 - dates and for all the provinces combined together.
One way to do that is to write a group by
483:01 - command for example. That's a df two equals
df dot group by and in group by what you see
483:02 - is for what kind of columns you want to you
want to group all these all this data. So
483:03 - for example, you want to group by country.
country. So that's your grouping. Now after
483:04 - gopeng What do you want to see what kind of
what kind of what kind of, for example the
483:05 - values you want to see because now you're
dropping? Well after grouping I really Want
483:06 - to see because data is gone once I drop, all
the dates, they are grouped together all the
483:07 - prevents that are grouped together. So, what
I really want to see is just the country and
483:08 - I want to see the confirmed cases. So, pick
all these records confirmed, and then I want
483:09 - to see deaths and recovered. So, for example,
if I want to deaths, and let's say then I
483:10 - want to see the recovered cases are E and
just I want a big group all the countries
483:11 - together group all these things together and
add all the records under each country. So
483:12 - sum all of them, and maybe we want to reset
any index if it is there. So for example,
483:13 - preset, we set index. So that So, after this
Curie For example, this group by query, what
483:14 - will happen is this df two will contain a
summary of the data with respect to each country
483:15 - and the total for example, in this particular
country, the total confirmed cases are these
483:16 - all confirmed cases till now, and the deaths
of these and recovered as these for this country
483:17 - for each country, now, each country is describing
Australia for example, in our till, till now,
483:18 - Australia has total these confirmed cases,
these total deaths, and these are recovered
483:19 - cases and so on. So, that is if we want to
group all these with respect to country, what
483:20 - if we want to group all these with respect
to country and then date for example. So,
483:21 - first we want to group them by country, so
country and then for each country, display
483:22 - all the dates, and then do the same stuff,
the the Curie will stay almost the same. A
483:23 - group by command will say almost the same
with one kind of
483:24 - with one kind of let's say we want to first
group by country, once the, it is grouped
483:25 - by the country, then I want to group them
by date. And now I want to see all the results
483:26 - in the form of I want to see the data as well.
And what will happen now is for each country,
483:27 - its trend with respect to all the dates that
will be displayed here. So let's see df two
483:28 - now, df two. So if you see df two now, you
can see, for example, this particular country,
483:29 - it has just one record in this country, it
has one record, then this country for this
483:30 - date has this record for the same country
and other date has same record and all the
483:31 - data is also sorted. I mean, now you can see
all the records in a very incremental way.
483:32 - So that may give you a very good look and
feel of what is happening or, for example.
483:33 - Another thing What if you want to what if
you want to, for example, find out all the
483:34 - records, all the records, you just want to
find out all the records? Let's do three,
483:35 - four, which the the confirmed cases, for example,
the confirmed cases are are more than 100.
483:36 - Let's find out all the records. Let's, let's
let's let's get just let's just pick all the
483:37 - records for which the confirmed cases are
larger than 100. And let's copy all these
483:38 - records just those records in this. So if
we do that, we have d3 available, and we have
483:39 - d3. This, I mean, these are just the records
in which the confirmed cases are for sure
483:40 - larger than 100. Just those. Yeah, so we can
do. I mean a lot of a lot of data analysis,
483:41 - the real data analysis, a lot of a lot more,
I've just shown you a very small snapshot
483:42 - of what we can do with pandas on the real
data set. I mean, there is a lot more that
483:43 - we can do with this pandas library, on real
data sets on multiple data files, combining
483:44 - them together, joining them together, seeing
their correlation, a lot of stuff. And this
483:45 - pandas really is a very, very fancy and very
high level library, very high level package
483:46 - to work with data. So due to time limitations,
I'm just ending this pandas here although
483:47 - there is much more to explain in that, but
in the next video we will be jumping towards
483:48 - matplotlib just we will see some some functions
of matplotlib. And we will see very briefly
483:49 - how can we plot How can we analyze data using
visual graphs or stuff like so. So, that that
483:50 - sometimes this visualization of different
attributes of the data give very good insight
483:51 - to the data wherever possible, wherever possible.
If the visualization is possible if the data
483:52 - dimensionality in a way are the visualization
techniques are in a way that you can visualize
483:53 - the trends in the data, that gives you much
more much better insight than the numbers
483:54 - or statistical results, but it completely
depends in what situation you can visualize
483:55 - the data there are situations, high dimensional
data, for example, is not always visualizable.
483:56 - So, in those cases, the statistical results
of the numbers may play a more important role.
483:57 - But in more in many cases, visualization give
a very good initial insight into the data
483:58 - and the design process can become very, very
fast if you know something about the data,
483:59 - whether you get that information by visualization
or by other statistics or whatever. So, in
484:00 - the next video, I will be just explaining
some very few functions of matplotlib. And
484:01 - then we will be, then we will be exploring
the same file, and we will be doing some stuff.
484:02 - Doing some stuff using the plots and matplotlib.
And doing, seeing the trends of death rates,
484:03 - seeing the trends of I mean, we'll be playing
with this file a bit more using matplotlib
484:04 - as well. So hope to see you in the next video.
Okay, in this video, I'm going to discuss
484:05 - matplotlib a very powerful package for plotting
graphs and scatter plots, line plots and 3d
484:06 - plots and plots on the globe and whatnot,
I mean, very, very powerful tool. The most
484:07 - important module in this matplotlib, or the
most popular module, or the most used module
484:08 - is biplot. So we can import matplotlib.pi
plot as PLT. Another way of writing the same
484:09 - kind of stuff is we can we can write like
from Matt matplotlib
484:10 - from matplotlib import by plot as PLT. So
either way is fine whether we write this as
484:11 - a documentation or that one that is fine as
MP is for NumPy. So let's create some points,
484:12 - just just just make our first plot. Let's,
let's make some points starting from zero,
484:13 - let's say all the points starting from zero
till 10. And let's create 1000 points in between.
484:14 - One way to do that is to use built in function
or a method in NumPy, which is linspace or
484:15 - linearly spaced points starting from zero
ending at 10. And there are 1000 of those
484:16 - points. Let's say this is our x and this is
our let's say y which is NP dot sine, the
484:17 - sine function is actually will apply element
by element on this NumPy array. And then this
484:18 - PLT will plot will actually plot x comma y
all the points in front of you. So let's go
484:19 - to Jupyter Notebook and actually see this
matplotlib in running form for the very first
484:20 - time, oh, we have seen this matplotlib. When
we saw NP dot random, we only plotted a histogram.
484:21 - While this is not the first time we actually
have seen this once, once, once before. So
484:22 - import mat plot lib.pi plot as PLT. That's
your import command. For example. Now PLT
484:23 - is available. Let's say x is NP dot Lin. space.
Let's start from zero. Go to 10 and generate
484:24 - let's say 1000 points. That's it. That's your
x, y might be your MP dot sine x. That's it.
484:25 - That's your y. And then what you do is you
say okay, PLT dot plot, x comma y point by
484:26 - point, and then you press Shift, enter. That's
it. Oh, this plot is there in front of you.
484:27 - That simple. I mean, that simple. Can you
imagine? This? Is that simple? Yeah, this
484:28 - is that simple. So I'm in plotting. This is
a line plot. For example, if we want a scatterplot,
484:29 - we can say okay, PLT dot scatter, there is
a scatter function that allows us to plot
484:30 - all these endpoints form rather than rather
than this line form. These are all these a
484:31 - lot of points. That's why you you're not seeing
these scatters. So let me let me let me take
484:32 - this n x s viewer. Let's see. Let's take x
as let's just take a few points, let's say
484:33 - just just just 30 points. Let's see the corresponding
30 points, see, they remember the indexing
484:34 - of NumPy arrays and just using that. So now
use the scatter plots, and you have this,
484:35 - oh, that's a scatter. Maybe we want to use,
let's say, start from the very beginning,
484:36 - due to end and big every, let's say, attempt
point. And do the same with why, just to just
484:37 - to see a plot in a better way, just sample
some points. So that's the scatterplot. It
484:38 - is just like I'm in the points and so on.
It is not a it is not a continuous plot, like
484:39 - the line plot, it's a scatterplot, we're going
to annotate this scatter plot, we can change
484:40 - these colors to any color we want. For example,
we can we can have a prop property, for example,
484:41 - color is equal to let's say, red, and everything
will become red. Yeah, so that's right, we
484:42 - can have I mean, we can label it we can x
label it, we can via label, there are a lot
484:43 - of properties. But but the but the main point
is plotting is that simple plotting is that
484:44 - quick, using matplotlib. So yeah, this matplotlib
is really, really powerful, we have just seen
484:45 - a snapshot, just a plot function and a scatter
function there, there are a lot of properties
484:46 - to be said, there are a lot of things to be
considered. And we will see we will see actually
484:47 - one one lanthier good use on this COVID-19
file. And we will we will actually analyze
484:48 - the data trends and the confirmed trends and
some trends that and we will plot them and
484:49 - see the trends really using matplotlib. So
But before that, let me let me show you that.
484:50 - If you call for if you call this plot multiple
times, for example, maybe with different colors,
484:51 - then you will be having a lot of curves on
the same on the same plot, for example. So
484:52 - for example, let's see PLT dot plot x comma
y, let's say with with color, let's say color
484:53 - equals to blue.
484:54 - You can write blue, the whole or you can like
write just be that's fine PLT dot plot, x,
484:55 - and let's say NP dot cause x and the color
you are interested in, and let's say the color
484:56 - is, let's say green. And that's perfectly
okay. And that will give you two plots in
484:57 - the same figure, sort of, and you can just
good to go. Well, yeah, so that more you can,
484:58 - for example, you can plot with a green, green
color, and you want the solid line, or you
484:59 - want, for example, Seon color in a dashed
line, or you want a dash and dot black line
485:00 - or, or maybe you want to completely dotted
line in red color. So there are several things
485:01 - that are available in matplotlib. This is
just a very few very simple snapshot. And
485:02 - I have given you a very quick start in and
actually actually the whole point is using
485:03 - Matlab is that quick, I mean, you can you
have your data, you just plug in their data,
485:04 - you just call the plot function, and you're
good to go for analysis. Okay. In the next
485:05 - video, we are where we will actually walk
through the we will actually walk through
485:06 - the COVID-19 data set. And we'll actually
analyze the trends and to add the death rate
485:07 - transfer each country individually, and then
we will see the depth confirmed and the recovery
485:08 - trend of the overall world till the 16th of
March till the day till the data data is available.
485:09 - So next video will be actually the viewer
will see the running form of pandas and matplotlib.
485:10 - Together, so hope to see you in the next video.
Okay, I already have shown you the COVID-19
485:11 - file. And here I have a notebook on that that
uses matplotlib and pandas to find out the
485:12 - depths conformations and recovery trends using
using different plots. So let me import all
485:13 - the packages that I need. I need a plot by
plot function from matplotlib. I need pandas
485:14 - somewhere I need NumPy. And I'm using a simple
mburo here for missing values. So let's run
485:15 - this. Let's run this command. And yes, everything
is imported. Now let's load the data that
485:16 - I've shown you earlier. The data is available
now. And let's run this thing that is the
485:17 - first 50 Records. Yeah, remember that? Yeah,
so that's the data that is available if if
485:18 - you just want another view another view of
the data That's the data file, which is COVID-19
485:19 - file. And it has observation day province
country, last update, confirm, to date, death
485:20 - to date and recover to date for each country
and for each province individually. Okay,
485:21 - great. So that's what we have. Now what we
can do is, now let's drop the serial numbers
485:22 - and last update using in place that and rename
the columns that we did already in a previous
485:23 - video as well. Let's convert the date into
the pandas built in date, frame. Okay, let's
485:24 - use the psychic learn in pewter, sk learn
in pewter, using the constant strategy, there
485:25 - are a lot of strategies there, let's use a
constant strategy. And this period or data
485:26 - frame, in pure dot fit transform that will
help imputing all the missing values with
485:27 - a constant strategy impure. So that's there.
Okay, next, let's apply this group by command
485:28 - and group all of all the records using country
for each country. And for all the dates, let's
485:29 - sum all the records that sum all the values
of records deaths and confirms using this,
485:30 - but now let's first country and then all it
state, then the second country, then all it
485:31 - states and so on. We have seen that in one
of our previous videos just running that again,
485:32 - just for a double check. So that's what the
data state is. So country one all it states
485:33 - country to all it states. So this country
has a lot of dates, then another country and
485:34 - so on. Next, let's see how many countries
are there. In total, how many unique countries
485:35 - are there. So what I, what I do is I find
the column, I actually pick the column with
485:36 - country and call a unique function on that.
And that gives me all the countries without
485:37 - repetition. And I just compute the length
length of countries tell me how many unique
485:38 - countries are there in this data file?
485:39 - There are 171 countries. So now my goal is
for each country, I want to see what is the
485:40 - trend of with respect to the date as the data
is moving from the first day till 16th of
485:41 - March? What is the trend of death? patients?
What is the trend of recovered patients and
485:42 - what is a trend of confirmed patients as the
data moves on. So because we have 171 countries,
485:43 - so let's loop over each country again, again,
and again, let's loop over what we do is for
485:44 - ID x in the range of this, that's the loop
you remember that. And what I do is let's
485:45 - find out the indices where the country is
like this, let's find out the index all the
485:46 - indices where the country is like that. Then
what do you do I make a scatterplot. That,
485:47 - with starting from this, and that, I just
pick the confirmed cases and all the confirmed
485:48 - cases for this one country, I just pick those.
And I look, I do that using this scatterplot,
485:49 - then I use another scatter plot, just to get
all the recovered cases, then I do another
485:50 - scatter plot to get all the depth cases. And
then the title of the title of my figure becomes
485:51 - the country name, the x labels the days, days
since the first suspect, the wire label is
485:52 - the total number of cases, the legend command
actually will be there that will show what
485:53 - eat that is in. So these kinds of labels that
are rewriting here, they will appear in the
485:54 - figure, then we force them to show that in
each iteration show the show the fourth. So
485:55 - this will show the trends of confirms to cover
some deaths for all 171 countries one by one.
485:56 - So if we run this command, we'll be having
171 plots in front of us. Let's see all of
485:57 - those one by one. So yeah, so this is for
the country. It has just one such thing. This
485:58 - is for that this is for Afghanistan. As these
moves on the confirmed cases that are even
485:59 - blue, they are moving up. These are the number
of cases. These are the number of days since
486:00 - the first day. And the green is the number
of recovered cases for Albania. That's the
486:01 - trend for Algeria. That's the trend. I mean,
these are each and everything is a separate
486:02 - that is for Argentina. That is for America.
This is for America till 16th March, by the
486:03 - way, today. The new says that America is really
in as dangerous position anyways, that's for
486:04 - Australia till till the date we have to do
that is for Austria. Yeah, so these are all
486:05 - the trends for all the countries. You see
I'm in the matplotlib how powerful that is.
486:06 - Although I walked through this code very quickly,
but you can see this video again and again.
486:07 - And then check how that happens. Yeah. So
that's what this is for Finland. Oh, Finland
486:08 - is also in trouble. So France. Okay. So that
is for Germany. And yeah, so all the countries
486:09 - that are available in data set, they have
these kind of plots. This is for Hong Kong.
486:10 - And this is for India. And this is for Italy's
or Italy's. Yeah. So that's it. So that is
486:11 - for each country individually, what if we
want the overall trend, or the overall confirm
486:12 - and the deaths and the recover trend for all
the world together, so what I do is I big
486:13 - I grew up all the data with date. So I pick
the first date, and add all the records, then
486:14 - the second date for all the records for all
the countries and so on. And then I plot the
486:15 - trend using the scatterplot, again, confirmed
record. And that's for all over the world
486:16 - and see the trend, where the world is moving.
So that's the trend of the world. As the days
486:17 - are going on, these are the depth grand, that's
a recovery trend. And that's a confirmation
486:18 - trend that is moving on. Although I walked
through or this notebook, the notebook will
486:19 - be available to you. I walk over this notebook
very quickly. But the goal was really to show
486:20 - you the the I mean, that was a file may not
be that informative, if you see that in Excel,
486:21 - but now it makes much more sense. When you
see these blobs you know what is happening
486:22 - and you have insight in the data. And later
on, we may we may want to predict we may want
486:23 - to make predictions. And the next date what
is going to happen, we may want to predict
486:24 - using this plot or using some Machine Learning
Library like psychic learn or TensorFlow or
486:25 - something like that. Okay, so that's it. I
can talk much more about pandas NumPy matplotlib
486:26 - of there are so many other data science packages,
very important packages, one of those is SK
486:27 - learn, we can that is for machine learning
basic machine learning. Then there are other
486:28 - packages like TensorFlow for deep learning
by torch for deep learning. There are a lot
486:29 - of packages with a lot of speciality is in
data science and stuff. I just discussed a
486:30 - few of those the most important of those do
to manipulate the data to make predictions
486:31 - to make classification or regressions. For
one, one way is to go to SK learn or psychic
486:32 - learn. And if the data is huge, and you have
a lot of large amount of data, and you have
486:33 - good expertise or deep learning, then you
should go to either TensorFlow or pytorch
486:34 - these are the Python packages that are available
for predictions, classification, regression
486:35 - and a lot more, but either way, whether you
are going to use scikit learn whether you're
486:36 - going to use TensorFlow or pytorch either
way, you have to use pandas NumPy and sometimes
486:37 - matplotlib to pre process the data and to
make the data ready for for these kind of
486:38 - libraries to to perform predictions, either
a either in the form of classification or
486:39 - in the form of regression. So so so this whole
course was about for for beginners who want
486:40 - to who want to learn Python, specifically,
I discussed a lot about the in a lot about
486:41 - Python in general, then then then I spend
some time not a lot amount of time sometimes
486:42 - on exploring the data science packages as
well. But, I mean, there is no end we can
486:43 - explore more, we can talk about the packages
more we can talk about other features of Python
486:44 - more, a lot of I mean, input formatting, output
formatting, modules, packages, standard template
486:45 - library, file handling Internet Access database,
486:46 - I mean,
486:47 - this is a whole universe, I have discussed
a few things for beginners. But But these
486:48 - few things were very carefully selected for
data scientists. The if you have this course
486:49 - available to you as you have gone through
all the course, you now have a very very good
486:50 - understanding and now you can you can move
towards further edit advanced courses towards
486:51 - data science and you will be ready to implement
the concepts in Python using using the packages
486:52 - I have discussed so far. So I thank you all
and good luck.

Cleaned transcript:

I'm going to talk about the focus of our course mastering Python for beginners in data science. So let me explain what kind of areas in this particular course we are focusing the most. In fact, because this is a course, for beginners, that's a beginner level course, we are not assuming the the course taker to have any experience whatsoever about any computer programming language before, not even not even the problem, problem solving paradigm that lies in computer science. So, we will, we will focus on problem solving for a bit. And we will actually start from the very beginning what problem solving is, particularly in computer science. The second focus of this particular course, is mainly telling you why we are choosing Python, why Python is so important, particularly for data science problems. The third focus and the main core focus is to learn Python, obviously, once we know what is what what are the techniques to solve a problem. And once we know that Python might be a very good language to go with, then what is Python, how to learn it? Well, the Python is the main core and main focus of this course, obviously, we will start from the very beginning, very, very beginning, which means we will start from how to install Python for example, we will start from there, and then we will see what are variables, I mean, very, very beginning, and then progressively we will be moving on and on and on to data structures to complex structures, but that transition from 02 onwards, that transition will be very, very smooth. I mean, whatever you know, so far, in the course, that will be helping you to gain more complex structures very, very easily getting the understanding of a lot of structures very, very easily. So in this Python, we will include all concepts of Python in general. And, and one more thing, after I mean learning, despite on the way we the way we organize this course of learning this Python, you will be having an understanding of other languages as well. I mean, the contents here are explained in so general way all over the Python syntax, but the general but but but the concepts are expressed in so general way, the problems that we picked to solve for practice are so generic that you will after this particular Python course, you will be having understanding of programming languages in general. So data science is one other focus of this course, actually, the whole course is organized in a way that it teaches you about Python, it teaches you problem solving, it teaches you something about overall programming languages and how computer can be used to achieve the solution of different problems. And and using Python, of course, and then we will be introducing the data science packages that are available in Python, because they are really, really fast, really fundamental, very easy to use, and very, very powerful to handle large amount of data very quickly for data understanding for visualization, for cleaning, processing, and a lot of stuff, what we are not focusing at because that's important. Knowing that what kind of things are are are the things that we are not covering, for example, we are not covering object oriented programming, we are not covering exception handling, we are not doing web development, or any general kind of tasks that are doable in Python, we are not focusing on those things. Everybody solves different problems every day. Some problems are easy to solve, and some are difficult. And yet some are impossible to solve. They are called unsolvable problems. But think about different instances of the same problem one needs to solve again and again. For example, sorting the sale records. And let's say we are sorting the sale records with respect to the sale value. And we have to do it after every eight hours. If the number of instances if that number is huge, the optimal choice is to automate the solution if the automation is possible, but how how to come up with the automated solution to come up with a general solution that works for every instance of some problem. That is one thing. But to get that solution running on a computer is yet another thing Problem Solving deals with formalizing a general solution for that works for every instance. And programming languages, like Python deals with the running of that solution on a computer. Python, as, as we will see, makes the transition from problem solving to the running solution much easier and quicker. And that's one big plus of Python. A lot of words, I know a lot of words. Let me take an example to clarify what I said, Hold on till the end of this video. And I will make everything what I said so far, crystal clear. So let's take an example. Let's dive into an example to see what I just said. Let's say your a, and your friend is B. And your friend B is always willing to help you. Let's say you found such a friend. And then a just said, I want off just for some days. But be said, but what ghobadi enjoy. He said, someone have to do my job in my absence. And then be said, That's it? Is that your problem? I'm available? As always go buddy, enjoy. Man. He said, great. You're a true friend. Okay, I'm leaving, wow. And be just said, Hey, wait, what do I have to do? What's your job? At the end of the day, I'm going to do your job. What's your job? What do you do? And then he said, after every eight hours, pick the email of the customer when the maximum sales. So that's what you have to do. He said, Okay. But from there, I mean, I have to pick that email of the customer from where, where are the records? He said, Well, there are sales records. I mean, at the job place, there are sales records. And you have to pick the email of the customer with maximum sales. We said, Oh, okay. But wait, what, what should I do with the email that I just picked? Then he said, oh, there is an other record called priority records, just write that email after eight hours, just write that email in purity records. And then be said, that's it. That's all your job. And he said, after so relaxed, he said, Yes, that's my job. That's all. No, think he leaves and later that day receives a call from B. And B said, I don't really know what to do. Can you tell me step by step? What to do? Focus on again, I'm reading this particular sentence again. Can you tell me step by step what to do? I have sales records with me having all the records for the last eight hours, what to do, I just messed everything up. I don't know what to do. And then at the call, he just described a procedure to be for his job. That procedure or a general solution, let's see the solution. He said number one, start from the first record, there may be several columns of the record, the customer name, the customer phone number, the customer email, the customer products that he buys and the total sales. And in the point one said, he said, start from the first record, and focus just on the sales column. Okay, then, then after that, go to each next record one by one, and find the record with a maximum sales. Obviously, once you have focused on the sales column, you're just comparing sales of different records with each other and will eventually come up with a record that have maximum sales. Number three. If there are more than one records with maximum sales, it is possible that the maximum sales value let's say is 100, whatever the units are, and there may be two or three or maybe five records with the maximum sales 100. Then which one to pick, as described here in Step three, that if there are more than one records with maximum sales, then pick the first one from top to bottom and ignore the rest I mean, whichever is the sole. So let's say you have five records with maximum sale value, which record appears first from top to down, just pick that one and ignore the rest. That might be a policy that might might be a tie breaking policy, but just do that. And then the fourth step is focus on the email column of the record you found in step three. In Step three, you found a column with maximum sales. Step five, see the email address and write that address in the priority records. So that's for the eight hours, then repeat this process, see the step six, then repeat this procedure, after every eight hours, I'm gonna repeat this procedure, I mean, you'll see the the solution a is communicating to be in in this in these kind of steps. It it gives me It gives a precise idea of what to do. Still, there may be some, there may be some questions to be is maybe asking, for example, B may ask how to find out a maximum, B might be that person who don't know how to find out the maximum. And third, for example, another question we might may ask is that when when I'm going to write the email address in the priority rock records, where should I write at the very top or at the end or somewhere or, but at the end of the day, a solution a step by step solution is required for communication, this kind of if you see the solution, although it has some it may be explained in there may be more steps that should be added, but if you see the solution, the step by step solution, this is a general solution. This is a general solution, much more general solution for every instance, but every instance I mean, after every eight hours, you will be having some records, and you have to do this procedure on the records for that eight hours. And then after that, that after that eight hours, you will be having more records to work on. So after every eight hours, you have the same, the problem is the same, but the instance is different, because the records after eight hours are different. But but the but the solution says whatever the instance you are right, right now, whatever the instance is that you're in, just perform these, these steps, a step by step solution, coming up with a step by step solution is is one module of the one module of the problem solving. And there's step by step solution is called algorithm. algorithm. Obviously, the step by step solution is not always required to be communicated in plain English or in natural language, you may come up with shorthands or shortcuts to explain these step by step solution. So, the the more shortcuts the more precise and unique meaning keywords you use in your step by step solution, the more better communication of your solution takes place. And going from this step by step solution, which is just in plain English, going from this to a more concise and unique kind of procedure, that that can that kind of work that one step that will take us from there to there, that we will see in the next video will be called a pseudocode. And from that pseudocode there will be few steps that will take us to the second major problem that the problem problem languages will solve the get the solution running on a computer. So I'm just just in this video i i wanted to explain you that solving a problem may not be that hard, I mean, coming up with a coming with coming up with a solution of a problem may not be that hard, but communicating that solution or, or writing that solution in a form of procedure that can solve every instance of that problem that that requires a step by step treatment of the procedure. And those those steps they should be linked in a sequence and they should be unambiguous. And if a particular step requires more elaboration, that step might be broken down to further steps. But that step by step solution at the end of the day is called algorithm. Now that algorithm might be in English, but we will see in the later video that there are better ways of expressing algorithms better than English or better than natural languages. So, so, if you have another problem come up with a step by step solution of that, though, every instance of that problem should be solved by that step by step solution, which is called algorithm. And in the next video, we will see how to actually how to actually eliminate the need of having English with us and how to incorporate the uniqueness of understanding of these steps or algorithm using using the concepts of pseudocode. And after the pseudocode, we will see it will be very quick to jump to any programming language and we will see that the Python is very close to what humans generally think, I mean, it's very easy, the transition will be very, very easy. So, hope to see you in the next video and I'll be explaining algorithms in in, in a in a more kind of keyword way. And, and in the same video we'll be focusing on pseudo codes which are basically pre step off of the actual core of any programming language. So, hope to see you in the next video. Okay, in in the last video, we were talking about the algorithm what an algorithm is and how to express that any any algorithm and we saw that algorithm is just a step by step procedure. But, but how to express an algorithm may vary, I mean, you need not always to have plain English to or any natural language to express algorithm. The reason is that the natural languages are normally so expressive, and each and every sentence they may have multiple meaning. So, it is it is a good idea to come up with a structured way to express an algorithm such that each and every statement is completely unambiguous. And one such way is is to express algorithms using flowcharts flowcharts are our graphical ways of expressing algorithms. Here we are taking. The problem here we are discussing is is computing PE of different employees of some company. And the procedure of I mean, if there are several employees, let's employ one employee to employ three and so on. Let's say there are several employees in a company and having each employee has name, phone number, email and all the credentials. And then let's say the pay is computed on hourly basis, and each employee has worked certain hours for example, eight hours and each employee has an hourly rate might be let's say 100 units, whatever the units are employed to might have worked for example, seven hours, but the hourly rate of this employee might be 200 different employees, they might have worked for different number of hours, and each employee can have a different hourly rate depending upon the capacity of the employee or the or the job nature the employee is doing and so on. So, so, so, if we want to compute pay of all employees, one by one, the procedure of computing pay is stays the same, the instances they differ for employee one, the value of our is eight the value of Raiders 100 for employee to the procedure will stay the same the values of our end rate they will differ so what should be the procedure, the procedure might be that you take the take the input of let's say employ one or whatever employee you are going to compute salary for take the hours hours value in a in a placeholder call that place or call that placeholder as ours placeholder or a variable y this is called a variable because for different employers this value will different will be different, ours will take value eight for each one employee one this this variable, this placeholder will take value seven for employee two and so on. Similarly, once whatever employ whatever employ for which you are going to compute the pay, if you have taken the hours from some records from some working records, then take the rate for the same employer as well. So input this that step one in Purdue that is step two, the steps the sequence of these two steps may change for example, you take the you take the rate value first and ours value later than that, but either way, that's one way of that's one way of expressing this this procedure. And then you compute the pay by this formula. So hours multiplied by rate. So maybe this is confusing writing a star. Maybe maybe We should write this cross symbol because that is more common in mathematics. Or maybe this whole line can be replaced by, by this particular line, maybe. So pay is equal to multiply hours. And rate. Maybe this is more expressive, but it completely depends, I mean, when you start writing pseudocode, or whatever pseudo codes you're writing, what kind of keywords begin is a keyword and is a key word, what kind of keywords you're using, and stay with those keywords for example, if the keyword input is to use to take to get the values to to process on then the input should stay everywhere wherever we want to do such kind of operation. If you if you're using for example, the value get rather than input then use get always but come up with some set of keywords that are expressive, as well as concise and then take the sequence of those statements, each and every statement should be should have a unique meaning, it should not be ambiguous, and the sequence should be in the sequence describe the flow of what is happening, what is going on. So, first we take hours, then we take rate these two values for for for any kind of employee, and then we will just multiply them and after multiplication, whatever the scene we want to make, based on this pay, we will do that, we may we may record this value, display value at at some other records register, we may we may print that value on a print slip, we may have emailed this value to some other department or whatever to see and we want to make, but the procedure really is still here, then based on pay whatever action we are going to do that that may differ. Similarly if we go this is this is I mean, some kind of structured example of, of the, of the expressiveness of an algorithm which is called pseudocode. And what kind of keywords you're going to use, there are no general keywords, I mean, some people may use get some people may use different kinds of keywords for it, but it is good to come up with a set of keywords to to describe the describe the solution of the solution of the problem in flowchart for example, everything every every statement here, that is here in in pseudocode every statement is described as a shape different shapes for different kinds of statements. If you want to take input, then you have to describe that action using a parallelogram. If you're going to do some computation, you have to express that using a rectangle the start symbol and end symbol the start and end of any procedure in flowcharts they are described by the ovals For example, this oval in that oval normally the flowchart sequences from top to down, but it is always good to just print the arrows to describe the flow, because in complicated flowcharts there are there are loops there are if conditions there are so many things. So it is good always to describe the flow using using arrows. So, now the question is flowchart or pseudocode because flowchart also looks like a very cool way of writing. expressing an algorithm and pseudocode is also a way of expressing an algorithm. Well, converting flowchart to actual programming code is somewhat tedious, writing a pseudocode beforehand, which is readable, which is precise, concise, as well as unambiguous then converting that pseudocode to code of any programming language, that is not that hard, that is simple in writing flowcharts for very complicated problems is somewhat tedious, because then it It also requires another transition from flowchart to reactive programming code. That's why writing pseudocode is more feasible, if the goal eventually is to convert that pseudocode to some core of programming language. So, you can go with flowcharts you can go with pseudocode either one is fine, but more feasible way of expressing algorithms is a pseudocode. That was just a very simple example. I mean computing, computing salary of an employee writing a procedure for that. I mean, this is so simple, nobody make your writing that kind of writing solution. have this kind of problem as a as an algorithm or as a pseudocode as a flowchart. But the basic idea is, is is is the same, even if you have a complicated problem if even if you have a problem with maybe many more steps, the idea is still the same. In the in the next video, we will we will see a procedure how to how to make tea for example, that might that may look look to you funny, I mean, do we really want do we really want to know the procedure to make tea? Well, the idea is not to learn how to make tea, the idea is to learn how to express the solution of this problem making tea that's a problem, the solution of this for how to how to express solution of that problem as as a pseudocode. And we will see one more example of flowchart as well. So hope to see you in the next video. Okay. In the last video, we saw flowcharts and pseudocode, we just took an example of we took a very simple example computing salary or pay of employee of a company given hours and rate. And I also described weatherflow, the the comparison between flowchart and pseudocode. And I said that pseudocode is closer to the core of some programming language, which eventually we need, because eventually we need automation of of a solution of a problem. And for that, we need a code of the digit the code for the solution, the general solution in some programming language, so flowchart and pseudocode, and then the core of some programming language like Python, it is somehow in sometimes handy to to break the problem or to devise a general solution of any problem for in first step in a flowchart because that is more expressive, and more generic, more general, maybe in a graphical way. And then once the proof of concept is clear, once it is clear that this is indeed a general solution, it has no bugs inside it has no errors, it will work always, then we can take another step to convert that flowchart to pseudocode. And then pseudocode can be converted to the the code of any the code in some programming language. But writing pseudocode right away, I mean, from the very beginning without flowcharts is also a common practice. Either way, whichever way suits you. In this particular video, I'm going to talk about problem the problem is making tea. You might be thinking, what are the different instances of this problem I'm in making tea is making tea. What what kind of different instances are there? Well, one person may be liking tea with, for example, 1.5 units of sugar, whatever the units are, and another person may want a tea with, let's say, two units of sugar, one person maybe, maybe needing a D with, for example, point five units of milk, and another one, maybe a different units of milk, and so on. So the procedure of making tea should stay same. And the instances which means the different people want tea in a different kind of combination that may vary. So let's let's like let's see a procedure first and flowchart. And then in pseudocode, for for making a tea, for making tea. So let's start that that might look like that might look you look to you a kind of funny kind of problem. But that's a genuine problem. For example, if you want to make tea, what is algorithm for this? So first we start and then the first step we do is we put teabag in a cup, that might be a first step. You can argue should this be a first step should that be the second step and so on the sequence of By the way, solving one problem, you can have multiple algorithms for that. And do different algorithms may just vary because of the sequence of statements even if you have the same statements. So I'm not talking about that the algorithm or the general solution is unique. You can have multiple different general solutions or procedures. So for example, putting a teabag in a cup that might be first step, or the first step might be the boil, boil the water and pour the water and pour the water in the cup and then put the tea back. Both are fine, I mean this way or that way. So let's start with putting a tea bag in a cup. So that's an that's an input. We take the tea bag from somewhere. That's our input last time, I do You that input is taken as parallelograms put a teabag in a cup and then forget about that cup and boil the water somewhere there is a water I mean take the water from somewhere and boil it and see if after let's say five or six or seven time units whatever the time units are, see if the water is boiled or not assume that there is a test that tells you that the water is boiled or not. So, there is a test available to you. So, you apply that test and check that the water is boiled or not if it is not oil then keep on boiling. So boil it again. And assume there is a procedure of boiling of water in in in normal case, boiling water is just happened by I mean keeping the temperature high or putting that thing putting the pot of water on fire or something like so, but that that itself is a procedure. So, while the water again and boil the water again check if the water is boiled if no then boil it again. If not boil again then check if no then boil it again this is called a loop this is called a loop or repetition you are doing the same kind of stuff again and again. Until there is a particular condition that is that is met. So in this case, the condition is when while the water is not boil, keep on doing the same procedure again and again. This is called repetition or loop. So you boil the water again, check the condition if the condition is true, for example, the water boil Yes, then come out. Then you're then you can exit this loop and come out. Then pour the water pour the water in in the cup. Here we should hear we should describe that is that the same cup or a different cup? Well, this see you pick up here is acting as as a placeholder where this tea bag and the water is going in. So we have a cup, we put teabag in it, then we put the boil water in it, but before pouring the boiled water in it. We just boiled the water. Okay, and then after we have water in a cup and a tea bag in a cup, what should we do next? We actually we actually first test one sugar or need more sugar? If yes, then then add sugar. So let's apply some arrows. If yes, add them add sugar. And then again ask do you need do you need more sugar? Or one sugar now? Yes, add sugar. One sugar. Yes, add sugar that is again a loop that is again a loop while while the while you want sugar. I mean you test that the sugar is okay or not. Here you test that the sugar is okay or not or whatever sugar you need. If Is that okay or not? Until that condition is not met, you keep on adding the sugar, add a teaspoon again, then test out a teaspoon that is again a loop or repetition. Once the condition is met once you know then exit this loop and ask what milk because some people just take tea without milk. Maybe somebody wants a milk maybe somebody don't. So want milk? Yes. So add milk. So that's that's a mistake this this loop should go there. There right there. And this line shouldn't be there. That's that's wrong. Add milk and then ask what milk? Yes, admin, that's again a loop. Once you exit the loop, then you ask need to steer. Yes, steer, then ask again. This line again shouldn't be there. So that that's another loop. Once you exit this loop, then the T is ready, you serve that D finish you're done with the procedure. Now let's see the same procedure in pseudocode program is the keyword and that's what program name is program make D what is a keyword put teabag in a cup while water not while while is a key word, while this is not while this condition is not satisfied, keep on doing this. Whatever written in while and while is is the body of this repetition are called loop. So while water is not boil, boil water. Then again check water boiler not know what again. I'm in keep on boiling. So this is repetition. Once the water is boiled, which means this condition is becomes false what not oil becomes false so water boil, then you exit this loop, you pour that water in cup, that's again a key word, you in a cup, and then you ask, okay, need sugar? Yes, add sugar, need sugar, yes, add sugar. So you keep on doing this until you don't need sugar anymore. So, that's again a loop. So, so, you might be thinking that why we are writing this add sugar and this boil water to writer to this this why we are really indenting this that style of pseudocode to just display that this is inside this this is this particular statement or set of statements are called the body of the loop and this end Oil should be here in this alignment here in this line and so, there is a there is a bug in this slide this should be here okay once this condition is false sugar needed no then you can exit this loop and you go here while milk needed yes add milk, check again milk needed yes add milk milk needed yes add milk. Once this condition becomes false milk needed no then you can exit this loop, you can just go to here. While latest here need to steer steer D need to steer yes sturdy he was there yesterday, once this condition is false get out and your tea is ready Do whatever you want to do. This example was so simple, but it expresses a very powerful tool in in the pseudocode as well as in flowcharts. And that tool is sometimes called loop which is there to repeat a particular procedure whatever procedure you want to repeat again and again to until there is a particular condition that is met that is loop loop is there. So, the The purpose of this slide is was just to just to make you make you convinced and make you comfortable with the pseudocode and flowchart we will not be talking about flowcharts any further from here on we will we will be just talking about pseudocode in just one or two more videos. And then we will be directly going towards from we will be we will be comfortable enough with pseudocode for solving certain kinds of problems that we will then eventually be moving from pseudocode to actual Python code. And and I bet you I'm going to tell you that the pseudocode in the next video I'm going to explain that will be very, very easily will be converted to the actual exact Python code. So in the next video, we are going to actually solve a problem of finding out minimum value from a list of values, sometimes called the searching problem, we're going to solve it by first using pseudocode. And then in a later video, we will see how to write the actual Python code for that problem. So hope to see you in the next video. Okay, let's dive into real problem. Let's say you're given, you're given a list of numbers, let's say, let's say l is some list. with numbers, let's say we define list by these, these square brackets, let's say the list contains 23. Let's say that's a value minus four, that value is zero, that's a value 73. That's a value, and maybe maybe minus 10. That's a value, maybe 13. That's a value. So let's just take an example that we have 123456 values in a list. So and that list is basically we took the list here as L and we just describe that let's say the list is declared by or expressed by the square brackets, and the elements of the list, they are separated by comma. That is just our convention for this kind of problem for this problem just for this code. And And I'm not talking about any particular programming language yet. This is just a list of numbers. And let's say we want a procedure that finds out the minimum value of any list. Well, first of all, why this problem has multiple instances. Well, we need to come up with a solution that works for any list for example, if the list is if the list has these six values, then the procedure should find out the minimum In this list, the minimum value in this list out of all the values is minus 10. Because minus 10 is smaller than every other value. 23 is bigger minus four is smaller than 23. Zero is bigger than minus four, because the, the value with negative sign, it is smaller with the value of a positive sign. But if you have two values with negative signs, the value with a bigger number, in terms of magnitude is actually smaller in negative sense. So if you compare minus four and minus 10 minus 10 is smaller. In minus in minus domain, in positive domain, the result is different. So I was talking about why this problem has multiple instances, why you need a general solution for that, that's less just go and find out the minimum that is minus 10. Go home happy? Well, we need a solution that works for another list. Another list with different numbers. And maybe different number of numbers. Maybe in this list, we have six numbers, another list may have 74 numbers, another list may have 1 trillion numbers, we want to come up with a procedure that always finds out the minimum value in that list. Obviously, the minimum value may repeat, I mean, the minimum value may occur more than once in a list. So what is a minimum value rather than knowing how many times that occur, what is the minimum value, that's a problem finding out a minimum value, and we want to find out, we want to come up with a procedure that finds out the minimum value, regardless of the list, whatever the list is, this procedure should actually return or end up finding out the minimum value. So, in this particular case, again, for this particular example, the minimum value is minus 10. And we will take example of this list, and we will see how to code a procedure for that. So but but before starting this procedure, what kind of things we really need to to, to write a pseudocode. For this kind of problem, we may start by writing that program, like in the previous video, program name as search. And then we take input or input list, then we take input, the number of values in the list the total number of values, and then we move on as as we want to move on. But writing out a procedure in terms of pseudocode, it is always good to to avoid these input statements inside the pseudocode. And always supply whatever whatever needed, always supply the instance, from outside and assume that the instance is supplied and then just work on that instance. Rather than reading the instance. Rather than taking the values of instance, a particular instance from inside the code, it is always a good practice to, to, to supply the instance from outside, so supply the list from somewhere, and this n is really the size of the list. In this particular case, let's say if this is the list, then that list will be there, supplied from somewhere, but we'll see how to supply that. And this n value here, in this particular case, the N value is six the total number of values in the list 12345, and six, these are six values. So it is a good practice to rather than writing program and then this, just write the name of the problem you're going to solve in this particular case the name is search minimum from list. And then this particular we are talking about this list l with total number of elements as n whatever the values inside the L is we do not know and and this n may take different values, l can be different, this n can be different for different instances. But it is not a good practice to take input from inside here. Then, one more convention is that, let's say list of two represents the second element in the list. In this particular case, L of two is basically L of two is basically the second element in the list, which is minus four, L of let's say three is the third element in this list, which is a zero, and so on. So let's let's take a convention, that whenever we want to access the elements of the lists, whatever whenever you want to read the elements from the list, we will read the element number by giving the element number here let's say whatever the if we write L of AI, that means it means the ayat element of the list. So, first we take a variable, we are assuming here that the list is supplied to us the total number of elements in the list is supplied to us. So we first take the minimum value, we, which we really want to compute the minimum value we want to compute, but any list can be supplied in this procedure. So what's the procedure, the minimum value that we want to compute, we just consider the very first value of the list in this case, the very first value is 23, we consider that is the minimum value. Obviously, that is wrong, this is not minimum value, minimum value may be somewhere else, or maybe this one may be somewhere else, but we are not sure that the first value in the list is the minimum value. But let, let's just hold on for a moment and move on. Let's say the minimum value is this here, this is called the assignment assignment. This min value is a placeholder or a variable, and I have assigned this value l one to it. Now, from here onwards, the min value will be will be will be having a value which is 23. In this particular case, okay, so min value is this, which is 23. Now, let's declare, let's declare another variable, which is called counter, we may need this counter. And let's declare this with two, why we are declaring this with two it will become clear later on. So now we so min Valley right now, for this particular list, the min value takes the value 23. So and counter takes the value two, these are two things for these two variables. Now, we apply a loop while counter is smaller than n smaller equal to n. Remember the value of n for this particular example is six, and counter here is two. So because counter has value two, while two is less than or equal to six, first check whether this condition is true or false, because if this condition is true, then you will go to the body of the loop, then this whole box will execute. If this condition becomes false, then you will exit the loop and we'll go out. So now counter is to the so two is smaller or equal to six. true false. That is true. So the condition is to two is indeed smaller than or equal to six, that is true. So we will go inside to the box and see what happens. Then what we will do, we will pick and pick a value from at the index counter. Right now the counter has value to L off counter means pick the value, because the counter has value to pick the second value, which is minus four and pick that value minus four from the list, pick that value and copy that value or assign that value to a variable v. That's a new variable we maybe needed somewhere okay. Previously the min value which is a variable, it was containing the very first value which is 23. Now we have picked the second value the counter value is two. So we have picked the second value from the list, which is minus four. Now we compare if the value now which is minus four is that value smaller than our minimum value. So far, the minimum value so far is is 23. So minus four is smaller than 23. Yes, the condition is true, if the condition is true, we will go into this block, otherwise we will go into this block. So right now the condition is true. So we will go in this block and minimum value will just be replaced by the new value. And the new value right now is minus four. So because a minus four is smaller than 23, so we are here in this body, the if condition becomes true, you're in this body, and the minimum value becomes whatever the value is in V and right for this example, the value in V is minus four. Okay? So if if if you go into the if condition, then you're not going into the else part, either you're going to F part or in the else part one of them. Okay, so then we move back Oh, there's a bug here we need to add the counter. We need to increment the counter here after after this. Before this. There is another statement increment the counter. increment counter. That's another statement increment counter. So Now increment the counter after this if part increment the counter, and the counter will become three. Now, we will repeat the procedure and check three is smaller than six, yes, we will go inside, and we will pick now the counter value is three, we will go and pick the third entry. And now the third entry will be in V, the V will now contain zero. Previously it contained minus four now it will contain zero min value is containing minus four now, so zero is smaller than minus four, no, if zero is smaller than minus four, then do this. But zero is not smaller than minus four, then go to the else part. And as far as just saying just go on do nothing, I mean don't do anything. So when you're here don't do anything except if condition increment the counter again. Now, you increment the counter the counter value will become four and the value add for is 73. First of all check for is smaller equal to six Yes, we will contain the value at index four which is 7373 is smaller than minus four no do nothing and given the counter check the if condition check the while condition now counter will be five five is smaller or equal to six Yes, pick the fifth entry because country's fifth the fifth entry is minus 10 minus 10 is smaller than minus four yes okay. Replace min value with the new value. Now the min value will contain minus 10 okay because if has executed else will not execute, you exit the if condition and then you increment the counter the counter will become six. Now six is smaller equal to six Yes, because six is equal to six hence the condition is true. Now, you go and pick the sixth entry which is 13. Check 13 is smaller than minus 10 because min value is containing minus 10. So far, no that is false go to else condition, the two else part just go on to nothing, increment the counter, now the counter will become seven and you go back and check the condition seven is smaller equal to six false exit the loop. Okay, exit the loop, go to this condition, go to this statement. Now Now you're out of the loop and return the min value. And see the min value here is containing the actual min value which is minus 10. So that's how we search the minimum, this return is also a keyword. So which means if we if we just if we just if we just use that function, if we if we just use that pseudocode with if we just use that pseudocode for this different kind of lists with with its sizes, whatever the list, this is this was just one example if we chain the list, the procedure will work one one bug in in the code was the increment counter statement was not there, it should be there after the end F and before this end while here. So this that was the pseudocode of searching a minimum. In the next video we are going to use this pseudocode and we will we will see how to rearrange the values of a list or sorting the values of lists such that all the values that are smaller they become earlier than the bigger values. And the problem is called sorting. So in the in the next video we are going to talk about one more problem, very famous problem called the sorting problem. And after that problem, we will be going towards Python. Because after that problem, you will be having a fairly good idea how to solve a problem how to write a pseudocode for a problem. And the way we are writing the pseudocode is very close to the actual Python code which will become so clear to you. So hope to see you in the next video. Okay, in the last video we talked about we talked about this how to find out minimum value from a list of values. And we came up with an algorithm with name search men from list. Here we have just made a little modification that rather than just returning the minimum value, we are also returning the position of the minimum value in the list. So for example, if the list is 17024, let's say in nine letter that's our list. There are seven numbers in the list, the minimum value is zero. so the value the minimum value itself is zero, but that appears in position three. So when when this procedure will end, the min value will contain zero and the ID x which is the position at which the value the minimum value was achieved that will contain three So, not only we are not only we are finding out the minimum value, but also we are finding out the position of the minimum value. This procedure, our pseudocode actually describes a very simple, very simple concept, you consider the very first value as a minimum value and the very first position as a position of the minimum value, and then traverse the list element by element and, and see if you find any value that is smaller than the minimum value so far, if that is found, then replace your minimum value with the new minimum value and update your position number. And then keep on moving till the end of the list. So, so that's what, that's the concept behind the behind this algorithm searching minimum from the list. And to traverse the list we use this loop while loop. So next we solve a problem called sorting problem very, very famous problem in computer science. So the problem really is let's say we have a list, let's say 14035. And seven, let's say and the sorted order the ascending sorted order is the order in which the list is presented so that the minimum value occurs first, then the second minimum, then the third minimum, and so on. So the sorted order for this particular list will be this, so this is the result, this should be the result of this sorting procedure. So let's see how can we solve this problem, we named this algorithm as sorted list and sorted list contains this L. In this particular case, the L is simply this. And this n is the size of the list. In this particular case, the size of the list is six, so six, and right now l two is empty. So although we have to populate l two, but right now it is empty. And counter again, we initialize the counter with one. And as as long as the Conqueror is smaller than six, we keep on we keep on moving inside this, this block, that's the that's the body of the loop. So what we do is we pass the list and the size of the list. And we use the previous algorithm to find out the minimum from the list. So the minimum from the list will be found as zero and its position will be found as three. So min value will contain zero, and Id x will contain three, then what we do, we pick this minimum value and insert in L two l two was initially empty. So we insert in L two, we insert the minimum value, which is zero so far. And then just in the original list l we delete the value at the position index. So for example, the index position is three, so we delete this particular value. So what we really do is we delete this value, we delete this particular value. And the list now becomes with size 1234 and five, so what we do is we decrement the size with with one and then we move on now the country is one again, the N value rather than six. Now the N value is five, so one is smaller than five, but the list has no zero now in it because it was deleted, we searched the minimum again, and we insert the minimum in the list. Now the minimum will be one in the new list. And we delete that value from the list. And we decrement the size we keep on moving, eventually the list l two will be populated like so. And once. And once this value of n becomes negative, which is minus one with we will exit the loop and we will return the sorted list. But see how this sorting procedure actually uses the algorithm that we that we defined in in RPB previous video. I'm not talking about that this kind of sorting algorithm is the most famous sorting algorithm. There are efficient algorithms very great kind of algorithms for sorting. But the idea here is not to actually teach sorting the idea here to actually come up with the pseudocode for this sorting problem. And also to show you how you can use the pseudocode how you can use existing pseudo cores as as instructions in in other pseudo codes. So that's all about problem solving. If you really understand the selection sort and all that procedure really well, you're actually very good in problem solving, at least the problem solving is that we encounter in the logic that we need to solve different kinds of problems in computer science. In the next video, I'm going to actually convert these pseudo codes to Python codes. What do you need? Doo doo doo, right this sortlist procedure in actual python programming language, and how will you change the search minimum from list in actual python programming language, we will see the Python details bit by bit in detail, starting from right zero and ending at the very high details of Python. So, in the next video, I will just be showing you how to convert this code. But when we will start learning Python, we will start from zero and we will see each and everything of, of Python in in detail. So don't worry. In the next video, if you see, I mean, things like lengthy chords in a very beginning, these are just because we have arrived at a pseudo code. It is very, I'm just want to show you how the pseudo codes which are very across expressible, how they can be easily converted to Python programming, just to show you the power of and simplicity of Python programming language. So in the next video, I'll be converting these pseudo codes to Python code actual programming code. So hope to see you in the in the next video. Okay, in the previous video, we just get a flavor of problem solving by using this selection sort called the sorting procedure. The idea was just to use this procedure to solve this kind of problem. And we saw in detail, not in that detail, we just just brushed up but we saw how to write a pseudocode for solving a problem of sorting, which requires actually a list to be sorting in ascending order. For example, in this video, I'm going to convert first this code search minimum from list, you see that code, you know that code completely, we're first going to convert that code in Python code, and then we will convert this code in Python code. So see step by step, what changes are there. First of all, in Python that we will see in detail. When you define procedures, different kinds of procedures, they are called functions in Python. And rather than writing this, we have to write a def statement before it and then whatever name we want to write out, the rest of the thing stays the same, except at the very end, we have to write a colon. That's the syntax of Python. So the changes from here to here is a def statement, which defines that is used for defining def for define. And then at the end, we write a colon. Next thing that we will see in detail, don't worry if you if you're if you just see that why we're messing up with lips. So early, we will see that things in detail. But just to compare the in pseudocode. Normally the lists are indexed the indexes of the list start from one. But in Python programming language, the first index of the list usually starts from zero. So they are the minimum value was the first value of the list here, the first value is actually the index and Python is zero, rest of the things are same, you declare the variable as in pseudocode. The same goes exactly in Python. They're the because the index was one. And so the counter was one more than whatever the index was. Here, the counter is simply one, we need to right here ID x ID x equals to zero that we just missed. In the previous the ID x is one, so here the ID x is zero, that's okay. Okay, then next, we write while counter is less or equal to n. Same thing while counter is less or equal to n here. So here we just write the, the colon at the end, we might have written this equal sign here, this equal sign, we just missed the equal sign the equal sign is there. So now, but see that see the difference here, the violet goes that way, here we have a colon at the end, rest of the things are exactly the same. Now, v is equal to L counter v is equal to L counter the same thing if v is less than the minimum value, same thing if v is less than the minimum value in the pseudocode. Python is exactly the same. Just see the colon at the end, we have colon at the end of the while statement, we have colon at the end of the definition, we have colon at the end of the if statement. The other statement in pseudocode. In Python exactly the same. Now, in pseudocode, we have l statement. In Python, we have l statement. If we want to write an else statement, we have write a colon at the end of that. Then in Python in pseudocode, we have a past statement Python in our past statement, same things in pseudocode. We have n def, just to describe that this f ends. In Python, everything is described by the indentation style. So if this indentation goes on, if we have If you're here, then this is goes if this if goes out, so we need not write ends every day. Similarly, the vile body has this indentation style, this is all the while body, whatever that is, that is earlier than this is not in the wild body. So, rather than writing the tokens and while and if the Python handles everything using indentation, so no need of end if no need of end while Oh, we haven't, right, we haven't written a counter here. So we have to write a counter plus plus here, so counter. So the same statement, we missed this statement in the Python code. So the same statement, exactly the same statement goes here. That's it. The rest of the story is same, we do not need an end search here. The goal here is to show that the pseudocode is, I mean, the way you write the pseudo codes, they are they're highly, they highly resemble with the actual code in Python, Python is that expressive Python is very, very high level language. I mean, the way the you the way you think the problem in the pseudocode, the actual Python code is much similar to it. So learning the Python is very, very simple. The simplicity of Python is really a great property of Python. And that's one big reason of popularity of, of Python. Now the return statement is same and everything is same, then we move toward the sorting. Again, we have sortlist, we have to write the Define def define, and then we have this colon out there, we have to write the colon there, then let's do is defined like empty, it's empty in Python as well. Counter starts from zero, because they are the list starts from index one. In Python, the list starts from zero, so we are at zero, while same as this one. Here we have this colon, maybe, maybe an equal sign, maybe an equal sign should appear here. I guess we are missing an equal sign. But either way, the code is more or less the same rest this statement exactly same as this statement, we have insert in L two, here, we write a band append function, I'm in Python, here with ID lead this in Python, we have a Dell statement, rest of the story is exactly same. So you see converting pseudocode to Python code is, is way more easier. This is this is not a this is not a formal introduction to Python. I mean, the the goal here in this video in these kind of session videos is just to introduce you with problem solving. But I I found this, I mean, I found this beneficial to show you that the pseudocode actually resembles to the actual Python code a lot, although we will be dealing with variables lists, while loops, if conditions, all these kind of stuff in them in a in a big and huge detail. When we in the upcoming videos, when we will introduce the Python syntax and variables and all that kind of stuff. Actually, you will be mastering each and everything in Python. And, and further, you may not write these lengthy chords to do stuff in Python, I mean, the whole dad thing is just you write l dot sort and you're done. I mean, you need not write a lot of lines of codes in Python. Here, I just here I just showed you that if you have a procedure, you can, if you have a pseudocode it looks like much like the same as Python, which, which actually tells you the expressive power of Python and simplicity of Python, and how it is closer to what you think. But the actual problem solving in Python does not require so many lines of codes, I mean, there are so many functions, so many powerful procedures. For those you just write one line and a huge amount of work is done for you. And there are very good one liners for Python I mean in for for for for programming in Python, you did not write a lot of lines of code to do some stuff. I mean a few lines of code even a single line of code does a lot for you. And for that you need to know the features of Python the feature of the features and the different kinds of syntax and features and libraries and the packages and what what is available with Python. I tell you almost each and everything is available just you need to know what is available. Once you know the what what what what are the things that are available. You need not to write lengthy codes you need now to build a lot of logic on yourself. Things are prepared, they're waiting for you, you just have to figure them out what are these things to do what what kind of features are there in Python, if you know that you are done. So you need not to be writing these kinds of codes and lengthy kind of codes. Although knowing that all knowing that is a is a is a huge advantage, but doing a bigger and bigger and bigger stuff. Python will give you a lot of features a lot of functionality that you need not to go into, and you need not write a lot of code for it. And that's the second power of Python. One is simplicity. Second, it gives you a lot of features a lot of functionality, a lot of built in stuff ready for you, you want to do something, it will be probably there in Python, you need to know where it is. And for that we have whole future series on Python to know Python each and every step in Python, and to know important packages in Python. Because knowing important packages and knowing how to code in Python will save a lot of time for you. So spending some time on learning Python will be saving a lot of your time. To solve the actual pure problem. Whatever problems you're doing, you're going to solve. And Python is a real programming language granting programming language, knowing this language is almost enough. So hope to see you in in the next videos where we will start Python from exactly zero. And we will see each and everything of Python in detail. Hope to see you in the next video. If you're new to data science, you may stuck in choosing the best language for data science. And in this video, I'm going to I'm going to talk about Python, which is the greatest language so far for data science. To explain the features of Python, let me first go back to a little bit history of Python from where it started. It basically starts in 1980s. It was introduced first in 1980s. But with constant improvements and a lot of bug fixes. It was officially launched in 1989. Nine years later. It was created by Guido van Rossum and it is open source which means it is accessible to everyone. Even though it's open source. It can be used for commercial purpose. The main goal of Python was to keep the code easier to use and understand. Its huge library enables data scientists to work faster with the ready to use tools it is dynamically typed. So the variables that you are defined that you are defining that they are defined automatically, you need not to set the type whatever the contents in bring in, the type will be defined automatically. It is more readable and uses lesser code to perform the same task as compared to other programming languages. It is flexible, portable, and can run on any platform easily. It is scalable, and can be integrated with other third party software easy. Python programming is easy to use, and has a simple and fast learning curve. new data scientist can easily understand Python, but it's easy to use syntax and better readability. So so that's what this point is basically it's it's really a beginner friendly if you if you're new to programming. Well, Python offers you a very easy environment to go on. It also provides plenty of data processing tools that help in better handling the data. Python is important for data scientists, because it provides a vast variety of applications used in data science, it also provides more flexibility in the field of machine learning and deep learning. It has, it has a lot of packages like TensorFlow, Kara's tiano. That is helping data scientists to develop specifically the trending deep learning algorithms very, very quickly. So basically, the sport, the sport of machine learning and deep learning is huge in Python. That's huge. As, as is the case with many other programming languages? It's available libraries that lead to Python success around around 72,000 available packages. In Python package index, sometimes called by pi, Python. Why? Python package index by by around 72,000 packages are available and they are good Constantly. So huge number of packages mature packages are available. It is free open source and consequently, any Can anyone can write a library package to extend its functionality. Data Science has become an early beneficiary of these particularly ponders The Big Daddy of all of them. The other great thing about Python is there are millions of users who are happy to offer advice or suggestions. When you get stuck in something, chances are someone else has been stuck there first. So a lot of community is there, a lot of packages are there, it's open source it it's easy to use, it's easy to learn. It's simple, it's readable, more close to human language, it's high level language, you code less you do more, I mean, you write a very few lines of codes, and you achieve a lot of work. So, I mean, I've spoken a lot of verbs here, too, too. I mean, explain that Python really is best suited language for data science. But let me let me introduce you some statistics about Python, the popularity of Python with respect to big with respect to its use, and with respect to the job opportunities that are there in Python. So for example, if you see this chart, in the ranking of top 10, languages, Python stays at the top. So that's the latest statistic, collected in 2019, February 2019. And out of the out of the total share of the languages, I mean, around 26%, just goes for Python, and the trend is moving up, which means the people are more interested in Python, I mean, the trend of using Python is getting larger and larger, as compared to several other languages like Java, JavaScript, C, sharp, bhB, C, our objective c, swift and MATLAB. I mean, many of them are used for data science, but Python stays at the top. I mean, this is that popular language. And further, if you see, for example, the job opportunities in Python so so that says, I'm in a different companies like Facebook, Julia, and I'm in Google and several different companies. This actually graph shows from 2014 onwards, that the job opportunities and job postings are in different languages are at what amount, and you can see the graph of Python, although starting a bit low, but then stays up and stays up, which means the 80 if you see the numbers 85% of the total jobs, there are just for Python. And not only, I mean, Python is not just for data science, it's a general purpose programming language, it's open source, it can be it can be used to perform any kind of task for embedded programming for, uh, for for posting, I mean, codes or embedding code on Raspberry Pi for web development and whatnot. You can you can, you can do the desktop development on it, you can use the web developer knowledge you can use the data science, I mean, I mean, this is general purpose programming language. In other disciplines do it is performing very well. But data science for data science, it is almost the default language today. So, I mean, if you're going to learn data science, really, we need Python. I mean, Python really is the choice, the default choice, and we need it. And in this particular course, we are going to, we are going to introduce Python to you with all aspects, I mean, we will start from the very beginning level. And we will gradually move towards the very advanced programming in Python, including the introduction to the data science packages, like pandas and matplotlib, for visualizations, and NumPy, for handling numeric data and stuff like so. So, in this particular course, we are really going to teach you Python, and we are not assuming you have any programming experience before. So and this is one plus of Python. I mean, whether you're an engineer, you're coming from health sciences, you're coming from biology, you're coming from arts, humanities, or from wherever. Python is something that is very easy to get hands on. So if you're not assuming that you have any programming background, you have any data science background nothing. So we will start from the zero and And we will gradually move to 200. So, and including the introduction to the data science packages. So Python is the best, it is a default. If you're going to work in data science, Python is the default. And we are going to, we're going to introduce you Python from the very beginning to the very professional. So hope to see you in this course. Okay, before actually discussing the best ID for Python, and particularly for data science, let's first discuss what an ID he is, as you start your coding journey, many of you prefer coding in a text editor maybe like notepad plus plus, where you write the code and then open a terminal window to execute your code. When there is an error detected in your code, you switch back to the text editor, correct your errors, typos and run the code again in the terminal, everything is fine. Typically, for large scale problems, however, you not only have to code but you also need to make sure your code works in all scenarios, which means you also need a testing module. Many times you have multiple coding and testing files, and switching between editor and terminal often becomes both confusing and efficient. So, an environment is needed, where you can write you can run and play with your code all at one place. So the one that provides you with the capability of not just coding, not just writing the code, but but also testing your code, running your code highlighting your syntax, bracket matching, auto completion, debugging your code, code suggestions, and and many more features. That is called an ID II or integrated development environment. Now, there are several ID is for different languages for for Python, there are several ideas for example, Jupyter Notebook is an ID IE by charm is an ID IE spider is an IP ID and thought cannot be whim atom and there are a lot more there are several of them. Now the question is for data science, in particular, what Id E is is the best or are what people suggest to be the best. So before actually showing you the statistics that which one is the best before actually showing you the actual numbers, the statistical numbers that shows which one is better, what are the other let me just go through a few of them few of it ease and their features and stuff. And then we will move to move to statistics and some numbers that will show that which one is better over the other. So let me start with with this Jupyter Notebook. For the past couple of years Jupyter Notebook has been gaining a lot of popularity in terms of coding and debugging. notebooks have been redefining the concepts of an ID E and are adding more and more features on to it. Jupiter was introduced in 2014 after its predecessor ipython and from that date, it is really considered to be a bless in the coding community. Jupiter stands for I'm in some people say Jupiter stand for Giulia Python r but that I come in that acronym does not mean just this. I mean Jupyter Notebook today is supporting more than Giulia, Python and R and by the way, this Giulia Python, R and R all these are open source languages for and they are best suited for data science. This Jupyter Notebook, it has markdown editor. It allows you to write HTML code, it allows you to write latex in it. I'm in a lot more. Further this Jupyter Notebook. It's a web application based server client structure, which is easy to use and allows you to create, analyze, and manipulate documents. And all these documents are in the form of notebooks. Since it's a web web interface, it can integrate with many of the existing web libraries. For example, for data visualization. Jupiter has so many functionalities you can write formula using labtech run a Python code and visualization. For example, a raw audio signal using matplotlib plotting library, all in the same notebook. Jupyter Notebook is not just an idea he but it's widely used and an educational tool for presentation and even for writing blogs. You can export your notebook from iPython Notebook formats to PDF or to HTML or even to.py, which is the Python file. The user interface of Jupiter makes it a favorite tool, especially amongst the data science community. And one plus of this Jupiter is, it's it's very quick to start, I mean, very easy and very quick to start, I mean, not much rocket science to write your first goal, you want to write your HelloWorld it's very, very quick. And you're better to go and do that. By charm, if I discuss pi charm, however, if I discuss some of its properties, and let me just discuss, first that the pipe the PI charm is by the company JetBrains. And if you have never used japin JetBrains other IDs like Java ID, then running your first code successfully can eat up a little bit of your time, actually, a large amount of your time maybe such as I mean, setting an interpreter by charm. By charm, however, is, is much better for, for working with multiple scripts, handling multiple files and linking them together and huge large scale coding products. The good thing about Python is it supports Anaconda. And as a result, all the packages that fall under Anaconda are supported by char pi charm as well. And those packages in including NumPy, Sai, pi matplotlib, and so on. Just like other IDE ease pi charm has a powerful debugger. With a graphical interface. It offers jet integration, it has skills, shell terminal and worryin control system. Python, it is customizable, which allows you to choose between different themes, color schemes, and key binding and whatnot. Additionally, Python lets you add plugins for non pythonic files. And these plugins take care of indentation highlighting the errors and keywords just on the fly. So Python is also providing I mean, a huge support for coding Python. But, I mean, the one bad thing about Python, which is not that bad, but one bad thing is it is memory intensive. It eats up a lot of memory. It's a heavy thing. And secondly, I mean getting getting getting started with PI charm is not that quick. I mean, it takes a lot of time to just go with that. Spider however, is a lightweight, open source ID Oh by the way, this by but this by charm is is is not I mean it has Professional Edition and and Community Edition and it does not open source completely. Spider however, is a lightweight open source, ie that comes pre installed with Anaconda. And it was built mainly for data science practitioners and engineers. Its look and feel is much like MATLAB. So if you're a MATLAB programmer, if you've used MATLAB before, you switch to Spyder and you get a mean much look and feel the same cannot be by the way the unthought cannot be also has roughly the same look and feel as MATLAB So, but spider was built for data science community, it is integrated with essential data centric libraries like NumPy, Sai, pi, matplotlib, pandas, ipython, and whatnot. The built in capabilities can be extended further by plugins and API's Spyder contains features like text editor with syntax highlighting code completion, static code analysis, debugging variable exploring, it also has profiler that recursively determines the runtime and number of calls for every function and methods call in a file. And I mean, there's no thought cannot be there is a vendor's atom there are a whole lot of it is just for Python language. But But the question really is being a data scientist, which one is which one should you choose being a beginner? which one should you choose? Even even for professionals, if you want to stay in data science, which ID he will you prefer over the other? I mean, there are so many of them. I have just described three or four of them. So let's see some stats based on popularity of different IDs for data science, and then decide which one is better over the other. So for example, this data this this analysis, that the chart I'm showing here, this analysis by was was done by Katie nuggets and The link for that and it shows that the most popular Python editors till December 2018 and you can see that the Jupiter is at the top, the second is pi charm, then spider then Visual Studio code and sublime tags, then add on atom women there are so many others, but Jupiter is at the top and this is for I mean, these all are listed with respect to the data science community. So in the data science community which Python ID he is best over the other and, and Jupiter Jupiter is at the top I mean it is it is way out. And one reason to this is its simplicity. It's it's supporting to so many different formats. It's it makes an interactive document it makes it makes a web page that is interactive, you can just change the code you can make another web page and so on. You can you can run it on a local system you can run it an online survey system and whatnot I mean it has so much flexibility and very quick start and easy to use. If you for example see the popularity of Python IDs with respect to the employment then then you can see overall the the Jupiter has been a winner as compared to pi charm spider also your code and sublime if you see company or self employed still the Jupiter is V out it has been if you see for in a student perspective, Jupiter is the choice. If you go to academia or university, Jupiter is the choice if you are working with government or nonprofit Jupiter is the choice I'm in Jupiter is I mean Jupiter is kind of outlier it is it is staying at the top everywhere. Further if you if you analyze the popularity of Python, it is with respect regions for example, again, overall, Jupiter is a winner. If you see US or Canada Jupiter's most popular mostly used Europe, Jupiter is the winner Asia, Jupiter is the winner, America use Jupiter sevinor effect Africa and Middle East Jupiter, Australia, New Zealand Jupiter. I mean, these numbers are suggesting that Jupiter is is at the top, not just at the top. It's easy, I mean, and maybe that's one reason why Jupiter stands on the top for the data science. So these numbers and these all statistics suggest that we should use Jupyter Notebook for Python. And we will be doing that. In fact, for this particular course we'll be working on Jupiter for all kinds of coding. And in the in the next video, I will be just showing you how to install Jupiter environment how to install basically Python and how to run Jupiter for the first time from it. So I hope to see you in the next video. Okay, in this video, I will show you how to install Python. There are multiple ways of installing Python you can go to python.org and install Python from there I would recommend to use Anaconda distribution it has Python it has a lot of packages pre installed it has Jupyter Notebook as well. So installing through Anaconda is easier as well. So if for example if you are working on a Windows system you should download the executable for Windows we will be working with Python three rather than Python two. So you should be installing you should be downloading Python three point whatever the latest version is. Further if your system is 64 bit you should be installing 64 bit version otherwise you will be installing 32 bit version. So let's say you have downloaded the executable file for Windows then after the download you just from that xe file and follow the steps and you'll be able to install Anaconda once the Anaconda is installed then in the search bar you just type Anaconda prompt and the Anaconda prompt kind of symbol that my mouse is pointing at this will appear in front of you, you just run it you will see a command prompt like so. Then in that just type Jupyter Notebook and press enter and you will be having Jupiter running in front of you. Let me let me show you that on my on my system. How to do that. Let's see. For example, this is my search bar. Let me type and conda prompt so this is the Anaconda prompt. So if I click it, it runs then I just typed for example, Jupiter note book Then I just press enter. For the first time it will take some seconds to run. So let's wait for it. So yes, it runs and it will show you kind of browser in front of you. And that's what the Jupiter into interface is. We will see then how from this Jupiter how to write the code how to make the code files and stuff but that's how from Anaconda installing after installing Anaconda that's how you will launch the Jupiter. So this is that easy, no problem. Then, for example, you can install you can install Python if you're working on Linux and just download the version for Linux. And then rather than For example, let's say your your your file is downloaded in the Downloads folder then run this command bash and this.sh that's the file name. The installer prompts in order to continue installation process this I'm in these kinds of commands will will appear Press Enter to Continue then press Yes, and the installer will finish with the thanks message. After that, you just go to downloads folder and type Jupyter Notebook and the Jupyter Notebook. interface the browser based interface will appear in front of you. You can have if you're if you're working on Mac, you can you can in you can download the Anaconda distribution for Mac, then you'll find an anaconda Anaconda navigator, the launchpad you can launch that and then just click there's a Jupiter icon in front of you just press the Launch button and you'll be having your Jupiter running in front of you. So in this video, we just talked about how to install Python. If you install Python using Anaconda you will be having Jupyter Notebook as well. In the next video, we will see how to actually use that Jupyter Notebook interface for example, I work on Windows, so I'll be having this kind of interface although the interface looks like same because it's a browser based web based interface. In the next video, I will show you how to get comfortable with Jupiter and we will be also writing our first HelloWorld program in Python. So hope to see you in the next video. Okay, so in this video, I will show you how to write the first program in Python basically the HelloWorld program. Before that, in the previous video, I show you I showed you how to launch Jupyter Notebook. So once you launch Jupyter Notebook, whether you are working on Windows, whether you're working on Linux or Mac, whatever, when you will launch the Jupyter Notebook, you will see this web based interface. And here you are in the right corner you can see the button new, you just click it, you will select Python three, and you will see a beautiful interface in front of you that will allow you to go here, there are a lot of file edit view there are a lot of parents kernel and a lot of controls here we will see them as we move on. But this is how you this is this is what the coding environment is this is kind of editor as well as I mean this is complete, ie interface in front of you. So let's see this interface a little bit. Step by step at least the controls that that we need. First of all, you are seeing where my cursor is moving. That's the file name or the notebook name. You can change the notebook name or you can just write for example. Whatever the name of the notebook you want, for example, mastering by Thorne for beginners. Okay, so let's say that you're mastering Python, let's say let's say zero to hero, maybe. So let's say this is your filing, you just create that file and you'll see this mastering Python zero to hero that file is created with this file is renamed. Second. This is a cell in which you are going to type your code. The code, I mean, the two modes of writing is one is you can write the Python code. Another way is you can write the markdown. The markdown is important in in a way that if you want to describe your code, if you want to write other stuff other than Python code, you can use these markdown cells and they We will be helping you. For example, if I select this markdown, and I just select this markdown, and I type here, for example, this is by THON directorial. And then I press Shift Enter, it will appear as a heading. And a new cell will be graded down. This is also a cell. But this is a markdown cell. As you can see, now in this cell, that's a code cell, you can switch a cell from code to markdown by just pressing an escape key, when you press an escape key, you will see the color will change here, you can press Escape key, then if you press M, it will change to markdown. And if you press Y, it will change to a code cell. There are several I mean shortcuts that are available keyboard shortcuts, if you if you just see, if you go to help and see this keyboard shortcuts, there are several shortcuts that will be available in front of us. For example, if you press escape, and then press F, you can do the Find and Replace operation. And if you press enter, then that will go into Edit Edit Mode, if that's important, if you press Shift, enter, the cell will run and the new the cursor will go into the new cell. And there are a lot of controls you should be seeing most of them, I mean, getting a good grip on these controls will help you moving in this Jupyter Notebook very quickly. So for example, this is a Python tutorial that's a markdown cell, you can also create this, this cell also as a markdown cell. And then you can type here for example. This is our first program in Python. It there it is just started here, for example, and it just appears like like a description. And again, a new cell is created down and there you can write your code. So let's write the first Python code HelloWorld. So first of all, you will write Brent Brent command will allow you to print anything on the screen. brantas says double codes, starts ends. And in the double code, you write whatever you want to be printed on the screen, for example. Hello, world. And once you have written that code, just press Shift and enter, and this code will execute in front of you. So that's HelloWorld printed in front of you. And that's our first program, I mean, writing the very first program in Jupyter Notebook. is is that easy. Not only that, this Jupyter Notebook will be created, you can you can just I mean describe anything, you can write the headings, you can write HTML in it, you can write math, using lattic. And for example, let me let me write lattic, or mat in front of you just just let's say you're making a notebook that requires some mathematics in it. And it allows you to write mathematics as well. For example, A equals B plus C, Shift Enter, and that appears like a mathematical equation, not just this, you can write very complicated equations. I mean, and and, and this whole notebook will contain your descriptions in terms of HTML or latech, or descriptions, and code and all that mixed up, whatever. And at the end, you will, you can, you can just download this. You can just download this, this notebook, as if you want a PDF file PDF file. If you want a notebook file, it's an output file if you want to latech if you want just a Python file if you want slides, for example. I mean, you can download the same thing as slides. It will make slides for you. So there are a lot of ways of using this notebook. And that's a ready made document. I mean, you end coding, the document is ready for you. So this notebook is really, really powerful Jupyter Notebook and coding in it is not just the coding. I mean, it is Preparing a document. If you want to prepare a document, you want to describe anything you want to add images, and at the end of the day, it will be an HTML document for you. It can be shared on web. I mean, it's ready. Nothing we we want to further finish it. So that was our HelloWorld program in Python. We will continue to build this byte mastering Python zero to hero notebook, we will continue coding in that we will describe the headings we will write the markdown cells and all that stuff. And we will at the end of this course, you will be having one notebook with all kinds of descriptions and code in it. You can use that notebook afterwards, we will be building well one notebook, one complete notebook for Python. So that's about it. That's the hello world. In the next video, we will see how to what are what are the constructs in in Python, what are variables and other stuff. But before that, I also wanted to show that this notebook is an enhanced worryin are the upgraded version of ipython shell. And I also want to show you ipython shell as well. So in the next video, we will just see the ipython shell and we will see how can we how can we view Python as just as a calculator by using ipython shell. So hope to see you in the next video. Okay, so in this particular video, I'm going to show you the ipython shell just open up the Anaconda prompt as as before, like you want to open a Jupyter Notebook, then you just type here Jupyter Notebook. And you will be you will be in the in the notebook word Jupyter Notebook word. But if you just type in ipython and press enter, then a prompt is open for you in a colored way. And this is perfectly fine to write any kind of Python code in here. Actually, the Jupyter Notebook is more enhanced and more featured the use of ipython. Basically everything that I bought, that is there in ipython is there in Jupyter Notebook as well. But it has more features more documentation and stuff. So for example, if I just write a Python code here, hello world, let's say it will work in ipython shell as well. But remember, previously in in Jupyter Notebook, we type Shift Enter to run a particular command here, we just press enter and everything will work. If you want to clear the screen here, whatever the whatever we typed here, if you want to clear that, just press Ctrl l if you're on Windows Ctrl l will work on Windows. Now ipython is just like, you can use the Python in this particular shell just like a calculator, for example, you want to plus three, press enter, that's five, let's say it's nine multiplied by seven, the answer is 63. You can write a complicated statement as well, for example, 45 minus eight is static, or multiplication, static is achieved by multiplication is achieved by a static symbol seven. And then you can have this minus then divided by two and just press Enter. And that's the answer 16.0. If for example, by the way, I have just press the up arrow key and last command just appears. I have pressed up arrow key again. And the second last command appears. I press the up arrow key again and the third last command appears and now I'm pressing the down arrow keys. So for example this and you may have whatever the result is, you may have that multiplied by 10 and minus or or maybe plus plus 15. So the result is minus 145, and so on. So this Python ipython shell, you can write very complicated are almost I mean, the complete Python coding can be written in ipython shell. And you can use this shell just for a calculator. Now let let's see, for example, you you compute this result, let's say 45 minus 45 minus nine and let's say you compute this result, whatever the result is, and you save that result in a symbol, let me call that symbol as a variable. In here the variable is So let's say you save that in a, and then you have another variable, let's say B, and three static 45, or maybe three steric 2.6, that is saved in B. Now, you have you have done this particular calculation, you know that 45 minus nine is in a, the result is in a, and then you have this particular result that is in B. And now, you just want to add the two results together, and you want to print the what what normal calculators does not have the support of saving the results and reusing them. But here in Python, even if you just want to use the Python, just as a calculator, you can declare as many variables as you can and you can save the previous results, you can retrieve the previous results. And you can use the previous results, save new results and so on. These kind of symbols that are used to save the results, and then they can be just used afterwards, these are called variables. And our next video will be on variables, what are these variables, what are the types, what kind of variables the Python supports one way or the other, if you want to go beyond calculators, you need certain results to be saved and retrieved retrieved afterwards. And the variables are are the constructs the variables are the features that actually do that. So the calculator is fine, you can use this ipython shell just as a calculator. But if you want to do interesting programming, complicated programs, I mean, you want to achieve a task that involves much more calculations one way or the other, you have to save certain results in somewhere. And then you have to combine the results together because the longer problems in normally are broken up into smaller piece of problems. And each smaller problem has a result that should be saved somewhere and afterwards the several results they should be combined to achieve the result that we are after. So these variables are required if you are going to do some interesting or complicated calculations or computations. So you, by the way before, before having these Jupyter Notebooks spit out just the enhanced version of this ipython shell, the iPod ipython shell just people used to write a lot of Python programming just in ipython shell. And even even today is several people are writing their code complete code in ipython shell. But the the Jupyter Notebook is more enhanced for the enmore documented more, I mean, it has better interfaces and several features that are better than just using ipython shell. So you have seen this ipython shell, it's very powerful, great, everything is fine with it. But we will be using Jupyter notebooks, which are just the enhanced variants of this ipython for our upcoming coding. So the purpose of this video was just to was just to introduce you with ipython shell and just to tell you that you can use Python just as a calculator and even more than that, and in the next video, we will be introducing variables in Jupyter Notebook and we will see the Python or Python is really really much more powerful than just a calculator. So hope to see you in the next video. Okay, in this video, we will talk about variables and operators the operations that you can perform on on variables. A variable in a very layman term is basically a symbol that stores some data that can be used later on. So for example, this x is a symbol corrector or a symbol y is a symbol x y is a symbol normally, and these are called names of the variables. For example, this is a variable name x, y is a variable name y, x y is a variable name itself. Now, these variables, they can store different kinds of data, I mean, whenever you want a particular data to be used again and again, it is better to save that data or label that data by a symbol by a descriptive name so that you can retrieve that team retrieve that data by using that label or symbol. So one way or the other. This this variable actually is a description of the data that you want to use our store and you want to use later on in your program. Different types of data are there, for example, the integer type data. For example, if the data you want to store is integer type, it's a number And the number is just the integer number it does not have a decimal point expansion that is a type of data and that can be stored in a variable in that in that case, the variable type itself will be integer, you need not to specify the type of variable when you are storing the data to it the storing data to a variable is sometimes called assigning data to a variable or assignment. For example, if your variable is x, and you are assigning a value let's say two, then two is integer value its integer it does not have a decimal expansion and when to is assigned to x, based on the content to that to basically is an integer type value, automatically this the type of x is set to be integer. And that is sometimes called the dynamically typed Python is dynamically typed language or dynamic typing, you need not to specify the type of the variable the contents that you are assigning to a variable, they will define the type of the variable on the fly. And the assignment for example, in here I'm storing two insight x and next time if I want to print for example, what is there in x the the print value will be two. Now, this kind of symbol is hot right there is no keyboard symbol that looks like so, so rather than writing this symbol for assignment, normally an equal sign symbol is used for assignment for example, x is equal to two that means two is assigned in x five is equal five is equal to five means five is assigned in y 7.2 equal x y equals 7.2x y is completely a new variable, it has nothing to do with x or y. And it is handy sometimes to to to suggest the name of the variables that are too descriptive that are very, very descriptive to increase the readability and management of the code, because later on you will you will be seeing when you will be working in data science and other stuff. The programs that you will be writing might not be very short programs, they might be lengthy programs. So readability of a program and management of a program becomes an issue if you if you if you do not assign the names of the variables carefully. However, if you write the names very in a very descriptive way, by just writing the name of the variable by just creating the variable symbol or or or the name, it tells a better look and feel of what kind of data inside and what should I do with that. So, I was talking about this equal sign this equal sign is used for assignment. Here for examples when 7.2 is assigned to a variable x y, automatically the type of x y variable is set to be a floating point integer floating point number a float is a data type in in Python that describes that the particular data is a real valued it may have a decimal expansion as well not just integer and floats are the only data types in Python, there are several others for example, you can define complex numbers if you if you want to you can for example, defining a complex number might be for example, you write the name of C and you write two plus four j if you write the symbol j here, it automatically becomes complex. And now you can you can use this see the way the complex numbers should be created. Similarly, there are other data types like fractions decimals, there are there are further data types, the objects called strings. For example, if you if you if you assign let's say s equals double quotes Hello then that S is also a variable and the type of this variable a string string is just a sequence of a lot of collectors, where he is a collector is a collector L is a collector L is a collector always a collector W is a vector. And when we will define anything, any sequence of characters inside the double quotes and then ended the double quotes here, or the single quotes, single quotes and double course either way, then the type of this is become strings. And these characters should be created as it is. Like for example, if we have another variable s two and we just say one, two, in double quotes. Now this s two is no longer 12 as an integer. It is a sequence of characters where first character is one and other graduates two, we will talk about strings in detail in the upcoming videos but just to give you a look and feel that Python actually supports a lot of data types, a lot of interesting data types including the most important data type is integer float and string as well that we will see in detail. Further you can assign you can assign more than one values to more than one variables in in a single line there is sometimes called multiple assignment. For example, if you write a comma b equals four comma 5.00, then four will be assigned to a and 5.0 will be assigned to B. notice one thing although 5.0 looks like an integer, but when you when you write a decimal expansion, it automatically becomes float. So, if you Now type the type, if you now check the type of a it will be integer and if you check the type of B it will be float. Once you have declared a lot of variables, they stay in the memory they occupy a particular space inside the memory. For example, x is just a label to a memory inside the memory that is to located somewhere. Similarly, y is also located somewhere in memory. And similarly x y is also located somewhere in memory. And this is the data inside that memory. These will stay in the memory and the occupy the memory. If you if you decide to no longer use a particular variable and future in the in the program, then you can call this function d l space, whatever the variable name, and it will delete the it will delete the variable from the memory like it was never there. And once the variable is no longer in memory, it is it is not accessible. If you now access the variable again, you will get an error. Let's see all these concepts. Let let's see most of these concepts in Jupyter Notebook and let's let's actually, let's let's actually define certain variables, use them, print them, do some multiple assignment and see a lot of stuff in in Jupyter Notebook. So let's go to Jupyter Notebook. So that was our notebook that we were doing, that we were actually working on the last time. So let's say I define a variable X, let's say x is two. Why not? Why not? I should describe this. as what we are doing here is let's say variables. So just to give a heading that we are now in variables, so variables, notice that now I'm in a code cell. Previously I was in a markdown cell, notice this change in this particular cell, this is markdown in this particular cell, this is code cell, C that goes, Okay, x is equal to let's say, three, let's into this. Now x is assigned a value three. If you want to know how many variables right now are there in the memory, we can write this command whose This is a percentage symbol, if you write percent a symbol and then just type a command, w h o s, it will tell you all the variables that are on right now that are there in the memory. And right now the memory has a variable with name x, its type is integer, and the data inside the variable is three, that's the memory view that you're now seeing. Okay, if you want to explicitly check the type of x, you can print type x. So for example, this function type will will actually find out the type of whatever variable you give inside and then this print function will help you printing that on on the notebook. So if you see the type of x, the type is basically its integer type. Now, if you for example, change the value of x as three to let's say, 5.7. So you have same variable, but you just change the value from three to 5.7. So let's see what happens now. So if we call us again, we have now the variable name is still x, but its type automatically it's type automatically change to floating point number, because of because we assign a floating point number to it. And this is the data if we want to explicitly check the type of this x, that would be class float now, further. Let's say we have another variable ABCD. That's a variable name, let's say and we assign a value 55 six Point, three, two, that's that's the value. If we now called whose function whose command, we will be having two particular values, one variable as ABCD, its type is float. another variable is x, its type is float, and that is there. If we, for example, do a multiple assignment, for example, a comma, when you write comma, first variable finishes, second variable starts A, B, C, D, F, let's say these are five variables. And if you assign five values to five variables, again in a comma separated list, 356, point 07, point two, and let's say minus three. So if you enter that, and you now check the status of the memory, because now all these values are assigned to the respective variables, if you now check the memory view, a is an integer type variable with value three ABCD, the old variable that we assigned earlier, it's already float B is also integer, it has value five sees float, sees float all those 6.0 looks looks much like integer. But when you when you write a point explicitly, it becomes it becomes a floating point number. So D is again, float with 7.2, f is integer, it's minus five. And x is the old old variable that we know already. Now, if we, for example, delete a particular variable, if we for example, we we no longer want to use ABCD variable ABCD. That's one variable that we don't want to use in future. And now if we see again, the view of the memory, we don't have this and if we now want to access this, for example, if we want to print this ABCD, we will get an error, we will get an error and we should we should get an error because this particular variable does not exist in the memory, it points to no data, it has gone, it has gone like it was never, it was never there. So that's about the variables. We just talked about integer and float, there are several other variable types as well. For example, let me just give you an example of an example of a complex number, if you are really interested in that's a complex number if you print its type so that the type is complex. Similarly, you can have a string variable, let's say hello, how are you? That's a string variable, if you bring the type of this you will get a string we will we have a whole set of videos just on string data type, because this is very important data type we will we will see that in detail. But the purpose here is just to tell you that there are a lot of data types that Python supports and Python is dynamically typed whatever content you are assigning to a variable the that content decides the type of the screen you need not to specify. So I end this video here. In the next video, we will be talking about operators basically what kind of so once we have decided once we have declared once we have defined a lot of variables, what we can do with these variables, can we add two variables together and get the result stored in another variable can we multiply two variables together, can we have an operation like addition or mixed types for example, one variable is a floating by number and other variable is integer number integer type, can we mix up those can we add two different types of variables together and get a result then what will be the type of the result and so on. So a lot of these discussions on operators the very basic arithmetic operators on these variables, particularly the integer and float variables, we will see that in the next video, so hope to see you in the next video. So in the last video, we saw variables and we particularly saw integer type variable and floating point, variable type. We also saw very briefly on Jupyter notebooks are complex, and string as well. So in this video, we are going to talk about operators, basically the arithmetic operators. Obviously, if you are defining variables, you're not defining the them the variables just to just to view them later on. Most probably you will be storing data to the variables and then you are you're applying some computation on a set of variables together. Comparing new results saving that and doing some stuff, most probably you will be adding to variables some one way or the other in inside a program, you may have to add two variables, you may have to subtract a variable from the other, you may have to divide a variable you may have to compute for example, these are arithmetic operators, let me let me just this this plus symbol is used to add to variables. This minus symbol or subtraction is used to subtract a variable value from the other variable value. Obviously, these all are operated on values, not the names. Division, it like like the name suggests, it's if you want to divide this this person to a symbol when it is applied to two different variables, if x is on left and y is on right, what it does it, it actually divides x by y, and checks what the remainder is, for example, if x is 27, and y is five, then what's the remainder? What do you think? If we divide 27 by five, what's the remainder the remainder will be? Two Yes, so the result will be two here. So this computes the remainder. This multiplication this star symbol is used as multiplication like in mathematics, we normally write this cross symbol. But in in Python, and in most of programming languages, Star symbol is used to achieve multiplication. This double slash is like the division, but it is division with the result flow to the quotient. What I'm saying is the following. For example, if you divide, let's say 10. by three, the result will be a floating point number, and the result will be 3.33. Something like so. But if you want just the quotient, not the remainder, if you want the integer, that's the quotient value, then you write the double slash three, and it will return just the value that is that is there before the decimal expansion. So this value will be returned. So this is kind of the integer division or floor division, this double star is used to compute the power. For example, if you want to compute to the right doublestar, four, that means two raised to the power four in mathematics, we write this as following. And the result will be 16, you can save that result in another variable, or you can just print it or you can write that in a file of whatever. So these are most important. operators. One thing that I want to tell you that these operator are not just for integers and floating point numbers, the applications of these operators is much broader than these later, we will see the objects or the data types that are collections. And very, I mean, the data types that are beyond these integers and floats, and still there, this plus minus division, and all some of these are all of these, they have their meanings there. Even even even this plus is used for strengths. Now think for example, if you have a string, let's say hello. And you have another string, for example, let's say this is string s one, and you have another string, let's say s two, which is why then Python allows you even to add these kind of data types, although some doesn't make any sense with these kinds of string variables, but we will see four different kinds of data types. The the definition of these operators, they actually changed or adapted accordingly. For example, in mathematics, we are much more fluent a four with plus with Debian with subtraction, and it makes sense to add two integers to subtract a floating point number from another floating point number and stuff, but with data type that is unfamiliar to you right now, these operators may not make that sense to you. But there are definitions there, there are ways to use these variables. For the data types that are even there or even beyond an integer and floating point numbers, we will see all these details as we move on, as we move on to as we move on to the videos. And I mean, as in later on, we will see all these things in detail, but just to tell you that these operators are not just limited to integers and floating point numbers or complex numbers, they can be applied to several different data types. So a lot of words, I guess you were born Now, let's go to Jupyter Notebook and have fun with these kinds of concepts that we are dealing with. So yeah, here. So let's first press escape, then m just to change it to markdown and then good scape one for heading begetting. And here I write, let's say operators, and shift enter its runs and automatically then go to code. Okay, now let's say I have a variable. So let's say what kind of variables I already have. In the previous video, we use that. So we already have these kinds of variables with us. Now, what is let me define a new variable, let's say sum of sum of A, B, that's a new variable sum underscore AB, that's a variable name, you can have a better way you will name maybe some of A and B, that might be a variable name. It is good to have the variable names that are descriptive that describe what data is inside. Because in in programs, the programs become manageable, readable, and a lot of benefits are there. So Sum of a and b, let's say that's a variable name. And you add a, b, you just write a plus b. Let me make the zoom level a little high so that you can see it clearly. So a plus b, let's say that's there. If you press Shift, enter, and now your brand. Some of By the way, if you have written some of you need not write everything, just press tab, and it will automatically complete the remaining part of the variable and press Shift Enter and you have eight. If you check the type of this variable, some of tab automatically completes tab complete that is called tab completion, while it's integer, the type of this particular variable is integer, that's a new variable and why and the type is integer because a was integer, B was integer. And integer plus an integer is an integer. What if we add an integer with a floating point number? What do you think? What should be the result? If I just type type? A, that's an integer plus d with some floating point number. So a plus d, the result will be here, and type of that result. What will be the type of that result? What do you think? Let me pause here for a few minutes, and oh, no, no, no, not for a few minutes. For a few, maybe seconds, maybe two or three seconds, what will be the result? What will be the type of an integer and a float combined? Well, the types are up costed, which means the floating point number, the result will be a floating point number. And the reason is, every integer by default is a floating point number, a floating point number is a is an upper class, or you can say a superset. So in Python, in Python, by default, the types are up costed to super super sets. So here integer plus a float, the result will be a floating point number. And that's a result, you might be thinking why we have why we haven't stored the result in another variable. Well, if we want to store the result in another variable, we can, or if we just compute the result and apply some operation on that, we can do that. For example. We could do the following, for example, a plus d. That's whatever the result is raised to the power three, whatever the result is, whatever the result is, divided by maybe four. And we just save that in a new variable. Let's say. Let's say the new variable is V. Let's say we save that value, and V. And now we print we, and we have the result for me. Wow. So we can do a lot of stuff with these kinds of variables. Let me show you a fancy stuff that we will see later on. Don't worry if you don't get it just as one, for example, as one is Hello. Hello, and let's say s two is world. And we have another variable, let's say s, which is s one plus s two. What it will do is it will just concatenate them together. We will see strings a lot later on. But just to tell you this plus is not just for not just for numbers, it is for other data types, very fancy data types that are there. One more thing, let's say we define 10 and we divide it by Three, and we want a quotient, the quotient is three. However, if we have 10 divided by three, Shift Enter, the result actually is 3.33, and so on, you might be wondering we have not saved that result in a particular variable. So where the result is saved, actually, if you do not, if you do not save the result, if you do not assign the result, for example, in this way, the result will be assigned to a variable or, but if you do not assign if you do not store the result in a particular variable explicitly, by default, there is a variable in Python, which is underscore underscore contains the last result that you did not store in a particular variable explicitly. So, that underscore is basically one default variable for for the result, if you want, don't try to update this underscore, just just read it Do not assign anything to underscore. For example, if you assign something to underscore assignment will be done, but then the properties of underscore will no longer be there as they are in in Python built in properties. Okay, so, that's about it, I guess. So that was the operators, we will see the operators more and more later on. But before ending this video, I leave you with a question. So the question is, we saw the variable names like, Sum of a and b X, Y variable name can be can be lengthy can be descriptive can be short anyways. So the question really is, can a variable name start with a digit? For example? Is it possible that the variable name really is is starts from the variable name starts from for example, a digit? is a 3x? valid variable name? Or, for example, at the rate of at the rate of Why is that a variable name? Or, for example, this symbol times two times x, is that a variable name? What are the conventions to for variable names? can we can we write anything? In the left hand side? The right let's say 3x? Is equal to four? That means 3x is now a variable name. Is that true in Python? Or are there conventions to define the variable names? So? Yeah, think about it. See you in the next video with the answer to this. So I hope you will, you will be having answer for this question. Hope to see you in the next video. Okay, so in the last video, I asked you a question about the naming convention of the odd variable names. In particular, I asked you whether 3x is a proper variable name or not in Python? So what's your answer? Yeah. What do you think? How many of say, how many of you say no? How many of you say yes? Well, by the way, you might have tried that, declaring that variable name and Jupyter Notebook, and then you might have got this answer one of these? Well, let me tell you, the answer is no. A variable cannot start with a digit. Not with, not with, at the rate of not with hash symbol, not with I mean, there are several other special characters are not there except a few factors. One of those is underscore. Let's go to let's go to Jupyter Notebook and and check this. So, for example, 3x equals five error, invalid syntax, let's say activate of y equals four. Invalid star d equals four error. Well, an exception is underscore underscore E equals six, that's allowed. Starting a variable name with underscore is allowed, it is different than the underscore that is built in underscore this underscore E is different than simply underscore. So it is good to not declare the variable names that start from these because you will be getting errors further. variable names should be descriptive. They should give you a look and feel of the data what they are containing and you're free to define variable names, as as descriptive as you want. So it is a good practice to, to start writing the variable names in a better way. One, one better notation, one better notation of defining these variable names, even the function names, we will see the functions later on. One way to defining those is to use camel notation. camel notation camel notation is you start with the variable name with for example, lowercase letters, let's say your variable is starting time of the course. Let's say that's your variable name. So you write starting, that's one word finishes, then the next word should start from capital T, starting time of the course, let's say. So this kind of notation is called camel notation. And very famous, particularly the Java developers, they normally follow this and several other developers. But you should come up with a notation that is one notation, there are other ways of keeping consistently keeping the consistent strategy of defining variables. There are several other ways this is one way. So starting time of the course is let's say 2.0. That's it. So that's a variable name, if you if you now check, that's a variable name. But now, if you see this variable, just just the name suggests the data inside is doing what? So the names should be descriptive, I mean, and make that as a habit. So, yeah, I guess we have now answered our question very concretely, that variable name cannot start with a digit not with any special character other than underscore, okay. In the next video, I will be introducing comparisons with with variables. For example, what if you want to compare whether one variable is smaller than the other or not? What if you want to compare whether the two variables they are containing values they are same or not? What if you want to do comparisons of the of the data that is stored inside the variables, and based on the result of the comparison, you want to do something else. So in the next video, we will see a bool data type that is very, very famous, and it is used in a lot in decision making. And we will see the comparison operator sometimes called the relational operators in the next video, so hope to see you in the next video. Okay, in this video, we are going to talk about a data type which is called bool. That's very, very famous data type. Actually, it's the most famous data type because it is used in decision making all the control flow most of the controls, so depends on this data type. Although it is very, very famous, very much applicable data type, it is very simple. It is a data type with just two states with just two values. By the way, there are capacities of different data types. For example, in T integer, the different kinds of values that you can store are huge, you can store any negative number in it, you can store zero, you can store any positive number, the capacity of floating point number or the number of values that it can save is is even higher than even higher than integer and the complex number is even higher than that and so on. But the bool data type, it has just two states one state is true. It has just two values. True is a value. And false is a value just these two straights true or false. In some programming languages, the true is denoted by one, and the false is denoted by zero. But in Python, the true is just t ru e true that thing and false is false. That's it. If you For example, define a variable let's say any variable name, whatever the name is, let's say B and you assign true then it's its default data type will become bool. And if you have another variable, let's see which is false. Then C is also bool. One thing that is important, there are other operations other than arithmetic operators that we saw, adding subtraction division and stuff, there are other operators that we can apply on bool datatype. For example, a true and and is a keyword combining true and true. If if there is a variable, let's say a with a There is a boolean variable a with data true. If there is a boolean variable b with data true, then a and b is also true. So let's say I've used this variable D, in storing this A and B, the D will also be true. So true and true is always true. Further true and false, this is always false. And this is committed if for example, true and true is true, true and false is false, false and true is false, false and false is false. So, if you apply an operator and keyword to combine the two Boolean variables together, if both are true, then and will result a true otherwise and will result of false other than this and there are there is there is another, there is another operator, keyword or so, this results false. If both are false, false, false, false or false is false. If any one of these is true, then the result is true. Remember the difference between n and R and will result false if any one of the two operands at least one of the two operands is false, then the result is false. If both are or are anvisa true, if both of the operands are true, otherwise it is false or will result false if both of the options is false or false. Otherwise it is true. So, you now know and you now know are there is another operator called not. This is not so not for example, returns not true. Results false and not false. returns true. Great. So knot is a unary operator. unary means it just takes it just takes one variable and operate on that, and is a binary operator like plus is a binary operator. It takes two variables to operate on, or is a binary operator it operate, it takes two operators, it takes two variables to operate on and so on. So remember, remember these things, one, and we'll return true if both of the variables are true, otherwise the result is false, or will result false. If both are false. Otherwise, it will return true and not is not just flips the the state. So not true means false, not false means true. So these are basic, that's how you can combine the Boolean variables together. In the next video, we will be seeing how to apply these comparison operators and the result will be Boolean types. And how can we combine the Boolean types together to to build a better decision making. So in this particular video, I just, I just introduced the boolean data type for you with you. In the next video, we will see where the boolean data type actually appears, and how it impacts our, our our programming style or thinking style or coding style. So hope to see you in the next video with comparison operators that actually produces the Boolean variables. Hope to see you in the next video. Okay, in the last video, I discussed boolean data type and I discussed that a boolean variable takes either a true or a false and we can combine these Boolean variables together with and our operators. And then we can apply a knot operator on a particular variable. And we we saw that a true and true returns true and and otherwise it also returns false. Similarly false or false is false. Otherwise, or always returns of a true before before actually discussing these comparison operators. Let's do let's just go to Jupiter and just just play with a boolean data type. Just Just for just for a moment. Let us just convert this to markdown cell and just cried. Both that's a word Boolean variable. So let's say A is true and B is true and C is false. False. And okay, so these are variables. Let's press those to see what are the states of. So, a is a boolean variable with value true B is a boolean variable with value true C is a boolean variable with value false. So, now it is true B is true, C is false. So that means, let me print print a and b, what do you think? What is what will be the result? Let me print a and see what will be the result. And let me Brent? C and A. So because a and b both are true, the first result will be true, because C is false, false, true and true is true. The the other two statements they will result false. So first value will be true, then false false. So yes, true, false false. Let's, let's check the or print. And by the way, let's store that are in another variable, let's say A is true, or C is false. So what do you think what will be the result here, because or gives false when both are false, here is true. So the value of d will be true for the not a, because A is true, not a will be false. Similarly, not B, B is true. So not B will be false. Not C, C is true, C is false, and not c will be true. Similarly, not D, we can save the result in another variable, let's say D. and we can just check the type of D if we want, that's a Boolean, we can also check the value inside D and that is false. So, yes, not only that, I mean, we can we can we can we can combine at a higher level for example, A and A and B, whatever the result is, or C or D, whatever the result is, and whatever the result is not of that. I mean, we can we can combine them in a very complicated way. If we want a and b the result will be some Boolean, that Boolean and that Boolean there are the result eventually will be a Boolean, and then not have that. So let's check what if that is the result is false, well, why the result is false. figured out why the result is false, let me go to comparison operators. So, the comparison operators, let me just go through comparison operators. This equal equal to it compares whether two variables whether whatever the variables are whether they are integer floating point, whatever, whether two variables are are, they have same data or not, for example, x equals equals two y. That will be true if x and y, they both have same data. So for example, if X has value four, and y has value four, then we are just checking x equals equal to buy or not, the result will be Boolean. Because an X may not be a boolean variable y may not be a boolean variable. If we want to compare the values of x and y, then we write w equal without a space inside. Remember, if we write single equal that will be an assignment operator. If we write w equal that means we are checking whether the two values are same or not. Similarly, if we write this particular symbol that checks whether two values are not equal or not, for example, x is not equal to y, the result will be true if x and why they both have different values, otherwise the result will be false. Remember, the result of comparison is always a Boolean, it is either true or false. Okay, next we check whether less than So for example, if x is less than y, the result will be true. If x indeed has a value that is smaller than y, let's say x is two and y is 10. In that case, the result will be a true otherwise the result will be false. Similarly, we can compare the two variables using greater than we can compare the two variables by less or whether whether the whether one variable less or equal to the other. For example, if X is less or equal to y, the result will be true of this comparison the result will be true if X has a value that is not larger than why as long as x and y are equal or x is smaller than y In any case, the result will be true otherwise false. Similarly, greater than or equal to. Okay, so I end this video here in the next video, we will be, we will be moving to Jupiter and playing with these operators, and seeing the return types of Booleans. And then combining them together with ands and ORS and doing doing interesting stuff with that. In this particular video, I just talk about the comparison operators, the boolean data type and combining them by and or not. In the next video, we'll be first moving to Jupiter, we will see the comparison operators, we will write all these statements in Jupiter and just get a good hands on grip on that. And then we'll be moving on verse. So hope to see you in the next video. So in the last video, I talked about comparisons, w equal to not equal to less than, greater than, less than or equal to, greater than or equal to. So let's go to Jupyter Notebook and see how they actually work. So let me just first enter a markdown cell and type comparisons. Shift Enter comparisons. So we can we can compare different values by first assigning them to variables. And then comparing those variables or we can we can compare the values directly or for example, rent. Two is less than three. What do you think two is lesson three, the result will be what Remember, the result of a comparison operator is always Boolean, it is either true or false. So in this case two is smaller than three. So the result will because this statement is true. So the result will be true and true will be counted. Further, we can store that result in in another variable for example to is smaller than three, whatever the result is, the result will be true, the result will be saved in a variable, see, if we check the type of see reject the type of seeing as long as let's print the value of C. So you can see the type of C is Boolean, and C in this particular case is true. Moreover, for example, let's have three equals to four. Is that true or false? What do you think three equals to four, three, w equals to four, that is false, three is not equal to four. And let's save this result in D, remember three double equals to four, that's an operation the result is false. This equal is an assignment operator that the false value will be assigned to the variable D. and here we can see Brent D. Burn it is false. Similarly, what do you think? Three double equal to 3.0? What will be the result? Remember, three is integer. 3.0 is a floating point number. And I'm comparing three double equals to 3.01 is integer, and other is a floating point number. So what will be the result? Let's say the result is true, because they are comparing the values by discarding the decimal position. Further, let's see. Three is smaller or equal to so let's say x is equal to four, y is equal to nine. And z is equal to let's say 8.3. And r is equal to minus three, let's say and these are our variables. Let's see. So what do you think what will be the result here x is smaller than y. What will be the result of that x is smaller than y, the result will be true and z is smaller than z is smaller than y. The result is again true because the smaller than y or r r is r is equal to for example, x. So what do you think what will be the result at the end after this, so, let's see first first this will be true, this will be again true, and that is false. Okay. So, this true and true will return true and true or anything, the result final result is true. So, this will return or it's returning true. But, if I just do if I just switch the order, for example, if I just write this statement, which is false, this particular statement here and then I do this, what will be the result now, Now see, x is smaller than y it is true, r is equal to x that is false. So, this result will be false eventually, and z is smaller than y, that result is z is smaller than y, let me just say z is larger than one, let me just check z is larger than y, z is larger than I just just do just to tell you. So, this is true, this is false. Both of these are let me let me switch the let me switch the listing r equals to x, I just want to show you the precedents of r and x is smaller than y. So now, if you see this is false, this is true, false and true is true, true or false and true is false, this is also false. And the result overall is false. It should happen, but what if, what if this goes first, if this goes first, I mean, I want to show you whether and an AR, which one of them will operate first. So, in this particular case, the result is false, but it can happen let me let me tell you this in more and two, or false and true or false. And true, what do you think what will be the result here, true or false and true, if true or false operate operate First, if true or false operate First, the result will be true, true and true, the result is true. If however, let me let me just write a false here. If all operates First, if all operates first, then false or false is false and false and true is the result eventually is false. And if and operates first, then false and true is false, false or false the result in both cases here is is false. So, a better way of representing these kind of sometimes sometimes they can make confusions, sometimes they can make confusions, for example, if we have a true here, if you have a false here for example, false and true How can I so, false, false and false or true. So, in this case, if in this case, if false or true that operate First, the result will be true and false and false, false and true the result will eventually be false. However, if n operates First, the result will be false here, false or true the result will be true. So, here if and applies if you apply if n is applied first, then the result overall result will be true. But if all is applied first, then the overall result will be false. So it is it is good to know whether and will be applied first or off will be applied first in this particular case and will be applied first even if you even if you change this even if you change this order for example, if you even if you pick this thing and apply here still the result is and will be applied first and or will be applied after, it is always good rather than to one way is to remember the precedents and will be applied first then or, I mean it is good to think about the precedents. Another good thing is to specify the order using parentheses. For example, now, we specify this first our will be applied and then four and will be applied. So, it is good for readability to always apply these parentheses and and check the order in which ands and ORS and the combination will be applied. So, the in any way the result of these comparisons will be bullions. Question, what will be the result here? So, not to not equal to three and true or false and true. See this slide for a while. Even if you want to pause the video, pause the video, see it? and answer the Brent will return true or false. okay with this question, I end this video. In this particular video, we just saw the comparisons on Jupyter Notebook. Just see how the comparisons return true or true or false. We combine the different tools and different Boolean values using ands and ORS. And here is a question for you. Okay, I will see you in the next video with answer of this question. So I left you with a question in the last video. So that was the question if you remember. So the question really was, what's the what's the result here? So what's your answer? True or false? The result, either will be true or false, because these are all comparisons and combination of Boolean values. So let's see step by step. First of all, let's see this two is not equal to three The result is two is not equal to three Yes, it is true, two is not equal to three That's true. So not true not true is false. So, this is false. So, this whole thing is false. Now false and true false and true that is false. So, this whole thing here till here is false. Now we have or or and then we have false and true false and true is false. So, this whole thing is false this whole thing is false and or between false or false it is false. So the result of this. So the So the answer to this question is is false. Let me let me just convince you by typing the statement in in Jupyter Notebook. So, if you remember we have Brent. Brent, not two is not equal to three and then we were having I guess and false and yeah, that was a different one. And true, sorry, that was and true. So this was and true, then we were having our and then we were having these false and true. So the front ends here and the result is Oh, I have some I have some parenthesis mismatch. So not true and this okay, I should have this one I guess this goes to there and this goes to there and I guess Yes. So the result is false. The result is false. The purpose of this question was not just to the purpose of this question is to appreciate actually the fact how we can combine different Boolean values to to to achieve the final boolean value and these kind of combinations will become very, very helpful further in in control flow and we will see the if conditions and decision making and stuff so The answer to this question is false. Yeah, and I end this video here. In the next video, we are going to see some useful functions of Python. And after seeing the some some kind of useful, there are a lot of functions, we will see just a few of them very useful of them. And after seeing those functions, then we will directly jump to control flow basically the if conditions and stuff where you will see these comparisons, these Boolean values in a much more applicable sense, then then earlier. So hope to see you in the next video. Okay, so let's have a very quick tour over some some useful functions in Python. Obviously, there are a lot of functions in Python, but I will be covering just a few of them. That I think with the passage of time, we will be covering more and more but let's start a function are sometimes, particularly a built in function is is basically a feature from the language that is supplied for the users to achieve particular task. For example, around function. If you give round for example, around, let's say 4.6. This 4.6 is a floating point number, and rounding means make it as integer. And what round does is it finds the nearest integer to 4.6. And the nearest integer in this case is five, because five is more closer to 4.6, then four. However, if you call round, for example, on four point, let's say three, then the result will be four, because four is more closer to 4.3, than five. So that's one use of round eight rounds, basically rounds a floating point number to the nearest integer. Another use of round is if you give another argument that that is called an argument to the function. For example, when you write Brent. Brent, let's say a, this a is called argument to a function Brent. Similarly, round is a function 4.6 is an argument round is function 4.3 is an argument, we will see functions in details, and we will be writing our own functions as well. But for now, just just bear that just bear with me that functions are these kinds of features that are available. However, we we will be writing our own functions later on. So this particular function accepts two arguments surround has two different kind of implementation. One is when it accepts only one input argument, it returns the nearest integer to that, if it accepts a floating point number as well as another argument like here we have three, that means after after point, after decimal, go to three places only, and then round up, then round, for example, this 4.55 and then eight will be rounded based on its next value. If the next value is larger than five, then eight will go to nine and stop. If the next value is smaller than five, then it will stay as eight and the result will be three decimal places after this. So let's practice this round function just on a Jupyter Notebook very quickly. Let's see. So here we are. So let's see rent around, let's say 4.556. And in this case, the result will be 4.5. And the reason is 4.5. And it's rounded up, it stays to five and the reason is this 4.556, it is more closer to five then than four. However, if you if you just print round, four point, let's say 345. Let's see, and the result will be for the reason is 4.345 is more closer to four. However, if you call this round function with more than one argument, for example 4.556789 let's say or with argument, let's do that means the result should be only two decimal places after the after the decimal point. So in this case, the result is 4.56. And the reason is, this five is rounded based on the next digit and the next digit is larger than five. Hence it is rounded up. So 4.56 If however, I call this function for three Then what do you think what will be the result it will be 4.55. And the six will be rounded up based on the seven, and it will become 4.557. Yes. However, if, for example, there will be a value at at the place of seven, if there is a value, let's say three, then you call this function, then 4.556. And then based on the next value three, the six will stay as six rather than going to nine, and the result will be 4.556. Yeah, so that's, that's the, that's the round function. Basically, another function is diff mode, diff mode function basically divides and returns quotient, and, and remainder. So in the next video, we will be seeing this diff mode in detail how it actually works and how, how it is useful. So in this particular video we saw around function in the next video, we will see diff mode, and there are a couple of more functions that we will see in the upcoming videos. So hope to see you in the next video. So in the last video, we saw round function that sometimes accepts one argument and sometimes accept two arguments and behave accordingly. In this particular video, we are going to see another function dev mode. And it accepts two arguments, two different arguments, but maybe same or different arguments. And it it returns two outputs, two numbers, two terms basically quotient and remainder. For example, in this particular case, the quotient is five, and the remainder is two, because if five is divided by if 27 is divided by five, the result is five, but then the remainder is two. And the result is returned in a kind of an ordered pair. And these kind of collection in which we have two or more elements, we call these collection as tupple that we will see in detail when we will see the data structures module of this course. But right now just bear with me that it returns two numbers, two elements, and the two elements are ordered in an ordered pair, which is called a tupple. A tupple is not just an ordered pair, it can have three more three, four, or five or seven, or maybe several elements. But right now we will a tupple is just an ordered list, which we will see in detail. So let's see the working of the stiff mode function in in Jupyter. notebook. Let's see. So let's say we have dev mode. Let's say for example, we have 34. And then we have lots of them. Or maybe let's say nine, so what do you think what will be the quotient and what will be the remainder. So 918 27 So three, three is the quotient. And the remainder is remainder is seven. So three is quotient and salmon is the remainder. So and if you save the result, for example, if you save the result in a variable, let's say G. So if you see the G the type of G if you if you just type the type of if you just find the type of ci it's a tupple, which we'll see in details, and if you see the contents of G if you see the contents of G the contents of gr three and salmon, and if you want to access each element independently, then you can access the element first element, because the if there are multiple elements in in a variable normally that that kind of variables are called collections that we will see in detail later on. And these are the indexing the positioning is start by zero rather than one. So g zero means the first element of G which is three in this case, and the second element of G is one at one, which is seven. So, this is basically this is called the index or position of of elements or data in this particular collection, we will see these indexing and all these kinds of collections in detail in in the in the data structure scores, and we will see arrays and strains and different kinds of structures. But and default sometimes is, is basically sometimes it is helpful. By the way you can achieve dev mode by by another by another thing. For example, if you want to achieve a more 34 nine, you can do the same thing by let's say 34 divided by double divided by nine that will give you a quotient. And the question is three and further if you write 34, remainder nine and that will give you the remainder that you need. So you can call that function Dave mode. Or you can use these two there are multiple ways of doing the same stuff. Okay? So, yes, so, I mean, sometimes it's useful when you're going and knowing this kind of function that returns quotient and remainder. Okay, next function that is more useful is is in stance, and we will see this function in the in the next video. So hope to see you in the next video okay, this function is in stance, it actually returns either true or false. And it just checks that particular given data value belongs to this type or not. For example, if you want to check whether one has type integer, so, you can check that using this function by the way, you know that one is of type integer then you may think that why on earth one should be interested in checking the type of one if somebody no it is in teacher, sometimes, we have certain variables and certain data is stored in it, and we want to check the data inside it belongs to which kind of type and in several cases the value to this variable is not assigned by us It may be read from some file or maybe through input a user give some number or something like so. So, sometimes it becomes important to check the type of a particular way if we are if we are expecting a particular type of the input and the input is different than this function might be helpful. somewhere. Either way, this is a function available in Python and it checks whether the given value has a particular type of not. So is instance one int returns true is instance 1.0 integer that returns false maybe, because this is a floating point number, and you can check a particular value belongs to one of the several types or not, you can give several types in a in a tupple. And you can check whether it belongs to this, this or not. So, let's go to Jupyter Notebook and see, actually how it works. So, by the way, this is the same notebook that we have, that we are populating. So, hold on with me, at the end of the day, we'll be having one notebook complete. So, is in stance is instance, let's say three is that instance of integer The result is true in this particular case, if for example, we check whether is in stance 3.4 is that nmt? Is that an end user? The answer is no it does not end in Deezer. If for example, we check if this is not in nature, then maybe it is a float? The answer is yes. Or maybe we check that. For example, if that value is either float or integer, if it is one of these, then I mean check that particular value in this particular case 3.4 whether it belongs to one of these types, we can increase these types, for example. So, let's say we we gave a complex number here and check is in stance let's say two plus three j that's a complex number. And let's say we asked whether it is an integer or float or not, the result is obviously false. And the reason is, it is neither integer nor float or even if we give string there str, so, it will still say no it is not not any of these, but maybe there is a complex data type if you see that, that says yes, because it is complex. So sometimes this is instance becomes really useful. Next function is power. So power you can you can compute power by the way using using for example, if you want to compute x raise to the power y, you can use double star and that computes exactly x raised to the power y or equivalently you can call the function POW x comma y and that will give you the same result as this one. But power sometimes take three arguments as well. And in that case, it it a it performs the power function in a different behavior. So for example, if you supply three arguments what it does it it raise y to equate x raise to the power BI whatever the result is, then it takes the remainder by z and gives the result. So let's see the functioning of this power function in Jupyter Notebook. So let's say Baba, I want to compute to raise to the power for the result is 16. No problem. To raise to the power four, I can compute the result 16 this way as well. But here is another way, how can we use this to raise to the power for whatever the result is, then I want to take the remainder, by let's say, I want to take the remainder by seven, or two, so we've got four is 16, then if we take the remainder by seven, the result will be two. And that's the result two. So that's how you can use this power function. I'm just introducing you some built in functions that are available, there are so many functions that are available, I'm just getting you comfortable with these kinds of functions so that in future if you see another function that he had not seen here, you'll be able to use it and apply it. So in this particular video, we saw this is in stance function and this power function. In the next video, we will see one more function that will allow you to take input from the user. So far, we are supplying values or assigning values to variables directly, what if on the fly, we want to give the values and those values should be assigned to the variables. So in the next video, we will see the function, we will see a function that will allow you to give input from the keyboard, hope to see you in the next video. So in this video, we are going to see a very important function called input. This function is I mean, this is beneficial for taking input from the keyboard from the user. And the way to call this function is you type input. And then you type a message that actually describes the expected entry that for example, into something if you want somebody to or tell somebody to just incur let's say, a number, you can write into a number, or any specification to help the user to enter whatever input the user want to interest properly. One thing is that no matter what the user will enter, the variable a will be having type string, str. So even if you enter a number, let's say 12, or 34, or whatever, that will be received as a string. And then there are ways to convert string to number if that really was a number. So whatever you receive using input function will be a string. And then there are ways to deal with that string, if that was a number, how to convert that string to a number, and, and so on. So for example, let's see, let's see on the Jupyter Notebook, how it works. So let's see, for example, x is equal to input, enter a number. Let's see. And then then if I press Shift Enter, a prompt will appear in front of you, that will require you to enter a number for example, if I enter, let's say 56, and then I press enter, not Shift Enter, Enter, then x will receive 56. Now, you might be thinking this 56 is an integer, so the type of x should be an integer. But this is not the case the type of x will be a string. And the reason is, whatever you enter is received as characters five and six, even if you have entered something else that would have been received as a sequence of characters. So this is no longer a five as a digit five, six as a digit six. These are some characters sequence of characters. Now, if you want to, I mean, there are ways to convert this x, for example, maybe you want, let's say, y or x as int x. So this means you have now converted this string to integer and then whatever the result is, you have stored that result in x again, if you now see the type of x type of x, the result is integer. And you can for example, print x minus 34. And the result is 22. Because X was X was 56. So this input function is I mean, it is an one way by the way, if you if you're expecting an integer or a float value, for example, let's say you're expecting a float value, then it is good to write input, let's say enter a real number, maybe or any message, any message and then at this particular time at the time of import, then it is okay to convert that thing to float and it will become a float. Yeah, that's it. So, now, for example, you enter 12.5 if you see the type of a now, type of a will be float okay. But there are problems for example, if you are if you are expecting float and somebody enters into something that is not float for example, a or let's say B equals load, input enter are real number, let's say and then you press Shift Enter and somebody just interest let's say ABC. So, now, this is not a float ABC cannot be converted to a real number no matter what. So, you will catch an error there are ways to avoid these kinds of errors and programming program breaks using exception handling and there are other ways, but be careful I mean the user is not I mean the one who is going to enter the the enter the input if that that user is not restricted enough, then you can get errors. So, I mean, this is not the case that whatever you will enter it will be converted to a float if it really, if whatever you have entered is really to convert it is really convertible to a float then it can be convertible to a float, not otherwise. And at the input time, there is no restriction you cannot restrict the keyboard to enter water or whatnot, although there are ways although there are ways to do that. So that's about the input function. So, we have seen some of the functions, let me just let me just go through quickly we have seen input we have seen is in stands, we have seen diff mode, we haven't we have seen power function, we have seen the round function and there are several others. Yes, so from now on, we will be actually moving towards basically decision making based sometimes we will use these kind of functions, mostly you will be using input function, but sometimes we'll be using maybe other functions like these functions. And sometimes we will be doing decision making based on the ease and and stuff like so, one thing that I want to tell you is if for example, you know the function name, some function, let's say like power, you know, that POW power is a function, but you do not know how to use that function. One way is to just type question mark in front of it, and then just press Shift Enter, and in front of you, the documentation of the power will open up so it will tell that this is power, that's how it should be called and then some description will be in front of you that equivalent to x raised to the power y with no arguments, the two arguments are equivalent to x raised to the power y remainder with z with three arguments and so on, if you want to see implementation of this function as well. We will see the functions later on but if you want to see more about the help, you can type the double Sam equal a double question mark and more things should be open up in front of you. So, in this particular case, the small function does not have an implementation in Python. So, the single question mark and double question mark are the same at one more way is to use the help function help out and you will get a lot of information about the power how for example, help on built and function power in module built in. So this is power this is equivalent to this some key types and stuff like so, or for example, you want to know how can I use the input function for example, so you can write help on input and this is how this can be used. So sometimes it is okay if you know the if you know the name of some function, and you know how to use it, you can just open up the documentation right here in Jupyter Notebook by either using a help function or you can use just a question mark in front of the name and so on. So, that's about the functions. In the next video, we will be seeing the power of comparisons and the decision making or sometimes called the control flow. So the real fun will begin from the next video because we will be actually deciding which part of the code should run and which part should Not run based on based on certain conditions. So hope to see you in the next video. Okay, we are in control flow, the most interesting part of any programming language will assume that you have two numbers, you have taken two numbers from the user a, you've taken that number from the user using input, I have not supplied the input message here, the message is optional. It's a description if you supply that that's okay, if you don't supply even that, that's okay. So A is some number the user will supply when the code will run B is some number the user will supply when the code will run. Now, once you have a and b in front of you, obviously the user will supply that on the fly, you don't know what the value of a and b are. Because when the program will run, only at that time, the A will be populated and B will be populated. Your task is whatever the value of a is that is that you don't know whatever the value of b is that you don't know, the user will supply that value those values, your task is to print the value that is bigger than both. So for example, if a is bigger than B, then print a if b is bigger than a, then print B. So whatever the bigger value is, print that value. Let's say that's your task. How can you do that? So the question is how does Python allows us does Python allow us to do that, for example, if a is bigger than we should print a, if b is bigger than we should print B, remember again, and again we are we are talking in terms of if A is bigger, if so this is this is this is what if a is larger than B, then this condition will be true. This is like the comparison. So this is true, but then we must have an F condition as well. If A is bigger than to what, so if a is bigger than B, then do certain things. Otherwise, don't do that. Those kinds of things. So this if condition is really, really powerful, and is available in all programming languages. In here, for example, let's see if a is an input B is an input, writing an if condition, that's if is a keyword. That's a comparison that we have done earlier as well. And then the syntax required a colon in front of that. So if this condition is true, if this result, if this comparison results to remember the comparisons, they return Boolean values, if this comparison, if this, whatever the result of this operation is if that is true, then you go into this block. And whatever the statement inside is do that, for example, print b is greater than a. Now my question is, is that is that done? Are we done with the task, the task was to print the bigger number. If b is greater than a, then B will be printed then or they might have printed, for example, we might have printed rather than writing this we might have might have printed, let's say just print B because b is bigger. If b is not bigger than a, what will? What we will do them. So yeah. If b is bigger than a then B will be printed? Yes. Because then you will be inside here. If b is not bigger than if this condition is false. We will do what then? So that's a question. So right now I'm just coding this in Jupyter. notebook. And then we will see how can we deal with that if b is not bigger than a kind of condition? So let's first see the blessings of if condition and Jupyter Notebook. Yeah, so let's say a is an integer. Let's say you're expecting an integer input. input, let's say and then you write if, let's say B is again, an integer input maybe. And let's say if a is greater than b, then print a. That's it. That's your program. Remember, this indentation, I have not written this print here. This is the indentation that defines the block of a let's say if I want to print a, then I want to print, let's say, I am still inside. If condition, condition, and so whatever that starts from this, whatever that starts Form whatever that starts from this alignment, if I write something here, let's say x is equal to five, all that block all that block is called the body of the if condition, if it starts from this alignment, If however, I I typed a statement, but I typed that statement in that kind of alignment, the alignment like this, this is no longer inside the if condition. So, for example, here I type I am outside the if condition. So, the purpose of writing these multiple lines is just the if condition does not require to contain only one line of code, it can contain a whole block of code multiple lines of codes. So, this is no longer inside the if condition. So, now we will take input a input B, whatever the numbers will be, if the value in a will be larger than B, then this will be printed and this will be printed. Once these two are printed, then this has to be printed regardless of the values of a and b, because this does not this last sprint statement, it does not depend upon. This does not depend upon the values of a and b, it has the if condition has no impact on that, that is just a sequence of statements. the if condition, the statement inside the if are just these two. For example, if a is not bigger than B, then neither this will execute, nor this will execute. But this will still execute because this is this has nothing to do with the condition. So let's run this code and see how it works. So let's set the value of a see the power of descriptions. If we could have written a description, then the description could have been could have appeared here. But let's say this is the value of a let's say 12. The value of b let's say, let's say 10. In this particular case, because the value of b is 10, the value of a is 1212 is bigger than B if this condition is true, this statement becomes true. Whenever this condition becomes true, you're inside the prints you are inside the if condition. Now this print executes and you're you get well this print executes and you get I am still inside the if condition, and this has to execute no matter what the values of NBR so now let me read on this and give other values of a and b let's say the value of a is 10. And the value of b is let's say 45. Now, this can this condition becomes false because 10 is greater than 45 this is not true, this is false. So whenever this condition is false, you never land inside the if condition and you go out from the if condition. So these are the statements that are inside the if condition they cannot execute because because you never visit them, they can only be executed if condition becomes true. So then once you're out the if condition that's the statement there is going to be executed anyways. So yeah, so that's the flavor of if condition on the see and making and this is the comparison operator that returns a Boolean value. You may have different kinds of comparisons here or combination of comparisons here No, no problem depending upon your logic. But the question is, are we done we are going to print only the bigger number we have, we have printed the one that is if a is bigger, we have printed that what if if b is bigger, we have not solved the task yet. This is the task we have not solved the task yet. So how to do it. Okay. So yeah, it looks like complicated. How to print only that number that is bigger. So if b is bigger than a, then we will print B. Maybe Maybe we should make maybe we should apply another if condition. If b is bigger than a then print B. If A is bigger than B, then print eight, maybe. Yeah, why not? So um, so for example, let's go to Jupyter Notebook and, and write the following. Let me let me write a whole new program here. A equals and import. Okay, let's do not have a message and input and then if A is bigger than B, then print a. Okay. However, if B is bigger than a then print B, I guess we are done. If this condition becomes true, then we are here and we know if this condition becomes true, then this condition cannot become true, because it cannot happen there is because then B as well as B is bigger than a This cannot happen. So, whatever the bigger number will be that will be executed further you can see I have this if condition and this if condition they are aligned in a way that this if condition is not this the second if condition is not inside the body of the first if condition, we will see such cases such cases when this is required. But right now, I guess we are done. If A is bigger than B, then print a, if b is bigger than a then print B and only one of these if conditions will become true, because A is bigger than B B is bigger than a, these two statements cannot be true at the same time. So, let's see. So A is 10, b is 45. So the answer is 45. Well, because 45 is bigger. So let's run it again. So A is let's say 22. b is let's say four and the result is 22. Because 32 is bigger, I guess we are done with the task, we have used this if condition twice to achieve the task to print the number that is bigger and both the numbers we we took both the numbers from the keyboard Yeah, I end this video here. And in the next video, I will tell you more features of this if condition particularly the L statement, whatever what we have done recently with another if could could be achieved through an L statement that is more powerful and more readable. So in the next video, I will talk about ELS statement which is a part of F so hope to see you in the next video. Okay, in the last video, we saw if condition and we actually had an example in which we wanted to know we wanted to just print the greater number. So we input a number a we input a number B and if b is greater than a we printed the is greater than eight, then we applied another if condition to check if a is greater than b, then paint a the else clause or the else part of f is as as the name suggests, if this condition is true. So, if this condition is true, this particular condition is true, then go there. If this is not true, which means else if this is true, then go there, else go there. So if this is true, then you learned here, if this is false, then you learn else part for sure. And this else is I mean, if b is greater than a if this condition is true, then you print this thing. Otherwise, a might be greater than B or A might be equal to b either way you learn in else part. So this if and else they both have this alignment, but then the block of ELLs started from this particular alignment, maybe you have more statements here, the alignment of this if block structure from here, and you may have more statements here. So let's go to the Jupyter Notebook and see the else running. So let's say a equals and input and B is B is int input and we say okay, if a is greater than b, then brand a else else rent else brand be elsewhere outspent B. Now B will be printed, even if it is equal to A or if it is greater than a either way, B will be printed. So let's just see. Let's just run this and see what happens. So Shift Enter. So input a number. So A is let's say 10, and B is let's say, 12. So what do you think when I will press enter what will be printed, B or A, B, B is printed, that's what B is printed. Now, if I run this again, and a is done, and B is done, still the 10 will be printed. So let's modify it, let's, let's just say, print. If part. So that means we landed in if part. Otherwise, we landed in Ellsberg. So just to be more elaborated, let's say so 10 and 10. And we landed in L sport. And the reason is if a is greater than b, so 10 is greater than b 10 is greater than 10. False. So you got two L's, and the LS block, the whole block just executed. So that's what else is, it's really very nice to have an L state or whatever this whenever the, if this is false, whatever that condition is, if that is false, then you learn in else. So yeah, that's the health part simply now, okay. So, we have this f l structure, we can have one more power with this F, what if we want, if a if b is greater than a, then you print B. Else, if A is equal to b, then you print they're equal. And if this is false, and this condition is false, if both these conditions are false, then you go to else part. So basically, if else if else if else, if else, so, you can have really deep structure for example, in this particular example, if b is larger than a, then you land in this part else, if this L is just short form of else, else means B is not greater than a else, you can have another check elsif A is equal to b, then do what? l l, if we can have one more check, we can have one more check, we can have several checks, and then else else will only execute if all if conditions or elsif parts on top. Their conditions, they are false, and only then else will be execute. So let's see these l diff running on Jupyter. notebook. Okay, so let's say a is and so rather than taking inputs, let's say is one, B is let's say five. Let's say we have taken these inputs is one B is five, if A is if a is equal to b, then the word rent equal l l F, which means else if now, because this is if you should you have to write a condition here, which will be either true or false. If A is larger than B, then do what? then print, let's say, a. And else, let's say your brain be okay. So that's it. And this statement, rent is not in if condition Not, not in if this is outside complete, this is complete if condition with all its L's and LDAP parts, and this is no longer inside. So let's run this. What do you think what will be the result if A is one B is five, then else bar is going to be run because A is not equal to B, A is equal to b that's false is larger than B that is also false. So you will learn in export and B will be printed and then a statement will be printed which is not an F. So yeah, so B is printed and not an F. If b is 10, then what will happen? A equals to B that is false, so you will not land here. Else if A is larger than B true. You will land here because you land here else will not execute. So He will be printed and then not enough. If A is 10 and b is also banned, let's say, then you have equal. Yeah, so that's elsif. Okay, so that's about if else if else if or short form is lf l structure. In the next video, we will be talking more about this if else if else structure in a bit more detail. And we will also be giving you a short form of this this guide of ELLs if elsif elberfeld of structure. So hope to see you in the next video. Okay, one way of writing this, if elsif else kind of structure there is a short form as well, which is written down here in a in this green color, for example. This is kind of a same code that we saw in the last video, but that's the short form, let's say a equals nine and B equals 10, then print a if A is larger than B, else print this particular thing, if A is equal to b, l sprint that this is exactly the same kind of structure, for example, print a, if A is larger than B, so you just read that if a is larger than B, then print a else if A is equal to b, then print equal, else print that. So that is kind of a short form of writing this if Elif else kind of structure. But I will, I will recommend to to to use, I'm in the structure in this particular horizontal form. Rather than writing that in this particular way. Because this kind of structure, that horizontal kind of structure is much more readable, much more manageable. And this might be this structure might be confusing some time for for some kind of readers or, and also if this structure goes on and on and on, which we'll see in a in an example today. Writing that writing very deep and lengthy structures in short form is not very feasible. So although but but this feature is there if you like to write if elsif else kind of structure in this way, this is available in Python. Okay, let's let's get a good grip on this f LS f l structure on Jupyter. notebook. Let's move on to Jupyter Notebook. To see an example, just an example. So let's say the example is user will input a number, let's say int input, let's say and enter marks, let's say enter marks for a particular subject, let's say user with enter some some marks. And our goal is if the marks are larger than 85, then we will print a grade. If the marks are larger than larger than 80, but smaller than smaller, so if the marks are larger equal to 85, then we will print a grade. Else if marks are larger equal to 80, but smaller than 85, then we will print a minus grade. And if else if if marks are larger than larger equal to 75, but smaller than 80, we will paint we will print for example, b grade for example, b grade, and so on, let's print this whole nested structure that let's let's make this else. if else if elsif kind of structure a little empty, let's let's get comfortable with it. So if a is larger than or equal to 85 to enhance readability, it is good to include a space is a space after the variable and space but don't actually write the space inside there because larger and equal to the combined without space is an operator. So if a is larger than 85, then print let's say a grade rate l if A is a is larger or equal to a D and E is smaller than 85. So let me let me write this in a more readable form. Else if A is smaller than 85 and is larger or equal to 80 then we should do what it is sometimes good to include these kind of parentheses sometimes it is good just to make these things more readable that this is one block. This is one this is one Boolean, this is one Boolean, this is one to see and this font is E and although not writing the parenthesis is also okay. But writing the parenthesis make code a little more readable. So, for example, if a is smaller than 85 and a is larger than 80, if that is true, So, remember and is true only when the left side is true and right side both are true, then this whole condition becomes true. And I promised you that I will show you the power of comparisons and actually combining the Boolean variables using ands and ORS and stuff like so. So here you're seeing the one. In that case, let's say brand. Let's say a binary sprayed and Elif if he is if he is smaller than if he is smaller than 80. And a is bigger or equal to 75. If that's the case, then what should we do? Let me omit the parentheses just to show that whether writing parenthesis or not writing parentheses is perfectly okay. I just recommend right parenthesis, so the code becomes much more readable than otherwise. Okay, then we have Brent, let's say, b grade. And let's say one more lF lF. If A is smaller than 75. And a is larger or equal to let's say 70. samedi, then Brent b minus grade, let's say. And let's just finish this let's else print. below. Average, for example, let's say that's it, that's our, that's our record. So, we will we will enter numbers, if the number is greater than 85, then a grade if, when this condition becomes true, then this print will execute. And we will out of the structure right there. If this condition is false, then this condition will be checked. If this condition becomes true, then this print will execute. And we will be out of this structure. If this is false, and this is false, then this will be checked. If this is true, then we print degrade and we are out. But if this is false, then this will be checked. And if this is true, then we'll print b minus grade. And we will be out. If this is also false, then we will dive into L sport and we will say okay, below average. So let's see, for example, let's say the marks are at two. So a minus grade. That, that that that makes sense, a minus grade because the marks are smaller than 85 and larger than larger or equal to 80. So a minus grade. Let's, let's run this again. And we have let's say marks let's say 64 below average. Okay, great. So you see this if Elif, Elif Elif else this can go as long as you want, depending upon your logic. So great. And further, you can combine several comparisons several billions, together with ands and ORS, and nots, whatever you whatever you like to like to do. Let me give you one more or one more beautiful thing. let's let's let's create an L without writing an else or let's let's just let's just write lF and implement ELS completely so we are not going to write ELS explicitly, but we are going to write a program that actually simulates ELS So let's see, if a equals let's say, three. If A is larger than 10, then Brent let's say larger than that. Now, we are not going to write else, but we are going to achieve the aerosport. Tell If not, a is bigger than 10. To see, then print you see that I mean, that's beautiful. If this condition is true, then go there. If this condition is false, then not have false is true, then you learn here. And you need not to write an expert if you want just I've implemented I have implemented l spark using l f. So see that. So l sparks so we are right now Spark. If A is let's say 13, then we will think okay, rather than just for fun, just for fun, okay. Okay, great. So, we saw if condition it's shorthand and LDAP structure in in a bit more, lengthy way. So in the next video, we will see if condition inside or in the body of another if condition, which is called a nested F. So hope to see you in the in the next video. In the last video we saw if lF structure, in this particular video, we will see nested F, or are simply called if inside the body of another F. So let's take an example to understand what nested if condition is simply we can understand if condition inside another if condition, that's all rest of the story is same. The way it works, it works even if it is inside the body of another if or or anywhere, actually. So let's say we have input a number, and then we check if x is larger than 10, then you move inside the if condition. If that is true. If that is false, then you are here, whatever you write here, it will work from here. But let's say x is greater than 10, then you print your number is greater than 10, your number is above 10. Let's say let's see Brent that now after this, after this statement, you move to the statement, and you just make another check if x is larger than 20. Now you see this if condition. This particular statement is inside this particular if condition, if this, this condition becomes true only then you dive in, otherwise you're not. So here you're checking if x is larger than 10, then you move inside and inside you're making more checks. So for example, if x is larger than 10, then you print or do some stuff here, then you apply Further more, more checks more graduality more, whatever your logic is. So let's say here you're checking if x is larger than 20. Now, if this condition is true, then you move here else now this else is of this if if x is not larger than 20, then you move to this else l squat and you're here. So and we can have another if inside this particular F or an F inside this L sport and so on. So if inside an F is called nested if and we can have I mean deep structures, for example, if then something then if then something then if so maybe we can have a very lengthy structure if nested if structure depending upon the logic. So let's get ourselves comfortable. As always, by writing the code on Jupyter Notebook because that makes much more sense. When we see things running on, on on the notebook. So let's say a is let's say again, and let's say we take some number and if a is larger than 10, then we say okay, Brent, larger than 10 and do more stuff, Brent. That's inside. If condition, okay, then then maybe we have another check if A is larger than 20 then say rent greater than 20 Yeah, greater than 20. And you can rent now rent inside the nested if, okay. Else rent l sprint, smaller or equal to 20, smaller equal to 20. And then brand, for example, inside the L spark of nested if that's it, and you can print here, brand outside all it's fine. So that's it that's that that's the structure. So let's see, let's give an input which is larger than, by the way, if input is not larger than 10, this if condition is false, then you directly dive to this print statement and all this structure is not going to be executed, this is this complete thing is called the body of this if condition, and the body will only execute if the condition becomes true, whether that condition is just a single condition, or you have a combination of a lot of comparisons and a lot of Booleans whatever, if this condition becomes true, whatever that condition takes form of, then Then and only then you dive into this part. And when you are in this part, then that's a whole new universe, then you're on its own in the new part, in the new part, for example, if this condition becomes true, then you are in this part, that's the body of this particular if condition, and that's the body of the else part, see the the body of the top if condition has this kind of alignment, all the statements that are in the body of if condition, they start the same alignment, and all the conditions all the statements that are in the body of this particular if condition, they have their own alignment, and this indentation is necessity just to define, for example, which statement is in what kind of block for example, if I just press a tab, then another tab, then this print statement is in this L sport and this is the indentation that is defining the placement of this print, if for example, I press I align this with this, this particular structure here, then this print statement is inside this if condition, this is the indentation that is defining the placement of different statements. And if the print starts from here, then it is completely outside of all if conditions it is like this way. So let's run this board and see what happens. Let's say we brand let's say we just cried a equals let's say 12. So, what do you think what should be printed, if A is 12 then first of all this condition is true. So greater than 10 will be printed inside the top if that will be printed, then this check will be executed and this condition will become false because 12 is not larger than 20 then you will go to the else part and less or equal to 20 this number this string will be printed and then inside the else part of nested if that will be printed and then you will be out of all if condition then outside of all F's that will be printed. So let's see whether whatever we have said is correct or not. So yes, greater than 10 inside the top if less than or equal to 20 inside the else part of the nested f outside all F's Yeah. So that's what the nested F is. And by the way, you can have you can have for example, more if conditions inside the nested ifs for example, you can have one more condition here, if A is larger than 30 for example, then do what then print it is larger than 30 as well. And for the brand, maybe not necessarily that you always write print statements you can do any interesting stuff inside inside the nested if of nested if find and then you can write the else part of this particular if condition here if you want to or or whatever I mean you can have as hilarious structure as you want, but that completely depends upon the logic or you may have an if condition inside that l spot here for example, You can write an if condition here, if whatever that is also, that is also perfectly fine. So, if a is larger than 20, then you print this if A is larger than 30, then this, for example, and literally write the else part here else, print less than or equal to 30. And we can print inside the nested inside the else for all of nested if of nested if, okay, so, while you see that program, let me let me just scale it down so that you can see that completely see that program. I mean, yeah, it makes perfectly sense to me, for example, you take an input, if that is larger than 10, then you're here. If it is larger than 20, then you are here. If it is not larger than 20, then you're here. Okay. So let's say it is larger than 20. If it is larger than 20, then you are here further, if it is larger than 30, then you are here. Otherwise, you are here. And once and by the way, if A is not larger than 10, then you are directly here. Wow. So let's run this code. Let me just scale it down so that you can see it more. You can see more text. Let's see. So let's run this. No errors. Great. So let's say the number is let's say 25. So, what do you expect the result. So the number is 25 is greater than 10 inside the top if it is greater than 20 inside the nested if it is smaller than or equal to 30. So inside the else part of nested if off nested if and then outside all the hips conditions. Great. Yeah. You enjoyed that. I enjoyed that. rate. Okay, so that's about the nested if one more thing that I have already told you, but just let me tell you the power of indentation. You are here for example, in this particular if condition, that's the if condition and that's the nested if, and that's the else part of this if if you move this L sport in in the indentation or the alignment with this if then this is else part of this if and this is not the else part of this If so, remember the power of indentation the this is the indentation that defines which part belongs to what what kind of block or structure in Python. In other languages. Sometimes, for example, in c++, they they normally use to write these curly brackets to define a block and their indentation doesn't really matter. But in Python, this is the indentation that actually defines each and everything. So, for example, this is a crucial example if this else just moves backwards and aligned with this f you get this else with this if these two if an L structures, this is still nested if without an L sport. And if this else move somewhere in between I mean this is not aligned with this if this not aligned with this if you get a syntax error because that is not a proper indentation. So focus on indentation that is really really important. Yeah, so although i have i've told you that the indentation has already told you but I just I just found to make a slide over this elsewhere because that's important. Sometimes you may get confused whether this else belongs to this F or that F Well, the indentation defines this LS belong to what? Okay, I end this control flow indentation here. So from next video we are jumping toward loops. But before loops, I just want to I just want to write a lengthy program in F LS f there are combinations. I just want to write a Jupiter program for you to to get comfortable with F nested f the conditions that are ands and ORS and nots are stuff like so. So So in the next video we will be practicing more on Jupiter for if conditions and then from the next to next video. We'll be jumping toward loops, the very very powerful structure. Okay. Hope to see you in the next video. Okay, so let's just practice this if condition a little bit more in this particular video and we are going to achieve particular tasks. So let's design some task here. By the way, this has comment, comment, comment is, it starts from a hash symbol. And that's a statement that will never be executed. This just describes your code, for example. So like it, like, it is not there. But it is there as a text, but not as a code file. Like hash sometimes represents. Comment or description with a single line. If your comment goes on multiple lines, it is good to write a multi line comment. So that's single line comment, for example, single line comment, the multi line comments, they start with three quotes, and then end with three chords. So whatever you write inside, in these, in this particular block, that's a multi line comment. So let's describe our problem in this modal line comments, because that's the problem in form of text. And then we will be solving that problem using using the code. So that's just description of the problem, let's say user will enter of loading point number. Number, let's say 230 8.915. Let's see. Okay, your task is, is to so let's just adjust more readable, your task is to find out the teacher integer, portion, integer portion, before the decimal before the point, let's say for the for the point, in this case, in this case, it is 238. And then, and and then check whether if that teacher portion is and even number or not. So just print yes or no. So print even if it is even number, otherwise, print odd. So that's the that's the problem statement. That's the problem that we are going to solve. And this is just to commit now we are outside the command that's a multi line comment. Yeah, so how to how to solve that problem? How to solve that problem? So let's start solving this problem. I'm going to spend some time on this program just to get comfortable with the if conditions, let's say let's say that number is x is input, let me convert that input into our real number. That's it. Okay, we're just assuming that the user will enter a real number. It's real number. real number might be I mean to 38.0, that's a real number or 238 itself, that's also real number. That's okay. But we're not assuming that the user will enter, let's say some characters like ABC or stuff like sort of just just assuming that. Okay, now, assume that x contains real number, it may be an integer. By default, maybe user just enters 10. And that's it. So it may be already an integer, then we have to check whether that 10 is whether that 10 is even or not, or the user may enter 11.7, or the user may enter minus 34.7. Or the user may enter just zero or user may enter just zero point 30 535. There are a lot of possibilities that a user come up with this exe can contain any kind of number, and we have to check according to. So how can we move let us just see, whether that number let us just extract the decimal portion, the portion before point. Let's just extract that how can we extract that there are two conditions First of all, let's see if x is positive, then do what else do what? So let's try this structure first. The facts is positive, then what we have to do? And if x is negative, then what we have to do? So if x is positive, then what we do? We, we just so, what should we do? I'm just stuck here. How can we extract the, the decimal portion, the portion without this particular thing? How can we extract that? That's, that's tricky. That's kind of tricky. Yeah. So any, any ideas? I guess this? The the structure I have, I'm using the let us just first think that x is positive, just make our life easier. And then if x is positive, it's a positive number. How can we extract this portion out? Just the number that is below? That is before the decimal point, but what should we do? can we can we can we apply apply around function? Will that help? x? Will that help? helps. Yes. But no round function? So let's say y contains the rounded value of x then, so what? Then how can extract How can we extract the the the decimal portion, the portion the integer portion? Or maybe there is a function that actually round down? Let me check whether there is a function float or not? No, float is not a function, I guess. So let's say round x. Okay, now y contains the rounded vol value forever the Xs we are now assuming that x is positive, okay, then what? Now, if, if y is larger than x, that means we moved up. Okay, we moved up, the round goes up. In that case, what we do is we just subtract. So the let me so we just subtract the integer portion. So the let me in teacher portion, let's say that's our variable name, then the integer portion is simply y minus one is that correct? Is that correct? If y is larger than x, then integer portion is simply y minus one. For example, for example, just Just think about it, if When, when, for example, if the value was 29.6, and the rounded value will become 30, so 30 minus one will be 29. There is what we are what we are interested in. So, yeah, so otherwise, if for example, else, else, if y is not larger than x, then y itself is an integer portion. Y itself is an integer portion. Is that correct? I mean, is that making sense to you? That if for example, if if x is larger than effects, larger than if the rounded value of x is larger than larger than x itself, then we just subtract one and we get the proportion. Otherwise, the rounded value itself is the portion, just just let's just run this, run this code for now and check whether what whatever we have done so far is correct or not. So after that, just print, let's say the integer portion. And teacher portion, let's just print that. Okay. So enter a number. Let's say the number is, let's say 25.3 45.367. Let's say, obviously, the integer portion here is 25. So let's say let's see our program returns 25. And now Oh, the result is 25. magically Oh my god. We found 25. Let's run it again. Let's run it again. Just to see. Okay, let's run this again. And order this time let's give it to 45.8. Okay, the integer portion is 45. But when we will round We will get to 46 and 46 minus one, we will dive into this particular if condition. Let's see. All the result is 45. We are we are still moving very bill. Great. That's, that's great. So, okay, let's play with it. Let's, let's give, let's give 0.2 the result should be zero, it is zero, right? Let's run it again and give it let's see, let's say four. That's it, the result should be four now, it is four. Great. So, we are working very well we have extracted the integer portion as long as the number was positive. Okay, right. What if the number will be negative? Let's say that was true, if that was true, so, that whole logic works, if x was positive, so if x is positive, then whole this logic just works okay, then else What should we do? If x is positive, then this logic works effects is not positive, then what will happen? Then how can we find out the integer portion because first we have to find out the integer portion and then we have to find out whether they are integer portion is even or not finding out whether they are indeed a portion is even or not might be simpler. But first, we have to find out the integer portion. So for example, let's check the behavior of round function on negative numbers, let's say around minus 9.3. So the result is minus nine. Okay? If we say okay, round, minus 9.6, the result will be minus 10. So it looks like the same as working in the positive numbers. So round function is actually working roughly the same way it should work in the positive numbers. Okay. So what should we do here? Any idea? Maybe, maybe we first convert? Maybe you first convert, by the way? Yeah, maybe first convert the number, let's say y equals around x again, like before, but then what? Then what? So maybe this rounding helps the same way? Maybe the rounding helps the same way. We should extract this out from this here, because it is going to work in the else part as well, why to compute it, why white write this redundant code? So why is round x let's say then if y is greater than x, what should we do? If it is negative y is greater than then what would what will be the portion? It will be the integer portion will be portion will be what? y minus one or one? y plus one? Yes, you got the answer? That's y plus one. Great. And else I guess we have in future portion. Equals Whitesell, I guess, yes, I guess that's the that's the good. That's cool. I guess that's checked, by the way, but I guess that's the code. By the way, this else part is, this else part is same in both of these conditions. So maybe, maybe we can combine this code and write a more elegant code, but I guess this would work. Let us just print the integer portion, just to check whether we are working well, so far or not. So let's enter let's see 12.3 The result is 12th grade. So it did not change our previous I guess our previous logic. So let's say there is minus 9.8. Now the integer portion should be minus nine, oh, it is returning 10 Why is that? Why is that? Oh my God, this should be changed when it is round. It may go that way or when it rounds it actually becomes lesser than 10. Because when it rounds it goes up and it becomes lesser than a negative word. This condition should flip. Yeah. So we are making an error here. Let's fix that. Okay, let's run this again. And see Let's say minus nine point minus nine d 3.2. Minus 93. Great. So then we have let's see, let's run it again. Minus 8.9. minus eight. Yes, we are working perfectly fine. Once we have integer portion with us, we just right here. At the very end if integer portion is your portion, remainder with two, if that equals to zero, if that equals to zero, Brent, even, otherwise, else, brand. Art. That's it. That's the whole program. Let's see. And let's see, how is it running? Let's say 22.6. It's even, let's say minus 87.3. That's odd rate. So you see the power, if condition and, and how can we think in writing these programs and stuff like so? That was a lengthier video, I know. But I guess you get a very good look and feel of, of if conditions and thinking and building logic and all that stuff. So in the next video, we will start loops. So that's a beautiful structure, hope to see you in the next video, the best way to understand loops is to think about in a repetitive structure or repeating structure. Let me let me give you an example. And they will, we will dive into this code in a while. The example is let's say a user gives you a number, let's say integer number. And you want to print all the numbers till that number, let's say you start from one, and you keep on moving and printing all the numbers, as long as you reach that number. So for example, if user enters, let's say, five, your goal is to print one, then print two, then print three, then print four, and then stops, then stop just or, let's say if user print, if user enter, let's say, three, then you print one, you print two, and then you stop. This is easy. If user enters in n, we can just print, we could have written this thing, print. Brent, I, let's initialize a variable by with one, Brent I, and then I equals two i plus one, or in Python, we can write this quickly as i plus equals to one that means I that means in I store a plus one, this is the short form of writing this. And then after that, you just apply an if condition. For example, here, you can apply an if condition and say, Okay, if I is smaller than n, you keep on printing, and after printing, you just increment again this, then check the if condition and keep on moving. Well, that is visible if n is five, or n is three, what if if n is let's say, if t 1000. In I mean, you're writing all that structure again, and again. And again. I mean, that's a lot of code. Well, the loops are just a solution for this kind of structure when you want to perform the same kind of task again, and again, the loop gives you the facility to do that. For example, let's just consider the VI loop. This is again a condition similar like a condition in if condition like an if condition, you evaluate this Boolean expression, then that's an expression that results a boolean value. While this condition is true, you will stay in this block and after executing whole block once you check this condition again, if this condition is again true, you will dive into this block again. Then check the condition dive into the block then check the condition dive into the block. As long as this condition stays true, you stay in the block you you move inside the block. Once this condition is false, then you exit this while loop then the loop terminates and you move on to the further processing just like an if condition just like if conditions if if the condition becomes false, you accept that if condition and you can move on, moved on. So in this particular case, for example, if n is five, let's say if n is five, user give an integer number that is five I is equal to one, now one is smaller than five, the condition is true, we move inside, you print I, the value of i is one. So that's what you print, you print one, then you change a, you increment i with one, that means i equals i plus one, so I becomes two. Now the body of the loop finishes, that's whole body of the loop, the body of the loop can have many, many statements, a whole block of code. Once I becomes two, you move on and you check, okay? Two is smaller than five, yes, it is true, you move inside the block again, you print two, then you update I, the loop body finishes. Once the loop body finishes, you go and check the condition again, whether that condition is still true or not, it is still true i is three i is three is smaller than five, yes, you move inside, you print three, you update, I, you check the condition four is smaller than five, yes, you move inside you print four, and then you update I and then you move on now five is smaller than five false. Once the condition is false, you will not dive into the body of the loop, you will exit the loop and you will print done. And that's it done. So this loop becomes very, very, very handy. In in, in, in applications that have representative structures. And in most of the interesting programs, most of the interesting problems, these are the loops that play a very huge role. So let's go to Jupiter just to get our hands, get our hands on this loop. For example, let's say x is again, that's the end or n, let's take n and is in input. Let me make this a little bigger, just do. Let's say that input and input is a number, let's say n i is your surgeon, let's say let's say one, while I is smaller than n, you may have written this parenthesis just to just to create the readability just to make readability. And otherwise I mean, this is also Okay, that's perfectly fine. If as long as I is smaller than n, keep doing the following you what you do is bring, for example, the square of I paint the square of I, that the square of it, let's say, and then you say, Grant, for example. This is a question number. And then you just print I, that's the iteration number I have the loop. That's the equation number I this is just the spring, this is just a string. And that's our variable, its value will be printed. This print function takes as many arguments as you pass. So you can you can write a comma here and continue whatever you want to print. That's very flexible function. Okay, then what you do you say, Okay, I plus equals to one. By the way, this i plus equals to one is the same as i equals i plus one. You see, I have just commented here just to explain what this is doing. If I just write i equals i plus one that is also that is also correct in Python, but that's kind of shorthand. Okay. And that's it. Now, again, when I de indent, I'm outside the loop, let's say sprint. Loop done, for example. So that's the code for example. So let's run this code. Let's run this code. For example. Let's say n is equal to five, then we have five. So this is one, this is the aggression number one, then two square is four, this is the aggression number two, then three squared is nine, the aggression number three, then four square is 16. This is the iteration number four, and then the loop finishes. That's it. That's the first snapshot of the loop. We will continue from here onwards in the next video and I will show you more and more flavors of this loop. So hold on and wait for the next video. Okay, in the previous video, we saw a while loop and we saw one. One program related to while loop, just printing Just printing a bunch of numbers till a particular number. Well, when you are inside the body of the loop, that's a whole new you can write whatever you want to write, for example, you can you can apply an if condition inside the body and check that an at each iteration a particular decision should be made or not. For example, in this particular case, I'm going to print I whenever I is an even number, so, I is some number if it is even then printed, else pass this pass statement for example, is just a statement of saying that do nothing It is just a shortcut of writing do nothing we could have we could have omitted the whole else part along with this pass and still the code is equivalent but sometimes writing this past make the code readable just so so writing this boss statement just means do nothing and just move on. If we omit else statement, and we omit this boss, that's perfectly okay. So, for example, let's try it on the score. Let's say n is let's say n is five i equals one one is less than five Yes, one is not an even number. So go to the else part else means boss, which means go on and then increment i this print statement is outside the loop this is this is aligned with this while it's not inside the body of the loop otherwise, it should have been intent indented inside now i is incremented I becomes to now move back to is smaller than five years. Two remainder two is zero Yes. So brand two, so two will be printed. Because if executed else will not execute and I will increment because I is not inside the if condition it is inside the body of the loop. So I incremented I becomes three you go back, three is smaller than five years. Three, remainder with two is zero false. So pass i i plus one, so I becomes four, four is smaller than five years for remainder two is zero, yes, so Brent four. So else will not execute now increment i, once you increment i you get, for example, I equals five, now five is smaller than five false, so you go out of the loop and you print down. And that's what this code is. So, you can have if condition inside the loop, you can have nested if inside the loop you can have loop inside the loop nested loops, we will see examples of nested loops as well. I mean, that's that's all allowed are sometimes rarely required. Okay. So, next there are two important statements that are there, one is break one is continue, I want to focus these statements because they have a deep link with loops. A break statement where ever written inside the body of the loop tells that exit the loop immediately whenever this brake is encountered, whenever this brake executes, it exits the loop immediately and brings you outside the body of the loop. That's what it does break. So for example, if I becomes if I becomes divisible by 17 and the remainder becomes zero, you will print a break and then when this break statement will execute you will exit the loop immediately regardless of what is the value of AI What are other states wherever break exits the loop Okay great. Now, the continue continue statements continue statement wherever encountered continue brings the next iteration loaded regardless of the remaining remaining statements in the loop for example, when this continue will be executed, no matter how many statements are there onwards that are there, in the body of the loop, the loop will not finish its iterations iteration by going through all the remaining statements, but it will start another iteration immediately. So continue basically skips the remaining body of the loop and starts another iteration. Here I have written this. true true means while true means always run. You might be thinking always run it's an infinite loop will it will it when we will exit the loop because this true statement will always stay true. We're not changing this true anymore. There is no condition here. That's true. While true means always go inside the loop but once where whenever this Break his encounter, you're outside the loop right away. And this break exists, the loop does continue skips the remaining remaining portion of the loop body and starts the new iteration starts another iteration. So this continue means start another iteration immediately skip the rest of the stress of the statements. So the rest of the statements inside the loop body. Okay, so let's just practice this break and continue with just just in Jupyter Notebook to get a better look and feel of the loop. So let's say we have, let's say again, let's say n equals let's say 10. Or we might have taken that as an input, let's say n is equal to 10. While true, which means keep moving, it might have taken some value here, I equals, let's say one, while true, if I remainder with, let's say, nine, if that is equal to zero, then just break the loop tells ELS. Else, what you do is really you increment a else what you do is, if I is if I is not divisible by nine, then what you do is i equals i plus one, that's true. By the way, previously, we we have written this way. So either way is fine, whether you write a short form or this form, so else this okay. And that's, that's it, the loop finishes. That's the loop. After the loop, you just write Okay, print, the loop is done. So let's see, what's the output? The output is done straightaway. And the reason is, why it is Oh, one is not one is divisible by nine, only then you could have break. While true. Why? Why the loop? Oh, it does not print anything, we could have printed some statements so that we know that we went inside the loop or not. Okay, so inside, if so, for example, Brent. Inside else. So let's run this again. Oh, okay, great, inside sales, inside sales inside sales inside rails, the first time it go inside, if that time it breaks, and it goes out and pants down. That's what this break statement does. So let's see an application of continuous statement. That's for example, just copy and paste that code into another cell and see how this continue works. So, let's say we have a loop like so. So, what we say is like this, if I is nine is not equal to zero. If this is the case, if I is not divisible by nine, what you do is you get take i plus equals to one and then continue continue to the next statement. And whatever else you write here for example, brand something brand something else something else whatever that is going to be printed and what wants to continue will will be encountered whenever this eye is whenever this I divisible by nine is not true. If I is then you continue once this AI is divisible by nine for example, then you will not follow then you will not dive into this if condition only then these two statements will be printed. Because this this continue will not allow anything further that should happen. And once these are printed, let's say we break our loop right there, let's say so if for example for the very first time one is not divisible by nine, so I equals two. So continue these three statements will not be executed the next loop the next loop. The next one If condition becomes false, this continue will not operate, and then we print this statement, then only then we will print this statement, and only then we will break and we'll exit the loop and print the data. So let's print here. Brent inside, if so, let's run this code, let's run this code and see what happens. That's the good I should I should just yeah, NASA better font, let's run this code. So, when the code is run inside if inside if you see when you when you are inside if when you continue when when this is the body of if condition when if condition completes, it should print these two things, but continue is telling the cursor to go back to the next iteration and move on. And once this if condition becomes false, only then you get this distinct printed this thing printed if this break was not there, you do you then again was going to the while loop and you will be running an infinite loop and then you have done so that's what this continue and break does. So, in the in the in the very next video we will see another kind of loop here we saw the while loop in the next video we will see a for loop very powerful and very famous kind of loop for it does almost the same stuff as while loop while the while loop runs based on a condition they fire the for loop it runs based on contracts a counter loop that many times it should run and so on. So we will see the details of for loop and the application The for loop in the next video hope to see you in the next one. Okay in this video we are going to discuss for loop and other kind of loop in the previous video we saw while loop although most of the stuff almost all of the stuff can be achievable through while loop and sometimes it becomes handy to apply for loop. In this particular example, I'm going to populate a list. So before actually moving towards for loop let's see very shortly what a list is, although we are going to be or we are going to explore this lesson in much more detail when we will discuss the data structures module but just for the sake of example, a list is a collection of different kinds of elements for example 234, that's a list of three elements. So two three and four the list can contains different type values, for example two 3.4 and stuff like so, we can access different elements for example, L of zero means the very first element the indexing This is called the index, the index starts from zero then index one is so if we print for example, Brent Elif zero the result will the result that will be printed will be two similarly we can append more values inside a list append let's say 53 and list after this append operation, the list will be having these values 234 53 we can remove delete, update and do a lot of stuff we will see lists in detail, but just for this example, just think that list is collection of a lot of elements and we can add insert more elements we can delete elements, we can change elements and so on. Or we can just initialize the list with just an empty list and start inserting elements one by one and expanding that list. Okay. Now, this is an empty list for example, and four is just a variable for i in this range isn't it greater range then means sequentially give a number one by one starting from zero start from zero a gift num give numbers one by one for example, first time give zero I will contain zero second time give 1/3 time give two and so on after every equation the range will give another number as long as the numbers they are smaller than 10. So, the last number that this range will return will be nine. So whatever this is written inside is not included and it starts from zero. So as long as I is in this range is lower than 10 as long as that you that the body of the loop just like the body of the while loop. So first time I will be zero and zero is smaller than 10 Okay, you print i i plus one and abandon the square of that in a list. Then next time this range will automatically return the next number into I. Now next time I will contain one next time I will contain two Next time I will continue In three, four or 5678 and nine, once the value of AI becomes nine, that's the last iteration of this body of the loop. And after that the loop finishes. So let's just write on this very very first time I will be zero when the loop enters its body very first time I will be zero and one will be printed because we are printing i plus one, at that time the list and the empty list will be having one number which is zero square. So list will be having just one number zero, because zero square, so, next time I will be one and we will print two and the list will contain one square which is one, next time I will be three we will I will be two we will print three and we will be having a square of two which is four, and so on till so until 10 here, when I will be nine we will print print 10. And in this list, we will be having nine square which is 81, I guess, and after that the loop finishes and we will be out of this loop. Okay, let's see this. Let's see example of this in, in Jupiter just to get more comfortable with with list as well as the for loop. So let's see, let's say we have an empty list, let's say an empty list. Just to consider a list like this L is just a variable, you can write another variable a name, that's a variable name L. Okay. So for i in range, in is a keyword range is a function in is a keyword, i in range. For example, let's say then, what you do is you brand, your brand i plus one or whatever you want to do, that's the body of the loop, and Eldad a band, that's a function of the lists, we will see that in detail in the data structure sessions. Okay, and that's it, the loop finishes. When you finish the loop, just print the whole list. So let's print the list. And you can see the result 12345678910. And that's the these are the values in the list. As as I mentioned earlier, all the little the values. By the way, this range function actually, if What if we want it to jump more than just one, for example, b we want it to start from zero, it reaches 10. And let's say we want two jumps to be taken as two rather than one and one. So the very first time so that's the start location. That's the end location which is not included start location is included and location is not included. And that's a step size. So very first time I will be one you move inside, then a jump of two will be taken the next time I will be so very first time the AI will be zero, then you move inside then the jump of two, then you move inside then a jump of two then you move inside as long as you stay smaller than 10 you will move inside the loop body of the loop. So let's see what now printed let's print just I rather than i plus one there was an error was the error 00 the range function does not have colons, it has actually commas. Sorry, my mistake. I was just a MATLAB user one. So MATLAB actually has this colon things. So I was just confusing MATLAB notation with this. Okay, great. So so first time i was zero, next time a jump of two, I becomes two. Next aim to jump off to AI becomes four, then I become six, then I becomes eight. And next time I becomes 10. But 10 is not included. So you're out of the loop. And that's the squares that you got. It is not necessary that you always start from zero, you can start from one and you can j take a jump for example the jump of three. And it's not necessary that you just reach them you can reach for example 20 it's up to you it's completely your choice. And in that case, you have this kind of vibrations. So this range function really is helpful for creating over over a loop body or a structure. Okay, great. So that was introduction of for loop and we have iterated here on on our list we just have actually populated a list using for loops. Okay In the next video we will see more details of this for loop and more fun stuff. Okay, hope to see you in the next video. Last time, we saw four In the last video, and magically this else has something to do with for loop in Python. Well this else clause makes sense for F. But in for loop it hardly makes sense. But let me let me let me try to make sense of else clause for follow there is an else part of for loop as well in Python, not in other languages. I don't know any other language that has this L spark maybe there is some but I don't know. So this else part in Python, particularly in follow, this else part or else that was blocked will only execute if four completes its iterations. For example, this is a set a set like a list is is a collection list is defined by square brackets set is defined by curly brackets, the set is just similar like the set in mathematics, we will see the set lists tuples dictionaries and many of these data structures in detail in data structures portion, but just I have introduced this, just consider this set has three elements Apple 4.9, and Jerry. Apple is one object or one data. 4.9 is one data, which is a floating point data and Jerry is one data which is a string data. Okay, so this S has three elements, three different elements. So now for x in this set, as long as x is in the set, the very first time the x will be Apple, so it will print Apple, next time x will contain a 4.9 as long as so I create over this set, as long as x is inside the set big elements one by one, and just print them all. Okay, we expect that when x is Apple, when the very first time x will be Apple, it will print Apple next time x will be 4.9 it will print 4.9. Next time x will be cherry it will print cherry, and the loop ends because there is no item in sets to iterate over. Because the loop finishes it's complete iteration there are expected three iterations and the loop finishes those now the else part will execute and you will say okay, loop completed. So iterations. Well, you will be wondering in what case the else will not else will not execute. If you apply any brake statement inside the loop body, which means you forcefully you forcefully remove some of the iterations that were going to be executed but the loop did not complete it did not complete citations, then the L spot will not run. So let's see an example in in in Jupiter to get a good grip on this else. Okay, let's define a set S. S is a variable name. You can have any variable name that say it Apple, or let's say 4.9 I guess and then we was having, let's say, Sherry, if if these Spelling's are correct, I guess jelly. Okay, then for x in PES, as long as x is ns Brand X. Fine ELLs rant, when you finish the law terminates with success, or all iterations it completed all its iterations. And this is a statement that is completely outside the loop. side the loop, so let's run this. So you can see Apple 4.9 cherry loop terminates with success outside the loop. Okay. Now you might be thinking in what case this else will not execute. Okay, if, for example, as long as x is an N, if I say okay, let's say I take a counter here, I equals one, that's a counter, let's say, and every time I just increment i, i plus equals one, and then I check if i is equal to three. If y is equal to three, then just break. Let's say else just for readability else was now this else is else of this four. And this else is else of this if and this POS statement is just a statement for doing nothing. Now what you do when is equal to one you Brent this i plus equals I becomes two two is equal to three false, so you pass you move on. Next time, x will print 4.9, I will become three and three is equal to three, that's correct, the break will execute, which means the loop should have one more iteration, but the break just disrupt that one more iteration that should be there, because the loop could not complete its iteration due to this certain condition, this else part of the loop will not execute, and you will go directly outside this loop. So let's run this code and see the result. So you can see this apple four by nine outside the loop. I would recommend although this else is there for for loop, but I would recommend to avoid using ELS in the beginning, I mean, you may be confusing this else By the way, there is a there is a mistake here, this l should be ended with a colon here, okay. So I would recommend to not use LS clause for a for loop in the beginning until you you really need it. Because you may confuse this else with the with the L of F condition. And you may think something else and the program behave in a different way. So either way, if you want to use LS LS for a for loop is there in Python. Okay, just one more example of for loop. And here we use dictionary, I'm introducing some data structures here just for fun, we will see these data structures in detail later on. So dictionary, that's a key value period like set, but one item is consists of two numbers, that's called a key. And that is called a value. That's a key. And that's a value like a dictionary, we have key and values. So now as long as x is an X, X represents two key and d is our dictionary and D off x represents to whatever value that x points to, for example, Apple is a key that points to 44. Cherry is a key that points to gain. For example, if we're ID, apples, apple, the result will be 44. Similarly, d of Jerry, the result will be game. Okay, so let's I create over this dictionary using this for loop. All am I showing you that this for loop is very, very handy of creating over different data structures and a lot of data and stuff. Whereas file while loop is more handy and checking the conditions and stuff. Although you can do all the stuff using while loop you can always stuff using for loop but one is better over the other insert in certain situations. So that's let's let's just run this for a dictionary. Let's say I have a dictionary D. It's defined like a set, let's say my key is a and my value is 10. Let's say my key is B and value is minus 19. And let's say my key is C and my value is let's say ABC, let's say that's my dictionary. So for x in the Brent the key as well as the value of that key. So now you can see the key is a the value of Stan The key is B the value is minus 90 in the key of C the values ABC. So this far loop is really really handy and iterated over a lot of data structures and stuff although it has other applications as well but this is handy. Okay great. So that's about loops for loops. And while loops These are two kinds of loops in important loop these are two important kind of loops and they are in Python, in the next video I will directly go to Jupiter and Jupiter notebook and we will be practicing for this for loops or while loops. We will be practicing the loops we will be doing actually examples of nested loops we will be actually solving a problem like we did in the if conditions we solve the problem Previously, we wrote a code for it. Here we will also write a code and we will be get a good grip on the loops. So hope to see you in the next video we will solve a problem in Jupyter Notebook directly. Okay, hope to see you in the next video. Okay, welcome back. In this particular video we are going to practice for loops are basically loops. So let's have a problem statement. First, what problem we are going to solve let's have comments. And the problem we are going to solve is let's define given a list of of numbers, numbers. For example, I II, let's say 124 minus five, a 7932, like this, make another list making another list that contains all the items in sorted order from minimum to maximum, ie, your result will be another list. Like, in this particular case, we will be having minus five, which is smallest, then we will be having one, then we'll be having two, then we'll be having two, then we will be having two, then we'll be having three. So all items, but in minimum to maximum sorted order, then we having I guess, four, then we'll be having seven, and then we'll be having nine. So that's your, that should be your output in another list. So assuming this list is available to you, or any list is available to you assume this list is available to you. So how to solve that problem? Let's start. Okay, let's assume that the list is available. That's it, this is the list we are going to sort. Let's say this is available. Okay. Okay. So, what should be the logic? What should be the logic? How can we solve that problem? This is, this is an easy looking problem, but it is not so easy. Let us first right. Let us just simplify this problem to just finding out a minimum from the list. Let's say we are given a list and we just want to find out minimum number one a minimum from the list. So how can we move that. So let's say M is some number. So M is the very first value of the list, let's MSP our variable, let's say that's the first value. And what we do is for i in the for i n L, as long as I is an L, if I AI is smaller than m, then if AI is smaller than m, then m should contain AI. Otherwise do nothing. That's it. So at the end, rentas m, then this m at the end. So, Brent, the minimum number, that's great. So so that's the nasty, basically. So yeah, that's the that's how we will find out just the minimum value. So let's run this code. And the minimum is minus five available to us. What if we want to store the minimum value as well as the position of that value? For example, we not only want to just find out what is the minimum number, we also want to find out at what index for example, here 012, and three, at the third index, we found the minimum, what if we're interested in the index as well. So let's say for the very beginning, the index is zero. And then what we do is we moved on and we say, okay, we maintain a counter, let's say a counter is C equals c equals zero, for example, right now, and C, just plus equals to one, that's a counter and then this ID x is just that C, whatever that c is. So whatever that index is, when we find this C, that index is also there. So let's print the index as well as the minimum value. So okay, so at the position three, at index three, we found the minimum value, okay, now we have written kind of a code block that helps us finding out the minimum value. How can we actually how can we actually do how can we act? So the basic logic is you find the minimum value and swap the that value with the very first value, okay, great. And then move the loop next time find out the minimum value from the remaining list and swap that minimum value with the second value. Next time you find the minimum value, as long as the position and swap that with the third value and so on. So do that stuff and just rearrange the same list using this but, but how can the so that's the logic find out the minimum value. So happened with the first value and then start from two till end start from start from the remaining values, find the minimum so appid with the first value of the remaining list, then reduce the list step by step and you will be having a sorted order, but how to start with how to find out like this how to how to do that. So, any idea and we are going to so for example, in this particular case, if I want to swap the list, what I will do is I will say okay, swap with zero at the at the at the zero, so, I will contain a temporary variable, temporary variable will contain the value of zero, this zero, so what I will do is at least zero, right the minimum value and the minimum value. So at zero you write the minimum value, but at this particular index, from there, we found the minimum value, just place the just place the the value at the very beginning. So in after that, after that operation, the minimum will be at the first position, or the zeroeth index, and that value will be some minimum value will be swapped with the very first value. So let's run this code and see what a list looks like after that good. So you see, for example, the minimum value is swept by the first value, whatever the first value was, but we want to do that progressively for for the rest of the list, we want to find out the minimum and follow up with the first one for the rest of the list and keep on moving. How can we do that? So yeah, that's, that's, so let me define four. So let me first in depth a bit, let's say control right bases that will indent all my code. So for j in range, length of the list, whatever the length of list, let's say for G is that so what I do is M is the gf value the index right now is J and the C is also C is also the Convert C is also starts from J, okay, great. Now, we want it to start with two now we want this I to start from J and move onwards here. So let's say i in range, start from G and go till length of L, one by one, take the step of one. Okay, great. So what next? Now the value will be L of I, rather than simply L of I rather than simply I in that case, you do this. Okay, and the index is just C. Okay, great. Keep on keep on introducing this index again, after this loop, what you do is you pick the gf value, you slap the gf value with the minimum. And you do that. And that's it, you keep on moving and offer after the outer loop finishes. If you branch your list, you will be having the list sorted or at least we hope so. So maybe there is a bug in the code or maybe there is a problem in the code. But we hope this will work. What we are doing progressively By the way, this is a nested loop. This is a loop inside the loop and that's and then we have an if condition inside the nested loop. Loop inside the loop. Great. Let's see how it how it works. If there is no Oh there is an error length of range. Oh, we haven't write a colon there. Don't forget this colon. That's a problem. Oh, we have a sorted order. Oh my god. We have a result with us. You see the applications of this. Oh, one three is missing. We were is three, we have two threes Oh, the output we have written here is wrong, there is no two threes there is only one three. So you have sorted a list. If you remember, we have written a similar kind of code in the problem. So problem solving session very earlier, where we solve this problem using selection sort, but they are we just wrote a pseudocode. And here we have a code much simpler than actually the Python code. If the problem was just sorting there are built in functions to do that, but I'm just telling you how these loops and if conditions and all that stuff can be used to communicate with each other to match with each other to to actually perform a problem solving task when given a problem. Although we will see later on in Python, most of the problem solving tasks, I mean many more of them, there are a built in function for those that are available functions for those you need not write all that stuff, but to mastering to to master any programming language, you have to go through these constructs. So that for a new problem, or for a very large, complicated kind of problem, eventually you you may need these kind of structures with you. So mastering these structures is really essential for problem solving and programming in general. So okay, that's about the loops and if conditions and control. So, all of that, in the next video, I will I will start talking about functions. So you have seen this L e m data function, you have seen this range, that's that's function idolater. Although you have seen around function, you have seen def mode, you have seen print function, what if we want to write our own function? How can we do that? From the next video, I'm going to show you how can we write our own function? Wow, isn't that great? That's great. So hope to see you in the next video. In this video, I will talk about functions. A very powerful construct in almost every programming language. Python also supports functions. What a function is, let me let me describe the let me describe the need of the function by a scenario. Let me give you a scenario. The scenario is let's say you are writing a very lengthy program, the program requires to print particular messages whenever needed, for example, you need to print this particular message the task, the task was successful, let's say you need to print this. And then you have to print moving to the next task maybe to to inform somebody maybe in to inform your client. And then you have to ask, okay, send me the next task. Because I am done with the previous task, let's say you want to print this, or maybe you want to print more or do some more stuff. And let's say you want to do this again. And again, whenever needed. Somewhere, whenever you complete a particular task or something, you want to print all these messages, and then somewhere else, whenever a particular event occurs, you need to print all these messages again. Now one way to do that is to write just these print statements whenever needed in the program. One way is if you want to perform a task and the task has a lot of coding, maybe maybe maybe a very small amount of coding or maybe a very large amount or magnitude of the coding. In this case, we have just three statements, but maybe we have a task that we want to perform again and again and it is really a very lengthy task in terms of the coding. So, one way to do that is to just write all the coding in coding somewhere and define a function and that function means the function contain all the tasks that you need to perform, whenever you need to perform that particular task. Just in your coding, just call this one statement, just this one statement, and the whole task that is written under this under this content maintaining this as a heading that will execute automatically I mean, however, I mean, that task that is under this heading may be very lengthy may be short, may may be complicated, may be simple one or anything, but the need is we want to perform this task whenever we need. And we do not write to code this again and again we do not write to code we do not write to we do not want to write the same lines of codes again and again and again. And again in our program. Just write this particular lines of code once define a function, just like a task. Whenever you need to perform that task, just call the heading or the name of the function. And the whole task under that function will execute functions in almost all programming languages. They do that even in mathematics. They do that In Python, the syntax of defining function is you if you want to define a function, you have to first start with D E F meaning definition or defining, then you need to write the name of that function the name of that function name a function and name a variable has resemblance, I mean, the name of functions should be descriptive, it should, it should portray what the function actually is doing. So, it is good to write it is good to suggest the names of the functions that are very descriptive to make the code readable and manageable. So, here I have written the function name is sprint success, you can write any name, then you start parenthesis then you end parenthesis and then you write a colon like you have written the colon for if conditions are for loops or any other constructs. And then you do indent like the body of the for loop like the body of the if condition, this is the body of the function, body of the function is all should all be aligned, then you write all the tasks, all the coding that you need to be performed whenever this function is invoked or called, this body can contain if conditions for loops inside, I mean, this can have a whole lot of coding inside it. And whenever you will call this function, whenever you will type this command, wherever in your coding, the whole task under this will be executed automatically again and again whenever you like. So, let's take a look of defining our first function in Jupyter. notebook. Let's just I guess, yes. So, yeah, so, that's our notebook, we were populating that notebook. So by the way, if you if you want to know where this notebook is located, if I want to, for example, invoke that notebook again, when you will run your Jupyter Notebook from the Anaconda prompt, you will be having all the files that you are working on. And one file is for example, this you just click on that, and your file one or more files, whatever you want to open up that will open up in the Jupyter. notebook. Yes, so it is opening up, it's a lengthy file, so it may take may take a second. Okay. Let me just take a better zoom level, just to Okay, so we were working on that notebook, let's define our first function, let's say D, F, define. Let's say the function name is Brent. Success. That's a, that's a syntax, then press enter, Brent, I am done. Then Brent, send me another task. Let's see. And that's it. Let's say that's the, that's the body of the function, the body of the function here contains only two statements, okay, then you run this, you run this command, just like Shift Enter, you run this. So that it is it is reported in the symbol table, there is a symbol table inside the Python maintaining Python is maintaining all the variables all the function information inside. So once you run this cell, then the then this print success function will be registered to Python. So that whenever you want to call this function, again, it will be available. Now if you want to perform this task, let's say you want to perform, let's say you want to perform this task whenever you want. So you just call this function, this is called calling of the function. whatever I'm doing now, when success and that's it, you press Shift Enter, and the all the statements that are under this will be executed. And you do some other stuff, let's say three plus eight that is that is 11 do some other stuff. And afterwards, if you want to do the same process again, then you call this function again and all the coding inside the function will be executed it is very, very handy. If a particular task if you want to perform that task repeatedly, it is good to just write one code for that task in a function and then just invoke function whenever you need. It supplies a lot of managing power, a lot of debugging power if you have an error for example, inside the function, you just go to the code we just go to the code of the function itself and fix the error and come back You need not to you need not to go all over the code if you have not defined the function and you have called these lines of codes everywhere inside your main code, then it will become very difficult to handle And function actually provides a lot of a lot of simplicity of managing and readability and, and a modular approach in that sense. So that was our first. That was our first function. We will be talking about more, we'll be talking more about this functions in the next video. So hope to see you in the next video. The function name should be descriptive, that's okay. But it is further important sometimes to have a documentation of the function sometimes called the doc string, the doc string allows you to write the description of the function. But that description will never be executed, it will be available whenever you need help. Or you need to know what this function does. Sometimes it happens your function can contain a lot of code, for example, you have a particular function, let's say, fun, let's say it contains def, fun, and it does a lot of a lot of complicated stuff inside. And it is sometimes required to know what this function actually is doing. So this document string is one way of describing what the function is doing. You might be thinking that if you're writing this document string inside the where the where the coding of the function should be written, we should open up that the coding file and see what the function is doing, or should we actually open up this function implementation where the function code is written. And then we have to read what the function is doing. Actually, Python gives you another power. If you have written the document string inside, that should be a top statement before the first coding statement. Whatever description you want, as a document string, it will be available without actually opening up with without actually seeing what's inside the funk without actually opening up the file that contains the implementation of this function. Let's see, let's see. Two in Jupyter, notebook imore, completely whatever I'm saying right now. So for example, let's define a function. def print success. to let's say the function name, this function is print success to the function name is print success two, although it's not a very descriptive name, but the specimens are also not correct, but that's fine. Print success to here I just define a document Strank. The document string may contain maybe just in one line, or it may be a multi line, it is like a multi line comment, or maybe a single line comment if you want. But it starts with the three quotes and ends with three quotes. Let's say I write here this function is doing nothing except renting. message, printing a message, let's say full stop. And then I further define let's say I define more in saying that that message is Hello, let's say, let's say are any description you want for this function. Now, this is a document string, and it will be available whenever you need. Now here are the coding starts, let's say you, right according here, and again, hello, let's and you run this code. Now, let's say we are not seeing this function we are we are not available with this function. We are not available with the code of this function. And we want to know what this function actually does. First of all, we can just write if we write pri, and just press tab, the tab will allow us to access all the functions that are available with prefix pri. So let's say we go to print success, brand success. Brain success here brain success, as should be capital, Brent success, let's say so print success to let's say and we write a question mark in front of it, and then just press Shift Enter, it will pull the document string it will pull the document strength whatever we have written and we will get to know what actually this this is doing. So this document string actually does a lot of job further if we I mean this is this is kind of whenever we need to know what a function is doing. The document string is one way to just go and check what is what is happening. Right now this function implementation is in front of us But in several times, the function implementation will not be in front of us several times, we will be accessing functions that other people have written in their libraries. And we need to know what those functions are doing. So document string is one very, very healthy way of describing our function. And I will recommend to make your habit writing document strings, every time you write a function. I was telling you that if you write a double question mark, then it will not only pull the document string for you, it will pull the whole implementation as well. So now if you see you, they said the document string, and that's the implementation. So whole implementation will be available, if you want. And this is true for the functions that are that are, that are the functions that are third party functions, or some other person have written that function and so on. For example, you know, a function length, we call that function several times. So let's let let's, let's see, also the document string is returned, the number of items in our container, that length function is not written by us, somebody has written that function that's a built in function, by the way. And we can, this document string tells us, okay, what this function is doing, we don't have the implementation of that function, obviously, somebody have written that function. And, and if we write the double, then we should get an implementation as long as the implementation is not in c++, I haven't told you that a lot of a lot of implementation of Python itself has been done in C and some other languages have C mostly. So several built in functions, because of because of their speed, they are implemented in C, and if you, if you want to get their implementation, they get their code, the code will not be available for most of the functions. So that's so whenever you write a double question mark, and the answer is the same as a single question mark, that's an indication that this particular function is not written in plain Python, it is written in some other language and is used in Python. That's, in other words, the diversity or flexibility of Python, you can engage multiple languages inside, Okay, one more thing, I can write Help, help command and I can get this Brent success success too. And the help of print success to by just typing this help command. So, this help will tell us, you see the Help is telling us the document strike I mean, this help on this function, if and this and this is the function we have written, this is the function we have written, this function is doing nothing except whatever description we are giving there. If, at some time, if we are supplying this function to somebody, or making a package of a lot of functions, that we are writing these documents, strings will help to get to know how to use these functions. By just knowing the function name, we can, this document string actually tells us how the what the function is doing. While great Oh, by the way, we haven't called this function yet, we are just playing with the document string, let's call the function print. Now we know what the function is doing. let's print, let's call this function. And whatever written inside the function will be called See, this is only called this is just acting as a comment and it is basically a comment. Yeah. Okay, great. Stay with us. There is much more about function that we are going to tell you. Hope to see you in the next video. Okay, in the last video, we saw document strength. Or you might be thinking, what is power of this function, if it is doing some static task? Well, in this video, I'm going to tell you that the function can the coding or the behavior of the function can be dynamic, based on based on the arguments based on some properties that you will be defining at the call time. For example, the function has in almost all programming languages, the functions, the most interesting functions are the function that receives an argument. And an argument is just considered an argument just as a variable and performs its task according to that to that arguments. argument. Just take a single simple example. Let's say rather than having a function print success, we have a function print message, and it it prints whatever message it receives. And at the call time, for example, we call this function like so print message. And let's say we call this as, let's say, success. Let's say now success will be printed. Next time we call the function and we give another argument maybe in a string, let's say so 74 errors, let's see, that will be that will be printed or anything, I mean, anything that you supply will be printed. Wow, isn't that great? I mean one function. And you might be thinking the plain print function does that what's the power of this? Well, I'm just telling you the function of the function does not only contain one line, I mean, it can be a whole task depending upon this input argument. And the whole task will perform dynamically based on based on what input argument you are supplying there. You are noticing one one thing that I that I just forgot, what is that thing I define this function? I guess everything is fine. I just have just missed something Oh, document string, I should have written document string. Although document string is not essential. If you do not write document string, it's perfectly okay. The function will run but it's a good practice. It's an it's a good habit to always write a document string. Okay, let's see the power of input arguments by again, going to our good friend Jupyter Notebook. Okay, so let's see. Let's say we define a function define Brent grant message, let's say, edit receives an argument message. And this argument is just a variable, it's just a variable. And let's say we say okay, print message or further, let's say you say, if is in stance message spraying, if this is spraying, then simply then simply branded. If this is not a string, then just say okay, brand, your input argument is not a string. And then you say, Okay, here is what you have, slide. And then you say, okay, whatever you have slide, just see, okay, message. And that's it, that's it, that's the function, we might have written a document screen for it. The function rents the message supplied by the user, or brains, that message is not in the form of strength. While Don't worry, we have to see the strings in detail, we will see the sprint function in detail as well, because the sprint has a lot of lot to do with strings. So so just for now, I mean, that's our function print message, let's say if the message is of string type, this string does not good, this is this should be simply str this should not be that is instant steak like this, your input argument is not a string here is what you have supplied. Here is what you have. So here, we can, we can say here is here is here is the type of what you have supplied. And then we can just print the Type, Type MSC. So the goal here is to just create a function that prints a message if that message is in plain string form. If it is not a string, then it prints that okay, you're the whatever you have signed is not a string, it is not a proper message in string form. Let's say this print message function receives a string, let's say that's our logic or something. So let's run this. First of all, let's see what it does help rent message. So the function prints the message supplied by the user. We can access the same help by question mark if you want and it gives us the document string If however, we want The implementation as well, then we write readable code and implementation is also available. While grade Python is really great. Okay, let's call this function. Let's call this function, Brent, message. And whatever you want to print, let's say, this is the message. This is the message, let's say you want to print this. And this is the message that's printed. Okay, now, let's say you call this function again some time, and you supply 23. And it will say your input argument is not a string, here is the type of what you have supplied, it's an integer type rate, you can you can have, you can have, you can call this function in the following way, let's say you define a variable y, and the variable y contains Hello. Hello there. That's it, that's your, and then you called, then you call this function on y. And it will print hello there, because y is also a string. Great. So that's how you can you can you can, you can pass different arguments and instruct the function, how should it behave without actually writing the whole logic of the task again, and again, if written all the logic, once, actually, this is actually the logic starts from here. That's what the task is to, that's what the task you want to perform. And you need not write this again. And again, whenever you need this kind of stuff, you just call that function supplied arguments, and it will behave accordingly you want. Great. So you might be thinking, the function only receives one argument, maybe we want to supply more than one arguments, maybe, maybe two arguments, maybe three, maybe four, maybe five, and maybe we want to supply several arguments. And we want to do some task based on the values of those arguments, or those variables. So in the next video, I'm going to show you multiple arguments. Okay. Hope to see you in the next video. So in the previous video, we saw we can define a function, and we can supply input argument to it. And in this video, we are going to see that we can actually send more than one arguments to the function these arguments are just variables, these are just variables, whatever value we will supply to these dynamically, because Python is dynamic dynamically typed dynamically they are type will be defined. And for example, here we have supplied just two variables, and we just printed them, but based based on supplying more than one input arguments, and based on what logic we are going to perform, we can do anything, we can do anything. So guess by thumbs, allows us to supply multiple input arguments to a function and and we can, we can just perform all the tasks according to whatever logic we are going to do with that. So let's go to our friend Jupyter Notebook and see an example of a function with multiple input arguments. Let's say the function the B define a function, let's say, my power, let's say, my power, my power, let's say, you remember there is a POW function in in Python that's a built in function. I'm going to write my own function, let's say it contains a and b. Well, document string. My, this function computes power just like built built in power function. Great. That's the document screen. Okay. Now what we want to do is we want to print Okay, let's let's, let's create another variable, see, that is a power B. Okay, then we print this C, and we are done. That's it. That's our goal. So we register that function by just just calling the job by just pressing the shift enter in Jupyter Notebook. And now we check what this function does. Well, this function can be horsepower, just like built in power function. Okay, just to Just to remind you again and again, the importance of document strength, I'm writing this again and again, let's run this function, my power, let's say three ways to recover for illness. So the result is 81. Oh my god. So whenever, by the way, if you don't have POW function with you, although you have, you can you can create your function and whenever you want to use, you can use your function, not a big deal. By the way, what if you? What if you What if, let's say, you can, you can define a function with more than two arguments to find, let's say, display types. That's it, that's your function display types. And all you know, is our check arguments, let's say, check our x. That's it, that's your function, and A, B, C, D, let's say E, these are the input arguments. And let's say, at some tasks, you want to know whether all the five variables that you're working in somewhere, whether all of them are numeric values or not. If they're not numeric values, you're not moving on, and you're doing something because you were extra, let's say you're, let's say you're taking input from somewhere reading from a file or whatever. And you need to, you need to check before moving on whether A, B, C, D, and E, whether they are in sore floats. Otherwise, if if if any of them is not into float, then you're not processing, then you're not moving on, and you're going to check the input arguments again, and so on. These kind of functions are there because whenever you call certain, whenever you want to do processing on data, sometimes it is required to check the type of the data whether the data is supplied in a way that you were expecting and so on. So let's have this function check Oryx. I'm not writing document string here, I guess, I've told you enough to write document string again and again. So let's see. If is instance. A, if is instance int float? If that is true? And is it let's just have three variables just to just to focus on if is instance, a then B. and is instance see if all of them are? If all of them are? If all of them are integers or floats, then do something then let's say Brent, a plus b, plus C, maybe, or a plus b plus c, raised to the power to just print their square, let's say else are if they are if they are all integers or floats, then do some interesting task here some task. Otherwise, you can say okay, print, air. The input arguments are not of the expected. But it's fine. You have this function, let's say, let's call this function. The function was check arcs. So let's check arcs, check. arcs, check arcs, let's say three, four, or five. So now you have all of them are great. Let's say you have jet arcs. And you call this check ARDS. On, let's say, three, four, but this five is a string, let's say, Gee. Now we'll be having an error. The input arguments are not all of the expected types. One of them or more of them or whatever. Yeah one more thing the this function is expecting three arguments if you call this function by less than three or more than three arguments you'll be getting an error for example three four although this function is accepting three arguments, you're calling it with just two you're getting an error because you have not specified all the arguments that the function is requiring although the the arguments that you have supplied they are of the type that it is expecting, but you have not supplied the the number of arguments that the function is expecting. Similarly, if you call this function by more than three arguments, although it requires three arguments, you again will get an error, because it is expecting three arguments and you have not supplied three arguments. later on. In later on, we will see how to write a function that accepts a variable number of arguments, we will see that but right now, in this particular way, if you write the function, if you define the function in this particular way, you have to define the arguments the number of whatever the number of arguments it is expecting, you have to supply exactly as many. Otherwise you are getting an error. Okay, so that's about the multiple arguments. Okay, what next? Well, next time, in the next video, we will see that what is the what's the importance of order of these input arguments? What will happen if I just swapped message to win message one? Will that will that change the behavior? Or is there any order? With the first mess? The first variable, the second variable, third variable? Is there any ordering inside the input arguments? Yeah, there is. So let's see in the next video, in the last video, we saw, how can we pass multiple How can we define a function with more than one input arguments, it is important to know that the order of the input argument is really, really important. So whatever argument at the call time, for example, if you call this particular function, the name of the function is f, that's not a great name, you should have a name that a descriptive but I recommend write good names, let's say this is f, that's a function and the very first variable is C to the second variable c one, the third variable is C three. Now you let's say call this function like like this, let's say two, four and nine, what will happen is this too will be copied in C two, this four will be copied in this C one and this nine will be copied in this C three. Now, C two has a value two, c one has a value four and C three has a value of nine. If you change the symbols or the variables order here, whatever order you have written there, the first value that is passed at the call time will be passed to the first variable whatever the name of the first variable is, the second value at the call time is copied in the second symbol, whatever the name of the symbol is. So, this ordering is really really important. One way to work one workaround for this is at the call time, you actually define the variable names and their values. For example, you call you call F and you say okay c one has this particular value, but this way you need to know that there is the symbol name in definition is exactly c one. So, C one has this value, C two has this value, C three has this value, once you at the call time, if you have defined your variable names along with their values, then you are order free. Now you change whatever whatever if for example, you call this way c two is b, c one is a now no matter in what order you have called these, this C one is going to be copied in C one, the C two is going to be copied in C two and C three is going to be copied in C three for the functions that has many more arguments, it is it is good to it is good to call the function in this particular way. If there is a chance that calling a function in a different order may may may become confusing and stuff like so. This actually gives you more grip on this ordering issue. if if if you're if you're happy with if you're very smart and When you say Ok, I will always supply in a particular order, I will always read the document string first, and then I will call that function, that's okay. Otherwise, this is also a feature that is available at the call time, you assign the values of the functions that are there at the definition time. And now no matter in what order you are calling that function, see one occurs at third position c two occurs at first position, the relative values will be copied according to their names. So and that's a good feature. That's a very good feature. Let's see, for example, a running example of this in Python. In Jupyter, notebook, okay, define, let's say function f, let's say it receives a, b, and c, let's say three values. And let's say prints. A, is that's it, Sprint, a, is a. And you'll say okay, B is B. And then it prints Okay. See, C, C is, whatever the value of c is, that's the C, okay? Now, let's call this function f, with, let's say, two, three, and game. So, they will say, okay, a is to B is three, C is game, fine, great. Now, this tool will be copied in a no matter what if we if we change this, if we change this calling order, for example, if we if we change this order, we just we just moved to we just moved to this particular order, we just say okay, this is three, this is game, this is to be called like, so now three will be copied in a game will be copied in B and two will be competency. And that, if if if that is the behavior you want, then you are good to go. Otherwise, it is it is handy to call the function in the following ways just fix, okay, a is a is to fine. B is three. And C is let's say again, if you want these numbers, now, if you call a function like so, that will happen. Now, if you change the order, no matter what order of add the calling time you come up with, it will stay the same. For example, you go and say okay, C is at the first position. And a is at the second position, let's say two, and B is at the third position three, the output will stay the same. And that's a, that's a beautiful, that's a beautiful thing. So that's one way of handling with the order. If you if if you think at call time it is important to define the variable names, but it has one problem that you need to know you need to know exact variable names. If the variable name is C one there, you need to know what it's see one, you need not to I mean the C one matches with C it must match with C one, C two must match with C two and so on. So you need to know these names. Okay, great. In the upcoming videos, more features of functions are are going to are going to be discussed. So stay with us hope to see you in the next video. So we in the last video, we saw the ordering of input arguments in a function. And we saw a fix to it. I mean, if you if you if there is a chance that you may miss a proper order, there is a way to fix that we saw that in the last video. Here, we have another another thing to discuss this x variable x input argument This is the variable that is defined inside a function although the value it receives is copied from somewhere else, but it is defined inside the function that is also the function variable or the or the variable that is in the scope of the function inside the function in the body of the function something like so it may be handy. For example, let's say you want you you compute something you do some processing on your inputs. And whatever the result is you save that result in another variable. And let's say now you need the value of this variable. to do some further process, let's say, what you do is let's say in a call time, that's let's say this is the this of the function and say, This is the complete function. And let's say a is equal to 12. And B is equal to, let's say seven. And let's say you call the function add a, b, now the value of a will be copied in x, the value of d will be copied in Y, okay, and now, you need the Sum of a and b, to be received here, in a variable, you want a variable in which the results should be saved. For example, let's say a variable is D, let's say, and then you want to do some more processing on D, let's say d doublestar five, mod three, and maybe you need to apply an if condition on that if that equals to zero, then do some stuff otherwise, so let's say you need this variable out, what will happen is this C variable is not accessible outside this function. And the reason is the C is defined inside the function when the function body completes its execution, the C is lost sees no more available, C is defined when the function call has been made, when the when when you're executing the statement C is defined and a memory location was created in a C sometimes called the function space in the memory or process space that is created in memory. But once all the body of the function executes all the functions that were inside the variable they are lost, what how can you How can you receive this value? How can you receive the value inside see outside this function? So, that is, that is question in this slide, how can we do that further, this particular function can access all the variables that are not defined in this function, but that are available outside this function and are defined already. For example, let's say I have a function, f. And the function is let's say I have a function f. And so if this function is defined, like so f, let's say F is your function, and it has to find like D, E, F, and that's it. And here it prints let's say, some variable, let's say a. Let's now now you know this a variable is no longer in F not even defined in F, but as long as this a variable is defined, before calling F for example, that's the cell where we are writing the code and we say okay, a is equal to seven, and then we just call this F, because a was available before calling f a will is accessible here. So, the functions the variables that are available before the call, they are available inside the functions, but the variables that are defined inside the functions, they are not available outside. That's the problem further, if we define this ad here is equal to two now, this a is sometimes called the local variable or the function where the variable there is local to the function. Now, this a is is is defined inside the function and all the accesses to a will access this value to rather than the sound considered sound has a separate location in memory, and this too has a separate location and memory, both have names a, but this a will only be referred to when the function is executing, after the after the execution of the function completes this has gone from the from the memory and this will still be available, the seven will still be available. So it is good to know and by the way, if a was not defined here, and you still call F, then either you will be getting an error, or this a might be a global variable or available in some package that you have already loaded or stuff like so, in that case, this eight will be accessed if it's a global variable or accessible. So, it is good to know the the scope of the variables inside the function because when you're calling them what functions if this if x is already defined, for example, if x is already defined like 34 and then this x is 34, as long as this x is not defined here, if x is defined here, this is this x actually is the local copy and that will be accessed inside the function. Once the function is gone again x will be 34. So, it is good to know the local copies or or the function space itself. The but but the problem here is how to access them. This variable the value of this variable outside the function, because this is completely defined inside how to access that? Well, well, there is a fix, and that fix is called the return statement. If you write the return statement, for example, you return this value. So x plus y, you might have saved these values, you might have saved these values, for example, C equals x plus y, that's okay. And then you say, okay, return, see, what will happen is wherever you have called this function, d equals add, let's do three. Now, this value, this value C, which in this particular case is five, that value will be returned in D, and all the properties of this variables are returned in D. So just like the C is copied in D, and this is available further, whatever you want to do with this D. Okay, so yeah, so return statement is there. So, in the next video, we will actually code this in Jupyter Notebook and see the return statement running and we will see the scope of the variables and all that in Jupyter Notebook. So hope to see you in the next video. In the last video, we saw a scope of a variable particularly if a function if a variable is defined inside a function, is it accessible outside the function and if a variable is defined outside the function, is it accessible inside the function and vice versa? and so on. So we discussed those kinds of things, which is sometimes called school scope of a variable. And further, we discussed what if we want, what if we want a value of the function that is computed value value of some variable or some result that is computed inside a function? What if we want that to be accessed outside, outside the function? So we discussed that in detail in the last video, so let's see all those concepts in a running form in Jupyter. notebook. So let's see how it works. So first of all, let's define variables, let's define a function, let's say define, let's say, my ad. And let's say it receives two arguments, let's say a and b. And then let's say C is a plus b, let's say that C are our c value, that's a c value or some value, whatever, whatever you want to call that value, some value. That's it. Let's say we did, we did that. Now we want to access that some value from outside the function. paint some value. By the way, let's first call this function, let's say my app, add four values, let's say two, three. So two will be copied in a three will be copied in B. So then, let's access let's try to access this value, some value, it will throw an error. And the reason is this variable, some value is not accessible outside this function. What if we want to access because this is defined inside the function? What if we want to access this? I mean, what if we want to compute some result and then use that result outside the function? So the way out, as discussed in the last video is return statement. Return Value. And now if we call that again, let me let me go if we call that again. Now, what we haven't actually registered, by the way, remember this, that's, that's a common error I got in that era, a lot of a lot many times. If you change the implementation of the function, you have to rerun that cell, you have to register the updated copy of the function to the Python, otherwise, you will be getting errors. Probably, yeah. What's the problem here? Now, when somebody Oh, we, oh, there's somebody is still not still not accessible. Because some value is not is not accessible it is it is a variable defined inside the function it is scope in, its the scope of this variable, is just the body of the function. So let's receive this output in a variable D. And then let's just print D and D is five. Great. So one more thing. Let's say we define a variable here, of variable outside the function, let's say that's a label name. That's a very lengthy name, but let's say that's the name variable. Well outside the function that saves value is three. And then then let's define another function somewhere. Let's see, let's define another function down somewhere, let's say define F, maybe G, and it receives nothing, but it prints this, that's a variable. out side the function. And that's it. That's it, that's a function. Now, when we call this function, this variable outside the function that is accessible inside the function. So so and and, and if this function, and if this variable is not defined inside here, and if there is this is defined somewhere else, and it is global or accessible, it will still be accessible. However, if we define a function with the same name, let's say variable, outside, outside the function, let's say five, now, this function will print five, if we because that's the local variable, that's the local variable in the function. Now, this will be accessed in this print statement. Let's see. Now the result will be five. But if you print the variable outside, now the value will be three, because this variable, this particular variable that was inside the function, it got destroyed when the function finishes. And this is available again. So yeah, so you need to know, by the way, it's a good practice whenever you want to, whenever you want to access a particular variable inside, it is a good practice to pass that variable as input argument to minimize the confusions because this can create a lot of confusions. So it's a good practice, although the feature is available and sometimes useful as well. But it is always recommended to pass the values as input arguments that whatever you want to access inside the function. Okay, so one more thing, this, this function g is returning nothing. For example, it is not returning anything, it is just printing, let's say something, let's say it is not printing anything, let's say, let's say this is a comment, let's say it is not printing anything. So this, and then we call this and that's it. So it has no return value. By the way, in Python, even if you even if any function, even if a function does not return anything, it still returns a value, which is called none, which you can see here. So in Python, a function always returns a value. If you write a return statement explicitly, it returns that if you do not write return statement, when the function body finishes, it automatically returns none. Let's see the type of this output. What is the type of this output? What is the type of this man, what kind of data type is this? Let's see. It's an n type, I mean, that's a type in Python. So downs are non type, output, how fancy Well, one more thing, the return statement is not only used to return a particular value, if you for example, in a particular function, let me write a function here. Let's say d f, that's the function is H. And then inside that function, you do something, let's say print, a, let's say then you define a variable, let's say a equals to three, let's say, then B equals let's say five, and then you add those values A and B. And then you do some other stuff, let's say plant something. And then you just write a return statement without any output or I mean it is not returning anything. You can still you can still I mean continue writing the function body more and more. But what happens is whenever the first return will be encountered, the function returns from there. So the effective body of the function is just that the function returns right from there. If you return a particular value for example C, you can receive that value outside the function. If you do not return anything, just type a return statement. That means exit the function right away. It works like the break statement and loop. Remember the break statement it It resembles to break Excitement bulletin means just exit the function right away, no problem. And by the way, when return is called the default return value that is returned is none type if the return is called without, without an argument here, so for example, let's run this function. Let's see. And let's call that function Ah, yeah. So it prints a, then it brings something and then it returns. And it returns, for example. It returns nothing but anon. It returns or not. And if you didn't see, for example, saying, then it returns a C, value of C, which is eight. And this time this type, the return value is no longer none type, it is probably an integer type. Let's see. Yeah, here. So it's indeed a type Make sense? Yeah. So return statement has two purposes, one, you can return a value, two, you can return, you can just return the control, you can just exit the function like the break and loops. Just Just one more thing. return statement can return multiple values. For example, let's say we have defined a function, let's say J. Let's say G, G, we already have defined, we can redefine it. But let's say our is our function. And we just have a equals five, b equals seven, and D equals let's say something. And then we just return them a, b, and A, D, and D. So return statement can return multiple values in a sequence. Now, if you receive those values, let's say X, Y and Z equals r, so a will be copied in a is a first return value, it will be returned in X, it will be copied in x, b will be copied in y, and D will be copied in z just as a sequence as you as you keep the sequence in the return statement, if you change the sequence and return statement accordingly. So whatever the first value here is the first value here, whatever the second value, here is the second value here, and so on. So let's run this and just print all these things X, Y, and Z. So yeah, five salmon and something. So this return statement is really powerful. I mean, it can return multiple, not all the languages, actually, not all the languages, they have feature to return multiple values. But Python does have feature to return more than one values. And more than one values of any type A can have different types, you can have different types, you can have different type, and so on. So that's about the that's about the return statement, as well as the variable scope. And whether you can access a variable that is outside the function or inside the function, and so on, and all that kind of things. In the next video, we will talk about what if we want to access arbitrary number of input arguments. I mean, we do not know how many arguments will be there inside. But no matter how many arguments a particular user is giving, let's say we want to write an add function. Just Just to give you an example, let's say you want to write an add function that says define add that say add to another function, add two. Let's say it receives an arbitrary number of arguments. D in I don't know how many and it has some implementation, then anybody who wants to call this add to it, if that person gives two or two arguments, then just two should be added. If the person gives three arguments, then three should be added. I mean, the person can give arbitrary number of arguments. How can we handle that because because the caller the this is the call, this is the call, the caller can give five arguments, six arguments, seven arguments. And earlier we saw in the definition, the total number of variables when we specify, we have to pass those many arguments for sure. If a single argument is missing, or a single argument is just more than the specified number of variables, we will be getting an error. But how can we handle the situation where we have an arbitrary or variable number of input arguments? How can we handle that? So to answer this, or to get, how can we do that? See our next video? It's coming. In the last video we were talking about how can we handle arbitrary number of input arguments. For example, let's let's say we want to write an add function. That should be a To add any number of let's say integer or floating point numbers that are passed in. Remember last time, we discussed in an earlier video, that when you are defining a function, the total number of variables that you are defining, you have to pause exactly those many input arguments. Otherwise, you're getting an error. But but this may be required some time that we want to add a universal kind of add function that has that has capacity to receive any number of arguments. But no matter how many arguments it receives, it, just add them all and return the result. Such a function, if available will be very, very helpful. Because sometimes we might be calling that function by just two arguments. Sometimes we might be adding might be calling that function with, let's say, three arguments, and sometimes more arguments or less arguments and so on. How can we have this kind of feature available, but the implementation is just one time implementation? Well, Python have a very, very easy way of handling this arbitrary or variable number of inputs. And the way you do that is when you receive when you are defining a function, you just write a star, and then just Brent let's say, one variable name, let's say arcs. And then after that, this arts will act like a list. And I mean, it will be having a lot of properties are this arts has a property, this this x like list, so all the arguments that you will send in will be received like, like you're receiving those in a in one list. And all elements, which are the arguments in the list, they are accessed by different indices, we will see lists in detail later on. But right now just think it is a collect all the collection, it is received by indices, for example, the ARDS, the very first element is indexed by zero, it is at the zero location. At the zero location, there is a three at first location, for example, the location index number one, which is actually the second look, the four will be copied at this and so on. Now, no matter how many arguments you pass a list, it will be of that size, and there is a function length le n that is handy to just check how many arguments are there. Now if you pass two arguments, the arcs will, the length of the arc will be two, if you have three, if you have passed three arguments, the length of the arts will be three and so on. No matter how many arguments you pass this arcs, it will receive all them in one by one and all the elements in that arc will be indexed by 012, starting from zero until the length of the arcs. So see, for example, here, they said the sum sum equals zero, let's, let's say we want to add all these for i in range. And inside range, we just give the length of arcs for this example 12345, the length of arg is five. So I will start from zero till till four, because five is not included. So the very first time I will be zero, and our eggs in subscript zero is actually the value value of the first variable, which is three, so three is added to zero, then next time, I will be one and add the position one four is located. So three plus equals four, which means three equals three plus four, a sum equals whatever the some previous value of the sum plus for the next time, the value of i will be four, you know how this loop works, we discussed the loop and loops in detail. And as you move on, you actually explore all these numbers. And this variable sum actually contain the sum of all the variables. Now you can return the sum and that at this particular function acts like a universal guide a function that receives arbitrary number of arguments. How cool is that? Let's see in Jupyter Notebook to get more convinced how it works. So let's say we have define, let's say we have any function, my ad, they might add, let's say that function might add powerful, that's universal or universal. Universal might add universal, and it received receives star whatever the variable name is, that you can read, you can write the name arcs or you can write any other other variable limits. This is this is just this is just a name of a variable. Okay, then let's say we have let's say we have s equals zero, which is some, then we just apply a loop. I guess you know, the loops we have lengthy discussion on loops, in range, length, that's a built in function length arcs. Okay, then what should we do s plus equals r x i, which means access all the elements one by one. And this is again the same as S is equal to s plus r x i. Either way you write this way or that way, both ways are fine. Then when the loop finishes, s contains the Psalm, just return it, and you are done. Wow. Now, let's call this add function, my add universal. And let's call this function as two, four and five for these, and let's just print the result. Let's just print the result. Okay, the result is 11. Well, because two plus four plus five is 11. Now let's call this function for let's say, for for, let's say, five arguments. It works. It adds all these five numbers. Wow, that is great. I mean, now we can add any, we have one function, we need not write a function for two arguments, and then another function for three arguments, then another function for four arguments and so on. Depending upon the number of arguments, we need not to write separate functions. We have just one function working in all scenarios. While so, yeah. That's doable. I've done in front of you. No problem. Yeah, Python allows this. Yeah. In the next video, we are going to see how can we actually handle the same kind of scenario. But we want to handle the sequence of the input variables in a very controlled way. Remember, in some of the previous this this year, in this order of input arguments, remember that we receive three arguments and we pass the three arguments in a very controlled way. And then whatever these are, we don't care whatever the order here if we don't care, what if we want to fix the issue? Or we want to become more careful for input argument orderings. But then we also want the arbitrary number of arguments. How can we do that? Yeah, wait for the next video. And I will show you how can you do that? In the last video, I promised you that I will show you how can you achieve the ordering of the input variables, but still having the arbitrary number of them. Remember, this looks like much familiar to you, that's a call that can be made to a function. And remember, the function definition in some previous slide was like C one, C two, and C three maybe. And then something. What if we want an arbitrary number of arguments to be passed, but we want their control. For example, let's say this particular variable symbol name that acts as a key, that's a variable name, and that's the value. So let me call the variable name as a key. And let's This is the value that is copied in the variable. That's another key that's a value, that's another key that's a value and so on, what if we have a lot of key value pairs? What if we have a lot of them. And we also want to check which value is of what key, let's say we want to specify those. But we want to specify an arbitrary number of them. Let's say here, for example, there are only three, let's say we want to pass five of them, six of them, and then we want our function to perform accordingly. No matter how many input arguments it received. Yeah, and and maybe inside the function, we may have applied a check that if the key value is C one, then do this processing, if the key value is C two, then do that kind of processing and so on, let's say, based on different variable symbol names, we want to process the value differently, how can we achieve that, and still having the need that these number of variables can be can can be in a variable, variable length, they can be an arbitrary number of those. So Python gives you again, a very, very simple way. Rather than writing a simple single star, you write a double star, and then you receive in whatever variable name. And now in this double double star means you are receiving a key value pair list. It's a list of key value pairs. We will see that that resembles two that resembles to a data structure in Python called dictionary. We will see dictionary later on in detail but right now just just consider that this input argument this input variable C, it contains a, it contains a list of key values pairs, and then you just you can just iterate over the sea you can just apply a for loop to check the contents of this Remember, we have actually done that kind of thing in the, in the portion of loops. Yeah, here. Remember that was a key. And that was a value that was a key that was a value. And we did that thing, we could explore the we were able to explore the dictionary, just just using for loop. Yeah, it's the same thing here. It's not exactly but you can think of that that's exactly the same thing. So you can explore that, that see looks like a dictionary. Now this is key, this is value, this is key, this is value. This is key, this has value, you can this x points, the first key, then C of x point to the value based on the based on the key x, and then x point to the second key, then the second value and so on you that that is very simple procedure, you're just printing all the dictionary, but you can, you're printing all the variable names and the values, but you can do very complicated processing, if you want to, let's go to our friend Jupyter Notebook to just get convinced that this indeed works. Let's see. So let's define a function first. So d f, that's the function name is Brent, all variable, variables, and values. So that might be a function name. While that's lengthy one, but descriptor one, maybe we can make it more descriptive, paint all the variable, variable names and values, while that's more descriptive a guess. So it receives, let's say, doublestar. Any variable, let's say the variable name is again, let's say arcs or anything, whatever you want, then what we do is for x in orgs, just Brent, let's say, variable name is just Brent x, and then the sprint x and then just continue, and value is value is our eggs of x. So let's say you, you done this, you did this. So the variable name is this, and the value is this, okay, and you want to do this for all, all the all the variable and value pairs that you that you send at the call time. So now let's call this brand, all variable names and values. And let's call this let's say the variable first variable name, let's say is a, and its value is three. The second variable name is let's say B, its value is capital B, let's say the third Will you third variable name is C, its value is CCC. And let's say the fourth variable name, I mean, you can define an arbitrary number of arguments here. Wow, that's amazing. That's the fourth variable name is why its value is 6.7. And further notice, you can you can pass variable and value all have different types, I'm in different number of them. And and much more. Yeah, you can do that. So let's call this function by just having four variables and their values. Let's see what we got. So well, variable name is a and the value is three variable name is B, and the value is B, variable name is C and the values CCC, variable name is why and value is 6.7. You can give an arbitrary lampi list here if you want. And Python just allows you to do that. And it allows you to do that in a very, very simple way. That's amazing. That's amazing. I mean, that's, that's why a high level language or radio, a powerful language should should have a feature. So Python does have this feature. I'm really amazed. I'm really, really astonished by time. By the way, I'm not saying the other languages don't have this. several languages actually support this kind of feature, but Python supports it in a very easy way. It's very easy to do that. I mean, it's not not a rocket science. Yeah. Okay, so now we have had an arbitrary number of arguments even when the ordering is really controlled. We have one or two more videos on functions. Just to explain a bit more than we will, then we will practice on Jupyter Notebook, we'll practice we will play with these functions a lot. And we will be calling one function inside the other function and so on, we will be having one better program just just program and noodle Jupyter Notebook just to get comfortable with this functions. But before that, let's have one or two more things to discuss about the functions. Yeah, let's see. So I hope to see you in the next video. Okay, I really want to talk about these default values for a function as well, because that's important and mostly needed. The default value is a value of the input variable that you assign well, while you are defining a function, and if the value is, for example, if you call this F, with let's say, the input value three, then three will be copied in the sum and the print will be three. But if you call this function without the input, then this value acts as as if you have passed this. So this is the default value if you do not supply the value, this is the value that is going to operate. And by the way, you can have multiple variables with default values, some variables with default value is defined some variables. With default variables, a default value is not defined, and so on. So you can have this one here must be taken here that the default value, when you actually define the function, and you compile this function, actually, you you run the cell shift enter in Jupyter Notebook. At that very time, this variable is assigned this value at that particular time, it is not assigned at the call time. So sum equals to zero is already there, when you actually press Shift Enter for a cell that contains this code. Now later on, if you pass a value, that value will be overwritten on some, if you don't pass the value zero will go on, it looks like very easy, but one care that I want to mention here that I haven't mentioned earlier, in Python, there are certain variables that are that are referenced rather than copied, I will discuss the referencing in the copying data in detail in data structures. But let me just tell you 111 example, let's say you define a list, let's say one, two, and three. And then what you do you copy this list into another variable, let's say l two, what will happen is in the memory, this list in a particular way, this is not the exact view of the memory, I'm just showing you, let's say this is the particular memory layout for which this L is pointing to this L is label for that l two is also labeled for that, which means actually in memory, this is not the copy of the structure that is made, I mean this is not like in variables. For example, if a is equal to three and b is equal to a, a will be a will be a position in memory, and B will be a separate position in memory. That is what a view of the memory in ordinary variables are. But there are certain variables in memory just for memory efficient and cost efficiency and time. People have people have designed these data structures in a way that when you copy them, when you just assign a variable to another variable, the memory view doesn't change the just it's it's another name for the same for the same for the same memory location. So what happens is if you change any value, and let's say l two, let's say l two, at the very, the zeros and add the zero index, let's say you change that by minus nine, the because it is the same view in memory that changes minus nine. And now if you print the elements of L rather than l two, you will get the changed value, you will see the change value. And that happens. Now why that is important in terms of these default values here for the function. The reason is, if you are accepting a list, let's say the default is a list, and you're accepting a list and you are also defining some default value for the list. If that's your definition, let's say then this list this default value is assigned at the ad the very first at the very first time, and this L is really a local variable inside inside the inside the memory. Now when once this cell is run, not the call time at the at the sowhat call the compile time, when the cell is run this L is assigned this and that just happens once. Now if you call this list with some other list let's say l to let's say two three and four. Then if you call this L two, l two will go there it will be copied in L and everything is fine, but don't then expect this the contents of L to to stay same as staying l because l is this default. values, they are assigned just once. And they stay as it is, every time you call the function, they don't change. They are not assigned at the call time they are assigned at the compile time and they stay fixed. So that care must be taken. I will show you that example that particular example, in Jupyter Notebook shortly at this, this might be confusing right now, because we have not defined, we have not seen lists in detail. But I just want to make this point. I just want to mention this because that's important difference with ordinary variables that I mean default values, just, I mean, just like like a value. And if you don't supply a value, the default value just works. But with the variable that are referenced by variables, you may expect something else. And the Python function behaves maybe differently. And that's because these default values they are assigned at compile time they are not are compiled time. Actually, this is not a compiled language, I should not use the word compiled compiled again. And again, just think when we define this function, and we run the cell at that particular time, the default value is assigned. And the default value never changes. It stays fixed. Yeah. So and I will show you that example. Why don't we move to Jupyter Notebook and see that example? Yeah. So or why don't we do that in the next video? What do you think? This video, okay, same with you. Okay, let's go to Jupiter and mode notebook and see the default values. For example, let's see. Let's say we have define a function, let's say GG, and the default value s is equal to four, let's say that's a default value. And we want to print let's say s, if available. From the call time, if not available, then four will be printed. Now we print now right now we are going to print, now we are going to press Shift Enter at that time, S is assigned to for S has no value for it is assigned there. Now we call GG, let's say and we call GG without input arguments. Now the four will be printed. If we call this GG with some input argument, let's say 56. Now the 56 will be printed, no problem, everything is fine. Let's see about the lists. For example, let's say the list is, let's say 123, that list, and then l two is simply let's say l two is L, then what we do is we change the contents of L two, let's say we change the very first value in L two, and we place that values minus nine, and then we print L. Now, you might be expecting that l is a different thing, l two is a different thing. Because l and l two, they both are pointing to the same memory. This, the content through l two actually changes the memory view and l also changes and that gives the result minus nine in L. Well, the behavior that I want to show you is different in the default values. When we when we talk about for example, let's say we define a function, f f and it accepts a list and the default value is empty list, or the default value is let's say one, two, that's the default value, let's say if, if no list is passed, the default list is one two. Now, in this particular scenario, if we just print, so for example, for i in the list, brand, I let's say we just print all the list. That's it. Now we will press Shift Enter, and at this time this L is assigned this value, and that's a default value that never, that is not going to change. Now let's say we have an L tool that is simply let's say two, three and four, or let's say 12, three and four. And what we do is we call F and we just press Shift Enter. Now, why don't we call f f without anything. So, the default list is printed, if we call this f f with L to the L two will be printed. Now the notice that this L two actually is copied in this L because we supplied it. So l and l two you may tend to think that l is now also pointing to L to an L has also the same contents as l two. So if next time because because of the behavior of these lists because they are by Reference. Next time you make you make might be thinking that because l two is past there, so l two L is also L, L two is copied in L in a memory view way layout. So l has also the same data as l two and next time, if we call this function without input arguments, then l might be pointing out to L two values. So, 12 three and four might be printed, but that is not going to happen, the default values they never change. So, again, you will be getting one, two, so, the behavior of these Reference Type variables, that is different ordinarily, but when you do that in in the default value structure, that, that, that might work in a different way. And the reason is, you, you must know that these default values they're assigned at, at the time when the function is created, not at the function when the function is called. And they are not going to change whatsoever. So, so that was about the default value. And by the way, the default if it was a simple concept, I guess I have made it too complicated by telling you layers and default values and creation of these variables, at what time and at the call time, I made this complicated, I guess, I shouldn't have told you the list values and all that stuff. But but that's true. And in whatever I have told you is true. Maybe I have told you in a very complicated way, but it's true. Yeah. Okay. One more video on the functions and then we will be practicing functions in detail on on Jupyter notebooks. So just be or one more video with me. Hope to see you in the next video. Okay, this is probably the last video on on the functions. Yeah, we will, we will be having one more video. But but that will be like coding and practicing all the concepts that we learn about the functions not? Not something not not new theoretical concepts. Yeah. So let me ask you a question to actually, to actually make you understand about this slide. Let me go to the Jupiter and ask you about a few questions. Let's say you have, let's say, let's say you have this particular function, and you, let's say my ad, my ad universal, let's say we have written that function, maybe two or three or three videos before, let's say you have this function, you have written this function, and you are very, very excited, wow, what kind of masterpiece you have generated, it can add an arbitrary number of values pass in it well, but this particular function is written inside this particular file, which is mastering Python zero to hero. Later on, let's say two or three months later, you are writing some code for some, some project or you are doing something somewhere and you are writing code, and there you just needed. You just needed a, you just needed a code for adding a lot of a lot of values together. And then you just remember, oh, I have written some function somewhere. How can you use that function? One way is to just go back to that file mastering Python zero to hero, and just copy this function, this particular this code and paste in the new file, run that, register that and then call that happy. What if you want to use let's say, 100 different functions, let's say you have written a lot of functions in a lot of different files. And now you want to use all of them. And, and let's say this is a repetitive kind of demand several times you notice that this usually happens that this particular kind of function, you require almost every almost in every project, let's say a set of maybe 50, or 60 functions that are that are required always, one way to do that, as I told you is to jump just copy paste those functions in every file, run them and do that. Another way is to just just I mean, make a module a file of containing just those functions. And whenever any of those functions is required, just import that module into your coding file, which has one line of code and then access all the functions as if they were they were they were actually available in in the port file that you are working on. So that's about the that's about making modules of so module is basically a Python file that contains functions that you want to use in several different coding projects or the functions that you don't want to write in your the functions. Having the implementation that you don't want to write in your grant coding file, so you can have several of those functions stayed somewhere else in a different directory they are residing there, whenever you want to use any of them, you just import the whole module and use the functions. So, so module is just a Python file that can that can contain a code for you that whenever you want to use, you can use it. Normally it contains functions maybe more than one function and several functions. Normally, it contains functions that you repetitively use, and that you have written once in very careful way. And then now you want to use it again and again in several different ways. You need not to write the function definition, in every coding file you need, you just make one coding file, or that that is the most important for you, that is called a module where wherever you want to use any of those functions that are there in that module, you can call it, you can use it. So that's about the modules we are going to make. I'm going to show you one example of making module and how to use that. But but to use the module, we need to actually specify the path where the module actually resides using this cess module. So and then we have to do some this import kind of commands. And then I mean, there is some work that we need to do to actually get this module running in our code. So in the next video, I'm going to tell you what that extra work, very little amount of work what that extra work you have to do. So here, for example, my funks.py, that's my Python file, and it contains these two functions. And let's say I want to use one of these have both of these functions in some other file, and that file contains this particular code. So in the next video, I will show you how to how to actually make and use the modules. Yeah, so hope to see you in the next video. Okay, in the last video, I told you about modules module is just a Python file that can contain a code that can be used anywhere, if you want normally, that module. Normally, the modules, they contain a lot of functions, but they can contain variables and other values, and so on. So think about file myfonts.py, that contain this, these two functions, and think about a different file, maybe Jupiter, maybe you're working in a Jupyter Notebook. And now you want to use these two functions. So you first have to import another module call the system module says you have to have you have to make this path available. There are a lot of built in modules that are already there in the path all the already there in the search path. When you want to call a function, it is written in some module that is already in the search path. If you're making your modules, you have to either either copy those, those modules into the modules that are built in or if you want to maintain them separately somewhere else, then you have to add the path of these in the search path as well. And the way to actually insert this path is sis dot path dot append. And then you actually write the the path of the directory where this module file one or more files are located. Once this is added to the path, now you can write the import. And you can import your file and your file as it is or you can import your file with some other name if you want, you can rename that on the fly if you want. Once this is imported, now you can use all the functions like the built in functions, the implementation of these functions are not there in your coding file, you are just using those and you can now import this module into some other file and use their and so on. for, for, for for very large kind of projects. It is good to make modules. Actually it is better to make packages, which is actually the directory structures that contain modules. But modules at least are really good too, for maintaining a large amount, of course, or actually the functions that you want to use again and again. So let's just let's let's make a module, why not? So let's make a module. Let's say let's go to Jupyter Notebook. Let's create another file. Let's create another file, let's say new Python three and let's let's name this file as my IE let's say let's let's name this file as my universal, let's let's use underscores my universal functions. Let's classify the name. Let's create another notebook. Right now it's just a notebook that's defined some functions. Let's say we want to define one function as jack, all orgs. Let's say that's the function it receives, let's say, let's say it receives a dictionary like input. And then it checks the date, let's say check, set check type of all arcs. And let's say, let's say you write a function check, if not numeric, let's say, let's say you want to write a function that that just accepts a lot of arguments. And you want to check whether any one thought, if any one of them is not numeric, you want to return let's say, a flag. Otherwise, you want to return a true, let's say, so for example, you may you may need this function in several places. Let's say in in your core, you're expecting numerical inputs. And if the input is, and let's say there are a lot of variables that you are working on if and if any one of them is not numeric, you might want to check all the all the variables and their values. One way of doing that is just to create a list. And that's it. I mean, that's and and you may have several of those, I mean, you can check all of them. And maybe here, maybe here, we do not need the dictionary kind of argument. So maybe we just are happy with just one. So let's say for so the output, let's say output is let's say, R or the return value that value. Let's say that is already true. And we will say okay, for x in ARDS, let's say for x in arcs. If x if is in stance, x is and float, if that is true, then we are happy. But if that is not true, if that is not true, then there is a trouble, then we say okay, if this is not true for any value, then we just return. False. Okay, we just return false. I mean, we need not to break anything, we just return false return means return, whatever. Otherwise, if we finish this loop, if the loop finishes successfully, and there is no return statement that is called already, then we return, maybe true, we need to do not need Actually, this variable. Let's see. So this function will return true if all the variables are either int or float. If any of them is not of this type, this function returns false. Well, we can have another we can have another function, maybe we can write several function, the same cell or in different cells. Either way, define let's say another function, universal. Or add all values, let's add all that's in Numerix, and all numerix. And it also contains, let's say, arcs. And the goal of this function is just to add all the values and return the sum. So let's say s equals zero for x in for x in ogs, as plus equals to tax, and that's it, then return us, let's say these are two functions. And maybe one more the name of this, or some some variable, let's say you, I mean, these are two functions. Now we are out of the function we are writing something else. Let's say my name let's say that's a variable, my name this, this does not this my name variable does not belong to any of these functions. And my name is Python. Course let's say that's my. So that's it. That's file with name my universal functions. So what we do is we download this file as a.pi file.pi file. So what we do really is the Go to File, let me just zoom this out so that you can see the download options. We go to File Menu, we download this, as we download this as we download this as well as by file, so Python file. So let's download this, or we can write this Python file as in some other editor if we want. So open folder, there is a Python file here, copy it. Now copy that file. And now you're free to go to any, for example, any, any folder if you want, just, for example, you go to somewhere in your directory, and make a new directory, maybe, maybe you want to make another directory. For example, go and make a directory, maybe in D, let's say, or maybe an E, let's say or maybe in C somewhere and then make a module anywhere. For example, in C, make a new folder, call that folder as my, or any name, whatever name you want, for example, my module or let's say utils, for example, utilities or whatever name, I mean, let's let's call it as, let's call it as ABC, for example, ABC, whatever. And you just made that and just copy that Python file here, my universal functions.by. Now, if you go back, if you go back to your there, there is a Jupiter, here is a Jupiter. Now you go back to your code, this is your file, go back to your code, let's say this file is no longer here. And what you do is you import Sis, that's a system module and says dot path dot bend. Right the path here where the module is located. So the module right now is located at ABC, this is the part of the module. Once done, you can import what what was the name of the module, you need to know that that was my my word. So I just I just don't remember the name, let's import my universal functions. How it appears, actually, when I when I have Eric this part, then this import command and after the dab completion, just fetches that file. So that that that name might be very lengthy. So you can rename that as let's say, my apps or whatever name you want. So you import that once you have imported that. Now you can use the functions if you want, for example, you can check the implementation of my efs.if, you see dot add Numerix, you want to check the implementation of that. Here, this remember this file is no longer in this particular file is located somewhere else. And you can call this function like like the built in functions, my apps dot add all numerix. And you can have for example, let's say accepts the input arguments, let's say 234. All that says six. And that's it. That's the, that's the return value, you can you can save the return value in some other variable, let's see. And then later on, you can print this see our do some stuff with this. See, that's one thing. Another way of importing the same thing is let's say you don't want to use all the functions, you just need this add all the metrics, let's say that's that's the only function that you want to use again and again. So you need not the other functions, let's say for this particular file, you do not need the other functions, then what you can do is you can just say okay, from my universal functions, import, add all Numerix and you can rename it rename this function as something and you can call that function the same way. So you do that now. You need Not to write any dot kind of thing, you just call add all Numerix because it is important now, and you say, Okay 234567 and you'll save that in let's a D, and then you print the if you want, or do whatever with that. That's it are you can import several multiple functions or you can import all of them. Other than modules, there are I mean, for complex codes, I mean, this is not one module that is there, I mean, there are several modules. And the several modules may be arranged in in a directory structure, where the directory and the sub directory and the sub directory and so on. So the modules that are arranged in directory structure, although they are accessed, much like the same way, that directory structure is sometimes called package. And these are basically the packages that are that are most useful. And we will be seeing some data science packages, like NumPy is a data science package. Then, we will be seeing pandas, that's a data science package, we will be seeing matplotlib that's a data science package for plotting and visualizations and stuff. So packages, just the modules that are arranged in directory structures. So now you know what module is. And the old one, Venus two, we actually missed to import the name of have to see the name Vivi have saved a name there as well. So let's go back. And let's go back and do that and see how, how many things are available. Let's go to some other cell and empty cell. So my apps dot tab completion, my name is available. Remember, there was a variable. Yeah, that's available. So the name is Python course. So this module file does not require to only contain functions, it can contain any information, any data that you want to use in other files, other coding and stuff, and so on. So, yeah, that's about modules. In the in the next video, we will practice about these functions a little bit, we will be seeing how to call a function inside another function, how to make a lot of functions that are calling each other and so on. So we will be practicing more on about these functions, not theoretically, just in Jupyter Notebook, just to get a better look and feel of of functions more. And after that practice, we will be then jumping towards data structure starting from strings. So hope to see you in the next video. Okay, before moving on, let's just practice some, some some, I mean, let's get a good grip on functions and multiple functions and handling those. And the best way to do that is to solve actually a problem. Remember, we solved a problem when we when we, when we are done when we were done with if conditions, then we solved another problem when we were done with loops just to get a good grip on loops. Let's solve a problem. Let's just solve a problem using using the functions just to get a good idea of functions. What kind of problems should be solved here? Should we solve an older problem? Last time we solve a problem using loops that are sorting a list? What Why don't we? Why don't we solve the same problem, but in a different way? So let's go to Jupiter and see. See our file Jupiter file? We have actually solved a function, which somewhere using loops, just let me just find that out. Oh yeah, they're here. So here. So given a list of numbers, let's this make another list or maybe the same list that contains all the items in the sorted order, from minimum to maximum, your result will be another list like this. And we solve that using loops. Okay, let's solve the same problem. Exactly the same problems that solve the same problem using a different way using a different user using functions just to get a grip on functions. So let's say that's our problem we want to solve. So that's the problem again, and we want to solve that. So how can we solve that? To solve that, let's first define a function. Let's just make a function. Let's just make a function that let's just make a function, let's say define, find minimum and the function accepts a list. And we're times the minimum value in the list not only the minimum value of the list, but also the position of that minimum value. So find minimum as well as find out Some minimum as well as the position of the minimum in the list. So how can we how can we solve that problem? That's that's one standalone function, no matter what list you pass in, it will find the minimum. Okay? As long as the the minimum is defined for the items of the list, for example, the list items, or let's say all the metrics, okay, how can we how can we do that? Let's see, minimum value is the list. Zero, that's let's say, the minimum value. And right now the index at the minimum value is, let's say, is zero. Okay? like we did in the loops, like is, it is kind of the same goal, but let's try it a function for it. Okay. So that's the function fine, man. So how can we how can we proceed? What should we write here? Let's see a counter. Let's see. Concrete let's or it may be that city counter right now is zero for x in L. K, if x is smaller than our minimum value, if that's true, then the minimum value indeed is x. And the index where we found that is high, okay, great. Else do nothing I mean, else just go away. And I plus equals one. So move on. So AI is just the position so AI is moving on and on and on. As you follow the list, and M contains the minimum value and Id X variable contains the position of the minimum value. So that's the function for for readability, we might be adding an else clause just write balls. And that means the if condition finishes, I'm in do if this condition holds true, do that stuff, otherwise do nothing. That's just because of readability. If you want, even if you don't write the else clause and pass statement, even then everything is fine. So let's call this function just to test whether this function is working properly or not. So let's just find, oh, we haven't returned anything. We need, we need the minimum value as well as the index. So return a minimum value as well as the position so return that. Okay. Oh, but we do view returning that inside the loop that becomes in the body of the loop. Oh, no, no, no, no, no, that's bad. Because even in the first iteration, the return will be called an even in the first iteration, the function will finish indentation, remember, indentation. Now that's better. Now this is no longer inside the body of the loop. Great. That was a bug. We fixed it, right? Okay. So let's go find, let's receive a B, so a will contain the minimum value, and we will contain the index of the minimum value. So fine men, for example. And the list let's let's give it the list. 13423409. Let's say now the minimum value is zero. And that minimum value appears that 0123. That's the third index. So b should be three a should be zero. So let's see, what's the value? What's the result? So Brent? A, B? So A is zero? Yes. And the position of minimum is three, I guess it is working fine. rate. So that's one function, find a minimum? Let's find another let's write another function. Swap. So define. define another function, let's say swap values. And what we do is it it actually accepts two indices index one that actually accepts list then two indices, index one and index two. And what it does is it actually swaps the value of index. So index, one value should go to index two position and index two value should go to index one position in the same list, and then it returns the list. Okay, great. So it would it so so that's, that's a good example it would, it accepts a list type variable, it accepts index type variable which are integers. Great. So let's continue with let's define a variable temp that contains l ID x index one, just store it in a temporary variable, then at this particular index, next one, just copy this value. Don't worry, we'll see lists in detail. Later on now list. Now at index one, the value of index two is copied. But it is not overwritten, because we already have saved the value somewhere before that copying appears. So l at ID x two is simply damp. And now return the list. So that's how you can swap the two values if you want. Great. So let's just check it, whether the two values are swept or not. So let's say list is 236. And seven, that's a that's list. And let's say we want alto that is swept values. And let's say we pass the list and we want the values to be swept at position one, and position three, which may add position one, the value is three, because the position starts from zero, and at the third position, the value is seven. So we want these to swap. So the result will be 276. And three, let's see what's the result? So let's print out two. And yeah, it works great. What else? What else do we need? So we have find a minimum function, we have swept values function. What else? So yeah, what should we do? Now let's write the main function sorting. Let's write that function. And we will call we will use these kinds of functions inside that function when you call these functions. So let's define sort list. Let's say that's our function, it accepts a list and it returns a sorted list. Okay, what should we do? What do you think? What should we do for the very first time? Well, first of all, we should check whether all these list it contains the list contains all the numeric values are not let's say we're just doing this for numeric values. So, we should first check the all the arguments are are of numeric type or not, for that, we should write a function that should do that oh, remember that function is all written in in a module remember that module we made that module ourselves? So, we can import that module if we want import? My remember that my universal functions and we just need that function we just need that function one just from from my universal functions import what import check if Numerix check if not numeric, as you can write that function name something else, but justice. So you import that function. Now you may be able to use that function. So after that, you can use that function. If check, if not, numeric list or remember that function returns true if all the values are numeric, otherwise, it returns false. So if it is true, then move on the if it is not true. If it is not true, what should you do? If it is not true? If it is not true, then you might be printing an error. Error. Last does not contain numeric values, maybe that and then you just return. Return. That's it. I mean, return. Don't need to write anything in return. Fine. Great. So else we need not to write else because this return will take care of that but it is for readability. That's good, right health. If all are numeric, then what should we do? Okay, what should we do? If all are numeric, what we do is we will be doing what we will be fine minimum. We'll be finding out the minimum and then we will be swapping the minimum from what should we do what we we have already a function find a minimum that we can call just right away we have a function swap values that we can call right away. We already have used this function. How can we combine all these functions? How can we use all these functions just to achieve the problem sorting, we want disorder list. How can you do that? Okay. Yeah, that's, that's, it looks like it looks like a different thing. Maybe? Maybe. So, let's just write out, let's just for x in the list, let's start thinking here for every element that is in list for x and list what should we do? We should we should find out the minimum and slap the minimum with x r. So, we should find out the minimum as well as the index of the minimum and should slap it with with the value x and everything will become great. Yeah, I guess Yes. Okay. So, what what we are going to do is we are going to maintain a counter right now, the counter is zero, which is just the index, which we are going to do is we are going to find out the minimum minimum and index where the minimum lies. So, by find minimum in the list, so, it will return us the minimum as well as the index where the minimum lies and then what we do is, we will say, Okay, okay, what we want to do is, L is actually L is swap, swap values with index see swap values and list with index c. So, index c should be swapped with ID x and C plus equals one, will that work with that work? So, after this will the will the whole list be sorted. So, let's return the list is that true, I mean, we are finding out the minimum value one by one, the only catch is the list is updated here. And, oh, there was a problem. When we are finding out, when we are finding out the minimum, we are finding out the minimum from the list. And every time the same minimum will be returned. That's a big problem. So, looks like this fine minimum function is not doing our job, what we need to do really is the, we should go to find min function and give it that start your stock your final minimum from a particular index. So, don't don't search the whole list to find the minimum, start finding out the minimum from the following index, for example. So let's give a start index and maybe an end index. But let's give a starting next. So start searching the minimum from right from there. How can we change all the code right now? Oh, that's bad thing. Let's change the code. Let's say that's the start index. Start index. That's it. This the index right now is start index and I is also start up VB we may use a range function here, that might be much more feasible to us. So let's use a range function. Rather than this let's change the coding a whole lot. That's a bad thing we need to change the code for i in range starting from start index, starting starting from start index, ending at length of the list and doing a step of one Okay. Now x really is x is really list at the index i okay if x is smaller than m then this is that an index is AI. Otherwise this we need not to do this because this is this is happening automatically. And rest of the story is same, I guess Yes. That will work out. Okay, great. Oh, there is a problem. Oh, we just missed this column here. Great. We fix it. Okay. Now, so if value is there, maybe this works. Maybe Doesn't maybe there is a bug. Let's see, let's let's just call this function. So let's call this function l two is sort list. And let's pass the list as to 153. Minus 870. Let's see. That's boss this list and see what it returns. If it returns fine, we might be happy. Otherwise, we will see where is the bug? If there is a bug, oh, this does not contain numeric values. Why not? list does not contain numeric values. Why is that happening? bliss actually contains all the American values. We read the problem, check if not numeric, let's see the let's see the implementation of check if not numeric. Let's see that. Check. If not numeric, let's see the implementation. And there is the bug. Because all these are numeric. So check if not numeric x in arcs, if not is instance then return false. So if everything is int or float, so if x is int or float, then return otherwise return true. So it returns true if all our if all our numerix. So it returns true if all our Numerix so not true means false. And why why does Why does returning for us? So that is just was let us just see why it is returning false. That's that's the bad news that something is happening wrong. Let us just see how this is working. So that is just check. Check, if not numeric. And let's pass the list this list. And let's see what is returned. Let's just print the return thing. But it is either true or false. So it returns a false why it is returning a false. It is a bad thing. Why does they're turning a false? Let's go to the File. Let's go to the File. Here. Sorry. Let's go to the File. Here in this directory. Let's open up this. Maybe open this in simply an old bad. Maybe an old bad, why not? Or maybe some other fancy editor. Let's open this up and see what is happening. ad format font, let's have a bigger follow on and see what is happening. Self face one of 20 bugs are bad, they're really bad for x and ogs. Okay? If not is in stance. So first of all is in stance this, it will return true always okay. If not true, which means false. Then we'll move on and the loop will be running if anywhere you where it is finding out where it is finding out basically. So this this is working really fine. Let's, let's let's write this function somewhere inside our notebook and see what is let's say rather than this. Let's say this function like check the metric to check numeric to check it not numeric to let's call that function and see what happens check numeric to it is returning false again. Why does returning false? That's amazing. Where is the false? So two is integer? Yes. One is integer. Yes. So true. True. True. True. All these are true. OH minus eight might be a problem. minus eight might be a problem. Let's see. Maybe. I don't know. Well, well, there is still false. I mean, I'm stuck here. Guys. I'm stuck here. I don't know what to do. I don't know what to do. I have to debug this function, I have to go inside that function and see what is happening. So what we really are eggs. Oh my god, the big trouble big trouble. Yeah, I found the air. We are passing a list. And that list is just one argument. That is not a lot of arguments we have to pass all these arguments in in a different way. I mean, if you want to, you're getting you're getting the bug, the bug is we're passing one variable, not a lot of them 2153 817 these are not all different variables. For example, if we just go inside and print x, for just first x, it is the all it is all the it is all the list. It is all the list. It is not the variables one by one. Let's see. Yeah, I found the bug. Found the bug. Wait. Yeah, see, it is not? It is not a lot of it is not a lot of variables. It is not a lot of arguments. It is just one argument that is in the form of placed variable. That's incredible. What should we do? Should we go inside and add another function check if not Americ for lists, rather than variable number of arguments. What should we do? Let's write another function that check for the list. Let's write here check numeric to it contains the list for exam just accepts list ello or maybe l or whatever x or art just simply, you can call the or l list. And it goes through all the list. And does does the same job as previous. So now this will work. So the function that was there in our module is no longer working, and it will not work. So we are not going to use the function that is in the module, we are going to write another function that will help us here. And we have written that, and here we go. It just chained that function to that. And we just we just throw that out again. And let's see what happens now. Oh, there was another error whichever. Find a man missing one o v v did not find this fireman is missing the starting index. So the starting index is C rate. Right? That's a problem. That's a huge problem. Let's just sorted Oh, my god list finally is sorted. Oh, huge, huge, huge. So you see, you can call the functions inside other functions, you can call the functions from modules. If they are no longer working or no longer beneficial for you, you can write new functions, you can call them you can. Yeah, all that stuff. I guess that that lengthy video taught you a lot of lessons, how to how to code actually. And this actually happens when you are doing tasks that are really big. You have to define different functions, you need to define different functions for modular approach, and focus on each function as a separate entity. And that that makes much simplicity in managing the code and bug fixing and all that stuff. You see, I fixed the bug by just noticing that just by just focusing on this function. I have not thought anything else, just focus on that function go and see the implementation fix that everything else stays the same. Yeah, so too lengthy a swap here. Okay, now you have done a lot of practice about functions, loops, and a lot of stuff. That was all the basic programming in Python. In the in the next video, from the next video, we will see the real power, a much more real power of Python where you need not write a lot of loops and a lot of gold and still you will be able to achieve a lot of stuff. And for that we need to go through the data structures that are available in Python. So from the very next video, we will start seeing strengths that study or structure we will see less in detail we will see set in detail we will see dictionary in detail we will see tuples in detail. And after going through all these data structures and getting a good grip for the data structures. Then finally we will move we will move to the packages that are available for data science, particularly NumPy, pandas matplotlib. And we will see maybe I include maybe I include one or two videos for psychic learn as well. So hope to see you For the whole new phase in Python, the data structures, so we'll hope to see in the next video. Okay, let's dive into the long awaited strings. string is basically just a sequence of characters. And it's a data type, it's kind of a data type. In Python, it's much more powerful. The reason, the reason of, I mean, making this a whole new data type in, in almost every language is, the reason is that almost all the data all the text that appears in sequence of characters, so making that sequence of corrector, the whole text as one kind of data type, and writing special kind of functions to, to deal with that text might be necessary. And that's what the string is. In Python, for example, you can declare a string variable s, or any variable name, by just double quotes, let's say ABC, are our equal monthly by a single quotes, either way is fine, d f. So either way is fine, you can declare using double quotes, or single quotes, either way is fine. One thing is, be careful, don't mix. I mean, don't start by a single quote, and think that now I will end with double quote, and that will be fine. So don't mix them together. If you're using single quotes, use single quotes, if you're using double quotes, use double quotes, don't mix them together, that might be much more confusing later on. So let's say this S is a string, Python is the best language for data science. That's a D is another string that is defined by single quotes. In this course, we are going to learn Python, then you can print s, different in a different way, let's say you will call you can call a brand s, you can call a print to D. Or you can just by the way, you can you can add two string variables s and D. And the result is a new variable. That's how the plus symbol works in strings is plus in strings means just concatenate concatenate them together. So first, you just copy this string, the whole string, and then you just concatenate the other string with it. And the result is a new string. Now that's a new variable, you can use that variable and do a lot of stuff with it. So let's go to Python and see actually, the brains in in the strings in in the running form. So let's say S is string, let's say, right on is good language, let's say. And let's have another string T, that is using single quotes. It's good for data science, sci fi. Okay, it's good for data science, let's run these two, and see the type of s was the type of s. The type is str string, str, that's what the type is. And if you just print s, that will be printed. Python is a good language. Remember, so far, we are using this sprint. And always we use this kind of Hello or something like that. That basically is a string because by the way, the sprint function, actually, it takes an arbitrary number of arguments, we can print hello, then we can print anything in another type, then we can print another Hello, let's say hello to hello to that's a multi multi variable argument function print, then we can have another string maybe Who are you. And then maybe a floating point number 5.9. So we we have used these kind of, we have used these kind of, I mean stuff a lot. We have used print function. And we were using these double quotes again and again. But but these are actually strings that we will be that we were using later there. So the spring function actually accept strings and all these kind of Normally, the whenever you use print, normally you're using it normally you're going to actually display some text, and maybe you're writing that text into some file and so on. So this string is highly, highly useful. Most of the data is available in the text form in the screen form. And we want to process the data we want to find the anomalies in data, we want to fix them again, we want to stay in the text. So it is good to have a data type that actually have a lot of functionality that handles all that stuff. So Let's see, for example, another another, let's see how can we concatenate the two strings, for example, SMT. Let's say we have B, that is s plus T, that's concatenated. B. And that's francqui. And we is going to get an ad. While bicon is a good language. It's good for data science. Well, it is concatenated. But there is no space between two because wherever the first string ends, the second string starts right from there. What if we can get in a three strings? s plus another string that just contains a space corrector? Then this string? Why do we whatever that is there in double quotes, or single quotes, whatever, one corrector to track character, all these things are called strings. So now we are concatenated, three strings together as a space, one space string that contains just a space greater than T. And let's see what happens now. So Python is a good language space, it's good for data science and so on. Well, so yeah, so that's basically the introduction of string. What if we want for example, to concatenate? What if we want, we have a variable A, which is 12. And let's say we have variable b, which is the price of this book, let's say the price of this book, and a is 12. So let's say this is our price. Now price is in integer form S is in book form, let's say we want to make another string we, that contains the following kind of thing, the price of this book is and then whatever the private price is, that should be there. So what how can we do that? So let's say s, plus, maybe, maybe another string is then maybe a space. So that after that the price appears? Now, if we right plus and right price, price is no longer a string, it is an integer, and an integer cannot be concatenated the string in a straightforward way, like plus, how can we how can we make a message like the the price of this book is, whatever the value of the price is, one way to do that is to convert the variable price, the Convert the type of the variable of price, from integer to string, that means whatever the value, in this case, 12 is written, that becomes a string of characters one and two. And now it can be concatenated with with the rest of the string, and we will contain the message that we want. For example, if we now see what is free, that is, the price of this book is this book is 12. Oh, we don't have a space before. So let's let's type a space, their space is also a corrector can be handled in strength, while so that's how we can convert different types to string. We can have a float type, we can convert that to string, and so on. Another way of doing the same or achieving the same kind of stuff is to write Brent, the price of this book is I mean, we can use the power of the variable number of arguments of then price, that's exactly the same thing. The price of this book is 12, the price of this book, however, consider one thing, the print function automatically adds the space for different kinds of arguments. You can see that here, yeah, you need not to specify a specifier space, the space is automatically added if it is if it is considered to be a different argument in the print function. Okay, great. So that's the introduction of a string. We are going to explore string much in in much more detail in the upcoming video, so stay with us, we are going to see a string in much more detail. Okay, hope to see you in the next video. A string might be very lengthy, or may span I'm in very lengthy and may span more than one lines. Or maybe the formatting is in a way that you want to even if even if it is not very lengthy, you will still want the different chunks of the same string to be appear in different lines. So there is a way to declare multi line strength again using either three single quotes or three double quotes. And then three double quotes or single quotes. Whatever convention you follow Then you write all the string in, no matter how many lines you want, and that one variable actually contains a multi line string. If you now print, for example, if you call the print function on this multi line, that that's By the way, a variable name, multi line string that contains this data, multi line, multi, multi line that now the spelling our Spelling's around here, I just created multi line anyways, if you if you call that print function, this will the print will display the string as it is like it is there. So let's see the and by the way that the same multi line string kind of fashioned remember that that is used for comments as well. If you have comments that span on multiple lines, you can use this. So this multi line string really is if it is not saved in a variable and used as it is somewhere in the code, then that acts as a multi line comment. Great. So let's practice the multi line string in in Jupyter. notebook. Let's see. So let's say we have a variable A that is multi line string. And let's say the spring is this is line one. Then we have this is line two, and then we have this is last line. And this line is three. That's it. Okay, great. That's a multi line string. Let's see. How can it Brent a, what happens? So this is line one, this is line two, this is last line and this line is three? Why this? The first this is shifted one corrector, right? Oh, there is a space here. Let's remove that space if not required. And run this again. While because space is a corrector that will be printed if you want. Okay, what if you really want really want the following kind of stuff, you have, let's say brand. So what you really do is you want to bring the following the following options are available. And the options are, let's say dab, dab, dab, let's see a hyphen, a. And that does play from a that does nothing. And then we have let's say hyphen B and they're also also does nothing. Let's say you want our message to be painted in in such a way, what will happen? Let's see. Okay, the following options are available hyphenate has nothing hyphen B I mean, all this is a string multi line string, these crackers that you think they are not there, these are spaces and they are I mean the spaces are painted here, the spaces are painted here, we are saying nothing is printed, these are the spaces that are printed there. So sometimes this multi line string, it helps to format our message in a way that we like. So that's how helpful in most of the cases further if you write this multi line, by the way, if you write this multi line, comment in the start and end of any good script. That means the if you write this multi line way of defining the strings at the start and end of any good script, that code script is commented that we have seen several times earlier as well. So, for example, in problem solving, remember that we define all? Oh yeah. So that's the comment. That's a comment. Even if some code is written inside that will not be executed. Right. Okay, so that's about the multi line string. In the next video we will see because because the string really is, is basically a collection of all these characters. What if we want to access a particular character? For example, this is the first graduate is d here, the second Gregory is at the third correct? Is it the fourth record is S, the fifth Gregory space and all? What if we want to access particular characters inside the string? Because the string contains a lot of directors? What if we want to play with some of the directors inside the string? How can we access different directors for example, if we want to access seventh director of the string, how can we do that? So, let's see in the next video, how can we index different characters inside a string, I hope to see you in the next video. Okay, in this video, we are going to actually access different characters inside the string, sometimes called indexing, the term slicing is basically more relevant to arrays, lists are actually the immutable structures, but we will see, I'm just comparing, because you may listen this term slicing again and again, but really this indexing but we will see the indexing or slicing sometimes is you these two terms are used interchangeably, we will see the examples of slicing in detail in lists. And, and in more detail in NumPy arrays. But here, you just think that indexing and slicing are the same things. index. So for example, I have this a let's say this is a array, and I want to access its fourth element here, the fourth corrector element is E. By the way, this a is a variable, if I want to access the very first corrector the the indexing the number, the positioning starts from the integer zero, that's the first corrector. So if I want to print out of it, that will print g if I access for example, if I write the index three, what do we mean that means the fourth element, the fourth element is he what will be printed, what will be printed, if I access the fourth element of the index for a fi access this thing or space will be printed and you will be seeing nothing because when a space is printed, actually, nothing colorful is printed there and you might be thinking Oh, nothing is printed, nothing, nothing has been accessed, actually a space corrector have been accessed. So yeah, a more we can we can we can actually access, we can actually access a substring inside a string as well. For example, we want to access for example, a substring starting from index three, and all the way up to index eight, but does not include the index eight. So it will include the corrector at index three, which is he correctly at index four, which is space, let me write space in this way. Director at index five, which is Oh, correct, read index six, next record, which is F, then a space, which is seven, and then the correct read eight. And so this is not included, to be accessed. This is included, this is inside, this is included. This is not included. So we can access a substring. So starting from three and ending at eight. Let's see, let's see an example. And you'll come back to this slide again, after after a few minutes. So let's say we have a spring as let's say, how are you? And who are you? That's it. So let's do that. So spring, okay. And what do we really want is we want to access for example, the, we want to access the element to access the elements, you have to write the square brackets. That's a standard notation. In Python. Whenever you have a collection and you want to access different elements, that collection might be a string that collection later on, we will see might be a list. Maybe a tupple dictionary may be a set. Maybe a NumPy array may be a panda's structure, I mean, anything that is a collection, normally it is accessed by It has different elements, and we want to index them. The indexing division is square brackets. And indexing always starts from zero rather than one. In Python. There are some languages in which the indexing starts from one for example, MATLAB, the indexing starts from one but in Python and in several other languages. The indexing starts from zero, which has some benefits or starting with one it has some benefits. So starting with zero is okay is okay. So let's say we want to access element at index five. The element at index five is actually the sixth element in the string starting from zero. So first, second, third, fourth, fifth, sixth, so our will be printed. So let's see. Our is printed. Let's check the let's check the type of this return value. Let's check the type of this this one element which is our what is the type of it subtype of different elements in a string different characters in a string? What are the types So what is the type of it. So the type is also string. So each and every corrector is also of string type. In some other languages, the type might be a corrector. corrector is another type, but in, in Python, each and every one character is also a string. More than one. correctness is also string, as long as they are accessed from a string. Okay, let's access for example, the element number three to element number, let's say eight. So the result is our so element number three, not three, actually starting from index three, which means the fourth vector, which is space, and then e, r, e, and then space, and then we finish. if you for example, move to from three to nine, let's say, and the the rally will be our why or we may move to from for example, we may start from the very beginning. So for example, index zero, we may end at the index 10, but not including the 10. So the result is, how are you and then I mean, why Oh, and not the you included, because that's index number 10. And index number 10. The last index is not included. Great. We can have negative indices in strings as well. So a negative index is just just the indexing from the right side, not from the left side, for example, on negative index. So minus one points to the last corrector. For example, you similarly minus two points to the second last corrector, and so on. So minus one, that's a success, you. And similarly, we have minus three, and that will access why, or we may have start from let's say, minus, start from let's say, minus eight, and go till minus three, that means go back to go back to minus eight index, and then move to minus three index, okay? And minus three. In this case, let's see what was the result are, what is that? Why are? Oh, this are, I guess this are? Let's check it out. So this is this, you, this is minus one minus two minus three, that's an X number three. So three is not included. minus three is not included. So it has to stop here. Okay. That's minus four minus five minus six, minus seven and minus eight. Oh, great. So that should be printed, it has printed. So let's say we have rather than minus eight, we start from minus 12, and be raised to minus three. So we're okay. Great. So we have negative indices as well. And by the way, this kind of fetching this kind of substring is sometimes called slicing, I mean, we are just fetching the slicing, although the term slicing is much more popular in, in in mutable data structures. What What is a mutable data structure? What is an immutable data structure? Well, yeah, I should tell you right now, you can change, you can not change any corrector in the spring. That might, that might look like a bad news for you. But once the spring is created, the elements in the strings are not changeable. So for example, let's say at position number one, you want to place a corrector. Let's see, that's not possible. And the reason is, the string is a data structure, the string is a variable type a data type that is immutable, immutable, are unchangeable. Once created, you cannot change its contents, they stay fixed, you cannot change them, you cannot alter them, you you cannot delete certain contents from it. I mean, once created, it stays as it is, you can copy this into another string, you can copy and paste, but you can get a substring and copy into another variable, for example, but the contents of s cannot be changed. So all the kinds of data types in Python that are unchangeable, the contents are not changeable. They're called immutable. And string is immutable. So so the the time slicing makes much more I mean sense or it is more popular in the data structures that are mutable, that are mutable, although, you can use time slicing indexing both interchangeably. But it refers to roughly in reference to fetching the sub structure or substring. In this case, in the list, it will be a sub list or so on. So that's what slicing is. Yeah. Great. Why don't we do some more fun with this spring? Yeah, let me show you more fun with this rank, more indexing, let's say you start at index zero, you go to index 12, but not including 12. And then you jump, you take a jump of two rather than one, what we'll do is, it will fetch all the corrector starting from index zero, all the way to index 12, but not including 12. But it will take a jump of two rather than taking the jump of two. So first greater than take a jump of two, then pick a corrector, then take a jump of two and then pick a corrector. So it will actually pick every other characters starting from zero. So let's see that. So for example, if you remember the string, that's the string. So it starts from h Fine, then it skips Oh, and go to W, then it skips bass and go to a then it skips R and go to E then a skip space and go to u and then it skips Oh, and go to a shoe and then the cloud achieved and we stop there. Wow. So the general way of slicing or indexing the general way is you have a starting next start, then you have an index and then you have a step size. If you do not mention the step size. the step size by default is one that we were doing already. If you do not mention the end, the default end is the building and the total list size. If you do not mention the start the default start is zero. For example, let me make that a comment and just practice a few for example. Let's start from zero we do not mention the start let's start from zero and go to 12 if you do not mention the starting index that starts from the very beginning zero go till 12 Okay great. If we do not mention For example, we start from three and we do not mention the end that means go till the end starting from index three including the last corrector Okay, if we do not mention the step for example, if you start from one go till 12 and we do not mention the step, the default step is one okay. There is one way of reversing the string, I mean very beautiful way I mean, you do not you do not start the mention and you do not mention the start, you do not mention the end, and then just take a step of minus one in this particular way. The Start and End index they are they are just swept and you get the string reversed way. While so that's the reverse great. Isn't that fancy? Yes, it is. Okay, a lot about indexing, you can find out the length of any string by using l m function, you can find out the length of any substring if you want to if you have a substring using again a lamp function, alien, that's okay. Okay, and now you've seen how to access sub strings and how we cannot change the elements of a string because it is immutable, but we can access them, we can access them, we can just display them, we can analyze them and so on. In the next video, we will see some functions that are supplied for string processing, what we can do with strings, I mean how can we manipulate those strings, although we cannot manipulate the contents of a string, but we may copy a string we may get explained, manipulate it and save it to another variable and how what kind of functions that are available in string in string data structure string data type. So let's see that in the next video. Hope to see you in the next video. Okay, let's see different functions that are available to play with the strings. In this dense string data structure, let's say you have the string a a lot of spaces, these are a lot of spaces at the beginning and these are a lot of spaces at the end there are some spaces in the middle as well. So, there is one function called strip all the functions of the string they are called by taking a dot A dot something These are called methods you can loosely call them functions, but those kind of functions that are related to some data structure and called with dot, they are sometimes called methods. The term method is more related to object oriented programming actually string is a class. So all these are the methods But even without knowing that it's perfectly okay, you can call it method or function that's perfectly okay. You can, I mean, it's okay. It's okay without knowing what a class is without knowing what an object oriented programming is, this a dot some function that operates on this a. One difference with method and function is when you call a function with a dot, and you call some function that say, a dot strip. Then inside the definition of the function, this a object or the a variable is available, like, like you have passed that variable as an input argument. That's all you need to know about the difference of matter and function, the rest of the story is perfectly okay. Even if you don't know that that's fine. Okay, eight outstrip, it operates on a which means that a is passed in this function as just as input argument or it is available there inside the function implementation. And then the script function, what it does is it removes all the spaces that are in the beginning, and removes all the spaces that are at the end, and returns another string that has that has no spaces at the beginning and no spaces at the end, and the new string is copied or created in a variable b, let's say whatever that we believe we can, we can have another name of that variable. So let's see. Let's see the running form of this script function in our friend Jupyter. notebook. So let's say a is a string variable. That's a lot of spaces abcdef, a lot of spaces and hg gilwell, whatever. And then a lot of space, and that's it, this is a and then we have B, let's say a dot strip. Okay, and that's sprint B. So b is actually everything without spaces without the starting spaces. And without ending spaces, it does not hurt the spaces inside. So that's the script function, sometimes processing the data. When we when we read the data from a file, it may have a lot of spaces at the beginning at the end, maybe due to formatting issues or something like so and it is this function is available. If we want to remove those spaces from beginning or from the end. Let's see more functions. Another function is lower, like the name suggests it actually it actually converts all the string to lowercase. For example, let's say we have a string, let's say, a B, A, let's say we have a string, a equals A, B, C, D, E, F, G, and some directors, some other directors and Q f, let's say that's a string. And now what we do is b equals a dot lower. What it does is it converts all the string to lowercase. For the characters that are already in lowercase. It doesn't hurt it. For the characters that has nothing to do with lower uppercase, it doesn't hurt that all the characters that are not in the lowercase and can be converted to lowercase, those are converted to lowercase. And this is available. Yeah. Great. So similarly, we have another function called upper for example, C is equal to a dot upper that the like the name suggests, it converts all the characters to uppercase. Well, let's see more functions. Oh, there is a function replace the Replace function. What it does is it takes a substring and replaces that substring with another substring. Okay, let's see. For example, let's say we here we want to be have the same a, let's say the a is this thing. Let's say that's a and what do we want to do is we want to replace the semi colons let's say with with with the semicolon, we want to replace the semi colons with statics. So what we can do is we can say okay, d equals a dot replace, replace the semi colon with with let's say steric. Or, yeah, so let's see what D is. So each semicolon is replaced by a steric. By the way, if you if you want to replace for example, a, a dark replace, if you want to replace one is there one semi colon One semicolon with a string. For example, the string is star star, and, and hashtag or some person. That means one semicolon will be replaced by this, seek with this string, and the other semicolon will also be replaced by this screen. And the result will be as expected, each semicolon will be replaced by the screen. And that's the result what it is further if you want, for example, if you want, for example, let's say d equals a dot replace, if you want this particular substring, that contains the two semi colons, if you want the two semi colons to be replaced by another substring, let's say two semi colons, let's say. And that is also possible I mean, you, you replace one substring with another one. Right? There is one more function called split. That what it does what what the split does is, for example, you have a string, for example, let's say a equals a string, let's say, ABC, then you have this colon, then you have d f, then you have semi colon, then you have ads g y, there's Dan semi colon, then you have y y 3223. That's it. That's your string. Let's say you read that string from some CSV file and disappears. And now what you want, you want all these values to be separated out that are that that are separated by the semicolon, maybe these are different values, ABC is a different value, then it is separated by a semicolon semicolon may be an indication or token that the next value started and so on. Let's say you want to separate them, let's say you want to just split them all of them with a particular splitter. And here, let's say the splitter is semi colon. So what you can do is you can have a list and a dot split. And in the split, you can specify the corrector that that is used for splitting after and before we split that. And remember, the split function actually returns a list of strings, where this is the first element of the list, this is the second element of the list, this is the third element of the list, this is the fourth element of the list and so on. Because once you will split, you will be having different elements that are split it out. So if your brand for example, l we will be having a list of different strengths, ABC and all that, Oh, don't worry about the single code, the single core and double core is the same thing. Now we can access for example, the third element or or maybe the second element by index one. And the second element here is D, E, F, and we can work more on that. Okay. Is that it? I mean? Are these the only functions that are available? stripped function lower a birthplace and split function? Or is that it? That's all the spring is about? Maybe there are more functions? How many functions are there in string? How can we use them? What are the what are the total number of functions? Where is the list? We visit documentation? Should should we follow some book? Should we go to some tutorial and find all the string functions and see how to use them? Well, if you want to do that, you can do that. But there is another smart way. Let's say a is a string that you know, you write a dot and then a press tab, and all the things that that are there in in string, they will they will appear in front of you on several things. You can go to this, you can go to that you can go to that and so on. So just you can check the documentation of a for example, if you if you press a and what it does, let's see. It's a string object and all that stuff. Fine. It's a string. So further what we can do. So let's say a.we, press A and then we press tab. Is there anything that starts from a Nope? Is there anything that starts from B? No. Is there anything that starts from C? Yes, capitalize case fold center count. These are the functions that are available that starts from C. Okay, let's focus on capitalized. Okay, what is that thing how to use it? That's press colon, question mark and see what this is and what it does. Okay, so here is the documentation here is a doc string returns capital. I used to worry enough the string capitalized version of the string. Is that the same as upper? Maybe? So let's see. Now we know what it does. Let's just check it out, print a capitalized and see what's the result? Oh, it's got Oh no, it does not get delays the whole screen, does it? Did they the screen a was it does not capitalize the whole string? What What is a? Let's see what is a? A is the following string is the following string, so it does not capitalize the whole string. Oh, the difference between the capitalized maybe? And the upper? Is that the capitalize when it encounters when it encounters? No, no, no capitalized just capitalizes the first corrector. Let me let me read the doc string, again, returns a capitalized version of the string, more specifically make the first corrector have uppercase and the rest lowercase. Okay, that means if we have a string that has a mix of values, the capitalized will do the following. It will convert the first character to uppercase and all the rest of the characters the lowercase. Wow, that's awesome function. For example, if you have string, abs D, A, B and GG, kill that say. And then we call capitalize, capitalize, let's say. So what that does is it actually capitalizes the first director and all the rest of the directors there as it is. And there are other functions as well, a dot A dot, let's see count, what it does a dot count what it does not count. What is that thing? Let's check it out. Or maybe we can check that out using help. What is zero count? So let's see what is a load count. It's a built in function called matters is an instance of and it returns a number of non overlapping occurrences of a substring. Sub in Oh my God, if you I mean, that's what it what what is written there, non overlapping apprentice of a substring. Great Oh my god. So basically, there are there are a whole lot of functions of strings that are available, there are several use of the string, there are several ways of molding and playing with the strings, some of the functions that are available, some you can make your own, you can make your own modules on top of that, to customize your written to customize according to your requirements. A lot of these are available, and you should know how to use them. And first thing if you want to do something with strings, or with any data type in Python, first check whether some method is available or not. And one way to go that is just right away from here. And other ways to go to internet and see I want to do this in Python. with strings, whether there is a function available or not the good chances are there will be a built in function that is available. And in that case, I will encourage to use that function rather than to write your own one because using the built in function, or the method that is tied up there will be much more faster probably than the function you will be writing at your end even if you're too smart in algorithms. So yeah, so that's about the spring matters, there are so many other methods that are available. In the next video, we will see some more some more manipulation and processing and some more working with strings. And then we will move to other data structures. Okay, hope to see you in the next video. In the last video, we saw some methods of string. And these are just a few of them, a lot of them are available. We just we just discussed some of them. In this video we are going to talk more about strings in a particular way. For example, what if you want to find out whether a particular substring is there in a string or not. Let's say you have a string and you want to know whether a particular substring is there inside a string or not? Well, you can easily find out that using the end keyword. And similarly not in means the reverse of that, or the complement of that or not of that. And in keyword always will return either true or Boolean or false. If it is inside the screen, it will return true if it is not inside it will return false. So let's check this the implementation of that in, in, in Jupyter Notebook. So let's see. So let's say we have a string ABC ABC. And we want to check whether this string is there in this particular string or not. So the return value is false because ABC as a substring is no longer there. A is there. For example, here, a B is here, but ABC is no longer there. Yeah, so if we, for example, have an ABC somewhere, at least once, then the result will be true. In the last, in the last video, or maybe in the very first video for strengths, I showed you that you can use plus with strings, can you compare two strings using less than or equal to? I mean, how to compare two strings, whether they are same or not, for example, ABC, that's a that's a string ABC, I want to check whether that string is the same as ABC or not, what will be the result? So so so the question is, is this double equal to is used can be used for comparing two strings? Well, the answer is yes. Or what will be the meaning of less than a string as less than the other? Is that true? For example, ABC, is less than, let's say d f. Is that true? If it is true, for example, what does it really mean? How can we define one string is I mean, this string is less so than the other string, maybe this, maybe this operator is working based on the length of the strings. But if even if that, then this length is the same as this length. And to be more precise, we can change that length, for example, by just saying, okay, ABC, D, F, G, H, I, and I guess this string will be still smaller than the right string. So how this comparison is working? Well, I guess the comparison is working based on the based on the alphabetic order, and you know, the alphabetic order, a B comes first and B and C and all the alphabetic order that is there in English dictionaries. That's how the strings are working here. And the alphabetic orders for all the special characters will also be defined in Python, for example, that's a special graduate, for example, maybe this string is this string smaller than the following string. Yeah, we've done for false, because there is particular ordering. In, in Python that is defined for these characters that this becomes first and there's like, a becomes first and B, B becomes first and C and so on. So whatever the alphabetic order is, based on that, or you can compare the two strings, no problem. So these are also available. And the third thing is in function that is also available to check whether a particular string is inside a substring is inside or not to in another string. One more thing that I want to talk about in that, for example, what if your goal is to print the following, let's say let's say you want to print the following, we are learning. And let's say you want to print the string in double quotes. We are learning string here. Let's say you want to print this, you want this string to appear in double quote, how can you do that in Python? Well, it looks like same. What's the difficulty? Let's Let's call the print function. And then just like here, we are learning. Then write the double quote here, scraping. And here. That's it. But there is a problem. The reason is, the reason is when we call this, when we write this double code, actually, the string ends here, exactly the string ends here. And when we write this single code, and this double code, another string starts here. And this is no longer a string. I mean, what it has no data type inside. Well, how can we then insert these double quotes inside? Well, there are several ways. One way is to use escape sequence and escape sequences just like it is you use a slash and then whatever you use is considered as a corrector. Inside the string that is you're using it now if you want another double quote, you use a user corrector which is the backslash or maybe a forward slash and if you use that That means that means whatever that is coming in front of it should be used as it is, rather than, rather than considering that that's a special string defining symbol. Now in this particular case, you'll be having your double quotes available, and the backslash will be just out, it's justifying that don't touch this double code, it has nothing to do with defining a string. It is just because I want to highlight this word. Another more. Another more easy way is to use the single quotes, for example, we are learning and use the double quotes as a corrector. Inside that now the single quote, wherever it starts and ends, they defined the string, everything else is correct. We do not need a escape cracker where we where we want, okay, great. But there are a lot of escape characters, for example, we have V, our backslash n, that means go to new line, we are now on an other line. So this backslash n actually puts everything that comes after to a new line. That's an escape corrector. Similarly, we have an escape corrector, backslash D, that actually inserts a tab. Whenever we want Sophie, then a tab then now on another line, now on another tab, whatever. So there are a lot of escape characters. I'm in backslash, N, backslash t there are other. So it is good to know those. One more thing that is important. For example, let's say you want to print. Let's say you want to print some address on the right, let's see, Mac's slash back slash forward slash whatever that is called name, backslash Dr. Let's say you want to do that. And your goal was to just print that box, what will happen is this backslash n will be treated as a newline escape sequence. And backslash n will tell Okay, go to the next line and create the rest of the things. But because backslash D is not any escape sequence, it is not listed inside, it is treated as it is and that way this slash is also treated as a director. But here because if this slash followed by this n, that's combination that is already there for a new line that is treated in a different way. If you want this to be used as a deus and you don't want these, you don't want this behavior, you just want that all this should be greeted in a very literal or raw sense, then you should just apply and are there in our will tell, okay, that's, that's a raw string, everything inside just treat that as a raw string, there is no escape sequence inside. Great. So and there is much more about strings, we can talk but that that was the most important that I that I told you, at least to me, we can explore this more actually, you should now explore the smaller What are other functions of string, how can we play with strings in another way and stuff and so on. If I talk about strings, I can just I mean, I can give a whole course on strings as well. But here I just give you a snapshot of strings. If you need more about strings, I mean you should be searching on internet of seeing documentations and seeing basically what you want according to your requirements, search the functions probably they will be available. Okay. In the next video, we are going towards list topples, sets and dictionaries some other data structures that we were talking about earlier, we will be going to explore them in more detail from the next video. Hope to see you in the next video data structure informally or in a very naive sense is basically a collection of a lot of basic data types that contains data one structure contain a lot of data. And we can define sometimes several methods and several specialized kind of functions are customized and define just because of that data structure to perform efficiently different kinds of I mean for different kinds of tasks, we may have to define or we may have to choose different kinds of data structures. The basic data structures that are available in Python is a list tupple set and dictionary. These are the basic data structures that are available. We can create our own data structures if we want to. But most of the problems almost all of the problems mostly they are solved by these four basic data structures. Although a lot of these are not that efficient. There are efficient ways for customized kind of problems, we will see that efficiency when we will deal with the package NumPy that is, that is faster than all of these, but will but we will see what kind of constraints are there to make it faster. Anyways, data set in a very loose term is collection, it is a collection of a lot of values a lot of data inside. And all these data structures list tupple set and dictionary, they they are a collection of data of heterogeneous types, which means one value can be integer another element let me call an element, another element or item, another item or element can be of string type, another element can be off, let's say floating point number another element is a whole list itself another element is a topple and so on. So different elements can be of different types. And that makes this heterogeneity that makes these four data structures much more applicable and much more abstract. And they can be applied to almost all the problems. So let's see one by one and let's compare them together because the best way to understand four of these is just to compare them which can do what as compared to the rest. So let's let's compare them and learn how can we use those in detail. So list first is list list is ordered ordered here means it is indexable which means there is a particular element number one is at position one element, there is an ordering of elements first element second third 25th element, there is an ordering of element with respect to their position. So that's what we mean by ordered changeable or sometimes called more more reasonable term or more usable term is mutable. mutable means once the list is created as contrast to string, once the list is created, you can change its elements for example, you can change the third element with another element and that's perfectly fine you can change it that what we mean by changeable or more popularly called as mutable duplicates means the list can contain more than one one element more than two, I mean, at the position number three, you can have the same item and position number five you can have the same item that so the duplicates are allowed tupple however, although ordered, there there is an ordering of elements there is there are indices of different elements, this is immutable, you can once topple is created like strings. Once the template is created, you cannot change different elements in the tupple you have to create a new topple if you want to, but you cannot change the items in the tupple and the duplicates are allowed again set on the other hand is unordered which means there is no indexing there is no positioning, there is no first element there is no third element, there is no Fifth Element, there is that's a collection without it without actually indexing because you cannot access a particular element with index you cannot change it, but what you can do it you can insert more elements and you can remove existing elements if you want to. Again, the set like in mathematics sets does not contain any duplicates. So one item appears just once we will see the examples Dictionary of very, very, very powerful data structure. Again, it is it is dictionary is just like a set, it's a set it is unordered. Again, chancer bow, you can change them but you can change the items you can and the dictionary the pocket and it does not have duplicates, because it's it's basically a set it is just like I said, the power of dictionary is each item consists of consists of a pair and one one value in the beer is called key and another is called the value for example, well is key for 12 name is key for band and and so on. So we have seen this dictionary before in loops and stuff in just a very loose way. But then that's really a very, very powerful data structure. And later on we will see in pandas basically all the data is basically managed, just like a dictionary if you if you have a good knowledge of dictionary, you will be having a very good grip very quickly on on a Big Data Science Library or Big Data Science package which is called pandas because each and everything in pandas is handled just like you're handling a dictionary. So it's it's a really powerful data structure to know about. So, so so list is mutable dictionary is mutable set is mutable, in a sense that you can insert and remove elements. topple is not mutable. And that's a comparison theoretically What is there, all these types, each and every of them is a collection of different values. And the values can have different types. That's the that's the abstract power of all these data structures. So, in the next video, we will, we will, we will actually try to get a good grip on list topple set in dictionary and we will actually define them code and access different methods of those and we will be we will be trying to become comfortable with with these data structures by coding them in Python. So hope to see you in the next video. Okay, continue in previous video we were talking about data structures in the last video. So let's go to the Jupyter Notebook and see how a list can be defined or declared how a tuple can be defined or declared set and dictionary, let's see how can we make these data structures in Python? So then one by one, we will compare how can we access elements of the list? How can we insert more elements in lists tuples are in dictionary and and see the comparisons of all these one by one operation by operation. So let's see. So let's go to Jupyter Notebook, our friend this file is getting lengthy, lengthy, let's let's make multiple files. Let's say this is part one. Just save it. And let's make another let's make another file. For example, let's just close this file, or maybe state opened, let's close this file and make another file. Python three. Yeah, so let's name that file as this part two, let's start a new file that that file was on in that was okay to stay with that file as well. But just let's make another file. Okay. So that's just have a markdown cell. And let's have a heading. data structures. Remember the markdown cells, I just introduced them introduce those just in the very beginning. And then we just forget them. Because writing these description again, and again, we'll make the video length here. And the purpose is not to actually format the notebook, the purpose is just to show you the power of Python. So I just omitted writing these descriptions more and more, but just write a few descriptions in the star and then we will forget again. Oh, that's it. That's amazing. Let's see, find a list. So list. Any variable name, that's a variable in the list is, let's say this. You define this by square brackets and different elements they are separated by comma, that's a 134, point nine. Name anything I mean, or five, or maybe maybe three again. So that's the list. Okay. ductile, on the other hand, is defined using parentheses. So let's say 134. point nine. That's the name. And that's a three again, that's okay, that's a tupple. A tupple is defined in. So when you write parentheses, that means by default that topple the variable name has I mean, if you have written t that has nothing to do that it's a tupple. That's because the Python is dynamically typed. When you will write the parentheses that means the tupple is being defined. Let's define a set Let's call the variable as S, the set is defined with with these curly brackets. So let's say 134. point nine, I want to tell you that all these things they can contain each element can have a different type. But then, even if we include this three again, because the set cannot contain the duplicates, later on, we will see only one copy of three will be there in the set, the other will, even if we want to include it will not be included. Okay? Then let's say a dictionary. dictionary is again defined like a set, but but each element is a pair, separated by a colon. Let's say the key value is 23 as a key value, that's the key and the value. Here is a string, let's say two, three, that's let's see the value. Now comma. Now one element is there. This one element that consists of key and value pair, another element, another element may have a key with string. So so the keys can be of different types, the values can be of different types, and so abstract. So the key is, let's say, let's say B. and the value for this is, let's say 43, then maybe we can have another key value pair with key as, let's say, c. and the value is, let's say, cc. CCD. That's a charge coupled device. Okay, anyways, so. So again, now you know how to define less how to define a topper, how to define a set, and how to define a dictionary. The difference is, is the main difference here is in dictionary, because one element consists of two values rather than one. Okay, let's print that and see the types let's print all the types sprint died off. So let's paint them. That type of L is. So the table L is just printed. That's L, let's print that. Let's see the other types, let's print the rest as well. So just copy them and B is the type of list L is that the type of topple is D. And that's a D, then we have s and then we can just replace this to the s. And then we have, let's say, D dictionary. And that's, that's D. Okay, so that's been, so the type of L is less the type of t is topple the time of s is set. The dive of D is dictionary. Oh, great. So that's how you can define these lists. You can define list you can find topple, you can define set, and you can define dictionary, no problem. Next, let's see how to access different elements from from these data structures. What are the way for example, to access an element from a list, let's say the element number element that indexed with one remember the element that index with one is element number two, because indexing starts from zero. So you can access that using the square brackets. If you want to access from topple again from the square brackets exactly like the list. In set, for example, you cannot index it because the set has no ordering. First, second third element is no longer there. But you can you can, you can check whether a particular element is there in the set or not using in keyword. In dictionary, for example, if you want to check whether a particular element or if you want to access value, for a particular key, you just create the dictionary variable name and then write the key and it will return the value. Okay, so let's practice this in in Jupiter. Let's just practice this in Jupiter. So let's say list value at index one. So that's brand new, this list added next one, the value should be printed as three brand topple at index one, again, the way of accessing the same Brent Brent, whether three in s or not, the return value will be the return value will be true or false. So print will be true or false. And then print the and just access the value with the key 23. So let's see what happens. So l added index one is three tier index one is three s, three years in S Yes. And what is the value with the key 23? The value is the value is two three. Let me just describe more about this D. What is the value at index B for example, now we have to give the index B in the string format. That's 43. Yeah, so that's how we can access that. Let's sprint s also let's see s because when we have defined as we have defined this duplicate three But if you see the elements of s, there are no duplicates. And it does not maintain even any ordering, I mean, we have defined s in a different way, it is maintaining everything maybe in a different way, one three. Yeah, oh, the ordering this way is the same, but there is no index for the first or second or third element and so on. Okay, so that's about the defining, declaring or accessing different elements. In the next video, we will see more about about the data structures actually, actually want to spend some time on the data structures because that will be a basic building block for for the data science packages, too. If we if we know very well about these data structures, these data structures, we will be very fluent in the data science packages and working with those. Okay, hope to see you in the next video. Okay, in the last video, we define less topple set and dictionary and we actually access different values. In this video, I'm going to actually, I'm going to actually introduce more indexing, how to access list and topple in particular, because the both are very, very easily indexable like strings. And I want to show you that all kinds of indexing that you have seen in strings, exactly works and list as well as in tupple. So let's go to Jupiter, and see what a list is, for example, a list, if you print the list, that's the list, it has these kinds of values, if you just see the list, for example, starting from index one, ending at index three, that that means the same big a slice for example. So index one value is three, index to value is 4.9. And the last element is not included. So, if you get that you get three and 4.9. So exactly the same, the same kind of indexing that you have seen in strings, exactly there is working here as well. So for example, if I say list, start from the beginning go to N but then I just give minus one it will reverse the whole list, I mean the whole list will be reversed. I'm in all the same all the things that that we saw in in string indexing stays exactly the same in list as well as in topple, so topple For example, let's access element from let's say from the very beginning till the till the third element, that's not the third element till index three, which is actually the fourth element. So topple unless they are exactly they will be exactly index as as it as it is. So all the slicing all the indexing all the sub sub listings, all all the sub topples, they can be accessed exactly the same way as you as you've gone through through the through the strings. One difference here that I will explain later on, because list is mutable it is changeable, I will discuss one thing that one use when you slice it, when you get a sub list then actually it refers to the same memory and if you change the sub list contents, the actual list chord changes. That is that is true for list in slicing. And that is true for sets and dictionaries, in the copying the references and so on. So I will discuss that later on. But rest of the things are roughly the same as as they're in string indexing. Actually, indexing is almost the same everywhere in Python, it has this kind of slicing is almost the same if you know the index, how to index planes, you know how to index lists, if you know how to index lists, you know how to index couples and strings and, and everything. And by the way, if you know how to index strength lists, you will be very fluent and NumPy. That's the very powerful data structure. That's very powerful kind of array processing package. with with with some defenses that we will see but even the indexing is same in pandas when you are working with large amount of data data file and stuff like so the indexing is more or less the same that you've seen in instruments we will we will cover indexing, masking and fancy kind of indexing in much more detail in NumPy. But this stays the same as, as you've seen in in, in strengths Okay, so now can we can we expand the list can we add more elements? Can we insert more elements to the list? The answer is yes. Because list is changeable. New trouble you can insert more elements. One way of inserting there is just to call an add operator, you can just add plus and you just insert in other lists like like two strings are concatenated by plus two lists can be concatenated, or combined together again by plus, but there is a faster function called append l dot append. That is sometimes faster than using this operator we will see that topple because it is immutable. You cannot touch any content of the double you cannot actually insert any element to a topple you cannot delete any element to a tupple. There are workarounds for example, convert a tupple to a last change it then convert the list to a tupple. There are ways to do that. But tupple in its true sense, in the literal sense, it is immutable. You cannot insert any elements you cannot delete any element you cannot change any element. However, you can combine two tuples. Together, you can concatenate two tuples together again by plus operator and save the result into a new double that's possible set. The you can insert elements using an add function add function allows you to just insert one element. If you want to insert more than one elements, then you can call an update function that actually accepts more than one that accepts another set that need to be inserted. That's possible dictionary, you can insert a new key by just the new key equals to that you just assign a new value to a new key and key value pair is just inserted there great, you can delete or remove any element from the list using D l Command D l l one that means the this particular element is deleted from the list that is possible. Deleting particular element from the tupple is not possible However, you can delete the whole variable whole topple that is possible, you can remove elements from the set using remove function as dot remove, and then you just give the element that you want to remove that as possible, it will be removed and you can delete the whole delete the whole variable that is always available. Similarly, you can delete a particular item from the dictionary by just deleting by just calling the D of the value for example, whatever the key is, so you call with the key and call the Delete and it will delete everything I want to mention here for to remove items from the list there are other methods and functions that are also available that I mean there is a remove function, there is a pop function, these are available. Similarly, from removing elements from the dictionary, there are other functions that are available. But just to compare them together, I am using this de l command, although there are other ways of doing the same stuff, as well. So let's let's let's let's end this video here. And in the next video, I will show you all these operations that concatenating together, inserting more elements, deleting different elements, I will show you all these things in in Python. So So hope to see you in the next video. Okay, in the last video, we saw how to insert different elements to different data structures. And we for example, in the case of tuples, it is not possible. And we also saw how to how to actually delete different elements wherever possible. So let's go to our friend Jupyter Notebook and see all these concepts in a running form. So let's go. Okay, so let's say for example, we have list, that's our list. Let's append an element to the list or maybe more elements, that is L plus. Let's say we can have another list for example, how are that's six, and then you that's and these two lists will be appended and the new list will be as you can see this similarly we can append an item using append function for example 6.8 that will also be appended and this will contain these kind of values. So yeah, so both arrays are fine. This plus is this plus can be used to append to append to lists and this append function can be used to simply append a list with a with an element. Okay, great topples. You cannot change the topple, you cannot change the topple. But what you can do is you can have two tuples for example, T two is a different couple. Let's say a A and B, and let's say you have four or five, that's it that's supposed to, then you can have a third double, that is just the combination of double one and double two. And in this case, you have double three, which is this. Yeah, so double one and double two are combined together, but you cannot actually insert into the assembly, the tuple is immutable, you cannot insert another element, you cannot delete existing elements, you cannot update any element and so on. Similarly, as the set, let's see the state of the set, that's the set set God add function, you can add anything, let's if the six that is added there, and the new state of assets this, or you can call the update function. If you update method, if you want to insert more elements, for example, if you have multiple elements to be inserted 23. Again, and let's say you wanted to insert an element that is already there. So for example, one, then the duplicates will no longer be there, but the new elements will be inserted. Now let's see the state of D, the state of D is this. If you want to add another key value pair, you can add a key here, for example, the key might be new key, for example, new key and the value might be the value might be, for example, a new value. Well, and now if you see D, the D, the contents of the D has changed. Well, that's simple. Yeah, great. Can you concatenate two dictionaries together using a plus operator? Is it possible? Is it possible to concatenate two dictionaries together? Let's see I have another I have another dictionaries dictionary D two. That is that say the key is why. and the value is why why? And then we have another key letter Z. and the value is. Let's sit down, can I can get an A D and D two together? Can I? Can I just update my D and add these values? insert these values also there? Okay. I left you with this question. You try to answer this. And in the next video will answer this question. But try to answer this question yourself. And one way to try that is just to go in Jupiter and just dive and check whether plus is working or not. Or maybe there is another method and stuff like so. Okay, great. Hope to see you. Oh, I have not used the D l delete and all that stuff, and so on. So this question is there, let me use the removing the elements. So let's say l is this list. If I want to remove an element, let's say element number three, if I want to remove element at index three, which is this string name, I can use simply this delete. And the L is everything but without that element. Similarly, I can remove if I want to remove any element from S, I can call the function remove. And whatever I want to remove, let's say want to remove game, and the game will no longer be there. Great. If I want to remove some element from dictionary, again, let's say that's the that's the view of dictionary. I can call the Add I can I can remove the element with key let's say C, whatever the element is with key C, delete that element, and the dictionary has this particular state with this item, this particular item is gone. Okay, great. I can do that. But But d L is not the only way of doing that. There are so many methods. I mean, a lot of methods to do that. But just to just to compare all these, I'm just giving you the most similarities and differences wherever available. Okay, great. So I have asked you a question in this particular video. Can we concatenate two dictionaries together, particularly with a plus operator? If yes, then we are done. If not, then Are there other ways and stuff like so that's the question. So hope to see you in the next video with more on these data structures. Okay, I asked you a question last time. Can we concatenate this two dictionaries together with a plus operator? So what's your answer? Yes or no? The answer is Nope, yeah, so we cannot concatenate them together, we cannot insert another dictionary to this dictionary using a plus operator. Because this plus operator is not defined for dictionary, what we can do is we can call an update function, because dictionary is also a set, I mean, a set of key value pairs. But at the end of the day, it's a set with specialized function, of course, but we can call update functions, and insert the whole new dictionary inside dictionary as as as follows. Yeah, so the answer is using plus operator No, but there is a way using update method. Right. So next, we focus on the copy function, the copy function is available for less the copy function is available for set, the copy function is available for dictionary. So let's see the need of this copy function here, I want you to be very careful. Because that's, that's really important. Let's say we have a list, let's say, That's list. And by the way, the same goes with set and dictionary as well, whatever I'm going to do with list, let's see a list. Now, what you do is you copy the list or you just make another variable, like you can assign the value of l to another variable l two, what you do is that now l two is also has this, now these are two different variables, L is this variable, l two is this variable. So you might be thinking l two is separately a completely a new thing. And Alice new thing, you might be thinking that both are independent. But Python internally manages the data structures, most of the data structures in a way that because the data structure is a collection of a lot of data it has it is consuming a lot of memory, what it does is when you assign a variable, or data structure to to another variable, it does not actually copy all the contents, it does not actually make a new memory, and store the contents in this. It actually this variable also actually points to the same memory as this. and and, and and the consequence of that if you change any value, for example, in L two, let's say you change the index to value from this, the index to values 4.9. Now you're working in L two, let's say you change this L to value from 4.9. To Let's 4.9. Let's see you do that. So you might be thinking that this happens in L two, well, in L two, that has happened. But what it also does is it does the same thing in L as well. So l also changes. The reason is L and L two, they both are pointing to this structure in the memory. And whether you approach that structure through L, or you approach that structure two l two, you're approaching the same memory anyway. And that is called referencing I mean, it does not create the data, it actually create a reference in the memory to actually create a new name for the same memory. And both are pointing to or accessing to the same memory. And if you really want the behavior so that l two becomes different than L and what I what I do with L two, that should not affect L, then you should call copy function. l two is L dot copy. Yeah. So that's the function, I'll copy. Now you have l two. Now you do whatever with L two, it will not affect L. So l two, for example, index at index two, you again say okay, this is 4.9. So l two changes. Now, l two changes, but l doesn't change, l doesn't change, l stays the same. Now this is different copy, same concept, go with the set. And same concept go with with the dictionary. If you if you just make another way will s two n equals two s, then if you change the contents of s two s will change. If you don't want that, then copy it similarly copy the dictionary, because the contents of the topple they are not changeable. The copy function is not available for double. Because even if you assign this T to T two, you can now not change D two because it is immutable. So having a copy function doesn't make sense in tupple. Wait. One more thing regarding slicing. Let's say you have let's say you have Dell that's available to you like so that's L and let's say you make l three another list by slicing Let's say a list from let's say one to five, let's say. So you start from index one, which is three, and you go to five by not including five, this way, the L three is automatically a copy, it is not a sub list, which is referencing. So l three. So l three is a different l two is a completely new list, a new memory view, if you change the contents in L, three, if you change the contents in L three, for example, l three, or index zero, it should go from three to let's say, three, if you change the contents in L three, these contents, these change will not reflect an L. So if you do the slicing, slicing picks a copy by default, it does not pick a reference. And that's a huge difference between this list and a NumPy array, when you end it, we'll see that when we will see a NumPy array, the slicing actually also, again refers to the same memory location. And that might be one difference in indexing, indexing in the whole Python, whenever you do slicing, you get a copy. But in NumPy, when we'll see NumPy in detail, in NumPy, when you do slicing, you get again a view not a copy, and if you change in the slice torian anything the actual the actual contents also changed. And there is a reason to do that there is a there are efficient reasons to do that and stuff like so, again, the dot copy function becomes the copy function become much more applicable there as well. So, so, so you need to know that even if you do if you do slicing in general in Python in any collection in any array, in any, if you do select a collection for even for mutable objects like list, you get a copy, but in NumPy array, the things the things these things, this particular thing with with a lot of other things this but this indexing scheme actually changing, changes with with this kind of slicing. Okay, so I am this video here, I mean, you can explore much more functions of lists tupple, seven dictionary and what you can do with each of them, and what you I mean, in which scenario, what kind of thing is more suitable for the other that completely depends upon the problem at hand. But what we can do in what what we will do what we'll be doing in the less next video, we will be seeing some using some functions of just list. And then I will be just just letting you to explore the the tupple set and dictionary and all their functions on your own. And to see what function or what method is doing what for what, which kind of data structure. So in the next video, we will be seeing some methods just for list data structure. Hope to see you in the next video. Like in screens. Let's Let's explore a lot of functions in list. Although in, in in sets and dictionaries and tuples tuples, as well. But many more functions are available in list. And by the way, let's see how many things are there in this list. And let's say l dot tab, and tab will open up a lot of things with me for me abanda we know already clear copy, copy, we know already count, we don't know count, extend, index insert, pop remove reverse some of these functions. They make sense by the adjuster name. But let's see one by one. Let's see some of those. What they do. One way to do that is go to internet and see some book or tutorial or something like So another way is just write this apply. Maybe, maybe help function maybe apply a help function, it may help you how to use that. Great this help function is great. So abandoned object method of building list in stance about an object to end of the list. Oh, it appends an object to the end of the list. Which means we may be able to append another list to to a list maybe. Have you thought about that. The append method just takes 111 object. Maybe it takes a whole lot of list. But then it may be possible that a list is appended inside another list and that whole list becomes becomes one element because list can contain other lists as elements are that's a problem. Yeah. So let's see more functions. Yeah, so let's see clear what this clear What is this clear what it does? Sometimes I use help, sometimes it's used that remove all items from the list, oh my god, if you call the clear that the list is empty, okay? If you just call clear function on a list will become empty. Be careful. Okay, great. What else? So that see I have this function maybe, Bob, what does Bob does watch. So let's see. So Bob removes and returns item at index defaulted the last, which means if you also that's the default value remember the default value. So, if you call a part function without an index, it will return it will remove the index it will delete the last item and it will give you that it will return that are if you give an index, it will remove that value at that index. And it will after removing it will return you that. So you can use it wherever you want. So there are many more functions for example, you can see all of them one by one remove function, for example, reverse reverse, like, like, like the name suggests, if you call the reverse function, the list will be reversed. Yeah, and remember, we have reversed the list in the following way as well, we have a way of reversing any way, this way. So now if you see the list is again reversed. So I guess both of them are working like so same. Similarly, you can explore several functions from a set, you go and say add Clear. Clear might be working as same as intersection intersection and update is destroyed is a subset of the other. Yeah, add by default or update by default, actually take a union. So I'm not seeing update function. Here it is update. Oh, union is there update is there, which means the list you're seeing is here is not a complete list you may be writing, what are the functions that start from you. So here are the and and several others. Similarly, you can go to dictionary and call for several functions clear copy from keys get items. That item might be might be interesting. What is this item? what it does? Oh, it has an error? What? So how can you use this? How can you use this function? Let's see, oh, this is just an object, it is not a function? I don't know. Let's see again, are it is not listed anywhere? Oh, it is items not item. Okay, items. That's a function maybe. So these are all the items 23 with this, be with that new key with that, and so on. Great. So actually, the purpose here is not to tell you each and every function, what it does, it will take a whole lot of time. You can go and explore all these functions. The purpose here is to tell you what kind of data structure has, what kind of properties and what are the similarities and differences in between. So if you remember this one slide, for list, double seven dictionary and some text that is written out above, you'll be having very good knowledge of where to pick what kind of data structure in practice. So in the next video, I'll be actually going to Jupyter Notebook as our as our style and I will be coding or solving some problem for you that will involve list topple set or dictionary are one of them or we will be choosing based on problem what kind of data structure is well and what so we'll be doing that. But before that, I just want to I just want to I just want to mention that list tupple set or dictionary they can contain any items inside any kind of type, which means a list can contain another list. A list can contain a set a list can contain a dictionary, a list of dictionary can contain a list which itself contains a dictionary, I mean, this is all abstract, this is all abstract, one thing can contain the other one thing can contain an instance of I mean, a list can contain multiple lists. And those lists can contain more or less and so on. So before actually going to problem solving, let me give you a flavor of that how abstract these things are. Let me give you a flavor of that in in just just in a couple of examples. So in the next video I'll be giving you a couple of examples based on the abstract mess of these data structures. And from the next next video, we'll be probably, we will be doing some problem solving based on that. So next two videos are completely on Jupyter notebooks. So get ready, I hope to see you in the next video. Okay, let's see the abstractness of all these data structures. Let's see just one example. Let's say we have l as the list, we have all rich top all that stuff. So let's say we have set that set, let's say n, we have dictionary, that's a dictionary. Okay? So let's say we have all these things that say available somewhere. So let's make another dictionary. For example, let's say D, D, Ma, that's a D tool. And that dictionary has key value pairs less The key is a and the value is whole list l master value is possible. Let's say the key is B. and the value is just to topple the whole topple, that's the value. Let's say the key is C, and the value is the set. And let's say the key is D, and the value is the dictionary, the whole dictionary D it is possible. I mean, you can just do that, that that is just one example, oh, what's Oh sorry, I should have I should have incorporated this way. Okay, so this is possible. Now, for example, if I access, if I access the element with, let's say, a, I will, I will get the whole list. And not only that, I can again access the whole element. And then after that, for that element, I can access for example, the third element, the element at index three. So this particular, this particular first level will extract the list. And that will in that is just the indexing or for that list. See, for example, if I access D two, and inside the tool, if I access the dictionary that is inside, and let's say I save that dictionary in k, then it I can see the contents of K but I can just for example, this or I can just access all elements of this dictionary, or k by just having 4x in gay brand, for example, x and k of x, just do that i can i can just do that we have done that in loops as well. So I want to tell you that the these even if for example, if you want to create a list l let's say l three let's say you want to create a list that can contain a whole list that can contain what will get Oh, I mean one element is the list another element is to pull another element is the whole dictionary inside and then you have some other elements let's Lee's game and that's perfectly fine i get i mean you can do that, these data structures are much more abstract I mean now if you for example, access element at index two which is dictionary, that is completely a dictionary if you if you check the type of that element that that will be a dictionary object and you can extract that element and play the way you want to play and whatever. One more thing if you can, for example lists we can let's say we want to make a list list very quickly for example list off all the squares till till starting from zero list of all the squares till till 10 for example zero square one square to square let's say we want a list of that. So one way of doing that is a quick shortcut is to just use the loops so in loops, for example, we right okay, x square for x in range. Then for example, so it will start from zero go till nine, including nine and you will get x one by one. And all this index is for making a list of x squares where x starts from zero and go to go to including nine go to nine one by one and that's how you can make a list and I'm in these kind of these are kind of shortcuts. Again, you can make a sale For example, let's say you want to make a set of all the squares for x in range, let's say, starting from starting from two, ending at 20. And you want to take a step of, let's say three. So, start from index two go till 20 do not include 20, but take the step of three, and you can now have a set, which is which is this. I mean, there are, there are a lot of ways of working these working with these. One, one can explore more and more about these things, but what what what the basic thing about these data structures are, they are very, very abstract, they can I mean, a list can contain a dictionary, and that dictionary can contain a topple and that will have an element which is another list and so on. It is that abstract, it allows you to do each and everything in that way. Okay, so I end this video here in the next video, we will actually solve a problem using these one of these data structures or we will try to choose one of those. And that video naby lengthy may be small, because we may have bugs inside. And we will we will play around with these data structures in the next video. So do attend the next video because it's really the practice and you will get your hands you will get a very good grip on the data structures in the solving the next problem that we are that we are launching for you, okay, hope to see you in the next video. Okay, let's see a problem just to get comfortable with these data structures. So let's let's design some problem and solve that problem here using using these data structures. So the problem that I'm thinking is, let's say the following. Let's say let's say you are you a teacher, should I type all these things? Okay? Let's say you're a teacher, you are a teacher. And you have different student records to learn records containing containing ID of a student and the mark marks list in each subject, where different students have taken different number of subjects. And all these records all these records are in hardcopy. You want odd copy, you want to enter all the data in computer and want to compute the average marks of each student. And display. That's the problem. So the problem let's say is, you have for example, you have a hardcopy you have you have some papers, upon which you have different students, each student have a different ID. Some students may have taken seven subjects, some student may have taken three subjects, some student may have taken eight subjects and so on different students may have taken different subjects. Regardless there, you want to first enter each for each student, you want to first enter the records, I mean all the data that is in and then you want to compute from that data, you want to compute the average marks of each student. For example, if a student have taken five subjects, then the marks for all the five subjects are available, you just add all the marks and divide by five and that's, let's say, the average marks. So first of all, let's ride away two way to compute for example, the to just collect the data, how to collect the data. So let's write a function for that. So let's say define a function, let's say get data From user or teacher, let's say, let's say that function, and it returns data. Okay? So what I do really is I say, okay, while true, I made a loop while true, just take the data from the from the user, and the data is in the form of you first say, okay, ID, student ID, let's say that is inter, or actually input, enter student ID. So he enters the the person enters the student ID. Yeah. So adopt, you might have define a dictionary, maybe a dictionary D, that is empty right now. But you may, you may add and remove different values. So what you do is, you add a student ID, you get a student ID, and in the string form, and then you get the you get, for example, the input as the marks list. So marks list as input. Enter the marks, by comma separated values. So enter the marks using for example, if you have five subjects, just write the five subject marks by separating each with the comma, okay, then this, let's see more students is equal to let's say input, enter, yes, or no. for adding more students, so if for example, you have more data to insert, then press Yes, otherwise personnel. So that's, for example, our setup. So we will keep on getting more and more, we will keep on getting more and more data from the user user will keep on increasing the data. But one thing that we must know is that if for example, a student ID, student ID is already in D, if that is already in D, then we should give a message brand. brand that student ID is already inserted. So that might be a message else. ls we want to do something else, what we want to do is the following. What we want to do else is we will make a dictionary, we already have a dictionary with a student ID as our key, that's our key. And at that key, what we do is be the pick the marks list, and just split it using comma because you're expecting and all the marks they will be saved as a list. So that will return a list. List of string values. These are not indeed values, these are string values. But all these lists they are tagged by this ID. So that is a dictionary that will be that we'll be getting populated on and on and on. Further if we check F for example, more students dot lower, for example, let's call the lower function because the user may interest at a lower form or if that is equal to let's say no, that is equal to No, if this is the case, or if there is no enter for example. No inter no inter Know, to quit when insertion, insertion into node with insertion. So let's say that's your message. So wherever the user inserted, if that's a no, then you return the and that's it. Otherwise, you keep on moving. So that's the whole goal. So you keep on asking the, the, you keep on asking more and more values. If whenever the teacher enters a no, then you just return. Otherwise, you keep an up, you make another equation, you make another equation and keep on moving. That's how you get the data. So the data will be available to you. Once you are done with that, then after that, we will see how to once we have this data collected from the user, then we will see how to compute marks for each student individually average marks and so on. So let's just check whether this function works or not. So let's say we have our dictionary that says student student data is equal to get data from user, let's just call that function. Let's see what happens. Okay. Enter student ID, let's say ID is 12. Okay, in remarks by comma separated values, let's say, well, one, let's say 24, comma 65, comma 87, let's say the first two in just the first tool and just have these three subjects, then internode width, so I will enter something else. And oh, what's the problem? There is a problem. If more students taught lower is more student is not defined. More student that's, I guess, more students, more student here, oh, the spelling mistakes. That's a huge mistake. So I just copy there, these bugs are there. That's part of life. Part of programming life, actually. So I guess now it will work. So let's do the process again. So 12, let's say, and the marks are the six comma 45, comma, let's say a bad subject with let's say, 13. into no to quit. No, I will intro something else, I will keep on moving. The other student is the student ID is 45, let's say. And the marks that this student has gained, actually, let's say this student has, has registered has already registered seven subject or let's say five subjects. And the marks are, let's say 44 to five, six to 677. And let's see a bad subject, let's say four. Okay, then internodal, quit. No, I want to insert one more, so do anything else other than No. So student ID, let's say now the student ID is 12. Again, let's say, let's say want to insert another ID again. And whatever the marks, let's say 45, and 45. Again, that's a now internode width, no something else. But now, the message is there, the 12 is already inserted, because the ID the key value index, now you cannot repeat, and so is the student value. So it does not inserted the because this may be my mistake, so it asks again. So now let's say I enter ID, let's say 23. That's the ID or maybe a different ID. That's the ID and the marks are let's say 45, comma, 45. That's it. And internodal grid. So let's say I enter No. And that's it. So now I have received the student data, if I show you the student data, that student data is student data. That's a dictionary, that's a dictionary with the with key 12. And that's a list. But this list contains all the values that are our string type, we will see how to handle that. That's a 45 as a key value, that's ID and that's the marks list. And that's the ID in that small list. Okay, great. Now we have student data. Let's write another function that helps us working on the student data, basically, we want to find out the average marks of each student. And then we want to print those. So let's define another function and get average marks of each student. And that function actually receives this dictionary, let me call it as D, any any variable, that's a local variable. Okay, so what we want to do with that is the following. Average marks for each student's, so we will define another dictionary, let's see everage marks dictionary, let's say that is empty in the beginning, maybe, and then what we do for x in D, let's icreate over x and d, what we really do is we go to the we find out the list of located at ELLs are located at x L is basically D sub x. So that's it, that's our list. That's our list that is located there. So then what we do for i in L. So for all i that is an L or let me call it for marks, marks in L. In this particular list, what you do is you actually have this sum of sum is equal to zero right now, there is no marks. So what you do is s plus equals two marks, but convert the marks to integer because they are already in string format. We have we have saved everything instinct string format, so you populate all the list. Once you are done with this loop, the S will contain the sum of all the marks, then what you do is you compute the average and just save that average in ABG. Marks decked dictionary, let's say on average marks, just just don't use the word deck, for example, you can but let's stay gradual and add x, you just write the average marks. And the average marks can can be computed by s divided by length of the list, whatever the list is. So that's what the list is. Yeah, so that's the average marks. And once you have an N one by one, all the average marks will be populated. And once we receive all these, we will then begin then we can then just display by populating the average marks. So let's see, let's call that function. So let's call that function. So ABG marks for example, equals to get a VG marks, and let's bond these student data inside. And if there is no error, then it will return everything. Then just print the average marks for each student for x in a Vgm. brand, let's say student and Brand X God average marks as then you just Brandt okay ABG m of x, x, and that will display everything Oh, if there is an error, non type object is not equipped. I prefer nine type object why non time object? We have done some mistake. Yes. Maybe. Let's see. Let's see, for example, when we run this, so let's run this and create a cell Let's run using alt Enter to create a cell everage m What is that thing? Oh, that's nothing. Why oh, we haven't returned anything. That's a bad programming. Really bad programming. We have not returned actually. The the value that we need. So the default value is none. raid actually not so great. Okay, great. You have this and now we have something in Emirates marks. Yes, this is and now we can just populate that and we have this student 12 got average marks 38 student 45 core average marks 90 49.2 and student 20 He got average marks as 45.0 Okay, great. So that was just a review of split function of string, type and marine through int, and functions in general input function, and, and dictionary and list and all that stuff. So although it was a just a tiny problem, but it gives a good flavor of the data structures and strings and all that stuff. Okay, that's about the data structures. From the next video, we are actually diving into the data science packages. And we will start from NumPy and we will spend some time on NumPy and then we will be moving towards pandas, which is very, very powerful built on top of NumPy and after that, we'll be moving towards matplotlib and we will also try to give you some snapshots of psychic learn as well. So hope to see you in the next video. Okay, the next few videos will I will discuss NumPy which is the which is the very very popular package for numerical Python. Actually NumPy is like list but it is much much faster than list. One one restriction if we restrict the list of Remember, a list actually is a collection of a lot of data objects. That was so abstract, as we saw in previous videos, if for example, we restrict a list that all the objects they must have same type all elements in the list for example, they have same type then that list with all the same type, there is what the NumPy looks like, but NumPy is very, very more faster. And the reason is, even if you define a list with all the elements that are let's say of same type Yeah, but because list in abstract way can handle heterogeneous kind of objects, the functions that we will apply on these items, they will no longer be faster further to store each element we have to store that information or metadata for that element in NumPy, it is both I mean, it is efficient with respect to memory, because if the type is saying we need not to save information about each element, because we need just to save the information about the type because the type is same for all elements further when the type is same, we can write functions that are much more faster than then then a list. So NumPy is very, very popular, it has very very fast universal functions available the methods that are available in NumPy. And it's a package i mean it's it's a whole directory structure containing a lot of packages inside a lot of modules and so much at the end of the day, it's it's it's simply or in laymen terms, it is like a list with all the same type objects and it is much more useful when all these objects are numeric type, although you can have a NumPy array with with spring data types, I mean all the strings are all general objects as well, but the the most the power mill the power of NumPy array will be will become much more evident when we will be working on numeric type data. So in this particular in this particular course we will focus more on numeric data then other kind of data. So that's how you you write import NumPy is installed or if you if you have installed Python using Anaconda NumPy is already installed there it is in the side packages kind of a built in package. So import NumPy we can stay as it is but we can rename this NumPy just NP that's most popular name, we can write any other name but if you see the books or internet or somewhere this NP somehow becomes much more popular. Okay. Now we can define an array for example NP dot array that array is just a method of NP kind of function. And we can define an array using list this is the list of several numbers or we can define array as as a topple as well. So whether we give a topple whether we give a list an array is defined and then we can see the contents of this array, this NP array so let let's just go to our friend Jupyter Notebook and get our hand Well dripped on, on this NumPy. So first of all, we need to import NumPy package. And we may rename as for future use as NP. So let's say that is imported. So now let's say a is an array, let's say NP dot array, that's a function and we may have a list and say, let's say 12357. Let's say that that's right, we can also define the array using a topple rather than a list, it's our choice. Which way we define the array either way. 235 Let's, that's, that's another array for example. So if we print for example, a it will give us a but if we just see the type of a it will no longer be list it will be an ND array numpy.md array that n dimensional array, okay, great. So, there are so many attributes of this a and this B. Same. Similarly, if you see the type of B although we have defined this be using the tupple. But the type is the same the it's a NumPy object rather than a list or a topple. So that's how you can create the the array 1111 more thing that is that is important is to check the attributes of a for example, k dot d type, that will tell us the data type in a so for example, a stores all the data that is integer 32. At defined time, for example, we can we can specify the data type if we want we can specify the type if we want. For example, in teacher that means as in teacher here, we can here we can define, for example, the type as float, for example, so data type becomes float. There are several other other options that are available to define the data type but, but even if we don't define the data type can be defined automatically based on contents. That's what the dynamic typing means. So if we now define type that is, if we, if we now check the type of a that is, again in digit 32, but if you check the type of be the type that that might be a float number, yes, that's float 32. Again, there are 64 bit support as well, I mean, we can define here there are several options here available. So that's the that's how we can define the NumPy array that's just getting started with NumPy array. In the next video, we will play with these arrays a bit more. So hope to see you in the next video. Okay, in the last video, I introduced NumPy. And we actually declared a NumPy array using a list as well as a topple. In this particular video, we will be seeing some of the properties of the NumPy array variable or sometimes called the object that variable there are several properties, but I will discuss for example, last time I discussed one property which is d type a dot d type, and that store actually the that actually stores the information of the data type of the elements of the array of NP array, remember NP array, all elements of NP array they must have same data type it cannot store heterogeneous arrays as it is. Okay. Now, there is another property sometimes called the dimensions are n them. That tells actually, what are the dimensions of of the array, I need to explain this term dimensions with the following example. Let's say for example, that's, that's that's an array just consider that a list for example, 123, that's one list. And if it is if it is an array, for example, if np.if this is NP dot array. With that list, we will say that array as a one dimensional array, because we only need one index to access that. For example, if you need to access any element in this array, you only need one index either 01 or two, only one index, that's okay. So in this case, we have just one dimensional array. On the other hand, for example, if you see here, that's one array or one list, that's another array, another list. And that's another list that contains lists inside for example. Let's say that array one, and that's array two. And that is simply an array of two different arrays. That's, that's an array and that's an array. For example, a One is this array and a two is this array. Now if we need to access any element in this particular array, we need two indices. First of all, we have to locate whether we are going to talk about a one or a two, we need one index for that, for example, if we want to locate a one, that means we are going to access with elements zero, let's say this, this whole array is a So first of all, we say okay, zero means we are going to access from from a one and a to one of those. So zero means the first one, okay, now a one. Now inside a one which element, this is the zeroeth element, this is the first element, this is a second element, let's say we want to access the first element. So that means we are going to talk about we are talking about this. So very loosely speaking, the total number of indices that are required to access an element inside the array is called dimension of the array. And m them that actually, that actually defines that that actually describes the this property, the total number of dimensions. Consider, for example, this is a 2d array or two dimensional array, let's head out to two dimensional array A one, and let that's another two dimensional array a two, that's another two dimensional array, a three, for example, and let's say this is an array of two dimensional arrays, let's say NP dot array. Now, that's that whole array, whatever that array is a three dimensional array. And the reason is to access any element, we need three indices. First index will define which one of these we are selecting, for example, let's say you're selecting that. So one index is needed that index is one for example, then inside this structure like so, we need two more indices to locate a particular particular index. For example, because it is a two dimensional array, it has two one dimensional array, so which one dimensional array you are, it has more, it has many one dimensional arrays, so which one dimensional array you want to pick, let's say the sixth one will index with index five, now you have located the fifth or sixth array. Now in that array, what element let's say the eighth element. So we need three indices to access a particular element. So the dimensions of this array is three. So let's play with that in Jupyter, notebook just to get more comfortable with with the term dimensions. So let's say for example, we have an array, let's say a is NP dot array. And let's say it contains a list, let's say 123. And then we have another array, one dimensional array, let's say four, five, and six, that's another array. And that is an array of these two arrays. So that is basically a two dimensional array. It is array of arrays. list of lists, equal entries. So that's a for example, oh, what's the problem? Oh, we haven't imported NumPy, we should have. So import, import NumPy as NP? Okay, we need not to import that every time. Actually, I'm recording this video after a few after a few hours. And I'm really I have restarted all these things. So I have to import now for the first time. But once imported in the notebook, as long as a notebook is running, you need not re import anything. Okay, so a DOD for example, and then Iraq and them. So that is to hear because there are two dimensions. For example, if I want to access element number three, this element, so this element is located in the first array of the two arrays, which has so the first array, there are two arrays with index zero or one. So I am going to look into the first array, which is 123. And in that array, I'm going to look for the element number two element with index two. So that's how you can access the elements of multi dimensional arrays are arrays with more, more kind of dimensions. Let's say we have another array just to just to get more familiar with NP array, let's say, and we have a list. And that list actually contains that list actually contains three one dimensional arrays. Not only that, actually Oh, I'm confusing you a lot. Let me know Let me just, let's say we have 123. Let's say we have three one dimensional arrays. Let's say we have another 2459. The the sizes of arrays, maybe, maybe, maybe, I mean, maybe different. Yeah. Is that true? maybe different? Yes or no? Let's see, for example, the first array has size three, and the second array has total size. Does that okay? I guess, yes. And now if we want to access, for example, an element of an element with a, let's say, I want to access this element five, so that is in the secondary index with one, and then in that array, it has index two. So I've accessed this element, oh, we're not too many indices for an array. Why? Why is that? Why too many indices, for for an array, B selects a B dot n dems. And then that is one y one dimensional, I have to, I have this one dimensional array. And this is another one dimensional array. And I have made a list out of it. I'm in this is 1d array and another 1d array of concatenate them together, so I shouldn't have accessed this element. The problem is when you are going to define multi dimensional arrays, the the number of elements for each dimension, they should stay consistent. For example, if the first array has three elements, the second array must have three elements, or if the secondary has four elements, and the first must have four elements. If that is not the case, the array will not be defined like a multi dimensional array. For example, if we, for example, extend our first array with let's say, minus one. Now, B will be having two dimensions, no problem. And now we will be able to access for example, this element five, like so. So we will go to B again, we will see okay, select array number two, and in that array, select index, select the value indexed by two, which is five. So accessed no problem. And that stays true if you if you're going to define for example, a three dimensional array, let me just give you an example of three dimensional array that's a C equals NP dot array. And let's say we have one, two and three. And then we have another array, for example. 456, remember or so let's say that, that we can have one more for example, we can have one more list, why not? So let's say we have a 00 minus one, let's say, and that is what that is. That is a two dimensional array. That's a two dimensional array. Great. Let's say we have another two dimensional array. Let's say we have another two dimensional array with same kind of consistency, the number of elements and stuff. Let's say these elements are our minus of the, the other ones, let's say there's minus, minus, minus and this is plus one. And now we have this, if you see this thing, that's a 2d array. That's a two dimensional array, that is also a two dimensional array. An array of two dimensional arrays is basically a three dimensional array. Now, that's a three dimensional array. This one, C, so if you Oh, we have some, Oh, I should have defined this with commas. Rather than rather than spaces. Actually. Yeah. The reason I did that is MATLAB. I worked in MATLAB also. So MATLAB allows this space separated list, but I just confuse the things with with Python as well. But Python requires comma, they're okay. With MATLAB. By the way, just as a side note, MATLAB allows you to have commas as well as spaces, but this Python is just restricts everything to comma. That's great. Okay, that is C. So now, if you check c dot n them that is three, if you for example, want to access this particular element, what should you do? First of all, you select the, the one of the 2d arrays, there are two 2d arrays. So this is the first 2d array and that's the second 2d array. And if you For example, want to access this particular element, this particular element, which is minus three, if you want to access that, you first have to access one of the two 2d, two dimensional arrays. So let's access the second one with the index one. Now you are in this particular 2d array in that array with list which 1d array you're talking about. So I'm talking about the very first 1d array, so the very first 1d array is indexed by zero, and in that one D array, which element you are talking about. So I'm talking about this element that has index two in this particular array. So now, if you press enter, you will get minus three Wow. So that is basically how and by the way, you can make a four dimensional array, a four dimensional array will be an array of three dimensional arrays, and so on, you can make, you can make, for example, n dimensional arrays, and that's one reason why we call this as nd array, n dimensional array, not the type of C's nd array n dimensional array, you can add as many dimensions as you want. Great, we will continue exploring this NumPy more and more in in the upcoming videos in particular, I will talk about this shape property of this NumPy we have already discussed D type we have discussed and then in the next video, we will talk about shape and we will discuss more about about NumPy. So hope to see you in the next video. Okay, in the last video, we discussed this number of dimensions or ending property of any any NumPy array. And we also saw an example of defining a three dimensional array in Jupyter. notebook. Let let's discuss another property which is which is the shape property. Let's see what what this shape actually represents. So let's go to Jupyter Notebook and see what actually this shape represents. For example, you have seen this C as in the last video, we define the C as a three dimensional array that contains two arrays of 2d. And each 2d array contains three 1d arrays, and each 1d array contains three elements. So what do we mean by shape? So if we just say shape? What is that thing? So shape is 233. And let me tell you what that means. The return is tuple. So that's a tuple. That is returned to three and three. This two means how many two dimensional arrays are there? Here we have two. So in each two dimensional array, how many 1d arrays are there? Well, three in each one, the array? How many elements are there? Well, three. So basically, this C dot shape, zero, tells you the total number of two dimensional arrays, that is too. And this shape. For example. One tells you in each 2d array, how many 1d arrays are there, these many? And this shape, for example, to tells you in each one the array, how many elements are there? Well, three grade? That's awesome. Yeah. Can I tell you 111 screens kind of thing? You can you can define a NumPy array, for example, a as NP dot array with just one element, let's say two. That's an array raid. What's the number of dimensions here? What do you think? What is that? Is that a 1d array? What are the number of dimensions? Strange? It's a 1d array. Yeah, it is. see another thing? For example, b is equal to NP dot array. And you define it with let's say three. And what are the dimensions of B, it looks like the same, the dimension of B should be one as as their the dimension of A is one, it looks like the dimension of B is also one. No, it's zero. Because that's an array. If you pass it as as a list. It's an array of one D if you just define just one number that can be defined as an array NumPy allows you that but that one number is just as a yo D array. Now if you can get in it, a lot of zero days, you get one day if you concatenate the last one days, you get a duty. If you're getting a lot of duties, you get a 3d and so on. Get a look and feel Yeah. So that's what it is. So yes, In this video, I discuss the shape there is another There is there are so many properties, let me let me discuss some properties, let's size that actually tells the total number of elements complete total number of elements in the array. So, how many elements are there that is size. There is also I guess m bikes property, that tells the how many total number of bytes that the destructor is taking inside the memory. And there are several other I mean properties, if you just apply a tab and get certain things, you will see a lot of functions. And you can you can check a lot of properties that some of these functions we will explore later on. Sometimes they are called the universal functions, we will see them because they are very, very fast. And these functions the vectorized implementation of these functions. That is the reason why NumPy is so so fast, and why it is so popular. Anyways, so in the next video, we will go to explore the NumPy a bit more. And we'll show you more fun stuff with the NumPy. So hope to see you in the next video. NumPy actually provides a lot of functions to create arrays, special kinds of arrays just for testing. And sometimes just for. I mean, there are a lot of ways to create arrays from scratch, for example, what if you want to create an array containing all zeros, so there is a function in NumPy NP dot zeros that tells you how to do that. Similarly, if you want to generate a lot of generate an array containing a lot of ones or all ones, there is a function to do that and stuff like so, there are some functions that are actually used a lot and I want to discuss those. One function is NP dot arrange, actually, this is a single R, this is not a two Rs, this is single r NP dot arrangement, one R and NP dot arranged function, what it does is it creates an array for example, if you say NP dot arrange, it creates an array for example, if you say okay, 100. So it creates an array that it creates a 1d array that starts from the the values in that array starts from 012, all up to 99. So that's an array. That's a quick way to create an array with all the numbers till 100. Yeah, so let's see, let's see running example of this NP arrange method in Jupyter Notebook just to get a better look and feel of how it works. So let's see. So let's say we have a equals NP dot arrange. And let's see 100. So that's it. If you want to see what is inside a, you can see this is an array with all the values starting from zero up to 99. Maybe you want to create an array that starts from a particular number ends at a particular number. Maybe those two numbers are different. And maybe this arrange function actually allows that. Let's say I want to start with 20. And I want to end at 100. And I want to create all the array that does that. So let's say this. So that's okay, start from 20 and 100. But the last element last index is not included. That's possible. Last but not the least, if you want for example, to start from 20 and add 100. And let's say you want to take a jump of three. That's possible. Remember, does this does this resemble with something that you know already? Remember that? Yeah, let me pause for a minute, but not for a minute, just for some seconds. Let me pause. Do you remember this arrange NP dot brains function? It looks like something like what? Remember that for i in range? Yes. for i in range, for example, start from 20. Go 200. Take example three. Remember that? So it has some resemblance with range function? Yeah. Although range is an arbitrator. What's an arbitrator? why I'm telling you that? Okay, let me tell you an arbitrator as well here, just just just just spend a few seconds on on this range function. You, you might be thinking when we call this range, let's say starting from, let's say range them, you might be thinking that it returns a list of numbers, starting from zero to nine, but that doesn't happen. It returns nothing. Actually, when you actually call it when you actually call it it returns just an object. When you call it in a for loop or somewhere. It progressively do. rounds one by one element one by one. So it returns an element, then it hydrates and return another element that it never creates a list of elements, it now creates a list for you. That's awesome. Actually, it generates numbers, it generates the next number and the next number as you move on. So it saves a lot of memory and these kind of objects, they are called I craters that I played, they they never played. But if you want, for example, to get a list, if you really want to get a list, then what you can do is you can call the range, let's say in the same way, and you can just write a list. So provide me a list don't just provide me an ID. And that will give you a list. How cool is that? Right? Anyways, that was just a side note. It has nothing to do with this arrange function anyways. So NP dot arrange, it actually returns an array does not it is not like an iterator, it returns an array, complete array the way you want. So that's what this arrange is it has resemblance with this built in range function that mostly used in in for loops. Okay. Next, let's discuss this NP dot random dot permutation NP dot random is a package. And P is a package, it has a lot of sub packages inside random as a package. Random has a lot of modules one module is permutation. There are a lot of other modules. So let's see this random. Let's see what it does. So for example, let's say a equals NP dot random dot, permutation, let's say permutation. And what I do is I say okay, np dot arrange, let's see 10 what it does is, this NP dot arrange will return an array containing all the values zero to nine, these are 10 values, and then this permutation function that resides in the package and P dot random that is in the random packet of MP, it actually shuffles all the values and rearrange all the values in random fashion. And he will now be an array containing the same elements, but in a different order in a different random order. So let me know print this a, it will be having all the elements from zero to nine bought in a really shuffled away. And that shuffling is completely random. Yeah, you see that? Sometimes you may you may call some function, you may want to write some function on arrays. And you may want arrays that are that that do not have a particular ordering, there are just random arrays, just to test your code just to test how it works on any kind of array. In that case, one way of getting shuffled kind of array. One quick way is to just use NP dot random dot permutation function. The NP dot random package does not only have this permutation, there are a lot of other functions and be random, for example, np dot random random dot Rand int, for example, Rand int, that creates a random integer. That's, for example, if I that's that, let me call this and we have, how can it be used? Okay, you can give a low value from the very start, we can give a high value, I mean, and it creates actually, random integers starting from low ending at high. So that's how it can be used. For example, let me call it as NP dot random dot Rand int, create a random number between 20 and 30, create some random integer, and it will return some random integer between 20 and 30. If we call it again, it may return some other is it is returning 30 again, 29. Again, and again. Now two turns 2932. Maybe we want to maybe want to generate random integer between 20 and 30. So it creates a random integer. One thing that you might be noticing what is the what is the return value? the return value? Is we for example, what should be the type of E or do you think? Is this V is an array? No, it is a number. It's an integer, the type of VA should be an integer because it is returning a random integer it is returning an integer but it is selecting that integer randomly from 20 to 300. So it should be integer and it is Yes. Wow. Yeah, so we will be exploring some more functions in the random package of NP and then we will be moving towards this fascinating function score function called V shape. So there is more to come for NumPy so hope to see you in the next video. Okay in the last video we saw a range function that's a very useful function to just create a test testing array and just see see the output of a particular operation or algorithm, just on different kinds of arrays. Further we saw permutation functions permutation function in NP dot random package. And we saw that this this permutation function, actually, it reshuffles, it shuffles different kinds of odd if if array is applied to this permutation function, it actually shuffles all the, all the elements of that array in a random way in a completely random way. Today, we will explore this random package a bit more, and then we will see a reshape function, but that reshape does basically this reshape, for example, if you have an array, let's say, array, is let's say we have an array with, let's say, 10 elements, and if we call a dot reshape, and we give, let's say, two by five, so it will make a two dimensional array out of a, which is B, and that will be a two by five matrix R, that will be an array, or a matrix with two rows and five columns. And now we can, we can just work with this B, just like it's a two dimensional array, and we can just, we can just treat this B as a two dimensional array and work with that. It is it becomes handy sometimes if for example, we want to, we want to test certain operations on on matrices. A quick way to make a matrix is just to call arrange function, and then whatever the result is just reshape it into the desired order matrix and test the algorithm. So let's go to the let's go to Jupyter Notebook and check this random package a bit more and then see the reshape function. So let's go to Jupyter. notebook. Yes, so there are a lot of ways to generate these random numbers. One for example, we already have seen Rand int. And other way for example, array, an array can be generated, like MP dot random dot RAND function. So now, if we create this, if we create, let's if we pass let's say 1000, random value array will be generated in a and a each value of a will be a random number between between zero and one. So all these numbers are just random between zero and one each number is zero and one random number. And, and this distribution basically is the distribution of this random number is all the distribution is uniform. If for example, you want to plot the histogram, the histogram or the distribution of a it will look like uniform. Let me just give you give you one or two plots, using matplotlib package, although we will see matplotlib package later on. But let's assume that this is just a plotting package. This is just a package that helps us plotting just import that import mat plot lib.pi plot as PLT import that. And after importing that, you just plot a histogram PLT dot hist, for example, and pass a and you can see the histogram is roughly uniform. I mean, everything is equally likely we can make more bands, for example, we can have bands, equals let's say 100. And we can see almost all events they are I mean just look like uniform. If we make more and more data set, then they will all look uniform. One more thing we can we can have, for example this. And let's say B equals NP dot random dot Rand n, and that generates normal random numbers, or Gaussian random numbers, let's say which which the distribution of the numbers are is the bell shaped curve, for example, so let's just PLT dot haste B. And then let's say equal to 200. And we can see a bell shaped curve because the distribution of this data is is Gaussian distribution looks like so. So this this random packages, this NP dot random is really important package. It has different, it can create different kinds of random numbers from following from different distributions and doing in machine learning or in statistics, sometimes we need to generate these kinds of random numbers for sometimes for testing purposes, sometimes for adding noise of a particular type to test our model and stuff like so. So it's good to have a good grip on NP dot random package. Okay. Next we see reshape function. One more thing. For example, if you want to create, for example, a two dimensional array of just random numbers, let's say you can call NP NP dot random dot Rand. And you can just call a, you can just pass two arguments, for example, two by three, and the C will be a two by three matrix. If you see the C, it will be a two by three matrix of four random values. If you see c dot, and then it will be having the dimensions are two. And it's a two dimensional array. Further, we can create, for example, a four dimensional array c equals NP dot random dot Rand, maybe two by three by four by two. And that's a four dimensional array with this particular order. So if you see this C dot m, then that will be level b, this. Yeah, so let me let me just give you an interpretation of what that thing is. There are two arrays that are three dimensional. And there are two of those. Okay? Now, each three dimensional array has three two dimensional arrays. Wow. So each two dimensional array has four one dimensional arrays, and each one dimensional array has two elements in it. So that's what the structure is. Yeah, get a good look and feel. So let's see the reshape function. For example, let's say we have d equals NP dot range. Let's say we have 100 values. And then we say reshape these 100 values to let's say, let's say four by 25. So this D will be a four by 25 matrix. So if we just get the shape of D, so that will be a four by 25 matrix or a two dimensional array with four rows and 25 columns. Yeah, so sometimes we want to work on matrices, and we just, we can just plug in these arrays function to generate a bunch of numbers. And then we can reshape those and build a matrix quickly, and then just test the performance of our algorithm or stuff like so. So, not only the reship not only returns the, the I mean, you can you can reshape a matrix, and you can reshape an array into more than two dimensional array if you want to, for example, arrange 100, let's say dot reshape, maybe or as four by five by five, it's a three dimensional array. Now, this D will be a three dimensional array containing different values. Yeah, so now you can access it and do whatever you want to do. So not only the reshape, arrange and permit random, there are other functions as well NP dot zeros. For example, if you press z, and you just see the zeros, and then you just press the question mark, you will know what that function is how can we use it and so on. Similarly, you can have several other function there is an important function once for example, you can call that function, and that will generate an array of all ones, you can see how to call that function here. There is NP dot empty, there is NP dot empty, like there are so many functions just to create some matrices very quickly. And you want to test your core algorithms based on those. So yeah, so there are a lot of functions that we want to that we can work on. So next, so there are a lot of functions that can quickly create a NP array and an n dimensional array. That we can quickly create an array test or algorithm or use the array wherever we want to like we're everyone to use. And we can move on just a few functions like arranged ones zeros, they are there are random dot Rand random dot Rand n, and other functions they are available. For In the next video we will be seeing we will be seeing the indexing or slicing inside NumPy array and we will also be seeing the difference of that indexing with or slicing from the array In the list or or are the ordinary data structures? What is the difference in? What is the difference of slicing in NumPy? with for example, with the list, we will see that in the in the next video, hope to see you in the next video. Okay? Here is my favorite topic in NumPy slicing. Actually, indexing or slicing in NumPy is the way you access sub arrays is just the same as the way you access sub strings or sub lists. And you already have seen, how can we how can we use the slicing or indexing in lists and in strings, the difference here in NumPy is in list for example, if you slice you get, for example, let's say B equals a one colon five, if you slice that thing, from NumPy, then B is not a copy, it is actually accessing the same memory view as an A. Now, if you change any element in B, the corresponding element in a will change as long as as a NumPy array. However, if A is a list or any other data structure, ordinary data structure, then the slicing this, this kind of slice gives a copy rather than a view. So that's an important difference, we need to know that rest of the indexing technique is almost the same. You do this kind of indexing that is how you can reverse this a start and step all all the things are same, except How can play How can we play with the two dimensional arrays. Let's let let's see that. Let's see some examples of indexing one by one in in Jupyter Notebook and see how the slicing actually creates a view rather than a copy. So let's go to our Jupyter Notebook and see how can we play with different indices, let's say a is NP dot arrange, and B dot arranged, let's say 100. And let's shuffle them. Let's say as it is, let's say that's a now a, let's say, let's bring some certain things. Let's A B equals a big all the elements starting from index three, ending at index nine, Sudan is not included. That's B, that's blank v. Let's see what's B. So b is this array. Okay? Now what I'm going to do is I'm just changing the contents of b, this NumPy array is mutable, you can change the elements inside, no problem. So I'm going to change the elements, let's say one element in B, let's say, I'm going to change element numbers zero, and B, which is three, and I'm just placing that element as minus 100 minus 1200. That's it. That's the case. Okay, now the contents of B has been changed. We are but now let's see the contents of a the contents of a also has changed. That's a big difference between slicing an ordinary Lester adini data structure or slicing a list, when you slice a list, you get us you get another label, but that label or that variable is accessing the same memory, the memory actually is not copied. There is one memory view. And these two different names, whether you access those elements using B, or you access those elements using a the same memory is being accessed if you change the memory using B or A you will see the effect in both of the variables. So that's one difference. Now, after having knowledge of this difference, if we really want this behavior to not happen, one thing that we can call is we can say okay, a, for example, a, let's say three to 10. And then we can call our famous function, remember that copy, you can copy that and now B is completely a different array. It's it's a different memory view, if you change B now, the effect will not be seen in a so copy function is there whenever you need copy. One thing if you are not going to change elements the number is applies you very fast implementation of slicing by not changing the memory view if if you are aware, your algorithm is not going to change the elements slicing will give you much much efficient access to the elements or the or the sub blocks or sub arrays without actually making the copies inside the memory which can take time and space both. So this is one plus of NumPy Over the over the other data structure that we have seen so far in Python, okay, let's play with indices, let's say what do you think? What is that thing? colon, colon to what? Or colon colon, let's say five, what it will do, it will start from the very first index, which is zero, it will go to the last index, but it will pick every fifth element. So let's see. So, it picks zero then five then 10, then 15, because the jump is five break, what do you think what this will do? Let me just let me just teach you by example, what this will do. Yeah, what it will do remember, if you apply a minus here, the end and the start and end they just get swept, and this becomes a step from from the end. So, what will happen is the same kind of impact, you start from the very end, then you take the step of minus one from the end, and you just based every element, so this is kind reversing the array with with kind of step starting at the end rate. So, another way of reversing the array is if you want to reverse the array as a whole display minus one, which means start from the end and pick every element from the end till the beginning and the end, and the array will be reversed. This element is there, remember that this is there, let's chain that element. Let's chain that element. So, so a adds position. So, I want to find out the index, where this minus 1200 is located. So Id x is equal to a dot index I guess there is a function index Yes, he has a no index Oh, there is no index there. Is there an MP dot index and P dot index? I want to find out the index where so in DAX there is no index function indices or something, I want an index function is there any index function I want to find out the index? Where minus 200 is located? There are several ways but I want to find one. So for example, for example, let me see whether there is an index function and not available in NumPy or not. No, it is no longer there. But there is in the CS function, I guess. So in the CS, what that does, I guess that does the same job. Let me see MPR indices returns an array representing the indices of a grid, okay. So I have to give a grid and then it returns for example, the indices of all that grid, how can I use that? Well, it becomes it becomes difficult, there may be a find function, or how can you locate the index where the minus 200? Is, is located? How can I How can I do that? Huh? Yeah, very difficult. Seems like very difficult. Oh, why don't I rather than finding out a function? Why don't I just play with play with the NumPy? Why not? So let's say a equal equals minus 1200. That gives me a Boolean array comparing each and every element with minus 1200. So, the array the returning array, let me call the index array or the Boolean array, let's be that array is true or false array or zero or one array, wherever there is minus 1200, that index is one that value is one otherwise it is zero, completely zero. And then what I do is, I just multiply that with with NP dot arrange NP dot arrange with with saying that a dot A dot A dot size, so whatever the size of A is, so because these are the indices Okay, then what that's point wise multiplication grade. So, when I will multiply them together, what I will get is is what I will get from multiplication, I will get, how can I How can I find out actually, a train lost here literally, how can I find out how can I find out the index where Where am I? So that will give me what? Let's see, what is B. Now, the B is B is just an array. B is just an array, and there is this three. That is looking at it. So how can I find out? Where is this three? How can I, again, the problem is finding out the index. Okay, that's, that's really a bad thing. Can I call this aid dot indices? And just give a minus 1200. And everything just worked out? No, there is an error, there is an error. Oh, I'm lost here. Literally, I'm lost here, I need to know how to find out the index where this particular element minus 1200 lies. So that's a question for you as well. I'm also lost. So let's see you in the next video. And we first will solve this problem to finding out the index of a particular element, or maybe a lot of elements. And then we will continue from there onwards to see more indexing. Okay, great. So hope to see you in the next video by first solving the problem, how to find out the index of a particular element in a NumPy array, or maybe more than one elements in a NumPy array. And then we will be practicing more about these slicing examples. Okay, hope to see you in the next video. Okay, let's say this element is there. And let's say we want to, we want to locate that element in the array, we want to just know where this element is in the array. So array has this element. Let's let me paint array as it is, this array has this particular element, and we want to know where what is the index of this element inside the array, there are several ways of doing this. One way is to find out their index is simply you call the function arc where arc where for example, org, where A is equal to minus 1200. And that will return a 2d array. And if you just want any one index, then you return that kind of thing. So if you write this thing, you will get the index exactly of the element that is there. So the index is three, if you want to change that value, for example, the value should be three here, if you want to change that value, what you can do is you can right, okay, ie x is equal to three, and is reverse to its position wherever it was created, okay, great. Now, let's play with the two dimensional indices. Let's do dimensional arrays, let's say we have a equals NP dot random dot, Rand, let's say, let's say we have a five by four matrix, let's say a two dimensional array, let's round all the values by multiplying them to 10. What it does is because all the values this RAND function, all the values it generates are the values between zero and one, what this multiplied by 10, what it does is, it actually scales up all the values to 10. And then round function, actually, round downs are actually rounds the values to the integers. Now a will be worse the problem round that third round method is no longer there. Okay, maybe there is NP naught round, maybe that NP dot round, maybe NP dot round is their Yes, and B dot round. So round function of NP. So this a is a is this array, for example, that's five by four, a four, five rows and four columns. So let's say I want to access the second row. First of all, let's say I want to access this particular entry. This particular entry is second row and third column, which means the index is one comma two, because second row means the row row first has index zero. row two has index one. Similarly, column one has index zero, column two has index two, a one and column three has index two. So that is what this particular entry is. What if we want to access the whole second row, for example, we want the second row. So that's how you call that's how you slice. A normal meaning of this is you the role should be one and the columns, all the columns, so That's how you access the whole second row. If you want to, for example, access the whole third row, for example, or a whole second column, let's say that means you say this, okay, the column number second, and all the rows, which means the whole second column that is accessed. That if you see, that's the whole second column six, four to 10. And one, that's what the second column is. Further, once you have a, you can, you can, for example, access a sub matrix, let's say you want, you want row number one to rule number three, not including three. And then of these rows, you want column number two to column number four, let's say. And if you do that, you access the whole sub matrix. First, it actually picks row number two and row number three, because row number two starts from one. And then of those rows, it picks these columns, and you can just pick the pick the sub matrix inside more, you can, you can do a lot of processing on these matrices. For example, this is matrix A, if you just type a dot transpose, that these four transpose, the matrix just is taken transpose of it. Further, there is a complete library, linear algebra library in NumPy. For example, if you just import NumPy NumPy dot linear algebra, as a for example, then this linear algebra library in NumPy, has a lot of functions, Eigen values, chelski decomposition, computing determinant of a matrix, finding out inverse of a matrix and what not. For example, let's say we have la dot inverse, and here is NP dot random dot Rand, let's say, some three by three matrix. So what it returns is, it returns the inverse of this matrix, and this linear algebra library, and there are other libraries as well. But this is one scientific library, that may be most of data science experts who actually want to do research, they might be thinking, this linear algebra library, that that specifies a lot of functions related to related to these matrices or two dimensional arrays. So that is there. Okay, so that's about indexing. We can play with these indices a lot if we want. One more thing, just just one. One last thing, let's say this is our a. And what we want to do is let's say we want to sort this A with respect to the columns, we want each column to be sorted individually, what we can do is we can call sort function, and we can pause X's equals zero, access equals zero, that means sort all the columns individually and the result will be if you see the result, the result will be every column is sorted individually. If we want to sort for example, every row individually, we will say okay, sort x is equals one, and every row will be sorted individually. And if this is a multi dimensional array more than three more than two dimensions, then x is can be two x's can be free. So which with respect to whatever axes you want, your sorting can happen. It can do that, if A is one dimensionally, then dot sort function without an access, just sorts just sorts the one dimensional array from beginning to the end. And if you want to descending order a sword just sought them sorted first and then reverse it using indexing. Great, I mean, there is a lot to discuss, there is a lot to discuss, I'm ending this slicing here. In the next video, I'm going to show you kind of masking or sometimes called the fancy indexing that is much more powerful and useful in a lot of different contexts. So hope to see you in the next video with more NumPy indexing. Okay, there is another way of indexing a NumPy array. In the last video we saw we can, we can do slicing notation, for example, start from here and here and stuff like so. There is another way of accessing a NumPy array as we have an array and we can just give the give an index array inside for example. Let's say a is one dimensional array and then we just give 146 that means big element at index one, pick the element at index four, pick the element at index six. So this kind of array inside can be a list or an array. That is called an index array. And you can just pick the elements that you want to pick, for example, you want to pick all all elements, you want to pick first element, fifth element and 17th element, you can just create an index array and pass it. And in an index your and access your elements using that index array that's possible in NumPy array. Further, you can access different elements using a Boolean mask as well. So Boolean array, for example, true, true, false false, wherever there is a true pick that element wherever there is a false, don't pick that element and return the elements that are picked. For example, assuming here that you have an array, which is one dimensional array, let's say, assume that has eight elements, 12345678 elements. Now you pass a Boolean mask inside, where with with obviously, eight elements, a true or false values, wherever there is true. So pick the very first value, pick the second value, pick the don't pick the third value, don't pick the fourth value, pick the fifth value, pick the sixth value, pick the seventh value, and don't pick the last value. So that is also possible in in NumPy. One thing that is important is if you do this kind of indexing, which is sometimes called masking, if you do that, if you do if you supply an array index, or index in a Boolean form, you by default get a copy as as as compared to slicing in slicing, you get a view that's a separate copy, you need not to call a dot copy function, it is by default, a different copy. And this is a difference between the ordinary slicing that you do, for example, start from one go till 50, take a jump of let's say two, if that is your indexing style, that is called a slicing, the return value is a different view having the same memory. However, if you do the, if you use the array index, or the Boolean array called masks, then you get a copy of rather than also so which means if you if you get a new array, you change the elements in the new array using the array indices. You're not getting that change happen to the original array. So that's the difference between slicing and masking. Okay, this kind of Boolean indexing becomes really handy. For example, what if you want to exit? What if you want to get all elements that are smaller than eight, one way to do that is just write a and then apply a condition is less than eight, well, a is less than eight, we'll create a Boolean array. And everywhere where the element is smaller than eight, there will be a true otherwise it will be false. Now, the inside array is a Boolean array, and you access all the elements with respect to that condition. So it will return all elements that are smaller than eight. How how fancy is that? Further, you can you can have these conditions in a combined way. There is one difference there is an AND operator A and D and, and there isn't an operating in a different way. So I'm going to discuss the difference of this and this and as well in this in this whole in this video. So let's go to Jupyter Notebook our fan and see how can we play with this masks. So let's say a is again and B dot arrange, arrange, let's say 100. That's it. That's our a. And what we now do is we access the elements of A, B access, for example, the third element and the fifth element and the sixth element. Let's say we want to do that. And that's our B. So that happens, let's say, so what B is B is this, something that you need to know is if you change the elements of B now, because that's a copy, let's say minus four, that change does not happen in eight that happens in B for sure. But that doesn't happen in a, a does not contain any value that is minus four. Because using these kinds of indices, the array index By default, the result is a copy rather than a view. Further, let's say you have this a and you want to access all the elements that are smaller than let's say that are smaller than let's say 40, access all elements that are smaller than 40. So that is possible now even contain only the elements that are smaller than 40. All the elements while further if you want to access all elements that are that are smaller than 40 that are smaller than 40. And they are bigger than they are smaller than 40. And they are bigger than 30. Let's say you want to access all the elements that are between 30 and 40. You can just access those elements like so there is a problem. A dot any a dot all what's the problem here? The truth value of an array with more than one element is ambiguous use a.ne or a dot all. Okay, this a is less than 40 is a Boolean array is greater than 40. That's a Boolean array. So what's the problem? What, why can't we not use this? What's the problem? We should have used that. So use and, and, yeah, I guess we were missing these, we were missing these brackets because it might be confusing this 40 with this a and stuff like so. So use parenthesis rate. Now, B contains only the elements that are between 30 and 40. Now, one thing, what's the difference between this particular and and this symbol and the difference is this and AMD an operator It is used when both of the sides of this end has what is one object and it has one true value either true or false. And this particular symbol is used when the left side and the right side can be arrays, and each element of that array can be true or false. And so, so, you can think of this and is using arrays, however, this is used when both the sides are single objects. So that's the difference. Other variants of and I mean, the end is like this, that these are these are the same things, but remember the use this is used for arrays, this is used for single objects. Similarly, there are other symbols like or that is used this way or or that is used that way. Similarly, there is a not not for arrays is used like this way and not for otherwise, is used like that way. So remember these the left side, I have symbols, they are used for arrays, the right kind of symbols, they are used for single objects that has true or false values. So these, this kind of masking is really, really powerful. Later, we will see in pandas accessing different kinds of data with particular kind of conditioning, that becomes really handy if we if we are comfortable with these kinds of indexing. And that's really powerful indexing. Okay. So, I've told you the difference here between Aaron and I've told you that this is copy rather than a view. So just bear with me some more time on NumPy. And I will tell you some more truths about NumPy. And then we will move towards another package called pandas. So before pandas more NumPy is coming, I hope to see you in the next video. Okay, in the last video, we saw masking, which is sometimes called the fancy indexing as well. And here we are going to discuss one more feature of NumPy, which is very powerful feature called broadcasting. I think, for example, you have an array, let's say two, three, a matrix, that's a two dimensional array 235 and nine, and you want to add, in every element, you want to add a number, let's say five. So one way to do that is create another array with 5555. And just apply this add operator and you are done. Great. But this NumPy allows you to just write let's say this is array, a NumPy allows you to just do this particular thing. And this five is automatically broadcasted to match with the dimensions of its other operand. And addition happens you need not to do this explicitly. And this broadcasting is not just one scalar value. For example, if you have one variable, let's say a is this and you want to add, for example, this particular column, let's say one three, you want to add this particular column in the first column as well as in the second column, but then you need this one three to be copied again and make a bigger array and then you do that well, broadcasting allows you if you just write this as a plus one three, it will be automatically broadcasted to match the size of the other operand, wherever the book broadcasting is possible, there are certain rules to to know when broadcasting is possible it is not possible each and every time. For example, if you have this matrix 239 and Jeff 421 Let's at this matrix and you want for example, two one and six two, for example, if you want to do that, the broadcasting may not happen because in this way, if I want to broadcast this structure, the structures should be if if the structure is broadcasted to in horizontal way, the the two columns will be arrayed and the addition cannot happen. If it expands to a vertical way still the addition cannot happen. So, this here you will get an error because broadcasting is cannot happen, but in several cases when you want to add for example, a scalar multiply with a particular thing wherever possible this broadcasting is possible and broadcasting is just a I mean it just a feature of NumPy that allows you to not repeat to match the dimension of the other operand to apply a particular operator it does it by itself great. Next, we see some more important functions to no one is horizontal stack. That means, if you want to concatenate two different array two arrays that are that can be concatenated together horizontally, you can get out you can call at stack function and that will concatenate the two arrays together and returns another array. Similarly, V stack is if you want to concatenate two arrays vertically, if they can be concatenated vertically, vertically, similarly, there, there is another powerful function sort, and there are a lot of other functions, these kinds of functions, they are called Universal functions. And they are very, very, very powerful, very, very fast their implementation is vectorized, where Christ mean the implementation the all loop kind of layer is deferred to at the compile time and the things are really faster when you do a vectorized code. So, having said that, it is always recommended to not use explicitly for loops to achieve these kind of, to achieve these kind of results, whenever a universal function is available, use that because the efficiency of that universal function will be way, way way more than then whatever loop loop or whatever function you will be writing other than the universal function. So, and by the way, there is another function concatenate as well, in which you can specify axes. And it will either act as horizontal stack or either act as vertical stack, depending upon whether the x value is zero or one, whatever. So, let's just get comfortable with these, these three functions, just quickly neural Jupyter Notebook and see an example of, let's say, broadcasting as well. So let's say we have a function, and let's say you have an array is let's say, np dot random dot Rand, let's say that is two by three. And then I just multiply this with them. Remember the last thing and then we just NP dot around, we just round everything. So that it becomes it becomes whole, in this particular way. Okay, that's a, let's say, so that's our a, that's the now if we say a plus three, three will be added everywhere in a, and that happens through broadcasting. Well, if we if we do, for example, a plus, for example, np dot range, let's say just do values, and then we just reshape it, reshape it, to reshape it to let's say, a two by one matrix. If you do that, then still, what what will happen is just apply the parenthesis just to show that this should happen. First, what what will happen is there will, there will be a column that will be added to every column A, and that again, will be happened through through the broadcasting. So broadcasting is that powerful. Next, let's see the stats. So that's it, this is a, let's say we have the that's another way, let's say NP dot random dot Rand. Let's say that new array is two by two. And again, let's say it is multiplied by Dan and NP doc round just to avoid the decimal points. That's it, this is B. Now a is two by three array D is a two by two array, if I just concatenate them horizontally, I will get another array which will be two by five. So C equals np.at stack horizontal stack, at stack, and I will call these A and B. One thing that you need to know is if you if you want to call this x stack, horizontal stack or vertical stack, these arguments in B that you want to concatenate you have to give them in a topple or you may you may want to give several values to concatenate together maybe you have maybe you have 10 matrices to concatenate together horizontally. You have to give all these as a tuple inside a All right. Now similarly, we can do a vertical stack if we want. I mean, one on top of the other. And we can call it and getting it function as well, if you want. Third is sort function. For example, if we want. If you want to use NP dot, let's say a is NP dot random dot permutation, let's say NP dot range, let's say the 10 values. Let's say that our a, let's say, this is a, and we want to sort this array. Oh, this is already sorted. Why is it sorted? No, it is not sorted 1/4. It is not sorted? Yeah. Let's say we want to sort it a dot sort. One way of doing that is just call a dot sort, and you're done. That's the value of a another way, which is sometimes more readable, although exactly the same is to use a universal function, using NP dot that thing that also is the same thing. Now sort by default sorts in ascending order. If you want to sort in descending order, then what you can do is you can sort aid or sought, for example, do that in ascending order, then what you do is you just reverse it, minus one, and just copy that in a again, now he will be sorted. While sorted in descending order. Yeah, great. Um, one more just just just just to give you one more flavor, if you create an array, for example, np dot array of strings, for example, ABC, and another string is, how are you and vai maybe we have another string? Whew, 785. And maybe we have another string, one, three e r, that's it. That's a string. That is possible. As long as all the objects have same type, you can create an empty array. Now, you might be wondering, what we'll do this sort function on a because these are all strings? Well, the answer is it will sort the strings according to the alphabetic order, whatever the alphabetic order is, whatever string according to the alphabetic order should become first that will become first and the other strings, they will they will just join. Yeah. So yeah, so that's about something that is not that is not the numeric value. Okay, great. There is a few more things to come about NumPy array, and then we will be moving towards panda's library that is built on top of NumPy array for better processing of data, I hope to see you in the next video. Okay, in last video, we saw horizontal concatenation, vertical concatenation sort function, we also saw some broadcasting and stuff like so. Universal functions, it should be speed here, sorry, it should be speed, speed. Universal functions are really, really speedy, I always am talking about NumPy. Whenever I start NumPy, I said, it is fast, it is fast as fast, I never show you how fast that is. So let me give you an example. Let me let me just create an A NumPy array with a lot of numbers, and then just apply an ordinary function, let's say want to add all the numbers in this array B, let's apply an ordinary function that is not in NumPy. And then let's use universal function dot sum, and see how speed differences there. If for example, we apply apply a universal function to achieve a particular task how speedy that universal function is, because a vectorized implementation, as I told you is much faster, how faster let's check that out in new Jupyter Notebook. That's a magic command time ID that will tell us how much time this particular task has, has taken. And if you run this command, it will it will call this function again and again several times. And then we'll report an average value that will be much more stable than just calling once. After that, we will also we will also write our own sum function using loop. And we will see whether that is even closer to a universal function speed or not. Let us just check the speed of universal functions that will give you a look and feel of how much NumPy implementation is faster. So let's say we have an array, let's say B and B dot random dot Rand. And let's say that array is huge, really huge. Let's say that's the case. Now what we do is we let's say we we call a function sum. So let's say we call a function sum. That's a built in function. In Mumbai, that's a built in function that's a built in function in Python, not a NumPy function. And then let's say we do the same task using NumPy universal function and P dot sum, that's the same as NP dot sum is the same as if we if we write, for example, b dot sum. So whether you write b dot sum, or you use NP dot sum and be passed and passed, as an argument, both these things are roughly the same. So let's run it, it will take a while It will take a time because, okay, the sum function takes 307 milliseconds, that is not a universal function in NumPy. That's a Python function. That is not written in NumPy. That is not a vectorized code, nothing. It takes 307 milliseconds to perform to take the sum of the elements of this array. And it does that by applying seven rounds in in Santa loops. However, the universal function takes just around three milliseconds, I'm assuming 2.7 milliseconds, how will how are you going to compare this 307? With three? How much faster you are around? Around 100? times your faster? I mean, yeah, I mean, this NumPy is literally faster NumPy, the universal function will faster, maybe you attempt to know that, okay, the sum function might be too slow. Let me write my own function. To do that, let me define my son, and my son just take an argument, let's say something, let's say G. And what it does is for, let's say s equals zero, what it does is for x in g, s plus equals 2x X plus equals to x and then just return as nothing. That's your function. Let's say you think that this is really a great function. Let's do that. Okay, let's compute the time for this time it my son. And let's pause the rabee and see how faster this is. This is roughly the same as your calling the sum function, but this NP dot sum or the universal function is very faster, fairly faster. So, use universal functions, avoid for loops, avoid your own functions, if the same task has been a can be achieved through universal functions, whenever possible, avoid loops when you are working with NumPy. That serious suggestion, follow that, because the universal function written in NumPy, they follow the vectorized code, all the interpreted slowness that is deferred to the compilation layer. And the NumPy becomes really really faster and shows its power when you are working on large arrays using the universal functions. So I can speak more about NumPy. But I have told you some basics of NumPy. And we end the NumPy here and from the next video, we will be moving towards a very, very fancy and beautiful kind of package called pandas to handle data. And by the way, the pandas library the pandas package completely is built on top of NumPy. Everything that is there in pandas is built inside is built on top of NumPy as all the indexing and all kinds of stuff, slicing and speed. All is there in pandas that is due to the NumPy. So we will see one more package after pandas which is matplotlib for for plotting afterwards. And we'll do a project at the end using scikit learn as well, just to wrap up all these things together. But for now I'm ending NumPy here and in the next video, we will start pandas hope to see you in the next video. Okay, welcome to pandas data science package that is very, very powerful of handling data, manipulating data and used a lot in data munging and data cleaning and data pre processing and whatnot. This pandas basically is built on top of NumPy. So most of the features of NumPy is also available in pandas. Let's let's dive in. I mean, this pandas is a very, very fancy library, very, very fancy package, that you can handle very large amounts of data in CSV files or an Excel files. Wherever the data is located. The missing entries are there. You can handle all the data you can manipulate all the data you can prepare all the data in just a few lines of Using this pandas package, so let's just start pandas package. There are two most important objects of pandas. One is series and other is data frame that we will see later on, there is one more index. But the most important one is, or the useful one is the series and data frames. So let's just define, first of all, you need to import pandas package import pandas. And you can rename this as PD, that's a, that's the most popular renaming, although you can rename it any. And then you just say okay, PD dot series, and then just like a NumPy array, you pass the data that you want. And you can create your own indices, for example, like, just like dictionary, this a is a key value. This is a key or index for this point, two, five, this B is index 4.5, C is index 4.75. And these index four one, so you can you can, you can supply your explicit indices as well. If you do not supply the indices, the default indices are 012, and three, but you can define your own his own indices in the way you want. Now, once this data object is created, you can call the data values and you will find out the values you can call the dollar index and you will find out the indices let's see in the Jupyter Notebook just to get comfortable with pandas. First of all, import pandas as PD, maybe or something else. So okay, let's import it, maybe we can check what we're going to reveal working in PD dot worryin. The version of pandas we are working in right now is 0.2 4.25. Read. So let's create data or whatever variable let's say a as PD dot series buzy dot series and there we just give a list of some values 2345 let's say these are the values. And then we can give index as another list. Let's say the indices are a maybe the indices need not to be strings, anymore, anything AB, C, and let's say the index of fighters. Let's see. So now the series object or the pandas object series is created. Series basically handles one dimensional arrays, later on, we will see DataFrame handles multi dimensional arrays, I mean more than one dimensions. Normally typically two dimensional arrays, but okay, a dot values. So let's call the values, values, and you will get all the values inside the series. And by the way, this values array that you get, let's check what's the type of that array was type of battery? A dot values? What is that thing? That's a NumPy array. Wow. And what's the type of a itself that will be a pandas object. Great. So everything inside pandas, the NumPy is playing all the role inside pandas. Great. So now, let's check the index a dot index. That's also a NumPy. That's also an array of index type, that's a different actually index is also an object in pandas. That's an index type object with these kind of indices, we can access for example, this a, just like we are working with dictionary for example, a dat returns a value, we can change the values, we can add different, we can add more key value pairs. So just think like these. Just think this data I'll just like the dictionary object that we saw this, these are the keys and these are the values. And this is one one very good way of remembering what the series does, and manipulating series The way we want. Okay, one, we can access a z like this, we also can do slicing. Let's say we want to access from A to let's say C let's say we want to access all these one difference is when you access like this, in the normal slicing using implicit indices, for example 123 or zero, the final index is not included, but if you access like so, using explicit indices that are there, the final index is also included. So that is one more fancy way of indexing using in this pandas. Okay. Great, that's a serious object by the way, we can create a serious object by first creating a dictionary for example. Let's let's go back to our slides and see this example, let's create a dictionary. For example, of plates, let's have a lot of students with Grade A grade A minus Grade B, red b minus, and let's create that dictionary, then we can just create a series object or panda's object, by just passing this dictionary inside, we can make another dictionary for example, and we can make another series object. So a one way of defining the series object is just to is just to pass the data as well as index in other ways to just first create the dictionary and just pass the dictionary variable inside, and the series object will be created. Okay, that was just an introduction to series, we will move on and see more features of pandas, as we as we explore it more and more in the upcoming videos. Hope to see you in the next video. Okay, let's say we have two different dictionaries, let's say we have a lot of students and the a grade is defined to be four and a minus grades defined to be 3.5. The b grade A has a number three, the B minus grade has a number of a numeric value that is 2.5. And similarly b grade has an American value let's do and then we create just a series object using this dictionary, let's say rather than just the numeric values as GPS or something like so let's say a grade also is defined at 85 marks in total, a minus graders defined at 80 marks in total, and similarly these and then we create another series object, let's say named with Mark marks using these PD dot series. So let's go to Jupyter Notebook and just play a little with these dictionaries. And build the series object, let's say marks, or let's say grades. dictionary equals, let's say, a grade, is has has an eighth grade has number value for RGB value for let's say, let's say we have a b grade with GPA value, let's say B is let's say it's 3.5. Let's say we have C grade with GPA value, let's say three. And let's say Finally, we have d grade with GPA value, let's say 2.5. Let's say that's a dictionary. Okay? What we do now is we create a grades series object, let's say using PD dot series, and just pass this grades underscore teched. Now this capital a capital B, capital C and capital D, they will act as indices and this for 3.53. In 2.5, they will act like values. So for example, if we call her and just now called grades dot v dot values, so we will get, for example, what is that? That just values, let's say, beget this grade stock values, and we get all the values that are available. Similarly, if we find grades or index, we will find out A, B, C and D. Let's define another dictionary, for example, marks dictionary dict. And there is let's say again, a while the total marks are 85. For the a grade, let's say, for b grade, the total marks are let's say, 75. Let's say for C grade, the total marks are let's say 65. And for D grade, let's say the total marks are 55, let's say. So let's say that's another dictionary. Now, let's create a series of objects, a series object PD dot series, series, let's say marks dictionary. So now again, we have if you just write this marks, just like so, you will see the marks is 85, b 75, c 65, D is 55. And all the values they are integer 64. Ghana values, now we can access. Now we can play with this marks, for example, if we just want to access for example, what are the marks? What are the marks between, let's say, for example, what are the marks given a at a we can access that we can change that we can just play like a dictionary. What if we rather than using the index In a, we use for example, slicing, we want to start from the very beginning. And let's say we want to go to two what will happen? Let's see. Yeah, so, the slicing is there for example, if you want these are explicit indices A B, C, D, these are explicit indices and they are there. For example, if you can slice the you can slice the data using explicit indices that you are given that you are given or implicit indices that are the default indices, the first value index at zero, the second value is index two one and so on. So, you can do that as well, one catch here for example, that we will see later on, there may be a problem that your explicit indices they are also numeric, and then you do the slicing like so, then the series object may be confused whether I have to use the explicit indices or implicit indices inside we will see how to resolve that issue, but by this pandas allowed to use explicit indices as well as the implicit indices. Okay, we were here. So, he just so, yeah, so, we were here. So, we have created these grades a series object This marks as a series object, these the series object is good for one dimensional arrays or data with just one dimensional list or dictionary, kind of with just one dimensions, later, we will see data frame that actually is is actually the extension of curl can be looks like it can be looked like as an extension of series towards more than one dimension, we may have, for example, two dimensional arrays or two dimensional data structures, something like so. And we will be seeing this data frame which is much more powerful, particularly for reading data from files and manipulating it and stuff like so. We will see that in the next video data frame that running form of data frame in the next video, hope to see you in the next video. Okay, in the last video, we were discussing series, and I told you that data frame is basically if if the data has if the data in the form of different columns, for example, a record as an array, then you have another record, then you have another record. And each element in that record is a different attribute. So this particular way of two dimensional data is very well handled using data frame inside pandas rather than series. So but you can make these data frame objects using different series objects. For example, you have a great object that grades object that we created last time, you know, marks object that we created last time, let's build a data frame using these two and see what it looks like in in Jupyter. notebook. Let's see that. So remember, we have a marks series object, and we have a grades series object. Let's now make grades. Maybe, maybe the name is rates, okay? The name is like grades. Okay, so grades object, this one, let's make a data frame. Let's say D, or maybe whatever name you want to do data frame with, again, that data frame can also be defined using a dictionary. Again, now we have let's say, marks is the key for data marks. And grades is the key for data grades. Let's say let's say we define a data frame like so. And now if you see if you just display this D, we get a very beautiful look and feel of I mean this as the index is the explicit index at index a, the marks, the marks is 85. The grades are for at index B, the marks are 75, the grades are 33.5. And so on that that looks like so not only that, you can just transpose it like you have transpose to a NumPy array, and you will get the flipped version or the transpose variant if you want. Great. So that's how and you can have for example, more dictionaries to concatenate together and more columns will be added here. And that's what the real data looks like. I mean, it has a lot of columns, which normally are attributes. And each row is basically one record or one sample of the data that you want to work on. So this data frame is really, really ideal data structure for working with files, having a lot of records and you want to manipulate the data and stuff like so. So yeah, so one more thing, let's let's access the D, for example, that's brand D, that's the, that's the D, let's access the values inside D, other than No, so what are the values, so, the values inside D is completely again, a two dimensional array that is completely like so. So for example, if we want to access this particular element 65, that is row number three, and column number one, excluding the indices at row number three and column number one. So we can access that particular value T dot values, just assuming that dimensional NumPy array, row number three is to index with do and column number one is index with that, and we will be able to access 65. Wow, great. So that is there. There are more things that are available d dot for example, columns, d dot columns, columns, it will give us what are the columns, the columns are marks and grades. There and there are other properties. And there are other several properties that we need to know Rs, for example, this there, we define this as di d dot index and stuff like so. Okay. One more thing that you need to know is we can repeat right now we have that sub D, that is this one. That's the D. Let's say we want to add another column here, just we want to add another column here. And that is the name of that column is scaled marks. And the scale marks are what if we have computed marks, rather than from 100? What if we have computed marks out of 90? What are the scaled marks up 90? So one way to do that, and very quick way to do that is just like a dictionary, again, like a dictionary, you just add a new key, let's say, scaled marks, that's a new key. and the value is simply all the marks column divided by 90. So is that true? No? divided by 90, if we have just completed all the marks by 90, and then how can we? How can we compute the marks from 90? It is rather than 100. It is from 90, I guess? How can we compute the marks from 90? If you want to compute the marks from 90, I guess they will look like and divided by 90. And maybe 100 is multiplied here. I guess maybe the formula. I guess that that that's what it is, I guess let's see. So now if you see D, there will be another column that is there. And oh, it does something else. Anyways, it does something that Yeah, so something anyways, so we see we have just, I mean, we've just computed this, we just we just found that we just inserted that column inside that I'm in, there is a process for each of these kinds of values. Maybe we have added this column in a very wrong way. And later on, we suggest that okay, we should delete that column. Well, that's very simple. Again, using the concepts again, just like the dictionaries, delete this, and this column is deleted from data. And you're again with the data that you had. So you can add columns, you can delete columns, and indexing is really fine. I mean, indexing like like masking, let's say, you want to bake for example, or you want to bake the DataFrame such that you want to pick all the records such that the marks are the marks are. The marks are greater than let's say, greater than, let's say 70. You want to pick all the records where the bulk of the marks are greater than 70. This is that simple. All the data will be will be copied into g with this condition. And this condition can be arbitrarily complex using ands and ORS and combinations and all that stuff. And you have seen this kind of stuff in NumPy as well. I mean, this is called Okay, great. So that's available in pandas as well. Okay, so that's how you can index in the next. In the next video, I'm going to basically show you one type of problem that normally happens in real data that is the missing value problem. Sometimes you read a data and some of the attributes or some of the row column p values they are just missing. I mean, they are not available due to certain reasons. How can you How can you handle those values? And how actually pandas suggest you to handle those kinds of missing values, which are sometimes called Nan values or non type values. Also, they they mostly used interchangeably in pandas. So in the next video, we are going to handle or see how to handle missing data in pandas hope to see you in the next video. Okay, in the last video, we saw data frame object. And we saw actually how to add and remove columns how to process data, how to index how to actually mask or how to apply conditions and selections in in bond as we saw that very briefly, but in this particular video, we are going to see one kind of missing value, sometimes called name or not a number, or maybe not anything or sometimes this nun type none, which is the default return type of any function. In Python. This non type is also sometimes in pandas is treated as Nan or Nan is treated as none or interchangeably. Any anything. Let me give you what do we mean by that, let's say we have two dictionaries, let's say one dictionary is a with key value a and value is one, then B and the value is two. Okay? The other dictionary is B and C. So for example, that is one record with columns A and B. So a and b are the columns. On the first record, the value of a is one, and the value of b is two. Now let's say we want to insert another record in the same data frame. Now the value of b is available in the second time, well, if b is available, which is three, and the value of c is available, which means a C column is added now. But for the value c the first row value is not available. So we will say this value is missing here. But in the second row, we have four similarly, the value of a is missing for for the second row, and that is a missing value, which is sometimes called Nam. So these are missing values. And they are typical. When you are working with data. And you're reading data on you're getting data from, from out from somewhere or large files and stuff like so. So pandas give some methods to handle these kind of these kind of I mean, this kind of situation, let's say let's say a equals PD dot data frame, data frame, again, a dictionary, let's say we have a, one and B, let's say four, that's the first row or record. The second record, let's say is another dictionary, let's say B is minus three, and C is let's say, nine. That's it. That's it. That's our data frame a. So now if you bring this a if you see the data inside a, you will see Oh, what's the problem? Is this and be heavy? Have you played something in a wrong way? Let's see. Oh, we have to create a list. That's okay, we have to create a list of it, you have to create list of dictionaries, that's the proper way of calling it. So we missed just this index list of that. Okay, right. So now we have this A, B, just call that a and this value is missing and that value is missing. And in large data files, this is typical, I mean, there are a lot of values that can be missing. One way that pandas supplies to hell these missing values is to just fill these missing values with some some fixed number for example, there is a fill na function, fill any function and let's say you supply as zero that means wherever there is a not available or not a number value, fill that with zero, or maybe any any value you want to fill that with. So that is One way to do that, and now if you see the value of a is all the non values are filled with that, another kind of function that is available in pandas that is sometimes used a that is drop na that that function drop na, what that does is it drops all the records that contain a missing value. Sometimes if that is visible, I mean dropping all the records that contain missing values, if that is visible, then go for that. But if if the if the missing values are a lot and they are spread over a lot of rows, then dropping all those kinds of records, they will create a lot of I mean data loss and and then it becomes really, really important how to how to handle these missing values. However, you can fix you can fill the missing values using fixed value or you can drop them and later on we will see in scikit learn that there are other ways of handling the missing values as well, you can fill the each column missing values in each column using an average or using for example, a regression there are ways to to handle these missing values. But in pandas, these two functions are right away they are you can fill all them with a fixed value for example or you can drop them and you are ready to go. Okay great. Next, we are going to see oh as as I mentioned earlier, what is the what is the confusion between what if there is a confusion between implicit and explicit indices. And that I will discuss in the next video basically, just to give you a look and feel what if the explicit indices you supply they are one three and five. And what if you call this this particular command one colon three, will it call the implicit index or the explicit index, that's a problem. So we will see because 1.1 colon three, one and three they are also explicit indices. And whether this one colon three is referring to the implicit indices that are default indices, or they're referring to these indices. So this confusion is there and we will see how to handle that confusion. Using this lock, LLC function and index lock ilsc function, we will see that in the next video, hope to see you in the next video. Okay, in the previous video, I mentioned a confusion that can be there, if you have supplied the explicit indices that can conflict with implicit indices. In particular, for example, if this is the series object, or maybe a data frame object if you want to if for indices, let's just think about the series object, it has these values ABC with index one three and five, if you for example, access a particular element let's say data with index one that means the explicit index for sure, but if for example, we slice the values for example, one colon three, the default behavior of slicing if you give an American disease, that is to use implicit indices, and by implicit indices, we mean by we mean that what is at index one at index one this is b, so B will be printed for example, or B will be fetched, and then you move to do which is C then C will be fetched, and these are the values that will be printed, but the behavior might be different, you might be expecting to use explicit indices, which means access one colon three, and when the explicit indices are used, the last index is also included. And in that case, you might be expecting the index one is of a so as should be printed, and index three is of B and B should be printed. And this configure might be there if if this is there. So to handle that there is there are two functions one is called l OC. And another method is called i l OC, whenever you call LLC, that means you are using explicit indices. I mean, you're forcing to use explicit index. And whenever you call, I LSE that means you're accessing elements using the implicit index what whatsoever. So let's, let's practice this and see the confusion. See the detail of this kind of confusions in in here Jupyter Notebook. So let's say we have a series object, let's say a equals PD dot series. And let's say it has values as a, b, and c, NASA value. These are the values and index as let's say One, three and five let's add these are the indices let's say this is eight Okay, let's say we access a using one that means that means the explicit index and that is this let's say B access and using the slicing operator. Now, this will use implicit indices and it will access I mean it will access these B and C because one colon three using indices implicit indices results that and we might be might be expecting that use this kind of stuff. So, if we are really interested in using explicit indices, what should we do is we should call the lat function a lock and then one colon three that means, use explicit indices there is to remove the confusions now, it will use the explicit index one and three and if for example, we are interested in using implicit indices, then it is good to use ilok function Yeah, now, one one column three is to use implicit indices and the implicit indices are like these. So, and like in series objects you can you can you can do the same in data frame objects. Once you are using lock and ilok then the further indexing inside these square brackets is exactly the same like NumPy. So, whether you use log or ILOG, the indexing mechanism is exactly that the slicing mechanism is exactly the same like, like you you you have used in in NumPy. I mean all indexing that stays the same log means you're using explicit index ILOG means you are using explicit implicit index. Let's say for example, we have our data frame, I guess D, that's our data frame available to us. Let's say I want to access d dot ilok. Let's say I want to access the second row completely the second record, oh, the record that is indexed at look at an index at two, which is a third row completely, let's say I want to access that. Now this two is acting as this two is acting as, for example, if you see the the second row or the or the row at the second index, which is a third row that is completely this edit returns that once you have used a lock, for example, and mostly people use ilok. Sometimes lock is also required. But I log is just to explicitly mentioning that I'm using I'm going to use the implicit indexing scheme. Again, you can consider hold that thing as a matrix. And once you have applied this eye lock, then you're free to play with the indices, like you play with two dimensional arrays, for example. I want to for example, I want to reverse, for example, all the rows and I want to reverse all the all the all the structure, for example, let's say I want to do that. And you can see everything is reversed. I mean all the indexing like like nine by all indexing is there in, in pandas. I mean, once you have used ilok inside is just just remember the NumPy indexing and everything like so. Okay, so that's the log and I log function. In the next video, we are actually going to going to just practice the pandas to actually to actually work on our data file that is saved as a CSV file. So we will, we will show you how to how to actually add how to actually manipulate read and write the data and play with the data, the data, the real data that is there in in some CSV file, and how pandas will help you to to manipulate the data very efficiently and very quickly. So hope to see you in the next video. Okay, in this particular video, I will be talking about real data set. The data set I have chosen just to show you some some functions that are available in pandas to work on real data set the data set I've chosen as COVID19 data set that was available on kaggle. And it's surreal data set that contains information of victims recovered the total number of recovered people in per country per province, the total number of died people and the total number of number of reported people per date available that that data is available. Let's see the look and feel of that data in a file. Just to just to see what kind of data we are talking about. Let's say this is our data. This is the serial number column that contains just the record number. That's, that's a column called observation date. That's a date, that's a province or state. That's country or region that's last updated when the record is updated was the time and how many confirmed cases were there at that date, and how many deaths at that date and how many recovered at that date, as the date is moving on and on, you will be seeing that the number of confirmed cases and the number of recovered cases they will be increasing, maybe the number of deaths they also increase. So let's see this data. Let's read that data using pandas and do some manipulation of this data and see the look and feel of that data. In Jupyter, notebook. Let's go to Jupyter Notebook and see. So first of all, I need this pandas library and pour it that maybe somewhere I need this NumPy library as well. I'm also learning a psychic learn SK learn library because I want to, I want to use impute function, just to handle the missing values, it is just more powerful to use the I'm in the SK learn library there is also a Data Science Library package that is particularly a machine learning library, or our package that actually gives a better support or a larger support of handling missing data. Although here I have used this SK learn function just for an example. And but but I could have used this data frame fill any function or something like so but I'm just using that one. Okay, after importing all these, what I did is I just call PD dot read CSV function, and I load that data and then I did this stuff one by one. Let's, let's let's spend some time on all these commands one by one. And let's see in Jupyter Notebook, what is happening, let's go to Jupyter Notebook and actually read that file and do whatever we are doing here. So first of all, import NumPy that is already imported. Import. For example, pandas that is also already imported, then from SK learn dot impute import simple impurity. So let's let's use that or let's Okay, let's do that. From SK learn dot impute SK learn dot impute import simple in pewter, okay, import that because that's a new thing, we need to import that now read the data, for example, data frame in df. So df equals PD dot read CSV. There is a CSV file read CSV. And it contains the path of the file. The path is located in my directory, it is located at this particular location COVID. And the name of that is COVID, underscore 19 ESCO data. So COVID underscore 19 underscore data dot c s v. So let's read that file, the file will be read, if you just see that some of there is a function, let's say head that gives the top records or the records that appear just the very top that's that's what the data file that I was showing you in Excel, it is showing just the first five records, I can show the first 10 Records, for example, just by calling the head function in this particular way. Okay, great. Let's say I just want to remove this real number because I think that is not required. And let's say I want to remove this particular column. Because that is also not required. There are multiple ways of doing that. I can call an t l function on this. And I can call the L function on that. But there is another way of doing that by df dot drop df dot drop and in that you just give the columns that you want to drop one column is serial number, I guess, what's the column name? That's s and No. So you want to you want to drop that column and then you want to drop this particular column with herring last update. So that is last update. So that is I guess what is there Xs one in place Drew. So Xs one is justments. Mentioning, do do that stuff with columns in place, equals true. That actually is, is telling that whatever this operation you are going to do reflect the changes in this df frame. If we do not write in place to it, we'll do everything and return onto a temporary variable or underscore variable or whatever we are saying, but the DF the data frame will stay unchanged. So in place true means do that changing in df variable itself. So now if we see df dot had flat say, it will no longer be showing us the serial number column and the last updated column. What next we can do we may we may want to rename this, this name to just date. For example, this to maybe another, let's rename all these columns, using using the Rename function, df dot rename columns equals two and then we have that dictionary again in place equals two. So let's use let's use this read in function, TF dot rename. Let's do that. And here we have columns, columns, if I spell right columns, and then that is dictionary what columns you want to change, I want to change observation date, I want to change that to simply date, let's say and I also want to change province slash state to simply simply state, our province province that say simply that and I also want to change this country slash region to simply country. So, maybe I want to change this country slash region to simply due to country cru and try country and I want all that should be happen in place. So in place equals true. So after that, if you run that, on this particular step, and now if you see the state of df, you will get like so. Okay, these many, so they province country, confirm debts, and so on. So this is much nicer form than earlier. Moreover, we may have a lot of missing values, oh, one way, this date format, the date format is not in a format that pandas internal date format. So let's convert the date format into into into the internal pandas date format, using to to PD to date time function. So let's say df date equals to PD to date time, and convert this df date in that particular format. And now if you run this TF dot had to might be seeing the date format in a different way. See that that's the that's that's the date format that the pandas is expecting. Now, we that that is just showing showing some records if you want to see more records, we can see those let's say I want to just I want to just count or let's say let's just describe all the data at TF dot describe there is a describe function that describe all most of the statistics of the data, I mean, the total count of confirmed cases are these the deaths are these recovered are these these many columns are there these many values are there. The mean is that and standard deviation is the minimum 25. And these are the statistics. Let's say there is another function info df dot d A dog info. If you call that function info, it will give us the more information about the null increase and the nominal increase and so on. For example, if you see the total number of data columns are six, the total number of records are 6162. The date increase is always available. The province entries are only 3700 available, the rest increase our null increase, so province increase most of the increase or null increase and they are there, maybe we want to drop those or maybe we want to impute those increase and stuff like so, but they are not increased that are available in the province column, some of the province, some of the province values are no longer available. Let's see that here. For example, this is not available, this is not available, this is not available. And that's what the real state of the data is this is not available, this is not available and so on. So this can happen. Okay, next, what we do is, we actually be actually use the simple computer just to impute the missing values. One ways to do that using simple mburo from SK learn. Another way is, as we already know, just df dot fill na fill na with, let's say a bit let's say not available with let's say a string, some string not available, that's it that string and with that, if you fill that fill any using that now, after that, we will be having all that data, the missing values will be filled according to Let's see some missing values because in the province there were some missing values. Now you can see for example, let me go on and left Yeah, so not available not available, we can we can use that or we can use a fancy kind of thing that is available by a psychic learn and so on. Okay, after that, if you now see the information info, now, you will not be seeing any null value, all the columns are there, oh, this was not in place. So don't fill na that is let's change the DF with it. So this doesn't happen in place, df just changed the DF. Okay, df changes. Now, if we now call the info, there is no null value anymore. Yeah. So I am this video here. In the next video, I will show you this group by command to just see these kind of stuff in a more detailed way. Because this this particular video is getting lamp here lanthier. me I'm stopping here in this particular location. Next time, I will show you the group by command in the in the panda's data frame. And I will show you what that does. So, we will explore all that code that is written here. And we will have in the in the upcoming videos when we will see the plotting and matplotlib we will be using the same data file to work more. And to get more insight how the how this pandas and matplotlib and NumPy in combination how they can actually how they can actually play a very important role in analyzing a very, very large real data files. Okay, so I end this video here. I will start the next video right from this command. And I will tell you what is happening what is the scope baikman so hope to see you in the next video. Okay, in the last video, we were discussing this COVID19 file, and we reached here but we didn't use this SK learn in pewter, we just use the fill na function of data frame. Now let's discuss this group by command or a Curie in in pandas that is much more visible. Let's say our goal is now for example, if you go to go back to Jupiter, if you see your dear df dot head, or all, at the D f dot head, let's attend records. If you want to see that there are so many records, let's just see 10. Let's see, what you want to do is you want to just see how many, how many total confirmed cases are there in each country, regardless of their date. And, for example, you want to just see all the all the all the confirmed cases, all the deaths, and all the recovered cases in each country for all the dates and for all the provinces combined together. One way to do that is to write a group by command for example. That's a df two equals df dot group by and in group by what you see is for what kind of columns you want to you want to group all these all this data. So for example, you want to group by country. country. So that's your grouping. Now after gopeng What do you want to see what kind of what kind of what kind of, for example the values you want to see because now you're dropping? Well after grouping I really Want to see because data is gone once I drop, all the dates, they are grouped together all the prevents that are grouped together. So, what I really want to see is just the country and I want to see the confirmed cases. So, pick all these records confirmed, and then I want to see deaths and recovered. So, for example, if I want to deaths, and let's say then I want to see the recovered cases are E and just I want a big group all the countries together group all these things together and add all the records under each country. So sum all of them, and maybe we want to reset any index if it is there. So for example, preset, we set index. So that So, after this Curie For example, this group by query, what will happen is this df two will contain a summary of the data with respect to each country and the total for example, in this particular country, the total confirmed cases are these all confirmed cases till now, and the deaths of these and recovered as these for this country for each country, now, each country is describing Australia for example, in our till, till now, Australia has total these confirmed cases, these total deaths, and these are recovered cases and so on. So, that is if we want to group all these with respect to country, what if we want to group all these with respect to country and then date for example. So, first we want to group them by country, so country and then for each country, display all the dates, and then do the same stuff, the the Curie will stay almost the same. A group by command will say almost the same with one kind of with one kind of let's say we want to first group by country, once the, it is grouped by the country, then I want to group them by date. And now I want to see all the results in the form of I want to see the data as well. And what will happen now is for each country, its trend with respect to all the dates that will be displayed here. So let's see df two now, df two. So if you see df two now, you can see, for example, this particular country, it has just one record in this country, it has one record, then this country for this date has this record for the same country and other date has same record and all the data is also sorted. I mean, now you can see all the records in a very incremental way. So that may give you a very good look and feel of what is happening or, for example. Another thing What if you want to what if you want to, for example, find out all the records, all the records, you just want to find out all the records? Let's do three, four, which the the confirmed cases, for example, the confirmed cases are are more than 100. Let's find out all the records. Let's, let's let's let's get just let's just pick all the records for which the confirmed cases are larger than 100. And let's copy all these records just those records in this. So if we do that, we have d3 available, and we have d3. This, I mean, these are just the records in which the confirmed cases are for sure larger than 100. Just those. Yeah, so we can do. I mean a lot of a lot of data analysis, the real data analysis, a lot of a lot more, I've just shown you a very small snapshot of what we can do with pandas on the real data set. I mean, there is a lot more that we can do with this pandas library, on real data sets on multiple data files, combining them together, joining them together, seeing their correlation, a lot of stuff. And this pandas really is a very, very fancy and very high level library, very high level package to work with data. So due to time limitations, I'm just ending this pandas here although there is much more to explain in that, but in the next video we will be jumping towards matplotlib just we will see some some functions of matplotlib. And we will see very briefly how can we plot How can we analyze data using visual graphs or stuff like so. So, that that sometimes this visualization of different attributes of the data give very good insight to the data wherever possible, wherever possible. If the visualization is possible if the data dimensionality in a way are the visualization techniques are in a way that you can visualize the trends in the data, that gives you much more much better insight than the numbers or statistical results, but it completely depends in what situation you can visualize the data there are situations, high dimensional data, for example, is not always visualizable. So, in those cases, the statistical results of the numbers may play a more important role. But in more in many cases, visualization give a very good initial insight into the data and the design process can become very, very fast if you know something about the data, whether you get that information by visualization or by other statistics or whatever. So, in the next video, I will be just explaining some very few functions of matplotlib. And then we will be, then we will be exploring the same file, and we will be doing some stuff. Doing some stuff using the plots and matplotlib. And doing, seeing the trends of death rates, seeing the trends of I mean, we'll be playing with this file a bit more using matplotlib as well. So hope to see you in the next video. Okay, in this video, I'm going to discuss matplotlib a very powerful package for plotting graphs and scatter plots, line plots and 3d plots and plots on the globe and whatnot, I mean, very, very powerful tool. The most important module in this matplotlib, or the most popular module, or the most used module is biplot. So we can import matplotlib.pi plot as PLT. Another way of writing the same kind of stuff is we can we can write like from Matt matplotlib from matplotlib import by plot as PLT. So either way is fine whether we write this as a documentation or that one that is fine as MP is for NumPy. So let's create some points, just just just make our first plot. Let's, let's make some points starting from zero, let's say all the points starting from zero till 10. And let's create 1000 points in between. One way to do that is to use built in function or a method in NumPy, which is linspace or linearly spaced points starting from zero ending at 10. And there are 1000 of those points. Let's say this is our x and this is our let's say y which is NP dot sine, the sine function is actually will apply element by element on this NumPy array. And then this PLT will plot will actually plot x comma y all the points in front of you. So let's go to Jupyter Notebook and actually see this matplotlib in running form for the very first time, oh, we have seen this matplotlib. When we saw NP dot random, we only plotted a histogram. While this is not the first time we actually have seen this once, once, once before. So import mat plot lib.pi plot as PLT. That's your import command. For example. Now PLT is available. Let's say x is NP dot Lin. space. Let's start from zero. Go to 10 and generate let's say 1000 points. That's it. That's your x, y might be your MP dot sine x. That's it. That's your y. And then what you do is you say okay, PLT dot plot, x comma y point by point, and then you press Shift, enter. That's it. Oh, this plot is there in front of you. That simple. I mean, that simple. Can you imagine? This? Is that simple? Yeah, this is that simple. So I'm in plotting. This is a line plot. For example, if we want a scatterplot, we can say okay, PLT dot scatter, there is a scatter function that allows us to plot all these endpoints form rather than rather than this line form. These are all these a lot of points. That's why you you're not seeing these scatters. So let me let me let me take this n x s viewer. Let's see. Let's take x as let's just take a few points, let's say just just just 30 points. Let's see the corresponding 30 points, see, they remember the indexing of NumPy arrays and just using that. So now use the scatter plots, and you have this, oh, that's a scatter. Maybe we want to use, let's say, start from the very beginning, due to end and big every, let's say, attempt point. And do the same with why, just to just to see a plot in a better way, just sample some points. So that's the scatterplot. It is just like I'm in the points and so on. It is not a it is not a continuous plot, like the line plot, it's a scatterplot, we're going to annotate this scatter plot, we can change these colors to any color we want. For example, we can we can have a prop property, for example, color is equal to let's say, red, and everything will become red. Yeah, so that's right, we can have I mean, we can label it we can x label it, we can via label, there are a lot of properties. But but the but the main point is plotting is that simple plotting is that quick, using matplotlib. So yeah, this matplotlib is really, really powerful, we have just seen a snapshot, just a plot function and a scatter function there, there are a lot of properties to be said, there are a lot of things to be considered. And we will see we will see actually one one lanthier good use on this COVID19 file. And we will we will actually analyze the data trends and the confirmed trends and some trends that and we will plot them and see the trends really using matplotlib. So But before that, let me let me show you that. If you call for if you call this plot multiple times, for example, maybe with different colors, then you will be having a lot of curves on the same on the same plot, for example. So for example, let's see PLT dot plot x comma y, let's say with with color, let's say color equals to blue. You can write blue, the whole or you can like write just be that's fine PLT dot plot, x, and let's say NP dot cause x and the color you are interested in, and let's say the color is, let's say green. And that's perfectly okay. And that will give you two plots in the same figure, sort of, and you can just good to go. Well, yeah, so that more you can, for example, you can plot with a green, green color, and you want the solid line, or you want, for example, Seon color in a dashed line, or you want a dash and dot black line or, or maybe you want to completely dotted line in red color. So there are several things that are available in matplotlib. This is just a very few very simple snapshot. And I have given you a very quick start in and actually actually the whole point is using Matlab is that quick, I mean, you can you have your data, you just plug in their data, you just call the plot function, and you're good to go for analysis. Okay. In the next video, we are where we will actually walk through the we will actually walk through the COVID19 data set. And we'll actually analyze the trends and to add the death rate transfer each country individually, and then we will see the depth confirmed and the recovery trend of the overall world till the 16th of March till the day till the data data is available. So next video will be actually the viewer will see the running form of pandas and matplotlib. Together, so hope to see you in the next video. Okay, I already have shown you the COVID19 file. And here I have a notebook on that that uses matplotlib and pandas to find out the depths conformations and recovery trends using using different plots. So let me import all the packages that I need. I need a plot by plot function from matplotlib. I need pandas somewhere I need NumPy. And I'm using a simple mburo here for missing values. So let's run this. Let's run this command. And yes, everything is imported. Now let's load the data that I've shown you earlier. The data is available now. And let's run this thing that is the first 50 Records. Yeah, remember that? Yeah, so that's the data that is available if if you just want another view another view of the data That's the data file, which is COVID19 file. And it has observation day province country, last update, confirm, to date, death to date and recover to date for each country and for each province individually. Okay, great. So that's what we have. Now what we can do is, now let's drop the serial numbers and last update using in place that and rename the columns that we did already in a previous video as well. Let's convert the date into the pandas built in date, frame. Okay, let's use the psychic learn in pewter, sk learn in pewter, using the constant strategy, there are a lot of strategies there, let's use a constant strategy. And this period or data frame, in pure dot fit transform that will help imputing all the missing values with a constant strategy impure. So that's there. Okay, next, let's apply this group by command and group all of all the records using country for each country. And for all the dates, let's sum all the records that sum all the values of records deaths and confirms using this, but now let's first country and then all it state, then the second country, then all it states and so on. We have seen that in one of our previous videos just running that again, just for a double check. So that's what the data state is. So country one all it states country to all it states. So this country has a lot of dates, then another country and so on. Next, let's see how many countries are there. In total, how many unique countries are there. So what I, what I do is I find the column, I actually pick the column with country and call a unique function on that. And that gives me all the countries without repetition. And I just compute the length length of countries tell me how many unique countries are there in this data file? There are 171 countries. So now my goal is for each country, I want to see what is the trend of with respect to the date as the data is moving from the first day till 16th of March? What is the trend of death? patients? What is the trend of recovered patients and what is a trend of confirmed patients as the data moves on. So because we have 171 countries, so let's loop over each country again, again, and again, let's loop over what we do is for ID x in the range of this, that's the loop you remember that. And what I do is let's find out the indices where the country is like this, let's find out the index all the indices where the country is like that. Then what do you do I make a scatterplot. That, with starting from this, and that, I just pick the confirmed cases and all the confirmed cases for this one country, I just pick those. And I look, I do that using this scatterplot, then I use another scatter plot, just to get all the recovered cases, then I do another scatter plot to get all the depth cases. And then the title of the title of my figure becomes the country name, the x labels the days, days since the first suspect, the wire label is the total number of cases, the legend command actually will be there that will show what eat that is in. So these kinds of labels that are rewriting here, they will appear in the figure, then we force them to show that in each iteration show the show the fourth. So this will show the trends of confirms to cover some deaths for all 171 countries one by one. So if we run this command, we'll be having 171 plots in front of us. Let's see all of those one by one. So yeah, so this is for the country. It has just one such thing. This is for that this is for Afghanistan. As these moves on the confirmed cases that are even blue, they are moving up. These are the number of cases. These are the number of days since the first day. And the green is the number of recovered cases for Albania. That's the trend for Algeria. That's the trend. I mean, these are each and everything is a separate that is for Argentina. That is for America. This is for America till 16th March, by the way, today. The new says that America is really in as dangerous position anyways, that's for Australia till till the date we have to do that is for Austria. Yeah, so these are all the trends for all the countries. You see I'm in the matplotlib how powerful that is. Although I walked through this code very quickly, but you can see this video again and again. And then check how that happens. Yeah. So that's what this is for Finland. Oh, Finland is also in trouble. So France. Okay. So that is for Germany. And yeah, so all the countries that are available in data set, they have these kind of plots. This is for Hong Kong. And this is for India. And this is for Italy's or Italy's. Yeah. So that's it. So that is for each country individually, what if we want the overall trend, or the overall confirm and the deaths and the recover trend for all the world together, so what I do is I big I grew up all the data with date. So I pick the first date, and add all the records, then the second date for all the records for all the countries and so on. And then I plot the trend using the scatterplot, again, confirmed record. And that's for all over the world and see the trend, where the world is moving. So that's the trend of the world. As the days are going on, these are the depth grand, that's a recovery trend. And that's a confirmation trend that is moving on. Although I walked through or this notebook, the notebook will be available to you. I walk over this notebook very quickly. But the goal was really to show you the the I mean, that was a file may not be that informative, if you see that in Excel, but now it makes much more sense. When you see these blobs you know what is happening and you have insight in the data. And later on, we may we may want to predict we may want to make predictions. And the next date what is going to happen, we may want to predict using this plot or using some Machine Learning Library like psychic learn or TensorFlow or something like that. Okay, so that's it. I can talk much more about pandas NumPy matplotlib of there are so many other data science packages, very important packages, one of those is SK learn, we can that is for machine learning basic machine learning. Then there are other packages like TensorFlow for deep learning by torch for deep learning. There are a lot of packages with a lot of speciality is in data science and stuff. I just discussed a few of those the most important of those do to manipulate the data to make predictions to make classification or regressions. For one, one way is to go to SK learn or psychic learn. And if the data is huge, and you have a lot of large amount of data, and you have good expertise or deep learning, then you should go to either TensorFlow or pytorch these are the Python packages that are available for predictions, classification, regression and a lot more, but either way, whether you are going to use scikit learn whether you're going to use TensorFlow or pytorch either way, you have to use pandas NumPy and sometimes matplotlib to pre process the data and to make the data ready for for these kind of libraries to to perform predictions, either a either in the form of classification or in the form of regression. So so so this whole course was about for for beginners who want to who want to learn Python, specifically, I discussed a lot about the in a lot about Python in general, then then then I spend some time not a lot amount of time sometimes on exploring the data science packages as well. But, I mean, there is no end we can explore more, we can talk about the packages more we can talk about other features of Python more, a lot of I mean, input formatting, output formatting, modules, packages, standard template library, file handling Internet Access database, I mean, this is a whole universe, I have discussed a few things for beginners. But But these few things were very carefully selected for data scientists. The if you have this course available to you as you have gone through all the course, you now have a very very good understanding and now you can you can move towards further edit advanced courses towards data science and you will be ready to implement the concepts in Python using using the packages I have discussed so far. So I thank you all and good luck.
