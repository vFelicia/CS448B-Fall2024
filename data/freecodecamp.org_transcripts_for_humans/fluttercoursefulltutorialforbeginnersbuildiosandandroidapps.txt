With timestamps:

00:00 - Hey, everyone, my name is Nick Manning. And 
I'm a flutter engineer. So I create flutter  
00:06 - apps in my free time. And I kind of also create 
tutorial videos about it. So I am the creator  
00:13 - of flutter Crash Course calm. Thanks very much to 
free code camp.org for sponsoring this video. And  
00:20 - let's get started. Hey, everyone, my name is Nick 
Manning. And this is my flutter Crash Course. So  
00:31 - I'm really excited to offer this to you because 
I've taken about six or eight months of filming  
00:36 - and content creation. And I've boiled it down into 
this course. And what it's meant to do is save you  
00:43 - time learning flutter. So what you see here is my 
show notes. And as every video I'm going to do,  
00:50 - I'm going to walk through my show notes, so you 
can read along and take notes on your own. And in  
00:56 - terms of my background, I've been writing software 
for about 20 years, five of those as an iOS  
01:02 - engineer. So to follow along, some of you might 
not want to follow along, you just want to watch,  
01:08 - that's fine. But you're going to need everything 
that the flutter website said, so any kind of  
01:13 - main operating system, popular operating system, 
latest version of flutter, and an iOS simulator or  
01:20 - Android emulator, so make sure you have that 
installed and all set up. So if you want to,  
01:25 - if you don't know how to set that up, you're 
having problems, you can go to my website or the  
01:31 - YouTube channel that I have. And I have specific 
videos on how to set up flutter, step by step for  
01:37 - Windows and OSX. So experience level required. 
So you need to have experience with one existing  
01:46 - programming language. And also you something that 
you've coded like a website or a web app, or even  
01:53 - a mobile app, you don't need to but something that 
you've done in the past. So that you know some  
01:57 - basic programming, you have some basic programming 
skills. So let's get started here. Um, if you want  
02:04 - to, again, go see other videos, check out flutter 
Crash Course calm, but we're gonna now start our  
02:10 - first lesson, which is chapter one, which is 
creating a basic screen. So stay tuned. Hey,  
02:17 - everyone. So in this lesson, we're going to cover 
layout in flutter. So we're going to be using a  
02:22 - widget called column. And what column does its 
lets us layout widgets from top to bottom. So let  
02:29 - me show you what we're going to be eventually 
coding. This is the location detail screen of  
02:36 - our app. It's called the tourism co app. And the 
location Details screen shows a number of things.  
02:41 - And you can tell that we can use this column 
widget because things are widgets here are laid  
02:49 - out from top to bottom. So there's another widget 
called a row and row lets you lay out stuff from  
02:54 - left to right, for example. So but you're pretty 
much most of the time going to use this column  
02:59 - widget because a lot of content on a mobile app 
is all is is a column style, layout. So in this  
03:10 - video, we're going to cover implementing three 
text sections. So text sections, let us define  
03:17 - the area for let's say, let's say we want to show 
summary and then this snippet of text, that's what  
03:23 - a text section will be. So let's get coding on. So 
last time we have this, we left off with this home  
03:30 - page. And we're going to rename it to location 
detail. So let's do that really quick. and name  
03:38 - this directory location detail because that's the 
convention of the code order organization we're  
03:44 - going to use. So we have a number of screens, 
and each directory is the name of the screen,  
03:49 - and then the name of the file, the main file 
that defines that screen is also that name.  
03:56 - So let's define that. And I'm going to now stop 
my app and restarted I can't use the hot reload  
04:03 - because I am changing the file name. So sometimes 
we can't use hot reload. So while that's starting,  
04:11 - let's go over column. So I'm gonna render three 
tech sections. But now I'm not going to just  
04:18 - display text, I'm going to display colored boxes. 
So colored boxes are going to show us how that  
04:24 - content is that the bounding areas for each piece 
of content. So one way we can define a colored box  
04:33 - is using a widget in flutter called container. 
So container is kind of like the div of flutter.  
04:41 - It's a div in HTML is just a bounding area that's 
flexible, you have different parameters you can  
04:48 - define. One of those parameters is color. So I can 
just say container and define some color I can use  
04:56 - a property called decoration so There's different 
types of decorations. One is a box decoration,  
05:03 - that's just a generic way to define a box, some 
sort, and I can style that box using the color  
05:11 - parameter. So I'm going to say color. And I'm 
gonna say colors dot red. So this in Dart means  
05:19 - colors that red, red is a static member, meaning 
you don't need to instantiate the colors class to  
05:26 - refer to it. So that's why you have class name, 
dot and then the value here. So lastly, container  
05:34 - will take a child. So we're gonna say child text, 
and then whatever. And then we're gonna save it.  
05:42 - And one thing we didn't do is define our column 
forgot to do that. So column has a parameter  
05:51 - called children and children is an a, it's a list, 
it's not a single widget. So and it is a list  
06:01 - because you can have multiple items in your list. 
So we're going to find three containers here. So  
06:09 - I'm going to just copy and paste this, and one's 
going to be read, one's going to have background  
06:14 - of green, and we're going to is going to have 
a background on blue. Now, nothing's happening  
06:19 - here. Because we want to define some parameters 
here, I can define some texts, that's fine, I'll  
06:26 - just do that real quick. But, you know, look at 
the screen, I mean, nothing really is happening.  
06:34 - That's interesting. It's just the finding these 
little tiny boxes here, you can't even see the  
06:39 - text. So what I want to do is define something 
called main axis alignment. And what main axis  
06:46 - alignment does is, it lets us control how each 
child is vertically spaced on the screen or  
06:54 - how it's laid out. And when I say vertically, for 
column, it's vertically. So main axis is something  
07:02 - generic. So I'll take a step back. So main axis is 
the main axis of the widget that you're using. So  
07:09 - if you're using a column, the main axis will be a 
vertical line on the screen from top to bottom. If  
07:15 - you're using the row widget, the main axis will be 
a horizontal line from left to right. So the main  
07:22 - axis says something that's loosely defined, and it 
depends on the widget that you're using. So So the  
07:29 - main axis alignment controls how content is laid 
out on from top to bottom, I have the following  
07:35 - options, I have space evenly. So let's try that. 
I'll just go ahead. And you'll see that the each  
07:44 - box is spaced evenly on the screen. Pretty simple. 
I can also say let's say end. So if I say end,  
07:53 - each item will be rendered from the very bottom of 
my column, and column occupies the entire screen.  
08:01 - There's other options I don't need to cover right 
now. But the most common one is start. So we're  
08:08 - going to stick to that. The second parameter for 
column or row, we're not going to cover row in  
08:14 - this video, but it's also a parameter for row is 
cross axis alignment. And cross axis alignment is  
08:21 - the exact opposite of the main axis. It's the 
kind of the kind of virtual horizontal line on  
08:33 - the screen. So if the main axis goes from top to 
bottom, the cross axis goes from left to right on  
08:38 - the screen. And let me show you what options you 
have here. So I have cross axis axis alignment,  
08:42 - baseline center and start stretch. So we're 
not going to cover all of these, but one of  
08:48 - the most common ones is stretch. So it's making 
sure that each item of my column is stretched  
08:55 - from left to right. So let's save that. And I'll 
show you now each item is stretched from left to  
09:02 - right. And cool. Um, that's it. So this code looks 
pretty ugly. But at least we have some containers  
09:11 - where we can store text. So once we do continue on 
implementing this screen will have a nice bounding  
09:18 - area. And content will flow nicely from top to 
bottom. And it'll also be stretched. So let's  
09:25 - clean up the code. That's the last step of this 
video. And since these are reusable kind of pieces  
09:32 - of code here, we're going to make this into a 
widget. So I'm going to take the template of  
09:39 - this file, like all the import the class here, the 
build method, and I'm going to copy it, and I'm  
09:45 - going to create a new file called text section. 
So the reason why we're defining the file here  
09:51 - in the location detail screen is because we're 
not going to reuse this widget. We're going to  
09:56 - define it anywhere else in the app so we can keep 
it local to this screen, it's going to paste this  
10:01 - in. And we have a nice template for our stateless 
widget we're going to build, which is defining a  
10:07 - text section, I'm going to name it like that. And 
then in the location Details screen, I can copy or  
10:15 - cut the content we want to show. And I'm going 
to say container. And I'm going to say returned  
10:22 - here. And now we can just update this. So we can 
say text section. And we can define, let's say,  
10:31 - let's say three of these later, it's going to be 
dynamic based on the types of text sections that  
10:36 - we have. But for now, we'll just define a finite 
list. And we're going to say import text section.  
10:43 - Cool. So this defines three red boxes pretty 
useless. So what we want to be able to do is for  
10:53 - now customize the background color, even though 
we're not going to use it. In our final screen,  
10:58 - this background color property, I just want to 
show you how you can define parameters. So how  
11:04 - to parameterize, a stateless widget or really any 
widget. So if we want to pass in a color, first  
11:12 - off, I define a private member, private, meaning 
it shouldn't be accessed outside of this widget,  
11:20 - it's just something that this widget should know 
about. And to do that, I say the type of member  
11:26 - it is, which is a color. And I have an underscore 
for the name of the member because that underscore  
11:33 - means that it's going to be private. So I'm going 
to say color. And to customize it, I'm going to  
11:40 - create a custom constructor. So a constructor, 
lets me customize how I instantiate this class.  
11:46 - So I'm going to say text section, because that's 
the name of the class. This is how you define a  
11:51 - constructor. And well, what I could do is there's 
there's two types of parameters for constructors,  
11:59 - there's in Dart, there's optional parameters, 
and there's named parameters. So option optional  
12:08 - names, ones and positional sorry. So we're going 
to find to keep it simple positional parameters,  
12:14 - meaning, if I say color, here, you know, we 
all will basically how we use it is in location  
12:24 - detail, I'm going to say colors, red, colors, 
green, colors, that blue. And it's positional  
12:33 - meaning based on the, you know, this is the first 
argument, it knows that it's going associated  
12:39 - with this parameter simple. And then I could say 
this dot underscore, color equals color. So this  
12:45 - means it's kind of like same thing in JavaScript, 
where this means it's referring to the instance  
12:51 - of this class. So I'm going to say this underscore 
color, and it's going to give me the value of that  
12:57 - parameter, it's going to assign it to that. So in 
Dart, there's a shortcut to this, this positional  
13:03 - parameter. And I don't have to define the method 
body here, I can just say, this dot underscore  
13:11 - color. And what that does is, for a positional 
parameter, it's going to take that value, and it's  
13:18 - just going to automatically make an assignment 
to the member here, this value. So whatever,  
13:24 - I pass it as the first argument here, it's going 
to assign immediately to this color. So that's  
13:30 - pretty cool. So finally, we're going to refer 
to our member here. So it's customized, we're  
13:36 - going to hit save. And let's see what happens 
here. Cool, it worked. Um, what else we want  
13:48 - to cover? Yeah, that's a bummer. I mean, the last 
thing that you should do is, say that this private  
13:54 - number is final. And what final means is that once 
you set it, you can't change it. And that's really  
14:01 - nice, because it makes anyone reading the code, 
know that they shouldn't change it, they can't,  
14:06 - because the compiler will give you an error. And 
we don't need to change it after that assignments  
14:12 - been made. So I just see final here. And that's 
just like a best practice. So that's it. Later,  
14:19 - we're going to add some real text, we're going to 
style it. We're going to see now how the layout  
14:25 - is is defining how the text is constrained. 
But for now, it's pretty simple. And I hope  
14:32 - you have a good idea of main axis lamb and cross 
axis alignment. And if you want to do like some  
14:39 - bonus work, changes to a row and try that out, 
or play with the different options you have here.  
14:46 - So let's continue on. Hey, everyone. So in this 
video, we're going to cover how to add images to  
14:53 - your app, and it's pretty simple. There's two main 
ways to do it. One is to use an image asset or A  
14:59 - URL of an image. So in this video, we're going to 
first import an actual image asset, like a file,  
15:06 - like a JPEG file to our app, and we're going 
to include it in our pub spec yamo file,  
15:13 - and then we're going to implement it. Later, we're 
going to pull the image from a URL. So this should  
15:19 - be pretty simple. But we're going to cover 
some things you probably don't know about yet,  
15:23 - like constraints and how to layout the image. 
So in the last video, we covered layout,  
15:30 - let's just kind of cover what we're review what 
we're gonna go over and implement in the whole  
15:38 - video series. So it's this detail page with a nice 
banner image at the top and some text sections. So  
15:45 - what we've done is we've laid the groundwork for 
the text sessions, we it just shows some lines,  
15:50 - which we will implement in the next video with 
the text and all the formatting. But for now,  
15:57 - let's add an image to the top and keep it simple. 
So to add an image of, we're going to be basically  
16:05 - going through the blog post for this video. So if 
you want to look at the notes, I will be showing  
16:11 - the notes as we go along. So you can read along, 
we're going to create a new directory called  
16:17 - assets, images. So assets is anything like font 
files, images, anything of that sort, and they're  
16:25 - all going to be in one directory. So that's how 
we're going to organize things. And we're going to  
16:29 - use JPEGs. And yeah, that's it. So you can follow 
along if you want to check out this branch of the  
16:37 - code, or you can code from step two on your own. 
So what I'm going to do is off to the side, here,  
16:45 - I have an image already that I'm going to copy 
and the image are going to copy, if you check out  
16:50 - step three of the code, anything from step three 
onward has this image. So I'm just going to copy  
16:58 - it here. And it's off screen here, you're not 
going to see it. But I'm going to copy it to  
17:04 - the following directories. So in my code, here, I 
have my main root directory. So I'm going to hit  
17:13 - this button at the top New Folder. And I'm going 
to create a new folder in the root of the project  
17:18 - called assets. Oops, let me move here. So assets 
is going to be alongside the Android directory  
17:28 - and the iOS directory. And then I'm going to 
create a new folder called images. And we'll  
17:33 - have other folders there later. And then I'm off 
in the video, I'm going to in another screen here,  
17:41 - I'm just copying the actual actual image file. 
So I'm getting it from my code on branch on the  
17:50 - branch that I have at the repo, the link to the 
repo is here in the blog post. And it's in step  
17:58 - three. So I've already copied it, and let me show 
you the fact that it is copied. So since this is a  
18:04 - tourism app, it's going to be of all Japanese 
locations, just I just decided to pick that  
18:10 - randomly. So this is a location in Japan, and this 
is the image file. So later, we're going to load  
18:16 - it from a server. So now that I have my images 
there, I can't just use it straight away, I have  
18:21 - to go into my pub spec yamo file. And let me hide 
the code here. And so the pub spec yamo file is  
18:30 - like a configuration for your project. It's in the 
root of the project, could see the filename there,  
18:36 - and you get to list like what packages you're 
going to use and all of that. We haven't added  
18:43 - any packages yet. We'll get to that in another 
video. But if you scroll down here, you'll see  
18:49 - that there's some example configurations you can 
enable. So in Dart to comment something out there,  
18:56 - they use this pound symbol, right, this number 
symbol here. So if you just comment it out,  
19:02 - you'll actually be able to use that config. And so 
the important part is to configure this correctly,  
19:09 - so that'll work or else. If the formatting is 
messed up, it may not work. So what we're gonna  
19:15 - do is say, it says here in the description to add 
assets to your application, add an assets section.  
19:22 - So we have to have this line here and it has to 
be indented properly. So the parent of this is  
19:28 - flutter. And then assets is here. So it's indented 
by it's indented here. So like that you can't do  
19:37 - this has to be like this. And then we're not going 
to include specific images, we're going to just  
19:43 - include the entire directory. So we're going 
to say, for all the assets we're using, we're  
19:48 - going to say what the path to the actual images 
directory is and then that is assets slash images,  
19:56 - and then make sure to include the slash at the 
end. That way, flutter knows that you can include  
20:03 - all the images there. So it's going to look like 
this. This is the blog post, you can see a note,  
20:09 - we're going to want it looking like this. Another 
gotcha is you want to make sure that this is  
20:14 - indented as well. So the actual directive here 
is indented properly. So we're gonna save that.  
20:21 - And then let's implement the actual image. So 
let's see, we have the code here. So last time,  
20:29 - we have our we had our location detail 
screen. So this location detail screen,  
20:34 - had just three text sections, we're going to 
fill that out in the next video, what we're  
20:39 - going to want to do is add an actual image banner 
at the top of the screen. So it's going to be one  
20:45 - of our children of our column. So let's add that 
now. Let me look at what we want to do here. So  
20:53 - because we want this to be its own widget, we're 
going to create a new widget the same way we'd  
20:59 - like we created the text section widget. So I'm 
going to call this new widget, image banner. So  
21:06 - this is an image widget we're going to create in 
just a second. And before we have an implemented,  
21:12 - we're going to just code what, how we want to 
customize it. So what do we want to pass in to  
21:19 - the instantiation of this widget, which is only 
in basically the file name. So that's what we're  
21:25 - gonna do, we're gonna say, include the path to the 
image. So we're gonna say assets, slash images,  
21:31 - slash, and then the name of the file. It's kind 
of weird, because it's Japanese, of course. So if  
21:38 - you don't speak Japanese, it'll look weird to you. 
But that's the name of the file. That's the name,  
21:42 - that's going to be the name of our location 
when we show the text corresponding text with  
21:48 - that image. And know that later, we're going 
to change this app to be dynamic. So we're  
21:53 - not going to hard code the image, we're going to 
pull it from a web service API, right? For now,  
21:59 - we're just going to hard code it just get it to 
work. So next, we're going to include the widget  
22:06 - that we haven't even implemented yet. And I'm just 
doing this for brevity here. So I'm going to say  
22:12 - image underscore banner. So that's going to be the 
name of the file we're about to create. Remember  
22:17 - that in darts, if you don't know already, the 
the the input should be in alphabetical order.  
22:23 - So I'm going to make sure that this is before this 
and that it's underlined red, because we haven't  
22:30 - created it yet. So let's create it. Now, we're 
going to go into our location detail folder here.  
22:35 - And because this widget is only going to be used 
by location detail, we're not going to have it  
22:42 - live anywhere else. It's a widget that's local to 
location detail. If it was shared across the app,  
22:47 - we would put it in a separate place. So let's 
call the Let's name the file the same name of  
22:54 - the widget, image, underscore banner, and 
make sure it's all lowercase. And then,  
22:59 - since this is a stateless widget, and we're going 
to implement it much like we did the text section  
23:06 - widget we did in the last video, so I'm just going 
to copy this code here, just as a template. And  
23:13 - note that Visual Studio Code also gives you some 
options. And there's extensions to kind of use a  
23:19 - hotkey to auto generate a stateless widget really 
quickly. But that's not what we're not going to  
23:25 - cover that that's something more advanced. So 
let's name it to our image banner. And this is  
23:32 - the name of our widget here. And we're not going 
to want to customize the color. But what we're  
23:39 - going to do is be able to customize the path to 
the asset. So we're going to have a private member  
23:46 - here. And it's going to be a string called asset 
path. So it's private, again, because there's an  
23:53 - underscore here. Second, we're going to pass in 
asset path. So this is going to be a positional  
24:03 - parameter to our constructor. So that means 
that when the person wants to use this widget,  
24:09 - the first argument they provide to the constructor 
will be the asset path. And this Dart I if you  
24:17 - didn't follow this in the last video, when we use 
this positional parameter, and we use this dot,  
24:23 - and then the name of our private member, it 
automatically assigns the value. So really quick,  
24:30 - if you didn't see it last time, if we just have 
something like this, this would be the long way  
24:35 - of doing it. So this acid pass acid pack. So 
this is kind of the the long way of doing it,  
24:44 - but we can't work. This is just better to do it 
this way. So let's implement our image banner  
24:52 - now. So what we're going to do is we're going to 
display use the flutter widget, the image widget,  
24:59 - but we're going to wrap it In a container, what 
that allows us to do is provide some options,  
25:04 - other options like padding, or the height, and all 
that. So you're going to want to wrap your images  
25:10 - in a container or some other widget like that. So 
let's get started on that. So there's going to be  
25:21 - if you look at the screenshot, there's going 
to be a certain height to the image. So we're  
25:25 - going to want to expand the image all the way from 
to the maximum, we can go in the container, but  
25:33 - we want to still constrain the container of the 
image to a specific height. And to do that, we're  
25:39 - going to use something called constraints. And 
that's a parameter on the container widget. And  
25:44 - much like decoration that, you know, there's also 
something called You know, there's box decoration.  
25:51 - But there's also box constraints. And what 
box constraints does is it lets us provide all  
25:56 - these other options for how it the content in that 
container is constrained. So the most common names  
26:06 - constructor for this is called expand. And what 
that does is it says, Let me expand everything,  
26:13 - all the content in my container, as long as the 
height stays at 200 pixels. So to specify the  
26:21 - height in flutter, or Dart, we're going to use 
a double and a double is a certain data type,  
26:26 - you can see it here, that just basically it has 
a decimal point, that's all, that's all you have  
26:31 - to know. So if you can say 200, like this, but 
sometimes the Visual Studio code will give you  
26:39 - a warning, you can also do like this, but using a 
decimal, like a proper decimal, even if it's not  
26:43 - zero is probably better. And that's constraint. 
So that's what we'll see how it works in a second,  
26:50 - but constraints is going to say, expand 
all the content until the height is 200,  
26:55 - we're going to have a decoration. And we're going 
to give it a decoration of a background color.  
27:01 - We've already covered this in the other video, 
where you just say gray here. The reason why we're  
27:06 - giving the container a background color is because 
later when we loaded as a from a URL, if that URL  
27:12 - fails to load the image, we still want to show 
some kind of placeholder, not just whitespace. So  
27:18 - that's just the decision I made. You don't have to 
do that. So the child now is going to be the image  
27:25 - widget. So we just say image. And to use the image 
widget, we're gonna use also a named constructor.  
27:34 - And remember, a named constructor is goes like the 
name of the widget, and then dot and then the name  
27:40 - of that constructor. So there's, as you can see, 
here, there's different ways to name the use that  
27:47 - different names with constructors, you can use. 
One of them's asset, which we're going to use,  
27:52 - there's also file memory and network. So we'll use 
network later. But let's use asset for now that's  
27:58 - basically taking any asset you've specified 
in your postbit camel file. So we can now  
28:05 - just provide it the name of the asset path. So 
I'm gonna say asset path. And the last thing we  
28:11 - want to cover in this video, last main thing 
is how image wants to expand and behave based  
28:17 - on the screen size or the container that it's in 
so much like HTML or CSS, you can specify how it  
28:25 - expands and all that. And the way you do that in 
flutter is we use this fits parameter. And we use  
28:32 - this kind of value called box fit cover. So box 
fit, like box decoration box can constraints. Box  
28:44 - fit gives you additional options like that. 
So, fit height fit with cover fill contain,  
28:50 - you can use these in your free time and click into 
them and read about them in the documentation. The  
28:57 - documentation will explain how to use these but 
in this video, we're just going to use a cover and  
29:04 - cover does is it fills the image all the way as 
much as it can within the container that it's in.  
29:09 - Cool, they have something similar in CSS as well. 
So let's save this. There's some syntax error. So  
29:18 - we're going to make sure that we have the image 
asset finished here. And then the container  
29:23 - finished and let's see what else we didn't, okay, 
like go like this. Make sure this is finished. And  
29:34 - what else I need a semicolon here. That's what it 
was the semicolon. So I'm going to restart it. And  
29:43 - there we go, the image loads and it's exactly 
200 pixels high. And now we can get started on  
29:49 - the text of our app. So that was the tutorial 
here. And again, if you want to read through  
29:56 - the blog post, it has all the code And you can 
read through it in your free time. And yeah,  
30:04 - that's it. So thanks for watching. Hey, everyone. 
So in this video, we're going to be covering how  
30:09 - to use custom fonts and flutter. And we're going 
to be building out our screen here, where we  
30:15 - already added the image at the top. And we're 
going to start adding text sections here. So a  
30:20 - tech section will have, as you see here, where it 
says summary, it'll have a title, and it'll have  
30:25 - a body. So we're going to implement that widget. 
And then we're finally going to cover text theming  
30:30 - and flutter. So text steaming allows you to define 
all your style in one place for different types of  
30:36 - elements in your app. And then that way your code 
is very clean, because it knows what kind of style  
30:42 - to pull from. So let's get started. If you want 
to follow along, I have the blog post here. And  
30:48 - to get the font files that we're going to be using 
the those font assets, simply checkout step slash  
30:56 - step 04 branch of this, the code repository, 
and the link is in the blog post. So let's get  
31:04 - started. Um, we're going to implement first, 
we're not going to quite follow step by step  
31:09 - the blog post in the blog posts order, we're just 
going to implement the actual text section first,  
31:16 - because then I can apply the font and it'll just 
look like nicer and be more understandable. So the  
31:25 - first thing we're going to do is implement more 
features of this text section. Because right now,  
31:30 - it's very contrived, it just shows colors, that's 
it, well, we want to do is remove this color,  
31:35 - and be able to show a title and a body. So 
let's implement that now. So instead of color,  
31:43 - we're going to implement two private members, one 
is title, and one is body, we're going to update  
31:49 - the constructor. And this, so this dot body, so 
whatever you pass it in pass in here as positional  
32:01 - parameters will be assigned to these members. And 
then let's basically define how we want our widget  
32:11 - to be structured. So this, each widget can have 
its own layout. So in the location detail screen,  
32:18 - we do use something called a column, we already 
covered that in the layout, video, but each text  
32:25 - section will have its own column, because content 
is laid out from top to bottom in a column format.  
32:32 - So it's going to be summary and then this 
body of text. So instead of container here,  
32:37 - let's implement a column, and it's going to be 
its own column, main axis alignment is going  
32:44 - to be start meaning the each child is going to 
be laid out from top to bottom, sequentially  
32:52 - without any pattern, cross axis alignment will be 
stretch. So I wanted to stretch to the full width  
32:58 - of the container. What we're going to do is remove 
decoration, we don't need that. And for child,  
33:04 - I'm going to have some text here. Well, we have to 
say children, because it's going to be a column,  
33:12 - and it's going to be a list of items here. And 
we're just gonna have title, and then the other  
33:19 - one is body. Then we're going to end our column. 
Nope, we already did here, and and our children  
33:29 - here, hit save. And then we're going to there's 
an error, because we have to update our location  
33:34 - detail screen to use that. So we already have text 
section imported here, we don't need to do that.  
33:39 - And now we're just going to say, well, hard codes 
and values in here. So we're gonna say summary,  
33:46 - something one, and then something to something 
three. So later, we're going to make all this  
33:55 - text dynamic, it's going to pull from a web server 
API, web API running on a web server somewhere.  
34:00 - And it we're not going to hard code anything 
like the image names and all that. So cool,  
34:06 - it looks really boring, because there's no 
formatting to it. So let's cover that next.  
34:11 - First thing we want to do is add padding to each 
of our widgets. So to add padding to each text,  
34:19 - bit of text here, we're going to wrap each text 
widget in a container widget. The container  
34:26 - widget lets us define that, that the text 
doesn't. So to add padding to a container,  
34:31 - because we want to control the different padding 
schemes, so we want to control padding on the left  
34:38 - and right and the top and bottom and it's going 
to be different for each we're going to say const  
34:43 - which is a constant edge in sets. And then from 
lt RB so that's a special named constructor for  
34:52 - edge in sets and lets you granularly define all 
that padding. So because this each day This text  
35:00 - section widget is going to share the same left and 
right padding, I'm going to for simplicity's sake  
35:06 - define a constant up here. And it's, well, it's, 
it's going to be a static constant. And I'll get  
35:15 - to that why it has to be static in a second. But 
we're gonna call it horizontal padding. And for  
35:20 - just brevity, because I use the slot, I'm going 
to say h pad. And people usually will figure out  
35:26 - what that means. The reason why it's static is 
because since I'm using a const, here, it just  
35:32 - has to be static. I can't I can't, you see, if I 
remove it here, I can't define a constant as a as  
35:39 - a member of a class here, it has to be static. And 
that's just the rules of Dart. So for the left and  
35:47 - the right padding, it's going to have that value. 
For the top and the bottom, I'm just going to use  
35:52 - a custom values and then use 32. And four, you 
don't really need to specify the decimal point,  
35:59 - but I just like to because it's a double and just 
more consistent that way. So then we define the  
36:06 - padding here, I'm going to end let's see text 
and and my container. And then I'm going to add,  
36:14 - let me add my child. And then I'm going to add 
the other container. And it's just going to have  
36:20 - different padding because of because of the fact 
that it's a just based on the design of the app,  
36:26 - it's going to have different type of padding. 
So that padding will be let me look at my notes,  
36:32 - it's going to be 10. And just use the same value 
as horizontal padding here. Save it. So cool. Now  
36:40 - we have the things like nicely padded, and I'll 
add some more text here. So you could see it like  
36:49 - kind of looking a little more realistic. In the 
next video, we're going to add in real text here.  
36:54 - So let me just paste that in. Cool. So that's just 
really, really ugly looking text. But it shows you  
37:03 - that it's going to flow nicely and the padding 
looks okay. Okay, so let's cover the style of  
37:10 - the app. Before we do that though, the style that 
we're going to implement uses a custom font. And  
37:15 - so we can implement that style without it failing 
until we add our font file. So let's go add a  
37:23 - custom font. So to get the custom font file we're 
going to need and let me show you the screenshot  
37:28 - that the the font looks really nice that it's 
this font Montserrat, I'm going to I've checked  
37:35 - out the step four branch of the code, and I'm 
just going to copy the assets that already have,  
37:41 - I'm going to do that off screen here because it's 
just easier. And what we're going to do is in the  
37:48 - assets directory, we're going to have a child 
called fonts. So that's going to be a sibling  
37:54 - of the images directory. And then I'm going 
to just paste it in here off screen, and boom,  
38:00 - okay, so the fonts got added. So each font file, 
I downloaded these from Google fonts, each font  
38:08 - file has a special like family name. And what 
we're going to do is in our pub spec yamo file,  
38:14 - as you remember, the public ammo file lets you 
define packages that we're going to cover that  
38:22 - we haven't used the custom package yet. It lets 
you define where your image assets are. So here,  
38:28 - assets slash images. But for this video, I've 
implemented this already, which you're going to  
38:34 - have to type in yourself or copy from the example 
code, we can define a section called fonts,  
38:40 - and it has to be indented properly. So you just 
do one indentation, because it lives under the  
38:45 - flutter section. That's very important. We're 
going to call it Montserrat. So the family name  
38:51 - you define here is the family name, you'll refer 
to in your style when you define styles. So for  
38:59 - each font file, I can specify the weight I want 
to use. So for this file, it's going to be 300,  
39:05 - which is kind of like regular light slash regular 
weight. And then 600 is kind of a bold weight. So  
39:12 - we're going to have two different weights. So 
make sure you save that. And the indentation is  
39:18 - all proper. It's like using two spaces for each 
section. That's how YAML format ml is defining  
39:25 - indentation. So how do we use these fonts? Well, 
one thing we can do is in our text section we can  
39:32 - define in each text widget, just to get something 
to work, we can just say style. And then we can  
39:39 - define text style. And then we can define all 
kinds of parameters for that style. But for just  
39:46 - for cleaner, simpler code, we don't need to do 
that verbose way of doing things because that's  
39:52 - going to get very repetitive. Where we want to 
do is to find one single style throughout the  
39:56 - app. And it kind of works like CSS as well. And to 
define the style throughout the app, because we're  
40:03 - using a material app widget, the material app 
widget gives us these shortcuts. And one thing,  
40:10 - let me look at my notes here. One thing we can do 
here is define something called a theme. So this  
40:18 - is how we use themes in flutter. So the theme is 
something general. And there's different types of  
40:24 - theme. So we're gonna say theme, and then theme 
data. And theme data lets us define various how  
40:33 - various widgets are styled in the app. So the 
first thing we're going to define is the app  
40:38 - bar theme. So the app bar is a material design 
terminology for the navigation bar at the top. So  
40:46 - for iOS users, it's called the navigation bar. So 
we say app bar theme, and you instantiate an app  
40:53 - bar theme class. Exactly. And so that app or theme 
class is going to give you certain parameters. One  
41:01 - is the just basic text theme of the navigation 
bar at the top. So let's define a text theme.  
41:06 - And the text theme we instantiate here. And for 
the title of that text theme, there's different,  
41:14 - there's different options you can use for text 
theme, you can go over it in your free time. But  
41:20 - these are the different. These are basically all 
the main options for a general text theme. And I  
41:27 - won't get into this too much. But for the sake 
of brevity, in this video, I'm going to find  
41:33 - the text theme that I want to use. And instead 
of hard coding into my file here, I'm going to  
41:40 - define the the text theme in a separate file. So 
it's nicely organized. But for now, I'm just going  
41:46 - to type in what I want to implement. And that's 
going to be at bar text style, this is going to  
41:50 - be something I defined as a custom thing. In just 
a moment, I'm going to now going to implement it.  
41:59 - So to organize your style properly, what I 
personally typically do is I create a file  
42:07 - called style dot Dart. And that style dot Dart 
is going to define all the style of my app. And  
42:16 - what I'm going to do is import material. And I'm 
going to define some constants at the top because  
42:25 - I'm just going to paste it in here. And what this 
does, it lets me keep my style file very succinct  
42:31 - and clear. So I'm defining specific different 
categories of text sizes. And then the name of  
42:39 - the font I want to use. This is the core family 
name I defined in my pub spec yamo file. So I'm  
42:46 - going to paste this in here, this is going to 
be my app bar style, it's going to be it again,  
42:51 - it's a text style. And it works. Again, it works 
a lot like CSS. So it's very easy to follow. It  
42:57 - has a font family, so refers to my font name, 
Montserrat, a weight. So for font weights. In  
43:05 - flutter, you can define different font weights. So 
they all go from 100 to 900. And because I defined  
43:13 - one that's called 300 in my pub spec, yamo file, 
see here, I can use that weight. So that's the  
43:21 - font weight, and then the font size, it's medium, 
it's 20. And then the colors, it's just going to  
43:26 - be kind of white, because the fact that I have a 
colored navbar up here. So I'm going to save that.  
43:33 - And then I'm going to import it in my app dark 
style dot Dart. I'm going to save it. And cool  
43:41 - now our navbar is styled with the custom font you 
see it's kind of like lightweight here. And we'll  
43:49 - we'll style it more later. Because that's not 
this is not quite the final design we want to  
43:55 - use. But we'll we'll continue with this later. So 
let's finish up the style of our app. So now that  
44:01 - we have the app bar theme, the adaptation is a 
bit strange looking here because of the way auto  
44:08 - format. But for me do this so that you can read it 
better. And the last style we're going to define  
44:15 - here is our style for just basically the text 
section. So I'm going to go look at my notes here.  
44:23 - So for the text theme, we're going to define, 
there's various text theme that throughout the app  
44:30 - that we can define here. So texting could be for 
various different components. So one is for just a  
44:37 - loose something loosely named called title you can 
I'll show you how to use it in a second. But it's  
44:42 - basically for any title you use. So we're going to 
call it a title textile. We're going to implement  
44:48 - this in a second because this style same with the 
app bar text style will come from our style file.  
44:55 - And then we're gonna say body one. So body one is 
just another Name we're going to refer to later  
45:01 - in our code. And that's for any body text body 
style, we're going to call it body one text style.  
45:07 - So let's implement this now in our style file, so 
and our style dot Dart, I'm going to paste these  
45:17 - in. First off, I'm going to paste in the title, 
textile. And the title textile is going to be  
45:24 - looking like the same thing, but it's just going 
to have a black color. And that's going to be  
45:27 - large. The next one is body one textile, same 
thing, but it's just going to have a different  
45:36 - text size. So body text size of 16. So now that 
I pasted those in, and I have these defined here,  
45:43 - the general style for all the text in the app now 
is changed. So it's going to use the basic font of  
45:52 - the style, but there's certain elements about it 
that are not going to be used. So for let's say,  
45:57 - the title textile, it's not going to use this. 
certain elements of this, so it's not going to  
46:04 - be large yet. So to to kind of deliberately say, 
hey, for this title here, let's say summary, one,  
46:12 - I want to use the title text style, I have to 
deliberately go into my text section widget. And  
46:18 - we're going to have to update that. So how we're 
going to update that is for here, we're gonna say,  
46:25 - for the text widget style. And then we're 
gonna say theme, use the name constructor of,  
46:32 - we're going to pass it our context. And again, our 
context is something we pass around in the app.  
46:38 - And it just is a way for flutter to kind of know 
certain, certain contextual information about the  
46:45 - rendering tree, the widget tree. And now we can 
refer to any style that we have defined here. So  
46:54 - we can refer to text style text theme rather. So 
because of the fact that we defined a text theme,  
47:02 - I'll go back to here, here. So in our theme data 
widget here, we defined a text theme. So now we  
47:09 - can use it. So I could say theme of context, text 
theme. And now I can specify exactly what subset  
47:17 - of my text theme. So I'm because I define a title 
text theme. Again, going back to App dot Dart,  
47:23 - see, I defined a title, text theme, I can use that 
now. So I say title here. And I'm going to save  
47:29 - it. And now it's using the actual text theme, I 
want it It's the exact text size that I wanted to  
47:36 - use all along, I'm going to do the same thing for 
my body. And so I'm going to paste this in here.  
47:40 - And I'm going to say body one. So basically, it's 
not going to be I don't have to do this, because  
47:50 - it's already taking the style of that because this 
is just normal text. If I define a text theme of  
47:56 - body one, all the just general text of the app 
is going to be styled like this. But I'm still  
48:01 - defining this style here. And I'm using explicitly 
body one. Because it's just more explicit that  
48:07 - way. It's clear. And but you don't have to do 
it like that. So yeah, that's, that's how you  
48:14 - style text and flutter. I think that wraps it up 
for this lesson. Yeah, and we're going to just,  
48:21 - you know, style this more later. And then the next 
episode, we're going to actually use dynamic text.  
48:26 - So we're not going to hard code anything in. Um, 
but yeah, that's it. So thanks for watching. Hey,  
48:32 - everyone, Nick here. So in this episode, we're 
going to talk about three things. One is how to  
48:36 - use models to represent data and functionality. 
And we're going to update our code to make our  
48:43 - screens dynamic, and not hard code, any data 
in there. And also, we're going to be covering  
48:49 - Dart concepts such as generics, the map function, 
anonymous functions, and cascades. So if you want  
48:56 - to follow along, I'm going to be going through 
this blog post as I go through the lesson. And  
49:02 - you can find the blog post on flutter, Crash 
Course calm, and then go down to the episode  
49:06 - working with models here. If you want the code 
there, the links in the blog post right here,  
49:12 - you have to just check out this branch here I have 
highlighted to half of the actually have the code  
49:17 - we're going to be implementing. So let's talk 
about the significance of the apps data model.  
49:23 - So a data model is something very, very generic 
to any kind of app. It's not only flutter apps,  
49:29 - it could be web app, just a traditional software 
application or could be a mobile app doesn't  
49:35 - matter. So a model is basically a glorified class 
in darts. So when we have an app that we're going  
49:41 - to write, the app usually has input and output. 
So like any software program, so the input of the  
49:48 - data is going to be probably some data we fetch 
from an API somewhere. So it could be a Firebase  
49:55 - API or a normal traditional HTTP based restful 
For API. So that's the input to our app because  
50:02 - the data is coming into our app. But the problem 
is we need to when we take that data into our app,  
50:08 - we need to represent it somehow in memory. 
And that data might be complex and might have  
50:13 - different types of data with different types of 
fields to it and properties. And also that data  
50:19 - might relate to each other in different ways. So 
let's say we have our tourism and co app here,  
50:25 - the input of the data would be a list of locations 
that can be shown to the user. And each location  
50:31 - could have a list of facts of that location, like 
fun, interesting things that you want to show to  
50:37 - the user. So if we want to represent that data 
in our app, we're going to create two classes,  
50:43 - a location class and a location, fact class. And 
we're going to have a relationship between them.  
50:50 - So the model also represents the relationships 
between different pieces of data. So the location,  
50:57 - model or class, if you will, will have a list 
item, a member, that's a list of Dart list, that's  
51:05 - going to be a list of facts. So there's a one to 
many relationship between location and location  
51:10 - fact. So all of this data taxonomy and all that 
stuff we're going to represent in classes, and  
51:16 - we're going to call them models, that's just like 
a terminology that a lot of people use. So when  
51:22 - we fetch the data from the API, we're going to 
write certain code that creates instances of the  
51:28 - location class. And when we want to use that data, 
in our app, let's say we load a given screen,  
51:36 - let's say we load a location detail screen, we can 
easily work with that data if we have them cleanly  
51:42 - separated into separate model files. So So again, 
scrolling down here, we have the models location  
51:51 - and location fact that we're going to create in 
the lesson. And again, it's going to be a one  
51:55 - to many relationship. So that's more coming from 
database design terminology, one to many and all  
52:00 - that stuff. But that's just like stuff that you 
should know as well, you could use that not only  
52:05 - for databases, but also for how your models relate 
to each other in your flutter app. So this is how  
52:13 - we're going to use our models I'm scrolling down 
here. This is how it is a given use case of how  
52:19 - we're going to use our models. So our app loads. 
And then, since we don't have multiple screens  
52:25 - yet in our app, we're going to do that in the next 
lesson, we have a single location detail screen,  
52:29 - it's going to load, we're going to say, hey, just 
give me like from a list of given locations, based  
52:36 - on a location identifier, or ID, we're going to 
also add that in this lesson, give us the name of  
52:43 - the location, and then render it in the navigation 
bar. And then for each location fact, again,  
52:49 - it's a one to many relationship between location 
location fact, render a given text section and  
52:56 - on our screen. So right now, as you can see, in my 
simulator, I have three text sections. That's just  
53:02 - hard coded. So what we're going to do is update 
the code to render a given tech session based on  
53:09 - each fact we have associated with that it could 
be one fact that could be five facts, it depends  
53:13 - on the location instance, we're rendering. 
So how do we add our models. So basically,  
53:21 - I'm going to show you the best practices for 
when you're adding models, where to add them,  
53:26 - and also how you can use code commenting and what 
the best practices are to make sure that if anyone  
53:32 - else is reading the code that it's easy to read. 
So let's get started. The code example that we're  
53:37 - going to code is in this blog post, so I am going 
to open my basically, I'm going to open my code  
53:47 - here. And I'm going to explore here, and I'm going 
to create a directory called models. So basically,  
53:54 - in terms of code organization, best practices. In 
the lib directory, there's going to be a sibling  
54:00 - directory, two screens, the screens directory 
that we have, and we're going to call it models,  
54:05 - then we're going to create a new file called 
location Dart. And now we can increase the size,  
54:13 - we can just implement our location model. So it's 
going to be again, a class and each class in Dart  
54:20 - is going to be in title case, meaning the first 
initial of every word is going to be capitalized.  
54:27 - And I'm going to have three fields here, I'm going 
to have string, I'm going to a location has a  
54:35 - given name, it's going to be let's see image path. 
And then it's going to be a list of location facts  
54:42 - final list location fact and I haven't created 
that yet. So it's going to have an error here.  
54:48 - Fax and then I'm going to update a constructor so 
that I can create this model very easily. So we've  
54:57 - gone over this before, but we're going to use a 
short Cut here, where if we use this dot name,  
55:02 - this dot image path, and this dot facts, we can, 
the constructor will automatically assign the  
55:10 - values you pass in to your members. And that way, 
we don't have to actually implement the the class  
55:17 - like the constructor like this. And we've gone 
over this previously, so I won't go over that too  
55:22 - much. And then we're going to import which a file 
we haven't created yet. Location fact dot Dart,  
55:29 - make sure that the name of your model is in single 
case, like a location because it is one given  
55:35 - location. So don't make it plural. And also, that 
goes for the file name. So I'm going to create a  
55:40 - file name called location facts, not facts or 
anything like that. It's a one single fact. And  
55:47 - a location fact, again, its title case, let's see 
what we want. It's going to have title and a text,  
55:55 - let me just paste this in because it's faster from 
the blog post. It's not rocket science here. So  
56:00 - location facts gonna have title and a text. And 
that's really it. So no errors are here. That's  
56:06 - great. Um, so yeah, let's see. So let's talk 
about how we're going to add business logic to  
56:15 - our model. So business logic, again, is just a 
glorified term for just some code. And there's  
56:21 - some rules to that code, based on your business 
or your what you're trying to accomplish. So we're  
56:28 - going to implement that. And one traditional way 
to implement business logic is you can add them to  
56:34 - the model directly. If it's not such a big app. 
If it's not, if the kind of a small to medium  
56:39 - size app, a lot of people just add the business 
logic and core functionality to their models. So  
56:45 - let's say I want to get a list of locations, 
I'm going to add a method that fetches those  
56:51 - locations. And I'm going to add that method to the 
location class. So um, that's pretty much a common  
56:59 - approach. So in this method, here, I'm going to 
implement that it's going to I'm going to paste  
57:08 - this in, because there's a lot of code here. And 
I, I suggest you not typing it in because it's,  
57:13 - it's tedious, you can just check out the code 
here. Let's go through this. So this is going  
57:20 - to be a function that's static and, and static, 
meaning you don't have to instantiate location to  
57:28 - invoke the function, you can just say, fetch 
all so this is going to be a function called  
57:32 - fetch all, it's going to fetch all the locations 
in our virtual database, it's hard coded now,  
57:38 - but in a few lessons, we're going to fetch it from 
an actual back end API. So we're gonna say fetch  
57:44 - all and this is not a realistic fetch all function 
because usually, you would add like a, you know,  
57:49 - pagination parameters, a fetch from one to 10, or 
whatever, or fetch numbers 10, to 20, or all that,  
57:56 - but this is very trivial example, and it's going 
to return a list of locations. So each location  
58:03 - we're going to call is the constructor, we're 
going to pass in a name here, and this is the  
58:09 - path to the image and all these, and then it's 
going to be a list. And for each list item,  
58:14 - we're going to instantiate a location fact. So 
this is going to be summary how to get there,  
58:19 - etc. So it's really ugly now. But once we have 
an actual web service API hooked up, it'll this  
58:26 - will all go away. And also note that for now, 
we are using this kind of ordered parameters  
58:35 - for our constructors, there's, if you're having 
a lot of parameters, that's there's another way  
58:39 - of doing that we'll cover in another lesson. But 
for now, this is like the simplest way. Great,  
58:44 - so we have our models. Let's continue. So let's 
make our code dynamic now. So we're going to take  
58:51 - and use this fetch all function, and we're going 
to update our location detail screen. So let's  
58:59 - import the location class. And we're going to 
update the following. We're going to update  
59:07 - the app bar title, we're gonna update this image 
banner and then we're going to iterate over every  
59:12 - fact of every of the location, we're going to 
load and render a given text section. So how we're  
59:19 - going to do that is simple at first, we're going 
to load all those locations in the build method.  
59:24 - So we're going to say location dot fetch all and 
then we're going to assign a given location. So So  
59:34 - for a given list locations is a list type. There's 
a special kind of property called first and that's  
59:41 - just like saying, like this, basically, and 
right now we don't have multiple locations, we're  
59:46 - going to implement the next lesson. We're just 
gonna assume we just have one location because  
59:51 - we're just loading a location Details screen 
here. In the next lesson, we're going to pass in  
59:56 - an identifier to location Details screen and then 
loaded by identity. to fire. Another word before  
60:02 - I continue is that um, usually you don't want to 
load data in the build function because the build  
60:07 - function of any widget can be called multiple 
times. So we don't want to be doing that. But  
60:11 - just to get it to work for now, we're going to be 
doing it here. And I'll explain in later lessons,  
60:17 - how the kind of ideal way to do it. So now we have 
access to our given location. So I can update the  
60:22 - title here. And I could say location dot name, 
because location has a name property, as you can  
60:28 - see here, this is the name property. And then 
I can say in the image banner, say location dot  
60:34 - image path, that's the another property here. So 
let's reload that. And it looks like it's working  
60:42 - pretty well. So what are we going to do with 
each text section. So basically, um, in Dart,  
60:49 - there is a special function called map. And what a 
map does is it converts a list or an array in Dart  
60:58 - is called list of stuff to another list, but but 
of another type of data. So if I have a list of,  
61:08 - let's say, strings, I can use map to convert it to 
a list of actual objects, like a list of widgets,  
61:15 - right? In our case, what we're going to do is 
we're going to have a list of location facts,  
61:21 - which is an array of I'll show you the model, it's 
going to be this data type list of location facts.  
61:27 - And, again, just touching over this again, this is 
what we call generics. So we've went over this in  
61:36 - the last few lessons, but I want to refresh real 
quick before I continue, it's going to be a list  
61:40 - of location facts. So generics is basically the 
ability to define a given type for specifying the  
61:47 - type of something so you have to specify a list 
of something, it's a list of string, you could say  
61:53 - list of integers. And in our case, we're gonna 
have a list of location facts. So that's what  
61:58 - generics is. Anyway, where the map function was, 
we're going to say, for a given list of location  
62:05 - facts, we're going to convert that to a list 
of widgets of type text section. So that's what  
62:13 - map does it transforms of one type of list into 
another type of list? So how are we going to do  
62:19 - that? Let's make a function where we're going to 
take all this stuff, we're going to cut it out.  
62:24 - And we're going to say, some list of widgets. And, 
and then we're going to just add it in here, after  
62:33 - the fact. So before we do, go ahead and do that, 
let me implement a function that returns that list  
62:40 - of widgets that implements our map function. So 
what we're going to do is, we're going to have  
62:45 - a list of widgets, that the function is going to 
return. And let me look at the code real quick,  
62:50 - what are we going to call it, it was called text 
sections. So the blog post I just brought up has  
62:56 - the kind of final implementation, but I wanted to 
do it from scratch here. It's gonna, it's going  
63:02 - to take a single location. And that location is 
gonna, we're gonna say location dot facts. Again,  
63:10 - it's a it's a list item. And we're gonna say 
dot map. And dot map takes a what's called a  
63:17 - anonymous function. In other words, it's another 
word for it is a closure in Dart. And a closures  
63:24 - are something very pervasive through other 
programming languages. And the syntax is just kind  
63:29 - of weird. A closure or an anonymous function is a 
function, but you don't give it a name. It's just,  
63:35 - it's anonymous, you don't have a name for it. So 
f is our function. And we're going to implement  
63:41 - our function right in here. So the function 
because how map works, the function will take  
63:48 - one single parameter, and the parameter is it's 
a given fact. So anonymous functions in Dart have  
63:57 - three parts to it. The first part is the actual 
list of parameters of the function just like any  
64:03 - other function, this is the list of parameters. 
And the number of parameters that's available is  
64:08 - defined by this actual map here. So we know that 
if we click into it, this is pretty cryptic. This  
64:17 - function that it's defining that we pass in will 
only allow us to have one kind of parameter, but I  
64:23 - would look at this as is pretty complex. Anyways, 
the list of parameters, and then there is a arrow  
64:30 - here, it's called rocket notation or something, 
which is saying, Hey, we wanted to find a  
64:37 - single line implementation of our function. So in 
theory, we can do this we can use curly braces and  
64:45 - implement our function here. But with this arrow 
does is it lets us define if it's the function is  
64:52 - a single line, it lets us define the function as 
a single line of code. So we can say no Whatever  
65:00 - we define here as a statement, it returns. So we 
can, if we want to return, let's say FUBAR, it'll,  
65:06 - we can do it like this, right? So what we want to 
do is the implementation of this is return a text  
65:13 - section. So remember, we had a text section widget 
here. And that's what we're going to implement. So  
65:19 - text section. And then for the fact, we're going 
to have fact, um, what is it, a fact has a title  
65:29 - and text. So fact, title, and fact text. So this, 
again, as I said, just to go over this one more  
65:40 - time, because you're going to be using this a lot 
in flutter apps is map will convert a list of one  
65:46 - type to a list of another type, right? So in here, 
we're going to, it's going to iterate each fact,  
65:52 - in the facts list. And for each fact, we're going 
to execute a single statement, as denoted by this.  
66:00 - And that statement is going to return what's 
going to be pushed into the new list. So it's  
66:06 - going to return a text section. And we're going 
to re implement the instantiation of our text  
66:12 - section. And then it's going to return it. So 
this is going to return a iterable kind of list  
66:19 - of stuff. So iterable of a given type. So iterable 
is another thing in Dart that's kind of a kind of  
66:27 - like a parent grandfather type of something that 
you can iterate over, it's something generic,  
66:33 - but we're not going to be it's not useful to us. 
So what we can do is, we need to get get a list.  
66:39 - So for iterable, we can just say to list and to 
list, we'll convert something that's iterable  
66:46 - to an actual list type here. So yeah, that's 
it. That's the implementation. Um, we return  
66:54 - this. And then we need to use this list of tech 
sessions read return here. So we can't just call  
67:02 - text sections like this and pass in location. 
Because we want to add, because this is a list,  
67:11 - we want to add it to the existing list of it, 
we want to inject it into our list here. So  
67:17 - this is already our list, we want to inject it 
here. And basically, we're going to do this,  
67:24 - we're going to use darts spread operator. And it's 
called the cascade spread is coming out in the  
67:31 - next version of Dart. And, and that's different. 
But cascade is two dots. And what cascade does  
67:39 - is it takes a given item, and it lets you run a 
function against it or, or make an assignment or  
67:47 - do something else. So I'm going to say the cascade 
operator. And then we're just going to say, add  
67:54 - all. So I'm going to, there's a special function 
in Dart called add all. And what that does is, it  
68:01 - depends all objects have something that's iterable 
to the end of the list. So if we have a given list  
68:06 - here, it's we're gonna say at all, and then we're 
going to pass it a something that's iterable. So  
68:11 - text sections is iterable. And that's where we're 
going to do. So there's a lot to unpack there on  
68:17 - the, but like, this is kind of a common situation. 
in Dart 2.3, which is coming out very soon, you'll  
68:26 - be able to use a nother operator called the spread 
operator, which is three dots, and kind of kind  
68:33 - of tack on list items like that more easily. So 
anyway, let's reload this screen. And yeah, there  
68:41 - we have the text here. So all the text looks nice 
here. And that's it. Um, let's see what else we  
68:49 - have to cover here. So if you want to go over what 
cascades are I have links to what cascades are I  
68:55 - have a I have a link to what the map function 
is. Well, I have notes on it. But I also have  
69:01 - a link to the actual documentation in the in the 
Dart website. So this is a link to it. And yeah,  
69:10 - like, you know, I would say play around with this 
stuff. And in summary, basically, I guess that's  
69:18 - what we cut. That's all we need to cover. So our 
app now dynamically adapts to whatever data we've  
69:24 - defined. So in the next section, next lesson, 
we're going to be covering more advanced features,  
69:30 - and building out a new screen. So thanks for 
watching. So in this episode, we're gonna be  
69:37 - covering navigation in flutter. And also the list 
view widget, which is a really important widget.  
69:42 - Because most apps are made up of some kind of 
ListView of stuff. It could be newsfeed items,  
69:48 - photos, whatever. So finally, we're going to be 
covering gesture detector also. So we're going to  
69:55 - be implementing the second major screen of our 
app, the tourism co app, and You'll be able to  
70:01 - browse through a list of locations and tap on one 
to get to this detail screen that we've already  
70:07 - implemented here. So let's get started. If you 
want to follow the code and and just get a copy  
70:15 - of the code we're going to be implementing In this 
lesson, you can check out the repo at this blog  
70:20 - post on flutter Crash Course calm. It's called 
navigation in flutter. And there's a link for  
70:26 - the code for this lesson up here. And you have 
to check out the branch step slash step 06. So  
70:35 - first thing we want to do is update our fixture 
data. So fixture data, again, is just test data.  
70:41 - But we want to show a lot more locations. So we 
can show this list view widget easily, we're also  
70:50 - going to add a new field to the location model, 
which is ID. And what Id is going to do is,  
70:57 - it's a unique identifier that lets us pass around 
in our app so that we can load a given detail  
71:04 - screen. So if I tap on location with ID two, for 
example, I then make a call to my back end to say,  
71:14 - hey, fetch me all the data for location too. 
So we're not integrating with the backend quite  
71:20 - yet. But that's the kind of code we're going to 
implement before we actually do that integration  
71:25 - just to wire things up. So you can check out the 
branch to just copy and paste this new location  
71:34 - data if you want. I'm going to do that right 
now. So let's open our project. So the we're  
71:42 - going to open the location model. And right now 
we only have one instance of a location. So we're  
71:49 - going to want to create three. And before we paste 
that in, I'm going to actually implement this ID  
71:54 - member. So int ID for location, and it's going to 
be an int. different apps do use different forms  
72:03 - of identifiers. Sometimes they use a string as a 
COVID. But in our case, we're just going to use an  
72:09 - old fashioned just into, so we have to update our 
controller here, our constructor rather sorry. And  
72:17 - then I'm just going to paste in what I have here 
to the side. And that'll be a lot easier. So boom,  
72:26 - done. That's it, let's make sure we have the 
images in our app. So every location refers to  
72:35 - an image. So an image file locally later, we're 
going to be loading it from a URL. So right now I  
72:41 - don't have all the images. So I'm going to have to 
take the images from an exhibit the ranch called  
72:48 - step slash step 06. And I'm just going to copy it 
now off screen. So I've checked it out off screen,  
72:56 - I'm going to copy it, and then I'm going to now 
paste it into the assets directory and the images  
73:04 - subdirectory. There. So I'm going to paste it in 
and boom, they show up right here. So make sure  
73:11 - you have these images here or else they won't show 
up. Great. So let's go back to my blog post. So as  
73:18 - you know, in every lesson, I follow my blog 
post, so if you want to see the show notes,  
73:24 - you can as I talk, let me increase the size for 
you. So our fixture data is done. So next thing we  
73:30 - want to do is implement a new screen, which is the 
location listing screen. And this is going to be  
73:37 - a stateless widget because it's not going to need 
to maintain any state. And it's going to also use  
73:43 - a scaffold, which is that it's that convenience 
widget that lets us create a new screen. And we're  
73:51 - going to create a ListView inside of it. And 
a ListView basically takes in a list of items,  
73:58 - whatever that is, it's just a bunch of data. 
And it will render those items and automatically  
74:04 - scroll let you scroll those items. If there's 
you know, if it overflows the screen. So this  
74:11 - is the boilerplate, as you see in front of 
you for the list, how we would use list view,  
74:16 - we would basically fetch all of our locations 
and pass it, map them. And we've covered map in  
74:25 - the last lesson. So if you don't know about that, 
check it out. And for each location, we're going  
74:30 - to display the locations name period. And that's 
it. And then we're going to return a list for the  
74:36 - list view. So let's continue on here. I will 
just implement it now. And we can build upon  
74:45 - this so we can add an image or make it tappable or 
whatever. So let's actually implement this. Okay,  
74:53 - let's continue here. Um, so open the so the 
screens directory It shows all of our existing  
75:02 - screens right now there's there's one folder per 
screen, we already went over code organization. So  
75:08 - this is how we're going to continue to organize 
our code. So I'm going to hit New Folder. And  
75:13 - we're going to call it locations. Because it's 
basically a list of locations. And for naming  
75:21 - your screens, you want to basically name them 
as simple as possible. So you don't want to  
75:27 - you don't want to name it location listing, 
it's just too verbose. You can if you want,  
75:31 - but it's just too verbose. So I'm going to call it 
locations. And because it's the main screen, I'm  
75:37 - going to name it the same name as my directory. 
And that's really important to be consistent. So  
75:42 - let's start implementing this. I'm going to paste 
in the boilerplate code for a stateless widget,  
75:49 - and also our imports. So I need to import app dot 
Dart and also the location model. So in terms of  
75:59 - the simple screen, pasting that in, we want to 
use a scaffold. So I'm going to paste that in  
76:05 - because we already went over this before, let 
me increase the text size for you. So and then  
76:11 - I'm going to hide the left panel here so you can 
see it better. So the scaffold takes in a body,  
76:17 - as you know. And let's go ahead and implement 
ListView. So we say ListView. And so there's  
76:27 - different versions of ListView. You can use right 
now we're going to use the traditional ListView.  
76:32 - constructor, there's some named constructors we're 
going to use later but we'll cover that. So if  
76:37 - you're used to list view already in your, you're 
implementing it in a different way, just like just  
76:43 - follow along and, and just see how I implement 
ListView. Because the main way to implement it is  
76:50 - there is a children parameter, and that children 
parameter takes the list of a list of whatever  
76:56 - you want to render. So it's going to be a list of 
widgets at the end of the day. And for now, we're  
77:01 - going to make it really, really simple. So let's 
go back to the example in the blog post, right,  
77:06 - now, we're going to just implement a list of text 
widgets. So let me when I fetch my locations,  
77:13 - I'm gonna say map. And map takes a is basically 
an anonymous function. So So for each item in the  
77:22 - map, which is a location, I'm going to execute the 
following function, and that function is going to  
77:29 - return a widget that represents each item in my 
list view. So I'm going to return a text widget.  
77:36 - And I'm just going to use the location name for 
the text widget. And then finally, I'm going to  
77:42 - convert it back to a list because map returns an 
iterable type. And that's more of an advanced type  
77:50 - that you don't really need to know about right 
now. But you just have to convert it back to a  
77:55 - list because that's what children is, it's a list 
of widgets. So we have to say that, and let's see,  
78:02 - I guess that's it. Let's see if that rendered. 
So I have my emulator open here. And we have the  
78:08 - detail page open now. So now we have to update the 
app dot Dart to kind of show this view right here.  
78:16 - So let's go to App dot Dart. And a shortcut 
for opening things in VS code is command p,  
78:24 - or if you're on Windows or Linux, it's Ctrl P, 
and then you just type the name of the file. So  
78:30 - that's really useful. So basically, the homescreen 
is now not going to be location detail that was  
78:36 - just there. For example sake, it's going to be 
now location. So let's update our imports. And  
78:42 - I'm going to update this, save it. And now let me 
let me just do this here, bear with me. That way,  
78:55 - you can see the code on the screen here. Cool. 
Now, this is a very basic list view doesn't look  
79:00 - really cool. It just shows like a single name. 
And that's it. There's nothing fancy about it.  
79:05 - We're going to be adding an image for each item 
here later. So Oops, I'm going to show you that.  
79:13 - So I have the mock up of like the actual end 
result of our app here. And I've showed it  
79:19 - to you before. Let me open it for you here in 
a new window. Because it's not let me show it  
79:26 - to you. Let's see location list. Yeah. So this 
is going to be our final ListView, we're going  
79:33 - to implement the list view is going to have one 
image per item. And it's going to have a widget at  
79:38 - the bottom with with the name, the opening times 
of the location, and just the some subtitle. So  
79:44 - that's what we're going to get to so we're not 
going to render those images quite yet though,  
79:50 - so great. Now let's we let's cover how to interact 
with an actual list view items. So we're going to  
79:59 - implement a gesture detector. And the gesture 
detector is something very basic in flutter.  
80:05 - Most other widgets already include the ability to 
detect a tap, it could be in the form of a button,  
80:13 - or whatever. But a gesture detector is the kind 
of parent type that's can be used for really  
80:20 - any widget. So we can wrap anything with a gesture 
detector and actually pass on an anonymous method.  
80:28 - And that method can do whatever we want. And in 
this case, we're going to navigate to the location  
80:33 - Details screen. So let's implement a gesture 
detector. So basically, to implement gesture  
80:41 - detector, it's it's its own widget. So because 
it's, it's just a widget here. Let me just do a  
80:47 - word wrap here, wrap. Great. And I'm going to hide 
the left bar here. So it's another widget. So we  
80:57 - can wrap the text widget here with a gesture 
detector. And a gesture detector has a child,  
81:06 - which is going to be the actual thing. And let's 
see child text there, and then and the parentheses  
81:17 - here and save it, it's going to automatically 
format. And it's not going to do anything yet  
81:23 - because we have to implement a new kind of 
parameter here. So instead of only providing  
81:30 - a child, there's another parameter you're going to 
provide, which is called on tap. And on tap takes,  
81:36 - let's click into it to see how you implement that. 
An on tap is a type of gesture tap callback. And  
81:44 - if you type tap into gesture tap callback, if you 
click into it, you're going to see it's just going  
81:51 - to be a function a general function. So you can 
click into this as much as you want to see how  
81:56 - things are implemented. But just trust the process 
for now that it's it's going to be a actual  
82:02 - function, anonymous function. And let's implement 
that now. So because it's just a generic function,  
82:08 - it doesn't take any parameters. So we're going to 
do the parentheses here, because without any list  
82:14 - of parameters, and then the arrow here, the rocket 
notation, and now we're going to implement the  
82:20 - function for on tap. And because it's a little bit 
more complex, we're going to pass it the name of  
82:26 - another function so that we're not implementing 
the function right in here. With like a block,  
82:32 - it's going to just get too messy. So we're going 
to implement a function called on location tap. So  
82:38 - it's really important to name your functions very 
explicitly. So we're tapping a specific location.  
82:44 - What's not ideal, in my opinion, is to name it 
something like handle tap, or handle location tap,  
82:52 - well, I guess the handle location taps fine. 
But on location tap is something a little more  
82:57 - concise. And it's already like explicit that it's 
a handler. So on location tab, um, I think is the  
83:04 - best terminology. And it's important to be good 
about terminology when you code something because  
83:09 - it makes sure that your code is nice and concise. 
Okay, so let's implement this now. Um, it's gonna,  
83:16 - we're gonna pass in the context. So as you're 
gonna see, in a sec, we're going to need to use  
83:21 - this context variable. And what we're going 
to do is pass in the ID of the location,  
83:25 - what's important is, we're not going to pass 
in the actual location, because in Dart,  
83:31 - it's going to make a copy of that location 
instance. And that's not really memory efficient,  
83:35 - what we want to do is pass only the absolute 
minimum data we need to any function we're going  
83:41 - to use because because we don't, again, we don't 
want to copy actual entire object instances. So  
83:49 - we're going to do that. And let's implement that 
method right now. So because this method doesn't  
83:54 - return anything, we can say void on location 
tab, but what I usually do is I just leave  
84:00 - out the void. If it's returning void, you can 
just omit that. And it passes a build context.  
84:06 - And then the location ID. And so what this is 
going to do is going to know navigate to the new  
84:14 - screen. So now let's talk about navigation next, 
before we actually implement it. Okay, so before  
84:20 - we start any implementation, let's just talk 
some navigation concepts. So in any mobile app,  
84:27 - navigation works like a deck of cards where every 
card in the deck is a screen. And when your app  
84:32 - loads for the first time, it's only going to start 
off with one card because there's only one screen  
84:38 - loaded. And that is defined in app dot Dart here 
in the material app widget by the home parameter.  
84:46 - And we already went over this, but that home is 
the starter screen for your app. So your app just  
84:51 - starts and it starts with one screen and one card 
in the deck. Now when I tap on an item in my list  
84:57 - view here, which we're going to implement It's 
going to load a new screen, it's going to load the  
85:02 - location detail screen, which is another card in 
your virtual deck of cards. And it's going to take  
85:08 - that card and move it on top of the other card 
in your deck into the view for the user. So that  
85:15 - you're pushing and popping cards at the end of the 
day. So it's basically in computer science terms  
85:21 - of stack. And that stack, you can push more cards 
on top of the deck. And the card on the very top  
85:28 - of the deck is what shows to the user and when you 
want to go back. So let's say they tap the Back  
85:33 - button, that card slides off the top of the deck, 
and the previous screen is still there for the  
85:39 - user. So the previous screen is still in memory. 
So when we define a series of screens in our  
85:46 - app in flutter, and a lot of other kind of mobile 
frameworks, you're defining a list of what we call  
85:52 - routes. And that borrows from web app development 
terminology where a route is a basic URL that  
86:01 - is a path to a page. So the home page route is 
just slash. Another screen route is like slash,  
86:07 - whatever. So in flutter, you're defining 
routes, and these are called named routes,  
86:13 - because for every route, you're giving it a name. 
So let's define that. There's a parameter here in  
86:20 - material app called routes. Now, ultimately, we 
won't be using this parameter, because I'll show  
86:25 - you the shortcomings of it. But for very simple 
applications, it works really well. Because if  
86:31 - you don't have any kind of like fancy context, you 
want to pass to your new screen, it works fine.  
86:37 - And I'll explain that in a second. I'll explain 
what I mean by that in a sec. So let's open up  
86:43 - the blog post to show you the example here. And 
I'm just gonna copy and paste this in. Because  
86:49 - it doesn't make sense to type it all out. So in a 
very, very traditional app, when we have routes,  
86:54 - we have the slashes, the just we can call it 
whatever you want. But it's usually using slash  
87:00 - as the home screen. This is the first screen 
that loads, right. And instead of home, we can  
87:06 - say like initial route, and we can just refer to 
that route by name, because the name of that route  
87:12 - is just slash. When we want to navigate to another 
screen, we have to do first to find that route to  
87:20 - that screen. And that screen is like slash second 
or like FUBAR or whatever you want to name it,  
87:25 - right. And to navigate to that screen, then I can 
refer to that screen by name or the route name. So  
87:33 - I can say navigator pushed named context, slash, 
and then you know the name of the route. So going  
87:40 - back to my Detail page, if I tap on a location, 
I can say, navigator, which is a to basically  
87:47 - work with navigation in flutter, there's a class 
called navigator. And you say push names, which is  
87:53 - a named route, and you pass it the build context, 
and then the name of the route you defined,  
87:57 - very simple. Now, the shortcoming to this is like 
pretty clear. Because if your second screen needs  
88:05 - to pass any parameters, if you need to pass any 
parameters to it, like FUBAR, whatever like this,  
88:13 - right? Where are you going to get the values to 
those parameters? That's a shortcoming because  
88:18 - there's no way to define how those parameters that 
data is going to get there if those parameters are  
88:24 - dynamic. So for example, if I have the location, 
detail screen here, location detail, and I need to  
88:31 - pass the ID of the location we're loading, 
how am I going to know what Id that is? By  
88:37 - defining it up here in material route? So there's 
a solution that we're going to implement and it's  
88:42 - standard flutter, but it's not like documented 
very clearly. It's it's kind of a little bit  
88:49 - more ways into the official documentation. So 
I don't recommend defining routes like this,  
88:55 - because they're really it's just that's that's the 
big shortcoming to that and I hope that makes that  
88:59 - explanation makes sense. So let's basically take a 
pause, and implement the location detail screen on  
89:10 - how we need to load it because I can't implement 
a working example of location detail screen unless  
89:15 - we update it. Now, we went over the fact that the 
location Details screen right now only takes it  
89:23 - doesn't take any parameters. Look, it just loads 
any random location, right? This is my location  
89:29 - Details screen, it just fetches all locations, 
and then it says whatever first location have  
89:34 - just loaded. So we're not going to have to quickly 
update the location Details screen to take in a  
89:40 - parameter. So let's go do that now. So we're going 
to have an int as a private member called location  
89:47 - ID. Now remember, this is still a stateless widget 
because location ID we don't need this data to  
89:54 - react to any kind of state changes. It just loads 
this location ID when it loads and That really  
90:00 - doesn't change. So let's create a constructor now, 
a custom one, so that we can load the location ID  
90:08 - and make an assignment to the private members. 
So I can call location detail pass in the ID.  
90:13 - And then we're going to need a way to fetch a 
specific location by ID and then loaded here,  
90:23 - and we don't have a method for that. So the only 
methods we have in the location model is just  
90:30 - fetch all. So we're going to have to implement a 
method that closely resembles what we're going to  
90:35 - ultimately be implementing, which is a call to 
our back end service, which fetches a model by  
90:41 - ID identifier. So let's go ahead and implement 
a function called fetch by ID. So we still have  
90:48 - the fetch all that that's going to be used still. 
But I'm going to implement static a static method,  
90:53 - because we don't need to instantiate a location. 
And it's going to return a location, fetch by ID.  
90:59 - And that's going to be the name of and we're going 
to pass in a location ID. And then, what we're  
91:05 - going to do is, whenever you implement a function 
that the easiest way to implement it, is just to  
91:10 - write out pseudocode. So and then implement that, 
because it's just easier to implement. So we're  
91:16 - going to say, fetch all locations, iterate them. 
And when we find the location with the IDB wants  
91:31 - a kind of return, it's immediately. Of course, 
it's good to get this is a trivial example,  
91:39 - we're going to be replacing it with a back end 
API call. But it's it's not an efficient way of  
91:45 - kind of implementing this, but it gets the job 
done for now. So we're going to first fetch all  
91:50 - our location. So we're going to say location fetch 
all and, and then I'm going to have a for loop and  
91:56 - in a for loop in Dart is pretty strict, simple, 
it looks like a lot for loops to use in other  
92:01 - programming languages. So I don't need to explain 
too much. So we're going to say, iterate all the  
92:08 - locations, and then, um, locations I, so the 
location at index i, if the ID matches location,  
92:18 - Id return immediately, the location at index i. 
And I know you're saying we can probably load all  
92:27 - the locations and a map and instantly fetch those 
locations via a map. But this is just a simpler  
92:34 - example. So we're going to have now fetch by ID. 
Now later, we're going to be going over this is  
92:40 - an error because we're not implementing haven't 
fully implemented our screen yet. In the future,  
92:45 - you're going to write a natural test for this. 
And we'll go over testing later like that, you're  
92:50 - not going to just write functions, and then just 
expect them to work, it's best to have a unit test  
92:56 - for that. But that's it for another episode. Also, 
let's move this method down here. So that because  
93:02 - it's a little bit more of an explicit method, and 
we want to show all of this data up here, just to  
93:08 - make it nicer looking. So now let's implement the 
location detail. And the location Details screen,  
93:15 - we'll call this method. So we're gonna say 
location fetch by ID. And then we can pass it  
93:21 - simply our location ID, and name it the variable 
location, and then we can remove this. So now,  
93:30 - we, we will just this is working fine. We can 
instantiates location detail instantiates,  
93:37 - it has a location ID automatically and then when 
the screen loads, we fetched by ID Great. So now,  
93:43 - let's implement. Basically, we can implement 
push named as I talked to you about like, like,  
93:52 - we have to pass in an actual ID. So I'm going 
to now go over how to pass in dynamic arguments  
93:59 - to the screen we want to load. Okay, so let's 
implement what we're actually going to be coding  
94:05 - at the final implementation of this. So instead of 
it, we're not going to use the normal push names,  
94:13 - we're going to use a more extended version of push 
names. And we're going to pass in an argument to  
94:18 - push name, which is the ID, the location ID here. 
So let's implement that now. So before we do that,  
94:27 - first, I'm going to go to App dot Dart. And this 
is how I personally implement this. Like there's  
94:33 - many different ways of implementing routes, but 
I'm going to have two constants at the top of app  
94:39 - because constants allow me to define like refer 
to location route globally, by the actual name  
94:46 - without having to it just prevents mistakes. 
So I can refer to location name, by an actual,  
94:54 - like variable name and in constants in Dart should 
be starting with Capital letter. So this is going  
95:01 - to be in title case, these aren't classes. They're 
actual variables. So they look like classes, but  
95:07 - they're actual variables. But again, they're in 
title case, because they're constant. So I define  
95:11 - all the names of my routes up here, I have the 
home route, which is just slash, and the location,  
95:17 - detail route. Now, when you pass the slash 
route to flutter, it's already going to know,  
95:21 - hey, this is my first screen, I'm going to load. 
Great. So now let's go back. And now I can say,  
95:29 - push named, and then locations route. And then 
I'm going to show you how I can pass an argument  
95:37 - to that. So we're going to have to pass this 
location ID to this push named function. And  
95:43 - to pass an argument to it, there's an arguments 
parameter. So for push means we have arguments,  
95:48 - and all that arguments is a map, so a map type. 
And then we can define whatever we want here,  
95:54 - I can say ID, and then location ID. And our 
screen is actually going to use this, and I'll  
96:04 - show you in a minute how it's going to use it. 
So we're going to refer to it by name, like ID  
96:08 - and then the value location ID. And we're going 
to remember that we use this ID key to our map.  
96:14 - So let's continue on. So in app dot darts, here's 
what we're going to do, we're not going to use the  
96:23 - routes parameter here. So I'm going to remove 
that. Also, we don't really need initial route,  
96:28 - because we already have a route called slash. 
And that just loads First, we're going to have,  
96:34 - we're going to use a special parameter called on 
Generate route. And on Generate route is giving  
96:40 - us a dynamic list of routes. It's in the form of 
what's called a route factory. And route factories  
96:49 - is the fancy term, which is a basically a payload, 
that of data, it's a chunk of data that just says,  
96:55 - Hey, here are my routes. So let's create a 
pass it a function we're going to implement,  
97:01 - it's a private function. So starting with 
underscore called routes. And now we're  
97:06 - going to implement that here, because it's in 
our app dot Dart, it's on the highest level, it's  
97:10 - easiest to define that here. So it's gonna return 
a route factory. And I'll show you what that route  
97:17 - factory is at the end of the day, in a second, 
rather, um, and this function is going to return  
97:24 - some data. So it's going to return an actual 
function. So if you click into on Generate route,  
97:32 - that is a route factory. Let's click in a route 
factory. And route factory is actually a function  
97:42 - that takes in a bunch of settings, and returns a 
route of type dynamic. So I won't like drill into  
97:51 - this too much, let me implement that. And that 
will make a lot more sense. But what we have to  
97:55 - do at the end of the day is return a function. 
So a function with the parameter settings. So  
98:01 - we're going to use settings here. And I'll show 
you how we're going to use settings. So first,  
98:07 - we're going to get the arguments to our whatever 
route was tapped. So arguments. And settings has  
98:17 - this member called arguments. So we can use this 
settings for getting all kinds of information,  
98:24 - but arguments is one of them. And now we're going 
to create a variable called screen and screen is  
98:29 - the actual widget and the final screen that's 
going to be returned to us based on the name of  
98:35 - the route. So the name of the route that we have 
is defined as settings dot name. So if a user taps  
98:43 - on whatever they tap on, the given route that that 
they're wanting to reach is defined by the name,  
98:50 - which is going to be either slash or slash 
location detail. And what we're going to do is  
98:57 - use a new feature of Dart called switch and switch 
let's it's basically a glorified if and then else  
99:04 - if statement. And it has can have as many else 
ifs as you want, but it's just a more concise way  
99:09 - of saying if something and then else if something 
and then else if something else, right. So instead  
99:17 - of doing that, we can say switch, and we pass 
it the name of the route. And then I can say,  
99:22 - in this case, if it's the locations route, I'm 
going to do something custom, I'm going to say,  
99:29 - my screen that I want to return is a basically 
a new instance of the locations widget. And  
99:37 - then I'm going to say break because in a switch 
statement, it will go through every case until it  
99:43 - breaks or you return something. So next case 
is the location detail routes. And remember,  
99:52 - every case has to be ended by a colon, not 
a semicolon. That's really important and  
99:57 - most programming languages have Have a switch 
statement. So most of you, if you're familiar  
100:03 - with this, it, this is going to look like second 
nature to you. So for the location, detail route,  
100:10 - if I want to navigate to location detail route 
here, and that's defined by slash location detail,  
100:16 - I have to do something custom now. And I'm going 
to say location detail. And I'm going to use my  
100:23 - arguments map here. And I'm going to refer to it 
by the ID key. And that's what we defined here. So  
100:30 - locations, the arguments is a map, and there's a 
key in that map called ID, you should use single  
100:38 - quotes, by the way, by default, um, and then, and 
now it can instantiate with a custom arguments.  
100:45 - So now I have my screen, I have to import it 
real quick. Location, detail, location, detail,  
100:55 - grades, and now I can return it. So break. And 
now, the switch statement has this final case,  
101:02 - which is if none of the cases match, there's this 
default case, and you define it with just default  
101:08 - colon. And then by default, just running going 
to return null and do nothing. And then finally,  
101:14 - what I'm going to do is return what's called 
a material page route. And you we know that we  
101:23 - need to return this because a route factory is a 
function. And, yeah, I won't get into it too much  
101:35 - right now. But let me just say that you expect 
some material page route to be returned, right.  
101:42 - And material page route is a type of is basically 
a type of route. So going back to the basically  
101:53 - the route, factory type, material page route, 
basically, I didn't want to get too much into  
101:58 - it. But it is a type of route. So you can use any 
type of route. There's multiple types of Route,  
102:03 - but the most popular is a material page route. 
And then material page route takes in a builder,  
102:11 - and I wouldn't worry about builder, all it is is a 
fancy fancy way of being able to pass in something  
102:17 - dynamic, like an anonymous function here. So the 
syntax is a little weird, but basically, it's a  
102:24 - function that takes in a context. And you say, 
Okay, what, what am I returning, I'm returning  
102:28 - my screen widget. And that's it. So I know this 
looks a little weird. But basically, this is how  
102:36 - we define all like, all the routes in our app that 
needs to be dynamic. And what's nice about it is  
102:43 - that it's defined upfront in our app widget. So 
let's get this working. And then I'll show you how  
102:49 - it's going to work now. So on Generate route is 
routes. And before we get to working, I'm going to  
102:56 - quickly clean this up real quick because I want to 
use the I'm basically going to take my theme data  
103:05 - before this, before we get into work real quick. 
Let me just tidy this up because it looks pretty,  
103:09 - pretty, pretty ugly. I'm gonna say theme data, 
sorry for the tangent here. But I want to just  
103:18 - put this here, and I'll show you how easy it is 
to quickly get this tidy up. Great. So our main  
103:25 - screen is very clear on our app widget we have 
just on Generate route and our theme. And it's in  
103:31 - a method here so that it's nice and clean. Cool. 
So now that we've gone over that it was a little  
103:36 - tedious. But let's see if this will work. So let's 
check our code again, push named Okay, this should  
103:42 - work. Let's see if this works. Cool. Now, it's not 
loading the location Details screen and see it's  
103:52 - just like loading the location screen. So let's 
troubleshoot why this is happening. So in our  
104:00 - app dot Dart locations to those location details, 
that location, detail route, and to the name,  
104:11 - we're loading his seat, location, detail route. 
So we have to push named location detail routes,  
104:18 - and let's hot reload this. And when I click 
on something cool, it comes up. So we got it  
104:25 - working. I can go back and when I go back, it 
will pop it off the route. So there's no, you  
104:30 - don't need to implement this pop method. Like you 
don't need to manually write some code that says,  
104:35 - push this card that's on top of our deck off the 
stack. It'll just do it automatically. Because  
104:42 - we're using the material apps, material designs 
app bar widget. So app our widget automatically  
104:50 - will show a back button when the screen appears 
if it's not the home route, saying cool. So in our  
104:58 - next episode, we're going to actually implement 
that the beautiful location listing screen. But  
105:04 - this is just the nitty gritty kind of mechanism 
for navigation. Let me make sure I didn't miss  
105:12 - anything. Because the blog post basically explains 
in detail how this is all implemented. And it  
105:18 - gives you also links to the documentation. Let's 
see. Yeah, I guess that's it. Final app dot Dart  
105:25 - file. Cool. And I talked about going back and all 
that stuff like that. So there might be a better  
105:30 - way that you have for implementing routes that 
are dynamic that need dynamic parameters. But,  
105:36 - you know, feel free to reach out if you have 
a better way of doing this. But for now,  
105:40 - and how flutter is implemented. This is 
pretty much the most clear cut way of doing  
105:45 - that. Everything's defined up front in app 
dot Dart. So thanks for watching and yeah,

Cleaned transcript:

Hey, everyone, my name is Nick Manning. And I'm a flutter engineer. So I create flutter apps in my free time. And I kind of also create tutorial videos about it. So I am the creator of flutter Crash Course calm. Thanks very much to free code camp.org for sponsoring this video. And let's get started. Hey, everyone, my name is Nick Manning. And this is my flutter Crash Course. So I'm really excited to offer this to you because I've taken about six or eight months of filming and content creation. And I've boiled it down into this course. And what it's meant to do is save you time learning flutter. So what you see here is my show notes. And as every video I'm going to do, I'm going to walk through my show notes, so you can read along and take notes on your own. And in terms of my background, I've been writing software for about 20 years, five of those as an iOS engineer. So to follow along, some of you might not want to follow along, you just want to watch, that's fine. But you're going to need everything that the flutter website said, so any kind of main operating system, popular operating system, latest version of flutter, and an iOS simulator or Android emulator, so make sure you have that installed and all set up. So if you want to, if you don't know how to set that up, you're having problems, you can go to my website or the YouTube channel that I have. And I have specific videos on how to set up flutter, step by step for Windows and OSX. So experience level required. So you need to have experience with one existing programming language. And also you something that you've coded like a website or a web app, or even a mobile app, you don't need to but something that you've done in the past. So that you know some basic programming, you have some basic programming skills. So let's get started here. Um, if you want to, again, go see other videos, check out flutter Crash Course calm, but we're gonna now start our first lesson, which is chapter one, which is creating a basic screen. So stay tuned. Hey, everyone. So in this lesson, we're going to cover layout in flutter. So we're going to be using a widget called column. And what column does its lets us layout widgets from top to bottom. So let me show you what we're going to be eventually coding. This is the location detail screen of our app. It's called the tourism co app. And the location Details screen shows a number of things. And you can tell that we can use this column widget because things are widgets here are laid out from top to bottom. So there's another widget called a row and row lets you lay out stuff from left to right, for example. So but you're pretty much most of the time going to use this column widget because a lot of content on a mobile app is all is is a column style, layout. So in this video, we're going to cover implementing three text sections. So text sections, let us define the area for let's say, let's say we want to show summary and then this snippet of text, that's what a text section will be. So let's get coding on. So last time we have this, we left off with this home page. And we're going to rename it to location detail. So let's do that really quick. and name this directory location detail because that's the convention of the code order organization we're going to use. So we have a number of screens, and each directory is the name of the screen, and then the name of the file, the main file that defines that screen is also that name. So let's define that. And I'm going to now stop my app and restarted I can't use the hot reload because I am changing the file name. So sometimes we can't use hot reload. So while that's starting, let's go over column. So I'm gonna render three tech sections. But now I'm not going to just display text, I'm going to display colored boxes. So colored boxes are going to show us how that content is that the bounding areas for each piece of content. So one way we can define a colored box is using a widget in flutter called container. So container is kind of like the div of flutter. It's a div in HTML is just a bounding area that's flexible, you have different parameters you can define. One of those parameters is color. So I can just say container and define some color I can use a property called decoration so There's different types of decorations. One is a box decoration, that's just a generic way to define a box, some sort, and I can style that box using the color parameter. So I'm going to say color. And I'm gonna say colors dot red. So this in Dart means colors that red, red is a static member, meaning you don't need to instantiate the colors class to refer to it. So that's why you have class name, dot and then the value here. So lastly, container will take a child. So we're gonna say child text, and then whatever. And then we're gonna save it. And one thing we didn't do is define our column forgot to do that. So column has a parameter called children and children is an a, it's a list, it's not a single widget. So and it is a list because you can have multiple items in your list. So we're going to find three containers here. So I'm going to just copy and paste this, and one's going to be read, one's going to have background of green, and we're going to is going to have a background on blue. Now, nothing's happening here. Because we want to define some parameters here, I can define some texts, that's fine, I'll just do that real quick. But, you know, look at the screen, I mean, nothing really is happening. That's interesting. It's just the finding these little tiny boxes here, you can't even see the text. So what I want to do is define something called main axis alignment. And what main axis alignment does is, it lets us control how each child is vertically spaced on the screen or how it's laid out. And when I say vertically, for column, it's vertically. So main axis is something generic. So I'll take a step back. So main axis is the main axis of the widget that you're using. So if you're using a column, the main axis will be a vertical line on the screen from top to bottom. If you're using the row widget, the main axis will be a horizontal line from left to right. So the main axis says something that's loosely defined, and it depends on the widget that you're using. So So the main axis alignment controls how content is laid out on from top to bottom, I have the following options, I have space evenly. So let's try that. I'll just go ahead. And you'll see that the each box is spaced evenly on the screen. Pretty simple. I can also say let's say end. So if I say end, each item will be rendered from the very bottom of my column, and column occupies the entire screen. There's other options I don't need to cover right now. But the most common one is start. So we're going to stick to that. The second parameter for column or row, we're not going to cover row in this video, but it's also a parameter for row is cross axis alignment. And cross axis alignment is the exact opposite of the main axis. It's the kind of the kind of virtual horizontal line on the screen. So if the main axis goes from top to bottom, the cross axis goes from left to right on the screen. And let me show you what options you have here. So I have cross axis axis alignment, baseline center and start stretch. So we're not going to cover all of these, but one of the most common ones is stretch. So it's making sure that each item of my column is stretched from left to right. So let's save that. And I'll show you now each item is stretched from left to right. And cool. Um, that's it. So this code looks pretty ugly. But at least we have some containers where we can store text. So once we do continue on implementing this screen will have a nice bounding area. And content will flow nicely from top to bottom. And it'll also be stretched. So let's clean up the code. That's the last step of this video. And since these are reusable kind of pieces of code here, we're going to make this into a widget. So I'm going to take the template of this file, like all the import the class here, the build method, and I'm going to copy it, and I'm going to create a new file called text section. So the reason why we're defining the file here in the location detail screen is because we're not going to reuse this widget. We're going to define it anywhere else in the app so we can keep it local to this screen, it's going to paste this in. And we have a nice template for our stateless widget we're going to build, which is defining a text section, I'm going to name it like that. And then in the location Details screen, I can copy or cut the content we want to show. And I'm going to say container. And I'm going to say returned here. And now we can just update this. So we can say text section. And we can define, let's say, let's say three of these later, it's going to be dynamic based on the types of text sections that we have. But for now, we'll just define a finite list. And we're going to say import text section. Cool. So this defines three red boxes pretty useless. So what we want to be able to do is for now customize the background color, even though we're not going to use it. In our final screen, this background color property, I just want to show you how you can define parameters. So how to parameterize, a stateless widget or really any widget. So if we want to pass in a color, first off, I define a private member, private, meaning it shouldn't be accessed outside of this widget, it's just something that this widget should know about. And to do that, I say the type of member it is, which is a color. And I have an underscore for the name of the member because that underscore means that it's going to be private. So I'm going to say color. And to customize it, I'm going to create a custom constructor. So a constructor, lets me customize how I instantiate this class. So I'm going to say text section, because that's the name of the class. This is how you define a constructor. And well, what I could do is there's there's two types of parameters for constructors, there's in Dart, there's optional parameters, and there's named parameters. So option optional names, ones and positional sorry. So we're going to find to keep it simple positional parameters, meaning, if I say color, here, you know, we all will basically how we use it is in location detail, I'm going to say colors, red, colors, green, colors, that blue. And it's positional meaning based on the, you know, this is the first argument, it knows that it's going associated with this parameter simple. And then I could say this dot underscore, color equals color. So this means it's kind of like same thing in JavaScript, where this means it's referring to the instance of this class. So I'm going to say this underscore color, and it's going to give me the value of that parameter, it's going to assign it to that. So in Dart, there's a shortcut to this, this positional parameter. And I don't have to define the method body here, I can just say, this dot underscore color. And what that does is, for a positional parameter, it's going to take that value, and it's just going to automatically make an assignment to the member here, this value. So whatever, I pass it as the first argument here, it's going to assign immediately to this color. So that's pretty cool. So finally, we're going to refer to our member here. So it's customized, we're going to hit save. And let's see what happens here. Cool, it worked. Um, what else we want to cover? Yeah, that's a bummer. I mean, the last thing that you should do is, say that this private number is final. And what final means is that once you set it, you can't change it. And that's really nice, because it makes anyone reading the code, know that they shouldn't change it, they can't, because the compiler will give you an error. And we don't need to change it after that assignments been made. So I just see final here. And that's just like a best practice. So that's it. Later, we're going to add some real text, we're going to style it. We're going to see now how the layout is is defining how the text is constrained. But for now, it's pretty simple. And I hope you have a good idea of main axis lamb and cross axis alignment. And if you want to do like some bonus work, changes to a row and try that out, or play with the different options you have here. So let's continue on. Hey, everyone. So in this video, we're going to cover how to add images to your app, and it's pretty simple. There's two main ways to do it. One is to use an image asset or A URL of an image. So in this video, we're going to first import an actual image asset, like a file, like a JPEG file to our app, and we're going to include it in our pub spec yamo file, and then we're going to implement it. Later, we're going to pull the image from a URL. So this should be pretty simple. But we're going to cover some things you probably don't know about yet, like constraints and how to layout the image. So in the last video, we covered layout, let's just kind of cover what we're review what we're gonna go over and implement in the whole video series. So it's this detail page with a nice banner image at the top and some text sections. So what we've done is we've laid the groundwork for the text sessions, we it just shows some lines, which we will implement in the next video with the text and all the formatting. But for now, let's add an image to the top and keep it simple. So to add an image of, we're going to be basically going through the blog post for this video. So if you want to look at the notes, I will be showing the notes as we go along. So you can read along, we're going to create a new directory called assets, images. So assets is anything like font files, images, anything of that sort, and they're all going to be in one directory. So that's how we're going to organize things. And we're going to use JPEGs. And yeah, that's it. So you can follow along if you want to check out this branch of the code, or you can code from step two on your own. So what I'm going to do is off to the side, here, I have an image already that I'm going to copy and the image are going to copy, if you check out step three of the code, anything from step three onward has this image. So I'm just going to copy it here. And it's off screen here, you're not going to see it. But I'm going to copy it to the following directories. So in my code, here, I have my main root directory. So I'm going to hit this button at the top New Folder. And I'm going to create a new folder in the root of the project called assets. Oops, let me move here. So assets is going to be alongside the Android directory and the iOS directory. And then I'm going to create a new folder called images. And we'll have other folders there later. And then I'm off in the video, I'm going to in another screen here, I'm just copying the actual actual image file. So I'm getting it from my code on branch on the branch that I have at the repo, the link to the repo is here in the blog post. And it's in step three. So I've already copied it, and let me show you the fact that it is copied. So since this is a tourism app, it's going to be of all Japanese locations, just I just decided to pick that randomly. So this is a location in Japan, and this is the image file. So later, we're going to load it from a server. So now that I have my images there, I can't just use it straight away, I have to go into my pub spec yamo file. And let me hide the code here. And so the pub spec yamo file is like a configuration for your project. It's in the root of the project, could see the filename there, and you get to list like what packages you're going to use and all of that. We haven't added any packages yet. We'll get to that in another video. But if you scroll down here, you'll see that there's some example configurations you can enable. So in Dart to comment something out there, they use this pound symbol, right, this number symbol here. So if you just comment it out, you'll actually be able to use that config. And so the important part is to configure this correctly, so that'll work or else. If the formatting is messed up, it may not work. So what we're gonna do is say, it says here in the description to add assets to your application, add an assets section. So we have to have this line here and it has to be indented properly. So the parent of this is flutter. And then assets is here. So it's indented by it's indented here. So like that you can't do this has to be like this. And then we're not going to include specific images, we're going to just include the entire directory. So we're going to say, for all the assets we're using, we're going to say what the path to the actual images directory is and then that is assets slash images, and then make sure to include the slash at the end. That way, flutter knows that you can include all the images there. So it's going to look like this. This is the blog post, you can see a note, we're going to want it looking like this. Another gotcha is you want to make sure that this is indented as well. So the actual directive here is indented properly. So we're gonna save that. And then let's implement the actual image. So let's see, we have the code here. So last time, we have our we had our location detail screen. So this location detail screen, had just three text sections, we're going to fill that out in the next video, what we're going to want to do is add an actual image banner at the top of the screen. So it's going to be one of our children of our column. So let's add that now. Let me look at what we want to do here. So because we want this to be its own widget, we're going to create a new widget the same way we'd like we created the text section widget. So I'm going to call this new widget, image banner. So this is an image widget we're going to create in just a second. And before we have an implemented, we're going to just code what, how we want to customize it. So what do we want to pass in to the instantiation of this widget, which is only in basically the file name. So that's what we're gonna do, we're gonna say, include the path to the image. So we're gonna say assets, slash images, slash, and then the name of the file. It's kind of weird, because it's Japanese, of course. So if you don't speak Japanese, it'll look weird to you. But that's the name of the file. That's the name, that's going to be the name of our location when we show the text corresponding text with that image. And know that later, we're going to change this app to be dynamic. So we're not going to hard code the image, we're going to pull it from a web service API, right? For now, we're just going to hard code it just get it to work. So next, we're going to include the widget that we haven't even implemented yet. And I'm just doing this for brevity here. So I'm going to say image underscore banner. So that's going to be the name of the file we're about to create. Remember that in darts, if you don't know already, the the the input should be in alphabetical order. So I'm going to make sure that this is before this and that it's underlined red, because we haven't created it yet. So let's create it. Now, we're going to go into our location detail folder here. And because this widget is only going to be used by location detail, we're not going to have it live anywhere else. It's a widget that's local to location detail. If it was shared across the app, we would put it in a separate place. So let's call the Let's name the file the same name of the widget, image, underscore banner, and make sure it's all lowercase. And then, since this is a stateless widget, and we're going to implement it much like we did the text section widget we did in the last video, so I'm just going to copy this code here, just as a template. And note that Visual Studio Code also gives you some options. And there's extensions to kind of use a hotkey to auto generate a stateless widget really quickly. But that's not what we're not going to cover that that's something more advanced. So let's name it to our image banner. And this is the name of our widget here. And we're not going to want to customize the color. But what we're going to do is be able to customize the path to the asset. So we're going to have a private member here. And it's going to be a string called asset path. So it's private, again, because there's an underscore here. Second, we're going to pass in asset path. So this is going to be a positional parameter to our constructor. So that means that when the person wants to use this widget, the first argument they provide to the constructor will be the asset path. And this Dart I if you didn't follow this in the last video, when we use this positional parameter, and we use this dot, and then the name of our private member, it automatically assigns the value. So really quick, if you didn't see it last time, if we just have something like this, this would be the long way of doing it. So this acid pass acid pack. So this is kind of the the long way of doing it, but we can't work. This is just better to do it this way. So let's implement our image banner now. So what we're going to do is we're going to display use the flutter widget, the image widget, but we're going to wrap it In a container, what that allows us to do is provide some options, other options like padding, or the height, and all that. So you're going to want to wrap your images in a container or some other widget like that. So let's get started on that. So there's going to be if you look at the screenshot, there's going to be a certain height to the image. So we're going to want to expand the image all the way from to the maximum, we can go in the container, but we want to still constrain the container of the image to a specific height. And to do that, we're going to use something called constraints. And that's a parameter on the container widget. And much like decoration that, you know, there's also something called You know, there's box decoration. But there's also box constraints. And what box constraints does is it lets us provide all these other options for how it the content in that container is constrained. So the most common names constructor for this is called expand. And what that does is it says, Let me expand everything, all the content in my container, as long as the height stays at 200 pixels. So to specify the height in flutter, or Dart, we're going to use a double and a double is a certain data type, you can see it here, that just basically it has a decimal point, that's all, that's all you have to know. So if you can say 200, like this, but sometimes the Visual Studio code will give you a warning, you can also do like this, but using a decimal, like a proper decimal, even if it's not zero is probably better. And that's constraint. So that's what we'll see how it works in a second, but constraints is going to say, expand all the content until the height is 200, we're going to have a decoration. And we're going to give it a decoration of a background color. We've already covered this in the other video, where you just say gray here. The reason why we're giving the container a background color is because later when we loaded as a from a URL, if that URL fails to load the image, we still want to show some kind of placeholder, not just whitespace. So that's just the decision I made. You don't have to do that. So the child now is going to be the image widget. So we just say image. And to use the image widget, we're gonna use also a named constructor. And remember, a named constructor is goes like the name of the widget, and then dot and then the name of that constructor. So there's, as you can see, here, there's different ways to name the use that different names with constructors, you can use. One of them's asset, which we're going to use, there's also file memory and network. So we'll use network later. But let's use asset for now that's basically taking any asset you've specified in your postbit camel file. So we can now just provide it the name of the asset path. So I'm gonna say asset path. And the last thing we want to cover in this video, last main thing is how image wants to expand and behave based on the screen size or the container that it's in so much like HTML or CSS, you can specify how it expands and all that. And the way you do that in flutter is we use this fits parameter. And we use this kind of value called box fit cover. So box fit, like box decoration box can constraints. Box fit gives you additional options like that. So, fit height fit with cover fill contain, you can use these in your free time and click into them and read about them in the documentation. The documentation will explain how to use these but in this video, we're just going to use a cover and cover does is it fills the image all the way as much as it can within the container that it's in. Cool, they have something similar in CSS as well. So let's save this. There's some syntax error. So we're going to make sure that we have the image asset finished here. And then the container finished and let's see what else we didn't, okay, like go like this. Make sure this is finished. And what else I need a semicolon here. That's what it was the semicolon. So I'm going to restart it. And there we go, the image loads and it's exactly 200 pixels high. And now we can get started on the text of our app. So that was the tutorial here. And again, if you want to read through the blog post, it has all the code And you can read through it in your free time. And yeah, that's it. So thanks for watching. Hey, everyone. So in this video, we're going to be covering how to use custom fonts and flutter. And we're going to be building out our screen here, where we already added the image at the top. And we're going to start adding text sections here. So a tech section will have, as you see here, where it says summary, it'll have a title, and it'll have a body. So we're going to implement that widget. And then we're finally going to cover text theming and flutter. So text steaming allows you to define all your style in one place for different types of elements in your app. And then that way your code is very clean, because it knows what kind of style to pull from. So let's get started. If you want to follow along, I have the blog post here. And to get the font files that we're going to be using the those font assets, simply checkout step slash step 04 branch of this, the code repository, and the link is in the blog post. So let's get started. Um, we're going to implement first, we're not going to quite follow step by step the blog post in the blog posts order, we're just going to implement the actual text section first, because then I can apply the font and it'll just look like nicer and be more understandable. So the first thing we're going to do is implement more features of this text section. Because right now, it's very contrived, it just shows colors, that's it, well, we want to do is remove this color, and be able to show a title and a body. So let's implement that now. So instead of color, we're going to implement two private members, one is title, and one is body, we're going to update the constructor. And this, so this dot body, so whatever you pass it in pass in here as positional parameters will be assigned to these members. And then let's basically define how we want our widget to be structured. So this, each widget can have its own layout. So in the location detail screen, we do use something called a column, we already covered that in the layout, video, but each text section will have its own column, because content is laid out from top to bottom in a column format. So it's going to be summary and then this body of text. So instead of container here, let's implement a column, and it's going to be its own column, main axis alignment is going to be start meaning the each child is going to be laid out from top to bottom, sequentially without any pattern, cross axis alignment will be stretch. So I wanted to stretch to the full width of the container. What we're going to do is remove decoration, we don't need that. And for child, I'm going to have some text here. Well, we have to say children, because it's going to be a column, and it's going to be a list of items here. And we're just gonna have title, and then the other one is body. Then we're going to end our column. Nope, we already did here, and and our children here, hit save. And then we're going to there's an error, because we have to update our location detail screen to use that. So we already have text section imported here, we don't need to do that. And now we're just going to say, well, hard codes and values in here. So we're gonna say summary, something one, and then something to something three. So later, we're going to make all this text dynamic, it's going to pull from a web server API, web API running on a web server somewhere. And it we're not going to hard code anything like the image names and all that. So cool, it looks really boring, because there's no formatting to it. So let's cover that next. First thing we want to do is add padding to each of our widgets. So to add padding to each text, bit of text here, we're going to wrap each text widget in a container widget. The container widget lets us define that, that the text doesn't. So to add padding to a container, because we want to control the different padding schemes, so we want to control padding on the left and right and the top and bottom and it's going to be different for each we're going to say const which is a constant edge in sets. And then from lt RB so that's a special named constructor for edge in sets and lets you granularly define all that padding. So because this each day This text section widget is going to share the same left and right padding, I'm going to for simplicity's sake define a constant up here. And it's, well, it's, it's going to be a static constant. And I'll get to that why it has to be static in a second. But we're gonna call it horizontal padding. And for just brevity, because I use the slot, I'm going to say h pad. And people usually will figure out what that means. The reason why it's static is because since I'm using a const, here, it just has to be static. I can't I can't, you see, if I remove it here, I can't define a constant as a as a member of a class here, it has to be static. And that's just the rules of Dart. So for the left and the right padding, it's going to have that value. For the top and the bottom, I'm just going to use a custom values and then use 32. And four, you don't really need to specify the decimal point, but I just like to because it's a double and just more consistent that way. So then we define the padding here, I'm going to end let's see text and and my container. And then I'm going to add, let me add my child. And then I'm going to add the other container. And it's just going to have different padding because of because of the fact that it's a just based on the design of the app, it's going to have different type of padding. So that padding will be let me look at my notes, it's going to be 10. And just use the same value as horizontal padding here. Save it. So cool. Now we have the things like nicely padded, and I'll add some more text here. So you could see it like kind of looking a little more realistic. In the next video, we're going to add in real text here. So let me just paste that in. Cool. So that's just really, really ugly looking text. But it shows you that it's going to flow nicely and the padding looks okay. Okay, so let's cover the style of the app. Before we do that though, the style that we're going to implement uses a custom font. And so we can implement that style without it failing until we add our font file. So let's go add a custom font. So to get the custom font file we're going to need and let me show you the screenshot that the the font looks really nice that it's this font Montserrat, I'm going to I've checked out the step four branch of the code, and I'm just going to copy the assets that already have, I'm going to do that off screen here because it's just easier. And what we're going to do is in the assets directory, we're going to have a child called fonts. So that's going to be a sibling of the images directory. And then I'm going to just paste it in here off screen, and boom, okay, so the fonts got added. So each font file, I downloaded these from Google fonts, each font file has a special like family name. And what we're going to do is in our pub spec yamo file, as you remember, the public ammo file lets you define packages that we're going to cover that we haven't used the custom package yet. It lets you define where your image assets are. So here, assets slash images. But for this video, I've implemented this already, which you're going to have to type in yourself or copy from the example code, we can define a section called fonts, and it has to be indented properly. So you just do one indentation, because it lives under the flutter section. That's very important. We're going to call it Montserrat. So the family name you define here is the family name, you'll refer to in your style when you define styles. So for each font file, I can specify the weight I want to use. So for this file, it's going to be 300, which is kind of like regular light slash regular weight. And then 600 is kind of a bold weight. So we're going to have two different weights. So make sure you save that. And the indentation is all proper. It's like using two spaces for each section. That's how YAML format ml is defining indentation. So how do we use these fonts? Well, one thing we can do is in our text section we can define in each text widget, just to get something to work, we can just say style. And then we can define text style. And then we can define all kinds of parameters for that style. But for just for cleaner, simpler code, we don't need to do that verbose way of doing things because that's going to get very repetitive. Where we want to do is to find one single style throughout the app. And it kind of works like CSS as well. And to define the style throughout the app, because we're using a material app widget, the material app widget gives us these shortcuts. And one thing, let me look at my notes here. One thing we can do here is define something called a theme. So this is how we use themes in flutter. So the theme is something general. And there's different types of theme. So we're gonna say theme, and then theme data. And theme data lets us define various how various widgets are styled in the app. So the first thing we're going to define is the app bar theme. So the app bar is a material design terminology for the navigation bar at the top. So for iOS users, it's called the navigation bar. So we say app bar theme, and you instantiate an app bar theme class. Exactly. And so that app or theme class is going to give you certain parameters. One is the just basic text theme of the navigation bar at the top. So let's define a text theme. And the text theme we instantiate here. And for the title of that text theme, there's different, there's different options you can use for text theme, you can go over it in your free time. But these are the different. These are basically all the main options for a general text theme. And I won't get into this too much. But for the sake of brevity, in this video, I'm going to find the text theme that I want to use. And instead of hard coding into my file here, I'm going to define the the text theme in a separate file. So it's nicely organized. But for now, I'm just going to type in what I want to implement. And that's going to be at bar text style, this is going to be something I defined as a custom thing. In just a moment, I'm going to now going to implement it. So to organize your style properly, what I personally typically do is I create a file called style dot Dart. And that style dot Dart is going to define all the style of my app. And what I'm going to do is import material. And I'm going to define some constants at the top because I'm just going to paste it in here. And what this does, it lets me keep my style file very succinct and clear. So I'm defining specific different categories of text sizes. And then the name of the font I want to use. This is the core family name I defined in my pub spec yamo file. So I'm going to paste this in here, this is going to be my app bar style, it's going to be it again, it's a text style. And it works. Again, it works a lot like CSS. So it's very easy to follow. It has a font family, so refers to my font name, Montserrat, a weight. So for font weights. In flutter, you can define different font weights. So they all go from 100 to 900. And because I defined one that's called 300 in my pub spec, yamo file, see here, I can use that weight. So that's the font weight, and then the font size, it's medium, it's 20. And then the colors, it's just going to be kind of white, because the fact that I have a colored navbar up here. So I'm going to save that. And then I'm going to import it in my app dark style dot Dart. I'm going to save it. And cool now our navbar is styled with the custom font you see it's kind of like lightweight here. And we'll we'll style it more later. Because that's not this is not quite the final design we want to use. But we'll we'll continue with this later. So let's finish up the style of our app. So now that we have the app bar theme, the adaptation is a bit strange looking here because of the way auto format. But for me do this so that you can read it better. And the last style we're going to define here is our style for just basically the text section. So I'm going to go look at my notes here. So for the text theme, we're going to define, there's various text theme that throughout the app that we can define here. So texting could be for various different components. So one is for just a loose something loosely named called title you can I'll show you how to use it in a second. But it's basically for any title you use. So we're going to call it a title textile. We're going to implement this in a second because this style same with the app bar text style will come from our style file. And then we're gonna say body one. So body one is just another Name we're going to refer to later in our code. And that's for any body text body style, we're going to call it body one text style. So let's implement this now in our style file, so and our style dot Dart, I'm going to paste these in. First off, I'm going to paste in the title, textile. And the title textile is going to be looking like the same thing, but it's just going to have a black color. And that's going to be large. The next one is body one textile, same thing, but it's just going to have a different text size. So body text size of 16. So now that I pasted those in, and I have these defined here, the general style for all the text in the app now is changed. So it's going to use the basic font of the style, but there's certain elements about it that are not going to be used. So for let's say, the title textile, it's not going to use this. certain elements of this, so it's not going to be large yet. So to to kind of deliberately say, hey, for this title here, let's say summary, one, I want to use the title text style, I have to deliberately go into my text section widget. And we're going to have to update that. So how we're going to update that is for here, we're gonna say, for the text widget style. And then we're gonna say theme, use the name constructor of, we're going to pass it our context. And again, our context is something we pass around in the app. And it just is a way for flutter to kind of know certain, certain contextual information about the rendering tree, the widget tree. And now we can refer to any style that we have defined here. So we can refer to text style text theme rather. So because of the fact that we defined a text theme, I'll go back to here, here. So in our theme data widget here, we defined a text theme. So now we can use it. So I could say theme of context, text theme. And now I can specify exactly what subset of my text theme. So I'm because I define a title text theme. Again, going back to App dot Dart, see, I defined a title, text theme, I can use that now. So I say title here. And I'm going to save it. And now it's using the actual text theme, I want it It's the exact text size that I wanted to use all along, I'm going to do the same thing for my body. And so I'm going to paste this in here. And I'm going to say body one. So basically, it's not going to be I don't have to do this, because it's already taking the style of that because this is just normal text. If I define a text theme of body one, all the just general text of the app is going to be styled like this. But I'm still defining this style here. And I'm using explicitly body one. Because it's just more explicit that way. It's clear. And but you don't have to do it like that. So yeah, that's, that's how you style text and flutter. I think that wraps it up for this lesson. Yeah, and we're going to just, you know, style this more later. And then the next episode, we're going to actually use dynamic text. So we're not going to hard code anything in. Um, but yeah, that's it. So thanks for watching. Hey, everyone, Nick here. So in this episode, we're going to talk about three things. One is how to use models to represent data and functionality. And we're going to update our code to make our screens dynamic, and not hard code, any data in there. And also, we're going to be covering Dart concepts such as generics, the map function, anonymous functions, and cascades. So if you want to follow along, I'm going to be going through this blog post as I go through the lesson. And you can find the blog post on flutter, Crash Course calm, and then go down to the episode working with models here. If you want the code there, the links in the blog post right here, you have to just check out this branch here I have highlighted to half of the actually have the code we're going to be implementing. So let's talk about the significance of the apps data model. So a data model is something very, very generic to any kind of app. It's not only flutter apps, it could be web app, just a traditional software application or could be a mobile app doesn't matter. So a model is basically a glorified class in darts. So when we have an app that we're going to write, the app usually has input and output. So like any software program, so the input of the data is going to be probably some data we fetch from an API somewhere. So it could be a Firebase API or a normal traditional HTTP based restful For API. So that's the input to our app because the data is coming into our app. But the problem is we need to when we take that data into our app, we need to represent it somehow in memory. And that data might be complex and might have different types of data with different types of fields to it and properties. And also that data might relate to each other in different ways. So let's say we have our tourism and co app here, the input of the data would be a list of locations that can be shown to the user. And each location could have a list of facts of that location, like fun, interesting things that you want to show to the user. So if we want to represent that data in our app, we're going to create two classes, a location class and a location, fact class. And we're going to have a relationship between them. So the model also represents the relationships between different pieces of data. So the location, model or class, if you will, will have a list item, a member, that's a list of Dart list, that's going to be a list of facts. So there's a one to many relationship between location and location fact. So all of this data taxonomy and all that stuff we're going to represent in classes, and we're going to call them models, that's just like a terminology that a lot of people use. So when we fetch the data from the API, we're going to write certain code that creates instances of the location class. And when we want to use that data, in our app, let's say we load a given screen, let's say we load a location detail screen, we can easily work with that data if we have them cleanly separated into separate model files. So So again, scrolling down here, we have the models location and location fact that we're going to create in the lesson. And again, it's going to be a one to many relationship. So that's more coming from database design terminology, one to many and all that stuff. But that's just like stuff that you should know as well, you could use that not only for databases, but also for how your models relate to each other in your flutter app. So this is how we're going to use our models I'm scrolling down here. This is how it is a given use case of how we're going to use our models. So our app loads. And then, since we don't have multiple screens yet in our app, we're going to do that in the next lesson, we have a single location detail screen, it's going to load, we're going to say, hey, just give me like from a list of given locations, based on a location identifier, or ID, we're going to also add that in this lesson, give us the name of the location, and then render it in the navigation bar. And then for each location fact, again, it's a one to many relationship between location location fact, render a given text section and on our screen. So right now, as you can see, in my simulator, I have three text sections. That's just hard coded. So what we're going to do is update the code to render a given tech session based on each fact we have associated with that it could be one fact that could be five facts, it depends on the location instance, we're rendering. So how do we add our models. So basically, I'm going to show you the best practices for when you're adding models, where to add them, and also how you can use code commenting and what the best practices are to make sure that if anyone else is reading the code that it's easy to read. So let's get started. The code example that we're going to code is in this blog post, so I am going to open my basically, I'm going to open my code here. And I'm going to explore here, and I'm going to create a directory called models. So basically, in terms of code organization, best practices. In the lib directory, there's going to be a sibling directory, two screens, the screens directory that we have, and we're going to call it models, then we're going to create a new file called location Dart. And now we can increase the size, we can just implement our location model. So it's going to be again, a class and each class in Dart is going to be in title case, meaning the first initial of every word is going to be capitalized. And I'm going to have three fields here, I'm going to have string, I'm going to a location has a given name, it's going to be let's see image path. And then it's going to be a list of location facts final list location fact and I haven't created that yet. So it's going to have an error here. Fax and then I'm going to update a constructor so that I can create this model very easily. So we've gone over this before, but we're going to use a short Cut here, where if we use this dot name, this dot image path, and this dot facts, we can, the constructor will automatically assign the values you pass in to your members. And that way, we don't have to actually implement the the class like the constructor like this. And we've gone over this previously, so I won't go over that too much. And then we're going to import which a file we haven't created yet. Location fact dot Dart, make sure that the name of your model is in single case, like a location because it is one given location. So don't make it plural. And also, that goes for the file name. So I'm going to create a file name called location facts, not facts or anything like that. It's a one single fact. And a location fact, again, its title case, let's see what we want. It's going to have title and a text, let me just paste this in because it's faster from the blog post. It's not rocket science here. So location facts gonna have title and a text. And that's really it. So no errors are here. That's great. Um, so yeah, let's see. So let's talk about how we're going to add business logic to our model. So business logic, again, is just a glorified term for just some code. And there's some rules to that code, based on your business or your what you're trying to accomplish. So we're going to implement that. And one traditional way to implement business logic is you can add them to the model directly. If it's not such a big app. If it's not, if the kind of a small to medium size app, a lot of people just add the business logic and core functionality to their models. So let's say I want to get a list of locations, I'm going to add a method that fetches those locations. And I'm going to add that method to the location class. So um, that's pretty much a common approach. So in this method, here, I'm going to implement that it's going to I'm going to paste this in, because there's a lot of code here. And I, I suggest you not typing it in because it's, it's tedious, you can just check out the code here. Let's go through this. So this is going to be a function that's static and, and static, meaning you don't have to instantiate location to invoke the function, you can just say, fetch all so this is going to be a function called fetch all, it's going to fetch all the locations in our virtual database, it's hard coded now, but in a few lessons, we're going to fetch it from an actual back end API. So we're gonna say fetch all and this is not a realistic fetch all function because usually, you would add like a, you know, pagination parameters, a fetch from one to 10, or whatever, or fetch numbers 10, to 20, or all that, but this is very trivial example, and it's going to return a list of locations. So each location we're going to call is the constructor, we're going to pass in a name here, and this is the path to the image and all these, and then it's going to be a list. And for each list item, we're going to instantiate a location fact. So this is going to be summary how to get there, etc. So it's really ugly now. But once we have an actual web service API hooked up, it'll this will all go away. And also note that for now, we are using this kind of ordered parameters for our constructors, there's, if you're having a lot of parameters, that's there's another way of doing that we'll cover in another lesson. But for now, this is like the simplest way. Great, so we have our models. Let's continue. So let's make our code dynamic now. So we're going to take and use this fetch all function, and we're going to update our location detail screen. So let's import the location class. And we're going to update the following. We're going to update the app bar title, we're gonna update this image banner and then we're going to iterate over every fact of every of the location, we're going to load and render a given text section. So how we're going to do that is simple at first, we're going to load all those locations in the build method. So we're going to say location dot fetch all and then we're going to assign a given location. So So for a given list locations is a list type. There's a special kind of property called first and that's just like saying, like this, basically, and right now we don't have multiple locations, we're going to implement the next lesson. We're just gonna assume we just have one location because we're just loading a location Details screen here. In the next lesson, we're going to pass in an identifier to location Details screen and then loaded by identity. to fire. Another word before I continue is that um, usually you don't want to load data in the build function because the build function of any widget can be called multiple times. So we don't want to be doing that. But just to get it to work for now, we're going to be doing it here. And I'll explain in later lessons, how the kind of ideal way to do it. So now we have access to our given location. So I can update the title here. And I could say location dot name, because location has a name property, as you can see here, this is the name property. And then I can say in the image banner, say location dot image path, that's the another property here. So let's reload that. And it looks like it's working pretty well. So what are we going to do with each text section. So basically, um, in Dart, there is a special function called map. And what a map does is it converts a list or an array in Dart is called list of stuff to another list, but but of another type of data. So if I have a list of, let's say, strings, I can use map to convert it to a list of actual objects, like a list of widgets, right? In our case, what we're going to do is we're going to have a list of location facts, which is an array of I'll show you the model, it's going to be this data type list of location facts. And, again, just touching over this again, this is what we call generics. So we've went over this in the last few lessons, but I want to refresh real quick before I continue, it's going to be a list of location facts. So generics is basically the ability to define a given type for specifying the type of something so you have to specify a list of something, it's a list of string, you could say list of integers. And in our case, we're gonna have a list of location facts. So that's what generics is. Anyway, where the map function was, we're going to say, for a given list of location facts, we're going to convert that to a list of widgets of type text section. So that's what map does it transforms of one type of list into another type of list? So how are we going to do that? Let's make a function where we're going to take all this stuff, we're going to cut it out. And we're going to say, some list of widgets. And, and then we're going to just add it in here, after the fact. So before we do, go ahead and do that, let me implement a function that returns that list of widgets that implements our map function. So what we're going to do is, we're going to have a list of widgets, that the function is going to return. And let me look at the code real quick, what are we going to call it, it was called text sections. So the blog post I just brought up has the kind of final implementation, but I wanted to do it from scratch here. It's gonna, it's going to take a single location. And that location is gonna, we're gonna say location dot facts. Again, it's a it's a list item. And we're gonna say dot map. And dot map takes a what's called a anonymous function. In other words, it's another word for it is a closure in Dart. And a closures are something very pervasive through other programming languages. And the syntax is just kind of weird. A closure or an anonymous function is a function, but you don't give it a name. It's just, it's anonymous, you don't have a name for it. So f is our function. And we're going to implement our function right in here. So the function because how map works, the function will take one single parameter, and the parameter is it's a given fact. So anonymous functions in Dart have three parts to it. The first part is the actual list of parameters of the function just like any other function, this is the list of parameters. And the number of parameters that's available is defined by this actual map here. So we know that if we click into it, this is pretty cryptic. This function that it's defining that we pass in will only allow us to have one kind of parameter, but I would look at this as is pretty complex. Anyways, the list of parameters, and then there is a arrow here, it's called rocket notation or something, which is saying, Hey, we wanted to find a single line implementation of our function. So in theory, we can do this we can use curly braces and implement our function here. But with this arrow does is it lets us define if it's the function is a single line, it lets us define the function as a single line of code. So we can say no Whatever we define here as a statement, it returns. So we can, if we want to return, let's say FUBAR, it'll, we can do it like this, right? So what we want to do is the implementation of this is return a text section. So remember, we had a text section widget here. And that's what we're going to implement. So text section. And then for the fact, we're going to have fact, um, what is it, a fact has a title and text. So fact, title, and fact text. So this, again, as I said, just to go over this one more time, because you're going to be using this a lot in flutter apps is map will convert a list of one type to a list of another type, right? So in here, we're going to, it's going to iterate each fact, in the facts list. And for each fact, we're going to execute a single statement, as denoted by this. And that statement is going to return what's going to be pushed into the new list. So it's going to return a text section. And we're going to re implement the instantiation of our text section. And then it's going to return it. So this is going to return a iterable kind of list of stuff. So iterable of a given type. So iterable is another thing in Dart that's kind of a kind of like a parent grandfather type of something that you can iterate over, it's something generic, but we're not going to be it's not useful to us. So what we can do is, we need to get get a list. So for iterable, we can just say to list and to list, we'll convert something that's iterable to an actual list type here. So yeah, that's it. That's the implementation. Um, we return this. And then we need to use this list of tech sessions read return here. So we can't just call text sections like this and pass in location. Because we want to add, because this is a list, we want to add it to the existing list of it, we want to inject it into our list here. So this is already our list, we want to inject it here. And basically, we're going to do this, we're going to use darts spread operator. And it's called the cascade spread is coming out in the next version of Dart. And, and that's different. But cascade is two dots. And what cascade does is it takes a given item, and it lets you run a function against it or, or make an assignment or do something else. So I'm going to say the cascade operator. And then we're just going to say, add all. So I'm going to, there's a special function in Dart called add all. And what that does is, it depends all objects have something that's iterable to the end of the list. So if we have a given list here, it's we're gonna say at all, and then we're going to pass it a something that's iterable. So text sections is iterable. And that's where we're going to do. So there's a lot to unpack there on the, but like, this is kind of a common situation. in Dart 2.3, which is coming out very soon, you'll be able to use a nother operator called the spread operator, which is three dots, and kind of kind of tack on list items like that more easily. So anyway, let's reload this screen. And yeah, there we have the text here. So all the text looks nice here. And that's it. Um, let's see what else we have to cover here. So if you want to go over what cascades are I have links to what cascades are I have a I have a link to what the map function is. Well, I have notes on it. But I also have a link to the actual documentation in the in the Dart website. So this is a link to it. And yeah, like, you know, I would say play around with this stuff. And in summary, basically, I guess that's what we cut. That's all we need to cover. So our app now dynamically adapts to whatever data we've defined. So in the next section, next lesson, we're going to be covering more advanced features, and building out a new screen. So thanks for watching. So in this episode, we're gonna be covering navigation in flutter. And also the list view widget, which is a really important widget. Because most apps are made up of some kind of ListView of stuff. It could be newsfeed items, photos, whatever. So finally, we're going to be covering gesture detector also. So we're going to be implementing the second major screen of our app, the tourism co app, and You'll be able to browse through a list of locations and tap on one to get to this detail screen that we've already implemented here. So let's get started. If you want to follow the code and and just get a copy of the code we're going to be implementing In this lesson, you can check out the repo at this blog post on flutter Crash Course calm. It's called navigation in flutter. And there's a link for the code for this lesson up here. And you have to check out the branch step slash step 06. So first thing we want to do is update our fixture data. So fixture data, again, is just test data. But we want to show a lot more locations. So we can show this list view widget easily, we're also going to add a new field to the location model, which is ID. And what Id is going to do is, it's a unique identifier that lets us pass around in our app so that we can load a given detail screen. So if I tap on location with ID two, for example, I then make a call to my back end to say, hey, fetch me all the data for location too. So we're not integrating with the backend quite yet. But that's the kind of code we're going to implement before we actually do that integration just to wire things up. So you can check out the branch to just copy and paste this new location data if you want. I'm going to do that right now. So let's open our project. So the we're going to open the location model. And right now we only have one instance of a location. So we're going to want to create three. And before we paste that in, I'm going to actually implement this ID member. So int ID for location, and it's going to be an int. different apps do use different forms of identifiers. Sometimes they use a string as a COVID. But in our case, we're just going to use an old fashioned just into, so we have to update our controller here, our constructor rather sorry. And then I'm just going to paste in what I have here to the side. And that'll be a lot easier. So boom, done. That's it, let's make sure we have the images in our app. So every location refers to an image. So an image file locally later, we're going to be loading it from a URL. So right now I don't have all the images. So I'm going to have to take the images from an exhibit the ranch called step slash step 06. And I'm just going to copy it now off screen. So I've checked it out off screen, I'm going to copy it, and then I'm going to now paste it into the assets directory and the images subdirectory. There. So I'm going to paste it in and boom, they show up right here. So make sure you have these images here or else they won't show up. Great. So let's go back to my blog post. So as you know, in every lesson, I follow my blog post, so if you want to see the show notes, you can as I talk, let me increase the size for you. So our fixture data is done. So next thing we want to do is implement a new screen, which is the location listing screen. And this is going to be a stateless widget because it's not going to need to maintain any state. And it's going to also use a scaffold, which is that it's that convenience widget that lets us create a new screen. And we're going to create a ListView inside of it. And a ListView basically takes in a list of items, whatever that is, it's just a bunch of data. And it will render those items and automatically scroll let you scroll those items. If there's you know, if it overflows the screen. So this is the boilerplate, as you see in front of you for the list, how we would use list view, we would basically fetch all of our locations and pass it, map them. And we've covered map in the last lesson. So if you don't know about that, check it out. And for each location, we're going to display the locations name period. And that's it. And then we're going to return a list for the list view. So let's continue on here. I will just implement it now. And we can build upon this so we can add an image or make it tappable or whatever. So let's actually implement this. Okay, let's continue here. Um, so open the so the screens directory It shows all of our existing screens right now there's there's one folder per screen, we already went over code organization. So this is how we're going to continue to organize our code. So I'm going to hit New Folder. And we're going to call it locations. Because it's basically a list of locations. And for naming your screens, you want to basically name them as simple as possible. So you don't want to you don't want to name it location listing, it's just too verbose. You can if you want, but it's just too verbose. So I'm going to call it locations. And because it's the main screen, I'm going to name it the same name as my directory. And that's really important to be consistent. So let's start implementing this. I'm going to paste in the boilerplate code for a stateless widget, and also our imports. So I need to import app dot Dart and also the location model. So in terms of the simple screen, pasting that in, we want to use a scaffold. So I'm going to paste that in because we already went over this before, let me increase the text size for you. So and then I'm going to hide the left panel here so you can see it better. So the scaffold takes in a body, as you know. And let's go ahead and implement ListView. So we say ListView. And so there's different versions of ListView. You can use right now we're going to use the traditional ListView. constructor, there's some named constructors we're going to use later but we'll cover that. So if you're used to list view already in your, you're implementing it in a different way, just like just follow along and, and just see how I implement ListView. Because the main way to implement it is there is a children parameter, and that children parameter takes the list of a list of whatever you want to render. So it's going to be a list of widgets at the end of the day. And for now, we're going to make it really, really simple. So let's go back to the example in the blog post, right, now, we're going to just implement a list of text widgets. So let me when I fetch my locations, I'm gonna say map. And map takes a is basically an anonymous function. So So for each item in the map, which is a location, I'm going to execute the following function, and that function is going to return a widget that represents each item in my list view. So I'm going to return a text widget. And I'm just going to use the location name for the text widget. And then finally, I'm going to convert it back to a list because map returns an iterable type. And that's more of an advanced type that you don't really need to know about right now. But you just have to convert it back to a list because that's what children is, it's a list of widgets. So we have to say that, and let's see, I guess that's it. Let's see if that rendered. So I have my emulator open here. And we have the detail page open now. So now we have to update the app dot Dart to kind of show this view right here. So let's go to App dot Dart. And a shortcut for opening things in VS code is command p, or if you're on Windows or Linux, it's Ctrl P, and then you just type the name of the file. So that's really useful. So basically, the homescreen is now not going to be location detail that was just there. For example sake, it's going to be now location. So let's update our imports. And I'm going to update this, save it. And now let me let me just do this here, bear with me. That way, you can see the code on the screen here. Cool. Now, this is a very basic list view doesn't look really cool. It just shows like a single name. And that's it. There's nothing fancy about it. We're going to be adding an image for each item here later. So Oops, I'm going to show you that. So I have the mock up of like the actual end result of our app here. And I've showed it to you before. Let me open it for you here in a new window. Because it's not let me show it to you. Let's see location list. Yeah. So this is going to be our final ListView, we're going to implement the list view is going to have one image per item. And it's going to have a widget at the bottom with with the name, the opening times of the location, and just the some subtitle. So that's what we're going to get to so we're not going to render those images quite yet though, so great. Now let's we let's cover how to interact with an actual list view items. So we're going to implement a gesture detector. And the gesture detector is something very basic in flutter. Most other widgets already include the ability to detect a tap, it could be in the form of a button, or whatever. But a gesture detector is the kind of parent type that's can be used for really any widget. So we can wrap anything with a gesture detector and actually pass on an anonymous method. And that method can do whatever we want. And in this case, we're going to navigate to the location Details screen. So let's implement a gesture detector. So basically, to implement gesture detector, it's it's its own widget. So because it's, it's just a widget here. Let me just do a word wrap here, wrap. Great. And I'm going to hide the left bar here. So it's another widget. So we can wrap the text widget here with a gesture detector. And a gesture detector has a child, which is going to be the actual thing. And let's see child text there, and then and the parentheses here and save it, it's going to automatically format. And it's not going to do anything yet because we have to implement a new kind of parameter here. So instead of only providing a child, there's another parameter you're going to provide, which is called on tap. And on tap takes, let's click into it to see how you implement that. An on tap is a type of gesture tap callback. And if you type tap into gesture tap callback, if you click into it, you're going to see it's just going to be a function a general function. So you can click into this as much as you want to see how things are implemented. But just trust the process for now that it's it's going to be a actual function, anonymous function. And let's implement that now. So because it's just a generic function, it doesn't take any parameters. So we're going to do the parentheses here, because without any list of parameters, and then the arrow here, the rocket notation, and now we're going to implement the function for on tap. And because it's a little bit more complex, we're going to pass it the name of another function so that we're not implementing the function right in here. With like a block, it's going to just get too messy. So we're going to implement a function called on location tap. So it's really important to name your functions very explicitly. So we're tapping a specific location. What's not ideal, in my opinion, is to name it something like handle tap, or handle location tap, well, I guess the handle location taps fine. But on location tap is something a little more concise. And it's already like explicit that it's a handler. So on location tab, um, I think is the best terminology. And it's important to be good about terminology when you code something because it makes sure that your code is nice and concise. Okay, so let's implement this now. Um, it's gonna, we're gonna pass in the context. So as you're gonna see, in a sec, we're going to need to use this context variable. And what we're going to do is pass in the ID of the location, what's important is, we're not going to pass in the actual location, because in Dart, it's going to make a copy of that location instance. And that's not really memory efficient, what we want to do is pass only the absolute minimum data we need to any function we're going to use because because we don't, again, we don't want to copy actual entire object instances. So we're going to do that. And let's implement that method right now. So because this method doesn't return anything, we can say void on location tab, but what I usually do is I just leave out the void. If it's returning void, you can just omit that. And it passes a build context. And then the location ID. And so what this is going to do is going to know navigate to the new screen. So now let's talk about navigation next, before we actually implement it. Okay, so before we start any implementation, let's just talk some navigation concepts. So in any mobile app, navigation works like a deck of cards where every card in the deck is a screen. And when your app loads for the first time, it's only going to start off with one card because there's only one screen loaded. And that is defined in app dot Dart here in the material app widget by the home parameter. And we already went over this, but that home is the starter screen for your app. So your app just starts and it starts with one screen and one card in the deck. Now when I tap on an item in my list view here, which we're going to implement It's going to load a new screen, it's going to load the location detail screen, which is another card in your virtual deck of cards. And it's going to take that card and move it on top of the other card in your deck into the view for the user. So that you're pushing and popping cards at the end of the day. So it's basically in computer science terms of stack. And that stack, you can push more cards on top of the deck. And the card on the very top of the deck is what shows to the user and when you want to go back. So let's say they tap the Back button, that card slides off the top of the deck, and the previous screen is still there for the user. So the previous screen is still in memory. So when we define a series of screens in our app in flutter, and a lot of other kind of mobile frameworks, you're defining a list of what we call routes. And that borrows from web app development terminology where a route is a basic URL that is a path to a page. So the home page route is just slash. Another screen route is like slash, whatever. So in flutter, you're defining routes, and these are called named routes, because for every route, you're giving it a name. So let's define that. There's a parameter here in material app called routes. Now, ultimately, we won't be using this parameter, because I'll show you the shortcomings of it. But for very simple applications, it works really well. Because if you don't have any kind of like fancy context, you want to pass to your new screen, it works fine. And I'll explain that in a second. I'll explain what I mean by that in a sec. So let's open up the blog post to show you the example here. And I'm just gonna copy and paste this in. Because it doesn't make sense to type it all out. So in a very, very traditional app, when we have routes, we have the slashes, the just we can call it whatever you want. But it's usually using slash as the home screen. This is the first screen that loads, right. And instead of home, we can say like initial route, and we can just refer to that route by name, because the name of that route is just slash. When we want to navigate to another screen, we have to do first to find that route to that screen. And that screen is like slash second or like FUBAR or whatever you want to name it, right. And to navigate to that screen, then I can refer to that screen by name or the route name. So I can say navigator pushed named context, slash, and then you know the name of the route. So going back to my Detail page, if I tap on a location, I can say, navigator, which is a to basically work with navigation in flutter, there's a class called navigator. And you say push names, which is a named route, and you pass it the build context, and then the name of the route you defined, very simple. Now, the shortcoming to this is like pretty clear. Because if your second screen needs to pass any parameters, if you need to pass any parameters to it, like FUBAR, whatever like this, right? Where are you going to get the values to those parameters? That's a shortcoming because there's no way to define how those parameters that data is going to get there if those parameters are dynamic. So for example, if I have the location, detail screen here, location detail, and I need to pass the ID of the location we're loading, how am I going to know what Id that is? By defining it up here in material route? So there's a solution that we're going to implement and it's standard flutter, but it's not like documented very clearly. It's it's kind of a little bit more ways into the official documentation. So I don't recommend defining routes like this, because they're really it's just that's that's the big shortcoming to that and I hope that makes that explanation makes sense. So let's basically take a pause, and implement the location detail screen on how we need to load it because I can't implement a working example of location detail screen unless we update it. Now, we went over the fact that the location Details screen right now only takes it doesn't take any parameters. Look, it just loads any random location, right? This is my location Details screen, it just fetches all locations, and then it says whatever first location have just loaded. So we're not going to have to quickly update the location Details screen to take in a parameter. So let's go do that now. So we're going to have an int as a private member called location ID. Now remember, this is still a stateless widget because location ID we don't need this data to react to any kind of state changes. It just loads this location ID when it loads and That really doesn't change. So let's create a constructor now, a custom one, so that we can load the location ID and make an assignment to the private members. So I can call location detail pass in the ID. And then we're going to need a way to fetch a specific location by ID and then loaded here, and we don't have a method for that. So the only methods we have in the location model is just fetch all. So we're going to have to implement a method that closely resembles what we're going to ultimately be implementing, which is a call to our back end service, which fetches a model by ID identifier. So let's go ahead and implement a function called fetch by ID. So we still have the fetch all that that's going to be used still. But I'm going to implement static a static method, because we don't need to instantiate a location. And it's going to return a location, fetch by ID. And that's going to be the name of and we're going to pass in a location ID. And then, what we're going to do is, whenever you implement a function that the easiest way to implement it, is just to write out pseudocode. So and then implement that, because it's just easier to implement. So we're going to say, fetch all locations, iterate them. And when we find the location with the IDB wants a kind of return, it's immediately. Of course, it's good to get this is a trivial example, we're going to be replacing it with a back end API call. But it's it's not an efficient way of kind of implementing this, but it gets the job done for now. So we're going to first fetch all our location. So we're going to say location fetch all and, and then I'm going to have a for loop and in a for loop in Dart is pretty strict, simple, it looks like a lot for loops to use in other programming languages. So I don't need to explain too much. So we're going to say, iterate all the locations, and then, um, locations I, so the location at index i, if the ID matches location, Id return immediately, the location at index i. And I know you're saying we can probably load all the locations and a map and instantly fetch those locations via a map. But this is just a simpler example. So we're going to have now fetch by ID. Now later, we're going to be going over this is an error because we're not implementing haven't fully implemented our screen yet. In the future, you're going to write a natural test for this. And we'll go over testing later like that, you're not going to just write functions, and then just expect them to work, it's best to have a unit test for that. But that's it for another episode. Also, let's move this method down here. So that because it's a little bit more of an explicit method, and we want to show all of this data up here, just to make it nicer looking. So now let's implement the location detail. And the location Details screen, we'll call this method. So we're gonna say location fetch by ID. And then we can pass it simply our location ID, and name it the variable location, and then we can remove this. So now, we, we will just this is working fine. We can instantiates location detail instantiates, it has a location ID automatically and then when the screen loads, we fetched by ID Great. So now, let's implement. Basically, we can implement push named as I talked to you about like, like, we have to pass in an actual ID. So I'm going to now go over how to pass in dynamic arguments to the screen we want to load. Okay, so let's implement what we're actually going to be coding at the final implementation of this. So instead of it, we're not going to use the normal push names, we're going to use a more extended version of push names. And we're going to pass in an argument to push name, which is the ID, the location ID here. So let's implement that now. So before we do that, first, I'm going to go to App dot Dart. And this is how I personally implement this. Like there's many different ways of implementing routes, but I'm going to have two constants at the top of app because constants allow me to define like refer to location route globally, by the actual name without having to it just prevents mistakes. So I can refer to location name, by an actual, like variable name and in constants in Dart should be starting with Capital letter. So this is going to be in title case, these aren't classes. They're actual variables. So they look like classes, but they're actual variables. But again, they're in title case, because they're constant. So I define all the names of my routes up here, I have the home route, which is just slash, and the location, detail route. Now, when you pass the slash route to flutter, it's already going to know, hey, this is my first screen, I'm going to load. Great. So now let's go back. And now I can say, push named, and then locations route. And then I'm going to show you how I can pass an argument to that. So we're going to have to pass this location ID to this push named function. And to pass an argument to it, there's an arguments parameter. So for push means we have arguments, and all that arguments is a map, so a map type. And then we can define whatever we want here, I can say ID, and then location ID. And our screen is actually going to use this, and I'll show you in a minute how it's going to use it. So we're going to refer to it by name, like ID and then the value location ID. And we're going to remember that we use this ID key to our map. So let's continue on. So in app dot darts, here's what we're going to do, we're not going to use the routes parameter here. So I'm going to remove that. Also, we don't really need initial route, because we already have a route called slash. And that just loads First, we're going to have, we're going to use a special parameter called on Generate route. And on Generate route is giving us a dynamic list of routes. It's in the form of what's called a route factory. And route factories is the fancy term, which is a basically a payload, that of data, it's a chunk of data that just says, Hey, here are my routes. So let's create a pass it a function we're going to implement, it's a private function. So starting with underscore called routes. And now we're going to implement that here, because it's in our app dot Dart, it's on the highest level, it's easiest to define that here. So it's gonna return a route factory. And I'll show you what that route factory is at the end of the day, in a second, rather, um, and this function is going to return some data. So it's going to return an actual function. So if you click into on Generate route, that is a route factory. Let's click in a route factory. And route factory is actually a function that takes in a bunch of settings, and returns a route of type dynamic. So I won't like drill into this too much, let me implement that. And that will make a lot more sense. But what we have to do at the end of the day is return a function. So a function with the parameter settings. So we're going to use settings here. And I'll show you how we're going to use settings. So first, we're going to get the arguments to our whatever route was tapped. So arguments. And settings has this member called arguments. So we can use this settings for getting all kinds of information, but arguments is one of them. And now we're going to create a variable called screen and screen is the actual widget and the final screen that's going to be returned to us based on the name of the route. So the name of the route that we have is defined as settings dot name. So if a user taps on whatever they tap on, the given route that that they're wanting to reach is defined by the name, which is going to be either slash or slash location detail. And what we're going to do is use a new feature of Dart called switch and switch let's it's basically a glorified if and then else if statement. And it has can have as many else ifs as you want, but it's just a more concise way of saying if something and then else if something and then else if something else, right. So instead of doing that, we can say switch, and we pass it the name of the route. And then I can say, in this case, if it's the locations route, I'm going to do something custom, I'm going to say, my screen that I want to return is a basically a new instance of the locations widget. And then I'm going to say break because in a switch statement, it will go through every case until it breaks or you return something. So next case is the location detail routes. And remember, every case has to be ended by a colon, not a semicolon. That's really important and most programming languages have Have a switch statement. So most of you, if you're familiar with this, it, this is going to look like second nature to you. So for the location, detail route, if I want to navigate to location detail route here, and that's defined by slash location detail, I have to do something custom now. And I'm going to say location detail. And I'm going to use my arguments map here. And I'm going to refer to it by the ID key. And that's what we defined here. So locations, the arguments is a map, and there's a key in that map called ID, you should use single quotes, by the way, by default, um, and then, and now it can instantiate with a custom arguments. So now I have my screen, I have to import it real quick. Location, detail, location, detail, grades, and now I can return it. So break. And now, the switch statement has this final case, which is if none of the cases match, there's this default case, and you define it with just default colon. And then by default, just running going to return null and do nothing. And then finally, what I'm going to do is return what's called a material page route. And you we know that we need to return this because a route factory is a function. And, yeah, I won't get into it too much right now. But let me just say that you expect some material page route to be returned, right. And material page route is a type of is basically a type of route. So going back to the basically the route, factory type, material page route, basically, I didn't want to get too much into it. But it is a type of route. So you can use any type of route. There's multiple types of Route, but the most popular is a material page route. And then material page route takes in a builder, and I wouldn't worry about builder, all it is is a fancy fancy way of being able to pass in something dynamic, like an anonymous function here. So the syntax is a little weird, but basically, it's a function that takes in a context. And you say, Okay, what, what am I returning, I'm returning my screen widget. And that's it. So I know this looks a little weird. But basically, this is how we define all like, all the routes in our app that needs to be dynamic. And what's nice about it is that it's defined upfront in our app widget. So let's get this working. And then I'll show you how it's going to work now. So on Generate route is routes. And before we get to working, I'm going to quickly clean this up real quick because I want to use the I'm basically going to take my theme data before this, before we get into work real quick. Let me just tidy this up because it looks pretty, pretty, pretty ugly. I'm gonna say theme data, sorry for the tangent here. But I want to just put this here, and I'll show you how easy it is to quickly get this tidy up. Great. So our main screen is very clear on our app widget we have just on Generate route and our theme. And it's in a method here so that it's nice and clean. Cool. So now that we've gone over that it was a little tedious. But let's see if this will work. So let's check our code again, push named Okay, this should work. Let's see if this works. Cool. Now, it's not loading the location Details screen and see it's just like loading the location screen. So let's troubleshoot why this is happening. So in our app dot Dart locations to those location details, that location, detail route, and to the name, we're loading his seat, location, detail route. So we have to push named location detail routes, and let's hot reload this. And when I click on something cool, it comes up. So we got it working. I can go back and when I go back, it will pop it off the route. So there's no, you don't need to implement this pop method. Like you don't need to manually write some code that says, push this card that's on top of our deck off the stack. It'll just do it automatically. Because we're using the material apps, material designs app bar widget. So app our widget automatically will show a back button when the screen appears if it's not the home route, saying cool. So in our next episode, we're going to actually implement that the beautiful location listing screen. But this is just the nitty gritty kind of mechanism for navigation. Let me make sure I didn't miss anything. Because the blog post basically explains in detail how this is all implemented. And it gives you also links to the documentation. Let's see. Yeah, I guess that's it. Final app dot Dart file. Cool. And I talked about going back and all that stuff like that. So there might be a better way that you have for implementing routes that are dynamic that need dynamic parameters. But, you know, feel free to reach out if you have a better way of doing this. But for now, and how flutter is implemented. This is pretty much the most clear cut way of doing that. Everything's defined up front in app dot Dart. So thanks for watching and yeah,
