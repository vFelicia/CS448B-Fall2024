With timestamps:

00:00 - hello everybody my name is tatus petra
00:02 - and i run the amateur coder channel
00:04 - where our goal is to explain things so
00:06 - simply that even amateurs can understand
00:07 - it
00:08 - and that's my goal for today's video as
00:10 - well to be able to explain how to build
00:12 - a complete production ready app from
00:14 - scratch as simply as i can
00:16 - so the topics we're going to cover today
00:18 - are planning which in my opinion doesn't
00:20 - get covered enough and i think it's one
00:21 - of the most important parts of building
00:23 - any software
00:24 - some other steps you take before you
00:26 - start building an app
00:28 - building an actual app then there's
00:30 - three types of testing that we're going
00:31 - to cover
00:32 - and finally maintainability
00:34 - and hopefully by the end of this video
00:36 - you'll be able to be confident about the
00:37 - apps that you're releasing to all the
00:39 - app stores i'd like to thank free
00:40 - codecamp for giving me this opportunity
00:43 - and i think all my links will be in the
00:45 - description if you want to check them
00:46 - out
00:47 - and let's get into the video
00:49 - okay so today the app we're building is
00:51 - going to be a very simple to-do app
00:53 - now the code for this app isn't going to
00:55 - be too complex but we're going to focus
00:56 - on the process and make sure we go
00:58 - through all the steps necessary to be
00:59 - confident about launching our
01:01 - application
01:02 - and to start with that is planning i
01:05 - think planning is the most overlooked
01:06 - topic when it comes to creating any type
01:08 - of software especially creating an app
01:11 - we're going to focus on two main parts
01:13 - of planning today one of them is
01:15 - requirements
01:19 - and then design
01:22 - so what are requirements it basically
01:24 - breaks down the big requirement of build
01:26 - a to-do app into smaller sections that
01:28 - are more achievable and that you can
01:29 - test at the end
01:31 - so we're gonna have requirements like
01:32 - the following we're gonna have
01:35 - create
01:37 - account
01:38 - be able to login
01:41 - be able to sign up
01:43 - only display
01:44 - not finished to do's
01:47 - keep the list
01:50 - synced up with firebase
01:53 - and lastly if no to-do's say that
01:55 - there's no unfinished dues be able to
01:57 - add a to-do and check off to do's
01:59 - now for each of the topics we're going
02:00 - to get in today there's whole
02:02 - methodologies about how to do them and
02:04 - just like for example requirements
02:06 - there's ways to actually structure the
02:07 - sentences in a way
02:09 - using words like shao and must
02:12 - but today we're going to keep it simple
02:14 - if you're interested in any of these
02:15 - make sure to do more research we just
02:17 - can't cover it within like a couple
02:19 - hours
02:20 - so we got eight requirements for this
02:22 - app now let's get into the design a
02:23 - little bit
02:24 - so with design i like to use adobe xd
02:28 - and there's other options like that you
02:30 - can use but for this one we're just
02:31 - gonna do some very basic
02:35 - drops
02:37 - so we'll have the
02:39 - login screen and then we'll have a
02:42 - logged in screen so here we're going to
02:43 - have a field for
02:44 - the email
02:46 - the password
02:47 - and then a login button and then a
02:50 - register button
02:53 - nothing too complicated
02:55 - then once inside we'll have an app bar
02:58 - with a
03:00 - sign out and then
03:02 - add to do
03:06 - and then down here
03:08 - just a list of to-do's you want to kind
03:10 - of get gain a vision for how the app's
03:12 - going to work and make sure
03:14 - all the parts are thought out for
03:15 - example if we didn't think about the
03:16 - sign up button at the top and we wanted
03:18 - to put something else at the top it gets
03:20 - a little clearer up there you just want
03:21 - to think about it
03:22 - now the design doesn't only include how
03:24 - the app looks
03:26 - there's also the architectural design of
03:28 - it
03:30 - so for this app it's pretty simple we're
03:32 - going to have
03:33 - we're going to have the main
03:35 - which will
03:36 - check for authentication
03:40 - and this is not a widget this is just a
03:41 - check then if the authentication data
03:44 - hasn't been received
03:46 - we're going to show a loading screen
03:48 - if there's an error we're going to show
03:50 - an error screen
03:52 - if there's no user logged in we're going
03:53 - to take them to the login screen
03:56 - and then finally if they are logged in
03:57 - we're going to take them to the home
03:58 - screen
04:00 - now inside these two
04:04 - inside the login screen will have a
04:08 - username widget
04:10 - a password widget
04:15 - and then two buttons
04:17 - then on the home screen we're going to
04:18 - have a
04:20 - sign out button
04:22 - and add to do widget
04:24 - and then a list of the to-do's
04:31 - so this is pretty much the way to treat
04:33 - there is software like jaw.io that you
04:35 - can use but
04:37 - this works for us
04:39 - so that's all the planning we're going
04:40 - to do for this specific app but a more
04:42 - complex app should have
04:44 - days or even weeks of planning in my
04:47 - opinion
04:48 - the things you need to think about are
04:50 - object oriented principles and stuff
04:52 - like that you can look up the
04:54 - principles called solid and
04:57 - grasp those will help you
05:00 - separate the widgets out and keep your
05:02 - architecture clean
05:04 - all right and next is to create some
05:05 - sort of version control and some way to
05:07 - be organized
05:08 - i think almost everybody uses github
05:10 - nowadays so make sure you create a
05:12 - github project and
05:14 - create some tickets and issues in there
05:16 - that you want to work on things like
05:18 - that
05:19 - and then finally we can start on the
05:21 - code so
05:22 - so i'll go do that right now i'll set up
05:23 - a new flutter project and a new firebase
05:26 - project and connect to it
05:28 - okay so we got our firebase project with
05:30 - the email and password sign-in method
05:32 - enabled we're able to run our app once
05:34 - to make sure it works
05:35 - so then i imported these three packages
05:37 - so we could use everything we need with
05:38 - firebase and then also lint along with
05:42 - analysis options.yaml so we can have a
05:45 - static analysis tool
05:47 - that
05:48 - tells us where we can improve our app
05:50 - performance so here you see problems
05:52 - with const
05:54 - we can add that before
05:58 - and now our app will technically be a
05:59 - little bit faster
06:01 - now we got a little bit more preparation
06:02 - before we're ready to start i'm going to
06:04 - set up our folder structure folder
06:06 - structure is very important to make sure
06:07 - you have everything organized
06:09 - and you can access it real quickly so
06:12 - this is the one i use but every project
06:14 - should be a little bit different
06:16 - depending on what it needs
06:18 - so i have a screens folder
06:21 - a models folder
06:23 - a services folder
06:26 - and a global widgets folder
06:29 - or we'll just call it widgets
06:32 - so models are like bits of data that go
06:34 - together for us we're going to use a to
06:36 - do model
06:37 - which will basically consist of data
06:39 - that is included within every to-do
06:42 - then we have screens we're going to have
06:43 - the login screen on the home screen
06:45 - services we're going to have two
06:46 - services authentication and the database
06:49 - service
06:51 - and then we have global widgets
06:53 - we're only going to have one in there
06:54 - called the to do card
06:56 - which basically will make all our
06:57 - to-do's look the same
07:00 - so now we're ready to start not yet
07:02 - there's still some more decisions to
07:03 - make
07:04 - now the final decisions you should think
07:06 - about before starting your app whether
07:08 - you want to do tdd which is test driven
07:10 - development this is actually a really
07:12 - great way to write apps but
07:14 - i personally don't like it too much
07:16 - because i find a little bit boring i
07:17 - like to write a little bit of code and
07:19 - then write the test for it right after
07:21 - then there's
07:23 - the state management decisions for us
07:25 - we're not going to use any state
07:26 - management solutions other than set
07:28 - state because it's such a simple app but
07:30 - state management is a huge topic and
07:32 - will definitely clean up your app
07:33 - architecture a lot so definitely take a
07:35 - look at the top three our provider get x
07:37 - and block
07:39 - so you could take a look at look at each
07:40 - of those and see which one you prefer
07:42 - and now finally i think we're ready to
07:44 - get started
07:45 - so one thing to keep in mind when you're
07:46 - building an app keep things simple and
07:48 - keep them iterative
07:50 - so that means do one small part at a
07:52 - time make sure you check all of it
07:54 - everything works and test it all those
07:55 - things
07:57 - so the first part we're going to start
07:58 - with is getting our connection to
08:00 - firebase working
08:02 - so this part's actually pretty simple
08:04 - there's a new firebase.flutter.dev
08:06 - website that
08:08 - kind of helps you out
08:10 - and this is the initialization code that
08:12 - we're just going to copy
08:14 - and
08:15 - paste right in here
08:21 - so
08:21 - the code in here runs the app
08:24 - you first initialize the app
08:26 - and return a future builder
08:29 - which depends on that initialization
08:32 - so this future builder pretty much
08:35 - takes in the future and builds depending
08:37 - on what state that future is in
08:39 - so if the future has an error we're
08:41 - going to return
08:44 - a scaffold with
08:47 - a center
08:49 - child
08:52 - text error
08:56 - very simple and then you see the blue
08:57 - that's our linter popping up saying we
08:59 - need to fix that
09:03 - then if our connection is done that
09:04 - means it was successful
09:06 - and you can go to your app
09:08 - we're not going to touch that yet
09:10 - and then the last case is it's still
09:12 - loading that if it doesn't have an error
09:14 - and it's not done yet then you know
09:17 - the only option left is it's loading
09:19 - we're going to return the same thing
09:21 - except we're going to say loading
09:23 - now the most important part if the
09:25 - connection is done and secure we're
09:27 - ready to move on to our app
09:29 - also one thing to keep in mind we're
09:31 - going to go through this code a little
09:32 - bit fast because
09:33 - there's a good amount of code in there
09:35 - but we want to mainly focus on the
09:37 - testing aspect of it
09:38 - but i still want to go through the code
09:40 - a little bit so you kind of get like a
09:41 - thought process of how
09:43 - you think through building an app
09:46 - so we have our firebase connected
09:49 - now there's another precondition we need
09:51 - to check whether the user is
09:52 - authenticated or not
09:54 - so we're going to do it inside
09:56 - a root widget
09:58 - which is going to be stateful
10:01 - so you can put this in another file but
10:04 - for simplicity i just put it in here
10:07 - and this is going to send us to our root
10:09 - so root is going to decide where the
10:11 - next page is
10:13 - so now inside our widget we're going to
10:14 - create our firebase auth instance
10:20 - firebase auth
10:22 - i'll call it auth and then
10:25 - firebase.instance
10:29 - and then while we're here might as well
10:30 - create a
10:32 - firestore one
10:35 - firebase firestore
10:39 - so then we get into the actual return
10:40 - type
10:42 - i like to use a stream builder for the
10:43 - authentication because anytime anything
10:46 - changes with your authentication state
10:47 - it'll be updated because it's being
10:50 - streamed
10:52 - so the way we do this is we need to give
10:53 - it a stream
10:55 - and our stream is actually not defined
10:57 - here
10:58 - so we're going to have an auth stream
11:01 - so remember i told you there was going
11:02 - to be two services that we have one for
11:04 - connecting to the database which is
11:06 - firestore and then one for the
11:07 - authentication
11:09 - so let's do the authentication part
11:14 - we'll have a file called auth.dart and
11:17 - here
11:18 - we'll have a class called auth
11:24 - we're going to pass in a firebase
11:28 - auth instance
11:33 - and does create a constructor for it
11:36 - and we're going to have three functions
11:37 - in here one is going to be a stream
11:40 - of
11:40 - type user which is a type return from
11:44 - firebase
11:46 - now we're going to get that from auth
11:48 - off state changes
11:49 - so any time the state changes will get
11:52 - returned a user and all the data for it
11:55 - so just like that
12:00 - then we'll have three other functions
12:07 - one's going to be called create account
12:13 - where we're going to need to pass an
12:15 - email
12:16 - and a password
12:20 - anything that's related to future i
12:21 - always make sure to wrap in a try and
12:23 - catch
12:24 - because if anything goes wrong then it
12:26 - gets caught here
12:28 - here we're not going to actually do
12:28 - anything we're going to re-throw it back
12:30 - but if you want to create any actions
12:32 - based off of a problem occurring like
12:35 - maybe a snack bar you want to make sure
12:36 - you return
12:38 - whatever you want to return
12:40 - then inside this try catch we're going
12:42 - to have
12:44 - create user with email and password
12:47 - really simple passing the email
12:49 - password
12:54 - and we're actually going to do
12:55 - email.trim
12:57 - just in case they put a space after it
13:01 - then if that's successful
13:03 - we're going to return
13:06 - success
13:08 - and now the reason i made a return a
13:09 - string is because we're going to also do
13:12 - an on
13:13 - firebase auth exception
13:16 - now we're going to catch that as well
13:20 - and return
13:22 - a dot message for that
13:24 - so basically
13:26 - if there's an exception from firebase
13:27 - auth
13:28 - it catches it in this variable e and
13:30 - it'll return a message for you basically
13:32 - why it failed
13:34 - then we can return that from this
13:35 - function give a little snack bar or
13:37 - something telling them
13:38 - that it failed
13:40 - and why
13:41 - so we have two more functions one for
13:43 - signing in and one for signing out
13:46 - i don't think we need to go through that
13:47 - they're going to be pretty much the same
13:59 - all right so that's it that's our three
14:00 - functions that's all we're going to need
14:01 - for the authentication
14:03 - notice how clean this code is all we're
14:05 - going to have to do is call this create
14:07 - account function and everything is going
14:09 - to be handled for us
14:11 - so now in the main we finally have
14:14 - our auth
14:16 - class
14:18 - and remember we need to pass in
14:21 - a parameter called auth
14:23 - and then the string that we're looking
14:25 - for is for the user stream
14:29 - this error as we'll see is because it's
14:30 - not a named
14:32 - parameter and you just do that by adding
14:34 - in brackets
14:36 - to make sure it's named i like to make
14:38 - sure everything is named for myself
14:41 - so we have our stream defined now
14:45 - the builder
14:47 - notice everything's filled out for us we
14:48 - have our context and
14:50 - a snapshot of our current user
14:52 - if our snapshot
14:55 - connection state is equal to connection
14:58 - dot
15:00 - dot active
15:01 - which means our authentication stream is
15:04 - active basically
15:06 - otherwise you want to return another
15:07 - loading state just like that
15:11 - now if it is active we have a couple
15:13 - more conditions to check
15:16 - so snapshot.data
15:20 - and we can look for the uid
15:23 - if the uid is no then we know there's
15:26 - nobody logged in
15:28 - otherwise uid is not null we'll know
15:31 - there's someone logged in
15:32 - so these two screens are going to be
15:34 - real simple so i'll make those real
15:35 - quick and be right back
15:38 - all right so both of those are done
15:39 - they're both very simple
15:41 - the login screen has two text form
15:43 - fields and two raised bonds that don't
15:45 - do anything just now
15:47 - and the home screen just has an app bar
15:53 - so here
15:55 - if the snow return
15:57 - login
15:59 - with an authentication
16:02 - of auth
16:05 - and a firestore of firestore
16:09 - now we're doing a lot of passing
16:10 - authentication and firestore everywhere
16:13 - this is why i think you should use some
16:15 - sort of state management because you
16:16 - only need to pass those around
16:17 - everywhere but
16:19 - it's not too bad for us
16:22 - then over here we're going to return the
16:24 - home screen
16:27 - and we're going to need an auth of
16:29 - auth again
16:31 - and firestore of firestore
16:35 - now within the to-do widget
16:37 - we have the two functions for signing in
16:39 - and create an account
16:41 - all we do here is call those functions
16:42 - we created so this will return a success
16:45 - or the error message if you remember
16:48 - we're gonna need to do auth and sign in
16:51 - the user
16:53 - with
16:53 - email
16:56 - from the email controller
17:02 - and password
17:05 - from the
17:07 - password controller
17:11 - dot text
17:13 - then we can check if the
17:16 - return value is equal to success
17:22 - then we can clear those controllers
17:25 - otherwise let's display a
17:27 - snack bar
17:28 - with the return value because remember
17:30 - we'll return the error
17:34 - okay
17:37 - copy paste that
17:39 - and add it here obviously it'd be nice
17:41 - to have another function like this but i
17:43 - think since it's such a small piece of
17:44 - code it's okay and we only do it twice
17:46 - so
17:47 - not too bad
17:50 - long screen should be done
17:52 - and i think we can run the app at this
17:54 - point and see if it works or not
17:56 - and of course things can't work on the
17:58 - first try like that
18:00 - but it's actually pretty simple we never
18:02 - wrapped it in a material app or anything
18:05 - so make sure this future builder is
18:07 - wrapped
18:10 - in a material app
18:14 - and then this should be the home
18:16 - and we might as well add some theme
18:19 - and make it dark theme because you know
18:21 - we're programmers that's
18:22 - that's kind of what we stick to
18:24 - and there we go
18:26 - let's see if it's working so we create a
18:28 - username
18:30 - let's just type anything
18:31 - signed in
18:32 - password is invalid and the user does
18:34 - not have a password or the user doesn't
18:36 - have a password okay
18:38 - so let's try
18:41 - taught us
18:42 - gmail.com
18:44 - password one two three four five six
18:47 - sign in
18:48 - there is no user record correspondence
18:50 - identifier user may have been deleted
18:52 - okay then let's create an account first
18:55 - we created an account and there we go
18:57 - we're back in the home screen
19:01 - now last part before we start testing
19:03 - is let's actually create do something
19:05 - when we try to sign out
19:07 - here we need an auth again
19:10 - we have our authentication pass to this
19:14 - and we can just do sign out
19:16 - easy
19:17 - and now hopefully we click it and we'll
19:19 - go back to the main screen
19:22 - now we're able to type in our email
19:23 - again
19:26 - and this time we're able
19:28 - we're not able to create an account just
19:30 - email our address is already in use but
19:32 - we're able to sign in
19:34 - there we go that's our full complete
19:36 - login process now after this stage is
19:39 - where the testing begins
19:41 - so the nice thing about test driven
19:42 - development or tdd is that at this point
19:45 - you're pretty much done you know your
19:46 - app is fully tested
19:48 - and that everything works
19:50 - but for us we don't have that yet so
19:54 - we're gonna add some unit tests
19:57 - so what unit tests are they basically
19:59 - test
19:59 - the unit per se so
20:02 - a unit is just a function pretty much
20:05 - and the only things that really make
20:07 - sense to test in this application are
20:08 - these functions that we have
20:10 - create account sign in and sign out you
20:13 - also want to make be careful about not
20:15 - writing useless tests you don't need to
20:18 - write a test for every little simple
20:19 - thing you do
20:21 - in fact there's probably an argument
20:23 - that these don't really need to be
20:24 - tested since
20:25 - firebase already tests this for you
20:28 - and you're not really
20:30 - you're not really testing much but just
20:32 - for demonstration we're going to go
20:33 - through it so the reason i wanted to go
20:35 - over is because these tests could be a
20:37 - little bit more complicated given that
20:39 - they need mocks in them
20:42 - so we're going to need to add some more
20:43 - dependencies in here
20:45 - we're going to add more keto and then
20:48 - we're also going to add flutter
20:51 - driver
20:52 - and test
20:54 - but those are for
20:55 - the integration test
20:57 - for this one we only need mokito and
20:59 - flutter test
21:00 - so each of your tests needs a main
21:03 - and then inside your again you can have
21:05 - a setup
21:06 - and a teardown
21:09 - so what these are the setup runs before
21:13 - every single test and the teardown runs
21:15 - after every single test then checking
21:17 - back to this class what was the one
21:18 - thing i said we're going to need this
21:19 - firebase auth in order to do anything we
21:21 - need this authentication
21:23 - but for us we're going to be mocking it
21:24 - so it's not calling the actual
21:26 - database
21:28 - so like i said the thing we need to mock
21:30 - is the
21:31 - authentication class
21:33 - so we will create a mock auth class
21:36 - the way you mark it is you need to
21:38 - extend that class with with a mock
21:42 - you'll see we have a library imported
21:44 - the mokito library
21:46 - and then it implements our firebase auth
21:49 - class
21:51 - so basically this says we're mocking our
21:54 - firebase auth class and this is the
21:56 - class that will contain all the mocks
21:59 - so once we have our class defined
22:01 - we can create an instance of it
22:04 - and now we will be able to use this for
22:06 - all our tests
22:09 - so our first test
22:11 - we're going to call
22:14 - emit
22:14 - occurs
22:16 - so we're going to test that this off
22:18 - state changes actually emits and we get
22:20 - a user from it
22:22 - we do that
22:23 - by overriding the function up here
22:26 - so auth state changes you just type it
22:29 - out i'll send you this whole thing
22:32 - and what we'll need to use
22:34 - is a
22:37 - string dot from iterable
22:40 - now inside here we're going to iterate
22:42 - over
22:43 - the type of objects that you use
22:45 - so you saw this should return our user
22:48 - so we're going to do is create a mock
22:50 - user as well so we'll have mock user
22:53 - extends mock implements
22:58 - user
23:00 - then here we can return a mock
23:03 - user
23:04 - so before we get to the actual test case
23:06 - i want to change this name to mock
23:07 - firebase auth
23:11 - just to make sure we're all clear
23:13 - that this is the firebase authentication
23:17 - our our class is actually called mock as
23:19 - well so we're not mocking this class
23:20 - we're mocking the firebase auth that
23:22 - we're passing in
23:24 - so now we can create our instance of our
23:26 - auth class as well
23:28 - and remember we have to pass in an
23:30 - authentication
23:32 - and that authentication would be mock
23:34 - firebase auth
23:36 - so there now we have our auth class that
23:38 - we can use for all our tests
23:41 - so here we want to call expect later
23:44 - which is for
23:46 - anything with futures
23:49 - and we're expecting the auth user class
23:51 - to return
23:53 - a stream
23:55 - which we can check by emits
23:58 - and order
24:00 - and inside here we'll have the mock
24:02 - user
24:05 - so there we go
24:06 - now if we run it well you'll actually
24:08 - see a problem
24:12 - there
24:14 - so we were expecting an emit of the type
24:18 - mock user
24:19 - instead we got an instance of generated
24:22 - stream of just user
24:27 - so what happened here
24:29 - well in flutter if you have two
24:30 - instances of an object
24:33 - let's say you do this simple
24:36 - check if you do mock user
24:38 - is equal to
24:40 - mock
24:41 - user even though they are exactly the
24:43 - same this will always return false this
24:46 - is because
24:47 - a separate instance of a mock user is
24:49 - not equal to a different instance
24:51 - there are packages like equatable and
24:54 - other ones i'm pretty sure that actually
24:56 - check the properties within i tell you
24:58 - whether they're equal or not but since
25:00 - we're not using that we have another
25:01 - option
25:02 - you can create a variable
25:04 - for mock user
25:06 - and then use the same instance within
25:09 - this iterable
25:11 - and this emit check
25:14 - so now if we save
25:17 - and run
25:18 - everything passes
25:22 - great so we got the mission there
25:24 - now go back to this function
25:26 - and we need to check this first part
25:28 - whether create an account works
25:30 - so you can copy paste that
25:32 - and check create
25:36 - account
25:37 - so here the difference is we want to
25:38 - mock an actual
25:40 - call to database so we want to mock this
25:42 - create user with email and password
25:44 - we're not trying to override it like we
25:45 - did here we're trying to
25:48 - catch it and then return something of
25:50 - our own instead of the database
25:52 - so you you will need to do when and then
25:54 - inside
25:56 - basically do when the mock mock firebase
25:58 - auth dot
26:00 - create user with email and password gets
26:02 - called
26:03 - with the fields we'll say
26:05 - tardis gmail.com
26:09 - and password
26:11 - one two three four five six
26:14 - so when that happens
26:17 - then answer
26:18 - and we put in whatever value we wanted
26:20 - to answer with
26:22 - so actually in this case
26:24 - we don't really care where it answers it
26:26 - will just return success no matter what
26:28 - the answer is
26:30 - unless it throws an exception that's the
26:31 - only way it doesn't return a success
26:34 - and it will throw an exception if this
26:36 - wasn't
26:37 - successful basically
26:40 - so
26:41 - we mark it we don't really care what the
26:43 - return is
26:44 - and then we can do an expect
26:47 - where we await
26:50 - our
26:51 - auth class
26:54 - create account
26:57 - and we want if we don't pass anything
26:59 - that means
27:00 - these aren't going to get called to the
27:02 - specific fields that we mentioned here
27:04 - so want to make sure we pass
27:06 - the email of tatus gmail.com
27:11 - and password of
27:13 - one two three four five six now since it
27:16 - gets called with those exact fields
27:18 - it'll return with a
27:20 - success
27:22 - okay
27:24 - let's try to run it
27:26 - perfect
27:27 - it works
27:29 - now we could check the same thing except
27:32 - for this firebase auth exception make
27:33 - sure the exceptions actually work
27:36 - create account exception
27:39 - so when this function gets called
27:41 - instead of turning null let's actually
27:44 - throw
27:45 - a firebase auth exception and you can
27:47 - put your own message like
27:50 - you screwed up
27:52 - now we can actually copy this message
27:55 - and that should be our return for that
27:57 - function
27:58 - now we can run all three actually to
28:00 - check
28:01 - all the past perfect
28:05 - now i'm going to copy paste these
28:08 - and we'll do for
28:11 - sign in
28:13 - i will do sign in with email password
28:15 - pass those in
28:18 - sign in
28:20 - that should run
28:24 - sign in exception
28:28 - you do sign in with email password
28:31 - sign in function gets called perfect
28:34 - now we should be able to run those
28:40 - that one runs
28:43 - this one runs
28:45 - and then we could do the same thing with
28:47 - sign out
28:49 - these don't need any calls
28:53 - let's check how this function works so
28:54 - success if it's no
28:56 - and same thing with exception
29:00 - very easy sign out
29:03 - and there we go now we can run all of
29:05 - these tests
29:08 - and we have one two three four five six
29:10 - seven eight tests that i'll pass
29:13 - let's say firebase gets updated or
29:15 - something and the sign out function
29:17 - works differently our tests will not
29:18 - pass anymore and now we have full
29:20 - coverage for all of our authentication
29:22 - functions
29:23 - and let's say firebase updates they no
29:25 - longer throw a firebase auth exception
29:27 - they throw something else
29:28 - then one of our tests is going to fail
29:30 - when we run it
29:32 - because we only catch a firebase auth
29:34 - exception
29:35 - we don't catch the other ones
29:37 - so our code is more safe and you'll be
29:38 - able to catch problems with anything you
29:40 - interface with and you'll know that it's
29:42 - not your app that's actually broken into
29:44 - something else so that's it now there's
29:46 - another type of testing called widget
29:48 - testing
29:49 - would you basically test your ui
29:52 - the thing is we don't really have
29:54 - anything that's driven with the ui here
29:57 - we just have a sign in screen that
29:59 - is based off of the firebase
30:01 - database it's not really
30:03 - ui changes right
30:05 - so we'll come back to that and the
30:07 - integration tests after we do the to-do
30:09 - lists
30:10 - so for this next part we're just going
30:11 - to go through the database interfaces
30:13 - because the rest is just making ui to
30:15 - work with it and i don't think that
30:17 - brings too much value for you guys
30:21 - so we're gonna need a to do model
30:24 - and here we're gonna have a
30:26 - to do model class
30:28 - with a to do id
30:33 - the content of the to do
30:36 - and then whether it's finished or not
30:39 - then we're also going to give it a
30:41 - name constructor from
30:44 - document
30:46 - snapshot
30:50 - going to want to pass in a document
30:51 - snapshot for it then in here just simply
30:55 - set the to-do id
30:57 - equals document snapshot dot
31:01 - id
31:02 - content equals
31:05 - document snapshot.data
31:12 - content
31:14 - as string
31:15 - and then same thing for the done
31:19 - except as boolean
31:22 - okay
31:24 - so now our database class
31:26 - we're gonna need to pass in firebase
31:29 - firestore
31:30 - and the constructor for that and then
31:32 - we're going to have
31:33 - a stream of the list of to-do's that we
31:35 - have
31:37 - so stream of list of to-do
31:40 - model
31:43 - i'm going to call that function stream
31:45 - to do's
31:47 - and all we need is the uid of the user
31:50 - so the way our database is going to work
31:52 - we're going to have a collection called
31:53 - to do's
31:55 - then have a document with the uid
31:59 - and then within that uid we're gonna
32:00 - have the to do for that specific
32:04 - user and then we're gonna have the to-do
32:06 - id
32:08 - content
32:09 - and
32:10 - done
32:13 - so that's what our database is going to
32:14 - look like
32:16 - very simple
32:18 - and easy to use
32:20 - so for the stream
32:22 - we want to again try catch as always
32:26 - and we will try to return
32:28 - firestore
32:29 - that collection
32:31 - remember to do's collection
32:34 - that document
32:36 - of
32:37 - the uid we passed in
32:40 - and then that collection of to do's
32:47 - and we only want to get the ones
32:51 - where the done field
32:52 - is equal
32:54 - to false
32:57 - and then we want the snapshots of that
32:59 - so that returns a stream but we want a
33:01 - stream of lists of to-do models
33:04 - so we gotta map it to such a list
33:07 - these snapshots will return a query for
33:10 - us
33:12 - and then
33:13 - i like to space it out even more
33:19 - we will have a list of to do models that
33:22 - we want to return
33:27 - at the end we got to make sure to return
33:29 - that
33:30 - and then here we're going to have a for
33:31 - loop for
33:35 - each document
33:38 - in
33:41 - query dot docs
33:44 - so all the documents that that query
33:45 - returns we're going to iterate through
33:46 - every single one
33:48 - and then
33:50 - append to the list we have
33:54 - with a to-do model
33:57 - from document snapshot
33:58 - and a pass in that document
34:03 - okay that was a mouthful but
34:06 - it's not as bad as it looks
34:09 - so we return a query
34:11 - and then we go through every document of
34:12 - that query add it to this list then
34:14 - return that list
34:16 - through a stream
34:19 - that's pretty much it
34:20 - so then we have two more functions
34:22 - i'm just i'm just going to go over them
34:24 - with you there's not too much to them
34:26 - this one's to add a to-do if you
34:28 - remember we need the id and
34:30 - what the content of it is
34:32 - so we'll find the collection name to
34:34 - do's go to that specific uid go to the
34:36 - collection call to do's again and add a
34:39 - document with the content and the done
34:41 - field is false
34:43 - then we want to update that to do
34:45 - so we'll have the uid and then the to-do
34:48 - id so we're able to get to the specific
34:51 - to do item
34:54 - and we just update the done to true so
34:56 - i'll go ahead and make the ui and use
34:58 - this and then i'll be right back
35:00 - okay so here we have the home screen
35:03 - we have
35:04 - list app we can call it
35:07 - amateur
35:09 - coder
35:11 - to do instead
35:13 - nice
35:15 - so i have our sign at the top we have a
35:17 - text saying add to do here
35:20 - a text form field
35:22 - an icon button which calls our add to do
35:24 - function that we created
35:27 - and then a list of your to-do's inside
35:29 - of a stream builder which takes in the
35:31 - stream to-do's that we created
35:34 - and then similar to when we log in we
35:36 - have a snapshot if it's active
35:39 - and our data is empty means we don't
35:42 - have any to use want to return you don't
35:44 - have any unfinished to do's
35:47 - and if we do
35:49 - we have a list built listview builder
35:51 - which returns
35:52 - a list of to do cards
35:54 - and to do cards are just
35:57 - a card with an expanded text and a
36:00 - checkbox next to it
36:02 - and if we click on the check inside
36:03 - check box it will update our to do to be
36:06 - checked
36:08 - so let's see if it works for the fun of
36:11 - it go
36:12 - eat a hot dog
36:14 - we can add that
36:16 - go get a hot dog perfect
36:19 - if we refresh here
36:22 - showed up uid and then to do and here we
36:25 - go
36:26 - and the cool thing is
36:29 - if we update here
36:31 - you'll see it update right there right
36:32 - away
36:34 - and same thing we got a check box we
36:36 - click it it's gone from here that's
36:38 - turned to true
36:39 - and you're good to go
36:40 - if you want to implement another screen
36:43 - saying
36:44 - to do is that we're finished you can
36:46 - take this code and do it it's in the
36:47 - description
36:50 - but now to test it so remember the fact
36:53 - that i told you about there's no need to
36:54 - have useless tests
36:57 - all these things in firestore are
36:58 - already tested so writing tests for
37:00 - these doesn't give us much value
37:02 - actually
37:05 - so we're going to skip the unit test for
37:06 - this if you want to do it
37:08 - it's very similar to the way we did the
37:10 - authentication tests
37:13 - so you can try that on your own so thing
37:15 - with flutter is there's two more
37:17 - different types of tests there's widget
37:18 - tests and then there's integration tests
37:22 - now what widget tests are is they test
37:24 - how your ui reacts
37:26 - if you click or touch something so
37:28 - basically it's ui tests
37:30 - the thing about our app that we created
37:32 - is there's nothing driven by the actual
37:34 - ui
37:35 - everything is streamed so when you click
37:37 - this button you're not doing anything
37:39 - within the page
37:40 - you're actually just sending it to
37:41 - firestore
37:42 - and then unrelatedly the stream builder
37:45 - updates
37:46 - once the firestore
37:48 - data comes in
37:51 - so there's nothing really to widget test
37:53 - here but i still wanted to show you how
37:55 - widget tests work and i have a to do app
37:57 - that doesn't use a database so let's
37:59 - look into that okay so this is the to do
38:01 - app it looks pretty similar right except
38:04 - there's one big difference we have a
38:06 - controller
38:07 - and this list isn't being streamed from
38:09 - firebase or anything it's just a static
38:11 - list that we're holding in the app
38:14 - as well the database isn't actually a
38:16 - database it's just a future
38:19 - that returns
38:20 - from database and true
38:22 - so if we look at the app you can add
38:24 - things like
38:26 - hello
38:27 - add it
38:28 - and then load to do from database you
38:30 - load it in from database and it's
38:31 - checked
38:32 - but if we reload it
38:34 - it's all gone
38:35 - anyways this means it's ui driven now
38:38 - this button when we click it actually
38:40 - does something within our app before
38:43 - the button click sends it to the server
38:45 - and then comes back right
38:49 - so here we have some widget tests we're
38:50 - just going to go over them because
38:52 - i think widget tests have a lot of
38:53 - material online i think
38:55 - integration and unit tests are the ones
38:57 - that are a little bit less covered and
38:58 - if you want more information about
39:00 - widget test
39:01 - unit test and integration test i have
39:04 - videos more dedicated to that topic on
39:06 - my channel so make sure to check those
39:08 - out
39:10 - but we're gonna read through this simple
39:12 - widget test that i have so this test is
39:14 - called add a to do and remove it
39:17 - and you'll see
39:19 - we have this tester.pump widget
39:21 - so this pump widget basically means
39:24 - in its ram or in its memory it brings
39:27 - that widget
39:28 - up in the background
39:30 - like we don't need to we don't need to
39:31 - be running this and this test will work
39:33 - some background it launches this widget
39:36 - we wrap it in a material app because
39:38 - you need a material app to launch
39:40 - anything
39:41 - or at least use the scaffold
39:44 - then we launch our home screen
39:47 - then we have these
39:48 - add field and add button
39:50 - they have a value key on them
39:52 - so if you go back to our home screen
39:55 - you can add things called
39:58 - keys to the buttons and form fields and
40:01 - that makes it a lot easier to find them
40:04 - with our widget test
40:07 - you can also do
40:11 - find
40:12 - by type
40:15 - by type what type of widget it is by
40:17 - tooltip things like that there's more
40:20 - than
40:21 - more than just that way to find stuff
40:24 - and also we'll have find dot text get
40:27 - groceries
40:28 - so this basically looks through
40:30 - everything in the widget tree and see if
40:32 - there's a text called get groceries
40:36 - so now for the actual widget tests
40:40 - we use the widget tester
40:42 - the same one we use to pump the home
40:44 - widget
40:45 - so we bring the widget basically onto
40:46 - the screen
40:48 - we enter the text get groceries into the
40:50 - ad field we tap the add button
40:54 - and then we call this pump function
40:56 - which rebuilds
40:58 - just basically like set state does
41:02 - and then we can expect
41:05 - find a get groceries
41:09 - so message finder
41:12 - basically tries to find a text called
41:15 - get groceries
41:16 - now we tell it that it should only find
41:18 - one of them
41:20 - so we can run this now
41:22 - and it passes
41:24 - let's say we do finds nothing
41:28 - it doesn't find any widgets
41:31 - so basically we add a text field and
41:33 - we're expecting it not to show up
41:35 - we have a problem right there
41:37 - said it actually did find that
41:39 - so that's all we're going to cover for
41:40 - widget tests
41:41 - there's a lot more
41:43 - documentation on the flutter docs you
41:44 - can watch come to my channel check out
41:46 - the videos if you need some more help
41:48 - but it's not too complex
41:51 - the most complex one in my opinion is
41:53 - the integration testing okay so we
41:55 - covered unit tests which go over the
41:57 - function then we cover the widget test
41:59 - which goes over a whole widget and now
42:01 - the last one is integration test
42:03 - and that goes over the app as a whole
42:06 - but to do that you need to run the app
42:08 - there's no way you can really test the
42:09 - app as a whole
42:11 - without running it
42:13 - if you remember we added this flutter
42:14 - driver so this flutter driver is the one
42:17 - that pretty much does the
42:19 - driving of the integration tests
42:22 - so we're going to do is add another
42:24 - folder called test
42:26 - underscore
42:28 - driver
42:30 - and here we're going to need two files
42:32 - we're going to need a app dot dart
42:35 - and we're going to need a
42:37 - app underscore test.dart
42:40 - inside the app dot dot we're just going
42:42 - to copy the flutter documentation
42:45 - and this basically runs the main of our
42:47 - app
42:49 - call the main function of the app or
42:51 - call run app with any widget you are
42:52 - interested in testing
42:54 - so then for the actual app test we're
42:56 - going to go to the documentation again
42:57 - and copy the
42:59 - the code that they have
43:01 - okay now let's read through this so this
43:03 - imports the flutter driver api
43:05 - all good
43:06 - we have all the finders that we have
43:09 - just like we checked in the
43:11 - widget test except
43:13 - there's a by value key so
43:15 - it's a little different syntax but
43:17 - similar idea
43:19 - then in the setup we want to connect to
43:21 - the flutter driver and then close it
43:23 - whenever we tear down
43:25 - and then they have two tests here we can
43:27 - remove these tests
43:29 - we don't need them
43:31 - our first test will be
43:34 - create
43:35 - account
43:37 - we're actually gonna have three tests
43:38 - total so we could just
43:41 - put them in here already
43:43 - we'll have a create account we'll have a
43:45 - login
43:46 - and then we'll have
43:48 - add a to do
43:51 - so notice we're doing
43:53 - creating the account that means it has
43:55 - to call the firebase server right
43:59 - and that's perfectly fine with
44:00 - integration tests you can do that it
44:02 - actually builds the whole app with the
44:04 - firebase connected to it and you can
44:05 - actually run the
44:06 - tests but i would recommend doing this
44:09 - not on the production server and have a
44:12 - different firebase project that you
44:14 - connect when you do testing
44:16 - so what i'm going to do right now is i'm
44:17 - going to go through the whole app and
44:18 - add a bunch of these value keys
44:21 - because we need to use them
44:23 - so on the login we have the
44:26 - value
44:27 - key
44:29 - called username
44:31 - and we can make a constant and i'll be
44:33 - back when i do this with every widget
44:35 - that we're going to need to use
44:57 - okay so these are all the objects that
44:59 - we're going to be using in our
45:00 - integration test we have the username
45:02 - password sign in create account
45:04 - sign out button add field add button
45:08 - so now in the create account
45:11 - first
45:12 - i want to check
45:14 - if there is a sign out button present
45:17 - because this builds the app and launches
45:19 - it if our authentication is already
45:21 - there we're going to be already logged
45:22 - in this test is going to fail because
45:25 - we're already logged in with an account
45:28 - so there's this function i made called
45:29 - is present basically it looks for the
45:32 - value key and it waits for a certain
45:34 - timeout that we pass in which one second
45:37 - if it doesn't find it within one second
45:39 - it'll throw an exception we return false
45:41 - if it does find it within one second
45:44 - it will continue and we will say that it
45:46 - is present
45:47 - so pretty simple
45:50 - so we check
45:52 - if our sign out
45:55 - button is present
45:57 - then we want to await driver which is
46:00 - what drives the actual test
46:04 - and we want to tap
46:06 - on the sign out button
46:12 - so
46:13 - we'll check if it's there if it is sign
46:15 - out
46:18 - once that's done
46:20 - we're going to await
46:23 - driver like i said this thing basically
46:25 - does everything for you within the app
46:27 - you want to first tap on the username
46:29 - field
46:33 - just like you would use the app you got
46:34 - to tap there first in order to type
46:36 - right
46:40 - now i can copy it and
46:42 - enter
46:43 - text
46:45 - and here we'll enter let's say tatus1
46:48 - gmail.com
46:52 - taught us that gmail is already taken so
46:53 - we get an error in this case obviously
46:57 - i don't know if this create an account
46:59 - test is worth making since this is
47:01 - testing whether firebase works or not
47:04 - but
47:04 - we're just doing it for demonstration
47:06 - purposes
47:08 - hopefully you will learn something
47:11 - so then let's tap the password field
47:13 - enter the password very secure one two
47:16 - three four five six
47:17 - and then we finally
47:20 - tap the create
47:24 - account
47:25 - button
47:29 - so that should have done the test for us
47:32 - now what do we do next
47:34 - we just wait
47:37 - for
47:38 - find
47:41 - the text
47:42 - called your
47:44 - to-dos if you remember on the home
47:46 - screen
47:47 - there was added to do and then there was
47:49 - your to-do so we find the text we know
47:50 - this worked and now this integration
47:52 - test is done and we can run it
47:55 - so the way you run the test is you do
47:57 - flutter
47:58 - drive
48:00 - target
48:01 - and you put the test driver app.dart
48:03 - that we made over here as the target
48:07 - so this will enable the flutter driver
48:09 - extension then run your app
48:11 - and then run your tests
48:14 - so if we click it let's see what happens
48:17 - so i was in the wrong directory but then
48:19 - i got to the right one and here's us
48:20 - running the flutter driver
48:23 - and then there's multiple devices found
48:26 - i have an iphone connected an ipad and
48:28 - then this is the iphone 11 pro so we
48:30 - want two
48:32 - so there we go it's done and now it's
48:34 - launching it'll start off logged in i
48:36 - think
48:38 - it's logged in logged out you saw that
48:40 - got pressed
48:41 - and everything worked
48:44 - all your tests passed and now if we
48:46 - check firebase taught us one gmail.com
48:51 - so there we go
48:52 - that's how integration tests work
48:56 - now let's quickly add these last two
49:01 - we'll pretty much copy this one
49:04 - if it's present sign out
49:06 - if it's not enter the password and then
49:07 - instead of create account button
49:09 - let's do sign in button
49:12 - then add a to do
49:13 - we want to check if it is signed in
49:16 - already just because we don't want to do
49:18 - be doing to-do's while we're in the
49:20 - login screen
49:22 - if it is
49:23 - tap the add field
49:25 - which is this part
49:27 - enter the text
49:31 - make a video for free code camp
49:34 - then tap the add button
49:37 - and then let's
49:38 - wait
49:40 - for
49:42 - the text
49:46 - make a video for free code camp to show
49:48 - up
49:49 - also you can add your own timeout in
49:51 - here if you want
49:53 - let's stay say three seconds
49:57 - make that constant again
49:59 - and now let's remove this tata suana
50:01 - gmail
50:03 - so get that problem again
50:05 - and we can run our
50:08 - integration test again
50:14 - it's running you see logged in logged
50:16 - out log back in and created us to do for
50:18 - make a video for free code camp
50:22 - nice that was pretty cool
50:24 - i wish you could slow it down a bit
50:26 - so there we go we have created a pretty
50:28 - robust to-do list app
50:30 - uh it has unit tests it has integration
50:32 - tests it doesn't have any widget test
50:34 - but if there was anything ui driven
50:36 - would have definitely done it there's
50:38 - also one more type of testing called
50:39 - functional testing
50:41 - this is pretty manual so i didn't really
50:44 - go over that but
50:46 - you also want to make sure you play
50:47 - around with your app by yourself make
50:48 - sure the ui looks good like for example
50:51 - all our tests would have still passed if
50:53 - this to do screen right here if this to
50:56 - do was
50:57 - off the screen it would have still
50:58 - worked because it's technically within
51:00 - the widget so you want to make sure
51:02 - everything looks good as well
51:04 - and the animations behave as as you want
51:06 - things like that
51:09 - now the last point i wanted to go over
51:10 - was maintainability
51:12 - things you should keep in mind as you
51:13 - work on this project because i'm sure
51:15 - you made a to-do app
51:17 - there's a lot of updates i want to push
51:18 - to this right to make it even better
51:21 - so one thing one great thing for
51:23 - maintainability is to set up a ci cd
51:25 - pipeline
51:26 - ci cd stands for continuous integration
51:29 - and continuous deployment or delivery i
51:31 - don't know i've seen both basically this
51:33 - gives you the ability to set up a
51:34 - pipeline where you push your changes to
51:36 - the master
51:38 - and then it runs a test for you it
51:40 - builds the code it checks everything and
51:42 - deploys the app store all automatically
51:45 - i think it's very useful and
51:47 - makes it more reliable that like your
51:48 - release will happen the same exact way
51:50 - every time
51:51 - i have a video about this on my channel
51:53 - if you want to check it out
51:55 - it's for code magic with flutter it
51:57 - seems to be the go to ci cd platform for
51:59 - flutter another big thing is to make
52:01 - sure you keep up with your tests as you
52:03 - go because i know
52:04 - even if you do it at the beginning it's
52:06 - hard to always keep up with them but
52:08 - they will definitely save you time in
52:09 - the future when you have updates make
52:11 - sure you break it down in github keep it
52:12 - organized make sure you
52:14 - break it down into simple tests because
52:16 - you want to make sure you incrementally
52:18 - change and everything works
52:20 - incrementally this way you can track
52:22 - where things go wrong and make sure they
52:24 - don't go wrong i guess in the first
52:25 - place
52:26 - and then as you keep building up to it
52:28 - if you keep your architecture principles
52:31 - in check and keep your testing up to
52:33 - date you will be a lot more confident
52:35 - about your app and you'll be
52:37 - able to release the app store with less
52:39 - bugs and people will enjoy the user
52:41 - experience a lot more
52:42 - and as you go forward i'd make sure you
52:44 - go through the whole process we went
52:45 - through today for every change make sure
52:47 - you check the requirements go through
52:48 - the design
52:49 - the widget tree planning all that stuff
52:52 - it might be a little bit tedious but for
52:54 - smaller changes it won't shouldn't be
52:56 - that bad and it'll definitely make your
52:58 - process a lot more smoother so that's
53:01 - been it for me once again i'd like to
53:02 - thank free code camp for giving me this
53:04 - opportunity
53:05 - if you want any more in-depth details
53:07 - about any of the topics we covered make
53:09 - sure to come to my channel i have videos
53:11 - on almost all these i think this code
53:13 - will be in the description and i'll also
53:15 - add the code for the widget testing as
53:17 - well
53:18 - and that's it for me thank you for
53:19 - watching

Cleaned transcript:

hello everybody my name is tatus petra and i run the amateur coder channel where our goal is to explain things so simply that even amateurs can understand it and that's my goal for today's video as well to be able to explain how to build a complete production ready app from scratch as simply as i can so the topics we're going to cover today are planning which in my opinion doesn't get covered enough and i think it's one of the most important parts of building any software some other steps you take before you start building an app building an actual app then there's three types of testing that we're going to cover and finally maintainability and hopefully by the end of this video you'll be able to be confident about the apps that you're releasing to all the app stores i'd like to thank free codecamp for giving me this opportunity and i think all my links will be in the description if you want to check them out and let's get into the video okay so today the app we're building is going to be a very simple todo app now the code for this app isn't going to be too complex but we're going to focus on the process and make sure we go through all the steps necessary to be confident about launching our application and to start with that is planning i think planning is the most overlooked topic when it comes to creating any type of software especially creating an app we're going to focus on two main parts of planning today one of them is requirements and then design so what are requirements it basically breaks down the big requirement of build a todo app into smaller sections that are more achievable and that you can test at the end so we're gonna have requirements like the following we're gonna have create account be able to login be able to sign up only display not finished to do's keep the list synced up with firebase and lastly if no todo's say that there's no unfinished dues be able to add a todo and check off to do's now for each of the topics we're going to get in today there's whole methodologies about how to do them and just like for example requirements there's ways to actually structure the sentences in a way using words like shao and must but today we're going to keep it simple if you're interested in any of these make sure to do more research we just can't cover it within like a couple hours so we got eight requirements for this app now let's get into the design a little bit so with design i like to use adobe xd and there's other options like that you can use but for this one we're just gonna do some very basic drops so we'll have the login screen and then we'll have a logged in screen so here we're going to have a field for the email the password and then a login button and then a register button nothing too complicated then once inside we'll have an app bar with a sign out and then add to do and then down here just a list of todo's you want to kind of get gain a vision for how the app's going to work and make sure all the parts are thought out for example if we didn't think about the sign up button at the top and we wanted to put something else at the top it gets a little clearer up there you just want to think about it now the design doesn't only include how the app looks there's also the architectural design of it so for this app it's pretty simple we're going to have we're going to have the main which will check for authentication and this is not a widget this is just a check then if the authentication data hasn't been received we're going to show a loading screen if there's an error we're going to show an error screen if there's no user logged in we're going to take them to the login screen and then finally if they are logged in we're going to take them to the home screen now inside these two inside the login screen will have a username widget a password widget and then two buttons then on the home screen we're going to have a sign out button and add to do widget and then a list of the todo's so this is pretty much the way to treat there is software like jaw.io that you can use but this works for us so that's all the planning we're going to do for this specific app but a more complex app should have days or even weeks of planning in my opinion the things you need to think about are object oriented principles and stuff like that you can look up the principles called solid and grasp those will help you separate the widgets out and keep your architecture clean all right and next is to create some sort of version control and some way to be organized i think almost everybody uses github nowadays so make sure you create a github project and create some tickets and issues in there that you want to work on things like that and then finally we can start on the code so so i'll go do that right now i'll set up a new flutter project and a new firebase project and connect to it okay so we got our firebase project with the email and password signin method enabled we're able to run our app once to make sure it works so then i imported these three packages so we could use everything we need with firebase and then also lint along with analysis options.yaml so we can have a static analysis tool that tells us where we can improve our app performance so here you see problems with const we can add that before and now our app will technically be a little bit faster now we got a little bit more preparation before we're ready to start i'm going to set up our folder structure folder structure is very important to make sure you have everything organized and you can access it real quickly so this is the one i use but every project should be a little bit different depending on what it needs so i have a screens folder a models folder a services folder and a global widgets folder or we'll just call it widgets so models are like bits of data that go together for us we're going to use a to do model which will basically consist of data that is included within every todo then we have screens we're going to have the login screen on the home screen services we're going to have two services authentication and the database service and then we have global widgets we're only going to have one in there called the to do card which basically will make all our todo's look the same so now we're ready to start not yet there's still some more decisions to make now the final decisions you should think about before starting your app whether you want to do tdd which is test driven development this is actually a really great way to write apps but i personally don't like it too much because i find a little bit boring i like to write a little bit of code and then write the test for it right after then there's the state management decisions for us we're not going to use any state management solutions other than set state because it's such a simple app but state management is a huge topic and will definitely clean up your app architecture a lot so definitely take a look at the top three our provider get x and block so you could take a look at look at each of those and see which one you prefer and now finally i think we're ready to get started so one thing to keep in mind when you're building an app keep things simple and keep them iterative so that means do one small part at a time make sure you check all of it everything works and test it all those things so the first part we're going to start with is getting our connection to firebase working so this part's actually pretty simple there's a new firebase.flutter.dev website that kind of helps you out and this is the initialization code that we're just going to copy and paste right in here so the code in here runs the app you first initialize the app and return a future builder which depends on that initialization so this future builder pretty much takes in the future and builds depending on what state that future is in so if the future has an error we're going to return a scaffold with a center child text error very simple and then you see the blue that's our linter popping up saying we need to fix that then if our connection is done that means it was successful and you can go to your app we're not going to touch that yet and then the last case is it's still loading that if it doesn't have an error and it's not done yet then you know the only option left is it's loading we're going to return the same thing except we're going to say loading now the most important part if the connection is done and secure we're ready to move on to our app also one thing to keep in mind we're going to go through this code a little bit fast because there's a good amount of code in there but we want to mainly focus on the testing aspect of it but i still want to go through the code a little bit so you kind of get like a thought process of how you think through building an app so we have our firebase connected now there's another precondition we need to check whether the user is authenticated or not so we're going to do it inside a root widget which is going to be stateful so you can put this in another file but for simplicity i just put it in here and this is going to send us to our root so root is going to decide where the next page is so now inside our widget we're going to create our firebase auth instance firebase auth i'll call it auth and then firebase.instance and then while we're here might as well create a firestore one firebase firestore so then we get into the actual return type i like to use a stream builder for the authentication because anytime anything changes with your authentication state it'll be updated because it's being streamed so the way we do this is we need to give it a stream and our stream is actually not defined here so we're going to have an auth stream so remember i told you there was going to be two services that we have one for connecting to the database which is firestore and then one for the authentication so let's do the authentication part we'll have a file called auth.dart and here we'll have a class called auth we're going to pass in a firebase auth instance and does create a constructor for it and we're going to have three functions in here one is going to be a stream of type user which is a type return from firebase now we're going to get that from auth off state changes so any time the state changes will get returned a user and all the data for it so just like that then we'll have three other functions one's going to be called create account where we're going to need to pass an email and a password anything that's related to future i always make sure to wrap in a try and catch because if anything goes wrong then it gets caught here here we're not going to actually do anything we're going to rethrow it back but if you want to create any actions based off of a problem occurring like maybe a snack bar you want to make sure you return whatever you want to return then inside this try catch we're going to have create user with email and password really simple passing the email password and we're actually going to do email.trim just in case they put a space after it then if that's successful we're going to return success and now the reason i made a return a string is because we're going to also do an on firebase auth exception now we're going to catch that as well and return a dot message for that so basically if there's an exception from firebase auth it catches it in this variable e and it'll return a message for you basically why it failed then we can return that from this function give a little snack bar or something telling them that it failed and why so we have two more functions one for signing in and one for signing out i don't think we need to go through that they're going to be pretty much the same all right so that's it that's our three functions that's all we're going to need for the authentication notice how clean this code is all we're going to have to do is call this create account function and everything is going to be handled for us so now in the main we finally have our auth class and remember we need to pass in a parameter called auth and then the string that we're looking for is for the user stream this error as we'll see is because it's not a named parameter and you just do that by adding in brackets to make sure it's named i like to make sure everything is named for myself so we have our stream defined now the builder notice everything's filled out for us we have our context and a snapshot of our current user if our snapshot connection state is equal to connection dot dot active which means our authentication stream is active basically otherwise you want to return another loading state just like that now if it is active we have a couple more conditions to check so snapshot.data and we can look for the uid if the uid is no then we know there's nobody logged in otherwise uid is not null we'll know there's someone logged in so these two screens are going to be real simple so i'll make those real quick and be right back all right so both of those are done they're both very simple the login screen has two text form fields and two raised bonds that don't do anything just now and the home screen just has an app bar so here if the snow return login with an authentication of auth and a firestore of firestore now we're doing a lot of passing authentication and firestore everywhere this is why i think you should use some sort of state management because you only need to pass those around everywhere but it's not too bad for us then over here we're going to return the home screen and we're going to need an auth of auth again and firestore of firestore now within the todo widget we have the two functions for signing in and create an account all we do here is call those functions we created so this will return a success or the error message if you remember we're gonna need to do auth and sign in the user with email from the email controller and password from the password controller dot text then we can check if the return value is equal to success then we can clear those controllers otherwise let's display a snack bar with the return value because remember we'll return the error okay copy paste that and add it here obviously it'd be nice to have another function like this but i think since it's such a small piece of code it's okay and we only do it twice so not too bad long screen should be done and i think we can run the app at this point and see if it works or not and of course things can't work on the first try like that but it's actually pretty simple we never wrapped it in a material app or anything so make sure this future builder is wrapped in a material app and then this should be the home and we might as well add some theme and make it dark theme because you know we're programmers that's that's kind of what we stick to and there we go let's see if it's working so we create a username let's just type anything signed in password is invalid and the user does not have a password or the user doesn't have a password okay so let's try taught us gmail.com password one two three four five six sign in there is no user record correspondence identifier user may have been deleted okay then let's create an account first we created an account and there we go we're back in the home screen now last part before we start testing is let's actually create do something when we try to sign out here we need an auth again we have our authentication pass to this and we can just do sign out easy and now hopefully we click it and we'll go back to the main screen now we're able to type in our email again and this time we're able we're not able to create an account just email our address is already in use but we're able to sign in there we go that's our full complete login process now after this stage is where the testing begins so the nice thing about test driven development or tdd is that at this point you're pretty much done you know your app is fully tested and that everything works but for us we don't have that yet so we're gonna add some unit tests so what unit tests are they basically test the unit per se so a unit is just a function pretty much and the only things that really make sense to test in this application are these functions that we have create account sign in and sign out you also want to make be careful about not writing useless tests you don't need to write a test for every little simple thing you do in fact there's probably an argument that these don't really need to be tested since firebase already tests this for you and you're not really you're not really testing much but just for demonstration we're going to go through it so the reason i wanted to go over is because these tests could be a little bit more complicated given that they need mocks in them so we're going to need to add some more dependencies in here we're going to add more keto and then we're also going to add flutter driver and test but those are for the integration test for this one we only need mokito and flutter test so each of your tests needs a main and then inside your again you can have a setup and a teardown so what these are the setup runs before every single test and the teardown runs after every single test then checking back to this class what was the one thing i said we're going to need this firebase auth in order to do anything we need this authentication but for us we're going to be mocking it so it's not calling the actual database so like i said the thing we need to mock is the authentication class so we will create a mock auth class the way you mark it is you need to extend that class with with a mock you'll see we have a library imported the mokito library and then it implements our firebase auth class so basically this says we're mocking our firebase auth class and this is the class that will contain all the mocks so once we have our class defined we can create an instance of it and now we will be able to use this for all our tests so our first test we're going to call emit occurs so we're going to test that this off state changes actually emits and we get a user from it we do that by overriding the function up here so auth state changes you just type it out i'll send you this whole thing and what we'll need to use is a string dot from iterable now inside here we're going to iterate over the type of objects that you use so you saw this should return our user so we're going to do is create a mock user as well so we'll have mock user extends mock implements user then here we can return a mock user so before we get to the actual test case i want to change this name to mock firebase auth just to make sure we're all clear that this is the firebase authentication our our class is actually called mock as well so we're not mocking this class we're mocking the firebase auth that we're passing in so now we can create our instance of our auth class as well and remember we have to pass in an authentication and that authentication would be mock firebase auth so there now we have our auth class that we can use for all our tests so here we want to call expect later which is for anything with futures and we're expecting the auth user class to return a stream which we can check by emits and order and inside here we'll have the mock user so there we go now if we run it well you'll actually see a problem there so we were expecting an emit of the type mock user instead we got an instance of generated stream of just user so what happened here well in flutter if you have two instances of an object let's say you do this simple check if you do mock user is equal to mock user even though they are exactly the same this will always return false this is because a separate instance of a mock user is not equal to a different instance there are packages like equatable and other ones i'm pretty sure that actually check the properties within i tell you whether they're equal or not but since we're not using that we have another option you can create a variable for mock user and then use the same instance within this iterable and this emit check so now if we save and run everything passes great so we got the mission there now go back to this function and we need to check this first part whether create an account works so you can copy paste that and check create account so here the difference is we want to mock an actual call to database so we want to mock this create user with email and password we're not trying to override it like we did here we're trying to catch it and then return something of our own instead of the database so you you will need to do when and then inside basically do when the mock mock firebase auth dot create user with email and password gets called with the fields we'll say tardis gmail.com and password one two three four five six so when that happens then answer and we put in whatever value we wanted to answer with so actually in this case we don't really care where it answers it will just return success no matter what the answer is unless it throws an exception that's the only way it doesn't return a success and it will throw an exception if this wasn't successful basically so we mark it we don't really care what the return is and then we can do an expect where we await our auth class create account and we want if we don't pass anything that means these aren't going to get called to the specific fields that we mentioned here so want to make sure we pass the email of tatus gmail.com and password of one two three four five six now since it gets called with those exact fields it'll return with a success okay let's try to run it perfect it works now we could check the same thing except for this firebase auth exception make sure the exceptions actually work create account exception so when this function gets called instead of turning null let's actually throw a firebase auth exception and you can put your own message like you screwed up now we can actually copy this message and that should be our return for that function now we can run all three actually to check all the past perfect now i'm going to copy paste these and we'll do for sign in i will do sign in with email password pass those in sign in that should run sign in exception you do sign in with email password sign in function gets called perfect now we should be able to run those that one runs this one runs and then we could do the same thing with sign out these don't need any calls let's check how this function works so success if it's no and same thing with exception very easy sign out and there we go now we can run all of these tests and we have one two three four five six seven eight tests that i'll pass let's say firebase gets updated or something and the sign out function works differently our tests will not pass anymore and now we have full coverage for all of our authentication functions and let's say firebase updates they no longer throw a firebase auth exception they throw something else then one of our tests is going to fail when we run it because we only catch a firebase auth exception we don't catch the other ones so our code is more safe and you'll be able to catch problems with anything you interface with and you'll know that it's not your app that's actually broken into something else so that's it now there's another type of testing called widget testing would you basically test your ui the thing is we don't really have anything that's driven with the ui here we just have a sign in screen that is based off of the firebase database it's not really ui changes right so we'll come back to that and the integration tests after we do the todo lists so for this next part we're just going to go through the database interfaces because the rest is just making ui to work with it and i don't think that brings too much value for you guys so we're gonna need a to do model and here we're gonna have a to do model class with a to do id the content of the to do and then whether it's finished or not then we're also going to give it a name constructor from document snapshot going to want to pass in a document snapshot for it then in here just simply set the todo id equals document snapshot dot id content equals document snapshot.data content as string and then same thing for the done except as boolean okay so now our database class we're gonna need to pass in firebase firestore and the constructor for that and then we're going to have a stream of the list of todo's that we have so stream of list of todo model i'm going to call that function stream to do's and all we need is the uid of the user so the way our database is going to work we're going to have a collection called to do's then have a document with the uid and then within that uid we're gonna have the to do for that specific user and then we're gonna have the todo id content and done so that's what our database is going to look like very simple and easy to use so for the stream we want to again try catch as always and we will try to return firestore that collection remember to do's collection that document of the uid we passed in and then that collection of to do's and we only want to get the ones where the done field is equal to false and then we want the snapshots of that so that returns a stream but we want a stream of lists of todo models so we gotta map it to such a list these snapshots will return a query for us and then i like to space it out even more we will have a list of to do models that we want to return at the end we got to make sure to return that and then here we're going to have a for loop for each document in query dot docs so all the documents that that query returns we're going to iterate through every single one and then append to the list we have with a todo model from document snapshot and a pass in that document okay that was a mouthful but it's not as bad as it looks so we return a query and then we go through every document of that query add it to this list then return that list through a stream that's pretty much it so then we have two more functions i'm just i'm just going to go over them with you there's not too much to them this one's to add a todo if you remember we need the id and what the content of it is so we'll find the collection name to do's go to that specific uid go to the collection call to do's again and add a document with the content and the done field is false then we want to update that to do so we'll have the uid and then the todo id so we're able to get to the specific to do item and we just update the done to true so i'll go ahead and make the ui and use this and then i'll be right back okay so here we have the home screen we have list app we can call it amateur coder to do instead nice so i have our sign at the top we have a text saying add to do here a text form field an icon button which calls our add to do function that we created and then a list of your todo's inside of a stream builder which takes in the stream todo's that we created and then similar to when we log in we have a snapshot if it's active and our data is empty means we don't have any to use want to return you don't have any unfinished to do's and if we do we have a list built listview builder which returns a list of to do cards and to do cards are just a card with an expanded text and a checkbox next to it and if we click on the check inside check box it will update our to do to be checked so let's see if it works for the fun of it go eat a hot dog we can add that go get a hot dog perfect if we refresh here showed up uid and then to do and here we go and the cool thing is if we update here you'll see it update right there right away and same thing we got a check box we click it it's gone from here that's turned to true and you're good to go if you want to implement another screen saying to do is that we're finished you can take this code and do it it's in the description but now to test it so remember the fact that i told you about there's no need to have useless tests all these things in firestore are already tested so writing tests for these doesn't give us much value actually so we're going to skip the unit test for this if you want to do it it's very similar to the way we did the authentication tests so you can try that on your own so thing with flutter is there's two more different types of tests there's widget tests and then there's integration tests now what widget tests are is they test how your ui reacts if you click or touch something so basically it's ui tests the thing about our app that we created is there's nothing driven by the actual ui everything is streamed so when you click this button you're not doing anything within the page you're actually just sending it to firestore and then unrelatedly the stream builder updates once the firestore data comes in so there's nothing really to widget test here but i still wanted to show you how widget tests work and i have a to do app that doesn't use a database so let's look into that okay so this is the to do app it looks pretty similar right except there's one big difference we have a controller and this list isn't being streamed from firebase or anything it's just a static list that we're holding in the app as well the database isn't actually a database it's just a future that returns from database and true so if we look at the app you can add things like hello add it and then load to do from database you load it in from database and it's checked but if we reload it it's all gone anyways this means it's ui driven now this button when we click it actually does something within our app before the button click sends it to the server and then comes back right so here we have some widget tests we're just going to go over them because i think widget tests have a lot of material online i think integration and unit tests are the ones that are a little bit less covered and if you want more information about widget test unit test and integration test i have videos more dedicated to that topic on my channel so make sure to check those out but we're gonna read through this simple widget test that i have so this test is called add a to do and remove it and you'll see we have this tester.pump widget so this pump widget basically means in its ram or in its memory it brings that widget up in the background like we don't need to we don't need to be running this and this test will work some background it launches this widget we wrap it in a material app because you need a material app to launch anything or at least use the scaffold then we launch our home screen then we have these add field and add button they have a value key on them so if you go back to our home screen you can add things called keys to the buttons and form fields and that makes it a lot easier to find them with our widget test you can also do find by type by type what type of widget it is by tooltip things like that there's more than more than just that way to find stuff and also we'll have find dot text get groceries so this basically looks through everything in the widget tree and see if there's a text called get groceries so now for the actual widget tests we use the widget tester the same one we use to pump the home widget so we bring the widget basically onto the screen we enter the text get groceries into the ad field we tap the add button and then we call this pump function which rebuilds just basically like set state does and then we can expect find a get groceries so message finder basically tries to find a text called get groceries now we tell it that it should only find one of them so we can run this now and it passes let's say we do finds nothing it doesn't find any widgets so basically we add a text field and we're expecting it not to show up we have a problem right there said it actually did find that so that's all we're going to cover for widget tests there's a lot more documentation on the flutter docs you can watch come to my channel check out the videos if you need some more help but it's not too complex the most complex one in my opinion is the integration testing okay so we covered unit tests which go over the function then we cover the widget test which goes over a whole widget and now the last one is integration test and that goes over the app as a whole but to do that you need to run the app there's no way you can really test the app as a whole without running it if you remember we added this flutter driver so this flutter driver is the one that pretty much does the driving of the integration tests so we're going to do is add another folder called test underscore driver and here we're going to need two files we're going to need a app dot dart and we're going to need a app underscore test.dart inside the app dot dot we're just going to copy the flutter documentation and this basically runs the main of our app call the main function of the app or call run app with any widget you are interested in testing so then for the actual app test we're going to go to the documentation again and copy the the code that they have okay now let's read through this so this imports the flutter driver api all good we have all the finders that we have just like we checked in the widget test except there's a by value key so it's a little different syntax but similar idea then in the setup we want to connect to the flutter driver and then close it whenever we tear down and then they have two tests here we can remove these tests we don't need them our first test will be create account we're actually gonna have three tests total so we could just put them in here already we'll have a create account we'll have a login and then we'll have add a to do so notice we're doing creating the account that means it has to call the firebase server right and that's perfectly fine with integration tests you can do that it actually builds the whole app with the firebase connected to it and you can actually run the tests but i would recommend doing this not on the production server and have a different firebase project that you connect when you do testing so what i'm going to do right now is i'm going to go through the whole app and add a bunch of these value keys because we need to use them so on the login we have the value key called username and we can make a constant and i'll be back when i do this with every widget that we're going to need to use okay so these are all the objects that we're going to be using in our integration test we have the username password sign in create account sign out button add field add button so now in the create account first i want to check if there is a sign out button present because this builds the app and launches it if our authentication is already there we're going to be already logged in this test is going to fail because we're already logged in with an account so there's this function i made called is present basically it looks for the value key and it waits for a certain timeout that we pass in which one second if it doesn't find it within one second it'll throw an exception we return false if it does find it within one second it will continue and we will say that it is present so pretty simple so we check if our sign out button is present then we want to await driver which is what drives the actual test and we want to tap on the sign out button so we'll check if it's there if it is sign out once that's done we're going to await driver like i said this thing basically does everything for you within the app you want to first tap on the username field just like you would use the app you got to tap there first in order to type right now i can copy it and enter text and here we'll enter let's say tatus1 gmail.com taught us that gmail is already taken so we get an error in this case obviously i don't know if this create an account test is worth making since this is testing whether firebase works or not but we're just doing it for demonstration purposes hopefully you will learn something so then let's tap the password field enter the password very secure one two three four five six and then we finally tap the create account button so that should have done the test for us now what do we do next we just wait for find the text called your todos if you remember on the home screen there was added to do and then there was your todo so we find the text we know this worked and now this integration test is done and we can run it so the way you run the test is you do flutter drive target and you put the test driver app.dart that we made over here as the target so this will enable the flutter driver extension then run your app and then run your tests so if we click it let's see what happens so i was in the wrong directory but then i got to the right one and here's us running the flutter driver and then there's multiple devices found i have an iphone connected an ipad and then this is the iphone 11 pro so we want two so there we go it's done and now it's launching it'll start off logged in i think it's logged in logged out you saw that got pressed and everything worked all your tests passed and now if we check firebase taught us one gmail.com so there we go that's how integration tests work now let's quickly add these last two we'll pretty much copy this one if it's present sign out if it's not enter the password and then instead of create account button let's do sign in button then add a to do we want to check if it is signed in already just because we don't want to do be doing todo's while we're in the login screen if it is tap the add field which is this part enter the text make a video for free code camp then tap the add button and then let's wait for the text make a video for free code camp to show up also you can add your own timeout in here if you want let's stay say three seconds make that constant again and now let's remove this tata suana gmail so get that problem again and we can run our integration test again it's running you see logged in logged out log back in and created us to do for make a video for free code camp nice that was pretty cool i wish you could slow it down a bit so there we go we have created a pretty robust todo list app uh it has unit tests it has integration tests it doesn't have any widget test but if there was anything ui driven would have definitely done it there's also one more type of testing called functional testing this is pretty manual so i didn't really go over that but you also want to make sure you play around with your app by yourself make sure the ui looks good like for example all our tests would have still passed if this to do screen right here if this to do was off the screen it would have still worked because it's technically within the widget so you want to make sure everything looks good as well and the animations behave as as you want things like that now the last point i wanted to go over was maintainability things you should keep in mind as you work on this project because i'm sure you made a todo app there's a lot of updates i want to push to this right to make it even better so one thing one great thing for maintainability is to set up a ci cd pipeline ci cd stands for continuous integration and continuous deployment or delivery i don't know i've seen both basically this gives you the ability to set up a pipeline where you push your changes to the master and then it runs a test for you it builds the code it checks everything and deploys the app store all automatically i think it's very useful and makes it more reliable that like your release will happen the same exact way every time i have a video about this on my channel if you want to check it out it's for code magic with flutter it seems to be the go to ci cd platform for flutter another big thing is to make sure you keep up with your tests as you go because i know even if you do it at the beginning it's hard to always keep up with them but they will definitely save you time in the future when you have updates make sure you break it down in github keep it organized make sure you break it down into simple tests because you want to make sure you incrementally change and everything works incrementally this way you can track where things go wrong and make sure they don't go wrong i guess in the first place and then as you keep building up to it if you keep your architecture principles in check and keep your testing up to date you will be a lot more confident about your app and you'll be able to release the app store with less bugs and people will enjoy the user experience a lot more and as you go forward i'd make sure you go through the whole process we went through today for every change make sure you check the requirements go through the design the widget tree planning all that stuff it might be a little bit tedious but for smaller changes it won't shouldn't be that bad and it'll definitely make your process a lot more smoother so that's been it for me once again i'd like to thank free code camp for giving me this opportunity if you want any more indepth details about any of the topics we covered make sure to come to my channel i have videos on almost all these i think this code will be in the description and i'll also add the code for the widget testing as well and that's it for me thank you for watching
