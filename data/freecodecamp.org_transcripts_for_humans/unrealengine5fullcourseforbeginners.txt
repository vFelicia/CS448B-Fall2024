With timestamps:

00:00 - Unreal Engine is a 3D computer Graphics
00:02 - game engine that has been used to create
00:04 - many popular games in this full course
00:06 - for beginners tsurav will teach you how
00:09 - to use Unreal Engine 5. surov has seven
00:11 - years of game development experience and
00:13 - has developed multiple games hi there
00:16 - game devs welcome to my beginner to
00:18 - Advanced game development course on
00:21 - Unreal Engine 5. in this course we'll be
00:24 - taking a deep dive into the engine and
00:27 - hopefully by the end of this course you
00:29 - would be able to create a game
00:30 - completely by yourself
00:33 - foreign
00:36 - start developing a game in Unreal Engine
00:38 - some of you guys may have a question on
00:41 - what sort of a system to get for Unreal
00:43 - Engine now the docs is a bit outdated on
00:46 - this page however uh this page whatever
00:50 - is there is uh insufficient in my
00:53 - opinion I have been working on Unreal
00:56 - Engine for almost 7 years now and I feel
00:59 - this system isn't going to be handling
01:02 - anything
01:03 - so
01:04 - 8 gigs of RAM isn't enough and for the
01:08 - video card I would recommend at least
01:11 - going for something like a 1650 or an
01:15 - RTX 3050 if you were to ask me I have
01:18 - worked in unreal for about four to five
01:21 - years with a 1050 TI that totally works
01:24 - however your experience isn't going to
01:27 - be that great and you will have to turn
01:30 - down all the settings as well
01:32 - and for the CPU a ryzen 5 or an Intel i7
01:36 - would do six cores or higher uh
01:40 - preferably eight or even 12 cores would
01:42 - be better but make sure if you do get
01:45 - more number of cores you scale up the
01:47 - other components as well there are a
01:50 - couple of things for example in Visual
01:52 - Studio
01:53 - uh when you compile a program
01:56 - you will actually need more RAM as
02:00 - you scale up the number of cores on your
02:02 - CPU so that's one thing to note
02:05 - and if you scroll it down you would see
02:08 - this list over here although the system
02:10 - is highly Overkill and the GPU is
02:12 - outdated of course one noteworthy thing
02:15 - is a solid state drive which I highly
02:18 - recommend
02:19 - do not use a hard drive for your active
02:22 - projects the experience isn't going to
02:25 - be that great so with that all being
02:27 - said let's actually start by talking
02:30 - about the installation process
02:33 - [Music]
02:37 - now there are two ways in which you can
02:40 - get hands on Unreal Engine one is
02:42 - through the epic games launcher so just
02:44 - search epic games launcher download the
02:46 - launcher and once you actually log in
02:49 - and do the regular sign up stuff you can
02:51 - go ahead and click on Unreal Engine
02:54 - and head into library and you should be
02:56 - able to add an engine version now as of
02:59 - this date the the latest table build is
03:02 - 5.0.3 however 5.1 is in preview and we
03:06 - we shall hopefully upgrade to that it
03:08 - has quite a few exciting features which
03:10 - I would love to show
03:12 - and the other way is to download the
03:16 - source code now you could use git or
03:18 - something and copy the link and clone it
03:21 - like that or you could just download the
03:24 - zip file from here and then there are a
03:27 - bunch of steps to actually install it uh
03:30 - we'll be going through this later in the
03:32 - course and also for more advanced users
03:36 - those of you who will be working with
03:38 - dedicated servers might need the source
03:40 - build as well now if you guys don't have
03:43 - access to this repository you just have
03:45 - to request the permission this is a
03:47 - private repository by default and it's
03:50 - pretty easy to get it
03:52 - and once you do get access to it you
03:54 - will be able to view this page there are
03:57 - quite a few tutorials on YouTube on how
03:59 - to do that so you guys could check any
04:01 - one of those out
04:03 - once you install the unreal editor
04:06 - through the epic games launcher uh
04:09 - you'll also need a code editor in order
04:11 - to work with the c plus files so
04:14 - generally you use visual studio for it
04:18 - now the documentation goes pretty well
04:20 - on what components you need and stuff
04:22 - and if you do need any additional
04:24 - components the installer is going to
04:27 - prompt you and it's pretty
04:29 - straightforward to be honest
04:31 - now you don't require vs 2019 you could
04:34 - use 2022 there is absolutely no issues
04:37 - uh I'll be showing you guys how to set
04:40 - the default code Editor to be vs2022 as
04:43 - well a bit later
04:45 - so that's about it for the code editor I
04:47 - guess now we can go ahead and create a
04:49 - project and let's create a game
04:53 - so I'm in the epic games launcher right
04:56 - now and before we actually launch the
04:59 - engine I just wanted to talk about the
05:00 - installation options
05:02 - try your best even though it looks large
05:05 - to have debugging symbols those are
05:08 - going to help us out later
05:12 - [Music]
05:16 - now you can go ahead and click launch
05:19 - once the loading is done you should be
05:21 - inside the unreal project browser where
05:23 - you can create your projects now yours
05:26 - might look a bit different I haven't
05:28 - selected templates so I don't see first
05:30 - person third person and all that however
05:32 - Our intention here is to learn so we
05:35 - aren't really going to use those
05:36 - templates we might look into them a bit
05:38 - later on but for now we'll be starting
05:41 - with a blank project and a couple of
05:43 - noteworthy things
05:45 - two things actually the first thing is
05:48 - the project location I always suggest
05:50 - having an unreal projects folder in your
05:54 - solid state drive and maybe move them to
05:57 - a secondary drive if you're not working
05:59 - on them
06:00 - now for the project defaults everything
06:02 - is fine except blueprint and C plus plus
06:06 - basically every C plus plus project will
06:10 - have blueprint and everything else that
06:13 - you will need to work with the editor
06:15 - however when you select a blueprint
06:17 - project there is one additional step if
06:19 - you want to start working with C plus
06:21 - plus as well please note that blueprint
06:24 - and C plus plus work complementary with
06:26 - each other and every project in my
06:29 - opinion should use a combination of the
06:30 - two and shouldn't be purely C plus plus
06:33 - nor should be purely blueprint so let's
06:36 - create a c plus project and let's leave
06:39 - it at desktop maximum and we didn't
06:43 - download the starter content so we don't
06:45 - have it but that's totally fine we can
06:48 - add it later on now
06:50 - for the project name we can go ahead and
06:54 - name it let's call it beginner to
06:57 - Advanced course
06:59 - or I'll just call it beginner course
07:04 - so let's create that
07:08 - once you open your project a visual
07:10 - studio window like this with your
07:12 - project solution open should be open by
07:15 - default if not head into the editor go
07:18 - to tools and click on open Visual Studio
07:21 - 2022 and here's where I'll just show you
07:24 - guys how to change the default code
07:26 - editor let's say you have a slower
07:28 - computer head into editor preferences
07:30 - and over here type in code editor
07:35 - and you should be able to change it to
07:37 - visual studio code or whatever let's say
07:39 - you do change it to vs code
07:42 - over here under Tools again you should
07:45 - be able to find refresh Visual Studio
07:48 - code project
07:49 - once you do that you should be good to
07:52 - go
07:53 - one thing that you will immediately
07:55 - notice is my editor layout does not look
07:58 - exactly like yours the reason is I have
08:01 - set mine to the Unreal Engine 4 layout
08:04 - so the way you do that is by heading
08:07 - into Windows load layout and this is the
08:10 - one you will probably have
08:11 - and you can hit
08:14 - control space in order to get your
08:16 - content drawer but I feel like it just
08:19 - adds an additional step in viewing your
08:22 - content and
08:24 - I honestly prefer the Unreal Engine 4
08:26 - layout but it's completely up to you
08:28 - everything else should be in the same
08:31 - place so I'm going to be using the ue4
08:33 - layout you can choose to use the default
08:35 - one if you wish
08:36 - and in case you want to go full screen
08:38 - here in the ue4 layout just get your
08:42 - viewport into Focus just in case you're
08:44 - wondering the middle large portion of
08:47 - the screen is called the viewport once
08:49 - you get it into Focus hit f11 on your
08:51 - keyboard to go full screen
08:54 - [Music]
08:58 - let's start talking about the actual GUI
09:03 - of the unreal editor so the first thing
09:06 - is your menu bar which contains file
09:08 - edit window tools build select and so on
09:12 - these are just the normal options that
09:14 - you would see on in any other computer
09:16 - software so let's say you wanted to save
09:18 - everything you would go go ahead and
09:20 - click save all however there's a key
09:22 - over here as well on the content browser
09:24 - which you will be using more often in
09:26 - this editor and under edit you also have
09:30 - a couple of important things
09:32 - obviously for undo redo and
09:35 - functionality like that you'd prefer the
09:37 - shortcut keys so for example let's say I
09:40 - add in a light over here
09:42 - and I go to edit you could undo that but
09:46 - I just prefer using Ctrl Z and Ctrl y
09:49 - and editor preferences project settings
09:52 - and plugins are a couple of options
09:55 - which you will use quite a bit we will
09:58 - be getting into all of those in detail
10:00 - later on
10:01 - now window as the name suggests has to
10:04 - do with uh your actual GUI so here for
10:10 - example if I wanted to know what game
10:11 - mode I have and again we will be getting
10:14 - into all of that so I can just go to
10:16 - world settings which contains the game
10:19 - mode info so it says game mode override
10:21 - none we can set that to be game mode for
10:24 - example and stuff like that
10:26 - it all depends on what you exactly need
10:28 - you could grab in a second viewport as
10:31 - well in case you needed it
10:33 - stuff like that and under Tools the only
10:37 - thing which we'll probably use here is
10:39 - going to be creating a new C plus plus
10:41 - class and occasionally we might need to
10:44 - refresh our project file
10:46 - and nothing else actually find in
10:48 - blueprints is something handy so in case
10:51 - you have written some blueprint code and
10:53 - you want to find it
10:55 - like in your entire project then it's a
10:59 - useful thing
11:00 - and build is for building your lighting
11:03 - and stuff basically uh baking your
11:06 - lighting
11:07 - select not really sure who would use
11:11 - that because most of the operations are
11:13 - there can be done by shortcut keys
11:16 - so that's your menu bar
11:19 - and under this there's another panel
11:21 - over here
11:22 - where you have another save button
11:25 - and under this select mode option
11:28 - over here you have quite a few options
11:31 - landscape is something which you will
11:34 - use when you're working with you know
11:37 - larger Maps so you can go ahead and
11:39 - create landscapes
11:40 - so what I'll do is I'll create a brand
11:42 - new level to Showcase those things and
11:45 - over here in blueprints this is where
11:47 - you'd access your level blueprint and I
11:50 - will get to what is that a bit later
11:52 - this option right here is mostly for
11:55 - cinematics so let's say I'm making a
11:57 - trailer for your game or something these
11:59 - are the things which you would use
12:01 - and this is just to play your game so if
12:03 - I hit play I can see what the game looks
12:06 - like while you're playing it
12:09 - one more thing let's say you wanted to
12:11 - look at how your game looked while
12:13 - you're playing without actually playing
12:15 - it you can press G on your keyboard and
12:18 - it it's going to go into game mode which
12:20 - will show you exactly how your game will
12:22 - look when it is being played
12:25 - and next up you have this button right
12:29 - here where it allows you to launch the
12:32 - game and stuff will be going into this a
12:35 - bit in detail later on
12:37 - now for those of you guys who have
12:39 - slower computers you can head into
12:42 - settings over here engine scalability
12:44 - settings and you can set Yours to low
12:48 - now how do you check your frame rate you
12:51 - may ask because that's a major concern I
12:54 - feel like you do require about 50 to 60
12:57 - FPS in order to have a smooth editor
13:01 - experience so the way you check that is
13:03 - by hitting your tailed key under your
13:06 - Escape key that is if you guys aren't
13:07 - familiar
13:09 - once you do that your focus should be in
13:12 - this enter console command window at the
13:14 - bottom of your screen type in stat FPS
13:19 - and you might see that it's locked at
13:23 - 120 if you have a fast computer so what
13:25 - I'll do is I'll type in t dot Max FPS
13:29 - and you can just type in a crazy value
13:31 - like 999. so this is my actual uncapped
13:35 - frame rate
13:36 - now this introduces us to another window
13:41 - this is known as the console now the
13:44 - console is really useful
13:47 - basically almost every setting you see
13:50 - over here and quite a few other settings
13:52 - which we will talk about later can be
13:55 - set using the console
13:57 - it's quite handy let's say you're
13:59 - debugging your game and you don't have
14:02 - an actual button to change your graphic
14:04 - settings you could use the console and
14:06 - change it as well there are many other
14:08 - uses for it for example in multiplayer
14:11 - you can simulate lag and stuff like that
14:14 - in order to represent an actual
14:16 - multiplayer game
14:18 - so that's the console and your output
14:21 - log is your output log so let's say I've
14:23 - printed something
14:25 - it's going to stay on your screen for
14:27 - about two seconds or how much ever you
14:29 - set the duration
14:31 - but the output log is always going to
14:33 - have
14:35 - the print so for example
14:38 - now we haven't gone into blueprints but
14:40 - I'll just print something and show you
14:41 - guys
14:43 - if I just type in print string hello
14:46 - you see you get hello over here but it's
14:50 - gone after two seconds
14:52 - however in the output log you should be
14:56 - able to still see Hello it should be all
14:58 - the way down
15:00 - as you see
15:03 - you get hello
15:04 - now don't worry about all these errors
15:07 - it's really nothing to worry about
15:10 - so that's about it and on the left hand
15:13 - side you have the place actors panel
15:17 - where you know you have various options
15:20 - you'll really not be using this you will
15:22 - generally just drag those from the
15:25 - content browser
15:26 - it just contains the same old things and
15:29 - the recent step may be helpful if you're
15:31 - placing the same object over and over
15:34 - again
15:35 - one thing that you might use this for is
15:37 - for a player start player start is
15:40 - basically where your player is going to
15:41 - spawn
15:43 - just press G on your keyboard if it ever
15:45 - disappears you're probably in game mode
15:47 - if you don't see it
15:49 - and if you want to get close to it like
15:51 - how I did
15:52 - uh make sure that is selected and press
15:55 - F on your keyboard
15:57 - F stands for focus and it's going to go
16:00 - near it the camera is going to go near
16:02 - that
16:03 - now once that's done let's talk about
16:07 - this massive chunk of the screen
16:10 - this is known as the viewport this is
16:13 - where you will actually arrange your
16:15 - level and do stuff
16:17 - so for example if you want to place
16:19 - something you drag that in the viewport
16:21 - and that's going to be added into your
16:23 - level
16:25 - now in order to navigate your viewport
16:27 - there are quite a few methods which you
16:29 - can use one is known as the Maya style
16:31 - navigation where you use alt and your
16:33 - mouse buttons and there are many other
16:36 - styles which I won't get into it's kind
16:39 - of pointless but there is one style
16:41 - which I personally prefer and I feel
16:44 - almost everyone is going to prefer that
16:46 - that is by using your right Mouse button
16:49 - and your wasd this is similar to how you
16:51 - move in video games except you're
16:53 - holding the right Mouse button here so
16:56 - hold down your right Mouse button and
16:58 - you can use your w a s and D keys and
17:01 - move your mouse so this gives you all
17:04 - degrees of freedom so you can rotate you
17:06 - can pan around you can do everything
17:09 - so this is my favorite way of navigating
17:12 - just try it a couple of times it's just
17:15 - a matter of getting the feel of it and
17:18 - if I want to speed up the camera which I
17:20 - will get into later you can use your
17:22 - scroll wheel along with this and your
17:23 - camera speed is going to change
17:27 - there are a couple of options again here
17:29 - now here uh instead of the console
17:32 - command you could use this as well to
17:34 - show your FPS
17:36 - and there are quite a few other options
17:38 - which you would generally not use screen
17:40 - percentage is basically a resolution
17:41 - scale you could set that all the way up
17:44 - there
17:45 - I'd leave mine at 100.
17:48 - and this is to change between
17:50 - perspective and orthographic views let's
17:53 - say you're aligning something from the
17:55 - top you would go to your top
17:57 - orthographic View
17:59 - now you might see everything is
18:02 - wireframe so you can change that here as
18:05 - well go to lit let's say there are
18:07 - shadows interrupting your work you could
18:10 - head into unlit there are many other
18:12 - view modes which you generally use for
18:14 - optimization and things like that
18:17 - but generally you'd stay in lit unlit or
18:21 - wireframe itself
18:22 - maybe a couple of times you might use
18:25 - one of these uh other settings but I've
18:30 - never found myself needing those
18:32 - so that's there
18:34 - and scalability is basically the same
18:36 - thing which we saw over here
18:39 - I can set that to cinematic for example
18:42 - in my case it shouldn't really matter
18:45 - that's about it and in these options on
18:50 - the right hand side
18:52 - this one basically allows you to select
18:55 - objects so let's say I click on this I
18:58 - select this now let me get closer a bit
19:02 - set into perspective
19:04 - so if I click on this I can select it
19:08 - now when I click on something now I'll
19:12 - create another Point light when I click
19:15 - on something and I have it selected
19:17 - if I want to move it I can press W on
19:20 - the keyboard
19:21 - or if I want to rotate it I can press e
19:24 - on the keyboard
19:25 - and if I want to scale it for a light
19:28 - it's kind of useless but it is going to
19:30 - scale the radius I believe
19:32 - so for that I can hit r on my keyboard
19:36 - in order to scale things or you could
19:38 - use these buttons over here
19:41 - so this is for move
19:43 - this is for rotate
19:45 - and this is for scale
19:48 - all right so once that said
19:51 - this button right here changes between
19:54 - uh local and World space
19:57 - now over here if I just drag in a cube
20:00 - for example under shapes you should find
20:02 - Cube
20:04 - and if I change this
20:07 - to local space
20:11 - now when I rotate this Cube you see the
20:14 - Gizmo rotates along with it and now I
20:16 - can move it along its rotation
20:18 - but let's say I wanted to rotate it
20:20 - along with the world's XYZ the way I do
20:24 - that is by heading into World space
20:26 - so now you see it's aligned to the
20:28 - world's XYZ that is your actual
20:31 - coordinate axis
20:33 - but this cube is rotated as you can see
20:35 - so if I want to move it along that
20:38 - rotation I can head into local space
20:42 - again if you are familiar with 3D
20:44 - modeling software these will sound
20:46 - pretty familiar to you
20:48 - the next thing is grid snapping
20:51 - now if I were to come close enough you
20:53 - would see that it's moving in increments
20:55 - it's not moving smoothly that's because
20:58 - grid snapping is enabled and snapping
21:00 - distance is set to 10. so I can just
21:03 - click on this button and disable grid
21:05 - snapping and now you see the object
21:07 - moves smoothly same goes with rotation
21:09 - if I disable that I can smoothly rotate
21:12 - the object
21:13 - if I enable that it's going to rotate in
21:15 - increments of 10
21:17 - same with the scale as well
21:20 - now this map is pretty huge and it's
21:24 - taking quite a while for me to actually
21:27 - go this far
21:29 - so the way I can actually
21:32 - move faster is by using this camera
21:35 - speed button so if I head into 8
21:39 - as you see we are moving very fast one
21:42 - more thing
21:43 - is if you scroll while using your right
21:48 - click and wasd basically I'm using that
21:51 - to move
21:52 - if you use right click and wasd and you
21:56 - scroll at the same time you can actually
21:58 - adjust your camera speed so I have my
22:00 - right Mouse button held I have wasd to
22:03 - move and if I scroll forward I'm going
22:06 - to move real fast
22:07 - now let's say scroll backwards I'm going
22:10 - to go slower
22:12 - so you can adjust your camera speed with
22:14 - your scroll wheel as well and of course
22:16 - you can adjust it over here and if you
22:18 - want the camera to be even faster you
22:20 - can go ahead and set this multiplier
22:22 - thing
22:23 - and that's about it
22:27 - [Music]
22:32 - now let's actually start creating
22:34 - something so the way you would actually
22:36 - go about doing stuff is creating
22:38 - something under your content folder now
22:41 - you might have some things over here if
22:43 - you have enabled starter content and
22:45 - stuff but in our case we don't have
22:47 - anything
22:48 - so one thing is whenever you create new
22:52 - levels it's always advisable to have a
22:55 - Maps folder in your content folder where
22:58 - you actually put all your Maps
23:01 - so head into this folder and in order to
23:04 - actually create a blank level where you
23:06 - can start making your own right click
23:10 - click on create basic asset level or you
23:14 - can head into file new level anyway is
23:17 - okay
23:18 - and we can call this one
23:22 - beginner course level you could call it
23:25 - anything you want
23:27 - double click on it to open it up
23:30 - and I've already saved it
23:33 - uh it's asking us to save this map
23:36 - actually so actually don't save this
23:40 - now head into your project settings
23:43 - and this is where we start talking about
23:45 - some of the things which you might need
23:47 - the first thing is maps and modes
23:50 - so in order to decide which level is
23:53 - going to open when you start the editor
23:54 - this is where you actually set it so
23:57 - anything associated with your project
23:59 - will be over here so for example your
24:02 - input bindings is something which you'll
24:03 - use a lot so all of those are there in
24:06 - the project settings so we can change
24:08 - the editor startup map to be beginner
24:10 - course level
24:11 - and we can set this to be beginner
24:13 - course level as well
24:15 - close that
24:16 - and if you were to notice there is
24:19 - actually a small note here
24:21 - it says
24:22 - these settings are saved in default
24:25 - engine dot ini which is currently
24:28 - writable what do I mean by that is if I
24:32 - head into my project directory
24:35 - and if I head into config there are
24:38 - actually many config files so for
24:40 - example if I open up default engine.ini
24:44 - it says editor startup map equals and it
24:47 - has the relative path of the map
24:50 - and you have a bunch of other settings
24:52 - as you can see these are useful we will
24:56 - actually talk about console config files
24:58 - in detail later on
25:01 - there are other config files as well
25:04 - most of which you won't use you would
25:06 - mostly just use default engine.ini
25:09 - now heading back to our level you see
25:12 - everything is completely empty
25:16 - now one of the first things that you
25:17 - will need is a sky actually so if you
25:20 - just search in sky
25:22 - you're going to find a skylight Sky
25:24 - atmosphere we are just going to be using
25:27 - a skylight for now
25:29 - and if you just type in atmosphere you'd
25:32 - you get the same Sky atmosphere here
25:35 - so you can go ahead and drag that as
25:37 - well
25:39 - and if you type in fog you'll be able to
25:42 - get exponential height fog
25:44 - now you will see the effects of it if
25:47 - you Tinker around with this yourself
25:50 - basically all of these things just do
25:52 - what they say so exponential height fog
25:54 - is going to add fog and if you want to
25:58 - change the properties of this always
26:00 - head into your details panel and this is
26:03 - where you will adjust all the properties
26:05 - now for something like fog the location
26:07 - and stuff doesn't matter
26:09 - so anything you place the location of it
26:12 - is going to be stored here location
26:14 - rotation and scale just know that
26:17 - location rotation and scale combined in
26:19 - Unreal Engine is known as a transform
26:22 - we'll be using that a lot
26:24 - now let's say you had a light which was
26:27 - fixed and you want the Shadows to just
26:30 - be baked in and you have nothing to
26:32 - calculate dynamically you could set your
26:34 - light to be static or it it goes the
26:37 - same with any other object if you're not
26:39 - going to be moving it it's going to be
26:41 - static
26:42 - stationary is almost like static but
26:46 - there are a couple of things which
26:47 - dynamically changes
26:49 - it's generally used for your directional
26:52 - lights which acts as your sun basically
26:54 - so we can drag that as well so if I type
26:57 - in directional light
26:59 - you see we get everything else that we
27:02 - need
27:04 - if I remove the fog you'd see that the
27:07 - fog went
27:08 - now for example here I have lost my
27:12 - directional light and
27:14 - or any other component so in order to
27:16 - navigate to that you can use this
27:18 - outliner window which will have a list
27:20 - of all the objects that are in your
27:22 - scene you can do quite a few things
27:24 - actually if you want you could select
27:26 - these and you could actually put those
27:28 - in one folder so I can go ahead and
27:32 - right click create a folder and I can
27:35 - just drag those inside this folder you
27:38 - could do that as well in the outliner so
27:41 - now let's say you lose your directional
27:43 - light you can head over here and let's
27:45 - just call this one
27:47 - sky for example
27:51 - let's just call it Sky actors I'll tell
27:54 - you guys why we call them actors a bit
27:56 - later on so you can drag in a sky
27:58 - atmosphere Skylight and stuff like that
28:01 - so these are the basic components of
28:03 - your Sky now if I go ahead and zoom into
28:05 - my directional light
28:07 - press e on my keyboard and rotate it you
28:10 - see the sun moves along with it
28:12 - so let's say we wanted an evening Sky we
28:15 - would use something like this
28:17 - and if you would notice the mobilities
28:20 - that set to stationary
28:22 - you could set it to movable then
28:25 - everything will be calculated
28:26 - dynamically and you won't have to build
28:28 - the lighting
28:30 - you could set it to stationary as well
28:33 - you could set it to static if you don't
28:35 - have any moving objects in your level
28:40 - now let's go ahead and just save
28:43 - everything
28:45 - now let's start actually creating
28:48 - something in our level
28:50 - [Music]
28:54 - so first of all remember I told you
28:57 - about the landscape tab this is what you
28:59 - would use if you have a larger world but
29:02 - for our purposes I'll just show you guys
29:05 - how to work with Landscapes even though
29:07 - we aren't really looking for a large
29:10 - world
29:11 - so here you can select your landscape
29:13 - material but you can change it anytime
29:15 - anyways and let's say you wanted a water
29:18 - body or something or let's say you
29:21 - wanted to have multiple multiple layers
29:24 - you know in your landscape you can click
29:26 - on enable edit layers
29:28 - uh and these things are basically a
29:32 - transform and stuff like that and these
29:35 - things are just these options number of
29:37 - components and the overall resolution
29:39 - adjust the size of your landscape so you
29:43 - can play around with that
29:44 - to see uh what the Precision or rather I
29:49 - should say the detail level of the
29:50 - landscape and the size should be
29:52 - depending on that you can increase that
29:55 - or you can go ahead and use a height map
29:57 - I actually have a chart on my channel on
29:59 - how to use height Maps properly in
30:01 - Unreal Engine
30:03 - but for our purposes we'll just create
30:05 - our own
30:06 - so let's just create everything with the
30:08 - default options
30:09 - and let's hit on create
30:13 - so it is going to take a while
30:20 - and once we are done with that we have a
30:23 - landscape
30:24 - now if I go ahead and press play as you
30:27 - can see I can navigate around this
30:29 - landscape just like you can navigate in
30:32 - any other level
30:34 - so now what I'm going to do is I'm going
30:37 - to edit the landscape now these are the
30:40 - tools that we'll be using to edit our
30:42 - landscape
30:43 - so you have to be under landscape mode
30:45 - and under this section over here you
30:48 - would find sculpt
30:49 - you can increase the tool strength you
30:52 - can get the brush type over here as well
30:54 - uh one thing that you will use is
30:57 - probably the alpha brush basically you
30:59 - can have your own mask and stuff but for
31:02 - our purposes we are going to be using
31:03 - the regular old Circle brush so I'll
31:06 - just increase the size now this need not
31:08 - be the limit actually I can set this to
31:10 - 10 000 as well
31:12 - so if I go ahead and do that Let's see
31:15 - we have kind of a mountain here
31:18 - now what if I wanted to randomize the
31:21 - bumpiness in the map I could use noise
31:24 - so you see it's going to be like this
31:26 - but this is overkill so I can go ahead
31:29 - and change the tool strength to
31:30 - something like 0.05
31:32 - and as you see this is a lot more
31:34 - reasonable
31:36 - so this is what noise does flatten as
31:39 - the name suggests is going to flatten
31:40 - your landscape at that level so let's
31:43 - say select this level everything else is
31:46 - going to go to that level if I use
31:48 - flatten now obviously I can increase
31:50 - your tool strength if you wish
31:53 - completely up to you and there are many
31:56 - other things such as the brush fall off
31:58 - so basically if you want a softer brush
32:01 - so you could use the brush fall off and
32:03 - increase that if you want a completely
32:05 - hard brush you could go ahead and use
32:07 - this but as you can see it produces
32:09 - harsh effects so we aren't going to be
32:11 - using that
32:12 - again completely up to you
32:15 - and erosion is basically if you wanted
32:18 - to create natural looking slopes and
32:20 - stuff so for example
32:22 - so I'll just reset some of these
32:24 - settings here
32:26 - so something like this you could
32:28 - experiment and find out what what each
32:31 - one does
32:32 - but generally you would stick to sculpt
32:34 - smooth flatten Ram
32:38 - and maybe sometimes you would use
32:40 - erosion and you would use noise
32:43 - and let me show what ramp does real
32:46 - quick
32:47 - so if I select ramp
32:50 - and if I go ahead
32:52 - and click somewhere and click in another
32:57 - place and click on ADD ramp
33:00 - you see it Bridges those two locations
33:03 - with a straight line and this is going
33:06 - to be a ramp
33:07 - you could add a ram
33:09 - anywhere like this so I can go ahead and
33:12 - do this
33:13 - and I can click enter or I can press add
33:16 - ramp on the menu over there and it's
33:19 - going to add a ramp now if you had a
33:21 - character or something you can walk over
33:22 - it
33:23 - now again we can use the smooth tool in
33:26 - order to smoothen this out
33:29 - so now these two in this intersection
33:32 - looks seamless
33:34 - so these are basically a landscape
33:36 - editing tools there is not much depth to
33:39 - it and not sure what it is does actually
33:44 - so I've never used eres to be honest you
33:47 - just undo changes if you really had to
33:51 - and one more thing if you wanted to do
33:53 - the inverse of an operation so let's say
33:56 - I am sculpting a landscape so let's say
33:59 - I wanted something like this so I'll
34:02 - increase the tool strength
34:05 - so make that let's say 0.14
34:09 - now this is one way but what if you
34:11 - wanted a pit instead of a hill the way
34:14 - you do that is by holding shift it's
34:16 - going to reverse the operation and it is
34:18 - going to make a pit
34:20 - same goes for the other tools as well
34:22 - shift is going to be the inverse of the
34:24 - operation
34:27 - so that's about what you'll use in the
34:29 - unreal editor most of the time so now we
34:32 - can start creating our own assets make
34:34 - sure you first of all go into select
34:36 - mode again don't forget that and now we
34:39 - can go ahead and start talking about
34:40 - blueprints
34:42 - [Music]
34:44 - foreign
34:47 - so let's start talking about blueprint
34:50 - blueprint basically is the visual
34:52 - scripting language which is used to
34:54 - write game logic in Unreal Engine
34:57 - so blueprint code can be written in many
35:00 - types of assets if you right click go to
35:02 - blueprint class you can write blueprint
35:04 - code in most of these assets
35:07 - and we will get to some of the important
35:09 - ones a bit later for example act upon
35:11 - character player controller game mode
35:13 - there are few others such as the game
35:15 - State player State and so on we'll be
35:17 - getting into all that now the most basic
35:20 - type of blueprint is going to be a level
35:21 - blueprint so if you head into this menu
35:24 - over here click on open level blueprint
35:27 - you would say you'd get a blueprint
35:29 - associated with your level
35:31 - now begin play is as the name suggests
35:34 - something which is called as soon as the
35:36 - game begins or in this case as soon as
35:39 - you open the level
35:40 - please do not interpret begin play as
35:43 - when you click on the play button
35:46 - this is only called once you load into
35:48 - the level so let's say you load it into
35:51 - another level the begin play for that
35:53 - level will be called as well in order to
35:56 - actually start writing code you would
35:58 - use some built-in functions or you could
36:00 - write your own so the way you do it is
36:03 - if you right click for example and if
36:06 - you just type in I don't know let's say
36:09 - set location
36:10 - now let's say you wanted to set the
36:12 - location of something in your level
36:14 - let's actually do that
36:15 - uh since this is object oriented you
36:19 - will need context for everything so you
36:22 - need to know for Which object you're
36:24 - actually moving so for example let's say
36:26 - we have a point light here now one handy
36:29 - thing which I forgot to mention before
36:30 - let's say it's up over here and you want
36:33 - to snap it to the ground you can hit end
36:35 - on your keyboard and it's going to go to
36:37 - the ground level
36:38 - now we have this
36:41 - have that selected and head back into
36:43 - your level blueprint if you right click
36:46 - you get an option create a reference to
36:48 - point light now
36:50 - internally this is a pointer to this
36:53 - object or rather I should say to this
36:56 - actor anything that can be placed in a
36:58 - level is called an actor just remember
37:00 - that
37:01 - now if I drag off of this now I want to
37:03 - get its location let's say for example
37:06 - now the search bar is really useful for
37:09 - that you don't really need to know the
37:11 - function names especially in blueprints
37:13 - so just type in get location and you see
37:16 - get actor location
37:18 - now I can go ahead and print it for
37:21 - example so if I right click and type in
37:24 - print you see print string now this is
37:28 - called a function
37:29 - even this will be called a function so
37:31 - let's say I drag off of this and I type
37:34 - in set actor location
37:37 - again every getter will usually have its
37:40 - own Setter if it can be set
37:43 - so what we are saying what we are
37:45 - implying by this
37:46 - is
37:48 - set the location of this point light to
37:52 - be zero
37:53 - which is what you've defined over here
37:56 - now let's say we just wanted to move it
37:58 - up a bit so we can do plus
38:01 - and on the Z we can do 200 because Z is
38:05 - the up Axis in Unreal Engine
38:07 - and we can set that to be the new
38:09 - location
38:10 - so if I go ahead and press play
38:15 - don't see much uh see mobility of the
38:20 - light is set to stationary so we have to
38:22 - make it movable of course uh remember
38:25 - what I was telling you guys earlier with
38:27 - static and stationary you would assume
38:29 - it to be in the same place but with
38:31 - movable it's fully Dynamic so now if I
38:33 - press play you see it became dimmer in
38:36 - case you guys wanted to see the change
38:38 - if you just press D on your keyboard and
38:41 - left click you get a delay node or you
38:43 - could right click and search for delay
38:46 - but I prefer using D if you press D and
38:49 - left click you get a delay node let's
38:51 - just keep a delay of two seconds and
38:53 - then let's move it up
38:55 - so if I press play
38:58 - as you see it got dimmer because it went
39:00 - up
39:01 - now this blueprint function has a couple
39:05 - of pins on the left so these are called
39:07 - pins the stuff from which you can drag
39:10 - off of
39:11 - now the Triangular one or the pentagonal
39:15 - one I don't know what shape this is the
39:17 - one which drags off the white wires
39:19 - these ones are called execution pins so
39:23 - this function will be executed only when
39:25 - this pin goes from left to right so only
39:27 - when you connect something to it from
39:29 - the left and when this is executed this
39:32 - is going to be called and once this is
39:34 - done this is going to be executed now
39:38 - this one is a function as well get actor
39:40 - location is a function too however it
39:43 - does not have an execution pin you might
39:45 - notice the reason is this is a pure
39:48 - function you can define a pure function
39:51 - whenever you need a function to return
39:53 - immediate values
39:55 - so what I mean by that so for example if
39:59 - I have this hit result and let's say I
40:02 - print this out
40:04 - so I can't print out a hit result I
40:06 - figured so let's just take location now
40:09 - this is just a sweep hit result so let's
40:12 - say we move it somewhere and it collides
40:14 - with something in between it's going to
40:16 - return a hit result if you have sweep
40:18 - enabled
40:19 - uh now if I print this out this value
40:22 - right here is actually cached so let's
40:25 - say I copy a print string and let's say
40:27 - I print this out again
40:30 - set actor location is not going to be
40:32 - called once again
40:34 - this value what you had is going to be
40:37 - cached in your memory however over here
40:40 - if I just drag off of get actor location
40:46 - and let's drag off of this once again so
40:50 - let me drag this over here this value is
40:54 - not cached what I mean is get actor
40:57 - location is executed each time I'm
41:00 - calling this print string wherever I am
41:03 - referring to this value the entire
41:06 - function is going to be called once
41:08 - again and in this case it makes sense
41:10 - because whenever we execute get actor
41:13 - location we want at the live location of
41:16 - of the actor not the location which it
41:19 - was in previously if we go by that logic
41:21 - we would get the location before it was
41:24 - set so we will get the live data using a
41:28 - pure function
41:29 - and the target Works in a similar way we
41:32 - are getting the point lights location so
41:35 - the target is point light
41:37 - now one more thing you might notice is
41:39 - event tick tick is basically a function
41:41 - which is called on every frame so if I
41:44 - just hit print and if I just print out
41:47 - tick for example
41:49 - you'd see it prints it a bunch of times
41:51 - basically every time a new frame is
41:53 - drawn uh the tick function is called
41:56 - [Music]
42:00 - now whatever I told you guys is just a
42:03 - vague overview of how blueprint works so
42:05 - I just talked about execution pins and
42:07 - that it's object oriented and types are
42:10 - color coded but now let's actually start
42:12 - talking about them one by one so the
42:15 - first thing you would want to do in any
42:17 - sort of a programming language or if
42:19 - you're writing any code is first of all
42:22 - be able to store data and that's done
42:24 - through variables now the way you create
42:26 - a new variable in Blueprint is by
42:28 - clicking on this little plus icon on the
42:30 - left hand side
42:32 - this menu is available in almost every
42:34 - blueprint so click on the plus icon and
42:37 - you can create a variable
42:40 - now let's just call it my variable for
42:42 - example
42:43 - now over here since blueprint is based
42:47 - on C plus plus obviously you you have to
42:51 - define a type for it so by default it's
42:53 - set to Boolean but you can select any
42:55 - one of the other types I'll go over some
42:57 - of the important ones if you are
42:59 - familiar with C plus plus these things
43:01 - will seem pretty simple to you guys so
43:05 - Boolean is basically a true or false
43:07 - value so for example
43:09 - if I drag my variable and let's say you
43:11 - want to get the value of a variable you
43:13 - can drag it and hit get so this is going
43:16 - to be the value so off of this pin let's
43:19 - say I I type in if
43:21 - we'll get to branching and stuff a bit
43:23 - later but I can do stuff like this since
43:26 - this is a true or false value if this
43:29 - variable is true this execution pin is
43:31 - going to come out if the value is false
43:34 - this execution pin is going to come out
43:37 - so that's basically how it works same
43:40 - way with all the other types so I can
43:42 - click on this variable and change the
43:43 - type to integer
43:45 - which is basically a non-fractional
43:47 - number N64 is basically 64 but integer
43:50 - so let's say you have larger numbers so
43:53 - you would use integer 64. however I
43:56 - don't really find many use cases for it
43:58 - float is a decimal number and then you
44:02 - have name String and text all of which
44:04 - are string types most of the times you
44:06 - would be using string
44:08 - however in some cases you would use name
44:10 - as well for example in tags which we
44:12 - will talk about later and text is mostly
44:16 - used for UI and stuff like that so if
44:20 - whatever you see in menus and things
44:22 - like that uh the text the strings over
44:25 - there are stored as text so that's the
44:28 - data type you'll use now a vector is a
44:32 - struct with three floats in it x y and z
44:36 - now obviously if you don't know what a
44:39 - struct is we will again talk about that
44:41 - no issues Rotator is a similar thing
44:44 - except uh there is a limitation on what
44:47 - values you can have you can only have a
44:50 - value of 0 up until 360. beyond that the
44:54 - Rotator is going to be invalid
44:56 - and transform is basically a struct
45:00 - again which contains a vector
45:03 - a rotator and a vector so location
45:07 - rotation and scale so this is
45:10 - transformed these are the fundamental
45:12 - types which you use most of the time
45:15 - however if you go undestruct you would
45:18 - see there are a lot more you will not
45:20 - use most of these uh some of the common
45:22 - ones that you will use are things such
45:24 - as hit result so hit result is a common
45:27 - one that you'll use now if I compile
45:29 - this and if I go ahead and drag this out
45:34 - and if I go ahead and break and one more
45:37 - thing if you want to get this variable
45:38 - there's a shortcut if you hold Ctrl and
45:41 - drag it you will get the value and if
45:43 - you want to set this variable you can
45:45 - all drag it so that's just a small tip I
45:48 - can give you guys
45:49 - so now bracket result is going to show
45:52 - us all the different
45:54 - variables inside this now similarly you
45:57 - can do that with any other struct if you
45:59 - just drag off of this and try type in
46:00 - break you can do that or with some
46:03 - structs you can you can even do split
46:05 - struct pin
46:07 - or actually with all structs
46:09 - so that's basically another way to see
46:11 - what members are there in the struct so
46:14 - for example uh similar to this this was
46:16 - the same struct over here so you see
46:19 - initial overlap so this is going to be
46:21 - their blocking hit location and things
46:24 - like that so that's basically your
46:26 - struct that's how it works in Blueprint
46:29 - and one
46:31 - different type is going to be our object
46:33 - type variable so for example if I select
46:35 - an actor and this was an object type as
46:38 - well if I drag off of this the variable
46:41 - which is color coded in your sky blue or
46:44 - your light blue color so these are
46:47 - basically object references
46:49 - internally when you write these in C
46:52 - plus plus so let's say you create an
46:55 - object reference for blueprint in C plus
46:57 - you can expose C plus plus variables to
46:59 - blueprint by the way they are stored as
47:02 - pointers so basically it's the memory
47:04 - address to that object now if some of
47:07 - these things sound confusing to you just
47:10 - stick along and watch the course till
47:14 - the end and if you guys still have any
47:16 - confusions make sure you guys do check
47:18 - out a video on pointers and I will go
47:22 - over actors and stuff like that
47:24 - basically uh this variable is going to
47:27 - refer to an actor and since this is a
47:30 - pointer and the default value is none so
47:32 - if I go ahead and click on this you see
47:34 - it says None so what this means is this
47:37 - is not a valid pointer and if we
47:39 - actually had some logic in C plus plus
47:41 - it would throw an exception so that's
47:45 - basically how object types work and you
47:47 - all also have enumerations which are are
47:51 - in in some disguise just your byte which
47:56 - is an unsigned 8-bit integer so
47:58 - basically uh for example if I just grab
48:01 - a random enum over here I can do a
48:05 - switch which we'll talk about
48:07 - so basically depending on the value of
48:10 - this variable you can perform your logic
48:13 - so a common thing that you would use it
48:15 - for is let's say you have a weapon in a
48:17 - game and depending on the type so let's
48:20 - say a weapon is fully automatic you
48:22 - would have an enumeration so one of
48:25 - these enumerators is going to be full
48:27 - auto the other one is going to be
48:29 - semi-auto the other one is going to be
48:31 - bolt action and depending on that you
48:33 - would execute the appropriate logic so
48:35 - that's one way of using enums there are
48:37 - many applications of course we will get
48:39 - to most of them later
48:42 - [Music]
48:46 - now that's about how you basically
48:49 - create variables so now let's actually
48:51 - talk about a few special types of
48:54 - variables namely structs and enums now I
48:57 - did show you what's a struct and Anum
48:59 - but I'm pretty sure it went all over
49:01 - your head if you're a beginner so let's
49:02 - just delete that and click on this
49:04 - variable and hit delete to delete that
49:06 - as well compile and save that
49:08 - now go ahead and right click create a
49:12 - new folder and call it structs and I'm
49:15 - doing this in my content folder uh you
49:18 - could do it in the same place if you
49:19 - want to follow along
49:21 - right click go ahead into Blueprints and
49:25 - create a structure
49:27 - and for now let's just call it my struct
49:32 - now
49:34 - structs by definition in C plus plus is
49:37 - going to be similar to your classes
49:40 - so basically you wrap a bunch of data
49:43 - and methods
49:44 - into a single unit
49:46 - however in Blueprint as a structure
49:50 - purely refers to a collection of
49:52 - variables you cannot have functions for
49:55 - structs in Blueprint sadly however you
49:58 - could just create a library for that so
50:01 - you have blueprint function libraries
50:03 - and you could just create functions for
50:04 - your structs
50:06 - anyways so the way you work with this is
50:10 - you can create a bunch of member
50:11 - variables a very simple example is going
50:15 - to be a 2d Vector Unreal Engine already
50:18 - has a 2d Vector type but just for
50:20 - demonstration purposes let's just create
50:22 - one so let's just call this X and make
50:26 - this of type float because it's a
50:28 - decimal number
50:30 - add in another variable
50:32 - make it of type Y and make this of type
50:36 - float once again so basically my struct
50:40 - is going to contain these two variables
50:42 - now if I head back into my level make
50:44 - sure you save this
50:46 - and if I go ahead and right click
50:48 - somewhere and type in Maestra
50:52 - you see you get an option called Break
50:54 - make and set members so if I go ahead
50:57 - and press break you see you get options
50:59 - X and Y now just like how you create an
51:02 - integer or any other variable you can
51:04 - create a struct as well so let's just
51:06 - call this one I don't know maybe my
51:09 - variable once again
51:13 - and it's going to be of type my struct
51:16 - so my struct is the type so this is our
51:19 - user defined data type
51:21 - now I can go ahead and get this I can
51:24 - right click perform split struct pin
51:27 - once again
51:28 - so this is basically how struct so
51:30 - basically you have one variable which
51:32 - stores multiple variables within it so
51:35 - this can be very handy for example in
51:37 - this hit result you have all these
51:39 - variables now it did not need not be the
51:42 - same type the types can be heterogeneous
51:45 - so I could have an integer over here I
51:49 - could have a string over here
51:51 - so let's say I have a student struct I
51:53 - could store name
51:55 - his role number and stuff like that so
51:57 - just a big example over there
52:00 - so that's basically how structs work in
52:03 - Blueprint so I'll just delete that we
52:05 - don't really need it but we'll keep my
52:07 - strength let's actually have something
52:10 - more descriptive let's say we have name
52:13 - and let's say we have points
52:15 - this makes no sense right now but we can
52:18 - use this a bit later on
52:20 - and you could anytime add a new variable
52:23 - but remember avoid removing variables
52:26 - from structs sometimes they do cause
52:28 - some issues with the blueprint so be
52:31 - careful with that in C plus plus though
52:33 - it won't be too much of a problem since
52:35 - you refer to the members by their names
52:37 - so that's one thing to note
52:40 - now one more thing if you guys want to
52:43 - set the members of a struct what you do
52:46 - is you just type in set members
52:49 - and you can get the struct name that is
52:52 - my struct in our case so we can use this
52:55 - and set the members now over here on the
52:57 - right hand side under default category
52:59 - you can get any one of the variables as
53:01 - pins and you can set the value now
53:04 - obviously you will need to tell it which
53:06 - struct so let's say you created a
53:08 - variable of type my struct
53:11 - so by struct
53:13 - you can go ahead and pass that as the
53:16 - struct reference now this is a reference
53:18 - because this pin over here is diamond in
53:21 - shape or rhombus or whatever that is so
53:24 - that means it's a reference so it is
53:26 - referring to the actual
53:29 - variable that you pass in
53:32 - so it is going to adjust the value of
53:34 - this variable
53:37 - [Music]
53:38 - oh
53:41 - we will deal with a lot of structs as we
53:44 - move on however there's one more special
53:46 - type which I would like to mention and
53:48 - those are enumeration so I will right
53:51 - click create a new folder and I'll call
53:53 - this one enums
53:54 - open it up and over here I can head into
53:57 - blueprints again and type in enumeration
54:00 - so this is basically a list of values
54:02 - and you could perform your logic
54:04 - depending on this list so let's just uh
54:08 - create an enum and let's call this one
54:11 - my enum again
54:13 - now over here you can add enumerators
54:15 - which basically are list items so let's
54:17 - say add three items so for example let's
54:22 - take names of fruits so Apple
54:26 - banana let's say and maybe a mango
54:31 - now once you do this these are basically
54:35 - the enumerators which are there and I
54:37 - will show you guys what it actually
54:38 - implies
54:39 - so I'll just go ahead and create a new
54:41 - variable and I'll call this one I don't
54:44 - know let's say
54:46 - fruits choice for example
54:48 - and it's going to be of type my enum
54:53 - now internally ultimately an enumeration
54:56 - is just a number basically it's a number
54:59 - between 0 and 256 so for example
55:02 - over here apple is going to be index to
55:06 - 1. Banana is going to be mapped to 2 and
55:09 - mango is going to be mapped to I mean
55:11 - one and uh mango is going to be mapped
55:14 - to 2 so 0 1 2 so that's how it's going
55:18 - to be internally now obviously you can
55:20 - give a description as well over here in
55:22 - Blueprint
55:23 - uh so if I just drag this in now by
55:26 - default it is set to Apple you can see
55:28 - the default value on the right hand side
55:30 - and we will talk about all these options
55:32 - a bit later on in the variable section
55:34 - so just to be brief uh if you are like
55:38 - creating new objects in your scene uh
55:42 - you would need some of these and for
55:44 - multiplayer and stuff you would need
55:45 - replication and we will talk about them
55:48 - in depth so nothing to worry about now
55:50 - you can cast it to a string so unreal
55:54 - has it built in to give this out as a
55:56 - string
55:57 - so if you see you should get apple
55:59 - printed
56:01 - oops I have something on tick so let's
56:03 - just delete that
56:05 - so nothing's printing
56:08 - uh okay we have a delay of two seconds
56:10 - let's just delete the set actor location
56:12 - stuff
56:15 - and just print this in
56:17 - and we could actually change this as
56:20 - well
56:23 - you can copy this and paste it by
56:26 - hitting Ctrl D so if you click on this
56:28 - and hit Ctrl D you can duplicate it and
56:31 - if you drag off of this
56:33 - you'll see you can perform a switch
56:36 - so basically if the value of fruits
56:38 - choice is Apple
56:40 - it's going to perform this logic so
56:43 - let's just say
56:46 - held it for example
56:49 - and for
56:51 - banana let's just give something else
56:55 - so it honestly doesn't matter
56:58 - copy that over
56:59 - and let's say we give tasty for mango
57:04 - so if I go ahead and press play you
57:07 - should see it says apple and healthy
57:10 - now
57:11 - if I set this value so if I alt drag it
57:14 - and I set this to banana
57:19 - now you should be able to see that it
57:22 - prints the second string
57:25 - so this is basically how enums work and
57:29 - this was actually a bit of a lengthy way
57:32 - I did it there's actually another
57:33 - shortcut you can use in Blueprint in C
57:36 - plus plus though this is the only way
57:37 - you would just type in switch instead of
57:40 - using this node
57:42 - so one more shortcut is if you drag off
57:45 - of this and type in select
57:47 - depending on the value of this enum you
57:51 - can make it do certain things so let me
57:53 - remove the switch here
57:56 - so now what I'm saying is if the value
58:00 - of fruits choice is Apple this is the
58:02 - value that will be passed so in this
58:04 - case I'll just type in one for example
58:06 - and over here I'm going to type 2 and 3.
58:09 - so what we are saying is if the value of
58:12 - this enumeration is Apple it's going to
58:14 - print out one so the value which will be
58:16 - returned here is going to be this value
58:18 - same with the other two choices so if I
58:22 - press play you see it says apple and it
58:24 - says two that's because we had set our
58:27 - choice over here if I change this to
58:29 - Mango over here we are going to get
58:31 - three so that's basically how
58:33 - enumerations work
58:35 - [Music]
58:43 - real engine let's start talking about
58:46 - the core scripting features in Blueprint
58:48 - so the first thing that you can do is
58:50 - create functions now a function is
58:53 - basically a block of code which adds
58:57 - functionality to your program so what I
58:59 - mean by that so in order to create a new
59:01 - function you can go ahead and click on
59:03 - this plus icon right here
59:05 - and we could call it whatever we want we
59:09 - could call this one my function
59:12 - and generally speaking you would use
59:14 - Pascal case so basically each word is
59:18 - going to start with an uppercase
59:19 - character
59:21 - so generally that's a convention you use
59:23 - you could use a space as well in
59:25 - Blueprint but generally it's not a good
59:26 - practice
59:28 - now I can call this function from my
59:31 - event graph now if you see you have
59:33 - opened two tabs one is the event graph
59:35 - and one is my function so I can close my
59:38 - function and I can double click on this
59:39 - on the left hand side to open it as well
59:42 - now if I drag this in
59:45 - or if I right click and type in my
59:48 - function
59:49 - you can go ahead and call it so
59:51 - basically this is going to execute my
59:53 - function
59:54 - so let's go ahead and actually do
59:58 - something with it now inside my function
60:00 - this is blank right now I can just go
60:02 - ahead and print a string
60:04 - and we can call this one my function is
60:08 - executed
60:10 - so I think I butchered the spelling but
60:13 - doesn't matter
60:14 - so if I go ahead and press play you see
60:16 - my function is executed
60:19 - now we can also pass in values so I have
60:23 - created this points variable here so
60:25 - just create a new variable and make it
60:27 - of type integer and call it points
60:29 - now if you head into your function and
60:32 - click on this block right here
60:34 - you can actually add input and output
60:37 - parameters so if I click on the plus
60:38 - icon
60:39 - and change the type to integer and I can
60:43 - call this one points
60:45 - so I can take this points value from
60:48 - outside the function so if you look at
60:50 - this now
60:51 - you see I can pass in points
60:55 - so that's pretty handy now I can go
60:59 - ahead and print this out as well
61:01 - so I can print out my function is
61:03 - executed and I can print out points as
61:06 - well
61:07 - and if you double click on the wire you
61:08 - can use the reroute node to keep things
61:10 - a bit clean
61:13 - now if I press play
61:14 - you see you get my function is executed
61:17 - and you get 0. now if I change the value
61:19 - of points for example
61:21 - you see we get that number
61:23 - so this is basically how input
61:25 - parameters work
61:28 - now what if you had some return value
61:30 - now let's say instead of points this was
61:33 - health so let me just call this one
61:35 - Health
61:36 - so compile that and over here if I click
61:39 - on this once again I can add in an
61:41 - output and you see it creates a return
61:44 - node for us
61:45 - so this is basically like your return
61:48 - keyword in C plus plus so when your
61:51 - function goes to this it's going to exit
61:53 - the function and the value whatever you
61:56 - want is going to be returned now you
61:58 - need not have it you can have an empty
62:00 - return node as well
62:02 - now in our case let's just return a
62:04 - Boolean and let's just call it
62:07 - be killed for example and let's change
62:09 - the name of this to be
62:11 - Health as well
62:14 - and we could do a simple if check we
62:16 - will talk about if as soon as we finish
62:19 - functions events and stuff like that
62:21 - so if
62:23 - I can't do that so let me just grab in
62:26 - an if
62:27 - if this value
62:29 - that is our health
62:31 - is less than zero
62:34 - or less than or equal to 0
62:37 - then
62:38 - what we can do
62:40 - is if it is true and if you type in Ctrl
62:43 - D you can have two return nodes
62:46 - so if our health is less than zero
62:48 - it's going to be true otherwise it's
62:51 - going to be a false now you can go ahead
62:54 - and print this out over here
62:58 - now our health is 32
63:01 - so we should have false
63:02 - let's say we set our health to be -1
63:06 - which is invalid of course but we get
63:09 - true
63:09 - so this is how you can return values
63:11 - outside a function
63:13 - now one aspect of functions which I did
63:16 - not cover and I'm recording this a bit
63:19 - later
63:20 - it is going to be local variables so
63:23 - what if you had some variable which you
63:26 - wanted only within a function
63:28 - so let's say for example we have a
63:31 - variable temp for example so let's say
63:34 - you wanted a number to be stored
63:36 - temporarily inside so for that case you
63:39 - would use this local variable option
63:41 - they work exactly the same as you would
63:43 - as it works in C plus plus and one more
63:47 - thing the input parameters whatever you
63:49 - take are also local variables so you can
63:51 - just grab an in and instead of dragging
63:55 - this actually you can right click and
63:57 - type in in
63:58 - and if I just get it so I should find it
64:01 - at the very end of somewhere
64:04 - or rather let me just type it get in
64:08 - so N is a really commonly used word so
64:10 - that's the reason we are getting it so
64:13 - many times here so let's actually change
64:15 - it so let's just type in in one two
64:17 - three let's say so n one two three so
64:20 - you can get it actually
64:22 - so you don't actually have to drag this
64:25 - let's say you have a large blueprint
64:27 - graph you don't have to drag it actually
64:29 - you could you could just do this over
64:30 - here that works totally fine as well
64:33 - even over here actually you could do
64:35 - this and it's totally valid
64:38 - so that's about it for local variables
64:41 - as you use them you will kind of
64:43 - understand their purpose but without a
64:45 - solid example we will not actually be
64:48 - able to tell the use case however once
64:51 - we actually get to the end where we
64:52 - actually create something that is when
64:54 - we'll get to practical examples
64:58 - [Music]
65:02 - at the base level those are what
65:05 - functions are and we will go a lot more
65:08 - in depth about functions events and
65:10 - stuff so not to worry about that I'll
65:12 - just go ahead and deleted that let's
65:13 - create a new one once again and now
65:16 - let's talk about the limitations and
65:18 - let's talk about the next type of
65:20 - scripting feature in Blueprint now one
65:23 - limitation that you would see is you
65:25 - cannot add a delay so if I right click
65:26 - and type in delay you actually don't get
65:29 - a delay note the reason is
65:32 - you cannot have latent nodes inside a
65:34 - function in Blueprint
65:36 - so delay is actually a latent function
65:39 - so what I mean by that is it actually
65:41 - takes some time to execute so let's say
65:43 - I cut or copy this and paste it in here
65:48 - you see I cannot do that it says one or
65:51 - more copied notes could not be pasted
65:52 - into this graph
65:54 - so the way you can handle this is you
65:57 - can use a macro now macros and
65:59 - blueprints are more like functions than
66:02 - C plus plus macros so they work a little
66:05 - bit different
66:07 - now if I call this one my macro for
66:09 - example
66:10 - I can go ahead and add a delay so I I
66:13 - can hold down D on my keyboard and left
66:15 - click and I can add in a delay one thing
66:17 - you'll notice is by default it doesn't
66:19 - have any input or output pins you can go
66:21 - ahead and add that
66:23 - but there is another advantage of macros
66:26 - now for example let's say we we have a
66:31 - database
66:32 - on our server and let's say it takes
66:35 - some time to retrieve the data so let's
66:37 - say it takes around 0.5 seconds for your
66:40 - computer to connect to the database and
66:42 - retrieve the data this is just an
66:44 - example it could be anything that takes
66:47 - time for example uh the prime number
66:49 - program takes some time to execute after
66:52 - you go to a larger number
66:54 - so while this is being executed
66:58 - now let's say you just wanted to print
67:00 - out something saying that it's starting
67:03 - and then you want to do something else
67:06 - when it's completed this is where it can
67:08 - come handy
67:09 - now you can type in print string
67:13 - and you can call this one
67:15 - starting now
67:19 - you could come in here and now you would
67:21 - notice this execution pin got
67:23 - disconnected you can't do them parallely
67:24 - but there's a workaround for that you
67:26 - can type in sorry sequence
67:30 - and over here you can just print this
67:32 - out and then you can go ahead and
67:35 - perform this
67:36 - and over here in the output as well you
67:39 - can drag this in and a handy thing which
67:42 - you cannot do in your return node in
67:44 - your function is you can have one more
67:46 - of these
67:47 - so now if I just give a longer delay so
67:50 - that we can recognize it
67:52 - and if I drag in my macro
67:56 - and if I print out strings over here
68:00 - and over here
68:02 - so we'll call this one done and here
68:04 - let's just print
68:06 - starting underscore outside for example
68:11 - so if I press play starting now and
68:14 - starting outside got executed first then
68:16 - after two seconds are done was executed
68:19 - so things like that can be done by
68:21 - macros which you cannot do in functions
68:25 - [Music]
68:30 - now the whole point of using our own
68:33 - macros and functions is of course code
68:35 - reusability so let's say I want to call
68:38 - this macro once again I can just type in
68:40 - my macro
68:42 - and I can call it now one difference I
68:46 - would like to mention and then we'll
68:47 - head into the next one which is collapse
68:49 - graphs is with a function let's say I
68:53 - call this my function
68:56 - my function
68:58 - I can actually execute this from another
69:01 - blueprint but this is not true for level
69:04 - blueprints it's a little more tricky to
69:06 - do it from level level blueprints you
69:08 - you guys will understand why once we
69:10 - actually head into classes and stuff
69:12 - but I'll just show you guys a simple
69:15 - example so I'll just create a blueprint
69:18 - here of type actor and we'll talk in
69:20 - depth about this later and let's say I
69:23 - create a function as you can see the
69:24 - same uh
69:26 - features in the blueprint are available
69:28 - here and let's just call it warrant test
69:31 - for example
69:33 - compile that now if I were to get an
69:37 - object reference to new blueprint so
69:39 - I'll just do that by dragging it into
69:41 - the level
69:42 - so I'll drag this
69:44 - and I'll create a reference
69:46 - and if you can notice I can actually
69:49 - call test from here however if I create
69:52 - a macro
69:54 - so let's just call this one test M for
69:57 - test macro
69:59 - you would see even once I save and
70:01 - compile everything
70:03 - I cannot call test m i see test but I
70:07 - don't see test M so that's one more
70:09 - difference between a macro and a
70:10 - function you cannot call a macro from
70:13 - you know uh other blueprints but you can
70:16 - call functions from other blueprints of
70:19 - course if you set the axis specifier to
70:21 - be private in that then you can't call
70:24 - functions either but you can by default
70:27 - now what if you didn't want to reuse
70:30 - them what if you just had this code but
70:34 - this looks a bit messy so you wanted
70:37 - them to be shown as one node let's say
70:39 - this whole thing did something one you
70:42 - could just press C on your keyboard and
70:44 - comment it
70:45 - however there's another feature in
70:47 - unreal called collapsed graphs now you
70:50 - can right click and click on collapse
70:52 - nodes and it's going to create a
70:54 - collapsed graph now you can have inputs
70:57 - and outputs here as well but in my
71:00 - experience I have never really bothered
71:03 - using them
71:04 - and let's just call this one my collapse
71:08 - graph
71:11 - and if I go ahead and type in my
71:14 - collapse graph by right clicking
71:16 - so let's say I type in my collapse graph
71:18 - you see I cannot call it because this is
71:21 - not a function this is just all of this
71:23 - code
71:26 - just stuffed into this collapsed graph
71:30 - so I lost my event graph here you can
71:32 - head back in or you can click on this
71:34 - away
71:35 - so that's basically a collapsed craft
71:37 - that's about it and when we actually use
71:40 - them you will get an idea you can
71:41 - actually have further execution so let's
71:44 - say I have this
71:47 - so it's going to come out of here as
71:49 - well
71:51 - so stuff like that so I'll go ahead and
71:53 - delete that it's not of much relevance
71:56 - [Music]
72:00 - now that we have studied about functions
72:03 - macros and collapse graphs let's
72:05 - actually look at implementing the
72:07 - various programming constructs inside
72:09 - blueprint so we'll use the level
72:11 - blueprint again and after this we will
72:14 - get to actually working with blueprint
72:16 - classes now the first thing that you
72:19 - would want to do is do an if check and
72:21 - we already did that several times so if
72:23 - you right click and type in Branch or
72:26 - you could just type in if
72:28 - or you could hold down B on your
72:30 - keyboard and left click that's another
72:31 - shortcut which I like to use you would
72:34 - bring up a branch node so a branch node
72:37 - takes in a Boolean and depending on its
72:40 - value it's either going to go true or
72:43 - false this is an execution pin again so
72:45 - depending on the value of this variable
72:47 - you can go ahead and execute some logic
72:49 - so instead of Health let's say I have B
72:53 - Alive as a variable so if the player is
72:55 - alive for example
72:57 - so put that in so if the player is alive
73:01 - then we are going to go ahead and run
73:06 - this logic otherwise we are going to run
73:09 - this
73:10 - now there's another thing which you can
73:12 - do with booleans which I probably
73:14 - mentioned for enums but you can actually
73:16 - do a select as well so if I go ahead and
73:19 - select
73:22 - you can go ahead and do this so again
73:24 - you can actually get this return value
73:28 - to take it to change depending on the
73:30 - value of this variable
73:32 - so this comes in pretty handy
73:35 - now this is the most basic type and
73:37 - there's nothing much to explain really
73:38 - so you could go ahead and print
73:40 - something and maybe do something else
73:42 - and if he's not alive maybe you can go
73:45 - ahead and you can quit the game or
73:47 - anything like that
73:49 - so that's basically it
73:51 - [Music]
73:55 - now the next construct that you'll use
73:58 - is switch now switch is something which
74:01 - we already talked about but we are going
74:03 - to go a bit more in depth now now I'll
74:06 - change this variable to an integer again
74:08 - or rather I'll just undo everything so
74:10 - that we have our integer back okay I've
74:13 - saved it in between so we can't
74:15 - so I'll just change the variable type
74:18 - and for this we are going to rename this
74:22 - to let's say health again
74:26 - now I have health
74:28 - so oops let's just compile that again
74:32 - control drag it now if I drag off of
74:35 - this and type in switch
74:37 - you would see that I get the switch on
74:39 - end node now basically what this means
74:43 - is if I just click on ADD pin
74:46 - and you can also set the start index so
74:48 - let's say you want it to be negative 1
74:49 - to start with you could do that as well
74:52 - negative 2 for example
74:54 - so what you are basically saying is if
74:56 - the value of health is 1
74:58 - head into this execution pin
75:01 - otherwise default is basically like an
75:04 - else
75:05 - so if none of these corresponds so let's
75:08 - say we have one two and three if the
75:11 - health is neither one nor two not three
75:13 - it's going to head into default
75:16 - so for example if I just go ahead and
75:18 - print now since our health is 0 and we
75:21 - are starting at 1 we should get hello
75:23 - printed in theory
75:25 - so we get hello
75:27 - if I go ahead and drag off of one you're
75:32 - not going to get anything
75:33 - now the same thing if I just change the
75:35 - value to 1
75:37 - I change the health variable value to 1.
75:39 - now you should get hello
75:43 - so this is how switch Works generally I
75:45 - would be using this with enumeration so
75:47 - for example we have my inner mother
75:50 - so let's just delete everything in the
75:52 - graph now my enum
75:55 - my enum now if I
75:58 - grab this into the graph and if I then
76:01 - type in switch you see
76:04 - you get the options so if health
76:08 - okay we can rename that to something a
76:10 - little more descriptive so let's just
76:12 - type in some enum
76:16 - so if our enum if some enum is Apple
76:20 - this is going to be executed if some
76:24 - enum is banana this is going to be
76:26 - executed if some enum is mango this is
76:29 - going to be executed so this is
76:31 - basically how switch works so that's
76:33 - about it actually now
76:36 - this was for your selection and to
76:41 - evaluate condition
76:42 - [Music]
76:47 - now coming to the iterative constructs
76:49 - let's say you wanted to print numbers
76:51 - from 1 to 10 you can use a loop now if
76:55 - you guys are familiar with CC plus plus
76:56 - these will seem much much easier to deal
76:59 - with there are basically two types of
77:01 - Loop and there is a version of while
77:04 - loop called do while loop so the types
77:06 - are while and far
77:07 - and there is one more type which you use
77:10 - a lot which is for each and we will get
77:13 - to that once we start talking out arrays
77:15 - now if I right click and type in while
77:20 - you see you get while loop
77:22 - so what this basically means is as long
77:25 - as this Boolean is true
77:27 - so I can change this to Boolean once
77:29 - again
77:30 - as long as this is true
77:33 - this value is going this Loop body is
77:36 - going to be executed so for example
77:39 - uh let's say uh let's actually make this
77:43 - a number again let's change this let's
77:45 - say I wanted to print numbers from 0 to
77:48 - 10. so I'd set the sum enum or we'll
77:52 - call this one num we can set num to be
77:54 - equal to 0 by default
77:56 - and now we can do an if check as long as
78:00 - number is less than or equal to 0
78:03 - or rather 10
78:05 - we can go ahead and print our number so
78:09 - we can go ahead and type in print string
78:11 - and we can just Ctrl D print it out
78:17 - now obviously the this is an infinite
78:19 - Loop you have to change the value of num
78:21 - itself so what I can do is I can set
78:27 - num
78:28 - to be equal to num Plus 1.
78:31 - so this is one way to do it
78:33 - also if you were to notice if you just
78:36 - drag off of the sentiment plus plus you
78:39 - can actually do increment as well so
78:41 - this is basically like your num plus
78:43 - plus in C plus plus that's how we would
78:45 - interpret that
78:47 - now if I go ahead and press play you
78:50 - should see we get numbers from 0 to 10
78:52 - as expected so that's basically how you
78:55 - use a while loop and once this Loop is
78:57 - done again you can go ahead and print
78:59 - something so let's say printed numbers
79:03 - printed numbers
79:06 - now you see it prints from 0 to 10
79:09 - and it just goes to completed this is
79:12 - how we would execute your logic one
79:15 - thing to note though avoid using Loops
79:18 - in your program especially in Blueprint
79:20 - unless the array length is you know less
79:23 - than about a few hundred it's fine but
79:26 - let's say you're dealing with larger
79:28 - data sets please refrain from using
79:31 - Loops in Blueprint uh try to use as much
79:34 - as you can in C plus plus
79:37 - because blueprint if I haven't mentioned
79:40 - yet is slower compared to C plus plus
79:43 - when you call Print string for example
79:46 - this is actually a function called in C
79:49 - plus plus so the actual function of
79:51 - print string is written in C plus plus
79:54 - it actually takes a little bit of
79:57 - processing to actually switch between
80:00 - blueprint and C plus plus blueprint is
80:03 - kind of like your jvm where it actually
80:06 - runs on a virtual machine so blueprint
80:08 - code is going to be comparatively slower
80:10 - than C plus plus but in this case this
80:13 - code is pretty simple so you don't
80:14 - really need to do that we will get to
80:17 - where to use blueprint and C plus plus
80:18 - much much later there's nothing much to
80:21 - worry about for simple games
80:23 - [Music]
80:28 - now the other type is going to be a for
80:30 - Loop
80:31 - so if I just type in for Loop you see
80:34 - you get for Loop this is how you
80:36 - basically execute your for Loop however
80:38 - this is a little more or actually much
80:41 - more easier than what you have to do in
80:42 - C plus plus in C plus plus you give an
80:45 - initialization expression an update
80:47 - expression and a conditional expression
80:50 - I am mixed up the order but anyways you
80:52 - get the point and you got to actually
80:55 - give the body of the loop like that but
80:58 - here in Blueprint you just type in a
81:00 - first and the last index which makes it
81:01 - very very simple for you to execute a
81:04 - for Loop and if you were to just drag
81:07 - this in let's say I just type in 0 and
81:10 - 10. and I just go ahead and print this
81:13 - we don't even need a variable at this
81:15 - point
81:16 - we can just grab this
81:18 - and we can go ahead and run this and
81:22 - it's going to print 0 to 10. so this is
81:24 - how you use a for Loop now there is
81:26 - another variation known as the for each
81:29 - Loop which is used similar to range
81:33 - based for Loop in C plus plus to iterate
81:35 - arrays and stuff like that we will talk
81:37 - about that now again the completed works
81:40 - the same way once this Loop is completed
81:42 - executing you can go ahead and print
81:44 - something
81:46 - or execute whatever logic you have so
81:50 - this is your for Loop and there is
81:52 - another variant of for Loop called the
81:54 - for loop with brick
81:56 - so if I just type in for loop with brick
81:59 - you see you get this now let's say I
82:01 - wanted to stop at a certain point
82:05 - let's say
82:06 - uh I mean in this case it's kind of
82:09 - useless to do it but let's say I wanted
82:12 - to stop in between let's say I have some
82:15 - logic we can just grab in some random
82:17 - logic uh let's say this number divided
82:20 - by 15 you know uh we have to make this
82:24 - float remember because integer division
82:26 - works in a different way
82:28 - so let's say this number divided by 15
82:31 - if it is greater than 3.5 we want to
82:34 - break let's say we have that logic
82:37 - so we are going to print as long as this
82:40 - number divided by 15 is greater than 3.5
82:43 - so do that if this is true we are going
82:46 - to break whoops
82:49 - and if we go ahead and print this we can
82:53 - just go ahead and print the number
82:54 - instead
82:56 - and once this is completed we can print
82:58 - something else now obviously to tidy
83:01 - this up you can use a reroute node and
83:02 - you can do this
83:04 - so this is one way to keep your
83:06 - blueprint craft ID
83:08 - so we can type in completed
83:13 - so that's done
83:15 - and we have a compiler error it says
83:19 - so
83:21 - okay we'll we'll take that in as a float
83:24 - so convert this pin to a float
83:28 - convert this pin to a float and then
83:31 - let's just do that
83:34 - and let's compile this again
83:36 - save
83:38 - and go ahead and press play
83:40 - now we would see it's 52
83:43 - so if we actually bring up our
83:45 - calculator
83:46 - so we get 51 by 15 is going to be 3.4
83:51 - and 52 divided by 15 is going to be
83:56 - 3.466 so that should be the last number
84:00 - so now if I do 53 divided by 15 you see
84:04 - you get 3.53 which is greater than 3.5
84:06 - so it did not print that
84:09 - foreign
84:17 - to head into R for each Loop now for
84:22 - this we'll need to learn about another
84:23 - data structure now this is a variable
84:26 - right over here where you select the
84:29 - variable type to the right of it you get
84:31 - an option to change it to an array set
84:33 - or a map now an array is basically
84:37 - a collection of homogeneous elements so
84:40 - basically in this case num is now no
84:44 - longer a single number
84:46 - instead it is a collection of numbers
84:49 - and why I say homogeneous is because I
84:51 - can only have integers in this list I
84:54 - can't have 0 and I can't have a string
84:56 - in the next index so basically each item
84:59 - is going to be referenced by an index so
85:01 - the first item which you put in is going
85:03 - to be 0 and stuff like that you can put
85:05 - in any number and if I have to iterate
85:08 - through this I will use a for each Loop
85:12 - now if I go ahead and print this out
85:15 - you would be able to see that I print in
85:18 - all the elements in that array so I
85:21 - printed in 2 and 32.
85:23 - which is what exactly what we have so
85:26 - that's basically how it works now one
85:30 - more thing you can have it of any type
85:33 - in case you guys were confused I'll
85:34 - create a new one for example uh let's
85:37 - just call it one Str array
85:40 - and let's make it of type string and
85:43 - let's compile that and I can go ahead
85:45 - and add a few elements I can I can just
85:48 - type in any set of characters
85:51 - and I could iterate through this as well
85:53 - so I can just drag this in
85:56 - compile that and go ahead and run this
85:59 - program
86:01 - now you see you can print that as well
86:04 - so this basically stores multiple of the
86:08 - data types elements and one more thing
86:11 - since this is an array this is more of a
86:13 - theory thing but
86:15 - the elements here so this string so
86:18 - let's just actually name it one two and
86:20 - three for our reference
86:22 - so 1 is 1 2 and 3 these are actually
86:25 - stored in continuous memory locations so
86:27 - iterating through them is actually a
86:29 - relatively cheap option now
86:31 - unfortunately Unreal Engine does not
86:33 - provide us with a linked list structures
86:35 - in Blueprint we have to implement that
86:37 - ourselves if we needed to but most of
86:41 - the times you'll be using arrays and
86:42 - Maps you will not be using sets or
86:45 - linked lists most of the time however it
86:47 - is Handy to use linked lists in some
86:49 - very rare occasions but we will not be
86:52 - going over that anyways so let's just
86:54 - delete all of this we are done with this
86:57 - so that's basically our array and your
87:00 - for each Loop now you can have an array
87:01 - of structures as well it's totally fine
87:03 - so I guess we called our my struct if
87:06 - I'm not wrong
87:07 - we could have an array of those that's
87:09 - about it basically you could store any
87:11 - type of element now I can go ahead and
87:13 - click on the plus icon and I can add the
87:17 - name and points and it works just as you
87:20 - would expect so I can go ahead and
87:22 - delete this we don't need that anymore
87:24 - [Music]
87:25 - foreign
87:28 - now along with your regular if switch
87:32 - and your Loops unreal in blueprints
87:34 - provides us with a a couple of Handy
87:37 - nodes which you might need one of them
87:40 - is called flip flop
87:42 - so what does it mean so flip flop is
87:45 - basically basically this is how a flip
87:47 - flop works if this execution pin goes in
87:51 - once a is going to be executed otherwise
87:55 - if you come here again B is going to be
87:58 - executed so let me actually show you
88:00 - what I mean
88:02 - so if I just drag this in
88:05 - and if I print and let's just say a is
88:09 - executed
88:12 - and now if I just go ahead and given a
88:14 - delay of let's say a second
88:18 - and if I copy this over and let's just
88:21 - type in B is executed give a delay of a
88:24 - second and again head back over there so
88:27 - I'll just use a reroute to make things a
88:29 - little more clear for you guys
88:31 - now make sure you guys do comprehend
88:33 - this logic correctly
88:35 - if I go ahead and press play
88:38 - you would see it says a is executed B is
88:40 - executed and it's going to be
88:42 - alternating like that so that's the use
88:44 - of a flip flop you could use this uh for
88:47 - key presses so let's say you wanted
88:49 - something to happen when you press the
88:51 - key once but you wanted something else
88:54 - to happen when you press the key again
88:55 - so for example let's say you have a
88:58 - scoping in uh thing in your game so
89:02 - let's say a scoping into your weapon
89:03 - let's say the first time when you flip
89:06 - flop to a you want the guy to scope in
89:09 - and when you flip flop to B you want
89:12 - your weapon to scope out so that's
89:15 - basically one place where you can use
89:17 - flip flop so it's pretty simple
89:20 - [Music]
89:24 - now one more thing which the engine
89:26 - provides is do once
89:29 - now do ones and there's also a gate node
89:32 - which you might need but I honestly
89:35 - never gotten an actual use case for this
89:38 - so there's nothing much to really worry
89:40 - about this but it's it can come in handy
89:43 - depending on your game especially if
89:45 - you're going for you know puzzle type
89:46 - games maybe
89:48 - not really sure so do ones basically as
89:52 - the name suggests it just allows you to
89:54 - execute this one time so let's say I
89:57 - print the string
89:59 - and I go back to this this is no longer
90:01 - an infinite loop it's just going to
90:03 - execute it once
90:05 - look it just executed hello and that's
90:07 - about it
90:09 - now let's say I want to call this
90:12 - function just once again so what I can
90:14 - do is I can drag this into reset so if
90:18 - anything goes into this reset the
90:21 - function which goes after completed will
90:23 - be allowed to execute once again so
90:26 - that's basically how do once works I
90:27 - don't think there's any explanation
90:28 - required for it so if I do it on tick so
90:30 - basically every frame it's going to
90:32 - allow you to do it once again and if I
90:35 - just go ahead and re-execute this I know
90:38 - this is an infinite Loop but we do have
90:41 - a little bit of a duration for us in the
90:43 - tick
90:44 - so that's how it will work
90:47 - okay so it did stop the execution over
90:49 - there that's a different thing but yeah
90:52 - basically reset is going to let you do
90:54 - that once again
90:55 - so I can actually get a more practical
90:58 - example so let's say we have a delay of
91:00 - 0.2 seconds and we do this I can
91:03 - actually use a sequence so sequence
91:05 - remember the node which we used before
91:08 - so after 0.2 seconds I can go ahead and
91:11 - reset that
91:12 - and after let's say not 0.5 seconds I
91:16 - can try executing that once again
91:20 - so if I go ahead and press play you see
91:22 - it works as expected
91:25 - [Music]
91:29 - whatever we spoke until now were just
91:32 - the basics in order to get you started
91:34 - with Unreal Engine but in order to
91:36 - actually practically create a game we
91:39 - need to First go into some background so
91:41 - that we can learn how to use classes and
91:43 - objects now if you guys aren't aware
91:46 - Unreal Engine or any game engine in
91:48 - general is going to be working on the
91:51 - principle of object oriented programming
91:54 - a bit of a background here so there are
91:56 - two main programming methods that we'll
91:58 - talk about now the first one is
92:00 - procedural programming so this is the
92:03 - approach used in languages such as C
92:05 - where basically your approach is mainly
92:07 - using functions so procedures that's
92:11 - what basically procedural programming
92:14 - stands for so you have a main function
92:16 - and you have several other functions
92:19 - now this is the most simplest form of
92:22 - what it could be however you could have
92:24 - a function over here as well so let's
92:26 - say you have function 4 for example and
92:29 - maybe function 4 can call function 2 or
92:32 - vice versa doesn't really matter but
92:35 - basically your whole program is divided
92:38 - into multiple functions and there is
92:40 - some global data on which it operates on
92:42 - so you have some data over here and
92:44 - maybe function three accesses some data
92:47 - here stuff like that could happen in
92:49 - procedural programming
92:51 - however the approach which is used in
92:54 - unreal in object-oriented programming
92:57 - languages such as C plus plus is going
93:00 - to be object oriented programming of
93:02 - course as the name suggests
93:04 - and here we use a principle known as
93:08 - classes
93:09 - and an instance of this class is known
93:12 - as an object so let me be a little more
93:15 - specific here so all the data and
93:18 - functions so for example or in this case
93:22 - this was a method this was the main
93:24 - function so we have one method here
93:26 - another one and we also have some data
93:29 - over here
93:30 - so all of this is going to be
93:33 - encapsulated into a unit known as a
93:35 - class and I will get to some examples
93:38 - later
93:38 - so once we have this encapsulated we can
93:41 - go ahead and create instances of these
93:44 - called objects so basically your class
93:47 - acts as a template for these objects
93:50 - now
93:51 - the first question that pops up in your
93:53 - mind would be why do we use object
93:57 - oriented programming over procedural
94:00 - well it's pretty simple to explain that
94:03 - so if we look at the wrong approach that
94:06 - is procedural programming
94:08 - you would know that you would have a
94:11 - character let's say for example so let's
94:13 - actually talk about a character which
94:15 - you'll have in a game and how we would
94:17 - approach it with both programming
94:19 - methods
94:20 - so in procedural programming you would
94:22 - have a character of course you are not
94:25 - defining any unit known as character but
94:27 - let's say we have a character in a
94:29 - program and you you're going to have
94:31 - several functions so you have move turn
94:34 - jump of course you'll have other
94:36 - functions I just took the most Bare
94:38 - Bones example and obviously you'll have
94:41 - the characters transform and if you guys
94:44 - forgot about what transform is transform
94:46 - is basically location rotation and the
94:49 - scale combined then you're also going to
94:51 - have a velocity for the character health
94:54 - and other variables pertaining to your
94:56 - gameplay
94:57 - however there is one problem which you
95:00 - might notice we do not have a unit which
95:03 - we can recognize as a character so we
95:06 - have several functions let's say we call
95:08 - the move function for example now when
95:11 - we move when we call the move function
95:14 - we actually have no idea which character
95:17 - we are moving so character itself
95:22 - is not actually an entity so we don't
95:25 - have an actual entity known as a
95:27 - character our program just has functions
95:30 - same with the transform we cannot
95:33 - instantiate another character so this
95:36 - code this entire code isn't reusable so
95:40 - that's the problem now what if we head
95:43 - back into the object oriented type so if
95:46 - we head back
95:47 - and if you can see here we have a class
95:50 - and we have instantiated several objects
95:53 - now if you were to actually model a
95:56 - character with this you would have your
95:58 - character class obviously with the above
96:00 - mentioned functions and data I didn't
96:01 - want to rewrite that so you'd have a
96:04 - character class
96:06 - and now that we actually have a unit
96:09 - which we can identify as a character we
96:12 - can go ahead and instantiate a character
96:14 - and let's say we call it character one
96:16 - so we are going to instantiate it so we
96:19 - are going to instantiate it and let's
96:21 - say we have another player let's say an
96:23 - enemy so we can go ahead and reuse that
96:25 - once again and instantiate character too
96:28 - so now we don't have to rewrite all the
96:31 - functions and whenever we are actually
96:34 - writing code we have an idea of which
96:37 - exact character we are referring to so
96:40 - character 2 is actually a real time
96:42 - entity and this is known as an object so
96:45 - character one is an object character two
96:47 - and character 3 all these three are
96:49 - objects now if you were to remember in
96:52 - our blueprint notes we had a Target pin
96:55 - so if I bring in for example set actor
96:58 - location
97:00 - so I'll just use the same node so set
97:03 - actor location
97:05 - now you would notice there is a
97:07 - character pin now if you were to just
97:09 - hover over it it says actor object
97:12 - reference now
97:14 - in our programming approach what this
97:17 - basically means is we have set actor
97:20 - location defined in our class so let's
97:23 - say for example
97:25 - we have something like this so we have
97:27 - our actor class now anything that can be
97:30 - placed in the level is called an actor
97:31 - so let's actually
97:33 - create that so actor
97:35 - so inside this inside actor you actually
97:39 - have a set actor location method so set
97:41 - that to location and not write the whole
97:43 - thing
97:44 - and let's say you instantiate actor one
97:47 - so let's call it A1 for example when you
97:50 - instantiate actor 1 your program needs
97:53 - to know on which actor set actor
97:57 - location has to be called
97:58 - so we have actor 1 so that is our Target
98:02 - so when we call set actor location in
98:05 - our case in a blueprint we call set at
98:07 - the location now it needs to know on
98:10 - which actor it has to perform it so when
98:13 - you call this in the through the target
98:16 - pin in Blueprint that's how we will do
98:18 - it in the Target pin you specify that
98:20 - and the program knows that it has to set
98:24 - a one's location so that's how it
98:27 - basically works foreign
98:34 - so it's time we apply whatever we
98:36 - learned just now so head into your
98:38 - content folder and create a new folder
98:40 - and we'll just call this one blueprints
98:42 - and inside here we'll create all our
98:44 - blueprint classes and we will compare
98:46 - all of them so basically the most Bare
98:49 - Bones one which you can create is an
98:50 - object now please do not confuse this
98:52 - with an actual object we are creating a
98:54 - class and the class name is going to be
98:56 - object we are basically deriving a class
98:59 - from this object class this is how you
99:02 - basically start in Blueprint however as
99:05 - you proceed further you will understand
99:06 - note that this is not an actor so I
99:09 - cannot drag this into a level now if as
99:12 - I mentioned before Unreal Engine already
99:14 - has a 2d Vector structure but just to
99:17 - Showcase what we can do with such
99:19 - classes let me just actually create a 2d
99:22 - Vector so let's just call this one
99:24 - 2D Vector for example
99:27 - now please note you cannot name a type
99:30 - with a number beginning in you know C
99:34 - plus plus however you can do that in
99:37 - Blueprint so let me just call this on
99:39 - Vector 2 for example
99:42 - so if I open this up
99:44 - you you would see you have a standard
99:46 - blueprint editor you have an event graph
99:49 - but you don't have your viewport and
99:51 - stuff like that which you would see in
99:52 - an actor now one more thing you would
99:54 - notice is you don't have an event pick
99:56 - and play so you get an option to add a
99:59 - custom event which is basically like
100:02 - defining a function but it does not
100:04 - return anything and you can call it just
100:07 - like a function and we will be using a
100:09 - lot of custom events so you would get an
100:12 - idea of what I mean
100:13 - now in Vector 2 we are going to have two
100:16 - variables the first two are going to be
100:19 - floats
100:20 - so obviously we'll think about what we
100:22 - can have later on so it's going to be an
100:24 - X and A Y
100:26 - so these are the variables which are
100:29 - encapsulated inside this Vector 2 class
100:31 - note that this is not an object this is
100:34 - a class and when we actually create an
100:37 - instance of this we create a vector too
100:39 - so that's how it basically works now we
100:43 - don't want this X and Y variable to be
100:45 - directly accessible
100:47 - now the reason I wanted this way is for
100:50 - data security now I don't want to be
100:53 - directly able to write any random value
100:55 - to X and Y let's say this was exposed
100:58 - and you could actually change this
101:01 - directly in memory what would happen is
101:04 - now for example let's say I have a
101:07 - vector 2 object so let me just create
101:09 - that so use the construct object
101:11 - function so construct object from class
101:17 - so I think I misspelled that so
101:19 - construct
101:21 - object from class yep there we have it
101:24 - so I'll just delete this and if you go
101:27 - ahead we will get access to our vector
101:29 - 2.
101:30 - so Vector 2 for example
101:33 - now we have a vector 2 object over here
101:36 - so this is actually a vector 2 object we
101:39 - could go ahead and promote that to a
101:41 - variable so it's going to create a
101:43 - variable of that type and let's just
101:45 - call this one R vector
101:48 - now we don't want any other
101:52 - external entity to actually be able to
101:55 - directly set X
101:57 - so this would be prone to lots of
102:02 - exploits basically
102:04 - so that's the reason what you generally
102:07 - do in object oriented is you make this
102:09 - private you see the option over here
102:11 - called private now basically you will
102:14 - not be able to access X and Y from here
102:16 - so now if I type in get X you see I
102:19 - can't get it if I type in set X
102:22 - I cannot set X so that's one way of
102:25 - providing security to the data now what
102:27 - if you just wanted to access the value
102:29 - that's pretty simple you would just go
102:31 - ahead and create a function so you type
102:33 - in get x value for example so get X
102:36 - and get y
102:38 - and we are going to make this PR
102:39 - functions because we are just returning
102:41 - the immediate value
102:43 - and we could add a compact node title
102:46 - and call This One X
102:48 - and we'll call this one y
102:50 - now in the return node we could just go
102:52 - ahead and return the value so return
102:54 - node
102:55 - and we can go ahead and grab our y here
103:00 - and return that
103:01 - and over here as well we can go ahead
103:04 - and return X
103:05 - so grabbing the return node and return X
103:09 - so now if you wanted to access X or Y
103:12 - you can go ahead and type in get X
103:15 - so you will get access to the x value
103:17 - however you will not be able to edit X
103:20 - directly
103:22 - so again for that we can go ahead and
103:25 - create setters
103:26 - so Setters are basically just functions
103:29 - which are going to set the value so
103:31 - let's say I type in set X
103:34 - and I type in set set y I accidentally
103:37 - type text again
103:39 - so set White
103:43 - all right so once that's set we can go
103:46 - ahead and take in the value
103:48 - and this is going to be
103:51 - of type float
103:53 - and we can go ahead and set our y to be
103:57 - equal to that
103:58 - and we can go ahead and type in let it
104:01 - the return node we don't really need it
104:03 - in this case but anyways we'll have it
104:06 - and in our set X function we could do
104:08 - the exact same thing we could add in an
104:11 - input pin and call this one value once
104:13 - again
104:16 - value
104:18 - and we can go ahead and add in a return
104:20 - node
104:22 - whoops we didn't need that
104:25 - now what if you just wanted to set this
104:28 - entire vector
104:31 - now when we set R Vector we are actually
104:35 - just getting a reference to it we are
104:38 - not actually setting our members
104:41 - so we can go ahead and write a function
104:43 - for that again we could get add a get
104:45 - Vector to
104:48 - and we could also have a set Vector too
104:54 - so something like this this was just to
104:56 - show you guys how we would work with
104:58 - classes and objects so
105:00 - for get Vector 2
105:02 - we can go ahead and
105:07 - actually return the value
105:10 - so we can go ahead and add in the return
105:12 - node
105:14 - and we can get our X and our y
105:19 - so things like that
105:21 - so for a set Vector 2 we can go ahead
105:24 - and all track this
105:27 - or track this once again
105:30 - now obviously please do understand that
105:32 - this is kind of impractical
105:34 - unreal already has a struct built in
105:37 - which handles all this for us I'm just
105:40 - trying to show you an example of how you
105:43 - would actually use it
105:45 - so this is how you do it so now if I
105:47 - type in set Vector 2 you see I can
105:49 - actually set its value and the target is
105:52 - R Vector so we are adjusting this value
105:57 - and we could go ahead and write in a few
105:59 - more functions so for example we could
106:02 - write a function to print the vector to
106:05 - so print vector 2.
106:08 - so we can go ahead and type in print
106:11 - string
106:13 - and we need a word context object
106:16 - however it is going to take the outer
106:18 - object by default I believe but anyways
106:21 - in these contexts what you would want to
106:24 - do with something which I haven't seen
106:26 - much is you would just get the outer
106:27 - object there is a function for this
106:29 - basically the outer object is the object
106:32 - from which the subject was created so in
106:34 - our case it's our level blueprint and we
106:36 - can call the print function from there
106:38 - the reason is it actually needs to know
106:41 - uh where to actually print the string so
106:44 - that's the reason actually
106:46 - so now I can just type in self self
106:48 - refers to this object itself so we can
106:51 - just pass that in
106:52 - now we can go ahead and actually print
106:57 - something so in our case we can get our
107:00 - X
107:01 - and one handy function which you'll use
107:03 - a lot is going to be append so we can go
107:06 - ahead and type in X for the x value give
107:10 - a space and then print out RX
107:13 - move that over there to keep things
107:15 - clean
107:16 - and we can go ahead and do the same for
107:19 - the Y as well so we can go ahead and
107:21 - give a space
107:24 - and we can type in y with a colon
107:29 - and we can go ahead and print that
107:32 - so we have our y
107:35 - we can go ahead and convert that once
107:37 - again
107:38 - and we can go ahead and print that if
107:40 - you right click you can actually remove
107:41 - the extra pin so that's an option
107:43 - available as well
107:45 - so now this is how you do it now if I go
107:48 - ahead and press play
107:49 - obviously we are not calling it anywhere
107:51 - so now now that we have R Vector we can
107:54 - go ahead and call Print vector2
107:56 - so this is going to print our vector
108:00 - so this is how it works
108:03 - and obviously we can also test out our
108:05 - set functions so we can type in set
108:08 - vector2
108:14 - and we can just give some random values
108:17 - to this and if we go ahead and print
108:19 - Vector 2 we should get that value
108:22 - so this is basically how we would work
108:24 - with the most basic type of object now
108:27 - this is mostly useful in cases where you
108:30 - only need some data and methods and you
108:33 - want methods basically because in
108:37 - Blueprint you cannot have struct methods
108:40 - so in those cases you would use an
108:43 - object type
108:44 - so we are not going to be messing with
108:46 - this any further
108:49 - [Music]
108:53 - now the the next type which you will use
108:56 - is going to be an actor now this is
108:59 - probably the most commonly used type and
109:02 - most of the other types of class
109:04 - official create will also be derived
109:06 - from actor so let me just create that
109:08 - right click go to blueprint class and
109:10 - create an actor it's directly available
109:11 - here or you could search down there
109:14 - so if I create an actor we'll call this
109:16 - one my actor for example
109:18 - now if you were to notice if I drag this
109:21 - I cannot do that because you cannot
109:23 - place a vector 2 in your scene right
109:26 - however I can drag my actor and I can
109:29 - place it in the scene and if I hit F on
109:30 - my keyboard I can actually see it now
109:32 - this is just a visual representation in
109:35 - the editor so that you can actually see
109:37 - it however if you hit G on your keyboard
109:39 - to go to game view it actually won't be
109:41 - seen
109:42 - now if you were to open your actor you
109:45 - would see the editor is a little more
109:47 - complicated than your basic object you
109:49 - have three tabs the viewport the
109:52 - construction script and the event graph
109:54 - where you will be working with most of
109:56 - the time we will separately talk about
109:58 - construction scripts and we'll also get
110:00 - to the viewport but of our relevance is
110:03 - the event graph right now and we will
110:05 - talk a little bit more about actors
110:08 - you would also notice that we have our
110:10 - begin play and tick which we missed in
110:13 - our basic object type class
110:16 - now if we wanted to have multiple of
110:18 - these actors so let's actually do
110:21 - something practical let's say we had a
110:23 - pickup actor in our game so we have pick
110:25 - up actor
110:28 - and it's generally a convention you do
110:31 - something like this
110:33 - BP underscore pickup
110:35 - because more often than not or here if
110:39 - you see the parent class it says actor
110:41 - right so more often than not you will
110:43 - actually create another class of your
110:45 - own in C plus plus so any code that
110:48 - needs to run fast or something you would
110:49 - put that in C plus plus and then you
110:52 - would derive BP pickup from the C plus
110:55 - plus pickup actor so that's why it's a
110:57 - convention I usually name it like this
110:59 - so I can go ahead and grab this so I
111:02 - have BP pickup whoops deleted the wrong
111:04 - thing so I can delete my actor here BP
111:07 - pickup 2 will be created so these two
111:10 - are pickups and both of these contain
111:13 - all the variables and functions which
111:15 - this creates
111:16 - so you can go ahead and edit our
111:18 - blueprint just like how we would usually
111:21 - all right so it's time to dive a little
111:23 - bit more deeper into some of these
111:25 - events and let's actually start writing
111:28 - some practical code
111:29 - so event begin play is called not when
111:33 - the game begins actually that's the
111:35 - wrong way to interpret it however event
111:38 - begin play is called when this actor is
111:41 - instantiated so for example we have our
111:43 - BP pickup here and since this is placed
111:46 - in our level this will get created as
111:48 - soon as our level starts so it is
111:50 - technically called when the game starts
111:53 - however if I just go ahead and print
111:55 - this
111:56 - and
111:58 - let's just call this begin play
112:02 - you would see two begin place because we
112:04 - have two instances of our BP pickup
112:07 - however
112:09 - it need not be called when the game
112:12 - begins it is called when the pickup
112:15 - actor is actually created so when BP
112:17 - pickup is created that is when it is
112:19 - called so let's delete a vector 2 stuff
112:21 - we don't really need it now in order to
112:24 - actually create an actor remember that
112:26 - every actor is going to have a location
112:28 - rotation and scale so that's the reason
112:31 - you cannot just create an object because
112:33 - you do need a certain number of
112:37 - default parameters in order to actually
112:39 - be able to place something in the scene
112:41 - so without a location the engine has no
112:43 - idea of where to place it that's the
112:45 - reason actor exists now if you head back
112:48 - into your level blueprint let's actually
112:50 - give a delay of a few seconds just to
112:52 - show you guys
112:53 - so let's say we give a delay of two
112:55 - seconds and in order to create an actor
112:57 - you call a function known as Pawn actor
113:01 - so spawn actor from class and over here
113:05 - under spawn transform we could just set
113:07 - that to zero for now it's since we don't
113:09 - have any visual representation it
113:11 - doesn't matter honestly
113:12 - so once that's done we can go ahead and
113:15 - select our BP pickup
113:18 - and we can go ahead and compile it now
113:21 - if I press play you see begin play is
113:23 - called but two seconds later another
113:25 - begin place called if you guys couldn't
113:28 - catch that I'll leave a longer delay
113:31 - begin play
113:33 - and another begin play was called and if
113:35 - you would notice in the outliner
113:37 - you would actually notice another
113:39 - instance being created here
113:42 - so if you were to notice there is
113:44 - another BP pickup that is created so
113:47 - that's basically how it works
113:49 - and tick is called every frame however
113:52 - it need not be once again
113:54 - so if I just go ahead or I can just go
113:56 - and reuse it actually
113:58 - so instead of this I'm going to type in
114:01 - tick
114:03 - and now this should be called every
114:06 - frame let's have let's only have one
114:07 - pickup actor and let's go ahead and not
114:10 - spawn this
114:12 - so if you want to disconnect pins like
114:14 - that by the way you can go ahead and
114:15 - press alt over here and it's going to
114:18 - disconnect the pin so we don't need that
114:20 - now
114:24 - if you were to notice it's going to
114:26 - constantly print tick
114:28 - so this should be about 200 to 300 times
114:31 - a second on my computer so if I just
114:34 - type in stat FPS
114:37 - whoops missed that start FPS
114:41 - it's locked at 120 so it's 120 times a
114:44 - second
114:45 - so if you want to increase it actually
114:47 - you can remove the cap by typing in t
114:49 - dot Max FPS space Max FPS give something
114:53 - like 999 or 1000
114:56 - all right so I don't know I did that
114:59 - now head back into your blueprints
115:02 - under your pickup and under your class
115:04 - defaults you can actually disable your
115:07 - tick
115:08 - so you can go ahead and disable and as
115:11 - you can see nothing's being printed
115:13 - now there's another thing
115:15 - you can actually change this parameter
115:18 - at runtime as well people don't know
115:20 - this but any and all details which are
115:24 - there in this panel over here so let's
115:26 - say for example I go to my class
115:29 - defaults
115:30 - I will definitely be able to change most
115:34 - of these at runtime so for example we
115:36 - have start with tick enabled so we
115:39 - should be able to enable or disable tick
115:41 - at runtime so let's actually just type
115:43 - in tick enabled
115:45 - and as you can see there is actually a
115:47 - function which lets us do it so if I go
115:50 - ahead and actually enable tick first of
115:52 - all
115:53 - and if I go ahead and disable it after
115:55 - one second you would notice that Tech is
115:58 - being printed and a second letter it
116:01 - stops printing tick so that's basically
116:03 - how it works and not only that any and
116:06 - all parameters and you can actually
116:08 - change the tick interval as well let's
116:10 - say it's printing too often you could
116:12 - just set it to 0.5 so it will be roughly
116:15 - 0.5 seconds now as you can see it is not
116:18 - printing as frequently so that's
116:20 - basically one aspect in blueprints that
116:24 - that is Handy to know because any and
116:26 - all settings that will be there will be
116:28 - usually uh exposed as functions to be
116:32 - adjusted at runtime otherwise again you
116:36 - have your class defaults where you can
116:37 - actually set them I think whatever we
116:40 - did till now is clear now so we can go
116:43 - ahead and delete this code we won't be
116:45 - using it as of now so now let's go ahead
116:47 - and actually write some code for the
116:50 - pickup itself so let's say we had an
116:52 - object and we had to pick it up first
116:54 - things first there is no visual
116:56 - representation for the object so let's
116:58 - say we actually just go ahead and oops
117:01 - okay go ahead and press play you would
117:04 - see that you can't actually see anything
117:06 - no
117:08 - if I zoom into this so as you can see
117:11 - you can't actually see this pickup so
117:14 - first of all let's actually add in a
117:16 - model and stuff like that now there is
117:18 - one thing
117:19 - uh the default scene root is not
117:22 - actually required if I delete it I won't
117:25 - be able to however I can actually add in
117:28 - a static mesh now a skeletal mesh is a
117:31 - mesh which contains Burns and stuff like
117:33 - that so basically your characters and
117:36 - anything with animations is going to be
117:39 - a skeletal mesh basically however your
117:42 - models like your pickups and stuff
117:45 - usually are going to be static meshes
117:48 - so that's basically how it works as you
117:50 - use them you will understand so now if I
117:53 - drag this into the default scene root
117:55 - I'll go ahead and delete the visual
117:58 - representation and the static mesh will
118:00 - be replaced now one thing to note when
118:03 - you do this the most high component the
118:07 - component which is the uppermost in the
118:09 - hierarchy over here is called the root
118:12 - component so for example this default
118:14 - scene root is the root component now
118:16 - when I drag the static mesh this is the
118:19 - root component and if physics has to be
118:22 - simulated in our case let's actually try
118:25 - that let's make the pickup fall down and
118:26 - follow the laws of physics so in that
118:29 - case we will need it to be the root
118:30 - component so that's one thing to note
118:32 - now if I go ahead and select a mesh so
118:36 - for example I can just select this
118:39 - random sphere that we have I think it's
118:41 - way too big so
118:44 - yeah we got to adjust that
118:46 - now I can go ahead and enable simulate
118:49 - physics
118:52 - so now if I go ahead and press play
118:57 - you see that it falls like you would
118:59 - expect
119:02 - so we basically simulated physics now we
119:05 - have a visual representation now how are
119:08 - we actually going to pick this up now
119:10 - actually let's select something a little
119:12 - more smaller because
119:14 - I don't think this is convenient
119:17 - okay this seems like a reasonable size
119:19 - so if we go ahead and press play
119:22 - we are simulating physics so absolutely
119:24 - no problem with that and one thing to
119:26 - remember in case you are not simulating
119:28 - physics make sure you do have collision
119:30 - and stuff like that if you if we
119:34 - actually encounter such an issue I will
119:36 - go ahead and show you guys how to deal
119:37 - with that
119:38 - so we have physics now now we can go
119:41 - ahead and set up some logic now
119:43 - we want to be able to pick this up when
119:46 - we overlap it let's say for example so
119:49 - we can do on actor begin overlap
119:53 - so what this says is when another actor
119:56 - overlaps this actor so in our case it's
120:00 - going to be this when it overlaps this
120:03 - actor we can go ahead and perform some
120:05 - logic and Unreal Engine has set this up
120:08 - for us now there is one problem though
120:11 - this is just R Cube which is our model
120:14 - however we don't have an actual bound so
120:17 - our code won't really be able to know
120:22 - when to actually call on actor begin
120:24 - overlap so even if I disable Collision
120:27 - so the way you do that is you can head
120:30 - over here
120:31 - and from physics actor you could go
120:34 - ahead and change it but we do need
120:35 - physics so we can't do that even if we
120:37 - actually bump into this you won't really
120:40 - notice anything happen so if I go ahead
120:42 - and bump it to this nothing is really
120:44 - going to happen
120:46 - now if I actually go ahead and creates a
120:49 - bound so the way you do that is right
120:51 - click or rather go to add and you can
120:54 - type in a sphere I believe
120:58 - sphere Collision yes
121:00 - so when you create a sphere Collision we
121:02 - could call this one bounds
121:03 - you would have created a sphere and you
121:06 - can't see that because the size is too
121:07 - small can go ahead and increase the
121:09 - sphere radius
121:10 - now these are our bounds so as soon as
121:13 - we enter this our on active begin
121:15 - overlap will be triggered so we can go
121:18 - ahead and print it
121:19 - and if you were to notice the Collision
121:21 - preset over here under the details panel
121:23 - select this and head into your Collision
121:26 - preset you see it says overlap all
121:29 - Dynamic and obviously if you select
121:31 - custom you can go ahead and edit each
121:33 - Channel and we will talk about this
121:35 - later
121:36 - so if I go ahead and press play
121:38 - you see we get hello every time we
121:40 - overlap it
121:41 - [Music]
121:46 - now hello is going to be printed every
121:48 - time any other actor overlaps this
121:51 - however we want to print hello only if a
121:55 - character overlaps it and it need not be
121:58 - a character as well now in unreal
122:01 - character is actually a derived class of
122:04 - another class known as pawn and I will
122:07 - talk a little more in depth about this
122:08 - right now so basically this is how it's
122:11 - laid out in unreal basically we are
122:13 - looking for a pawn and I will get to
122:16 - that in just about a minute so we can
122:19 - type in pawn and if you were to scroll
122:21 - down you would see cast to pawn so cast
122:25 - is another programming feature now if
122:28 - you were to feed in an object to this
122:31 - you can check whether it is upon object
122:35 - so now if I go ahead and print this out
122:39 - now uh you would go ahead and actually
122:43 - get hello just normally
122:46 - the reason is when you are actually
122:48 - controlling your camera over here
122:51 - you are actually controlling a pawn
122:54 - actor
122:55 - anything that can be possessed by a
122:59 - player controller is known as a pawn and
123:01 - we will talk a little more in depth
123:03 - right now and just to clear your doubts
123:06 - on whether this logic actually work
123:09 - let's say it wasn't a pawn so which
123:11 - means it's not a player basically so if
123:14 - I copy this over and instead of hello
123:16 - let's just print not player
123:19 - and now if I go ahead and press play
123:23 - you'd see you won't get anything
123:25 - and if I overlap it it says hello but if
123:29 - I go ahead and copy this over and let's
123:32 - say I keep it above this and if I press
123:34 - play you see you get not player printed
123:37 - that is because
123:39 - the Box overlapped another box
123:42 - or rather RBP pickup overlapped another
123:45 - BP pickup however those are not
123:48 - characters so this cast right here
123:50 - failed because the object which came
123:53 - from this actor begin overlap was not a
123:56 - pawn hence we got not player printed
124:00 - foreign
124:07 - part of the course I'll just tell you
124:09 - guys the most basic form of inheritance
124:13 - hierarchy which is there and unreal
124:14 - however once we get to the more advanced
124:17 - part I will tell you guys more in depth
124:19 - but as far as what you guys need to know
124:21 - so at the base level the most simplest
124:23 - type of class from which you can
124:25 - instantiate objects is known as object
124:27 - in Blueprint so object is the simplest
124:30 - type and from that the most basic one
124:33 - which you can create is going to be an
124:35 - actor now an actor is basically an
124:37 - object which has a transform and can be
124:40 - placed in the level as you would have
124:41 - figured by now now under this you have
124:44 - various other classes however for the
124:48 - most basic level we are going to be
124:50 - considering only two
124:52 - so there are many more and we will talk
124:55 - about many others where once we actually
124:58 - come to the advanced part but these are
125:00 - the two which you do require to get up
125:02 - and running so the first one under this
125:05 - is going to be your controller
125:08 - so a controller as the name suggests is
125:11 - a class which has functionality for your
125:15 - built-in to take player input and stuff
125:17 - like that
125:18 - and under controller you also have a
125:21 - special type known as a player
125:23 - controller and there are others such as
125:25 - AI controller so you have a player
125:28 - controller so player
125:30 - and I'm just going to put this so play a
125:33 - controller
125:35 - now a player controller is basically a
125:37 - controller which belongs to an actual
125:40 - player you also have other things such
125:43 - as AI controllers which is assigned to
125:46 - CPU players basically so if you have
125:50 - enemies in game for an offline game or
125:52 - something you design an AI controller
125:55 - now another class that you'll need is
125:57 - pun and that's what we talked about so
126:00 - this is called Pawn now a pawn is
126:03 - basically
126:04 - a class
126:06 - which is an actor obviously and can be
126:09 - placed in the level and note that you
126:11 - cannot place a controller in a level
126:13 - although it is derived from actor it is
126:15 - actually an exception controllers player
126:17 - States game states there are a few other
126:19 - classes which are exceptions and you
126:20 - can't place them in the level however
126:22 - pawns can be placed in the level and a
126:25 - pawn is always possessed by a player
126:28 - controller so a player controller is
126:30 - going to be possessing a pawn so when
126:33 - you call the possess function and you
126:36 - give the target as a pawn you are going
126:38 - to be possessing the pawn and one
126:41 - special type of Pawn which has a lot of
126:43 - functionality built in for us already
126:46 - is called a character most of the times
126:49 - you will be working with characters and
126:51 - not puns however you can use puns so by
126:55 - character I mean a character such as a
126:58 - living being basically so generally if
127:01 - you have like a human or if you have
127:03 - like an animal or something like that
127:05 - you would generally use characters
127:06 - however if you have something like a
127:08 - vehicle you would usually stay away from
127:11 - characters because it has some
127:12 - properties which are not realistic for
127:15 - those however it is completely possible
127:17 - to use a character class for something
127:19 - like a vehicle as well so you can
127:22 - possess a character as well there is no
127:24 - harm in that pawn or any derived class
127:27 - of Pawn can be possessed by a player
127:29 - controller
127:31 - foreign
127:39 - we can go ahead and actually create our
127:42 - own character class or I should rather
127:44 - say Pawn class which is also a character
127:46 - class in our case so we can create that
127:49 - as well as a player controller and I'll
127:51 - show you guys how to set those and how
127:54 - we can go about interacting with this
127:57 - pickup using those so right click go
127:59 - ahead and create blueprint class and as
128:01 - you would see you have character and
128:02 - clear controller right here because they
128:04 - are really really common
128:06 - so type in character and let's just type
128:08 - in BP underscore character
128:13 - again you can you can name it
128:15 - appropriately or as per your wish
128:18 - now if I go ahead and open it up you see
128:21 - this looks a little more different and
128:23 - it already has something set up for us
128:25 - and some of these are quite handy
128:28 - especially the character movement
128:29 - component which is there and if I
128:32 - haven't mentioned yet whatever we did
128:34 - here
128:35 - under the component step these are
128:37 - called components basically basically
128:40 - every actor is made up of several
128:42 - components and you can actually create
128:45 - your own components as well and make
128:47 - them behave as you wish but as of now
128:50 - just know that these are just
128:52 - constituents of these this actor and
128:56 - these are the constituents of BP pickup
128:59 - and this is these are the constituents
129:01 - of BP character basically now we haven't
129:03 - set a mesh and we don't really have one
129:06 - so let's just take okay we have
129:09 - a character tutorial PPP and one thing
129:13 - to note this Arrow actually represents
129:15 - the forward direction of the character
129:16 - so you can go ahead and move it down
129:19 - and you can go ahead and rotate it 90
129:22 - degrees so let let me have snapping
129:23 - enabled
129:25 - so rotate it by negative 90 and you can
129:29 - go ahead and bring him all the way down
129:31 - until I feel it's correct
129:35 - now we don't have any animations but I'm
129:37 - not really sure if we do have an
129:39 - animation blueprint for him
129:41 - so let's just check
129:43 - tutorial animation blueprint I guess
129:46 - tutorial animation blueprint so yeah we
129:50 - do have an animation blueprint for him
129:53 - now if you want to change the default
129:56 - character that you will be using the way
129:58 - you'll do that is by first of all
130:00 - heading into Window World settings make
130:03 - sure that is enabled and then over here
130:05 - on the right hand side head into World
130:07 - settings and under game mode override
130:09 - you can go ahead and set your own game
130:12 - mode now if I were to just select game
130:14 - mode I still cannot edit it so I will
130:17 - get to Game Mode classes later on
130:19 - because they are not that important but
130:21 - for now you can just go ahead and create
130:23 - a new game mode and it could be of type
130:25 - game mode base or it could be of type
130:27 - game mode it doesn't really matter but I
130:30 - would suggest sticking with game mode
130:32 - base
130:33 - and let's just call this one uh BP
130:36 - underscore game mode
130:38 - uh I just did something there
130:41 - so yeah BP underscore game mode
130:46 - that's what we'll call it and now under
130:48 - this we will get our option to select
130:50 - the game mode now since this is our
130:52 - custom or custom made game mode we get
130:55 - the option to select the default Pawn
130:57 - class and over here we can select our BP
131:00 - character and if I save everything and
131:03 - if I go ahead and press play you would
131:05 - see that we have indeed possessed our
131:08 - character and you were to notice that
131:11 - the camera is a bit off
131:14 - so what you can do is you can actually
131:16 - create a camera
131:18 - if I go ahead and type in camera under
131:21 - the component section
131:22 - you can create a camera and you can
131:25 - align it as per your requirement so this
131:28 - should be about correct
131:31 - so I feel rotating this a bit maybe a
131:35 - bit back maybe a bit to the side would
131:37 - be nice
131:38 - so there you have it so this is our
131:40 - character
131:42 - however we are not actually able to move
131:45 - the reason is we haven't actually
131:47 - written the code for it to take our
131:50 - input
131:51 - Now setting up input in unreal is really
131:55 - really easy and I will show you guys the
131:57 - brute force method as well as the proper
132:00 - way to do it so The Brood force method
132:02 - is for example we want W to be able to
132:04 - make us move forward so I can press W
132:07 - and if you just give a space and type in
132:09 - keyboard
132:10 - you would be able to get W and we can
132:13 - make the character move forward
132:15 - so in order to make your character move
132:18 - basically there's a function for us
132:20 - built in already under the character
132:22 - movement and not character movement I
132:25 - believe it's there in our Pawn class I
132:27 - believe or a character class so if you
132:29 - right click and type in add movement
132:31 - input
132:33 - so it's written in our Pawn class we can
132:35 - go ahead and make him move
132:37 - and if you were to notice we have to
132:40 - provide a direction and a scale value
132:42 - scale value is useful if you are on a
132:45 - joystick or something where you can
132:47 - partially press down so let's say you're
132:49 - halfway pushing the joystick uh
132:52 - knob so in that case it would be 0.5 so
132:57 - the scale value can be given through an
132:59 - axis value
133:00 - now if you were to notice ah there is
133:03 - another problem here when I actually
133:06 - plug this in
133:07 - it's not really going to work as you
133:09 - would expect so for our direction we
133:12 - need the forward direction of the
133:14 - character so a very simple way to do
133:16 - that is typing in get forward Vector so
133:19 - get actor forward vector
133:21 - so get actor forward Vector so that's
133:24 - the way you would actually get the word
133:25 - Direction that's how you do it
133:28 - and if you were to notice
133:30 - it's not going to work as expected at
133:33 - all the reason is this has to be called
133:36 - every frame in order to actually work
133:39 - so the way you do it is Type in uh or
133:43 - rather we can do it on event tick for
133:45 - example
133:46 - so if we go ahead and do it on event
133:49 - tick I'm just doing this to show you
133:50 - guys how to do it if I do this now we
133:53 - would see that our character is moving
133:55 - forward
133:57 - now the most obvious question is how am
134:00 - I actually going to set this up so there
134:04 - is something known as an axis mapping
134:06 - which runs every frame basically what
134:08 - add movement input does is it moves you
134:11 - a very very slight amount and by calling
134:14 - this multiple times in a single second
134:16 - you are going to be adding considerable
134:19 - amount of movement now if I head into my
134:22 - project settings
134:24 - and under input this is the right way to
134:26 - do it the Brute Force wave would have
134:28 - been like doing this on tick and I'll
134:30 - just show you this really shouldn't be
134:32 - your option but I'll just show you just
134:35 - in case so for example you could just
134:37 - have a Boolean here and we could just
134:40 - set this to true for example and when
134:42 - you release it we could set this to
134:44 - false
134:45 - now this is wrong so don't really worry
134:47 - about the logic this is just gonna work
134:49 - but you shouldn't really do this so we
134:52 - could do if new variable is true we want
134:55 - to move otherwise we don't want to do
134:57 - anything
134:58 - so if I go ahead and press play I can
135:00 - press W and move but as soon as I
135:02 - release it I'm going to stop this is the
135:04 - Brute Force way to do it but unreal has
135:07 - a much more elegant system to do it so
135:09 - we can go ahead and delete all of this
135:12 - head into our project settings once
135:14 - again
135:15 - and under input you would see action and
135:17 - access mappings
135:19 - now we want an axis mapping because we
135:22 - do want to be able to control the scale
135:24 - and since add movement input is actually
135:27 - a function which depends on the scale
135:30 - value so remember what I told you about
135:32 - the joystick so we can create an access
135:34 - mapping so for things such as jump where
135:37 - there is no scale value so it's either
135:39 - jumping or not jumping so wherever you
135:42 - have a toggle you would have an action
135:43 - mapping wherever you you have some value
135:47 - which goes linearly you would have an
135:49 - access mapping so we can call this one
135:51 - move forward
135:54 - and
135:56 - make that Pascal case and we could have
135:58 - W on the keyboard for that and again
136:02 - for move backward we could reuse this
136:04 - actually so s is going to be moved
136:07 - backward
136:08 - and for the scale value you can make
136:10 - this negative one
136:12 - now if I right click over here and if I
136:16 - type in move forward
136:18 - you would notice that we have an axis
136:21 - mapping
136:23 - so if I grab this into this input event
136:27 - or rather if I bring this into this axis
136:30 - move forward event and for the scale
136:32 - value if I put this under access value
136:34 - now this will work exactly as I would
136:37 - want it to so if I go ahead and press W
136:39 - it's going to work and even s is going
136:41 - to work now for us
136:43 - so this is basically how you do access
136:45 - mappings similarly you could do it for
136:48 - move right
136:49 - so we could have move right or we could
136:51 - call it move sideways
136:54 - and we'd have our A and D keys so we
136:58 - have our a key and we have our D key so
137:02 - D is going to be
137:04 - this one and it's going to be negative
137:07 - 1.
137:08 - so let's actually just test it out
137:11 - so
137:12 - it's not really doing anything because
137:14 - we didn't set up the logic obviously so
137:16 - move
137:17 - sideways
137:19 - whoops
137:21 - axis
137:22 - move sideways
137:27 - so once you have the event set up you
137:30 - can go ahead and add the movement input
137:32 - and again you can get the right Vector
137:34 - of the actor so basically the right
137:36 - direction of the actor is going to be
137:38 - your right Vector so your forward Vector
137:42 - is always in this arrows Direction and
137:44 - your right Vector is going to be a
137:45 - vector in this direction basically
137:47 - so right vector and if I go ahead and
137:50 - press play
137:52 - so it's always one so that's the reason
137:54 - it's happening so
137:56 - if I plug that into the axis value
137:59 - I am moving reverse actually right now
138:01 - so that's just a simple mistake I did
138:03 - here so I can type in minus one for this
138:06 - and I can type in plus one for this now
138:09 - everything should work as expected so if
138:10 - any of your directions are reversed just
138:13 - multiply the access value by -1 now as
138:16 - you can see we are able to move forward
138:18 - left right and all of that good stuff
138:22 - now that is about it for the keyboard
138:25 - input however if you were to notice I
138:27 - really can't rotate the character so
138:29 - let's actually set that up first so
138:32 - first things first head back into your
138:34 - BP character and the functions which we
138:37 - require to set up keyboard input I mean
138:40 - Mouse input for a character is going to
138:43 - be your controller pitch input and your
138:46 - controller your input so controller
138:48 - pitch input
138:49 - and controller your input
138:53 - so these are the functions that we need
138:55 - now again since our Mouse needs to be
138:59 - captured as much as possible because it
139:02 - it has to detect every tiny movement so
139:05 - we again need to create an axis mapping
139:08 - so go ahead into inputs
139:10 - and create two new access mappings and
139:14 - call one
139:15 - look around
139:18 - and the next one call it look up
139:24 - and for this look around is going to be
139:26 - the x-axis of the mouse so type in Mouse
139:28 - X
139:29 - and for this one type in Mouse y
139:33 - so that should be good
139:35 - and over here
139:38 - if I go back and if I type in Access
139:44 - look around
139:46 - and we can go ahead and add your input
139:49 - over here
139:50 - and over here access
139:54 - lookup
139:57 - oops I misspelled that
140:02 - so head back into input so look up
140:12 - now if I go ahead and compile this and
140:15 - press play
140:17 - you would see that I am able to look
140:20 - around
140:21 - however I really am not able to you know
140:24 - look up and down
140:26 - that's mostly because your character
140:29 - isn't really meant to rotate along with
140:32 - it so that's the reason it's happening
140:34 - so if I head into my camera and enable
140:38 - use spawn control rotation and if I
140:40 - press play you see I am able to rotate
140:43 - my camera
140:44 - however there's one small problem here
140:47 - we are again uh doing it reverse
140:50 - so again in that case as I told you guys
140:53 - before just change the scale value to
140:56 - negative 1.
140:58 - now if I go ahead and press play you
141:01 - would be able to see that our camera is
141:04 - working as expected now there is one
141:07 - slight issue though
141:08 - that is
141:10 - uh our view is kind of off which you can
141:13 - fix
141:14 - but when we actually look up our
141:17 - character doesn't seem to be looking up
141:20 - but the reason that's not happening is
141:22 - because you can't just rotate the whole
141:24 - character now if I were to actually go
141:27 - to this uh main tab over here under BP
141:30 - character
141:31 - and if I search for control rotation so
141:34 - if I type in control rotation
141:36 - and if I enable it to use pitch
141:40 - you would actually see
141:42 - that I am in fact able to do that but
141:45 - there is a small problem now if I hit f8
141:47 - to unpossess my character you see he
141:50 - just rotates like that however we want
141:52 - only his spine to rotate and that is
141:54 - something which we have to set up using
141:56 - an animation blueprint which we will do
141:58 - later so for now we'll just disable this
142:00 - and even for the yaw part you could you
142:04 - could disable this and
142:07 - you could technically do something like
142:09 - this and maybe set up some other logic
142:12 - in order to actually rotate your
142:13 - character but for our purposes we'll
142:15 - only do it for the pitch
142:18 - another tiny thing that I would love to
142:20 - cover here is how do you actually set up
142:23 - different sensitivities because
142:25 - obviously right now
142:27 - the current sensitivity may be a little
142:30 - too much for some for some maybe it's a
142:32 - little too less
142:34 - so the way you do that
142:35 - is just multiply this axis value by your
142:39 - sensitivity value that's basically how
142:41 - you do it
142:42 - so multiply this
142:44 - and multiply this as well press Ctrl D
142:47 - to duplicate that
142:49 - now we could just promote this to a
142:51 - variable however remember that this BP
142:55 - character refers to only the character
142:57 - which we are playing so let's say we are
142:59 - playing a death match or something where
143:01 - your character dies and you respawn with
143:03 - a new character you would have to pass
143:05 - in the variable every time so instead of
143:09 - doing this we are going to set this up
143:11 - in a class which will be common
143:14 - even when your character is destroyed so
143:18 - the class which we'll use and as you
143:21 - would expect is called player controller
143:24 - so go ahead and create BP player
143:27 - controller
143:30 - so make sure everything is in Pascal
143:32 - case
143:33 - now if you open this up now over here we
143:36 - can go ahead and create a variable and
143:38 - call this one sensitivity
143:41 - and now uh this is going to be of type
143:44 - float obviously
143:45 - and let's make this one private and
143:48 - let's create a method to get the
143:50 - sensitivity
143:54 - now this player controller is going to
143:56 - be persistent even after your character
143:59 - dies so that's the reason we're using it
144:01 - and since we need the immediate value
144:03 - this will be pure and for the return
144:05 - value we are just going to return the
144:07 - sensitivity
144:09 - now obviously the reason we're doing it
144:12 - this way is you don't want an external
144:15 - entity to actually modify sensitivity
144:17 - that would be crazy
144:19 - and one more thing make sure you set
144:21 - this value to anything other than zero
144:23 - because if it's zero your mouse
144:24 - obviously will not move so maybe
144:26 - something like 0.5
144:29 - so once that's done I should be able to
144:32 - set my player controller first of all
144:35 - over here in your game mode override for
144:37 - your BP game mode go ahead and change
144:39 - your black controller to the one you
144:40 - created
144:42 - save that and open up your BP character
144:45 - and now
144:47 - on begin play what we can do is we can
144:50 - actually get our player controller so we
144:52 - can type in get player controller
144:56 - and we can cast this to our as you would
145:00 - guess BP player controller so we are
145:02 - getting our play controller and we are
145:04 - checking if it is a BP player control
145:06 - obviously we set it over there in the
145:08 - game mode so it will be there is no
145:10 - there's no way it's going to head into
145:12 - cast field so we can just right click
145:14 - and make this appear cast so this just
145:16 - helps us save some space in the graph
145:18 - this will be a success for sure and we
145:21 - can go ahead and type in promote to
145:22 - variable and we'll call this one pcrf
145:26 - for player controller ref
145:29 - now go ahead and compile that again you
145:31 - can go ahead and make this one private
145:33 - but honestly it doesn't matter in this
145:35 - case
145:36 - so on begin play we have gone ahead and
145:39 - stored our player controller
145:41 - and from our player controller object we
145:43 - can go ahead and get the sensitivity
145:46 - go ahead and get the sensitivity
145:49 - go ahead and do the same thing over here
145:52 - compile that
145:54 - and if I go ahead and press play
145:57 - you would see our sensitivity works and
146:00 - not only that actually if I go ahead and
146:02 - change the value so let's say I make
146:04 - this point O one or rather point of 5
146:08 - for example
146:09 - 0.01 would have been too less now as you
146:12 - can see I can make very precise
146:14 - movements
146:15 - so now this sensitivity option
146:17 - definitely works
146:19 - so this is how we would actually go
146:20 - about setting up sensitivity obviously
146:23 - if you really didn't care you could just
146:25 - have a variable here and stuff like that
146:27 - doesn't really matter honestly
146:30 - and there's another thing which you
146:32 - could do is first on begin play itself
146:36 - you could go ahead and pass your
146:38 - sensitivity over here
146:40 - and you could promote this to a variable
146:42 - over here
146:43 - and instead of calling the function
146:46 - every time
146:48 - and make this one private once again
146:50 - instead of calling the function every
146:52 - time you can go ahead and use the
146:54 - sensitivity variable
146:55 - so that's a little more better in terms
146:58 - of performance this is something which
146:59 - you could do as well
147:01 - now remember we are only able to do this
147:05 - because the player controller is always
147:08 - created before your character spawns
147:10 - let's say a player controller is not yet
147:12 - created by the engine you can't actually
147:15 - do this so let's say I go to my player
147:18 - controller and I'm not sure if I can do
147:21 - it on begin play maybe it would work on
147:23 - begin play but technically if I type in
147:26 - get player character
147:29 - and if I type in cost to my BP character
147:34 - and if I go ahead and print the string
147:40 - copy that over
147:42 - and I'll just type
147:44 - failed for this
147:46 - and doesn't matter to be honest and I'll
147:49 - type in success now if I go ahead and
147:52 - press play you see we get success
147:54 - however this happens only because our
147:58 - player controller is probably created or
148:02 - rather the begin play is actually called
148:05 - after the character is created as well
148:07 - however now I'll just show you guys
148:10 - another class now we'll discuss more in
148:12 - depth about this but if I just type in
148:14 - game instance I can go ahead and create
148:16 - a game instance class and this is
148:19 - actually referring to your whole game
148:21 - application so if I type in event init
148:24 - this is when your game starts this is
148:26 - It's not like the begin play where you
148:29 - are actually you know talking about when
148:32 - this entity is created
148:34 - the event in it is actually called uh
148:38 - act when the game starts so that's one
148:41 - difference so over here if I go ahead
148:43 - and put this logic over here
148:45 - and if I go ahead and go to my project
148:49 - settings
148:50 - and change the game instance
148:53 - game instance to new blueprint we'll
148:56 - delete that soon
148:57 - and if I go ahead and press play you see
149:00 - it says failed because our character is
149:03 - not yet created so that's one thing to
149:06 - note the the begin play logic only work
149:09 - because our character is already created
149:11 - now let's say we added a two second
149:12 - delay now this is gonna work
149:14 - so now if I do this it's gonna work
149:17 - because our character is now
149:19 - successfully created so that's basically
149:21 - one thing that you guys need to
149:22 - understand just make sure all your
149:25 - entities are valid before you actually
149:27 - set them and we can go ahead and revert
149:29 - our game instance so
149:31 - again we'll talk about all of this more
149:33 - in depth this is not something which you
149:35 - would really worry about at a beginner
149:37 - level
149:38 - now save everything and that should be
149:41 - good to go
149:42 - to go a little more in depth on the part
149:45 - where you know you'd actually check if
149:47 - this object is created so in our case I
149:51 - mean everything just worked out smoothly
149:52 - but what if it didn't what if this
149:55 - wasn't valid yet because as I told you
149:58 - guys the default value is none what if
150:00 - this wasn't valid well there is a fix
150:03 - for that as well there is actually a
150:05 - function called is valid so if I go
150:08 - ahead and type in is valid there's
150:10 - actually a macro which is created for us
150:13 - so what we can do is we can go ahead and
150:17 - actually do this
150:19 - so if we we can convert this to a normal
150:22 - MPR cast
150:24 - so on begin play we can go ahead and do
150:27 - this
150:28 - we can check if it is valid and if it is
150:32 - not valid we would not want to do
150:34 - anything but I mean if it is valid we
150:37 - want to set the reference obviously but
150:40 - if it is not valid we want to again
150:42 - check after a while and if it is valid
150:45 - obviously uh after setting the reference
150:48 - you would want to go ahead and set the
150:49 - sensitivity and do the regular stuff
150:53 - foreign
150:57 - now
150:58 - how do we actually check once again so
151:02 - for this you would use a technique known
151:04 - as polling so polling is where you
151:06 - repeatedly call a certain function until
151:10 - a certain condition is met and you
151:13 - actually get your desired result
151:15 - so the way you can do this is by using a
151:18 - timer and that takes us to the next
151:20 - important concept
151:22 - now if I right click and type in set
151:24 - timer you would see you you'd get a few
151:28 - nodes over here
151:30 - however the only one which you'll use is
151:32 - set timer by function name
151:34 - set timer by event is kinda pointless in
151:37 - my opinion because even if you do use
151:40 - this you can actually refer to an event
151:43 - by the function name itself so most of
151:45 - the times you would be using set timer
151:46 - by function name
151:48 - so you set timer by function name now it
151:51 - returns as a timer handle which allows
151:53 - us to control this timer
151:55 - and what this basically means is it is
151:58 - going to call the function with a given
152:00 - name so we can right click on this and
152:03 - type in collapse to function and let's
152:06 - call this one for example get references
152:11 - or let's call this one initialize
152:13 - and we don't really need this in the
152:15 - event graph
152:17 - and over here we can copy over this name
152:20 - so what we are basically saying is after
152:22 - certain time call this function once
152:24 - again so we can have a very small time
152:27 - such as 0.01 seconds and make this one
152:30 - looping because if you just uh set this
152:32 - to point on without the looping it's
152:34 - just going to execute it once
152:36 - and we can go ahead and store the handle
152:39 - of the timer so we can call this one
152:41 - initialization timer
152:47 - and once we have that
152:50 - this timer is now set and we could just
152:52 - comment it out and call this one polling
152:55 - for references
152:58 - again you could name it a little more
152:59 - descriptively you could give it a color
153:01 - as well that's one cool feature in
153:03 - unreal honestly you'd never use it but
153:05 - yeah I just showed it and under
153:08 - initialize
153:11 - we need to stop the timer once we
153:14 - actually finish everything so once we
153:16 - finish setting the sensitivity there's
153:17 - no reason for this function to run again
153:20 - so we can go ahead and get our timer
153:22 - handle first of all
153:23 - and if you just type in clear you'd get
153:27 - an option called clear and invalidate
153:29 - timer by handle go ahead and call that
153:31 - this is how you stop the timer
153:33 - copy this and if it is not valid we
153:36 - don't really want to do anything and if
153:38 - the cast failed again we don't really
153:39 - want to do anything
153:41 - so again yeah this cast is bound to fail
153:45 - actually this check is kind of useless
153:49 - in this case
153:51 - so we can just go ahead and do this
153:53 - because if we don't have a player
153:56 - controller this cast will obviously fail
153:58 - but anyways I'll just keep it like this
154:01 - and now if I go ahead and run this what
154:05 - will actually happen is every 0.01
154:08 - seconds it is going to repeatedly call
154:10 - the function until we have cleared it so
154:12 - once we get all the references we go
154:14 - ahead and clear the function I mean
154:16 - clear the timer there are some key
154:18 - differences though between doing this
154:21 - and using a delay obviously you could
154:23 - have done this as well so you could have
154:25 - done delay
154:27 - and let's say we give 0.01 once again
154:30 - and over here we can go ahead and call
154:33 - initialize and we can go ahead and loop
154:36 - this obviously we can call this first so
154:38 - initialize then after 0.01 seconds we
154:41 - could do this and maybe we could check
154:43 - if we have all the references we could
154:45 - maybe return a Boolean over here or
154:47 - something and do something like that the
154:49 - difference between a delay and a timer
154:51 - is that a timer is going to be very very
154:53 - precise it is going to be precise
154:55 - usually up to micro or even nanoseconds
154:59 - if you have a precise timer this one I
155:01 - believe is precise up to a couple
155:03 - hundred microseconds so as far as my
155:06 - testing is concerned you could use
155:08 - Chrono in C plus plus and actually test
155:10 - it so this is going to be accurate
155:13 - however a delay is going to be very very
155:15 - inaccurate so that's one thing to note
155:17 - if you want something to time accurately
155:20 - you would use a timer or in our case we
155:23 - needed the looping functionality so
155:25 - that's the reason we use the timer
155:28 - [Music]
155:33 - since we have built a fundamental idea
155:36 - on how inputs work now we can go ahead
155:39 - and check the other type of input that
155:41 - is input action mapping now before that
155:44 - let's actually just clean this up a
155:47 - little bit so just comment it out and
155:50 - type in movement
155:52 - movement and maybe you could type in
155:54 - movement and Camera maybe so movement
155:56 - and Camera
155:58 - so now we can just group this
156:01 - now head back into your project settings
156:04 - and under input again
156:07 - if you look at action mappings you can
156:09 - go ahead and add one and we can call
156:11 - this one interact
156:13 - and we could set that to the F key
156:17 - now the advantage of using it through
156:19 - the project settings like this rather
156:21 - than brute forcing so you could do F
156:23 - over here as well so if I just type in F
156:26 - and give a space and type in keyboard I
156:29 - can actually do this but this is not the
156:32 - proper way to do it because this uh
156:35 - these action mappings can be actually
156:38 - changed through your in-game settings
156:40 - menus so you can actually create a menu
156:43 - inside the game and allow the user to
156:45 - change or allow the player to change
156:48 - these key bindings
156:50 - so we'll call the call this one interact
156:52 - now so action event interact and this
156:55 - gives us a pretty basic pressed and
156:57 - released option so when we actually
157:00 - press it
157:01 - so we want to be able to pick up an
157:05 - actor now how are we going to actually
157:08 - set this up
157:09 - so first things first
157:11 - remember we had our actor begin overlap
157:14 - instead of doing it here it's always
157:16 - advisable we do it from the character
157:19 - so do your actor begin overlap here
157:22 - actor begin overlap
157:25 - once you call the actor uh begin overlap
157:29 - or here for the other actor instead of
157:32 - casting to a character since we are the
157:34 - character ourselves here because we are
157:36 - inside the character class right now we
157:39 - can cast to the pickup instead
157:43 - now that we have casted to BP pickup we
157:46 - are checking if this is actually a
157:48 - pickup now there is a better way to do
157:51 - it using interfaces but that is a much
157:53 - higher level concept than casting but I
157:56 - will definitely get to that a little
157:58 - later in this course so we'll probably
158:00 - change this to use an interface even
158:03 - that is casting at the very fundamental
158:06 - level but that's a more elegant solution
158:08 - to do things
158:10 - now if this is actually a pickup we can
158:13 - go ahead and actually store it so
158:15 - promote to variable
158:17 - and let's just say let's just call this
158:21 - one nearby pickup
158:23 - nearby pickup
158:26 - and what we can do is on our actor end
158:29 - all app so end overlap
158:34 - over here we can go ahead and again cast
158:37 - it first things first and if it is we
158:41 - can check if it is equal to the nearby
158:43 - pickup
158:45 - and if it is equal to the nearby pickup
158:48 - and we have left its bounds we can go
158:51 - ahead and remove it
158:53 - and invalidate the reference so we can
158:56 - all drag it and we can set it to be
158:58 - equal to none that is going to
158:59 - invalidate a reference
159:02 - so that's about it
159:03 - now once we have our reference what we
159:07 - can do is we can head in our interact
159:09 - function check if this is valid one more
159:11 - way you can do it is by right clicking
159:13 - and converting this to a validated git
159:15 - so if our pickup is valid which means we
159:18 - are near a pickup so what we can do is
159:20 - we can actually call a function for now
159:23 - let's just print out a string let's say
159:25 - so or rather we can just destroy it so
159:28 - type in Destroy and you will get destroy
159:31 - actor
159:32 - if I go ahead and press play
159:34 - and if I go close to it and if I hit
159:36 - interact you see I destroy the pickup
159:38 - and if I do that once again that is not
159:40 - gonna work
159:42 - the reason is once our pickup is
159:45 - destroyed it's no longer valid so what
159:47 - we have to do basically is check once
159:51 - again if we have any pickups nearby
159:54 - so that's actually really easy to do so
159:56 - once we destroy it we know that our
159:58 - nearby pickup isn't actually valid
160:00 - so we can go ahead and set our nearby
160:03 - pickup to the nearest one now how do you
160:05 - check that again using a function so we
160:08 - want to see if we are overlapping so
160:10 - type in overlapping
160:12 - and you already see
160:15 - you actually get
160:17 - options for get overlapping actors which
160:21 - is exactly what we need and for the
160:23 - class filter it's obviously going to be
160:25 - BP pickup
160:27 - and over here we get an array of actor
160:30 - references
160:31 - instead of getting all of them we can
160:33 - just get the first one this is an array
160:35 - so obviously we have to get the first
160:38 - index of the array
160:40 - so once we get that we can go ahead and
160:43 - cast this to BP pickup once again
160:47 - and it is going to be successful all the
160:50 - time so we can just make this a pure
160:52 - cast
160:53 - because we are actually using the class
160:54 - filter here
160:56 - and then we can go ahead and set the
160:58 - nearby pickup
161:00 - so now our logic should work
161:04 - for both the pickup so if I hit f one of
161:07 - the pickups got destroyed
161:10 - so I shouldn't have moved back actually
161:13 - so if I press f one got destroyed if I
161:15 - press F again the other one got
161:17 - destroyed as well and there are no
161:19 - errors
161:20 - so this is basically how you do
161:22 - something like a pickup now obviously
161:24 - before you destroy it let's say you had
161:27 - some properties let's say for example
161:29 - let's say this was a health portion or
161:32 - something which gave your player a
161:34 - couple of Health points
161:35 - so we can add in
161:38 - I don't know let's say health points
161:41 - obviously you will have a better
161:43 - inheritance hierarchy and we will get
161:47 - into that
161:48 - so Health points make this a float let's
161:50 - say we have 10
161:52 - so what we can do is for now we can just
161:55 - go ahead and print it so we can grab
161:57 - this
161:58 - Health points and we can just print it
162:01 - out
162:03 - so move all of this logic a bit over
162:06 - there to make space
162:07 - we can just print that before destroying
162:10 - it make sure you call Print before
162:12 - destroy otherwise you're going to get a
162:14 - log error
162:17 - now if I go nearby if I press f we are
162:21 - going to get 10 printed every time
162:23 - so that's basically how you do it
162:26 - [Music]
162:31 - however
162:33 - let's say you wanted to change some of
162:36 - these properties
162:38 - depending on which pickup it is
162:41 - now apart from having these as a
162:43 - variable
162:44 - you can go ahead and check these two
162:46 - options called instance editable and
162:49 - expose on spawn
162:52 - what these will do is allow us to edit
162:55 - these properties when we actually spawn
162:57 - it so let's say we spawn a pickup for
162:59 - example
163:01 - so over here
163:02 - let's say I do spawn actor
163:05 - let's have a spawn a pickup
163:08 - you see we actually get an option to
163:10 - change our health points so we could do
163:12 - something like 90 for example and for
163:15 - the spawn transform we can just uh get a
163:17 - random location let's say uh let me just
163:20 - add in
163:21 - something for us to recognize so
163:24 - something which you would use for such a
163:25 - case is called a Target point
163:28 - so I can use a Target point so this will
163:30 - represent a target a point in space you
163:33 - can copy this over and we can go ahead
163:35 - and paste it in or okay maybe we can't
163:38 - do that here you can do it in the
163:41 - details panel so one one five zero
163:44 - uh negative whatever this value is
163:47 - and 650.
163:50 - so 650.
163:52 - and we have health points set to 90 over
163:55 - there now as you would see we actually
163:58 - spawn another pickup now if I go ahead
164:00 - and pick these up you get 10 but when I
164:03 - go near this I get 90.
164:06 - however it need not be restricted to
164:09 - spawning it through the blueprint you
164:12 - can actually edit Expos on spawn
164:13 - variables right here as well so even
164:16 - when you're placing them in the level
164:18 - you could have this to be 20 for example
164:21 - so if I go nearby
164:24 - you would see 10
164:25 - 20 and this one is obviously going to be
164:28 - 90. so stuff like that which you can do
164:32 - using expose on spawn you can expose any
164:34 - variable on spawn and they will be
164:36 - passed right into the actor and the
164:38 - value which you pass in would be set to
164:40 - that variable
164:42 - and now we can go ahead and remove this
164:44 - logic that was just for showcasing
164:46 - purposes
164:47 - and we can go ahead and collapse system
164:50 - function and call this one whoops call
164:54 - this one pickup
164:57 - and along with this maybe we could also
165:00 - have something like door open or
165:03 - something let's say this is not valid we
165:05 - could go ahead and perform door open or
165:07 - something like that we could go to the
165:09 - return node and we could have a sequence
165:12 - node here
165:13 - so first we would check for a pickup
165:16 - and we could also do something like a
165:18 - door open or maybe anything else
165:21 - probably maybe if you had some sort of
165:24 - an interaction system with a player or
165:26 - something so you could interact with the
165:28 - other player stuff like that which you
165:31 - can do using these input bindings and
165:33 - using the overlap events
165:37 - foreign
165:47 - events now I will show you guys how to
165:49 - do it the better way with interfaces
165:51 - later but this is the Brute Force way
165:53 - and if you have maybe one two or maybe
165:56 - three or not more than four interactions
165:59 - you could use this method itself the one
166:01 - which we did with casting so this is
166:04 - totally okay for small things
166:06 - now let's actually do it so right click
166:09 - create a new actor and let's call this
166:11 - one interaction actor
166:15 - maybe we could just uh nudge it or
166:18 - something so
166:20 - let's say we have we have another static
166:22 - mesh make that the root component and we
166:26 - need some sort of bound so sphere
166:28 - Collision Maybe
166:29 - and for the mesh let's just take a cone
166:33 - for example and also I've gone ahead and
166:35 - deleted the code which we had inside BP
166:39 - pickup since we are not using it
166:41 - and over here go ahead and simulate
166:44 - physics make sure you don't forget that
166:46 - and we can go ahead and okay maybe we
166:50 - can have a smaller one for example
166:53 - so I'm not really sure I'm just looking
166:55 - for
166:57 - any mesh that's available to us because
166:59 - we haven't imported ours
167:02 - okay this is way too big
167:05 - okay this sphere seems like a reasonable
167:07 - size we can go ahead and increase our
167:09 - bounds
167:11 - that's about it
167:13 - and once again over here we can head
167:16 - into our BP character
167:18 - and what we can do is we can copy our
167:21 - the same logic
167:23 - so instead of nearby pickup we are going
167:26 - to have something else so if this cast
167:28 - fails so if
167:30 - whatever we are nearby is not a pickup
167:33 - we can check if this is actually an
167:35 - interaction actor so we can do cast to
167:37 - interaction actor
167:40 - and again other actor is what we are
167:43 - checking if it is the interaction actor
167:45 - we can go ahead and promote this to
167:47 - variable and call this one interaction
167:49 - actor again I prefer going with Pascal
167:53 - case
167:54 - all right now when we actually
167:59 - go away from it we can again do the same
168:02 - cast so we can copy this over
168:05 - we can paste it
168:07 - and for this actor if it is equal to the
168:11 - interaction actor which we were nearby
168:13 - so copy this over
168:17 - grab in the interaction actor if it was
168:19 - in fact the interaction actor then we
168:22 - can go ahead and invalidate it
168:26 - and set that to be equal to none
168:31 - so that should be about it now over here
168:34 - in the interaction logic we can go ahead
168:37 - and check if this is valid right click
168:39 - convert to validated get so if we are
168:43 - near an interaction actor uh what we can
168:46 - do is we can instead of destroying let's
168:49 - actually add impulse so add impulse
168:52 - so add impulse
168:57 - so ins so we want to add impulse to the
169:01 - root component here which is simulating
169:03 - physics
169:04 - basically these are the physics
169:06 - functions you have impulse Force dark
169:08 - and all sorts of stuff obviously you
169:11 - could spend some time and study those
169:13 - but we'll not get into that so we have a
169:16 - sphere here so
169:18 - static mesh is the root component so we
169:21 - need to get the static mesh
169:25 - if I go ahead and scroll all the way
169:28 - down I should see get static mesh now
169:30 - this variable refers to the component
169:33 - even components are objects so you can
169:37 - just get them as variables
169:39 - and for the impulse what we can do is we
169:43 - can go ahead and get the forward
169:44 - direction of a character get forward
169:46 - vector
169:48 - now you could change it according to
169:50 - y'all this is logic based so it's
169:53 - nothing much really and you can multiply
169:55 - this by a certain value so you can make
169:57 - this one a float
170:00 - and change this to a float
170:03 - make this let's say something like 10
170:06 - 000 something big Maybe
170:08 - get active forward Vector multiply that
170:11 - by ten thousand
170:13 - and that should be good to go
170:17 - now we can collapse this to a function
170:20 - and we can call this one nudge ball or
170:24 - something because the sphere looks like
170:26 - a ball so
170:27 - nudge ball Maybe
170:30 - and if I go ahead and press play okay we
170:32 - have a compilation error so we can check
170:35 - what's that
170:36 - so it says
170:38 - let's read the arrow first of all okay
170:41 - it was just uh it just compiled it in
170:44 - the wrong order it compiled character
170:45 - before this so it didn't know what
170:48 - static mesh was now we should be able to
170:50 - go ahead and play this and first of all
170:52 - we don't have an interaction actor let's
170:54 - actually create one go ahead and press
170:56 - play
170:58 - now if I go ahead and bump into this
171:04 - oops I shouldn't have bumped into that
171:06 - if I press F on my keyboard when I'm
171:08 - overlapping it
171:09 - uh the bounce is a little too small let
171:11 - me just increase that
171:16 - so increase the radius don't scale it up
171:21 - and one more thing if you want to see
171:23 - the bounds just for testing purposes you
171:26 - can set this flag called hidden in game
171:28 - to false so now it is going to be
171:31 - visible in the game as well
171:33 - so if I look around yeah there we have
171:36 - it so we can enter our bounds and now if
171:39 - I press F on the keyboard you see we
171:41 - actually not jit
171:43 - so the force is way too small so I can
171:46 - go ahead and make this something like 50
171:48 - 000 let's say
171:52 - so if I go ahead and press F over here
171:54 - you see we are actually not doing it
171:57 - so this is the way you would set up
171:59 - interaction using casting obviously you
172:03 - can use interfaces to simplify things a
172:05 - little bit
172:06 - but yeah this is the basic idea
172:09 - [Music]
172:14 - all right so in order to understand
172:16 - whatever I just told now in case it went
172:19 - above your head please do Tinker around
172:21 - and try some of the functions yourself
172:23 - using the context sensitive and the and
172:27 - the search bar basically so when you
172:29 - right click and let's say you drag
172:32 - something off of this you can go ahead
172:35 - and type any random function so for
172:37 - example if I just press a you get a
172:40 - bunch of functions maybe you could have
172:42 - a look at all of these maybe have a look
172:44 - at documentation and maybe try out some
172:47 - of your own logic
172:49 - and try out something else maybe add in
172:52 - another actor to do something else with
172:54 - maybe add in a door and make it open or
172:57 - something so you guys should be able to
172:59 - try it out yourself and once you are
173:02 - actually done with that now we can go
173:04 - ahead and talk about the next part now
173:07 - until now we talked about the basics and
173:11 - I'm pretty sure you can write some basic
173:13 - game logic with whatever we have done
173:14 - already but there are a couple of
173:17 - functions which the engine provides us
173:19 - which is going to make our job a lot
173:21 - easier
173:22 - the first one and one of the most
173:25 - commonly used ones which I would like to
173:27 - talk about is Ray casting now if you
173:30 - guys are familiar with other engines you
173:32 - guys would know what a raycast is
173:34 - but in Unreal Engine you call it a line
173:36 - dress so if I right click and call line
173:38 - Trace so you see you get a bunch of
173:40 - options the one you'll use most of the
173:43 - time is line Trace by Channel multi is
173:45 - basically used when you have penetration
173:47 - and stuff when you are detecting
173:49 - multiple hits in the same line I'll I'll
173:51 - tell you guys what's line Trace first
173:53 - so line Trace is basically a function
173:56 - which lets us draw a line from a given
174:00 - starting point to a given ending point
174:02 - and in between these two points if you
174:05 - are actually hitting anything you are
174:07 - going to get it as a hit result
174:09 - so I can get access to the hit location
174:11 - and in case you want to see the line
174:14 - itself you can change this draw debug
174:17 - type enum and make this for duration and
174:21 - if you guys wondered this is an
174:22 - enumeration that's the reason we are
174:24 - getting these options so none for one
174:27 - frame for duration and persistent are
174:29 - the enumerators so if we select for
174:32 - duration we are going to get the line
174:35 - for some time persistent means the line
174:38 - is going to be shown to us forever until
174:40 - you close the game of course
174:42 - so let's actually do something with this
174:45 - so let's actually set up an input event
174:48 - let's say when we click our left Mouse
174:50 - button so we can type in left Mouse
174:52 - now I'm just setting this up brood Force
174:55 - because I don't really know what exactly
174:58 - we are going to set up once we actually
175:00 - get to the examples we'll do that
175:02 - now for the start location
175:05 - you can choose the camera's location of
175:08 - the player because this is where you
175:11 - would be seeing stuff so you can select
175:13 - the camera's location for example
175:16 - so if I go ahead and get the start
175:20 - location the way you do that is there
175:22 - are a couple of ways
175:24 - you could do this and you could do get
175:27 - location
175:28 - so you can get get World location and
175:31 - you could use this as a starting point
175:33 - and the way you would go forward towards
175:36 - the center of your screen is going to be
175:39 - first of all by getting the forward
175:40 - vector
175:42 - so you can get the forward Vector of
175:43 - this camera
175:45 - and multiply this by a certain value
175:48 - Again by a float
175:51 - uh we'll do that add that to the
175:54 - starting location so starting location
175:58 - plus forward Vector into a certain
176:01 - number of a certain number that is going
176:04 - to be your end and we can go ahead and
176:07 - change this to a float
176:10 - and we can do let's say 50 000. I mean
176:15 - the number is arbitrary obviously unreal
176:17 - uses centimeters remember that
176:20 - so anything that you type in will be in
176:22 - centimeters so 50 000 centimeters is
176:25 - going to be divided by 100 so it's going
176:29 - to be like 500 meters
176:31 - now if I go ahead and Press Play If I
176:33 - press my left Mouse button you see you
176:35 - get a line drawn over there so if I
176:37 - press f8
176:38 - you see I can actually see the line
176:40 - which was drawn so the red thing which
176:42 - you see that is the line which was drawn
176:45 - and as you can see
176:47 - uh where where it hit the surface it
176:49 - actually registered a hit
176:52 - and in order to show that there is one
176:55 - more thing which you can do actually Oh
176:57 - and about the other options Trace
176:59 - channel is something we'll talk about
177:00 - later but basically you can do stuff
177:03 - like ignoring several uh types of
177:06 - objects so let's say you had a shooter
177:09 - game and let's say you wanted to like
177:11 - ignore teammates you could use it for
177:13 - that but you'd use tags for that as well
177:15 - but there are several other use cases
177:18 - camera is another thing depending on
177:21 - what type of objects you want to you
177:23 - want the hit to detect you would do that
177:25 - and actually if you were to notice if I
177:28 - select my mesh and if I scroll down to
177:31 - the Collision part
177:34 - so I'll just type in Collision instead
177:37 - of searching for it like this so
177:39 - Collision
177:40 - you have to notice it says character
177:43 - mesh for the preset and over here if you
177:45 - see there is actually visibility and
177:47 - camera so what you can do is you can
177:51 - actually make it block certain things so
177:54 - now let's say I wanted this line Trace
177:57 - which is using visibility right now to
177:59 - block it I would have to change this to
178:01 - custom and make this one block
178:04 - visibility so then I would be able to
178:07 - I would be able to make this line block
178:10 - it
178:11 - stuff like that which you could do now
178:14 - obviously I'll change it back to
178:15 - character mesh we didn't do anything but
178:17 - still
178:18 - so over here change it back to character
178:22 - mesh
178:23 - and let's say you wanted to ignore the
178:25 - camera Channel you could do that as well
178:28 - now let's say you wanted to just Mark
178:32 - the place where you actually hit so now
178:34 - we have access to the hit location so
178:36 - there is a function called Draw debug
178:38 - sphere
178:39 - you can actually draw many other shapes
178:41 - but sphere is the one which you'll use
178:43 - most often
178:45 - and the center is obviously the place
178:48 - where you hit it so out hit location
178:50 - and radius 100 maybe we can have 10
178:54 - seconds for the duration and thickness
178:56 - let's just say two units line color
178:59 - let's set that to maybe something like a
179:02 - greenish yellow or something
179:03 - now if I go ahead and Press Play If I
179:06 - left click you see it's drawing a sphere
179:08 - where it actually hit it
179:10 - and you could change some of the
179:12 - properties let's say you wanted a more
179:15 - details here I don't know why you would
179:17 - want that though and maybe reduce the
179:19 - radius of the sphere you could do that
179:21 - as well
179:23 - so as you can see we are registering a
179:26 - hit over there so that's what it's
179:28 - basically showing us
179:29 - so this is how you do a line Trace
179:31 - basically you draw a line from one end
179:33 - to the other and you can detect hits
179:34 - obviously for shooting a weapon and
179:37 - stuff like that you use it now there is
179:39 - another way you can actually determine
179:41 - the start and end location now whatever
179:44 - logic you have here is fine if you only
179:47 - have one camera but what if you had a
179:50 - first person view and a third person
179:52 - view for example let's say you had two
179:54 - cameras
179:55 - you cannot check which camera you are
179:58 - using and stuff that would make the
179:59 - logic complicated so the way you do it
180:02 - is you would use a function called get
180:04 - player camera manager
180:06 - now this is going to get the current
180:09 - camera which you're using and it's going
180:11 - to be an actor so we can just type in
180:14 - get actor location
180:17 - and this is going to be your camera's
180:20 - location so let's say you switch between
180:21 - cameras this is going to work
180:24 - universally regardless of which camera
180:26 - you're using however since in this logic
180:29 - we are using this camera's reference
180:31 - let's say we had another camera this
180:34 - logic is not going to work it is going
180:35 - to work with respect to this camera
180:38 - so instead of this I can go ahead and
180:41 - replace it
180:43 - and we can get the actor for Vector
180:46 - again
180:47 - get actor forward vector
180:50 - and we can replace this by this
180:54 - and we can go ahead and delete it and
180:57 - the rest of the logic Remains the Same
180:58 - obviously and now if I were to press
181:01 - play you would see that the logic does
181:04 - not work okay we didn't plug it in so
181:07 - the actor location is going to be the
181:08 - start of course not zero
181:11 - press play and the logic works exactly
181:13 - the same one more thing you'll notice is
181:15 - that the line Trace is going exactly to
181:18 - the center of our screen if you were to
181:19 - notice
181:21 - that's one more thing the reason it's
181:23 - happening like that is because we are
181:26 - going from the center of our Viewpoint
181:28 - and going exactly forward to the view so
181:32 - that's the reason it's actually going
181:34 - right at the center of the screen and if
181:36 - you add a Crosshair in game it would
181:37 - land right at the center
181:40 - so this was recasting there are many
181:43 - other options as well such as hit actor
181:45 - so you can cast it so let's say we cast
181:48 - it to pick up for example so we can
181:50 - check if we actually hit the pickup so
181:53 - if we actually did hit a pickup what we
181:55 - can do in fact is we can go ahead and
181:58 - run some logic let's say we destroy it
182:02 - so I'm just showing you guys one more
182:04 - example to make things clear
182:06 - so if I press play
182:07 - so that's not the pickup so nothing
182:10 - happened but if I hit a pickup as you
182:12 - can see we are destroying it so
182:14 - something like a gun
182:16 - [Music]
182:21 - all this is fine but we do not have any
182:24 - sort of a user interface now apart from
182:27 - the lighting needs to be rebuilt then
182:29 - you can actually delete that by typing
182:31 - in disable all screen messages
182:34 - so oops I didn't type that so disable
182:37 - all screen messages
182:39 - so you can go ahead and type that and
182:41 - it's going to remove that
182:43 - so there's nothing much really we don't
182:46 - even have a simple health bar so we can
182:48 - go ahead and add a couple of components
182:50 - on screen
182:51 - so in order to create widgets on the
182:54 - screen if you want user interfaces the
182:57 - way you do that is using widget
182:58 - blueprints so let's get to that inside
183:01 - your content folder I want you guys to
183:03 - create a new folder and we can call this
183:05 - one UI
183:06 - and inside this we can call this one for
183:10 - example HUD to denote heads up display
183:14 - now open it up and inside this folder
183:17 - right click and create a widget
183:20 - blueprint by heading into user interface
183:22 - now you could do it through the
183:25 - blueprint class menu as well type in
183:27 - widget blueprint you should you should
183:29 - find a widget blueprint somewhere over
183:31 - here so user widget is the one actually
183:34 - so go ahead and select that and we can
183:37 - call this one HUD
183:39 - BP underscore HUD generally I also like
183:43 - to add underscore WB to represent widget
183:46 - blueprint but if we are going to have
183:49 - separate folders for each one it's not
183:51 - really required
183:52 - open it up and you will get a blank
183:55 - canvas
183:56 - and you'll have two tabs over here on
183:58 - the top you have a designer and a graph
184:00 - as well
184:01 - so what we'll be using most of the time
184:04 - is the designer and to add the logic for
184:07 - it we are going to use the graph if you
184:10 - guys have used the QT framework in C
184:13 - plus plus the functions and stuff work
184:16 - pretty similarly over here but since
184:18 - this is going to be in Blueprint it's
184:21 - going to be much much easier to
184:22 - comprehend
184:24 - now the most basic type of widget that
184:27 - you can add is a canvas panel so add in
184:30 - a canvas panel before this actually used
184:32 - to come by default without you having to
184:34 - actually add it now you won't worry
184:37 - about most of the settings actually the
184:39 - only thing that you'll worry about is
184:41 - custom or fill screen actually these are
184:43 - the only two which you'll most probably
184:45 - use custom is basically used if you have
184:49 - stuff like drop down and you're making
184:51 - like a child widget for something
184:53 - and I will show you guys examples for
184:56 - that when we go to the higher level part
184:58 - so for now we'll use fill screen so this
185:00 - is going to take up the entire screen
185:03 - now in order to actually create this now
185:05 - there is nothing but we we can just
185:07 - create it nonetheless
185:09 - generally it's not advisable to create
185:11 - it in in the character widgets usually
185:14 - would be created in something a little
185:16 - more persistent such as a player
185:18 - controller so we have one setup already
185:20 - so we make sure you set that in the game
185:22 - mode open it up and we could do it on
185:26 - begin play
185:27 - add in a custom event and this is where
185:30 - you actually use custom events so you
185:33 - could use a function no harm with that
185:34 - but let's use custom events this is what
185:37 - you would use them for
185:39 - so we are going to be calling this one
185:41 - for example create HUD
185:44 - and we can call that so create HUD
185:49 - over here we can go ahead and type in
185:52 - create widget
185:55 - we'll get to select it so BP HUD does
185:58 - what we want to create and we can
186:00 - promote this to a variable and call this
186:02 - one HUD
186:03 - or you could call it hardref if you
186:06 - really want to be that specific
186:08 - now we have a reference to the HUD
186:10 - however we still haven't actually
186:12 - created it we have just internally
186:15 - stored it but if you want to show it on
186:17 - the screen type in add to viewport
186:23 - so now this should be added to your
186:27 - screen
186:28 - however there is there is another thing
186:31 - which you could do actually there is
186:33 - another option called add to player
186:35 - screen
186:36 - however this is not really used that
186:40 - much so this is usually used for split
186:43 - screen and stuff like that will not get
186:45 - into this so you'll use add to viewport
186:47 - most of the times
186:49 - all right so now under your HUD
186:52 - for the health bar obviously we need a
186:54 - progress bar so type in progress bar and
186:57 - unreal has everything built in for us so
187:00 - let's add it at the bottom left hand
187:01 - side of the screen that's the reason I
187:03 - chose the canvas panel
187:05 - so that we can easily uh just drag stuff
187:09 - in with other types of widget it's
187:12 - usually like a layout which you create
187:13 - so it's going to be harder for you to
187:16 - just move things around
187:19 - all right so let's add the progress bar
187:21 - and on the right hand side under the
187:23 - details panel we can rename it we can
187:25 - call this one health bar
187:27 - and we can set all sorts of parameters
187:29 - maybe we can make this one 350 by 45
187:35 - and over here you'll see another tab
187:38 - called anchors now anchor is basically
187:41 - telling you the position with respect to
187:44 - it basically for example let's say set
187:47 - it to bottom left in this case bottom
187:49 - left is ideal
187:51 - so this is going to be your 0 comma 0
187:54 - and with respect to that your Y and your
187:57 - other values are going to be set so when
188:00 - I say the anchor is at the bottom left
188:03 - and my position is 88 what I mean is I
188:06 - have placed this progress bar 88 units
188:09 - to the right of this anchor
188:11 - and Y is basically your vertical
188:15 - Direction so minus 120 is 120 units
188:18 - upwards basically
188:20 - and size X and size y will remain the
188:23 - same
188:24 - alignment is basically telling you what
188:28 - to take as this the reference point so
188:31 - if I make this 0.5
188:33 - you see it's going to Center off so it's
188:35 - the distance between this and the center
188:37 - now
188:38 - same with the Y so if I type in 0.5 it
188:40 - will move a little bit down or up
188:42 - actually because it was over here so now
188:45 - the point shifted over there so it moved
188:47 - a bit up and if you want to Center
188:50 - something exactly at the center of the
188:52 - screen so for example across here so you
188:55 - would set the anchor to be this the
188:57 - center one
188:58 - and over here you will change the
189:01 - alignment to 0.5 and set the position to
189:03 - 0 and 0. now this is going to be
189:05 - perfectly centered regardless of your
189:07 - resolution
189:09 - now another reason to actually use this
189:14 - so let me just actually move this back
189:16 - so zero zero
189:19 - another reason to use anchors is for
189:21 - different resolutions let's say you had
189:23 - an 800 by 600 screen let's say somebody
189:25 - is playing with that and you had a
189:27 - progress bar over here
189:29 - let's say you left it at the default
189:32 - anchor let's say you didn't actually
189:34 - modify the anchors this widget is
189:37 - actually going to go outside the player
189:39 - screen
189:40 - however if you change the anchor to the
189:42 - bottom right now this widget is
189:46 - minus 461 and minus 137 relative to the
189:51 - bottom right corner so then it will
189:53 - always be inside the screen so that's
189:55 - another reason to use anchor so I'll go
189:57 - ahead and undo all of that
189:59 - so that should be good now if I go ahead
190:03 - and create this so in apply controller
190:05 - on begin play we are actually creating
190:07 - it now if I go ahead and press play you
190:09 - see we see our progress bar and since we
190:11 - have our anchor over here you see it
190:13 - always stays at the same relative
190:15 - position on the screen
190:17 - the next thing that you obviously want
190:20 - to do is actually bring in the values of
190:23 - Health from the character to the actual
190:25 - widget so it's actually pretty simple to
190:28 - do that so let's go step by step there
190:31 - are quite a few ways you in which you
190:33 - can do it so if you would have created
190:35 - the widget on the character it would
190:37 - have been simple to just pass in the
190:39 - health value to the widget however since
190:42 - we have done it in the player control
190:43 - there is an extra step but nothing to be
190:47 - worried about
190:48 - so now let's create an event in the
190:51 - player controller so that we can
190:53 - actually interact with the widget
190:55 - so we can call this one update health
190:57 - for example so type in custom event and
190:59 - call this one update help
191:02 - and for the new value we can go ahead
191:05 - and add in an input and it's going to be
191:08 - of type float obviously and we'll call
191:11 - this one new health
191:14 - now over here in the progress bar we can
191:17 - go ahead and create another event or we
191:19 - could even directly adjust it here so we
191:22 - could get the HUD
191:23 - and over here we could type in first of
191:27 - all let's check if our progress bar is a
191:29 - variable make sure it's set to is
191:31 - variable otherwise you won't be able to
191:32 - access it
191:33 - so if once that is variable get the
191:36 - health bar
191:37 - and again this is where your blue print
191:41 - menu is going to help you a lot now you
191:44 - want to set the percentage so type in
191:47 - set percent
191:50 - you will go ahead and get this node now
191:52 - in case you guys don't know this percent
191:55 - is going to be a value between 0 and 1
191:57 - and our health is a value between 0 and
192:00 - 100 so let's just divide this by 100.
192:04 - so do that or you could make your health
192:07 - variables store 0 to 1 that works too
192:09 - all right so you can do that or you
192:12 - could have a custom event inside your BP
192:15 - HUD that works too
192:17 - so let's head back into a character now
192:20 - and what we can do is we can actually do
192:24 - something so let's say when we actually
192:26 - pick something up let's say we reduce
192:28 - our health for example so we can head
192:31 - into our interaction so when we pick it
192:34 - up let's say we reduce our health by 10
192:36 - maybe
192:37 - now if it is valid we destroy it and we
192:41 - invalidate the nearby pickup and let's
192:43 - reduce our health by 10. so create a
192:46 - health variable first of all now health
192:49 - is a variable which is dependent on
192:52 - which character you are in so that's why
192:54 - we are creating it in the character make
192:56 - this private
192:58 - over here
193:00 - make this variable private
193:02 - and we can go ahead and set the health
193:07 - to be equal to whoops
193:09 - we can go ahead and set the health to be
193:12 - equal to health
193:13 - minus
193:15 - 10.
193:18 - and we don't want it to actually go
193:22 - below zero so we can go ahead and clamp
193:24 - the value so we can call this one clamp
193:28 - so clamp float minimum is 0 maximum is
193:31 - 100 obviously
193:34 - so I can go ahead and set it now if our
193:37 - health is zero so if our health is less
193:39 - than or equal to 0 if you don't clamp it
193:42 - you can check for less than or equal to
193:44 - so let's do that actually
193:46 - so if our health is less than or equal
193:49 - to 0
193:50 - whoops less than or equal to zero
193:53 - we can go ahead and just kill our player
193:57 - so instead of killing it let's just exit
193:59 - the game instead so we can call
194:02 - we can execute a console command so type
194:05 - in execute console command
194:07 - and this one will simply type in exit
194:10 - it's going to exit the game even quit
194:12 - works
194:14 - now this is something which you might
194:15 - need multiple times
194:17 - so what we can do instead of this is we
194:20 - can actually make a set Health function
194:22 - because we want to exit the game even if
194:25 - our health is reduced for some other
194:27 - reason
194:28 - so here in this case we picked it up so
194:31 - our health reduced but we want to be
194:33 - able to reuse this so right click
194:35 - collapse the store function and call
194:37 - this one set health
194:40 - now let's say you don't want this to be
194:42 - able to call it on the other blueprints
194:44 - so let's say you want to only be able to
194:46 - call it in this BP character you can
194:48 - make it a macro instead and obviously we
194:51 - need the health value so grab in health
194:54 - and head back into your event graph pick
194:57 - up over here we can go ahead and pass in
195:00 - the health so this is going to handle
195:02 - everything for us and let's actually
195:04 - make this a larger value let's say 40.
195:07 - so on our third pickup in theory we
195:09 - should exit our game
195:10 - and if it is not less than or equal to
195:13 - zero uh we can go ahead and update the
195:16 - progress bar first things first and
195:18 - remember we had our play controller
195:20 - reference now we can go ahead and use
195:22 - that
195:23 - so regardless of what we do we want to
195:25 - update the helper I mean we'll exit over
195:27 - here so we don't need to update it so we
195:30 - can type in update health
195:33 - and new health is going to be our health
195:35 - variable
195:38 - now some people might show you how to do
195:42 - this using a binding so you can actually
195:44 - go into your progress bar and you can
195:46 - type in bind and create a binding
195:49 - however this is very very inefficient
195:52 - and it is going to run on tick so
195:55 - actually don't really bother using that
195:57 - do it the way I am showing you guys this
195:59 - is the proper way to do it however there
196:01 - is a good there is a small chance that
196:04 - it might miss it might not update but
196:07 - that's nothing to worry about it's going
196:09 - to be like one in a million maybe so it
196:11 - honestly doesn't matter
196:13 - so once that said we should be good to
196:16 - go and make sure by default your health
196:18 - is set to 100
196:20 - and once just update the progress bar
196:23 - once you set the player controller
196:25 - reference because we are not actually
196:27 - setting the health by default
196:29 - uh in the heart you could set it however
196:31 - what if a player disconnected from a
196:34 - match and is coming back so you don't
196:36 - want it to be 100 because you'll be
196:37 - creating the widget once again right so
196:40 - set it once you get the player
196:42 - controller so in our initialize function
196:45 - once we get the play controller
196:47 - reference we can go ahead and set that
196:50 - and we'll clear the timer at the last
196:53 - order doesn't matter here since this
196:55 - function is already being executed the
196:58 - order honestly doesn't matter but we can
197:00 - do it like this
197:01 - now if I go ahead and press play you'd
197:04 - see our health is set to 100
197:07 - and if I go closer okay let me just
197:09 - speed that up a bit
197:13 - so if I interact with this nothing
197:15 - happens but if I go ahead and interact
197:18 - with this our health reduces my health
197:21 - reduced and now we exit the game the
197:23 - third time we do that
197:25 - so this is basically how you work with
197:27 - widgets so if you want to update it you
197:29 - would just use one of the functions
197:31 - which are there in one of these widgets
197:33 - and what if you wanted text obviously
197:36 - you just search accordingly type in text
197:39 - and you should be able to find text
197:42 - so let's actually type in the actual
197:45 - health value
197:46 - so over here
197:48 - what we can do is we can just give 100
197:51 - by default or we could leave it a text
197:53 - block and set it normally so over here
197:57 - get back into your play controller
198:00 - and in your update Health function we
198:03 - can go ahead and grab our text I don't
198:06 - know if it's set variable so it is not
198:09 - set to be variable so we can type this
198:10 - one Health text
198:13 - now you should be able to access health
198:15 - text from the player controller once you
198:18 - set that to its variable
198:19 - so grab in our HUD
198:22 - Health text so get your health text
198:26 - and over here we can go ahead and set
198:29 - the text
198:30 - to be equal to the health value itself
198:33 - now there is a special node which you'll
198:35 - use a lot called format text
198:38 - so this is very simple actually use
198:41 - curly braces
198:42 - and type in health
198:45 - it will make a pin for you whatever you
198:47 - type in curly braces will be a pin
198:49 - and the first one let's just put a plus
198:52 - over there because it's usually usually
198:55 - health is denoted with a plus before
198:57 - so your current so your text is
199:00 - basically going to be plus along with a
199:02 - health appended with your health so let
199:05 - me just show that actually so grab in
199:08 - your new health
199:09 - you can grab in any sort of pin by the
199:11 - way
199:12 - now if I go ahead and press play you see
199:15 - it says plus hundred because it took
199:18 - plus and the actual health value itself
199:20 - now I apologize I do realize that the
199:23 - screen is a little bit black and white
199:24 - so now it should be fine
199:27 - so you have plus and you have your
199:29 - health
199:31 - similarly you could you could do
199:33 - something like maybe hyphens
199:37 - so it's just going to append it as is
199:40 - you can go ahead and mess around with it
199:43 - a little bit let's say you wanted
199:44 - another parameter you could put curly
199:47 - braces once again and type this one
199:50 - maybe
199:51 - something
199:53 - and over here you can go ahead and make
199:56 - make a little a little string or a text
199:59 - so
200:01 - let's just say hi for example so it's
200:03 - going to print
200:04 - plus 100 space High
200:07 - if I put a hyphen here it's going to
200:09 - take it as is so plus 100 hyphen height
200:14 - so stuff like that which you can do
200:16 - using this format text node and it's
200:19 - really handy in my opinion
200:21 - so now if I go ahead and press play we
200:23 - have our health bar
200:25 - now we could do a little more of
200:27 - Designing so head back into your HUD
200:31 - and you can actually wrap this around
200:33 - with a border if you right click and
200:36 - type in wrap with
200:38 - you can wrap it with a border and
200:40 - actually have a border color and stuff
200:42 - so I can select this and make sure you
200:45 - set your padding to whatever you want
200:47 - padding is basically the spacing you
200:49 - give
200:50 - so if I change the padding in this case
200:52 - so if I change this to 10 you'd see that
200:56 - you're giving more space on all
200:57 - directions I'll just set it to something
200:59 - like 5 Maybe
201:01 - and I'll make this one black so not
201:03 - content color that's going to be a
201:05 - progress Parts color instead go to brush
201:07 - color and change that to something dark
201:09 - Maybe
201:10 - and over here as well let's just change
201:13 - the fill color to Green because that's
201:15 - more appropriate for your health widget
201:16 - so change that to something a bit more
201:19 - greener
201:21 - now if I go ahead and press play you'll
201:24 - be able to see we get the appropriate
201:25 - color and our health bar updates as
201:27 - normal under text updates as well
201:31 - so that's basically it so that's the
201:33 - basics of widget blueprints we will talk
201:36 - a lot more in depth about this as we
201:38 - move further but now you guys should
201:40 - have a pretty basic idea on how to
201:42 - create stuff now the palette is
201:44 - something which I want you guys to
201:46 - explore so check boxes a checkbox and
201:49 - you won't use most of these most often
201:52 - you'll use text slider button image
201:55 - border and images as it says it's an
201:58 - image and one more which you might use
202:01 - if you want something like a username
202:03 - password menu is a text box
202:05 - so you can grab in a text box and this
202:09 - will allow the user to enter any text
202:11 - inside
202:12 - stuff like that
202:14 - now
202:15 - I want to cover widgets in a little more
202:18 - detail
202:19 - so let's actually
202:21 - create another level called main menu
202:23 - and let's accelerate transition to this
202:26 - level using a widget so like you click
202:28 - the play button in your widget and then
202:31 - you would enter this level let's do that
202:32 - now
202:34 - first we can go ahead and create our map
202:36 - so heading to content maps right click
202:39 - create a new level and we can call this
202:41 - one main menu
202:43 - open it up or rather let's just be a
202:46 - little more descriptive call this one
202:47 - main menu level open it up and this
202:50 - should be blank and that's really none
202:53 - of our concern head into UI create a new
202:56 - folder and we'll call this one main menu
202:59 - over here go to user interface widget
203:02 - blueprint and go ahead and select user
203:05 - widget
203:06 - now we can start making our main menu so
203:09 - we can call this one BP underscore main
203:12 - menu
203:15 - open the widget
203:16 - and we can just have a canvas panel
203:18 - again
203:22 - add in a button
203:25 - we can Center it first of all
203:29 - so make it 0.5 and 0.5
203:32 - and set the positions to be zero
203:35 - we can increase the size a little bit
203:37 - maybe we could make that something like
203:38 - 350 by 100 Maybe
203:41 - maybe 450 again size is your personal
203:45 - preference
203:47 - and we can make the background black so
203:50 - background color change that to
203:52 - something darker
203:53 - maybe something like a dark gray
203:55 - we can go in and add in some text and we
203:58 - can call this one play
204:02 - now you can change the font as well by
204:04 - the way under font
204:06 - uh you can actually import your own
204:09 - custom fonts will not get into that but
204:11 - it's actually pretty simple to do it
204:13 - we'll try to get into that in the later
204:15 - part of the course but I'm not really
204:17 - sure if I will so maybe change that to
204:19 - regular increase the font size to 35
204:22 - let's say this should be good
204:24 - now head into your event graph and let's
204:26 - call this one play button
204:28 - so select the button and then under the
204:31 - details panel rename that
204:33 - now if you select the play button
204:37 - variable you should get a bunch of
204:39 - events including on clicked on pressed
204:41 - on release all of these are as they
204:44 - stand obviously maybe if you have a
204:46 - sound effect or something you could play
204:47 - it on on hovered or there's another way
204:50 - actually where you can play sound effect
204:51 - when you hover your mouse so over here
204:54 - if I just type in Hover
204:57 - I should be able to find Howard sound
204:59 - let's just play uh
205:04 - so
205:05 - maybe let's just play this I mean it
205:07 - doesn't make any sense but anyways
205:10 - and
205:12 - I think there is a clicked sound or a
205:14 - pla press sound I guess it's called
205:17 - so we can play press sound so
205:20 - click on button
205:22 - and what we can do is on click we can go
205:26 - ahead and open our map so we can type in
205:29 - open level
205:30 - and we can do by object reference
205:33 - so over here let's just select our level
205:36 - beginner course level and that should be
205:39 - good now if I go ahead and press play
205:43 - as you see nothing happens because we
205:45 - haven't created the widget yet now since
205:47 - this is a widget which is the only thing
205:51 - in this level you could simply go ahead
205:53 - and create the widget here on begin play
205:55 - so create widget
205:59 - create widget
206:01 - BP main menu add to viewport we don't
206:04 - really need to store it because we are
206:06 - not actually calling any functions
206:08 - so if I press play you can see it and
206:10 - when we hover over it you see you get
206:12 - the sound effect
206:13 - however one thing you would notice is if
206:15 - you actually have your focus on the
206:17 - window
206:18 - you can't see a mouse cursor so the way
206:20 - you do that is first of all get your
206:23 - player controller so type in get player
206:24 - controller this is a static function
206:27 - so in inside any actor basically you can
206:31 - get your player controller reference
206:33 - and from here there's actually a
206:35 - variable called set show mouse cursor so
206:37 - show mouse cursor is the variable
206:39 - set that to true and another thing which
206:42 - you can do actually is change the input
206:45 - mode to UI only so that it only focuses
206:49 - on this widget there is another option
206:51 - called game and UI only we'll use that
206:53 - set input mode to game and UI only
206:56 - grab in the player controller reference
207:00 - and that should be good so we can just
207:03 - reroute it double click on the PIN to
207:06 - reroute it
207:08 - and now if I go ahead and press play
207:11 - you see even when I focus it I can still
207:13 - see my mouse cursor now if I press play
207:16 - you see we transition to the level now
207:18 - we obviously spawned at 0 comma zero
207:21 - comma zero so that's the reason that
207:22 - happened
207:23 - now if you want to fix that you can go
207:27 - ahead and add in a player start where
207:29 - your default player will spawn so now if
207:32 - I head back into the main menu play it
207:34 - if I head in we will spawn where our
207:37 - player start was but one thing you'll
207:39 - notice is uh we still haven't actually
207:41 - got rid of the mouse focusing part so
207:44 - your mouse isn't behaving like how it
207:47 - should
207:48 - so what we can do is on begin play now
207:52 - we are in a main menu level
207:54 - head into our beginner course level
207:56 - generally you do it on your player
207:58 - controller so BP black controller and
208:01 - what you can do is you can set input
208:03 - mode
208:05 - game only
208:08 - and we can get a reference to self
208:12 - and you can also set show mouse cursor
208:14 - to false so set show mouse cursor make
208:17 - that false
208:19 - now if I go ahead and press play okay I
208:21 - mean that wasn't what I intended
208:25 - now
208:26 - head back into your main menu
208:28 - go ahead and press play now you see your
208:31 - mouse is going to behave normally
208:34 - so that's basically how you deal with it
208:35 - now you can do your normal gameplay
208:37 - stuff so that's how you would actually
208:39 - create
208:40 - you would actually interact with your
208:42 - actual levels and stuff your transition
208:45 - levels and stuff using widget blueprints
208:47 - so head back into UI main menu and if we
208:50 - take a look at our code it's really
208:52 - simple and a widget as well it's really
208:54 - simple
208:55 - so that's about it now let's say we
208:58 - wanted to have more than one option
209:00 - and let's say we wanted to layer them
209:02 - vertically so if you want to add
209:05 - multiple rows you can go ahead and use
209:07 - something known as a vertical box so if
209:09 - I right click on this type in wrap width
209:12 - and use a vertical box
209:14 - you can go ahead and get this now the
209:17 - vertical box will automatically use the
209:19 - same anchor as we used for the child
209:21 - but nonetheless just something which you
209:24 - can change
209:25 - the size y to something big Maybe
209:28 - and press Ctrl D to duplicate this
209:32 - button
209:34 - now over here I can type in exit let's
209:36 - say
209:37 - and again on clicked we can change that
209:40 - so play button one is not appropriate
209:43 - we'll change that to exit button
209:46 - so exit button
209:49 - and on clicked we can go ahead and
209:51 - execute console command and we can type
209:54 - in exit
209:57 - so that should be good to go and you'll
209:59 - notice one thing it's just taking up a
210:02 - fixed amount of space and it's not
210:03 - actually filling it properly so if you
210:05 - want to do that you can select both of
210:07 - these and select fill
210:09 - now let's say you wanted your play
210:11 - button to occupy more amount of space
210:13 - than exit so you can increase this uh
210:18 - what a text box which is available to
210:21 - you so if I hit 2
210:22 - and the exit button has one on this
210:25 - option basically they are occupying
210:28 - space in the ratio two is to one that's
210:30 - basically what it means so you don't
210:33 - want your place to exit obviously so
210:34 - you'd make the play button bigger so
210:36 - this is how you do it
210:38 - now if I press play
210:41 - now the same logic is copied over the
210:44 - reason why the sound is playing even for
210:45 - the exit button is because we copied
210:47 - over the code so that's why so all the
210:51 - sound effects as well is copied so as
210:53 - you can see press sound and hover sound
210:55 - are actually the same in both of these
210:58 - now if I press play I press exit we are
211:00 - going to quit the game if I press play
211:03 - We load into this level
211:06 - so that's pretty cool so that's about it
211:10 - for this part
211:11 - foreign
211:18 - talking about another feature which
211:20 - blueprint offers that is blueprint
211:23 - function libraries now let's say you
211:26 - wanted to have some functions which
211:29 - might be used in multiple places but are
211:32 - not relative to a certain object
211:34 - so in that case you would use a
211:36 - blueprint function Library so let me
211:39 - actually show you guys an example
211:41 - so head into blueprints and or maybe we
211:46 - could create another folder let's call
211:48 - this one function libraries
211:54 - open it up and over here right click
211:57 - head into Blueprints and
212:01 - select blueprint function Library
212:04 - and we can call this one my or our
212:08 - blueprint function Library
212:15 - now inside here you would notice that we
212:18 - actually have functions options to write
212:21 - functions
212:22 - so for example let's say we have
212:25 - something generic so for example let's
212:27 - say
212:28 - uh we have a vector and let's say we
212:31 - wanted to normalize it now obviously
212:33 - there is a normalized function already
212:34 - but I'm just taking an example now
212:37 - normalizing a vector is a general
212:39 - operation it's not relative to any
212:41 - object so we can type in
212:44 - normalize
212:47 - and for the input obviously we are going
212:49 - to take in a vector so take in a vector
212:52 - and we can type this one in maybe
212:56 - uh now once we have the vector we are
212:59 - going to first of all get the magnitude
213:02 - of this Vector the way you get magnitude
213:04 - of a vector in Blueprint is by typing in
213:07 - Vector length so get Vector length
213:11 - now this is this is the magnitude of the
213:14 - vector so we can divide this vector by
213:17 - the magnitude
213:18 - so that is going to normalize the vector
213:21 - for us
213:22 - and once we actually do that we can go
213:25 - ahead and return it
213:28 - so this is going to be the return value
213:31 - and obviously we'll make it a pure
213:33 - function now
213:36 - let's just call this one normalize
213:38 - underscore hours because I I think there
213:42 - is another function called normalize so
213:43 - just so that it's understandable for us
213:47 - now head back into any one of your
213:50 - blueprints let's say our level blueprint
213:52 - and over here if we just type in
213:55 - normalize
213:56 - so we already had a normalized function
213:59 - but I just took the example underscore
214:01 - RS you see we actually get our function
214:05 - and this is not relative to any object
214:07 - so you can call this pretty much
214:09 - Everywhere You Wish so this is basically
214:12 - our blueprint function Library you just
214:14 - go on creating functions
214:16 - [Music]
214:21 - so once that's all settled now what if
214:24 - you wanted to use some code or some
214:26 - assets created by somebody else there is
214:30 - actually a huge Marketplace called the
214:32 - unreal Marketplace and you can access it
214:35 - through the epic games launcher so if I
214:36 - head into my epic games launcher head
214:39 - into Marketplace under the Unreal Engine
214:41 - section you would see that you get a
214:44 - massive library of assets and there are
214:46 - a bunch of free ones as well like I I
214:49 - really mean a lot of free assets
214:52 - so what if you wanted to use them so
214:55 - that is where using plugins and other
214:58 - content packs comes in handy so how you
215:00 - do it is really simple actually so for
215:03 - example I know one which is very handy
215:05 - it's called low entry I believe
215:09 - oops low entry
215:12 - so I actually have it in my library so
215:15 - so it's by this publisher actually
215:18 - so low entry low entry standard Library
215:21 - this is the one which I'm using this is
215:24 - really useful so once you search it up
215:28 - and you can look it up in the
215:30 - marketplace and there are many Forums on
215:32 - Reddit and stuff talking about which
215:34 - plugins are good and stuff so you can go
215:38 - ahead and install it according to your
215:40 - needs so let's say I wanted some weapon
215:42 - models for prototyping you could just
215:44 - type in weapon and you're going to get
215:46 - weapon packs the way you install it is
215:48 - by clicking on this install to engine
215:50 - button I've already done that so that's
215:52 - why it shows that I can't
215:54 - now over here in my plugins panel now I
215:57 - should be able to access it over here
215:59 - under installed or if you just search it
216:02 - up you would be able to find it and you
216:04 - can enable it so low entry extended
216:07 - standard library and I need to restart
216:09 - the editor so let me go ahead and do
216:11 - that
216:12 - now that it's done I can go ahead and
216:14 - use the content in the plugin now how do
216:17 - I know what content is there there will
216:19 - actually be a documentation and source
216:22 - code and stuff available so you could
216:25 - just look it up so there will be a place
216:27 - where the documentation is given so you
216:30 - have a preview over here then you also
216:32 - have access to the source code
216:34 - and a bunch of stuff you could also take
216:37 - a look at this over here so maybe let's
216:40 - say we wanted to use uh some function
216:44 - here so for example I type in is debug
216:48 - build let's say I wanted to see if I am
216:51 - currently in a debug build
216:52 - so I can type in is debug build whoops
216:56 - debug build and as you can see I can use
216:59 - the function now this was a plugin which
217:02 - has to be installed to the engine
217:04 - however we will also look at other types
217:08 - of plugins such as let's say I type in
217:10 - weapon for example I needed a weapon
217:12 - pack
217:13 - so I actually have some in the library
217:15 - you could find a free one so you can
217:17 - head under free and you can look for it
217:19 - but again now in my library I actually
217:22 - have some weapon packs if I want to
217:24 - install those it's actually really
217:26 - simple so FPS weapons bundle this is one
217:29 - thing which I have so I can go ahead and
217:31 - add this to a project and it does say
217:34 - none of my projects are compatible but
217:37 - plugins like these actually it doesn't
217:39 - really matter if you are using a later
217:41 - version then what is supported as long
217:45 - as you're using a later version than
217:47 - that it should be totally good to go so
217:49 - click on show all projects and you can
217:50 - go ahead and select this and you can
217:53 - change the version to the latest
217:54 - available one and you can go ahead and
217:56 - add it now just another thing in case
217:59 - you don't have a plug-in of this sort so
218:03 - the one which we saw last time
218:07 - so let's search for low entry once again
218:13 - so let's say we have a plugin of this
218:15 - sort
218:16 - which you install to the engine but you
218:19 - actually don't have the appropriate
218:21 - version
218:22 - so the way would actually go about
218:24 - upgrading your version is actually
218:26 - really simple people haven't made any
218:29 - tutorials on this I don't see any Forum
218:31 - or anything talking about that either so
218:33 - basically you just come into your Unreal
218:37 - Engine installation directory so I go to
218:39 - program files Unreal Engine this is
218:41 - where I have it
218:42 - and over here under engine
218:45 - plugins
218:46 - and the marketplace ones will be in the
218:49 - marketplace
218:50 - and for example I go to low entry
218:52 - extended standard Library I can right
218:54 - click on this U plugin file and I can
218:57 - actually open it with any text editor or
218:59 - I can open it with something like vs
219:01 - code so I'll open it with Visual Studio
219:04 - inside the U plugin file you should see
219:06 - something a little like this so you
219:11 - don't have to worry about any of these
219:13 - things the only thing is the engine
219:15 - version let's say it was there for 4.27
219:18 - and you are using 5 and if you want to
219:20 - make it compatible and let's say you're
219:22 - getting build errors you could just go
219:24 - ahead and change 4.27 to 5.0.0 so let's
219:27 - say it was
219:29 - 4.27.0 by default so you can go ahead
219:32 - and change it to 5.0.0
219:35 - whoops y dot or dot O So stuff like that
219:39 - [Music]
219:44 - all right so that's about it there isn't
219:46 - really that much depth to plugins I mean
219:49 - I will talk about creating plugins and
219:51 - stuff integrating third-party libraries
219:53 - a bit later on in the advanced part of
219:55 - this course but now let's go ahead and
219:58 - actually talk about a recently release
220:01 - tool and which is quite handy in my
220:04 - opinion and those are the modeling tools
220:06 - first of all in your plugin section make
220:09 - sure your plugin is enabled so make sure
220:11 - modeling tools editor mode plugin is
220:13 - enabled and if you don't want to
220:16 - separately drag your model in the level
220:18 - and edit it then you can press this as
220:21 - well
220:22 - ah now if you check your content browser
220:25 - uh make sure you have some sort of a 3D
220:28 - model make sure you have some sort of a
220:30 - static mesh
220:31 - so you can import that from your 3D
220:33 - software
220:34 - so I just got one in from the engine
220:37 - content so what I did was basically
220:39 - actually I'll just go ahead and delete
220:40 - that and redo it
220:42 - so delete that
220:45 - and delete this folder as well
220:47 - save everything now I just search for SM
220:51 - underscore usually it's a convention to
220:53 - name it SM underscore for static mesh
220:56 - under content I just went ahead and
220:58 - created a new folder
221:00 - so new folder and I called it models
221:04 - open it up and just paste it in uh just
221:07 - using the one from the engine content
221:09 - now you can drag it in the level and
221:12 - start editing it by heading into this
221:14 - tab right here and heading into modeling
221:17 - so we have a bunch of options the first
221:19 - few are for creating objects but some of
221:23 - the useful ones are for example moving
221:25 - the pivot so let's say you didn't want
221:28 - this to rotate along the center you can
221:30 - go ahead and type pivot and you can move
221:32 - this point over here now if I rotate it
221:35 - it's going to rotate along this point
221:37 - and these changes are actually applied
221:39 - to this so
221:41 - even if I just drag in another ball
221:44 - these changes will be applied to that so
221:46 - just be careful while using them of
221:48 - course you can undo them at any point
221:50 - so just save that and sculpt is
221:53 - basically to deform the shape so
221:54 - something like this
221:56 - and again you can use shift the same
221:59 - principle works over here as well as we
222:01 - did with the landscape editing so stuff
222:04 - like that then descalp does a similar
222:06 - thing just works a little bit
222:08 - differently so I can just drag it like
222:10 - this
222:11 - I'm not sure what I did there but yeah
222:14 - so I'm not really here to talk about the
222:16 - tools in detail but just to give you an
222:18 - overview of how to actually use it so
222:21 - you could experiment around with all of
222:23 - these
222:24 - so if you type in accept so now we have
222:27 - the ship obviously this is it just
222:30 - messed up with the UV map and the
222:31 - materials and stuff but anyways that was
222:33 - not our point
222:35 - now a couple of useful things first of
222:38 - all creating shapes so if I just type in
222:40 - stair over here
222:42 - and if I head into this and I can
222:46 - actually make it a curved staircase I
222:49 - can actually increase the number of
222:50 - stairs I can decrease the step height so
222:53 - I can increase the curve angle for
222:55 - example then I can decrease the step
222:57 - height so I can make it something like
222:59 - 10
223:00 - maybe place that and type in complete
223:02 - now if I go ahead and press play
223:06 - you would be able to see that I can
223:08 - actually use my stairs
223:12 - so that works well
223:15 - so stuff like that and now shapes are
223:19 - pretty obvious obviously just create a
223:21 - box do stuff with that and now you might
223:24 - be wondering where these are stored over
223:27 - here just check uh what is selected
223:30 - under this under the new asset location
223:32 - if it is selected to Global in your
223:35 - content folder folder there should be a
223:37 - underscore generated folder in my case
223:40 - it was set to World relative so wherever
223:42 - you have your map over here this you
223:45 - should see a underscore generated folder
223:47 - and if you open it up you should be able
223:50 - to see your static meshes
223:53 - so for example we have this stair which
223:55 - we just created and we can drag this in
223:58 - so this is going to come in really
224:00 - really handy for many people in my
224:03 - opinion
224:04 - now not only that it provides us with
224:08 - several other cool features I'll just
224:10 - showcase one of them actually
224:11 - so if you head into your modeling tools
224:14 - once again so I'll just close it and
224:17 - open it up again so I'll open up the
224:19 - modeling tools and if I type in poly
224:22 - extrude you can actually draw a shape so
224:25 - if I just click somewhere drag a point
224:29 - do something like this
224:32 - and if I join them
224:35 - now I would be able to create something
224:37 - like this so let's say I wanted to
224:39 - create a castle wall or something
224:41 - you could do that and the good part
224:43 - about this is this is UV map by default
224:46 - you don't have to actually you remap it
224:48 - the UVS are pretty good so you can
224:51 - directly go ahead and apply a texture
224:53 - and it is going to look decent generally
224:55 - if you create a weird shape like this in
224:57 - a 3D modeling software you separately
224:59 - have to go through the effort of UV
225:01 - mapping it so that the textures don't
225:03 - look distorted but in this case you are
225:06 - good to go
225:07 - so that's about it for the modeling
225:09 - tools so you can mess around with those
225:12 - these are really you know specific to
225:15 - what you're doing
225:16 - so according to what you would need you
225:18 - would use the appropriate tools but it
225:20 - is there now even over here you can
225:22 - change the Pivot Point let's say for
225:24 - example so I'll just show you guys once
225:27 - again so modeling
225:30 - if I select pivot
225:32 - and if I
225:36 - move this over and press accept you
225:39 - would see that the pivot point mode over
225:40 - there so that's about it so let's move
225:43 - on to the next part
225:45 - [Music]
225:50 - so what I'm going to be talking about
225:52 - next is kind of the basics of what we
225:54 - did till now so basically we worked with
225:57 - these models over here basically these
226:00 - are called Static meshes so any and all
226:04 - 3D models which you get in the engine
226:06 - without any sort of animations or
226:09 - anything those will generally be static
226:11 - meshes
226:12 - uh any mesh with some sort of Animation
226:15 - is going to be a skeletal mesh basically
226:17 - so stuff like characters gun models and
226:20 - those are going to be your skeletal
226:22 - meshes anything which simulate physics
226:26 - or which does not have animations so for
226:29 - example the staircase may be a weapon
226:32 - model in a pickup blueprint stuff like
226:35 - that are going to be static meshes
226:37 - so they are recognized by a light blue
226:40 - color in the content browser so if I
226:42 - head into models you see it has a light
226:45 - blue color coding and this indicates
226:47 - that it's a static mesh
226:49 - now we will dive into skeletal meshes a
226:54 - little more in depth later on but for
226:56 - now I'll just head into static meshes
226:58 - there are a couple of things which I
227:00 - would like to cover first one is
227:01 - enabling nanite now if I head into
227:04 - wireframe mode
227:06 - so now I can actually see
227:10 - all of the vertices in space
227:13 - foreign
227:17 - now say I have many of the Spheres and
227:20 - in this case I have more than six
227:24 - thousand so six thousand four hundred
227:25 - and eighty so your first question over
227:28 - here is how's the performance still this
227:31 - great
227:31 - that is thanks to nanite so if you right
227:35 - click on your model and enable nanite
227:37 - over here if you right click and click
227:39 - on enable you will enable nanite now if
227:41 - I go ahead and disable this you would
227:43 - see that the performance dips
227:45 - immediately
227:46 - so that's one thing about nanite so as
227:50 - you can see it's really not playable at
227:52 - this point now if I mean obviously this
227:55 - is highly unrealistic and moreover it
227:57 - will depend more on your computer as
227:59 - well so if I go ahead and enable nanite
228:01 - now and if I press play as you can see
228:04 - even with so many spheres right in front
228:05 - of me
228:06 - it's absolutely not affecting
228:08 - performance now we are not here to talk
228:10 - about the actual technology involved in
228:12 - nanite so that's the reason I'm not
228:13 - telling anything else but this is
228:16 - basically it currently in 5.0.3 there
228:19 - are a few limitations for example let's
228:21 - say I wanted to use this on a tree you
228:23 - probably cannot because trees contain
228:26 - leaves and leaves used masked materials
228:29 - and those are not yet supported on
228:31 - nanite and it but they will be supported
228:33 - in 5.1 so very very soon you would be
228:37 - able to use them
228:38 - so that's about it there are few
228:40 - material features which you can't use
228:42 - and we will talk about materials so
228:44 - stuff like dithering and stuff you will
228:46 - have to just disable those notes if you
228:48 - want to use nanite but for most objects
228:51 - or stuff like walls or maybe if you have
228:54 - an insane level something like this
228:56 - nanite is going to come in handy so
228:59 - that's about nanite
229:01 - [Music]
229:06 - by now one thing that we would have
229:08 - probably noticed is that any and all
229:10 - objects in the scene actually have some
229:13 - sort of a material on them so for
229:16 - example this has some neon blue texture
229:19 - on it and it seems to be glowing and
229:22 - this box right here has some sort of
229:24 - checkerboard and same with the ground so
229:28 - what's up with that so basically those
229:30 - are materials and that's what gives the
229:33 - color and all the other roughness
229:36 - related properties of a given surface
229:39 - now let's actually go about seeing how
229:42 - to create a material and apply it on
229:43 - objects so let's just use a cube for
229:47 - example in order to demonstrate using
229:49 - materials so let me just grab in a cube
229:52 - and I'll just place it in the scene
229:54 - now this has a material basic shape
229:57 - material you can actually explore this
229:58 - by clicking on this search icon over
230:00 - here
230:01 - so we'll actually go to the directory
230:04 - where the material is stored but in our
230:06 - case let's create a new folder called
230:08 - materials
230:11 - and let's go ahead and open it up
230:14 - right click and create a new material or
230:18 - you can head into materials and create a
230:20 - new material here now the most important
230:22 - ones are just materials and material
230:24 - instances the rest are just stuff which
230:28 - you might need in specific circumstances
230:30 - so we'll take a look at material and
230:32 - let's call this one our material now
230:35 - applying a material on a surface is
230:37 - actually really simple now we aren't
230:39 - going to be dealing with multiple
230:41 - materials on a single object in this
230:44 - part of the course we will try to deal
230:46 - with it later on but for now we won't be
230:48 - doing anything so by default you get
230:50 - this Checker material so I'll just drag
230:52 - this in
230:53 - and you can in order to apply it you
230:55 - just drag it basically on the surface
230:58 - that's how you do it or if you want to
231:00 - apply it to a static mesh in general so
231:04 - let's say I wanted all of the uh okay
231:07 - whatever this object is so let's say I
231:09 - wanted all of this object to have our
231:12 - material so what I do is I head into the
231:15 - static mesh and over here I'm going to
231:17 - select our material so
231:19 - let me go back
231:21 - so all content materials are material
231:25 - you can select that and you can click on
231:27 - this Arrow icon which will use our
231:29 - material so now it's actually using our
231:32 - material so we haven't seen any change
231:34 - because
231:35 - we don't have anything set up in the
231:37 - material but the way you actually start
231:41 - working with this is by using these
231:44 - nodes so this pin right here is as the
231:47 - name suggests the base color now how do
231:50 - you define a base color so the most
231:52 - basic node over here is going to be a
231:55 - constant
231:56 - so whoops I press C on the keyboard I'm
231:58 - supposed to press 1 on the keyboard and
232:00 - left click and you see you get this node
232:03 - here which allows you to enter value now
232:06 - generally you would enter a value
232:07 - between 0 and 1 but in some cases you
232:10 - would enter higher and lower values so
232:12 - in this case if I just plug this in the
232:15 - base color and you can see it's
232:16 - compatible
232:18 - so you would see that our material is
232:21 - fully black
232:23 - now
232:24 - it's just a fully black material what if
232:27 - I increase this a bit
232:32 - now save that again as you can see it
232:35 - became a lighter shade of gray
232:38 - so one is going to be white so this is
232:40 - basically a gradient 0 is black and one
232:43 - is white
232:44 - what if you wanted to give a color so
232:47 - you'd hold three on your keyboard and
232:49 - left click then you'd get something
232:51 - known as a constant three Vector this is
232:54 - basically our r g and B value so red
232:57 - green and blue
232:58 - so you can go ahead if you wanted red
233:00 - you could do 100
233:03 - and as you can see
233:05 - you get a red color material and it's
233:07 - applied to all the objects which are
233:09 - using our material so that's about it
233:12 - for base color now if you want to bring
233:14 - in any textures I recommend this website
233:17 - called cc0 textures
233:19 - so open it up now it's renamed to
233:22 - ambient CG keep forgetting about that so
233:26 - if you just head in and you can just
233:28 - grab in any texture
233:30 - so just I'll just grab in the lowest
233:32 - resolution one
233:34 - so I can open it up in my folder over
233:37 - there
233:39 - and over here I'll just drag it into
233:42 - images for now I just have it set up
233:44 - like this
233:45 - so I'm just going to extract it
233:49 - and over here you see you get a bunch of
233:52 - textures if you want to import it in the
233:54 - engine it's really simple actually to
233:57 - import any asset B textures models or
233:59 - whatever so we'll create a new folder
234:01 - and we'll import it so textures
234:04 - open it up and if I go ahead and drag
234:08 - this for example so
234:10 - I can just select all of these
234:14 - and I can go ahead and drag this in my
234:17 - content browser
234:19 - and we can go ahead and save it
234:21 - now if I want to apply this texture to
234:23 - this material now first of all we'll see
234:26 - which one is the base color sometimes
234:28 - these textures are labeled as Albedo but
234:31 - Albedo is basically a base color without
234:34 - any sort of uh Shadow related
234:36 - information that's basically what it
234:38 - means without any other sort of
234:40 - detailing it's just the raw color
234:45 - so if I drag this in the base color I
234:48 - can do that now you could do this as
234:51 - well
234:52 - totally fine
234:54 - so this is how you would bring in a
234:56 - texture now if I go ahead and look into
234:59 - my level you see we have this wood
235:01 - texture on our little wall here now what
235:04 - if I wanted to tile this texture a
235:08 - little better now let's say I wanted to
235:10 - make this bigger or smaller you'd use
235:12 - something known as a texture coordinate
235:14 - so you type in text chord and you're
235:17 - gonna see
235:18 - texture coordinate plug that into the
235:21 - UVs
235:22 - and now let's say I press 0.1 your
235:25 - texture will now be scaled 10 times you
235:27 - and we are basically like your X and Y
235:30 - to be very vague now we zoomed in way
235:33 - too much so let's let's make two now so
235:36 - now you see it's going to be more tiled
235:39 - so now if you would see
235:42 - you would have a more tiled material so
235:45 - if I make this three for example
235:48 - and if I go ahead and save this you
235:52 - would see that it'll be even more tiled
235:54 - so I can make this 3.5 I can increase
235:57 - the value and it's going to be more
235:59 - tiled so I can click apply save
236:03 - and I should be able to see there are
236:05 - more number of Tricks now I'll I'll just
236:07 - set this to one once again
236:09 - and save that and as you can see it's
236:11 - applied to our level now this may be
236:15 - fine but what if you wanted more details
236:18 - let's say you wanted to make this very
236:20 - glossy so in that case you can use the
236:23 - roughness node now the roughness is
236:26 - basically a zero to one value so you can
236:28 - again use a constant if you want so 0 is
236:31 - going to be fully reflective
236:34 - now you could use the specular Channel
236:36 - as well but most of the times you will
236:38 - only use roughness
236:40 - it's very rare that you'll actually mess
236:42 - with the specular channel so now if I go
236:46 - ahead and apply this
236:47 - you'd see that it's very glossy
236:51 - and if that's not really that clear drag
236:53 - in a point light
236:55 - just move this and as you can see it's
236:57 - reflecting everything over there you see
236:59 - the little point over there so that's
237:02 - showing roughness 0
237:04 - now if I change this to 1 for example
237:07 - and if I hit save
237:09 - you'd see that it's not reflecting the
237:12 - light at all
237:13 - so that's the use of the roughness
237:16 - Channel now obviously this is some sort
237:20 - of a wood floor texture so obviously it
237:24 - will be depending on the grains of
237:25 - what's there over there so
237:28 - how you would set it up is by using a
237:31 - roughness map now generally in in
237:33 - websites such as cc0 or ambient CG now
237:36 - as it's called you would get something
237:38 - known as a roughness map basically the
237:41 - brighter parts of the image are where
237:43 - the light is reflected more the darker
237:46 - parts of the image are where light is
237:48 - not reflected so let's say there is a
237:51 - fully black area here so that's where
237:54 - all the light is going to be reflected
237:56 - so I might have told it the other way
237:58 - around basically the more bright the
238:01 - color the more the roughness
238:04 - now if I drag this in
238:06 - use this in the roughness Channel
238:09 - as you can see this gives us a little
238:11 - more definition
238:12 - now as you can see at the borders over
238:15 - there you can clearly see that the
238:17 - roughness map is doing something
238:19 - so this is about roughness
238:22 - similarly normal is basically uh your
238:27 - depth so as you can see this texture
238:30 - although it has a bit of roughness it
238:32 - looks completely flat
238:33 - now if I go ahead and add in the normal
238:36 - map so if I just snap this to the left
238:38 - and bring in my
238:41 - unreal editor on the right
238:43 - and if I go ahead and apply my normal
238:46 - map here
238:48 - and if I hit apply
238:51 - as you can see you would see a little
238:53 - bit of a depth over there
238:56 - now if you can't really see it
238:58 - that's probably because this is pretty
239:00 - subtle so you can use something known as
239:03 - a multiply basically it's just going to
239:06 - multiply the value of each pixel in this
239:08 - texture so multiply this you can use a
239:12 - constant or you can set the value over
239:14 - here itself in the multiply node so if I
239:15 - type in 100 let's say
239:19 - for example
239:21 - so now you would be able to see a little
239:23 - bit of the depth over there
239:25 - but since this sort of a texture isn't
239:28 - really containing much of depth so you
239:31 - won't really see it
239:32 - there are other ways to increase the
239:34 - depth of a normal map but that's not the
239:36 - point of this tutorial so basically
239:38 - normal map is for your depth if you are
239:41 - into PBR rendering you'll probably
239:42 - already know all this stuff ambient
239:45 - occlusion is basically like your depth
239:50 - in your crevices and stuff it's kind of
239:54 - hard to explain it there's actually a
239:55 - comment here so simulate the self
239:57 - shadowing that happens within crevices
240:00 - of a surface basically that's what
240:02 - ambient occlusion is so in stuff like
240:04 - trees and rocks ambient occlusion is
240:07 - something which would play a major role
240:09 - on this sort of a texture it's really
240:12 - not going to do much
240:15 - so this is about the basics of materials
240:18 - now obviously this is completely wrong
240:22 - because we only have a texture
240:24 - coordinate for that one texture so make
240:26 - sure you plug everything in
240:29 - so just plug everything in
240:31 - now if you go ahead and apply and save
240:34 - that
240:35 - now you'd be able to see that it's
240:37 - applied properly
240:39 - this had a subtle effect from the start
240:42 - itself so that's the reason you couldn't
240:44 - really see anything wrong with it
240:48 - so we created a basic material here
240:52 - now for any of these you can actually
240:54 - use your constants but most of the time
240:57 - except base color you won't be using
240:59 - constants you will be using textures
241:02 - now
241:03 - that's the very basics of materials
241:06 - there are a lot you can do let's say you
241:08 - wanted to make this thing glow so let me
241:10 - just remove all of this stuff
241:13 - let's say I just wanted a glowing neon
241:15 - green color so let me just get a
241:17 - constant pre vector
241:20 - so the same right click search menu
241:22 - exists in the material editor as well
241:25 - drag that in the base color
241:27 - and what you want to do is first you can
241:30 - grab in a constant and maybe let's say
241:32 - you have 10 this has to be a value
241:34 - greater than 1.
241:36 - so let's say I have 2 for example
241:39 - so now you'd see that it's completely
241:41 - glowing white in color
241:44 - now if you wanted it to Glow in this
241:46 - color itself what you do is you would
241:49 - actually get this and you would multiply
241:51 - this by 2.
241:53 - so you would multiply this by two
241:56 - now if I go ahead and press save you see
241:59 - it's glowing in
242:00 - sort of green color
242:03 - so this is basically called an emissive
242:06 - material because it emits light and it's
242:10 - pretty cool to look at
242:12 - by adjusting the value you multiplied
242:15 - with you adjust the intensity now one
242:18 - problem which you might have noticed
242:20 - here is every time we want to change a
242:22 - value so for example we want to make
242:26 - this less bright let's say 1.5
242:29 - now every time we have to apply and save
242:32 - this what if we could dynamically change
242:34 - this that's where material instances
242:37 - come in is basically like your derived
242:39 - class in your C plus plus inheritance
242:42 - but to put that in short basically you
242:47 - create another asset known as a material
242:49 - instance which is subordinate to this
242:53 - material and you can edit all the
242:55 - parameters in it so I can right click on
242:58 - our material and create the material
243:00 - instance and let's just keep it as the
243:04 - engine has suggested now instead of
243:06 - applying our material we'll apply our
243:08 - material instance nothing has changed
243:11 - obviously however if I head into our
243:15 - material instance now I can change the
243:17 - parameters over here the first thing you
243:19 - might notice is there is nothing to
243:21 - change
243:22 - so how do you do that basically you
243:25 - would have to head in here right click
243:28 - and convert it to a parameter
243:30 - so any constant or any texture which you
243:33 - convert to a parameter will be a value
243:36 - which you can change so this is going to
243:38 - be called brightness let's say
243:40 - brightness
243:42 - and this one is going to be called color
243:44 - so right click convert to parameter and
243:46 - call this one color
243:47 - now apply and save it
243:51 - now if I open up my instance
243:53 - you would see that you get two
243:55 - parameters and now I can edit them so
243:57 - now if I press 2 you see the changes are
244:00 - live so zero works one
244:03 - two
244:05 - not point three
244:08 - so I can adjust my values just like this
244:11 - and I can change the color as well and
244:14 - it's updating dynamically
244:16 - so for the most part you will be using
244:20 - material instances for this purpose
244:22 - itself
244:23 - so these were the basics of materials
244:25 - now you could Tinker around a bit look
244:28 - into the documentation and create
244:30 - something yourself
244:31 - [Music]
244:35 - now we haven't talked too much about the
244:38 - other type of mesh that is the skeletal
244:41 - mesh so let's talk about that now now if
244:44 - I go ahead and press play actually you'd
244:46 - see that we have a character over here
244:49 - which is moving around
244:51 - now the animations aren't actually
244:54 - complete if you were to notice he's just
244:56 - sliding around he's not actually doing
244:58 - anything
244:59 - now how do you define the logic where
245:02 - you know if you are moving above a
245:04 - certain speed
245:05 - maybe let's say you start moving you
245:08 - want to play an animation how do you
245:09 - define that so that is where you use an
245:12 - animation blueprint and that is what I
245:14 - was searching at the start of this
245:16 - course when we actually did the
245:17 - character so head into your character
245:20 - over here one thing that you would
245:23 - notice is if I just head into mesh and
245:26 - if I just click on the search icon on
245:28 - the animation blueprint it actually
245:30 - takes us to a folder inside the engine
245:32 - directory where there is an animation
245:34 - blueprint which actually
245:38 - does something over here
245:40 - so this is how the animations are
245:43 - actually controlled and we'll create one
245:45 - from scratch we can reuse these
245:47 - animations no problem
245:49 - so head into your content folder not the
245:51 - engine so content
245:54 - and for now we can just head into our
245:58 - models folder and over here let's assume
246:01 - we had our character here so let's call
246:03 - that tutorial character because I guess
246:06 - that's what it was called tutorial TPP I
246:08 - guess
246:09 - I'll just open it up right click create
246:12 - under animation create an animation
246:14 - blueprint and select the skeleton now
246:17 - now I'm assuming you have a little bit
246:19 - of knowledge of what's a skeleton what
246:22 - are bones and stuff so at least that
246:24 - much would be required if you want to
246:26 - understand this
246:27 - basically know that each joint which you
246:31 - have each uh point which can hinge
246:34 - basically is going to be our bone
246:38 - so I am not clear about that if I head
246:41 - into the actual skeletal mesh
246:44 - so if I head into this one so I'm not
246:46 - sure what it's called and this one let's
246:48 - leave it at new and MBP
246:50 - so let's PPP I guess
246:53 - so this is the skeletal mesh now if I
246:56 - were to just click on this
246:58 - and if I head into the skeleton view
247:02 - you'd see for example this is going to
247:05 - be your index so if I rotate it you can
247:09 - see that we can actually control it
247:12 - index 2 is going to be the further part
247:14 - of the finger stuff like that I'm not
247:17 - actually applying these changes so
247:18 - that's totally okay
247:20 - and for example if I take the pelvis I
247:23 - can go ahead and rotate the entire thing
247:25 - because that's the root that's the
247:27 - reason it's happening if I take spine is
247:30 - going to rotate the back
247:32 - stuff like that let's say you wanted to
247:35 - rotate it a little something like this
247:38 - so you could make him Bend forward stuff
247:41 - like that
247:42 - so this is a skeletal mesh and output
247:46 - pause over here in the anim graph as
247:48 - soon as you open the animation blueprint
247:50 - this is what determines what pose here
247:53 - and by default it'll just take a t-pose
247:55 - or whatever pose it was in when you
247:56 - imported the model so let's apply our
247:59 - animation blueprint to a character so
248:01 - head into your character select the mesh
248:03 - and for the animation blueprint let's
248:06 - select new nmbp or whatever that was
248:09 - called so new anim blueprint
248:12 - so as you can see we are stuck in a
248:14 - t-pose right now
248:17 - and let's start applying animations
248:19 - now in order to add an animation the
248:22 - most basic way you could do it is you
248:24 - can simply drag in this animation
248:27 - and you can play it so this is going to
248:30 - be
248:31 - the idle animation
248:33 - and these are animations which the
248:35 - engine has provided so I haven't really
248:37 - done anything here so if you have your
248:41 - own character you would have your own
248:42 - animations but as you can see there is
248:44 - really no logic that you can Define over
248:46 - here
248:47 - so the way you do that
248:49 - is by first of all we can start by
248:52 - creating a state machine this is the
248:54 - most basic thing you can do in an anime
248:56 - blueprint so basically you can use your
248:59 - variables over here
249:01 - to determine Logic on how to change
249:04 - between animations let me show you with
249:07 - an example so we'll just leave it at New
249:09 - State machine for now or we can call
249:11 - this one uh walk run Maybe
249:15 - idle walk run let's say
249:20 - just name it appropriately and now if I
249:23 - compile I'll be in a t pose again
249:25 - now entry is where you would start so
249:28 - obviously if nothing's really happening
249:30 - you you'd want to idle so head into
249:33 - tutorial Idol if you were to notice it
249:36 - just outputs the animation because this
249:39 - is something like your return node
249:40 - basically
249:41 - head back into your ideal walk run State
249:43 - machine now if I compile
249:46 - as you would see
249:48 - it's playing behind the animation and if
249:50 - I press play actually this is going to
249:52 - work
249:53 - now we want another state so right click
249:56 - add State and this one is going to be
249:58 - called walk slash run
250:03 - now
250:05 - this is a shortcut way to do it like I'm
250:08 - not doing a separate Walk and Run face I
250:11 - will do a separate Walk and Run state
250:13 - after I do this
250:15 - so we want to be able to transition from
250:17 - idle to walk run so drag in an arrow
250:20 - and when we stop we actually want to be
250:23 - able to go back as well and I will show
250:26 - you what I mean by that now if I head
250:27 - into walk run
250:29 - and if I drag this animation
250:32 - you would see that he's not actually
250:35 - heading into walk run
250:39 - so what you can do is you can just set
250:40 - this to true for example
250:43 - and you would see that he will be in
250:46 - this walk run state
250:47 - so what this basically is is if this
250:50 - Boolean is true
250:52 - the character will be able to transition
250:55 - from this animation to this basically
250:58 - so how do you do that we can actually
251:01 - set uh set up some logic here
251:04 - so we can say is moving for example
251:07 - this is not how you do it I'm just
251:09 - showing you guys the basics so if he is
251:12 - moving we want to transition to the
251:15 - run face
251:17 - so idle walk run we have that
251:20 - now in the event graph we'll actually
251:22 - set up the logic to get is moving
251:25 - because remember we only have the
251:27 - variable but we are not actually setting
251:29 - the value so every time the animation
251:32 - updates so that's going to be every
251:33 - frame what we can do is we can try get
251:37 - Pawn owner basically that's going to be
251:39 - our character reference
251:41 - and we can cast it to our uh I don't
251:46 - know what it was called BP character I
251:48 - guess
251:49 - cast it to that don't do a cast on
251:51 - update actually you can actually uh do
251:54 - it on I guess it's called start
252:00 - uh there's an equivalent of begin play
252:02 - actually
252:04 - event blueprint begin play so on this
252:07 - node you can actually cast it and you
252:09 - can store a reference and use that don't
252:11 - cast to it every frame it's not
252:12 - efficient
252:14 - so you can promote that to a variable
252:16 - and call this one character reference so
252:19 - character
252:22 - reference
252:24 - and once we have that stored what we can
252:27 - do is we can use that if this is valid
252:30 - of course so convert to validated get if
252:33 - our character reference is valid uh what
252:36 - we'll do is we will get the speed
252:40 - so how you get the speed is by getting
252:43 - the velocity so velocity
252:46 - get velocity and we are going to get the
252:50 - vector length
252:52 - and if this Vector length is greater
252:56 - than zero
252:58 - it means we are moving
253:00 - so now if I compile you see his idle but
253:03 - now if I press play
253:04 - if I start moving you see the animation
253:07 - triggers but now he's not going back
253:10 - and that is where the transition comes
253:12 - in we have set up the logic to go from
253:14 - idle to walk run but the engine doesn't
253:16 - know when to come back so a very simple
253:19 - thing you can do is put this back and if
253:22 - he is not moving so you can type in an
253:25 - exclamation so if he is not moving
253:28 - then we can go ahead and transition back
253:31 - now if I press play
253:33 - as you can see it's working just fine
253:37 - now there are only two animations here
253:39 - but what if you wanted to blend between
253:41 - them what if you wanted a walk face
253:43 - let's say
253:45 - so the way you do it is by using a blend
253:47 - space
253:48 - so what a blend space is is basically
253:51 - transitioning between two animations and
253:54 - I'll just show that I'm not really going
253:56 - to talk too much in depth about
253:57 - animations and stuff but I I guess you
254:00 - you guys kind of get the basic idea
254:02 - let's say you had like a jumping
254:04 - animation so what you do is you'd have
254:07 - another Boolean for uh the jump State
254:10 - and in this state machine here you'd
254:12 - create a new state and call this one
254:14 - jumping
254:15 - and then you would transition from this
254:19 - and you would go back stuff like that
254:20 - that's basically how you do it
254:23 - uh now if we wanted to set up our blend
254:27 - space as I told you guys so head into
254:29 - your models TP tutorial TPP
254:33 - and let's just right click animation and
254:36 - let's create a blend space
254:39 - so now we can select a skeleton and
254:41 - we'll call this one walk run for example
254:43 - so walk run
254:47 - if you have a separate walking animation
254:49 - you can inject it in
254:51 - but for now we won't
254:53 - now in the access settings here this is
254:56 - what you will actually be using so your
254:59 - vertical axis is like your speed
255:02 - basically I mean it's a convention you
255:05 - can interchangeably use this but you can
255:07 - use the vertical axis as speed so
255:10 - basically you see the value of 0 to 100
255:12 - so that's what it is so we can type in
255:14 - speed
255:15 - because we can use this name later on
255:18 - and for the horizontal axis we can call
255:21 - this One Direction
255:23 - and it's going to be from minus 180 to
255:26 - Plus 180.
255:28 - over here for Speed we can go 0 to
255:31 - whatever maximum speed by default at 600
255:33 - so we'll go go with that
255:35 - and we don't have sideways animations
255:37 - otherwise on the left here you can place
255:40 - your sideways animations I'll just show
255:43 - you with these ones so obviously when
255:45 - your speed and direction is zero you
255:48 - would be idling
255:49 - and walk forward is going to be over
255:52 - here
255:52 - now if I hold down shift and if I walk
255:58 - through this
256:00 - so whoops
256:04 - so I might just leave that over there so
256:06 - at 0 and 0.
256:10 - and hold Ctrl actually hold Ctrl
256:14 - and if you notice you're transitioning
256:17 - between the animation so if I play
256:20 - as you see now if you're walking slowly
256:23 - so let's say I leave it at here so when
256:26 - my speed is 373 and my direction is
256:30 - whatever that is this is how the
256:31 - animation is going to play
256:34 - now if you want this to change a little
256:36 - bit you can actually uh increase or
256:41 - decrease the values over here
256:43 - and smoothing time is basically for your
256:46 - transition time so how long it will take
256:48 - to transition from one animation to the
256:50 - other generally I just leave it at zero
256:52 - I've had no issues honestly
256:54 - now in our animation blueprint instead
256:56 - of this we can use our walk around blend
256:58 - space
257:00 - all right you can connect this blend
257:03 - space to the output now we would see
257:05 - that you have to provide the direction
257:07 - and speed and doing that is actually
257:10 - pretty simple so head into your event
257:11 - graph and what you basically do is you
257:15 - grab your character reference over here
257:17 - and from this we can actually get the
257:20 - velocity
257:22 - so velocity
257:26 - get velocity and then from here we can
257:29 - get the vector length so basically the
257:31 - magnitude of the vector
257:34 - all right uh once we get that for the
257:38 - direction actually uh we have a node
257:40 - called calculate Direction
257:43 - which requires uh the velocity
257:46 - and I will tell you what to do next so
257:50 - we need direction and speed so we can
257:53 - promote these two variables so promote
257:56 - to variable we can call this one
257:58 - Direction
258:01 - and we can call this one speed
258:09 - and if the character is valid we can set
258:13 - the direction and speed
258:16 - over here in the direction
258:19 - for the velocity
258:22 - we can just directly grab in this pin
258:24 - over here
258:25 - and then what we can do is we can get
258:29 - after
258:31 - rotation
258:36 - now if I hit compile and if I go ahead
258:40 - and plug these in
258:42 - over here in my blend space layer then
258:46 - in my transition over here so walk run
258:49 - to idle instead of not moving what we
258:52 - can do is we can get the speed and if it
258:56 - is less than a certain value
258:58 - so if it is less than let's say about 10
259:04 - so then we will enter this transition
259:07 - similarly if the speed is greater than
259:10 - 10 we'll enter this transition
259:12 - so if the speed is greater than 10
259:16 - so then we can go ahead and transition
259:18 - into the walk run state
259:20 - so once we change that we should have
259:22 - our logic working so now if I go ahead
259:25 - and press play
259:27 - as you can see
259:28 - the walk run animations are working
259:33 - so that's about it now we have finished
259:35 - animating the character with some basic
259:38 - animation blueprints
259:40 - so that's all there is to it obviously
259:44 - there are many more things you can do
259:45 - with this animation blueprint of course
259:48 - you can you can have sprinting as well
259:50 - so if you would have Sprint uh you would
259:53 - you know have another state called
259:54 - Sprint and then you would plug it in
259:57 - according to what logic you want
259:59 - basically all you have to take care of
260:01 - is when your character can transition
260:04 - into States and make sure it's not going
260:07 - to be in two states at the same time
260:09 - that's about it and in the event graph
260:12 - uh anything that has to update so for
260:15 - example the speed of the character those
260:17 - can be done over here on blueprint
260:20 - update animation event
260:23 - so now I I think this is more than
260:26 - enough for blueprints and I I think with
260:30 - this much of blueprint knowledge you
260:34 - would be able to make an entire game
260:37 - assuming of course you would be ready to
260:40 - look into the documentation a bit and
260:43 - look into what the various functions do
260:46 - if you actually play around with
260:47 - whatever we did plus look at a few extra
260:50 - functions you can create an entire game
260:53 - and now for the more keen ones out of
260:57 - you here we are going to head into C
260:59 - plus plus now
261:01 - we'll be taking a deep dive into the
261:03 - more advanced features of the engine now
261:06 - not to worry for those people who don't
261:08 - know C plus plus I will also be brushing
261:11 - through some of the prerequisites that
261:13 - you need in C plus plus in order to get
261:15 - started honestly there's not much to do
261:18 - with the language most of it would just
261:20 - be function calls and stuff like that so
261:23 - anyways without any more further delay
261:25 - let's actually start learning C plus
261:28 - plus for unreal now I will be going
261:30 - through the basics now
261:32 - [Music]
261:37 - now let's just talk a little bit about
261:39 - the prerequisite knowledge of C plus
261:41 - plus which you'll need to actually
261:43 - understand the further part of the
261:45 - course I do still recommend you learn C
261:48 - plus plus separately but I will get you
261:50 - guys what you need for unreal because
261:52 - it's really not that important to know
261:54 - the language more so you need to know
261:57 - the features which we actually will make
261:59 - use of in unreal so I'll just create an
262:02 - empty console application here so it's
262:05 - just going to be a blank application
262:07 - with in the terminal now I won't even
262:09 - use this I'll just use an empty project
262:11 - template
262:13 - so I'll just search for empty in Visual
262:15 - Studio of course
262:16 - I mean we have it right here so just go
262:18 - click next and doesn't really matter
262:22 - I'll just look for a folder
262:25 - so I'm just going to create it there and
262:27 - click create
262:30 - so just leave all the settings at
262:31 - default none of these would matter for
262:33 - now
262:34 - now once I've created this I'll just go
262:37 - ahead and set up
262:38 - the basic stuff which you need for C
262:40 - plus plus so first of all you'll need a
262:43 - C plus plus file with a main function in
262:45 - it so just to
262:47 - uh just for my reference I'm going to
262:49 - name it main.cpp
262:52 - and we need a main function we'll not
262:54 - get into that now so int Main
262:57 - and we're just going to return 0. now
263:00 - I'll not get into this but the feature
263:03 - which first of all we'll need is to
263:05 - include code from other files
263:07 - now if you want to do that
263:10 - you would do
263:11 - hash include and inside angular brackets
263:16 - or inside double quotes depending on the
263:18 - situation
263:19 - you would include the actual header file
263:21 - so let's say I have a header file so
263:23 - I'll create one
263:25 - so go ahead and call this
263:28 - I don't know header.h let's just leave
263:30 - it as is
263:31 - and pragma once basically means uh this
263:35 - header file will only be included once
263:37 - so you won't have circular dependencies
263:40 - and stuff basically
263:41 - but anyways let's go ahead and type some
263:44 - code so in order to create variables
263:47 - that's the first thing you'll need apart
263:49 - from including so including this header
263:51 - file is simple so in double quotes you
263:53 - can put header dot h
263:55 - or you could even use angular brackets
263:58 - you know generally you would use that
263:59 - only for like standard C plus plus stuff
264:01 - but both of them will work
264:04 - so if you want to include header.h
264:06 - through this you might have to add it in
264:08 - the include paths so will not do that we
264:11 - will stick with this so let's say
264:13 - something standard C plus plus such as
264:15 - IO stream
264:17 - so I misspelled that IO stream I can go
264:21 - ahead and do this
264:22 - or if I have something standard C for
264:25 - example windows
264:26 - dot h so I can do that so for standard C
264:30 - plus plus libraries you would not use
264:33 - dot h for standard C1 so you'll use dot
264:36 - h so for example if you want cmath
264:39 - that's going to be without a dot h or it
264:42 - could do maths.h this is the cmat
264:46 - library
264:47 - so stuff like this for now we'll include
264:50 - adder so whoops
264:53 - so header dot h
264:57 - now this should work and later on I will
265:00 - be showing you guys how to include
265:01 - unreal headers that's not an issue so
265:04 - this main function I just like to go
265:06 - over basically our program is going to
265:08 - start from here but again as I told you
265:11 - guys when you're developing a game in
265:13 - unreal you'd really not worry about the
265:15 - main function that is handled in the
265:17 - engine so if you actually go through the
265:19 - engine Source you will find somewhere
265:21 - where you have int Main and there is
265:24 - there will be a wild rope while loop
265:26 - which actually runs the game so we'll
265:28 - not talk about that so let's write some
265:30 - code so first of all creating variables
265:33 - and before we do that one thing to note
265:36 - is that these are just text files
265:38 - honestly you can put the same code in a
265:41 - header and a c plus file
265:43 - it it really doesn't matter by putting
265:46 - dot hatch you just indicate that you
265:48 - want to include it as a header so that's
265:50 - the only reason both of these are
265:53 - technically just text files and can be
265:54 - opened with any text editor such as
265:57 - notepad notepad plus plus Visual Studio
265:59 - or Visual Studio code honestly doesn't
266:01 - matter
266:03 - so if you want to create a variable
266:05 - you can first of all head into CPP
266:08 - reference to know the basic types
266:11 - but if you want to create an integer for
266:14 - example you type in int space your
266:17 - variable name so for example we'll have
266:19 - my integer
266:21 - and if you type in equals you can assign
266:24 - any initial value to it
266:26 - you actually don't need to do that you
266:28 - can do this a bit later as well
266:30 - but you have to do it inside of a
266:32 - function or something so if I just put
266:35 - my integer equals 12
266:38 - and make sure you end everything with a
266:40 - semicolon this is not going to work
266:42 - because
266:43 - even though you have this line here you
266:45 - are not executing this at all
266:48 - so remember I told you guys uh the
266:51 - program starts from the main function
266:53 - so over here if I put my integer equals
266:56 - 12 this is going to work
266:58 - why this works is because we have
267:00 - included header.net so it's as if it
267:02 - just copied over all of this content and
267:04 - pasted it in instead of this hash
267:06 - include
267:08 - now similarly you can have other types
267:10 - which we discussed so you can upload
267:12 - float X for example
267:15 - and you can have many other types so for
267:19 - example if you wanted a string you would
267:21 - put in STD
267:22 - string in unreal you use F string but
267:26 - again now we are getting an error that's
267:29 - simply because you have to include
267:30 - string so these are the few additional
267:32 - complexities which come with C plus plus
267:34 - so STD string my string equals let's say
267:41 - test string
267:44 - and you can go ahead and set the value
267:47 - again
267:48 - test string
267:51 - so not sure what we call that so okay my
267:54 - string is what we called it
267:56 - so my string
268:00 - equals and you can assign any value to
268:03 - it or you could even use the Constructor
268:05 - for this
268:06 - anyways this is how you create variables
268:09 - like this
268:10 - data type variable name equals value
268:14 - need not be defined
268:17 - initialized as soon as you create the
268:19 - variable you can do it later as well but
268:22 - it's always a good practice to do it
268:24 - now one more thing is that these
268:30 - variables can be printed out which you
268:32 - will not use in unreal you'll use the
268:34 - print string function to print it on the
268:36 - viewport but in in a console application
268:39 - you do something like STD C out
268:44 - and you would go ahead and print my
268:46 - string for example
268:49 - again we're not using this in unreal so
268:52 - that's the reason I'm not really
268:53 - covering this
268:54 - so the error is because we haven't
268:56 - included the header which contains this
268:58 - function
268:59 - so you can go ahead and include IO
269:02 - stream
269:03 - and if you go ahead and run a debugger
269:06 - here as you see we get 232 printed
269:09 - because that was our string again if we
269:11 - just delete this part
269:13 - you would see we will get test string
269:16 - and we can also print my integer
269:22 - like this
269:24 - so we get 12
269:26 - so this is how we would go about
269:27 - printing stuff
269:29 - and what if you wanted to write your own
269:31 - function so what if you have like 10
269:33 - lines of code and you wanted it to
269:36 - be in be called once so basically you
269:40 - can create a function with this syntax
269:44 - so if you want to create a function what
269:46 - you do is you put the return type let's
269:48 - say we create an addition function so
269:50 - our result is going to be an integer so
269:53 - the return type is in
269:56 - space your function name so in our case
269:59 - let's just descriptively name it add
270:01 - and in the bracket you would put the Val
270:05 - put the variables which
270:08 - you know it should take from outside so
270:11 - in order to add two numbers we will need
270:13 - two numbers first of all
270:15 - so we are going to pass two integers so
270:18 - the same way in which you created a
270:19 - variable and in the same way in which
270:22 - you know you would handle anything else
270:24 - you just to enter a comma into B so you
270:27 - separate arguments through a comma
270:30 - so what this basically means is when I
270:33 - call add so when I say add
270:35 - and I put my parentheses so this is how
270:38 - you call a function so if you want to
270:40 - execute add this is how you do it and
270:42 - you'll end it with the semicolon
270:43 - now inside the bracket you would put the
270:45 - values of A and B so in my case if I
270:48 - just put in 12 and 43 and I'll just take
270:52 - some some random numbers
270:55 - now the result of this
270:57 - is going to be returned here
270:59 - and in fact instead of you can set it
271:03 - inside the variable so if I do my
271:06 - integer equals add of 1342 comma 43 so
271:10 - whatever value will be returned here
271:12 - that will be set inside my integer now
271:15 - if you want to actually write the logic
271:17 - for this so it's simply to return a plus
271:19 - b
271:21 - something like this so this is how you
271:24 - do a function but honestly you don't
271:26 - need the syntax since we'll we like we
271:30 - actually have a simpler way to actually
271:32 - write functions we'll be using classes
271:34 - mostly so you shouldn't really bother
271:37 - too much about all this
271:40 - and with that being said let me just
271:43 - show you guys how to create a class so
271:45 - I'll do it in my header so for example
271:47 - I'll just do a class called student
271:51 - and I'll open up my curly braces
271:54 - just follow along with the syntax it's
271:56 - just a matter of getting used to it
271:59 - so under private so these were the
272:02 - private variables which we talked about
272:04 - in Blueprint as well
272:05 - so I can say we have a name
272:11 - and let's say we have his Mark so and
272:14 - marks something simple like that
272:17 - and under the public section we can have
272:19 - some methods
272:21 - so we can say STD string
272:26 - oops
272:29 - and we can call this one get name
272:32 - and instead of writing the definition
272:34 - over here like this so this is similar
272:37 - to what we did here it's just that it is
272:39 - inside the class now
272:41 - what we can do is we can only have the
272:44 - Declaration here like this so only the
272:47 - name is given here
272:48 - but we can actually have a defined
272:51 - outside this class itself
272:53 - so I can do this and I can go ahead and
272:56 - actually make another function so I can
272:59 - say in get marks
273:06 - so now you can also go ahead and Define
273:09 - this outside the class
273:11 - how you do that is
273:13 - you would use this syntax
273:15 - I'm not talking in depth about this
273:18 - mostly because there's a shortcut to do
273:20 - it which I will talk about
273:22 - so s3d string and what what was a class
273:25 - called
273:26 - student
273:28 - followed by two colons you do get name
273:32 - and you can write your function
273:33 - definition over here
273:35 - so you can go ahead and return
273:39 - I guess it was called name so name
273:42 - and similarly you can provide a
273:44 - definition for the marks as well so int
273:48 - student
273:50 - get marks and you can go ahead and write
273:52 - the definition for it return
273:55 - locks so basically you are going to get
273:58 - the marks from this now if you want to
274:01 - instantiate a student so let's say you
274:03 - wanted to create a student object from
274:05 - this remember we talked about classes
274:07 - and objects so you just to student let's
274:11 - just call him S1 for example
274:14 - and you can do S1 dot get name
274:19 - now dot is what you'd use to
274:22 - refer to the members inside a class
274:25 - in unreal though when you create objects
274:28 - you generally have a pointer to it
274:31 - so basically the memory address of it is
274:34 - a pointer nothing much to worry really
274:37 - so I'll just show you guys a way to
274:40 - create it
274:43 - so if I type in student pointer instead
274:46 - equals
274:48 - new S1 basically we are Dynamic new
274:52 - student
274:54 - so new student
274:56 - basically we are dynamically creating
274:58 - this and instead of the actual variable
275:02 - name we have a pointer to it pretty much
275:05 - now nothing much to worry about you just
275:08 - put a star instead of just referring to
275:11 - student
275:12 - and if you want to refer to something
275:15 - through a pointer you do S1 instead of
275:18 - putting a DOT
275:19 - now if you were to do dot you see it
275:22 - just got replaced with an arrow so you'd
275:24 - refer it with an arrow so something like
275:27 - this so if we actually just create a
275:30 - method to set the marks
275:32 - so I'll just do void set marks and it's
275:36 - going to be in the parameter which we
275:39 - need so end marks so we'll take this
275:41 - value from outside
275:43 - and we can say
275:45 - marks
275:48 - okay we are using this again so we can
275:51 - type in marks with a lowercase so marks
275:54 - equals marks
275:59 - so what we can do is we can say S1 dot
276:02 - set marks or rather with the arrow set
276:04 - marks and we can just say 56 for example
276:08 - just a random number
276:09 - and we can print it by typing in stdc
276:13 - out
276:14 - and we can print this so run a debugger
276:17 - and as you can see we got 56 printed so
276:20 - we successfully set the marks
276:22 - so this is how we would call functions
276:25 - which are defined inside a class and you
276:28 - will need to call them through an object
276:30 - because you need to instantiate them
276:32 - first of all this is something which you
276:34 - will not do in unreal you would use the
276:36 - function such as spawn actor and stuff
276:38 - in order to actually create objects but
276:41 - anyways this was just something I showed
276:43 - you guys now with this much you can
276:45 - pretty much do it if there's anything
276:47 - else such as for loops and stuff you can
276:50 - just follow along and look at the syntax
276:53 - that's pretty much it and if statements
276:56 - are also easy so you just do if and you
276:58 - would have the condition in the bracket
277:00 - so let's say
277:02 - the marks is greater than 56 so I can do
277:05 - S1 get marks
277:07 - S1 get marks greater than let's say 35
277:11 - then we can go ahead and print that the
277:13 - student has passed so stdc out
277:17 - and I can say past
277:21 - so if I do this as you would see we get
277:24 - 56 and passed obviously this is not in a
277:27 - new line but that's pretty easy to do so
277:29 - you can do STD ndl
277:33 - and now you'd see 56 passed
277:37 - so with this much basic C plus plus you
277:40 - can actually follow along but again I do
277:43 - recommend you separately learn a bit of
277:45 - C plus plus before you come in
277:47 - the upcoming sections of this course is
277:50 - going to be for intermediate and
277:52 - advanced users so before you actually
277:55 - get started I recommend you guys do a
277:57 - few things first of all spend maybe a
278:00 - few days actually exploring the engine a
278:03 - little bit more may be creating a tiny
278:05 - game or something
278:06 - and secondly make sure you do know the
278:09 - basics of object oriented programming in
278:11 - c plus plus so stuff like your classes
278:15 - and you know uh stuff like structs
278:19 - functions and variables and the the
278:23 - basic stuff basically if you guys are
278:26 - familiar with that much of C plus plus
278:28 - and you have used the engine a little
278:31 - bit you would be able to follow along
278:33 - with the further part of the course
278:36 - [Music]
278:41 - so in order to start coding in C plus
278:44 - plus for unreal head into tools and open
278:47 - your Visual Studio project by clicking
278:50 - on that button over there
278:52 - and you should be in some sort of a file
278:56 - over here now you may have something
278:59 - blank so we'll just close that
279:01 - now under your games folder you should
279:04 - see your project name here and this is
279:07 - where you actually start working with
279:09 - stuff now we don't have anything
279:11 - actually under this we are going to be
279:14 - having our source files
279:16 - so you don't actually create it here in
279:19 - unreal in unreal you actually have the
279:22 - option to just generate all the
279:25 - boilerplate code for you
279:27 - you can do that by heading into tools
279:30 - and by typing in new C plus plus class
279:33 - now over here
279:35 - you get various options now if you have
279:38 - something really simple if you have some
279:40 - pure C plus plus logic you could just
279:42 - create an empty class and you could just
279:44 - sticker around it's just going to create
279:46 - a Constructor Destructor and it's going
279:48 - to write the class definition for you
279:50 - along with no macros just the standard C
279:54 - plus plus one but the most basic useful
279:57 - thing that you'll use in unreal is going
279:59 - to be your object so under all classes
280:02 - if you select object this is going to be
280:06 - equivalent to your object in blueprints
280:08 - however when you actually create it so
280:10 - if I just create it uh just select
280:13 - public and this is just to determine
280:16 - where your CPP file will be whether it
280:19 - will be in the public folder or the
280:20 - private folder now over here we can just
280:23 - call this CPP object
280:28 - so let's not confuse ourselves let's
280:30 - just call it CPP underscore yeah object
280:34 - is fine so this is not an object this is
280:37 - the class which is named CPP object
280:41 - please don't get confused with that so
280:43 - create a class
280:45 - and now as you can see you have some
280:47 - really basic code and one thing you
280:49 - might not have noticed is okay live
280:52 - coding is on that's a different story
280:54 - but what you might notice is it already
280:57 - has several things such as it has
281:00 - included some header files here
281:02 - these are just unreal standard header
281:05 - files and you will need them
281:09 - and you might have seen a few extra
281:10 - macros as well so this is a u-class
281:14 - macro
281:15 - and inside these these actually taken
281:17 - arguments too now these are useful for
281:20 - the unreal header tool basically when
281:23 - you compile this it happens in two
281:25 - phases basically your unreal header tool
281:28 - sets up stuff which are specific to your
281:32 - objects for unreal called your objects
281:35 - and in order to implement those features
281:38 - it does certain extra steps
281:40 - so when you get a compiler error it
281:43 - could be either from that or from your
281:45 - standard C plus compiler anyways that
281:47 - shouldn't be much of a problem to you
281:50 - guys
281:52 - now if you might have noticed
281:54 - even though we called it CPP object it's
281:57 - prefixed with a u and we have inherited
282:00 - it from U object
282:03 - now why is it like this now basically
282:06 - any object that you create that is a
282:10 - derived class of your object must have
282:12 - the prefix U and even object has the
282:14 - prefix u in Blueprint it is just shown
282:17 - as object however in theory it is
282:22 - actually U object
282:24 - and similarly for actors so let's
282:27 - actually create an actor as well so we
282:29 - can head back into the editor tools new
282:32 - C plus plus class and as you can see you
282:34 - see pretty much the same stuff over here
282:36 - but these are the two important ones
282:38 - object and actor now obviously character
282:40 - pawn and stuff like that are important
282:42 - but they don't have any specific
282:44 - prefixes so I I'll be talking about them
282:47 - a bit later and obviously we'll talk in
282:49 - depth about the inheritance hierarchy so
282:51 - I'll select actor
282:53 - and let's call this one CPP underscore
282:56 - actor
282:57 - create that
283:00 - and live coding if it works properly it
283:03 - should in theory compile it for us
283:06 - now if we actually open it up and reload
283:11 - this
283:12 - you would see
283:13 - you find something which looks a little
283:15 - bit overwhelming if you're looking at it
283:17 - from the first time but if you ignore
283:19 - this macro and if you ignore this
283:22 - comment here I don't even know why this
283:24 - comment exists because if you have come
283:27 - to an extent where you can write or
283:30 - interpret this code I don't think you
283:32 - need to know that a Constructor sets the
283:35 - default value so we'll just delete that
283:36 - comment
283:38 - and begin Place basically our event
283:40 - begin playing blueprint same thing
283:43 - uh tick is again your tick and blueprint
283:46 - you can delete the comment now this code
283:49 - looks a lot more cleaner now this is a
283:51 - virtual function and if you were to
283:53 - notice it's not called CPP actor it's
283:55 - called ACP actor basically every actor
283:59 - is prefixed with an A and the actor
284:01 - class itself as well
284:03 - [Music]
284:09 - all right now that we have established a
284:11 - basic understanding on creating a
284:14 - blueprint equivalent actors and objects
284:16 - let's look at the inheritance hierarchy
284:19 - in unreal in a little more detail now
284:22 - I'm not covering everything over here
284:24 - now I have left a few things such as
284:26 - interfaces and I'm not going into each
284:29 - class I'm just talking about the ones
284:31 - that you'll use in almost every project
284:33 - so that should cover things for you if
284:36 - you need anything in specific the
284:37 - documentation should help you if you
284:40 - understand this much so at the base
284:42 - level you have your object of course you
284:44 - have your typical basic C plus plus
284:48 - class but we are not getting into that
284:50 - now under that I can categorize a these
284:55 - into three main other classes which
284:57 - you'll use now there are many others but
285:00 - you won't really use them the first one
285:02 - and which you probably expected is a
285:05 - actor now an actor
285:08 - or a actor as it's called in C plus plus
285:10 - is something which can be placed in the
285:13 - scene so if you want to place something
285:15 - in the scene and write the code in C
285:17 - plus plus you would create an a actor or
285:20 - in the menu or in the unreal editor it's
285:24 - referred to as actor everywhere
285:26 - now similar to pawn you have a pawn
285:29 - which is basically something which can
285:32 - be possessed by a controller so
285:34 - basically you can control it and it need
285:36 - not be you it could be an AI as well so
285:39 - maybe you could write some code for Bots
285:42 - or something so you would use spawn in
285:45 - that case
285:46 - and if you have something specific like
285:49 - a humanoid character or something
285:51 - generally for most of the things which
285:54 - will be Pawn you generally use character
285:58 - so if you need a movement component
286:01 - and stuff like that you would use
286:03 - character some functionality is already
286:06 - set up in your character which is not
286:08 - set up in Pawn so something such as
286:11 - adding your controller pitch and your
286:13 - input and you know many other functions
286:17 - which we will talk about as we use them
286:20 - so that's where you'll use character
286:22 - this might be clear
286:23 - now a controller is basically an actor
286:28 - which takes an input now you cannot
286:30 - place a controller in a level obviously
286:32 - it sounds a bit stupid to place a
286:34 - controller in a level but basically uh
286:38 - each player will have his own controller
286:40 - and to be specific he will have a player
286:42 - controller
286:44 - if it's an AI or something you have
286:46 - something known as an AI controller but
286:49 - again we are not getting into that we
286:50 - it's really not that common to use it
286:54 - a controller will basically take your
286:56 - input now although you can set up your
286:59 - input bindings in other actor blueprints
287:02 - controller is the right one to actually
287:04 - hard code bindings and stuff like that
287:06 - generally when you create widgets which
287:09 - are not associated with your character
287:11 - you would create them inside your player
287:13 - controller blueprint generally you
287:15 - create a player controller you don't
287:16 - create a controller and that's about it
287:20 - for what you'll use for the most part
287:22 - and if we actually head into more
287:24 - gameplay oriented classes you have a
287:27 - info the reason I put this is because
287:29 - this was
287:31 - this was just a wrapper for you know
287:33 - these classes which you'll use you'll
287:35 - never create an info actor so ignore
287:38 - this this just for your reference
287:41 - over here you'd see a game mode base as
287:45 - the name suggests game mode base it's
287:48 - basically your game mode so anything any
287:51 - code logic regarding your game mode will
287:54 - be there in this and obviously it's
287:57 - really simple for me to just tell it
287:59 - like this but once I take a couple of
288:02 - examples it's going to be crystal clear
288:04 - for you guys and there is also an a game
288:07 - mode class which is inherited from this
288:10 - and it has some additional functionality
288:12 - for the most part we will stick with a
288:14 - game mode base but again you can feel
288:17 - free to use a game mode
288:19 - similarly a game State base and a game
288:22 - State now you might ask what's the
288:25 - difference between these two the main
288:27 - difference is that game mode exists only
288:29 - on the server in multiplayer games
288:32 - whereas game State exists both on the
288:35 - server and client so things like match
288:37 - timers which you would want all the
288:40 - players to be able to see as well you'd
288:42 - have them stored in the game State and
288:44 - maybe some other variables which you
288:47 - only want to use as a means of
288:50 - calculating something in game so stuff
288:52 - which will only be there on the server
288:54 - and multiplayer games or something which
288:56 - is core to your fundamental gameplay so
288:58 - something like maybe you know switching
289:01 - to another level when you enter place or
289:03 - something I mean it depends on the game
289:05 - honestly can't just tell what you would
289:07 - do with it just like that but basically
289:11 - game mode game state
289:13 - work together hand in hand now there's
289:16 - one more actually called the player
289:18 - State now the player state is really
289:22 - special because this is replica this is
289:25 - replicated by default to all the clients
289:28 - in multiplayer we upload in detail about
289:31 - multiplayer later on but for now just
289:34 - know that player state is going to be
289:37 - kind of the class which you'll use for
289:39 - anything that all the players must know
289:41 - at all points of time
289:43 - and generally you'd store info common to
289:46 - a given player which other players need
289:48 - to know uh stuff like your player name
289:51 - would be there in your play State
289:52 - because all other players need to be
289:54 - able to access your player name at any
289:56 - point of time so I just gave you an
289:58 - example you could be creative with it
290:00 - and do whatever you want
290:03 - now one thing you might have noticed
290:04 - over here for the last one which I'll
290:06 - talk about under your object is are
290:10 - actually two more uh game instances as
290:13 - the name suggests your game's instance
290:15 - so this is talking about your game as a
290:18 - whole and not anything inside the game
290:20 - so instead of begin play actually you
290:23 - have something known as event in it here
290:26 - so let's say you call something off of
290:29 - event init that actually runs well
290:32 - before your level actually loads so
290:35 - we'll look into examples again
290:38 - if you have anything pertaining to the
290:41 - game which has to sustain between level
290:44 - transitions let's say you move from your
290:46 - main menu to your actual gameplay level
290:49 - if you want stuff to sustain between
290:51 - them let's say you wanted a variable to
290:53 - sustain in that case you'd use the game
290:55 - instance because the game instance will
290:57 - not be destroyed between levels but when
291:00 - you transition from one level to the
291:02 - other all the actors and all the widgets
291:05 - everything else that you could possibly
291:07 - think of are going to be destroyed now
291:10 - speaking of widgets we have multiple
291:12 - classes here which you will probably
291:14 - never even touch even widget to be
291:16 - honest you will never touch in C plus
291:17 - plus it's very rare that you re you
291:20 - would require a C plus plus class for a
291:22 - widget
291:23 - so your user visit is the class which
291:25 - you'll use of course in the editor it's
291:27 - going to be referred to as user widget
291:28 - so this is how you would create widgets
291:31 - but honestly it's too much of a pain to
291:33 - work with widgets in C plus for
291:35 - something that's just you know very
291:38 - simple you could just work with other
291:40 - Blueprints and just have a blueprint
291:42 - widget which you would interact with
291:44 - stuff like that so that's about it
291:47 - actually
291:48 - now the way I'd practically use this is
291:51 - you'd have one C plus Base Class so for
291:54 - example we can have for a character we
291:56 - can have one character and we can go
291:58 - ahead and derive one so let's say we
292:00 - call this one R character so let's say
292:04 - it is a
292:06 - we'll just call it CPP as a convention
292:08 - ACP underscore our character
292:12 - I'll just call it our care for now
292:14 - now what you do is you would have core
292:17 - functionality written inside this class
292:20 - so for example your movement maybe maybe
292:23 - if you have a first person shooter game
292:25 - you're firing logic basically stuff that
292:27 - is Mission critical for the game and
292:29 - stuff which would break if they don't
292:31 - execute so for that you write it in C
292:33 - plus plus
292:34 - but other cosmetic things which you
292:37 - don't really require and it's fine if it
292:40 - executes a bit late stuff like you know
292:43 - uh creating widget maybe uh let's say
292:46 - you have a Crosshair on the screen maybe
292:48 - updating its position uh if you have a
292:51 - dynamic Crosshair that is or maybe you
292:53 - know stuff which is not essential like
292:57 - effects spawning FX so if you have stuff
293:00 - like that which is not really Mission
293:02 - critical it's fine uh if it's a bit slow
293:05 - and maybe if you don't have too many
293:07 - Loops so if you have many Loops in your
293:09 - code blueprint generally run slower I
293:12 - will talk about why that is and stuff so
293:15 - what you do is you'd have the core
293:17 - functionality in your base class and
293:19 - then uh you would create a blueprint
293:22 - class which I'm marking in yellow and we
293:25 - you'll call this one BP underscore r car
293:28 - now this is just a convention I use you
293:30 - could call it anything you could simply
293:31 - call this one r car
293:33 - so this is going to be our blueprint
293:35 - class and this is what you'll spawn in
293:36 - the level so since this is inherited
293:39 - from this BPR car will have all the
293:42 - properties of acpp Archer similarly you
293:45 - do that for all the other classes and
293:48 - that's how you would work hand in hand
293:50 - with blueprint and C plus plus blueprint
293:53 - is going to make your coding a lot
293:55 - easier so it's basically your visual
293:58 - scripting language so it's going to be
294:00 - very simple to write game logic
294:03 - but when it comes to finer control and
294:06 - when it comes to using other libraries
294:08 - when it comes to doing machine critical
294:10 - stuff you would use C plus plus so
294:12 - that's basically how you use blueprint
294:14 - and C plus plus hand in hand of course
294:16 - this is a very in-depth topic and we are
294:18 - going to be talking about this in the
294:21 - future now let's actually go ahead and
294:23 - work a little bit more on whatever we
294:25 - learned till now
294:28 - [Music]
294:33 - so now that we know about the basic
294:36 - inheritance hierarchy let's actually
294:38 - start creating stuff on our own now the
294:41 - first thing which you might want to
294:43 - create are variables now for our case
294:46 - just for reference we'll be using our
294:49 - CPP object.h but anyways you don't have
294:52 - to use this you can you can do this
294:54 - inside the actor as well so stuff like
294:56 - that will remain the same most of the
294:59 - time you will not have anything in the
295:01 - global scope you will create everything
295:03 - inside of your class itself so the rest
295:06 - of your file maybe if you are creating a
295:09 - new struct or something you'd use it but
295:11 - most of the times you will be doing
295:12 - stuff inside the class
295:14 - so let's create a variable
295:17 - now you could do your normal C plus plus
295:19 - syntax thing so for example let me just
295:23 - create an integer so by using int let's
295:26 - say our integer variable
295:31 - all right you could initialize it here
295:34 - or in the Constructor
295:35 - now one thing that you might know is
295:39 - that since this is private are derived
295:42 - classes hence any blueprint class which
295:44 - we create out of this cannot access a
295:47 - variable so in order to actually access
295:50 - it there are two ways I'll be showing
295:52 - you guys both the ways so I'll I'll type
295:54 - in our private integer variable because
295:56 - we made it private this is how you would
295:58 - ideally do it I'm just uh explaining you
296:02 - guys each thing but you could you could
296:05 - you know brush through if you are
296:07 - already aware of object oriented
296:09 - programming but anyways it will give you
296:11 - a learning experience nonetheless
296:14 - now another way you could do it is you
296:16 - could create a variable in the public
296:18 - section so we'll call this one r
296:21 - public
296:23 - integer variable
296:26 - now this is good if you want to access
296:29 - it everywhere however it's really not
296:33 - you know appropriate to do it this way
296:35 - because if you have it in public any
296:38 - other class can just straight up modify
296:41 - this variable which is not good for us
296:44 - let's say you have something like your
296:46 - character speed or something it's very
296:49 - easy to misinterpret that maybe
296:51 - accidentally change the value so it's
296:53 - better to have Getters and Setters
296:55 - instead now this is how you would work
296:57 - with a public variable I know you guys
297:00 - are still waiting for the unreals
297:02 - reflection system so all these macros
297:05 - which is EU class use truck your
297:07 - property I'll tell you about all those
297:08 - not to worry foreign
297:16 - is that since this is private in order
297:19 - for other classes to access it we
297:22 - actually need to define a method so we
297:24 - can call this one int get
297:27 - our
297:29 - private
297:30 - hint
297:32 - we called it increaser order so let's
297:36 - call it
297:37 - like this
297:39 - now we also probably need a Setter
297:42 - so set our private
297:45 - integer now we don't have a function
297:48 - definition so if the reason I told you
297:51 - guys at the beginning that you don't
297:53 - really need to know too much C plus plus
297:54 - is that once you know how to write the
297:58 - Declaration you could just right click
298:00 - quick actions and you could just create
298:02 - a definition like this same way with our
298:05 - Setter function oh and this has to be
298:07 - void because we aren't actually
298:09 - returning anything you could make it
298:11 - bull so let's say you have a condition
298:13 - where you can't set it so let's say for
298:15 - a health variable you can't set it to
298:17 - 101 so then you would do those checkings
298:20 - and stuff but in our case we'll just use
298:21 - void
298:24 - head into the file here and instead of
298:27 - this we will return this variable so not
298:30 - public we'll return our private integer
298:32 - variable
298:35 - now this is how you would set it up for
298:38 - the private variable and this is the
298:40 - proper way to do it
298:42 - also
298:43 - uh currently none of these use unreals
298:47 - reflection system now if I just run a
298:49 - debugger so it's going to launch the
298:51 - editor make sure it's set to development
298:52 - editor in the configuration
298:56 - so wait for that to build
298:58 - and once it's done building it should
299:00 - start the editor
299:04 - [Music]
299:09 - now in order to actually use this over
299:11 - here and actually check stuff uh in
299:15 - Blueprint so what you would do is you
299:17 - would right click go to blueprint class
299:19 - and type in CPP underscore object but
299:21 - you see that it's not visible now the
299:24 - reason it's not visible but our actor
299:26 - was visible because by default All
299:28 - actors if you were to go into this file
299:31 - by default All actors are going to be
299:34 - marked as blueprintable so if I actually
299:36 - head into
299:38 - uh the actor over here
299:41 - and if I actually look into this U class
299:45 - macro you see it says blueprintable
299:48 - so what we need to do is in our object
299:51 - if we want to use this in Blueprint that
299:52 - is inside this u-class macro type in
299:55 - blueprint table now this is how you
299:57 - expose your view objects to blueprint so
299:59 - let's say anything is not accessible in
300:02 - this menu over here okay under all
300:04 - classes it probably means you haven't
300:06 - marked it as blueprintable so let's stop
300:08 - the debugger and run it again
300:11 - so wait for it to compile then once the
300:14 - editor loads up we should be able to use
300:17 - our
300:19 - CPP underscore object class
300:22 - so give it a second for it to load
300:26 - and now if I head back into blueprints
300:28 - right click blueprint class CPP
300:30 - underscore object you see that it's
300:33 - usable
300:34 - and this one will call it BP underscore
300:36 - object
300:38 - now if I just right click and if I want
300:41 - to access the function
300:43 - so we have get our private integer
300:46 - so get R and as you can see there is
300:49 - really nothing
300:50 - the reason is
300:52 - unreal doesn't really know that you want
300:55 - this to come in the editor basically
300:58 - you're not utilizing
301:00 - uh the unreal standard macros which
301:03 - enable you to do it
301:05 - so how you do it is for variables what
301:08 - you do for a public variable here we are
301:10 - going to type in U property
301:13 - and in the arguments will use a
301:17 - parameter known as blueprint read write
301:23 - now when you put this in the arguments
301:25 - basically what you're saying is you want
301:28 - this to be readable and writeable in
301:31 - Blueprint let's say you only wanted to
301:33 - be able to read it you do blueprint read
301:35 - only now how do I know how to do this
301:38 - basically you can just head into your
301:40 - browser and type in you property
301:46 - ue4
301:47 - audio A5
301:49 - oops not properties
301:54 - so
301:56 - yep your property so basically you have
301:58 - to go to the documentation page and
302:01 - as you can see there should be a list of
302:04 - specifiers somewhere over here there is
302:07 - so all of these are the specifiers so
302:11 - let's say you wanted a function to be
302:13 - blueprint callable you do that that is
302:15 - blueprint PR as well I'll be showing you
302:17 - guys the common ones but you can have a
302:19 - look at all of these
302:21 - the documentation is King
302:24 - now for a private variable actually we
302:26 - don't need to make this Au property
302:29 - however you could choose to make it now
302:32 - if you want to use these Getters and
302:34 - Setters which will technically
302:36 - you know enable us to use our private
302:39 - variable
302:40 - our get function will be pure of course
302:42 - so we are going to use a u function now
302:45 - now view function is another macro again
302:48 - you could have a look at it so here if I
302:51 - head into U function over here
302:53 - you see again there is documentation
302:56 - which talks in depth about this
302:59 - we will be looking at the common ones
303:01 - anyways
303:02 - this one will be blueprint pure
303:05 - blueprint PR means those green nodes
303:07 - which we saw without any execution pins
303:09 - so if I actually head into any blueprint
303:12 - these types of nodes basically without
303:14 - this execution pin
303:17 - that's going to be our Pure function
303:20 - and I talked a lot in depth about it
303:22 - when I talked about Blueprints and stuff
303:24 - now this one will be a u function as
303:26 - well and this one will just be blueprint
303:29 - callable
303:32 - all right now we can go ahead and run a
303:36 - debugger
303:38 - now we should be able to access this
303:48 - now live coding is a bit finicky that's
303:51 - the reason I'm not using it otherwise I
303:54 - would have chose to use it now let me
303:57 - just create that I didn't actually save
303:58 - it so CPP underscore object
304:01 - we'll call this one BP underscore object
304:05 - save that this time
304:07 - if I open it up now and if I type in get
304:11 - our
304:13 - private integer you see we get this
304:15 - function which gives us access to the
304:17 - value similarly set our private integer
304:20 - also works but it's kinda useless we
304:23 - actually didn't set up any functionality
304:25 - so let's just take in a parameter
304:27 - parameters are pretty simple except
304:30 - references everything else is going to
304:32 - be the same for parameters like how you
304:34 - do in standard C plus plus so you could
304:37 - type in in new value
304:40 - and over here as well we could just head
304:43 - into the definition and change that
304:45 - and then we could do our private or our
304:48 - public it should be nope it should be
304:50 - private so our private integer variable
304:53 - equals new value
304:56 - now that should fix things so we should
304:59 - have our logic corrected over there
305:02 - but that's not really our concern right
305:04 - now
305:05 - what if you wanted to take a value by
305:08 - reference now this is passed by value
305:10 - and it will work you could try it out
305:12 - not really going to waste my time to
305:14 - show it if you actually want your value
305:18 - to be passed by reference you use this
305:20 - macro known as U param
305:22 - ref
305:25 - and then you use an ampersand over here
305:30 - so copy this do the same thing in your
305:33 - CPP
305:34 - and now if I go ahead and actually build
305:37 - this once again
305:39 - and and in my object if I go ahead and
305:42 - type set our private integer you see
305:45 - it's taking in by reference if you hover
305:47 - over it it says new value integer by
305:50 - reference
305:51 - so this is how you do pass by reference
305:53 - I just showed that this is one thing
305:56 - which is a little different from C plus
305:57 - plus you can't just use an ampersand
306:00 - however if you use an ampersand it is
306:03 - going to take it as a second return
306:05 - value in Blueprint basically like your
306:07 - out parameters so let me show you guys
306:09 - what I mean by that so if I do this now
306:11 - this is wrong logically this is wrong I
306:14 - know that but anyways I'm just showing
306:16 - you guys what's gonna happen
306:18 - so if I go ahead and run a debugger once
306:21 - again
306:22 - this time it's going to take it as an
306:24 - output rather than an input
306:30 - if I open my BP object again
306:33 - and if I type in
306:36 - let's say set r
306:40 - private integer you see the new value
306:42 - goes out basically this is how you
306:44 - handle multiple return values as well
306:46 - you could just do pass by reference and
306:49 - in Blueprint it's going to interpret it
306:51 - as an out parameter in our case uh your
306:54 - param ref was the correct choice so we
306:57 - are going to do that undo this over here
307:00 - as well
307:01 - so that's about it
307:04 - oops just correct that
307:07 - also if you guys want to access your
307:10 - public variable you can just directly
307:12 - use our public variable so our public
307:15 - integer variable so it's directly
307:17 - accessible to us but one thing you might
307:19 - notice is that unlike these variables
307:22 - here it does not let you edit the
307:24 - default value and stuff
307:26 - now there is one reason for that that's
307:29 - because you again need to set a flag in
307:32 - order to do it remember the you property
307:36 - macro or here you have to type in edit
307:39 - anywhere in order to be able to do it so
307:41 - edit
307:43 - anywhere if I can spell that correctly
307:46 - if I actually do this and run a debugger
307:49 - once again I should be able to use our
307:51 - public integer variable and set its
307:53 - default value
307:55 - now if you were to see under the class
307:57 - defaults we have an option to set the
308:00 - default value or when we even get our
308:02 - public integer variable you see that we
308:05 - can set our default value so this is
308:08 - basically how you expose that to
308:09 - blueprint
308:11 - [Music]
308:15 - I suggest that you guys now try it with
308:19 - a few more functions of yourself
308:21 - and maybe you know check how they work
308:25 - in the editor and stuff once that's done
308:28 - let's talk about the next type that is
308:32 - u-struct so basically if you want to
308:34 - create structs for the Unreal Engine you
308:38 - need to use the macro known as you
308:40 - struct now generally I prefer doing it
308:44 - inside this dot h file for your project
308:46 - so you will have a file like this
308:49 - but you really don't need to you could
308:51 - do it in any file so for example let me
308:54 - just do it in our CPP object.h file it
308:58 - could be really anywhere unreal is going
309:01 - to recognize it for you so I'll just do
309:03 - it above our U class so I'll just type
309:06 - in struct
309:07 - and if you guys don't know what struct
309:09 - is uh well you got to learn that before
309:13 - it's basically like a class but uh by
309:17 - default all its members are public but
309:19 - remember when you are working with the
309:21 - Unreal Engine you don't really work with
309:24 - struct methods you only work with
309:27 - variables and any methods you'll have
309:29 - you'll have it in another class as
309:31 - static functions so that's how you work
309:34 - with it anyways I will show you guys
309:36 - what I mean by that real soon
309:38 - so for example let's just create a
309:41 - struct known as let's say book
309:44 - this is obviously highly impractical but
309:47 - just as a basic example and for the
309:50 - variables we could have maybe a string
309:53 - now remember in Unreal Engine the
309:56 - variable you use is not STD string so
309:59 - you don't use STD string actually what
310:02 - you use is called fstring which is
310:04 - unreal string type
310:06 - obviously most of the string types are
310:10 - just interconvertible at any point of
310:12 - time so if you are using a third party
310:14 - library or something you can convert it
310:16 - so F string is the string type in unreal
310:19 - so if I type in F string let's say name
310:22 - and maybe we can have an integer for
310:25 - number of pages
310:28 - and we can have a float for rating
310:32 - all right we have a really basic struct
310:35 - over here now if I go ahead and build
310:37 - this actually so I'll close my editor
310:40 - if I go ahead and build this
310:42 - you would see that it would build
310:45 - successfully
310:46 - however obviously uh as you would expect
310:49 - you cannot access this struct in the
310:51 - editor because we haven't used the
310:53 - unreal macros so in order to use this in
310:56 - the editor you you call you struct
311:01 - and inside the parameters what you do is
311:04 - you would make this
311:06 - blueprint
311:09 - type
311:11 - so this is what you use to expose truck
311:13 - to blueprints now if I actually run a
311:16 - debugger right here
311:17 - so you would find that there are a few
311:20 - build errors
311:22 - so what this is is this is not your C
311:25 - plus plus compiler error
311:27 - basically there are a few rules in order
311:30 - to use structs in unreal similar to how
311:32 - you have a u prefix for all structs you
311:35 - need to have an F prefix
311:37 - so now if I go ahead and run this
311:42 - in the editor it's going to be visible
311:44 - as book you see that we get another
311:46 - error now it says expected a generated
311:50 - body now if you notice our class here it
311:53 - has a generated body similarly for our
311:56 - struct as well for all U structs we are
311:58 - supposed to be having a generated
312:01 - u-struct body
312:04 - so it's going to set stuff up for the
312:06 - editor for us basically
312:08 - so now if I go ahead and build this you
312:11 - should see that we compiled successfully
312:15 - and we open up the editor right now
312:19 - but you will soon notice one problem
312:21 - again which you probably would have
312:23 - guessed if you would have seen these
312:26 - so the so if I just head into my object
312:29 - for example and if I if I type in let's
312:32 - say I create a new variable and call
312:34 - this one book one
312:36 - and I get the type book
312:39 - you see I can access this
312:42 - there's no issue but if I right click I
312:45 - can't actually split the struct pins
312:47 - now if you actually hover over this
312:50 - cannot split the struct pin it may be
312:53 - missing blueprint exposed properties
312:56 - so what is it basically tells us is we
312:59 - actually need to Mark these as you
313:01 - property as well so the same macro can
313:04 - be used here as well so you property
313:07 - and there's a little bit of an issue
313:09 - with the indentation there don't mind
313:12 - so your property again
313:16 - make this one a you property depending
313:19 - on what you want let's say we don't want
313:22 - to be able to change the name so let's
313:23 - make that blueprint read only so then we
313:26 - won't be able to change it now if I stop
313:29 - debugging and open the editor once again
313:33 - now if I go ahead and take a look and if
313:36 - I drag this in right click and split
313:39 - struct pin I am able to split it now if
313:42 - you drag this in and if you want to edit
313:44 - the members you would use the set
313:46 - members function
313:48 - and obviously you can have number of
313:50 - pages and rating as a parameter and we
313:53 - set name as not being editable since we
313:56 - did blueprint read only as you can see
313:59 - we don't have that available as a pin so
314:02 - this is basically how you use structs in
314:04 - C plus plus now the way you use it in C
314:07 - plus plus is pretty much the same like
314:08 - how you would by the way if you want
314:10 - struct methods you can use them but you
314:13 - cannot write U functions inside stock
314:15 - that's the thing so if I actually go
314:18 - ahead and try it basically I'll show it
314:19 - to you guys so
314:22 - if I had in here type in let's say void
314:25 - test function and I'll just give it a
314:27 - simple body here and I won't do anything
314:29 - now we would see that it will build
314:31 - successfully there won't be any issues
314:35 - so as you can see it builds but if I
314:37 - actually make this a u function
314:40 - I won't I won't even give any parameters
314:42 - if I just make this a u function
314:45 - as you would see it says use trucks
314:48 - cannot contain you functions
314:50 - so how do you actually do stuff with it
314:53 - so how do you actually operate on
314:55 - structs basically what you do is instead
314:58 - of having the U function here you would
315:00 - have it inside either a function Library
315:03 - class or you would have it inside some
315:06 - other object and make it a static
315:08 - function maybe so let me actually show
315:10 - that
315:11 - so let's create a test function
315:14 - so for example let's create a u function
315:16 - here
315:17 - so U function
315:19 - and what we can do is we can make this
315:23 - blueprint callable
315:27 - and over here instead of just declaring
315:29 - a regular function let's do a static
315:31 - function static void test
315:35 - and now we want to operate on this truck
315:39 - so if you want to operate it similar to
315:42 - your objects what you could do is you
315:44 - could simply create your own Target pin
315:47 - so the way you do it is fbook
315:51 - Target and obviously you would make that
315:54 - a reference so
315:57 - you param
315:59 - and in the brackets you would have ref
316:02 - so you would pass this as a reference
316:05 - and then you could work with it inside
316:09 - so I can write the definition here as
316:11 - well but just to be a bit cleaner so
316:14 - quick actions
316:15 - so whoops
316:18 - quick actions and I can create the
316:21 - definition
316:22 - uh now now that we've actually come this
316:25 - far I'll just show you guys how to print
316:27 - strings so it's not like blueprint where
316:31 - you directly just call you know print
316:33 - string and this is not gonna work so I
316:37 - can't just do this so let's just say
316:40 - test function called for example
316:44 - I actually cannot do this
316:47 - uh the very simple reason being that
316:52 - [Music]
316:57 - in Blueprint unreal actually Imports or
317:01 - rather includes all your headers for you
317:03 - as per necessity but basically that
317:07 - doesn't happen here so it's not exactly
317:10 - headers but you get the point
317:13 - so in order to use print string so how
317:16 - you would go about searching for
317:18 - functions is you do something like this
317:20 - so you do print string
317:22 - unreal C plus plus this is how you just
317:25 - search it up and you would look for the
317:26 - one which says docs.unreal engine.com
317:30 - and you would head in here and it says
317:33 - it tells you the include file so copy
317:36 - this path
317:38 - paste this in no not path rather the
317:41 - include
317:42 - and now we would see you have all the
317:44 - various parameters some of which are
317:46 - optional there are only two parameters
317:48 - which actually need but anyways
317:52 - now what we can do is
317:55 - now you notice that you are not able to
317:57 - call it
317:58 - but that's because this is actually a
318:00 - static function once again
318:02 - so what you do is you do you Kismet
318:04 - system Library
318:06 - and followed by a scope resolution print
318:09 - string and now we would see that it
318:11 - still shows an error that's because you
318:13 - actually need to pass in a world context
318:16 - object because it doesn't really know
318:19 - you know where to uh output the string
318:23 - like how to show it on the screen so in
318:26 - order for it to know that you actually
318:28 - need to pass in an object if this wasn't
318:31 - a static function you would just use
318:33 - this so if if this were inside an actor
318:36 - and it's not static you'd use this but
318:39 - it says this may only be used inside a
318:43 - non-static member function so what we
318:45 - can do is we can just pass in a u object
318:47 - pointer over here or rather we'll just
318:49 - pass in an actor pointer so a actor
318:53 - pointer now remember when you work in C
318:57 - plus plus
318:58 - any object any actor anything that you
319:02 - have which is enclosed in a class
319:04 - basically any class if you want to use
319:06 - them you would use a pointer to it you
319:10 - will never refer to it as a actor it'll
319:13 - always be a pointer just remember that
319:17 - so an actor is just to give you know
319:20 - some context to it so we can just type
319:23 - in context for example
319:26 - it could be an object as well I assume
319:28 - so if I type in context here
319:32 - now we would see that the error is gone
319:34 - but obviously we change the function
319:36 - signature you could make this a u object
319:39 - pointer I believe
319:41 - and now what we can do is we can copy
319:43 - this over
319:44 - head back into our function declaration
319:49 - and put that in
319:51 - so now our error should go now if I go
319:54 - ahead and actually run this
319:58 - now if I head in to Blueprints and BP
320:03 - object or here if I call test for
320:07 - example I think it's called test as you
320:10 - can see now we can operate on this truck
320:12 - and for the context we can what we can
320:15 - do is simply we can plug
320:18 - any you know outer object in so I'll
320:21 - just actually do that
320:24 - so I'll open up the level blueprint so
320:26 - for the context what we can do is we can
320:29 - go ahead and
320:31 - get a reference to sell
320:33 - and for the Target what we would do is
320:36 - we would go ahead and actually get a
320:39 - struct so instead of this I'll just
320:41 - create a struct
320:42 - so I'll just call this truck for example
320:46 - and it's going to be of type book
320:50 - so we can use that and now this function
320:52 - is going to operate on this truck
320:55 - so this is just a basic way you can do
320:57 - it now if I go ahead and press play
320:59 - after three seconds you should see
321:01 - something being printed test function
321:03 - called
321:04 - as you can see that works so that's
321:07 - pretty much how we would handle struct
321:09 - methods
321:10 - [Music]
321:15 - so that pretty much covers the basics of
321:17 - using structs in unreal C plus plus now
321:20 - the next thing is obviously enumerations
321:23 - and that should be about it and then we
321:26 - can start you know working with a little
321:29 - more complicated things at the base
321:32 - level enumerations in Blueprint and C
321:35 - plus plus work the same but in order to
321:37 - create them in C plus plus you can do
321:40 - the same thing actually you can do enum
321:42 - this one doesn't really need to have a
321:44 - prefix by the way so for example let's
321:47 - just say fruit
321:49 - uh fruit list let's just call it
321:53 - and inside that we can have our list
321:56 - items so let's say we have apple
321:59 - let's say we have our mango
322:02 - and let's say we have a banana
322:06 - stuff like that make sure I just end
322:08 - everything with a comma
322:10 - now again the same thing this is not
322:15 - exactly exposed to blueprint but in
322:18 - order to actually expose this you you
322:20 - use the same
322:21 - specifier as your use struct but instead
322:24 - you type in you enum
322:26 - if you use the U in a macro and if you
322:30 - add in the parameter blueprint type now
322:33 - this would be usable in Blueprint but if
322:37 - you wanted to give it a different you
322:39 - know name for it in Blueprint so if you
322:41 - wanted to give a display name to this
322:43 - basically what you do is you'd use
322:45 - another macro known as you meta and over
322:48 - here you change display name equals and
322:52 - you put in the string so in our case uh
322:56 - let's just call this one apple
322:59 - underscore underscore one maybe
323:03 - so just for you just for me to
323:06 - demonstrate that it works
323:08 - now if I actually run the editor
323:14 - and I can just go ahead into any
323:16 - blueprint and I can operate on that so I
323:18 - can say switch on whatever we call that
323:22 - fruit list as you can see instead of
323:24 - Apple it actually shows apple one and
323:27 - mango and banana is just shown as this
323:29 - generally what you do is you would
323:32 - simply have the display name to just
323:34 - display exactly what this list item was
323:37 - so you would simply have this and you
323:41 - would have mango over here
323:43 - generally you would just leave it like
323:44 - this
323:46 - banana
323:48 - so this is how you would go about doing
323:51 - it
323:53 - [Music]
323:57 - now we have brushed through the basics
323:59 - of Unreal Engine C plus plus of course
324:02 - if you want to know what function calls
324:04 - to use for your gameplay specific needs
324:06 - you could refer the documentation and
324:09 - later on when we actually take an
324:11 - example we will look into some of the
324:13 - common ones so it's not really that you
324:15 - have to refer the docs for everything I
324:17 - will be going through many of them now
324:19 - over here let's actually do a quick
324:21 - exercise let's try to translate this
324:24 - into C plus plus now if you were to
324:27 - notice this entire thing is actually
324:31 - purely in Blueprint and let's say we
324:34 - wanted our code to run faster or for
324:36 - whatever reason we needed it to be in C
324:38 - plus plus so let's actually go ahead and
324:41 - translate that so it's really simple
324:44 - uh let's start step by step
324:47 - so we have our get player camera manager
324:49 - function let's see which header file we
324:52 - need so it says Target is gameplay
324:55 - Statics right so this tells us that we
324:58 - need gameplay static so if I head into
325:00 - Chrome and if I type in gameplay Statics
325:04 - poe4 or ue5
325:06 - you see you actually get the
325:09 - documentation page
325:11 - so over here we can get access to which
325:14 - header file we need so Kismet gameplay
325:16 - statics.net so stuff like that let's
325:18 - actually go about doing it now for the
325:20 - cast node we need a C plus plus class
325:23 - because all are C plus plus classes will
325:26 - not have access to the blueprint classes
325:28 - but all our blueprint classes will have
325:31 - access to the C plus ones so you cannot
325:33 - access a blueprint class from C plus so
325:37 - that's one disadvantage
325:39 - now let's go about doing this
325:42 - so
325:43 - I'm just showing you guys one example
325:45 - obviously we will talk about a few of
325:48 - the common ones such as spawning actors
325:50 - and stuff which are really common
325:53 - now let's start in the editor so let's
325:56 - go ahead and actually create the classes
326:00 - that we need so first of all we need a
326:02 - base class for our BP character so go
326:05 - head into tools new C plus plus class
326:07 - character and call this one CPP
326:10 - underscore character of course you can
326:12 - name it descriptively if you wanted
326:14 - create the class
326:16 - head back in
326:18 - and we need a couple more things
326:20 - actually
326:21 - so one thing that we need is the pickup
326:24 - class itself so type in actor
326:26 - and call this one
326:29 - CPP pickup
326:31 - all right
326:33 - create the class
326:41 - now what I want you guys to do is head
326:44 - into BP pickup and over here under class
326:47 - settings for the parent class I want you
326:49 - guys to select CPP pickup
326:52 - and over here as well I want you guys to
326:55 - select BP CPP character so CPP
326:59 - underscore character I want you guys to
327:01 - select that now what this basically
327:03 - means is that you are inheriting this BP
327:06 - character class from CPP character so
327:09 - everything that's there in CPP character
327:11 - will also be there in VP character
327:13 - basically this is your inheritance
327:15 - now let's head back in let's just reload
327:18 - this and I think we can close the editor
327:19 - for now
327:21 - or actually we might need that for
327:23 - reference so let's actually open up the
327:25 - character
327:26 - so we need a camera manager and from our
327:30 - header file we from our documentation we
327:32 - know that we need this header file so
327:35 - inside our character.h because that's
327:37 - where we wrote it always when you're
327:39 - including header files you need to do it
327:41 - above the generator.h
327:43 - so over here Kismet gameplay statics.h
327:47 - and let's just uh do this in the public
327:51 - section
327:53 - and let's have a look so when we press
327:55 - our left Mouse button we get the player
327:57 - camera manager so let's try calling that
327:59 - static function
328:01 - so go ahead
328:03 - let's actually create the function let's
328:05 - call this one I don't know what do we
328:07 - call this
328:09 - so we're just tracing and destroying so
328:11 - let's call this one
328:13 - remove pickup or something so avoid
328:15 - remove pickup
328:18 - all right we don't really require any
328:20 - parameters
328:21 - now let's go ahead and create a
328:23 - definition for it
328:25 - so whoops let's just head in and it has
328:29 - created the definition for us
328:33 - so let's go ahead and get that that's a
328:35 - static function so you gameplay Statics
328:40 - get player camera manager
328:45 - and over here what we can do is for the
328:47 - world context object since this is an
328:49 - actor characters are actors so you can
328:52 - just use this generally you just use
328:54 - this and player index as 0 since we have
328:56 - only one controller per screen
328:59 - so we got the camera manager and from
329:02 - this we need the actor location as well
329:04 - as the forward vector so what we do is
329:08 - let's actually just store it in a
329:09 - temporary variable so we can type Auto
329:11 - Temp equals
329:13 - and we can store this in a variable and
329:16 - what you can do is we can go ahead and
329:18 - get the actor location
329:21 - so this is a pointer again so temp
329:25 - with the pointer operator we can get the
329:28 - actor location
329:30 - we have forward Vector here let's do
329:32 - that as well
329:34 - and temp
329:36 - get actor location now this might
329:40 - actually warn us right now uh to use the
329:44 - get camera location function so as you
329:46 - can see use get camera location instead
329:49 - so get camera location
329:52 - just spell that correctly and now we
329:54 - have access to these locations
329:58 - and what we are doing is we are
330:00 - basically plugging this into the line
330:02 - Trace
330:03 - so what I can do right now over here to
330:05 - simplify things is we have a forward
330:07 - vector
330:09 - we grab that in
330:11 - and we multiplied by a float
330:14 - so the operator is already overloaded so
330:17 - we multiply that by 50 000 in our case
330:20 - so let's just do that
330:22 - and if we head back into our blueprint
330:25 - so we add that to our camera location
330:29 - so plus our camera location so you could
330:32 - just do a plus again
330:34 - so plus our camera location we can put
330:37 - these in parentheses just to be a little
330:39 - more clear on what we're actually doing
330:42 - so we can delete this line
330:44 - we have that next what we have is our
330:47 - line Trace so if you just hover over
330:49 - this you see it says Target is gizmit
330:52 - system library and I know this header
330:55 - file so I'll just do it for you guys
330:57 - anyways uh what we are doing is going to
330:59 - be correct so let's close this up
331:02 - so it's going to be Kismet Kismet system
331:05 - Library you could have a look at the
331:06 - documentation as well
331:08 - so Kismet
331:10 - Kismet system Library
331:14 - and if we include that our error should
331:16 - go and if I open up the CPP file once
331:19 - again
331:20 - now we should be able to call the line
331:23 - Trace function so you Kismet system
331:26 - Library
331:27 - line Trace if I do that I should find
331:30 - line Trace single
331:33 - and for the parameters we have a bunch
331:35 - of them so first one is the world
331:37 - context object which is going to be this
331:39 - again and next we have the start and the
331:43 - end location we look into all of that so
331:45 - this
331:47 - and our start location is going to be
331:50 - our camera location
331:52 - so what we can do is we can actually
331:54 - store this in a variable right now
331:58 - so what we can do is we can type in auto
332:02 - camera location
332:04 - equals
332:06 - get camera location
332:09 - now for the start we can go ahead and
332:12 - type in camera location
332:14 - and then we have our end so again we can
332:18 - store this in another variable so Auto
332:21 - End Lock location or let's just call
332:23 - this one end
332:25 - equals
332:26 - whatever calculation we just did right
332:28 - there so
332:30 - end and is what we called it then the
332:34 - next parameter we have is a trace type
332:36 - query which is the trace channel so this
332:39 - is what you see over here
332:41 - now over here uh this is a little bit
332:44 - peculiar in C plus plus so if I just do
332:47 - e Trace type query
332:49 - so e Trace type query
332:54 - and if I take a look you get something
332:56 - like one two three so on basically these
332:59 - are what you define in the project
333:01 - settings so if I actually head into my
333:03 - project settings and just type in Trace
333:07 - you would be able to see that you get
333:09 - Trace channels by default we actually
333:12 - get to uh that is visibility and camera
333:15 - so if we just do a trace type query one
333:18 - that is going to be your visibility and
333:21 - then if we take a look we have a Boolean
333:23 - for dress complex we don't really want
333:25 - to dress for complex collisions here so
333:27 - let's just do 0 or that is false
333:30 - and over here we have a parameter which
333:33 - we actually don't need and we also have
333:38 - a few more I guess we'll just use the
333:40 - ones which we absolutely need so actors
333:43 - to ignore we can just create an empty
333:45 - area and we can just pass that in so
333:48 - tra
333:50 - actor pointer
333:53 - and I will get to TRS don't worry
333:55 - basically this is like your STD Vector
333:58 - in standard C plus plus uh instead of
334:01 - that the one used in unreal is called
334:03 - tra so all the same functions exist
334:06 - inside this as well instead of dot size
334:09 - you have you know dot num there are a
334:12 - few names which have changed but it this
334:14 - is pretty much like your STD vector and
334:17 - let's just call this one ignore
334:20 - and we'll just pass that in so ignore
334:24 - and the next parameter is uh e draw
334:29 - debug Trace so basically whether you
334:32 - want to see the line trace or not so we
334:35 - draw
334:37 - debug Trace
334:41 - whoops
334:43 - and over here we have for duration for
334:47 - one frame persistent uh let's keep that
334:49 - for duration for now
334:53 - all right
334:54 - once that is done we have our head
334:57 - result which we are going to Output so
334:59 - we'll just create another variable so if
335:02 - hit result
335:05 - and we'll call this one
335:07 - hit or out hit or whatever
335:10 - and what we can do is we can just pass
335:12 - hit over here and once we have our hit
335:15 - result we have B ignore self yeah we
335:17 - want to ignore ourselves
335:19 - and don't really need the dress color
335:24 - because this has a default value so
335:27 - that's about it basically
335:29 - so we can go ahead and close this
335:32 - so I feel these parameters should be
335:34 - enough and once this function is
335:36 - completed we should have access to
335:38 - everything that we can possibly think of
335:41 - so the first thing uh that we are going
335:44 - to do is we are going to cast it to the
335:45 - pickup
335:46 - now in order for us to work with this
335:49 - first of all we need to include the
335:51 - header file so hash include
335:53 - because we don't know what CPP pickup is
335:56 - so we'll just do
335:58 - CPP
336:00 - ickup.h
336:02 - so this should compile because it is in
336:04 - the same folder and once we actually
336:06 - include the file what we can do is we
336:08 - can simply cast it now you won't use a
336:11 - dynamic cast here unreal actually has
336:13 - some things built in for us
336:16 - so we can get our hit
336:18 - so if
336:20 - hit
336:23 - dot actor dot get actor
336:27 - if this is valid now at this point if we
336:32 - haven't actually hit any actor with our
336:34 - line Trace basically this if is going to
336:37 - be false and we are not going to execute
336:39 - this code however if we have hit the
336:41 - actor we can go ahead and cast it to our
336:43 - pickup so if we can go ahead and cast it
336:46 - so this is going to be acpp pickup this
336:49 - is how you cast in unreal C plus plus
336:51 - basically you have a cast function and
336:54 - over here we can just pass in the actor
336:57 - so if this actor is valid so again the
337:00 - pointer is going to be pointing to an
337:03 - actor if it is actually valid in that
337:05 - case what we can do is we can go ahead
337:07 - and destroy this actor so hit not get
337:10 - actor and we can call the destroy
337:12 - function
337:14 - that's about it and just to make sure
337:18 - what we can do is we can just print it
337:20 - so UK is mid system Library
337:23 - print string and over here we can just
337:26 - pass in this instead for the world
337:28 - context object and we can print
337:30 - destroyed a pickup
337:34 - and we can go ahead and terminate that
337:37 - so now in order for us to actually be
337:40 - able to call this from blueprint uh
337:42 - we'll set up input and stuff a bit later
337:44 - in Blueprint it has a couple of extra
337:46 - steps so in order to expose this to
337:49 - blueprint field again use a u function
337:51 - and make this one blueprint callable
337:54 - make sure I get the case right
337:57 - and just indent that and now if I go
338:00 - ahead and close my editor and run a
338:03 - debugger now
338:04 - the editor should load up and if we open
338:07 - up our character we can get rid of all
338:09 - this code and I don't know what we call
338:11 - this so we called it remove pickup I
338:14 - don't even know why we call this but we
338:16 - can call remove pickup
338:18 - remove pickup now if I go ahead and
338:21 - press play
338:22 - and if I left click as you can see
338:25 - our logic actually works
338:28 - and okay this is not a pickup this was
338:30 - just a cube so that's the reason it
338:32 - didn't work
338:33 - but anyways the line Trace works
338:37 - now the reason it's working is because
338:39 - BP pickup is also a CPP pickup because
338:42 - we inherited from it so that's the
338:45 - reason what's happening is when we
338:46 - actually cast it over here uh we are
338:49 - actually
338:51 - successfully casting to our CPP pickup
338:54 - as well even though that was a BP pickup
338:56 - so that's basically how we translate it
339:00 - now we can go ahead and clear out some
339:02 - stuff this was just for clarity so
339:05 - instead of using the camera location as
339:08 - a separate variable we can go ahead and
339:10 - copy the server
339:12 - similarly for n we could just do the
339:14 - same
339:16 - and
339:18 - if we have anything else we could do
339:20 - that as well so we don't have anything
339:21 - else we can go ahead and close this up
339:25 - we'll we'll leave this temp variable
339:28 - because having such a long line
339:30 - everywhere is going to be a little bit
339:32 - weird but again you could you could do
339:35 - this so you could just place this
339:37 - instead of temp wherever temp is going
339:39 - to be there you could go ahead and
339:43 - get the player camera manager and do
339:45 - that but in this case actually using
339:47 - temp would be a better solution so we'll
339:49 - just stick with using temp
339:52 - [Music]
339:56 - so we have brushed through quite a bit
339:59 - regarding C plus plus and as we create
340:02 - stuff we will go through more things now
340:05 - what if apart from a pickup we also
340:09 - needed to cast some other thing so let's
340:11 - say let's actually create another actor
340:13 - so let's do it with our interaction
340:15 - actor itself so let's go ahead and open
340:18 - it up not sure why we've used it so
340:20 - let's just hit Ctrl f to find and let's
340:24 - just find interaction
340:29 - so
340:32 - so we are basically nudging it so what
340:35 - are you basically doing is we are again
340:37 - casting so I have to just check where it
340:40 - is
340:41 - so if we are overlapping so that's what
340:44 - we are doing
340:45 - so let's actually remove this logic and
340:47 - let's actually have the destroy logic
340:49 - itself
340:50 - so remove this
340:52 - and remove this or actually we could
340:54 - keep this
340:56 - now if you wanted to do it with your
340:58 - cast so what you would have to do is you
341:00 - have to cast to interaction actor
341:05 - if this fails and then destroy it and
341:09 - this for the most part will work
341:12 - so let me just go ahead and drag that in
341:15 - forget about the C plus plus logic
341:18 - and as you can see this works and even
341:21 - this works
341:22 - however one thing you might notice is
341:25 - let's say in an actual game obviously
341:27 - we'll have many such actors not just an
341:30 - interaction and a pickup actor
341:32 - so in that case
341:34 - you will have to perform many cars and
341:37 - casting is expensive for your computer's
341:40 - performance
341:42 - so the way you get around this is
341:44 - instead of casting multiple times you
341:46 - could cast to an interface
341:48 - and in unreal blueprint there's actually
341:51 - a very elegant system implemented we'll
341:54 - be talking about both the blueprint and
341:56 - C plus versions of interfaces now
341:59 - so in order to handle this problem
342:02 - what we can do is we can actually create
342:06 - an interface so I'll show you guys step
342:08 - by step to implement this exact logic uh
342:11 - using an interface and we can actually
342:14 - have separate logic as well for both the
342:16 - interaction and the pickup Factor
342:19 - so head into your blueprints right click
342:21 - blueprints blueprint interface and let's
342:24 - just call this one I don't know destruct
342:27 - I guess
342:28 - uh generally I have a Convention of
342:31 - calling it BPI underscore
342:34 - and we can call this one
342:38 - destruct pickup Maybe
342:42 - all right and we don't need anything for
342:45 - the input
342:47 - but anyways now the way you actually use
342:50 - this is for whichever actor that needs
342:54 - to be casted to so for example we are
342:56 - casting to our pickup and our
342:58 - interaction actor so we would head into
343:00 - both of these and under your class
343:03 - settings under implemented interfaces we
343:06 - can go ahead and Implement BPI destruct
343:10 - and do the same thing for the
343:12 - interaction actor head into class
343:14 - settings
343:15 - DPI destruct
343:17 - basically at at the fundamental level
343:21 - what this is doing is it is inheriting
343:25 - this interface along with actor so
343:27 - basically your interface is also class
343:29 - internally in C plus plus I will show
343:31 - you guys the C plus plus version which
343:34 - will make things a little more clear
343:36 - but instead of doing all this what we
343:38 - can do is we can call destruct
343:43 - or I guess I call it pickup so let's
343:45 - just call it destruct in general
343:48 - to compile and save that so we call this
343:51 - destruct
343:52 - and now if I actually go ahead and press
343:55 - play I mean nothing's going to happen
343:57 - because
343:58 - although we have destruct as you can see
344:00 - we can't really Define the logic here
344:02 - the way you define the logic is for
344:05 - example we can head into pickup under
344:07 - interfaces right click Implement event
344:11 - and if I go ahead and just print a
344:13 - string and I can type in
344:15 - destructing pickup
344:19 - and if I go ahead and destroy it so
344:21 - destroy actor and Target will be self
344:24 - and I'll do the same for the interaction
344:26 - actor so implement this event oops
344:30 - paste this in and we can do destructing
344:33 - whatever this is
344:35 - interaction after
344:39 - so now you should be able to see that
344:42 - both of these different implementations
344:45 - are actually called so if I press play
344:49 - you see our pickup is destroyed and if I
344:52 - actually click on this side our
344:55 - interaction actors also destroyed
344:57 - so this is how you basically use
344:59 - interfaces instead of casting basically
345:02 - what it's doing internally even though
345:05 - this looks like we got rid of casting is
345:07 - instead of casting to our interaction
345:10 - actor it casts to the interface because
345:13 - interaction actor implements that
345:15 - interface the cast is going to succeed
345:17 - and the function will be executed
345:20 - the situation where the cast fails is
345:22 - automatically handled in the engine
345:25 - now how do you do the same exact thing
345:27 - in C plus plus you may ask it's pretty
345:31 - simple actually you just use the concept
345:33 - of multiple inheritance in C plus plus
345:36 - so tools
345:38 - [Music]
345:42 - create a new C plus plus class and over
345:46 - here what you have to do is Select
345:48 - unreal interface
345:50 - and we can just call this my interface
345:52 - for example and create the class
345:54 - it should load up visual studio for you
345:59 - so just reload that and over here you
346:03 - should be able to see my interface.h and
346:06 - my interface.cpp basically this is where
346:09 - you would write the function definitions
346:11 - and you can go ahead and Define it in
346:14 - your various classes
346:16 - so what you do is for example let's just
346:20 - have
346:21 - this function
346:23 - work for both the pickup and you know
346:27 - our
346:29 - whatever that was interaction actor so
346:32 - let's say we want this function to work
346:35 - for both of them so let's go ahead and
346:36 - do that using an interface we'll
346:38 - actually get rid of the C plus plus
346:40 - logic
346:42 - so we'll get rid of that
346:44 - and what we got to do is first of all uh
346:48 - since we are actually casting to the
346:50 - interface here we can go ahead and
346:52 - include the header for that so hash
346:54 - include
346:56 - over here uh we can go okay we are
346:59 - including pickup already so what we can
347:01 - go ahead and do is we can go ahead and
347:04 - include this interface in the pickup
347:07 - so not after a generated before the
347:10 - generated dot h
347:11 - and this is going to be
347:14 - my
347:15 - interface dot h
347:19 - and over here where you see public a
347:21 - actor
347:22 - I put in a comma and type in public
347:26 - I my interface
347:28 - I is basically the prefix which is used
347:31 - for interfaces just remember that
347:34 - so my interface in the editor is going
347:37 - to correspond to IMI interface in C plus
347:41 - so let's actually write our function so
347:43 - let's call this void disrupt Maybe
347:50 - and we can go ahead and add in our
347:52 - implementations
347:54 - so we can right click first of all
347:57 - and
347:58 - make this one virtual
348:04 - right click
348:06 - actions
348:07 - create a definition for it
348:10 - this is just going to be like your
348:13 - default implementation
348:19 - so now let's say we wanted to implement
348:22 - this function in another class it's
348:24 - really simple to do it now that we have
348:26 - a virtual function here we can head into
348:29 - our pickup.h and over here along with
348:33 - this we can type in Virtual void and I
348:37 - don't know what the function was so I'll
348:39 - just copy this over
348:41 - do the same thing in the pickup
348:45 - and since we are actually overriding a
348:47 - base class method what we can do is we
348:49 - can use the keyword override
348:51 - uh now if I go ahead and right click
348:54 - quick actions create a definition
348:57 - head in here and now let's say we do the
349:00 - same thing so let's say we do U Kismet
349:04 - system Library
349:06 - print string
349:09 - this and let's just say
349:12 - destroyed
349:14 - pickup from C plus plus
349:18 - and we need to include Kismet of course
349:20 - so let's just do that real quick so let
349:23 - me just copy this over
349:26 - because let's just do this in the dot h
349:27 - file
349:30 - so now we can go ahead and actually
349:32 - destroy it so we can say this
349:36 - destroy
349:39 - or rather you can just call destroy
349:43 - all right so we can go ahead and test
349:45 - this logic but remember it's not going
349:47 - to work for our interaction actor
349:49 - because
349:50 - we again don't have another C plus class
349:53 - for it so let's actually create that too
349:55 - so new C plus plus class actor
349:58 - let's just call it for example I don't
350:02 - know
350:03 - CPP underscore interaction active
350:09 - okay so we'll create the class
350:12 - and what we can do is we can again
350:13 - implement this so in order to implement
350:16 - the interface
350:18 - so I'll just stop the editor there so in
350:20 - order to implement the interface we'll
350:22 - do the same thing what we did for pickup
350:23 - so if you head into the header here
350:26 - copy this over head into your
350:28 - interaction actor
350:30 - implement the interface and again we
350:33 - need the header file so what we can do
350:35 - is we can do hash include
350:38 - uh whatever this is so we have my
350:41 - interface.h
350:43 - and then we can go ahead and implement
350:45 - this event by using virtual void
350:48 - destruct which was a function name and
350:51 - we are overriding a base class method so
350:54 - override
350:55 - and now we can go ahead and create the
350:57 - definition for it
351:00 - and over here we can go ahead and print
351:02 - the string again
351:04 - we can do that by simply including
351:06 - Kismet again so let me just copy it over
351:10 - oops I'd copied that so head back into
351:12 - your pickup
351:14 - where we had included it copy that paste
351:16 - that back in
351:18 - and let's just copy over the code from
351:20 - our pickup
351:22 - you can have different code as well I'm
351:24 - just showing you guys as an example on
351:27 - how to use it so we'll change what we
351:29 - print so destroyed
351:32 - interaction actor from CPP and this
351:36 - should work
351:38 - also just head back into your CPP file
351:41 - your CPP character and where we cast it
351:44 - to the pickup what you basically do is
351:46 - instead of casting to the pickup you
351:48 - cast to the interface since we inherited
351:51 - the interface so it's going to be I my
351:53 - interface and make sure you actually
351:55 - include the header file I've already
351:56 - done that so somewhere over here we have
351:59 - included pickup.h already and pickup.h
352:02 - already implements the interface and we
352:05 - have included the header so we don't
352:07 - really need it so we can cast to this
352:09 - interface and instead of destroying and
352:13 - printing what we can do is we can
352:15 - utilize this
352:17 - so we can
352:20 - have this separately so we'll just do
352:23 - Auto
352:25 - temp equals I mean I'm doing uppercase
352:28 - temp because we've already used
352:29 - lowercase temp here
352:31 - and temp is going to be valid because
352:34 - the cost has succeeded
352:36 - so what we can do is we can call
352:38 - destruct from here
352:42 - all right
352:44 - now we can go ahead and run a debugger
352:47 - now if I head back into my character
352:50 - connect this up
352:51 - uh hit play
352:54 - and you should see that we say destroyed
352:58 - pickup from CPP but the interaction
353:01 - actor doesn't work that's because we
353:04 - haven't actually set up the parent class
353:06 - over here so go ahead and change that to
353:08 - CPP underscore interaction actor and we
353:12 - could rename this as well BP interaction
353:14 - actor
353:16 - all right so if I go ahead and press
353:19 - play the pickup works
353:21 - and as you can see destroyed interaction
353:23 - actor from CPP
353:26 - so that's pretty much it that's how you
353:28 - use interfaces and later on we will also
353:31 - be seeing more practical examples this
353:34 - was probably a good one but still will
353:36 - actually implement this in our actual
353:38 - game
353:40 - [Music]
353:44 - now let's look at another case where you
353:48 - know you want to call blueprint
353:50 - functions from C plus plus now this
353:53 - almost seems impossible because your C
353:56 - plus plus classes aren't actually aware
353:58 - of what blueprint classes exist but
354:02 - actually it is
354:03 - it's really simple too so what you do
354:06 - you could use it in any actor any object
354:09 - even in the interface if you want but
354:12 - I'll just show you guys in the character
354:13 - by just printing something
354:15 - so the way you actually call blueprint
354:18 - from C plus plus is like this so you
354:21 - just write the normal function so let's
354:23 - just call this void
354:26 - test BP func let's say
354:30 - and now what you got to do is you have
354:33 - to use the U function
354:35 - a macro and you can make this blueprint
354:39 - callable or not but the specifier that
354:42 - you need is called blueprint
354:44 - implementable event
354:49 - so now you can have the function
354:51 - declaration over here you can actually
354:53 - have parameters too so we can test that
354:56 - if you want so in X let's say
355:00 - so now if I actually run this you won't
355:02 - actually get a compile error because
355:04 - unreal or automatically generates the
355:07 - definition for you and you can Define it
355:09 - in Blueprint
355:10 - so if I open up my BP character
355:14 - and under functions under overrideable
355:17 - if you just have a look you will have
355:19 - test BP func and as you can see I can
355:23 - actually implement this over here and we
355:25 - also got our input parameter so we can
355:27 - just go ahead and print a string we can
355:29 - either call this through blueprint or we
355:32 - could even call this through C plus plus
355:33 - let me show you guys by calling it
355:35 - through C plus plus so I'll do it on
355:37 - begin play
355:38 - so what was a function called again test
355:42 - BP func
355:43 - and you would see that this is actually
355:46 - implemented so let's type in 100 for
355:48 - example
355:49 - and this will work and in the meantime
355:52 - now I would like to show you guys one
355:55 - more thing that you can do I just wanted
355:57 - to show you guys that yes you can
355:58 - actually do this you can actually
356:00 - implement it in Blueprint
356:02 - [Music]
356:07 - but there is a possibility that you have
356:09 - some C plus code but then you also have
356:12 - some blueprint code which you want to be
356:14 - executed so in that case what you would
356:17 - do is you would use another type known
356:19 - as blueprint native event so we'll just
356:23 - copy over this function
356:25 - and let's call this one test BP native
356:29 - funk and let's just have something else
356:32 - for example let's say we'll have a float
356:35 - and for this actually what you need to
356:38 - do is you need to have another function
356:41 - called The implementation of this
356:44 - function
356:45 - so that is going to be what you define
356:48 - in C plus plus and this is going to be
356:50 - our function name in Blueprint so in
356:53 - order to explain what I mean instead of
356:54 - implementable type in Native
356:58 - now if you compile this you'll actually
356:59 - get an error so what you're supposed to
357:01 - do is not create a definition however
357:05 - you are supposed to create an
357:07 - implementation for this so the way you
357:08 - do it is you just copy over the
357:10 - signature and instead of the same
357:13 - function name you type in underscore
357:15 - implementation
357:18 - whoops
357:19 - implementation
357:22 - so what you can do now is for the
357:24 - implementation you can go ahead and
357:26 - create the definition
357:27 - head into your definition and we can go
357:30 - ahead and print something so let's say
357:32 - we go ahead and print
357:35 - for example let's just say
357:38 - C plus plus implementation
357:42 - called
357:45 - and we can close that in
357:47 - and for a blueprint implementation we
357:50 - can set that up in Blueprint no issues
357:53 - so that should be it now you can go
357:56 - ahead and actually compile this once
357:57 - again
358:00 - so apologies I just made a few typos
358:02 - over here so
358:05 - so let me just copy Implement over here
358:11 - so implementation
358:13 - and do the same in the CPP file as well
358:17 - so underscore implementation and now you
358:20 - should have no problems
358:25 - so if we head into a BP character
358:27 - and we can go ahead and override both of
358:30 - them so test bpfunk we can go ahead and
358:34 - print it actually uh this is our
358:36 - blueprint implementation and we called
358:38 - it from C plus plus so okay we'll just
358:41 - go ahead and print it we are calling it
358:43 - from C plus plus so what should be
358:45 - expected is 100 is going to be printed
358:48 - even the native event you can call it
358:50 - from C plus plus I'll just do it over
358:52 - here
358:53 - so first of all let me Implement that in
358:55 - Blueprint so
358:57 - Implement that go ahead and just print
359:00 - that
359:01 - that shouldn't be that hard and just
359:04 - grab in our begin play here
359:07 - and instead of okay let's just spawn
359:10 - this let's keep all of this logic
359:12 - and we can go ahead and since we made it
359:14 - blueprint callable
359:16 - whatever this was and we'll just take in
359:19 - some random value
359:22 - now if I compile and if I go ahead and
359:24 - press play as you can see we get 100 as
359:28 - well as our four two three four three
359:31 - printed
359:33 - now your obvious question is why didn't
359:36 - the C plus plus implementation get
359:38 - called so if we if I actually go ahead
359:40 - and delete this and if I were to press
359:42 - play now we would see our C plus plus
359:43 - implementation is called but that's not
359:47 - really that useful isn't it unless you
359:50 - just have some sort of a default
359:52 - implementation
359:53 - so what you actually need to do in order
359:55 - to get the C plus plus version called is
359:58 - right click on the Node and type in add
360:01 - call to parent function
360:03 - now it is going to call the C plus
360:05 - version
360:07 - now if I go ahead and press play
360:09 - as you can see
360:11 - it calls the C plus C plus plus
360:13 - implementation the blueprint
360:15 - implementation as well along with it so
360:18 - that is basically how it works
360:21 - now if I if you were to do this as you
360:23 - can see we call the C plus function
360:26 - along with the parameters of course as
360:28 - well as the blueprint function what you
360:30 - are calling here is actually the
360:32 - blueprint function if it does not find
360:34 - an implementation it is going to use the
360:36 - parent class version of the function
360:38 - remember that foreign
360:46 - discussed everything which was
360:48 - foundational in order to actually start
360:50 - developing in C plus plus however we do
360:53 - lack a little bit of knowledge regarding
360:56 - you know the implementation of various
360:58 - data structures in unreal now apart from
361:01 - just using normal variables you would
361:03 - use arrays and Maps there are others
361:05 - such as sets linked lists and stuff but
361:08 - for games you would honestly just use
361:11 - arrays and Maps most of the time
361:14 - so in order to implement arrays in
361:17 - unreal so you don't use a static array I
361:20 - mean value could but you don't use
361:21 - static arrays uh you don't really use
361:25 - the STD Vector as well you could use a
361:28 - 3D Vector but you can't expose them to
361:30 - blueprint and stuff or you would have to
361:32 - write your own wrapper class now if you
361:34 - guys don't know what I'm talking about
361:35 - I'm basically referring to the standard
361:37 - template library in C plus plus
361:40 - but in unreal instead of STD Vector we
361:44 - actually have
361:45 - another type known as template array or
361:49 - tra so the way you create that so let's
361:51 - create a variable in C plus plus let's
361:53 - do that in the public section we're just
361:55 - doing it for demonstration so I'll just
361:58 - make a U property
362:00 - and make this one blueprint read write
362:05 - and add it anywhere
362:07 - so edit
362:09 - anywhere
362:10 - and over here what we can do is instead
362:13 - let's say we have an array of integers
362:15 - so the way you do it is you type in t
362:17 - array and as a template argument you
362:20 - would give the type as integer and let's
362:23 - just call this our end array
362:26 - all right now template array is actually
362:30 - internally
362:31 - something like your STD Vector so if I
362:34 - actually Ctrl click on this this is
362:35 - actually a class which implements it
362:39 - and the methods which are associated
362:41 - with this are pretty simple we will go
362:43 - ahead and check all of this
362:46 - so similar to the STD vector class in
362:50 - standard C plus plus tra has a bunch of
362:54 - functions which gives us info about
362:56 - various things so let's actually set
362:59 - some stuff up so in order to initialize
363:02 - this array so what we do basically we
363:05 - can do it in the Constructor or right
363:07 - here we'll do it in the Constructor just
363:08 - to keep things clean so we'll call R and
363:12 - array equals
363:14 - and within curly braces we can just give
363:16 - some values so I'll just initialize it
363:19 - with some random values
363:21 - all right so now let's go ahead and look
363:24 - at how to add stuff to this so similar
363:27 - to add and in place we have methods for
363:31 - that over here as well so we can type in
363:33 - R int array
363:35 - Dot add and now we can go ahead and add
363:40 - an item so let's say for example I want
363:42 - to add 12. so our fifth element here
363:45 - that is at index 4 is going to become
363:48 - 12. and this array is going to be
363:51 - resized since it is similar to an STD
363:54 - vector
363:55 - now similarly also have M plus so
363:58 - constructing an element in place
364:00 - basically
364:02 - dot m Plus
364:04 - this is like your M plus back function
364:07 - in STD vector
364:10 - so I'll just add in some random element
364:13 - over there now our array is going to be
364:15 - 23 6 43 64 12 and 4. now what if I
364:20 - wanted to remove something so I can type
364:23 - in R int array and I can remove either
364:26 - at index so dot remove I can either
364:30 - remove an element by using the remove
364:32 - function so let's say I wanted to remove
364:34 - 23 I'm gonna remove 23.
364:38 - and R and array
364:40 - whoops
364:42 - R and array
364:45 - dot remove at
364:48 - is going to let us remove something at a
364:50 - given index so let's say I choose zero
364:52 - so now it's going to remove 6 because we
364:55 - already removed 22 so 6 is our first
364:57 - index so 6 is going to be removed
365:00 - all right so we did all of these but now
365:05 - what if we wanted to reserve some memory
365:08 - for our array so what if you didn't want
365:10 - it to resize and search for memory so
365:12 - even those functions are available so
365:14 - let's call The Reserve function before
365:16 - all of this so our end array
365:19 - dot Reserve whoops Reserve
365:23 - and we can as we can see we have four
365:27 - elements five six
365:29 - and we remove two so we have to so we
365:33 - can reserve for but at Max we have six
365:35 - elements so let's Reserve six
365:39 - so we can call that and stuff
365:43 - so these are the most common ones that
365:45 - you'll use I won't really use all the
365:47 - other methods but again you can just
365:49 - refer the documentation if you really
365:51 - need it
365:52 - now we can go ahead and iterate through
365:55 - this array through a range based for
365:57 - Loop just like how you can with any of
365:59 - the STL data structure so you can go
366:03 - ahead and do for Loop
366:06 - Auto
366:07 - we can just call this one element
366:11 - and we can pass in the array just like
366:13 - how you would pass an STD Vector so R
366:16 - and array
366:18 - and what we can do is we can go ahead
366:20 - and print it out by calling the print
366:22 - string function so you Kismet system
366:23 - Library print string you know that drill
366:26 - by now so
366:29 - now in order to print an integer you
366:33 - actually use this function which is a
366:35 - static member of the F string class so F
366:38 - string from int is what you use
366:42 - and you can go ahead and type in Le here
366:46 - now remember if you wanted to print a
366:49 - float you would use this function known
366:50 - as sanitize float now it's going to cast
366:54 - it implicitly anyway so even float works
366:56 - for this
366:57 - and you also have other functions for
367:00 - converting between various data types
367:03 - you could again have a look at either
367:05 - the F string class or you could go ahead
367:07 - and just search it up on the
367:10 - documentation so if I actually head in
367:12 - over here so we have our sanitized plot
367:15 - here we have two hex blob from hex blob
367:20 - we have we have various functions
367:22 - basically so we have from int as you can
367:25 - see you can go through this class
367:27 - see the return type and look at what the
367:31 - function does and then you can go ahead
367:33 - and implement it accordingly
367:36 - so now I'm in the editor if I open up my
367:39 - BP character and if I actually head back
367:42 - over here we had made this blueprint
367:44 - read write so we should be able to
367:45 - access our
367:47 - and array so if I just type in our int
367:50 - array so as you can see we get it just
367:53 - like any other blueprint variable and
367:55 - since we initialized it in a Constructor
367:57 - we already have certain values now in
368:00 - begin play if we go ahead and iterate
368:03 - through this
368:04 - so I'll just do that we'll uh not call
368:06 - this function anymore now we have an
368:08 - idea of what that is
368:10 - so we have already set it up actually so
368:13 - we we have done it over here so we're
368:15 - printing stuff
368:17 - in our begin playing C plus plus so we
368:19 - don't have to set it up actually so if I
368:21 - go ahead and press play as you can see
368:23 - we have 4 12 64 43 in reverse order that
368:27 - is 43 64 12 and 4. and let's actually
368:31 - walk through the logic so we have 23 6
368:34 - 43 64. and we went ahead and added 12
368:39 - and 4 so 12 and 4 should be our last
368:42 - elements
368:43 - and we remove 23
368:45 - and we removed six so our RS should be
368:48 - 43 64 12 and 4. and if we go ahead and
368:53 - look at our logic here and our output so
368:56 - we see that we get 43 64 12 and 4. so
369:00 - this is basically how you use the tra
369:03 - class functions so this is exactly the
369:06 - same as your STD Vector but there are a
369:09 - couple differences in the function names
369:10 - and most importantly from a readability
369:13 - perspective all of these functions use
369:16 - Pascal case so it's readable compared to
369:19 - the standard C plus plus stuff which
369:21 - uses underscores which is not really
369:24 - that readable
369:26 - so this is how we would it return array
369:28 - obviously you could use a full length
369:30 - iterator but there is no actual purpose
369:32 - to do it as per my experience
369:35 - anyways let's head into the next part
369:38 - now and take a look at how else we can
369:40 - iterate through this through your
369:42 - standard C style for Loop so I won't be
369:45 - actually showing you guys the output
369:46 - since it's obvious that it's going to
369:48 - work so you just do something like for
369:51 - INT I equals 0
369:53 - I less than where now this is where we
369:56 - talk about another method in this class
369:58 - so we do I less than
370:00 - R and array dot num this is similar to
370:04 - the size function in the standard
370:06 - template libraries STD vector
370:09 - and we can do I plus plus so we can just
370:13 - increment I go to I plus plus or I plus
370:16 - equals 1. now instead of Ali since this
370:19 - is not a range base for Loop we can get
370:21 - our array
370:22 - and we can get the ith element
370:26 - now this is going to work exactly the
370:28 - same
370:30 - [Music]
370:34 - apart from RS the other data structure
370:37 - that you would use in a game is going to
370:40 - be Maps well there are linked lists and
370:42 - other data structures which you really
370:44 - won't use that very much in games
370:47 - even maps to be honest you just use it
370:49 - maybe a couple of times in your entire
370:51 - project
370:52 - but anyways in order to create a map in
370:55 - unreal basically you you use the type T
370:59 - map
371:00 - so if I just copy of the U property
371:02 - macro and in the next line you can go
371:04 - ahead and create a map
371:06 - and if you guys know about Maps
371:08 - basically it's just a key value pair so
371:11 - for example you can have two strings as
371:13 - key and value and you could have
371:15 - something like a username password key
371:17 - value pair something like that so let's
371:19 - just create a simple one let's say we
371:22 - map a string to a float
371:25 - so it's case sensitive obviously
371:29 - and we can call this one R map
371:33 - now you can't just initialize a map like
371:36 - how you would initialize an array so you
371:38 - would have to call the add or the MPS
371:40 - function multiple times that's just how
371:43 - you would do it
371:44 - so our in Array or rather R map dot add
371:49 - and what we can do is we can pass in the
371:52 - string and the float so let's say pi and
371:56 - 3.14
371:59 - then we can go ahead and call add once
372:01 - again
372:03 - so we'll just go ahead and do all of
372:04 - this in our begin play
372:10 - so let's just find some other number
372:12 - let's say num1 for example let's just
372:15 - grab in a random value
372:20 - now once that's done
372:22 - you have other methods but you aren't
372:25 - really going to be using them for
372:27 - anything but I'll just show you guys how
372:29 - to iterate through this and how to
372:31 - retrieve the key and the value so that's
372:34 - what you'll be using this most for
372:36 - now let's say I wanted to access an
372:38 - element though you could do something
372:40 - like this so let's just print out uh
372:43 - what the index num1 will contain
372:47 - so copy this over
372:49 - and instead of R and array of I what we
372:52 - can do is we can get our map
372:56 - our map
372:58 - of
372:59 - num1
373:01 - basically num1 is the key here and
373:05 - basically by doing this you're getting
373:07 - the value of it
373:09 - so in our case we mapped num1 to 43.4543
373:15 - and if you want to iterate through this
373:18 - we can use a range best for Loop here as
373:19 - well
373:21 - so we could just say Auto element
373:25 - and we can pass in our map
373:30 - and what we can do is we can get the
373:32 - element so we'll print this so we'll
373:34 - copy the code over once again
373:37 - so we'll print both the key and the
373:39 - value so let's just create a string
373:41 - variable temporarily
373:44 - and the way you get the key of this so
373:47 - each element in this map is going to be
373:50 - a key value pair
373:51 - so Le is going to be a key value pair
373:54 - what we can do is we can do Dot key in
373:58 - order to get the key
374:00 - and if we want the value we can go ahead
374:03 - and do Le dot value the way we'll do
374:06 - that here is we'll just append the
374:08 - string so basically we'll concatenate
374:09 - the two strings so what you can do is
374:11 - temp dot append
374:13 - and let's just put a call on Just for
374:16 - visual purposes
374:18 - and we can do temp dot append and since
374:21 - our value is going to be a float we can
374:24 - do F string
374:26 - sanitize float and we can go ahead and
374:30 - get arm
374:31 - value so Le dot value
374:33 - that is going to be a float
374:35 - now we can go ahead and rather than
374:37 - printing this we can go ahead and print
374:39 - in temp
374:41 - so we also learned how to concatenate
374:43 - strings on the way
374:46 - so this is how you would iterate through
374:47 - this this is how you would get a key of
374:50 - a given element in the map and this is
374:52 - how you get the value
374:54 - now remember
374:55 - you cannot have two keys of the same
374:58 - value so let's say I actually create
375:00 - another uh element with the key num1
375:04 - it's going to throw an exception you
375:06 - can't actually do that so now we'll
375:09 - actually stop printing our array now
375:11 - that we are done with that
375:12 - so if I go ahead and run a debugger now
375:16 - since everything is set up now if I go
375:18 - ahead and press play
375:19 - you would see that we get Pi 3.14 and
375:26 - num143.4543 and as you can see we also
375:29 - get our four three dot four five four
375:33 - three uh that printed first
375:37 - because we had printed our map
375:40 - of num1 so basically
375:43 - the key here is num1 and we basically
375:46 - asked for the corresponding value it is
375:48 - just as if you asked for R int array of
375:52 - one it's pretty much something like that
375:55 - so basically instead of the index you
375:59 - would pass in the key that's basically
376:01 - how you use this operator here
376:03 - now this is basically how you iterate
376:06 - through it now you could you know do
376:10 - many other things with the map
376:11 - but for the most part you'd just be
376:14 - using it to store key value pairs
376:16 - generally it's useful for having a track
376:19 - of you know game users and stuff like
376:21 - that they're really very odd audios
376:24 - cases for maps you wouldn't really use
376:26 - it that often so I'll leave this over
376:29 - here
376:31 - [Music]
376:36 - now when it comes to designing your game
376:38 - once you're actually aware about all the
376:41 - things that we just discussed over here
376:43 - up until Maps in order to actually
376:46 - Implement them in an appropriate and
376:49 - efficient manner you would use the
376:51 - classes which the engine provides us
376:54 - so we'll be going through some of the
376:56 - most important ones which will be used
376:58 - in all of the games and there are other
377:01 - derived classes of it the ones which I
377:04 - showed you guys in the flowchart
377:06 - previously when I showed the inheritance
377:09 - hierarchy those are the ones that we
377:11 - will be discussing in detail there are
377:14 - other classes we'll just be brushing
377:16 - through few with whichever are important
377:19 - but if they are not we are going to be
377:22 - just skipping through them but if we
377:24 - ever use them in the last part of the
377:26 - course
377:27 - we'll be having a look at them in depth
377:29 - once again
377:30 - so now let's start talking about actors
377:33 - now at this beginning of this video I
377:37 - actually talked a little bit about
377:38 - actors basically anything that can be
377:41 - placed in the level is an actor so that
377:44 - definition still holds good but it is
377:46 - incomplete there is another thing which
377:49 - an actor can do and that is it can tick
377:52 - now you guys have probably seen the tick
377:55 - function so let's open up an actor
377:57 - actually let's create one because all of
377:59 - these have their own base classes so
378:02 - let's create a pure actor in Blueprint
378:03 - we'll do one in C plus plus as well
378:05 - pretty soon
378:06 - or actually we probably have it so let's
378:09 - call this one BP underscore a let's say
378:14 - I just created this for the sake of it
378:16 - now if I were to actually have a look
378:19 - over here
378:20 - you would see that you have three tabs
378:23 - and the event graph is where you worked
378:26 - on for the most part but we haven't
378:28 - actually gone in depth into all of these
378:31 - little details so first let's actually
378:34 - go from the top so what we have here is
378:37 - the class settings and most of the times
378:40 - you'll just use it to implement an
378:42 - interface or change its base class but
378:45 - other than that you aren't going to be
378:47 - using it now under class defaults you
378:50 - have a bunch of things which actually
378:51 - Define what an actor actually can do now
378:55 - if you were to look at actor tick you
378:57 - have several options start with tick
378:59 - enabled tick interval and you also have
379:03 - several other things now we did talk
379:04 - about this one so I'll I'll not be
379:06 - talking about that
379:08 - but anyways all of these are
379:10 - self-explanatory and one thing which you
379:13 - won't see in any other type of blueprint
379:14 - other than actors is the replication tab
379:17 - ly if you check this replicates tab this
379:22 - actor will be eligible to be used in
379:24 - multiplayer what I mean by that is that
379:27 - when you spawn this on the server which
379:31 - we will get to when we talk about
379:32 - multiplayer basically all your other
379:34 - clients can see too by clients I am
379:36 - referring to players in this Con context
379:39 - and we have settings regarding that
379:42 - now these are just the flags these are
379:45 - pretty self-explanatory hidden in game
379:47 - and visible stuff like that
379:49 - and under the Collision tab these are
379:52 - things which we again talked about
379:54 - but there are a couple more things which
379:56 - an actor provides us the first one is
379:59 - your damage now if let's say you have
380:04 - you wanted this actor to be destroyed so
380:06 - let's actually do that
380:08 - let's go ahead and create an object so
380:12 - let's add in a model here so let's say
380:15 - we add in a sphere
380:17 - I don't know uh maybe simulate physics
380:21 - on this or let's let's leave it as is
380:24 - what we can do is unreal actually
380:27 - provides us with default logic to apply
380:29 - damage to this so if I type in
380:32 - event damage
380:34 - you see we get three of these nodes
380:37 - Point damage radial damage and any
380:40 - damage so any damage is going to refer
380:42 - to all types of Damages Point damage is
380:45 - going to be your damage through a line
380:47 - trace or something generally radial
380:50 - damage is going to be something where
380:52 - you know you damage this actor through
380:54 - grenade or something like that so you
380:57 - would have you know a distance and stuff
381:00 - like that so if I just press this so you
381:03 - have your origin so that's going to be
381:05 - where your grenade landed for example
381:08 - so it need not be a grenade could be
381:09 - anything else just give an example so
381:12 - from that point uh if as you go further
381:15 - away your damage is going to decrease
381:17 - stuff like that so let's just do event
381:19 - any any damage so any damage
381:24 - what we can do is over here we can go
381:27 - ahead and simply print this out rather
381:31 - just to demonstrate that that this
381:33 - actually works now by default unreal
381:36 - does not give you any health variable
381:37 - you got to do that yourself and one
381:40 - thing you might have noticed is this
381:41 - little icon over here at the top right
381:44 - hand side of any damage basically that
381:47 - property is called blueprint Authority
381:50 - only what it means is that you can only
381:53 - call this on the server so you cannot
381:56 - call this on the clients obviously you
381:59 - don't want your players to be handling
382:01 - the damage and stuff but anyways let's
382:04 - actually go ahead and work on this logic
382:06 - so when we left click we do the line
382:08 - Trace thingy so let's bring up the line
382:11 - Trace logic once again
382:14 - so what we can do is we can line Trace
382:17 - by Channel
382:20 - and we get our camera manager get player
382:24 - camera manager
382:26 - get the after location
382:29 - this is some stuff which we've already
382:31 - done then we get the forward vector
382:35 - and we multiply this by a certain value
382:39 - so let's just convert this to a float
382:43 - and let's multiply this by let's say 50
382:46 - 000. we are going to add this
382:49 - together
382:51 - and we can plug that into end and the
382:53 - start
382:55 - and from our output we can go ahead and
382:59 - call apply damage
383:02 - so there are multiple nodes apply damage
383:04 - apply Point damage and apply radial
383:06 - damage will do apply Point damage you
383:08 - could just do apply damage
383:10 - and base damage let's just give it a
383:12 - value of 30. or just to keep things a
383:16 - little more interesting so Random float
383:17 - in range
383:19 - so let's just say anything between 20
383:22 - and 50 Maybe
383:24 - so it's just going to select a random
383:25 - number
383:26 - and damage doctor is going to be the hit
383:28 - actor obviously and damage causer is
383:31 - going to be self
383:33 - damage type is something we won't be
383:35 - talking about and hit info we could just
383:37 - pass in this whole hit result
383:39 - so what we can do is instead of doing
383:41 - this we can recombine this
383:44 - pass this in here
383:46 - and we can go ahead and break this
383:48 - separately
383:49 - so type in Brick
383:51 - and pass the hit actor once again to the
383:54 - damage actor
383:55 - and we can collapse this as is hit from
383:59 - Direction basically uh that is going to
384:03 - be something which isn't really going to
384:05 - affect your damage
384:08 - but once you know the damage doctor's
384:13 - location you can actually find the
384:17 - direction towards it basically so what
384:20 - we can do is you can do something like
384:21 - this
384:22 - so basically use this node called find
384:25 - unit Direction so unit Direction
384:29 - so get unit Direction
384:31 - so it's going to be from our start to
384:34 - our location and this is going to be our
384:36 - hit from Direction
384:39 - so basically uh this is a position
384:41 - vector and this is a position Vector as
384:44 - well so we can subtract it to get a
384:47 - vector joining those two points
384:49 - basically and now it should compile
384:52 - if you really don't want to use this you
384:54 - can go ahead and split this and this is
384:57 - going to work as well it's just going to
384:58 - construct a vector in place
385:01 - so we'll recombine that and use that
385:03 - and if I go ahead and press play
385:05 - nothing's gonna happen but if I actually
385:08 - drag our BPA here
385:12 - and if I go ahead and press play
385:16 - so as you can see
385:19 - we are applying some random amount of
385:21 - damage
385:22 - so not sure why the lag exists
385:26 - but anyways
385:28 - now once that's done the next thing that
385:31 - an actor provides us and also just one
385:34 - one more note here so now we are talking
385:37 - about the blueprint version of this
385:39 - we'll also look at C plus plus stuff a
385:41 - bit bit later there are a few things
385:44 - that I would like to go over in C plus
385:46 - plus as well so the next thing is hit
385:49 - events now remember we had done the
385:52 - overlap for a character so somewhere
385:54 - over here so similar to that you also
385:56 - have hit events so you just type in
385:58 - event hit
386:00 - and this is how we set up hit events you
386:02 - also have hit events for each individual
386:05 - component so if I click on the sphere if
386:08 - I scroll down I can actually do on
386:09 - component hit as well that works too
386:13 - now other is going to be the actor which
386:16 - actually hit this
386:20 - and other component is basically the
386:23 - component of the other actor which hit
386:25 - it my component is going to be the
386:28 - component in this sector which actually
386:30 - hit the other actor
386:31 - and hit location is the hit location of
386:34 - course and we also get a hit result so
386:37 - way too much for what you need so that's
386:39 - generally the reason why when I actually
386:42 - work on these things I I just create an
386:44 - interface myself
386:46 - because generally you really don't
386:48 - require all of these things in order for
386:50 - your damage logic to work
386:52 - anyways I'll show you guys how this is
386:55 - gonna work so if I just go ahead and
386:56 - print this
386:58 - and one handy node here is you can
387:01 - actually get this and if you can type in
387:03 - get display name
387:04 - and you're going to get
387:07 - the display name of the object basically
387:09 - if my character bumps into this so let
387:11 - me do that real quick okay I can't it's
387:15 - too high so let's bring that down
387:19 - so if I actually bump into this as you
387:21 - can see you get BP character the reason
387:24 - it's printing it so many times is
387:26 - because we are in contact with it for
387:29 - quite some time
387:30 - so when we are in contact and we are
387:32 - sliding on it each frame it counts a new
387:36 - hit basically that's the reason it's
387:38 - happening all right so the next thing
387:40 - that I would like to touch upon when it
387:42 - comes to actors is the construction
387:43 - script so this is similar to your
387:46 - default Constructor in C plus plus now
387:48 - there is a way to actually uh get an
387:51 - equivalent of a parameterized
387:53 - Constructor I will get to that both in
387:55 - Blueprint and C plus plus but first
387:58 - let's work with this so let's say I drag
388:00 - this in now every time I update this
388:03 - actor the construction script is
388:05 - actually called so let me just show you
388:08 - guys so if I just go ahead and print
388:10 - string
388:11 - and if I go ahead and move this actually
388:13 - so first let me compile that
388:16 - save it and now if I head back as you
388:19 - can see every time I move it it actually
388:21 - prints hello
388:22 - basically every time you spawn this
388:25 - actor or you update this actor in the
388:28 - level this construction script is called
388:30 - at runtime it's only going to be called
388:33 - when you actually spawn it but over here
388:36 - in the editor whenever you move it it's
388:38 - going to be called each time there's
388:40 - actually an option somewhere in the
388:41 - class settings
388:43 - so run construction script on drag so
388:46 - you can disable that if you don't want
388:48 - that to happen so it's it's only going
388:51 - to call it once you finish placing it
388:54 - I'll just leave it as is
388:56 - now if you want a parameterized
388:58 - Constructor
389:00 - basically let's say you wanted to set a
389:02 - variable so let's call this
389:04 - uh I don't know maybe some float
389:07 - variable
389:08 - and we'll make this of type float now if
389:11 - you want to actually set the value of
389:14 - this outside like a parameterized
389:16 - Constructor
389:17 - first select this variable
389:19 - and head into
389:21 - this option right there select instance
389:24 - editable and expose on spawn
389:27 - now what you've essentially done is your
389:29 - basically exposed this when you actually
389:32 - call the spawn act a function
389:35 - so if I just head into my character and
389:37 - spawn this on begin play so I'll just
389:39 - leave this BP pickup and let me just do
389:42 - this actor instead so BP underscore a
389:46 - now Health points is not a parameter so
389:49 - you can alt click that to delete the pin
389:51 - now as you can see
389:53 - we can select some float
389:56 - so I can set this to whatever I want
389:59 - now this is something which we touched
390:02 - upon
390:03 - however there is an equivalent of this
390:06 - in C plus plus as well
390:09 - but it is a little more complicated than
390:11 - this
390:12 - so if we actually head into our Visual
390:15 - Studio solution
390:18 - all right so now that we are in C plus
390:20 - plus now let's actually test it out with
390:23 - our CPP underscore actor so let's go
390:27 - ahead and spawn this from our character
390:30 - or if we have anything else we could try
390:32 - that as well so our interaction actor
390:35 - maybe if we could try that so we can
390:38 - spawn our interaction actor
390:40 - now if we go ahead and head in here
390:45 - inside our character's header file
390:49 - so we can go ahead and include that as
390:51 - well so hash include
390:54 - and we can go ahead and include CPP
390:57 - interactionactor.h
391:01 - now let's actually create a function or
391:03 - we can do it on begin play so head into
391:05 - begin play
391:07 - now after we are done with this or we
391:09 - can actually just remove this logic we
391:11 - aren't really using this
391:13 - the way you spawn actors in C plus plus
391:15 - is by calling the spawn actor function
391:18 - from world
391:20 - so in order to get your world you call
391:21 - this function known as get word
391:25 - and from here you can go ahead and call
391:28 - spawn actor
391:30 - and this actually takes in a template
391:33 - argument
391:34 - and this is going to be the type which
391:37 - this spawn actor function will return
391:40 - so it is going to be acpp interaction
391:43 - actor
391:44 - and I could just spawn it like that it's
391:46 - going to take in all the default
391:48 - parameters you can actually set up
391:49 - subclasses and stuff so let's say
391:51 - instead of CPP interaction actor you
391:54 - want it to spawn some derived class of
391:56 - it which is there in Blueprint you could
391:58 - do that totally
392:00 - so let's say I wanted to spawn BP
392:03 - interaction actor and not CPP
392:05 - interaction actor so we can actually
392:06 - test that theory actually
392:09 - so BP
392:11 - interaction actors pond
392:15 - I mean the spelling doesn't really
392:17 - matter here
392:18 - so let's delete whatever's there in the
392:21 - level so BP interaction actor
392:24 - so interaction actor so I'll just go
392:27 - ahead and delete that now if I press
392:29 - play I'm not really getting that
392:32 - so what I can do this is going to spawn
392:35 - your CPP interaction actor
392:37 - but if we actually have a variable here
392:40 - which stores the exact class which we
392:43 - are spawning so we can do that right
392:45 - there so you property
392:48 - make this one edit anywhere
392:54 - and make this one blueprint read write
392:56 - as well
392:59 - now what we can do is we can go ahead
393:01 - and pass this in so the type which you
393:04 - use is T sub class of
393:08 - and obviously we are looking for a
393:10 - derived class of
393:13 - acpp interaction actor so we'll just
393:16 - copy that over
393:18 - so this is going to be prefixed with an
393:20 - a
393:21 - and we'll call this one class to spawn
393:24 - or rather we can call it actor to spawn
393:28 - now this will be available to us in our
393:30 - blueprint
393:32 - now one thing to remember you have to
393:33 - make sure it is actually valid
393:36 - so if
393:37 - r
393:40 - reference is valid here so our subclass
393:42 - is basically so if this class reference
393:45 - so if actor to spawn is valid
393:48 - only then we are actually going to be
393:51 - spawning this actor
393:53 - and over here in the arguments list you
393:55 - can go ahead and pass this in
393:58 - and paste this in
393:59 - and you can also pass in a transform
394:01 - optionally but I won't be doing that
394:05 - now let's actually pass in some
394:07 - parameters
394:09 - so if you want to pass in a parameter
394:11 - using your deferred spawn actor as I
394:15 - would call it as the function is called
394:17 - so we can actually do that with the same
394:20 - thing
394:21 - so let's create a variable here which we
394:24 - would want to edit
394:26 - so under the public section we can go
394:28 - ahead and create a new property
394:31 - we don't need this to be blueprint read
394:33 - write or anything so we can call this
394:35 - one in
394:36 - some variable
394:40 - and the way you would set default values
394:42 - for this
394:43 - is if I go ahead and write the function
394:46 - again so this is how it's spawn an actor
394:49 - here you would have what's going to be
394:52 - returned so if I actually do Auto
394:55 - temp equals
394:58 - spawn actor interaction actor basically
395:01 - this temp will be of type ACP
395:04 - interaction actor pointer so pointer to
395:07 - this point actor will be uh returned
395:11 - now
395:12 - what what we can do is we can spawn
395:14 - another one actually so we'll just do
395:16 - Auto
395:17 - temp one equals
395:20 - we can just go ahead and copy this
395:23 - and instead of this we can do spawn
395:26 - actor deferred
395:30 - and just make sure to get the spelling
395:32 - right so spawn actor
395:35 - deferred so for this one we have to pass
395:39 - in the transform so we can just uh write
395:42 - a Constructor over here so F transform
395:48 - and that should compile but once you
395:51 - call this function the actor is actually
395:53 - not spawned now since we have a pointer
395:56 - to our actor we can go ahead and call
395:59 - this function known as finished spawning
396:02 - so if I type in Finish spawning this is
396:06 - going to actually complete the spawning
396:08 - process
396:09 - now you can just again pass in the
396:12 - default transform
396:16 - so once this is done
396:18 - our spawning would actually be complete
396:21 - and in between this is where you can
396:23 - actually set your variables
396:26 - so you don't have a parameterized
396:28 - Constructor but now we can go ahead and
396:30 - set our some variables so some variable
396:32 - equals 100.
396:34 - obviously temp one
396:37 - and now what we can do is in our
396:40 - interaction actor we can go ahead and
396:42 - just print it on begin play so you
396:44 - Kismet system Library print string and
396:48 - we can go ahead and
396:53 - continue with this and go ahead and
396:56 - print in
396:57 - F string
397:00 - from end
397:01 - and we can pass in our value here so
397:05 - some variable
397:07 - is what we want
397:11 - and that should be about it
397:15 - now if we go ahead and run a debugger
397:18 - here everything should work as expected
397:20 - just make sure you close the editor
397:23 - before you actually build it so
397:27 - so now if we go ahead and press play we
397:30 - shouldn't see any print strings
397:32 - and this proves that our if check here
397:35 - is actually working if we would have
397:38 - removed this if check our engine would
397:40 - have crashed since this actor to spawn
397:43 - class reference would be invalid anyways
397:46 - we can set that since we have exposed it
397:48 - to blueprint so in our character I
397:50 - assume so this is in CPP character so
397:53 - it's going to be inherited into BP
397:55 - character
397:56 - and under your class defaults over here
398:01 - you should be able to find your variable
398:06 - so CPP character under the third section
398:09 - here actor to spawn and we can select
398:12 - our BP interaction actor if I go ahead
398:15 - and press play now as you can see we get
398:17 - two prints along with one zero and one
398:21 - hundred for our
398:22 - Pond actors now the first ones are 0
398:25 - because in our first Pawn actor function
398:27 - we actually didn't set any of the values
398:30 - so this was our class X Pawn actor
398:34 - and in the second one we actually use
398:36 - the Deferred spawn actor which let us
398:40 - set the default values before calling
398:42 - the construction script
398:44 - so this is basically how we would
398:46 - simulate the parameterized Constructor
398:48 - in Unreal Engine in both blueprint as
398:52 - well as C plus plus
398:54 - [Music]
398:58 - now the next class that I would like to
399:01 - mention here is going to be the
399:03 - character class and we have used that
399:06 - quite a bit so if we just open up our BP
399:08 - character for example which is a
399:10 - character class so we have inherited
399:12 - from CPP character just to keep things
399:15 - clean and just create a new character
399:16 - here
399:17 - and let let this just be called new
399:20 - character Maybe
399:22 - now open it up now if I were to just
399:26 - look at the parent class it says
399:28 - character
399:29 - and character is actually a derived
399:33 - class of Pawn so basically every
399:36 - character is a pawn and pawn is a
399:39 - derived class of actors so when I'm
399:42 - talking about characters I am
399:44 - collectively referring to both pawns and
399:47 - characters basically
399:49 - every character is going to be a pawn
399:51 - now
399:53 - the reason why I especially wanted to
399:55 - mention this even though this is
399:57 - technically just a derived class of
399:59 - factor and probably probably many other
400:01 - classes which I'll mention further are
400:03 - derived class of factors is due to this
400:06 - character movement component now this
400:08 - allows you to do various things now if
400:11 - you were to just go ahead and look into
400:14 - these parameters
400:15 - you can actually have a pretty basic
400:17 - idea on what you can do at the beginning
400:19 - of the course if you remember I had
400:22 - mentioned that you can actually use
400:24 - functions to modify almost any of these
400:28 - values not all but most of these values
400:30 - at runtime so for example now let's just
400:33 - take our BP character for example and
400:36 - let's go ahead and press play and we
400:38 - know that we're using this
400:40 - so we are walking forward but what if
400:44 - this feels a little bit too fast for you
400:46 - now this is where our character movement
400:49 - component is going to help us
400:51 - so the maximum speed of this character
400:54 - is actually set by a variable inside
400:56 - here so if I just drag this in and if I
400:59 - type in set max
401:02 - walk speed
401:04 - as you can see we are able to set some
401:07 - value over here so I'll just do this on
401:09 - begin play you could do it somewhere
401:11 - else as well
401:12 - but let's say we wanted him to go only
401:14 - at 500 default is 600 by the way
401:18 - now if I go ahead and press play you see
401:20 - that he moves a little bit more slowly
401:22 - now if you feel this is a now one more
401:26 - thing is that the animation will also
401:28 - slow down along with his speed so that's
401:30 - not something which you should really be
401:31 - seeing in this example
401:33 - so we are moving slower let's say we
401:35 - wanted him to move a little more fast so
401:37 - let's say we have 1000
401:39 - we can go ahead and set the speed and
401:42 - now we walk much much faster
401:44 - so stuff like this
401:46 - and one more useful thing which the
401:49 - character movement component provides us
401:51 - is movement modes so if I just type in
401:53 - movement mode
401:55 - and get movement mode you can actually
401:58 - see this is an enumeration we can just
401:59 - do switch to see what are the
402:01 - enumerators here as you can see we have
402:03 - walking nav mesh walking which is for AI
402:06 - basically falling
402:08 - swimming flying and Custom
402:12 - now there are various things you could
402:14 - even do with this uh apart from
402:16 - switching between them you can actually
402:17 - set the movement mode
402:20 - so for example if I just change this to
402:23 - Flying for example
402:26 - and if I go ahead and press play
402:30 - now you will notice that this behaves a
402:33 - little bit differently now if the
402:36 - movement mode is flying
402:37 - if I go further
402:40 - as you would see
402:42 - he's actually floating in the air
402:44 - so when you actually set this movement
402:46 - mode to Flying basically it also allows
402:49 - you to take vertical movement input so
402:52 - apart from your move forward and
402:54 - backward you could also do up and down
402:56 - so let me actually do that so where we
402:58 - have our add movement input instead of
403:01 - forward if I do up Vector so get actor
403:05 - up Vector
403:07 - if I just do something like this and if
403:10 - I go ahead and hit W as you can see we
403:12 - can actually go up and down as well
403:16 - so this is something cool which you
403:17 - could do and there are a few functions
403:19 - which I would specifically like to talk
403:21 - about right now and one of them is
403:24 - launch character launch character so
403:27 - let's say I wanted to implement a jump
403:29 - pad or something so let's just do it
403:31 - after a delay so
403:34 - delay of about 2 seconds
403:37 - and we can go ahead and give something
403:40 - for the launch velocity let's just give
403:41 - 10 000 Maybe
403:44 - now if I go ahead and press play
403:47 - as you can see
403:49 - we were launched in the air I mean I
403:51 - just gave a really high value for the
403:53 - launch velocity let's say we give
403:55 - something like 3000 Maybe
403:58 - if I go ahead and press play
404:01 - as you can see we are launched in the
404:03 - air so if you had something like a jump
404:05 - pad or something which you wanted to
404:07 - implement this is a really cool way to
404:09 - do this and the best part about all this
404:12 - is this is actually networked by default
404:14 - most of this logic if you just run on
404:17 - the server is just going to run well for
404:20 - multiplayer as well
404:22 - so that's one thing so launch character
404:24 - and stuff like that there are actually
404:27 - many other functions which
404:29 - you would have access to one way to
404:32 - actually take advantage of the context
404:34 - sensitive menu is if you just drag off
404:36 - of self
404:37 - and if you can just head into character
404:42 - you can actually look into various
404:45 - functions over here
404:47 - this is what I find useful you can act
404:49 - apart from launch character few more
404:52 - functions which I would like to go over
404:53 - or Crouch
404:55 - so if you set your movement mode to
404:57 - crouch
404:58 - and make sure you have you can Crouch so
405:01 - there should be an option somewhere here
405:03 - so Crouch
405:05 - should be under character movement can
405:07 - Crouch make sure that is true
405:09 - otherwise it's not gonna work make sure
405:11 - this is true and if you go ahead and hit
405:13 - Crouch
405:14 - and one thing that I would like to show
405:16 - you guys is by setting this hidden in
405:20 - game to false so let this be visible in
405:22 - the game
405:24 - now if I go ahead and take a look at
405:27 - this
405:29 - as you can see everything seems normal
405:31 - here
405:32 - let's actually just disable some of this
405:35 - logic
405:38 - all right so I'll go ahead and Crouch
405:43 - so if I go ahead and Crouch as you can
405:45 - see
405:46 - our
405:48 - capsule whatever we had is actually
405:50 - shrunk
405:53 - this is basically our Collision now so
405:56 - let's say you couldn't pass under some
405:58 - things now you can actually so I'll just
406:00 - drag this a little bit below average
406:03 - character height
406:05 - so let's say about this much
406:08 - and our walking speed is also very less
406:10 - even though we set it to thousand
406:12 - manually now as you can see our
406:14 - Collision is only up to the capsule you
406:16 - can change the height by the way
406:18 - so if I just type in Crouch I should
406:22 - find Crouch half height you can actually
406:23 - increase that no issues with that and as
406:26 - you can see now this has a separate Max
406:28 - walk speed so stuff like this is already
406:31 - implemented for you in the engine now
406:34 - all you have to do if you really want to
406:36 - learn more is just browse through this
406:39 - list just look at something which might
406:41 - be useful so let's say you're doing
406:43 - multiplayer but have a look at this now
406:45 - this is not something which would really
406:48 - be that helpful to be honest
406:50 - but there may be a few settings which
406:52 - you might actually find helpful
406:56 - now there are many many more things
406:59 - which you can do and if you aren't able
407:02 - to actually write a certain mechanic
407:05 - using these nine out of 10 times you're
407:08 - just doing it wrong it's just one out of
407:11 - maybe 10 20 times that
407:15 - the engine is actually deficient of
407:17 - features
407:18 - so just like this you could go ahead and
407:20 - explore this for yourself all of those
407:23 - parameters which we saw in Blueprint are
407:26 - also accessible in C plus plus there is
407:28 - nothing special really so for example
407:31 - let's say I wanted to crouch so I can
407:34 - just type in Crouch as you can see the
407:37 - method Crouch exists here as well
407:40 - ah not only that if I want to access my
407:43 - character movement based functionality
407:45 - there is actually a get function for it
407:47 - so get character movement is the
407:49 - function name
407:51 - so this is going to return a U character
407:53 - movement component pointer so once we
407:56 - actually have access to that so let's
407:58 - say Auto Temp 2 equals okay it's in a
408:02 - different scope so we can reuse temp
408:05 - so Auto Temp equals
408:07 - get character movement and now we can
408:10 - use this variable in order to just call
408:12 - our regular functions so for example if
408:15 - we want to change a movement mode so we
408:17 - can type in
408:19 - whatever the function was over here
408:22 - so movement mode
408:26 - so set movement mode was the function
408:28 - name
408:32 - set movement mode
408:37 - now clearly it's not happy with us using
408:40 - this type but fix for this pointer to
408:43 - incomplete class type so the simple fix
408:46 - for this is to just look up the
408:47 - documentation for the header here we
408:49 - don't have the character movement
408:50 - component header file so we'll just
408:53 - paste that in our dot h
408:55 - and now if you go ahead and look at this
408:58 - this should work and now we get the
409:00 - options for the parameters
409:03 - so for this let's actually type in
409:06 - e movement mode
409:13 - and we have move flying for example
409:17 - and then new custom mode we can just set
409:20 - this to zero
409:22 - so like this you can set the movement
409:24 - mode in C plus plus
409:27 - so stuff like this is going to be
409:29 - analogous to both blueprint as well as C
409:31 - plus plus however note that some of
409:34 - these headers aren't actually included
409:36 - by default so make sure you just go
409:39 - ahead and include them before you start
409:40 - working with them
409:43 - [Music]
409:48 - so we are inside the BP player
409:50 - controller class
409:51 - and we have dealt with this before but
409:54 - going a little bit more deeper player
409:57 - controllers or controllers in general
409:59 - are designed to handle input
410:02 - so if we actually bring in an input
410:05 - binding so for example I just type in w
410:07 - on the keyboard
410:09 - so what's going to happen is
410:12 - this input will actually be taken over
410:15 - our input bindings which we set up in a
410:18 - character so if I just print a string
410:20 - we'll actually not move instead we'll be
410:23 - printing hello
410:24 - so that's one thing to note other than
410:27 - that the mouse interface has several
410:30 - important functions such as show mouse
410:32 - cursor enable click events enable mouse
410:35 - over events and stuff like that all
410:37 - these are self-explanatory one thing to
410:40 - note is that your Pawn or your character
410:42 - obviously is going to be possessed by a
410:46 - player controller and without apply
410:48 - controller you can not actually control
410:50 - your character and all of these are
410:53 - actually set inside your game mode
410:56 - so which black controller class you use
410:59 - is decided by your game mode class which
411:01 - we will talk about soon game mode game
411:03 - State player State and play controller
411:05 - all of these work in conjunction a
411:07 - player controller is going to possess a
411:09 - pawn which you can control
411:11 - now once that said there are a few other
411:14 - functions which are important here such
411:16 - as set input mode game only which will
411:19 - take your game input basically and when
411:23 - you have set input mode game and UI only
411:26 - so in that case you are going to be able
411:29 - to interact with widgets as well as take
411:32 - player input in the game
411:35 - similarly UI only is going to disable
411:37 - your keyboard input entirely so stuff
411:40 - like that functionality regarding input
411:42 - is available in your player controller
411:46 - [Music]
411:51 - despite using all of the above mentioned
411:54 - classes it is technically impossible to
411:57 - set up a well playable game
412:00 - so we have a few more classes which
412:02 - actually set up the whole framework to
412:05 - actually start developing the game logic
412:08 - itself
412:09 - and those are game mode game State and
412:13 - the player State now the play State
412:15 - isn't that important but the game mode
412:17 - and game state will provide you with all
412:20 - the functionality that you need in order
412:22 - for your gameplay logic to work so we
412:24 - have already created a game mode
412:26 - know that every level will have one game
412:29 - mode and you have to set that
412:31 - and the important part here is
412:34 - these classes this can be set over here
412:38 - in the world settings
412:40 - and upon class is as as expected BP
412:44 - character however this can be changed at
412:47 - runtime in the sense you can possess a
412:49 - different Pawn the default is going to
412:51 - remain the same but you can call the
412:53 - possess function on your play controller
412:55 - so let me actually show that so let's
412:57 - say I'm on new character right now
413:02 - so now I can't move or do anything
413:04 - however if I head into my game mode
413:11 - and let's say after begin play
413:14 - I just give a delay of few seconds
413:18 - so delay and I give let's say three
413:21 - seconds or two seconds
413:23 - and I get my player controller
413:26 - now note this is a single player game so
413:28 - this works otherwise anything that you
413:30 - do will be with respect to the server
413:33 - game mode in a multiplayer game will
413:35 - only exist on the server that's one
413:38 - thing to note
413:39 - so from here we can type in possess
413:43 - and what we can do is we can just spawn
413:45 - a character so where our player start is
413:48 - you can just copy this over let's say
413:51 - or you can have a Target Point instead
413:55 - so just type in Target point
413:58 - drag this in
414:00 - and get the location
414:04 - so we have something like 10
414:06 - negative 11420
414:10 - so head into the game mode class
414:15 - for an actor
414:19 - select BP character for example
414:23 - so BP underscore character and for the
414:27 - transform
414:28 - negative 11 420
414:33 - and we'll do 350 for the Z
414:38 - and for the pawn this is going to be the
414:41 - pawn which we will possess
414:44 - now if I go ahead and press play wait
414:47 - for two seconds and as you can see we
414:50 - have possessed our BP character
414:53 - so stuff like this you can easily set up
414:57 - in
414:58 - your game mode so anything such as this
415:03 - which is handled on the server is done
415:05 - in the game mode but the game mode isn't
415:08 - really limited to this
415:10 - the game mode has several functions such
415:13 - as post login
415:16 - and you also have other things such as
415:21 - on
415:24 - log out
415:27 - so this is basically when you join the
415:30 - game in a multiplayer game this is
415:33 - basically when you leave the game or you
415:36 - disconnect
415:37 - so you'll still have all the references
415:40 - available to you
415:42 - so that's where you'll use the game mode
415:46 - foreign
415:57 - however let's say you wanted to store
415:59 - something like a timer now the timer has
416:02 - to be in sync with everyone
416:04 - so obviously it has to be on the server
416:07 - but all your other players must be able
416:09 - to read it at least so in that case you
416:12 - use a class known as game state which
416:15 - does the exact same thing
416:17 - so if I just type in game state
416:22 - I'm going to use Game State base game
416:24 - state is basically game State based with
416:25 - a few extra functions
416:28 - so let's call this one DP underscore
416:31 - gamestate oops BP
416:34 - game state
416:36 - open it up
416:38 - and ignore the viewport and stuff
416:39 - doesn't really matter
416:41 - and once you have this
416:43 - over here we can have something like a
416:45 - match timer so I'll create a new
416:47 - variable and call this one timer
416:50 - so I'll make the subtype integer
416:53 - over here we can go ahead and start the
416:55 - timer so set timer by function name
416:59 - we can go ahead and create a simple
417:00 - custom event here so custom event and we
417:04 - can go ahead and call this one for
417:06 - example timer increment
417:11 - you can copy the name paste that in we
417:14 - want it to run every one second we want
417:17 - it to be looping and it has to run till
417:19 - the end of the game
417:21 - so we can do timer plus plus
417:26 - now this uh value of timer over here can
417:31 - be read by
417:32 - your widgets and stuff like that so
417:35 - there's actually a function which you
417:36 - can use for this so let's do that in our
417:39 - widget
417:40 - head into your UI
417:43 - HUD BP HUD
417:45 - and where we have our stuff set up
417:49 - so let's actually revert our character
417:52 - settings so change the character to BP
417:56 - character
417:58 - and over here for the spawn actor as
418:00 - well we'll remove that for now
418:03 - for now we'll forget about it
418:06 - over here where we actually create our
418:08 - HUD this is where we have our reference
418:11 - so what we can do is we can actually
418:13 - create some more text here so we can
418:15 - type in timer so whoops you can type in
418:18 - text
418:21 - drag in some text here
418:23 - maybe just increase the font a bit
418:27 - and we can go ahead and have
418:30 - has to be light
418:32 - anchor it to the top right hand side
418:36 - and instead of this we can go ahead and
418:39 - set this to be whatever the timer is
418:42 - so in our game state every time this
418:44 - happens we have to update it
418:47 - so what we can do is we can get our
418:49 - player controller here we don't have a
418:52 - reference to it currently so get player
418:55 - controller
418:57 - we'd have to cast it to our BP player
418:59 - controller cross to BP player controller
419:04 - now we can do this on begin play
419:07 - and we can store a reference in a
419:10 - multiply again this is not going to work
419:11 - obviously
419:13 - so promote this to variable and type in
419:15 - pcrf maybe
419:18 - for play controller f
419:20 - you can go ahead and update
419:23 - okay we have a update Health function we
419:26 - can create an update timer function so
419:29 - custom event
419:31 - update timer
419:33 - and this should work as is so give
419:37 - the timer value to this
419:40 - so type in timer
419:43 - get a reference to your HUD
419:46 - make sure this is variable and we'll
419:48 - call this one timer text
419:52 - make sure you compile this
419:54 - so
419:56 - timer text
419:58 - set text
420:00 - and we can set this to be whatever this
420:03 - timer reads obviously you can use format
420:06 - text and you can make this show minutes
420:08 - seconds and stuff like that
420:11 - so we have our timer so we can do format
420:14 - text
420:16 - so format text
420:18 - we can have minutes
420:23 - colon seconds
420:27 - something like this
420:30 - so make this
420:32 - in curly braces
420:35 - and our timer by 60 is going to be our
420:40 - minutes
420:42 - and our timer mod 60 is going to be
420:47 - seconds
420:49 - however we also have one more parameter
420:52 - which we need to take care of is if this
420:57 - value is less than 10 we want to append
420:59 - a 0 at the start
421:01 - so divide so rather convert this to a
421:04 - string first
421:07 - so
421:09 - to string
421:12 - and once we have the string we can check
421:15 - if this is actually less than 10
421:20 - and if it is less than 10
421:26 - you can use a select instead so select
421:31 - so if it is true and if it's false
421:34 - we need separate things
421:37 - so if this is going to be greater than
421:41 - 10 which means this is going to be false
421:44 - so we directly want to print that out
421:47 - but let's say this is less than 10 we
421:49 - want to append a 0 here so append
421:54 - type in 0 and then we want to print the
421:57 - seconds
421:58 - so some simple logic like this
422:01 - now we can go ahead and test this out
422:04 - and if you were to look at the top right
422:06 - hand corner it does not update because
422:08 - we have to set the game State as well
422:11 - so if I just select BP underscore game
422:13 - State over here
422:15 - and if I go ahead and press play
422:18 - this should technically work but it's
422:21 - not
422:22 - so let's have a look
422:24 - under our BP games that we have our
422:27 - black controller and we are actually not
422:28 - calling the update function so update
422:30 - timer
422:32 - now this function should work as normal
422:34 - so the timer is going to be the value
422:37 - which we get over here
422:39 - and on begin play we can just set the
422:41 - timer to zero so we'll just call the
422:43 - update timer function once
422:45 - I go ahead and press play
422:47 - as you can see our timer works and it
422:50 - increments every second
422:52 - and if we just give it a little bit of
422:54 - time so we have a runtime error here
422:57 - we'll take care of that
422:58 - so it says assessment trying to read
423:01 - property HUD
423:03 - this so this error is in apply
423:06 - controller the reason is uh when the
423:08 - game state is actually created the
423:10 - player controller isn't actually yet
423:12 - created
423:13 - so that's the reason why or rather the
423:17 - player controller is created too but the
423:19 - HUD does not get created
423:21 - so once this begin place called our
423:23 - heart is created so a simple fix for
423:26 - this is to get a validated get
423:29 - and if it is valid we are going to set
423:32 - this text and we shouldn't get any
423:33 - errors now
423:36 - anyways as soon as we create this HUD we
423:40 - can go ahead and update the timer
423:42 - oops update time
423:46 - and we can set it to zero
423:48 - for a timer variable we can actually set
423:50 - it to some higher value right now so
423:52 - that we go ahead and test out the
423:55 - minutes part of it so let's just set
423:57 - this to something 65 it should start at
423:59 - one minute and five seconds
424:01 - so one minute and six seconds seven
424:04 - eight nine ten and our logic works
424:08 - properly so for stuff like this you
424:10 - would use the game state
424:12 - now the game mode is going to drive the
424:14 - actual logic itself behind your game
424:17 - functionality
424:19 - but let's say you wanted to access all
424:21 - the players information
424:23 - you would do that through the player
424:25 - State class
424:26 - so I'll just be vague about it and if
424:29 - you right click in your game State and
424:30 - type get layer array
424:33 - you can actually get an array of player
424:35 - States so you can actually Loop through
424:37 - this in fact
424:39 - and we can get stuff like the player
424:42 - name so get player name
424:44 - and for multiplayer games you can get
424:46 - the unique net ID
424:50 - so for these things basically any
424:53 - details which all players need to have
424:56 - access of at all points of time those
424:58 - are the things which your player state
425:01 - will hold
425:02 - so that's about it basically and one
425:05 - last class that we have left to talk
425:07 - about which is important is going to be
425:09 - our game instance then we can head into
425:12 - more advanced stuff and we can have an
425:14 - example project created
425:17 - [Music]
425:22 - unlike all the other classes which we
425:24 - spoke about till now the game instance
425:26 - is kind of special
425:28 - the game instance behaves very
425:30 - differently compared to all of these
425:32 - classes so if I actually just open up my
425:34 - game mode for example so I will open up
425:36 - the main menu first things first maps
425:39 - and our main menu level
425:41 - and now in my uh game mode
425:45 - I'll just go ahead and print stuff so
425:49 - I'll just print
425:51 - host login
425:53 - and I'll just type in log out maybe
425:58 - so log out
426:00 - and we can also have
426:02 - event destroyed
426:05 - event end play
426:08 - so we'll just go ahead and print stuff
426:10 - over here as well
426:11 - so destroyed
426:16 - I'm just doing this in the game mode but
426:18 - this could be in any other class
426:20 - and this is going to be end play
426:24 - all right so if I go ahead and press
426:27 - play right now and if I go ahead and
426:29 - press play as you can see our post login
426:31 - was called
426:32 - and as soon as I close it or rather I
426:36 - should switch levels because
426:38 - if I close the game the logic isn't
426:40 - really going to be executed so I'll just
426:42 - type in open
426:45 - main menu level
426:47 - as you can see our logout function was
426:49 - called
426:51 - so what I'm trying to say here is that
426:55 - this game mode class will not persist
426:58 - between levels
427:00 - so once you log out this game mode
427:03 - reference whatever we have is not going
427:05 - to persist
427:07 - now forget about the game mode reference
427:09 - you can't even access it from anywhere
427:12 - else so let me actually show you guys
427:15 - using the game instance the special
427:17 - thing about the game instance is that
427:19 - when you switch levels
427:21 - your game instance will still remain the
427:23 - same when you open up the game an
427:26 - instance of the game instance is created
427:29 - so basically an object of type game
427:31 - instance is instantiated and that is
427:33 - going to remain the same so go to
427:36 - blueprint Class Type in game instance
427:40 - and over here we can name this our game
427:44 - instance our rgi
427:46 - anything you want
427:48 - you could put a BP underscore you can
427:50 - have a C plus plus class as well but I
427:53 - don't really find the point in having a
427:55 - base class for this one
427:56 - now instead of begin play we'll actually
427:58 - find events such as event in it
428:02 - so this is when
428:03 - your game actually starts so if I go
428:06 - ahead and print this out if I type in
428:09 - init
428:11 - and if I head into my project settings
428:14 - type in game instance I can actually
428:18 - change this to bprgi
428:21 - if I press play and if I press play
428:24 - again
428:25 - or rather I'll head into the level and
428:27 - do it
428:29 - if I press play you'll notice that
428:33 - init isn't even printed here in the
428:35 - console
428:37 - but it was printed way before everything
428:39 - else that's why it's way down at the
428:41 - bottom over there the reason is even
428:44 - before the viewport was properly spawned
428:46 - and even before it started logging stuff
428:50 - the event in it was actually called so
428:51 - the event and it basically refers to
428:54 - when you start the game not when you
428:56 - open up a level or not when you create
428:58 - something else
429:01 - now one thing which I want to show you
429:03 - guys is I'll head into blueprint head
429:06 - into our game instance I'm going to go
429:09 - ahead and call the get game mode
429:10 - function
429:12 - and I'll go ahead and promote this to a
429:14 - variable
429:15 - and let's not name it it's fine
429:18 - and then what I want to do
429:20 - is after a while
429:24 - so let's say I switch from one level to
429:27 - the other now I'm going to go from this
429:28 - level to the main menu level
429:31 - so I'll head into main menu level
429:34 - and in the level blueprint here I'll
429:37 - just access the game instance get game
429:39 - instance
429:42 - and we can cast it to bprji this can
429:45 - always be a pure cast because it will
429:47 - never fail
429:49 - and over here get
429:52 - whatever the variable was called I think
429:54 - it was called new variable zero
429:57 - and we can go ahead and right click and
429:59 - convert this to a validated get
430:03 - we can go ahead and print it
430:05 - and we can say not valid
430:10 - and this is going to be if it is valid
430:13 - so valid
430:17 - so if I go ahead and I'll actually leave
430:20 - a bit of a delay here
430:23 - oops delay
430:25 - let's say about a second not more than
430:28 - that
430:31 - so if I go ahead and head into my level
430:33 - again and if I press play
430:36 - as you can see everything works normally
430:39 - but I'm going to go ahead and type in
430:40 - open main menu level
430:43 - and as you can see I get not valid
430:46 - so what this exactly means is that our
430:49 - game mode object
430:51 - which was created when we loaded the
430:54 - level because game mode objects are
430:57 - specific to a given level as soon as we
430:59 - change the level
431:00 - our BP game mode object was destroyed
431:03 - and whatever game mode we had over here
431:06 - in our main menu level so this is none
431:08 - so it's just going to take game mode
431:09 - base
431:10 - so that object was created
431:13 - however our game instance was still the
431:16 - same so if I actually store a reference
431:19 - to the game instance somewhere else that
431:21 - is still going to be completely valid
431:24 - throughout our game
431:26 - so anything that is persistent between
431:28 - levels you would have it set in the game
431:31 - instance generally you would handle save
431:33 - games and stuff like that through the
431:35 - game instance because even if a player
431:39 - exits a level your save game logic and
431:41 - stuff should be able to work
431:43 - and stuff like settings and all those
431:46 - things are what you would put inside the
431:48 - game instance anything related to file
431:51 - handling will also be put in the game
431:53 - instance
431:54 - and many other things regarding
431:56 - networking uh in general outside the
431:59 - game is going to be in the game instance
432:01 - for example a database
432:03 - you could handle it through the other
432:05 - classes as well but this is going to be
432:07 - the safest way since this class is going
432:10 - to have itself instantiated throughout
432:12 - the program in in our case the game
432:16 - and even when you actually exit the game
432:19 - we have events shutdown rather than
432:21 - event destroyed or event end play so if
432:24 - I just type in print string
432:27 - and if I just exit nothing's really
432:29 - going to happen because the viewport is
432:32 - already destroyed by the time the
432:34 - shutdown is called
432:37 - so stuff like that let's say you had to
432:40 - close out some connections or something
432:41 - you could do that through your event
432:43 - shutdown let's say you have a database
432:45 - or something like that just give give an
432:47 - example
432:48 - anything that's persistent between
432:50 - levels you would use the game instance
432:53 - and one thing which should be obvious by
432:56 - now but I wanted to mention is each
432:59 - player in a multiplayer game will have
433:00 - his own game instance and you cannot put
433:05 - in-game networking code in this you can
433:07 - put networking code but whatever's
433:09 - outside the game if you have any in-game
433:12 - networking code you there is absolutely
433:14 - no reason to use the game instance
433:16 - there is no use of calling rpcs through
433:21 - the game instance since one player's
433:23 - game instance is in nowhere related to
433:25 - the other players game instance so if I
433:28 - actually start two instances of the game
433:30 - let's say I have two players
433:35 - even though they may be connected
433:38 - your game instances will be different so
433:42 - this player will have a different game
433:44 - instance unlike the game State or the
433:46 - game mode where it's going to be common
433:48 - for one game so let's say two players
433:52 - are connected both of them will have one
433:54 - game modern game stat in common which
433:56 - will be created on the server but in a
433:59 - game like this game instances will not
434:01 - be the same so I should have done listen
434:03 - server or client so Standalone in
434:07 - Standalone even game mode game State and
434:09 - classes like that will be different
434:10 - because in Standalone you are not
434:12 - actually connected
434:14 - but in any case your game instances are
434:17 - never associated with each other
434:20 - [Music]
434:25 - so with all the knowledge that you have
434:27 - now you should be able to create an
434:28 - entirely complete single player game in
434:32 - Unreal Engine 5. of course you will need
434:34 - to refer the documentation at times at
434:37 - times you will need to mess around with
434:38 - stuff but this much of knowledge should
434:41 - be enough for you to create a complete
434:42 - Game completely functional game using
434:45 - all of unreal score features however I
434:50 - am aware that I didn't touch upon
434:51 - particle effects and audio that sounds
434:55 - uh we will take a look at that when we
434:58 - actually create a practical game I am
435:00 - not a VFX artist nor am a sound design
435:03 - personally so that's the reason I didn't
435:06 - touch over them but we will go over some
435:08 - resources which you can use and I'll
435:10 - just talk about what I do to actually
435:12 - get hands on those resources
435:15 - now that's done we can go ahead and
435:18 - start talking about plugins until now we
435:21 - just implemented plugins which were
435:24 - there in the marketplace or if you have
435:26 - a plugin from GitHub or something you
435:28 - would download it and maybe just paste
435:31 - it inside your project so if I had in
435:33 - here you just create a plugins folder
435:35 - and paste that in there that's simple
435:38 - but what if you wanted to create your
435:40 - own plugin if you wanted to do that and
435:44 - this topic is very less discussed so not
435:48 - many people actually talk about this
435:49 - stuff so you're in luck because we are
435:52 - talking about this in detail now
435:54 - so head into plugins click on ADD and
435:58 - you see many options now we won't be
436:01 - worrying about the editor plugins those
436:04 - are for more advanced users and if you
436:06 - are in a state where you're creating
436:07 - editor plugins I really don't know what
436:09 - is the reason for you to watch this
436:11 - course so we won't be touching upon this
436:14 - we'll be looking at third party
436:15 - libraries later on we'll be looking at
436:18 - blank content only in Blueprint library
436:20 - now blueprint library is
436:22 - self-explanatory it'll just contain a
436:24 - blueprint function Library let's say you
436:27 - wanted some functions for a vector or
436:29 - something maybe you are implementing
436:31 - another data structure for which you
436:32 - want functions
436:34 - you could have a blueprint Library
436:36 - and content only is basically the type
436:39 - of plugin where you know you'd have
436:40 - models and stuff like that without any
436:42 - code basically
436:44 - but the one which we'll be doing is
436:46 - blank and just give an author name in my
436:49 - case I'll give gaming and description
436:51 - this is my first plugin
436:54 - well it's not but just for the sake of
436:57 - giving a description and let's call this
436:59 - one
437:00 - test plugin
437:01 - and go ahead and create it
437:06 - so the plugin has been created and we
437:08 - have Visual Studio open however before
437:10 - we actually start working on it I want
437:13 - to touch upon one topic that is the
437:16 - build.cs file basically everything you
437:20 - have in the engine is divided into
437:22 - modules so the core functionality of the
437:25 - engine is like core choreo object and
437:27 - engine
437:28 - so now that you have actually created
437:30 - your plugin your plugin as well will
437:33 - have a build.cs file if actually open
437:35 - the folder over there so plugins test
437:37 - plugin and if I head into Source test
437:41 - plugin I have a build.cs file here and I
437:45 - have content binary stuff like that
437:48 - so what this basically is is this plugin
437:52 - itself is actually a modulant in itself
437:54 - so if I want to use this plugin in C
437:57 - plus plus let's say I should go ahead
438:00 - and include that module so I can do that
438:03 - by typing in a comma and we can type in
438:06 - test plugin
438:08 - this concept will be more clear once we
438:11 - actually Implement a third-party
438:12 - libraries when we Implement a
438:15 - third-party Library you actually have a
438:17 - separate module for the library as well
438:19 - as your plugin as a whole basically a
438:22 - plugin acts as a wrapper so that it can
438:24 - interface with Unreal Engine
438:27 - because unreal standard API does differ
438:30 - a little bit compared to your standard C
438:32 - plus plus what you do generally so you'd
438:35 - use the plugin as sort of a wrapper to
438:37 - you know interconvert types so let's say
438:39 - you wanted to convert all the STD
438:41 - strings into s f strings which is there
438:44 - in unreal so stuff like that so you
438:46 - would have the plugin as a wrapper and
438:48 - you would interface that uh through the
438:51 - plugin inside the engine
438:54 - so let's actually take a look at our
438:56 - plugin now now that we have a basic idea
438:58 - of build.cs
438:59 - in our editor we already have our test
439:02 - plugin content folder open
439:04 - we can work with this normally but
439:07 - anything we created uh inside here will
439:10 - be actually packaged inside our plugin
439:13 - so for example let's create an actor
439:16 - class so let's just call it some actor
439:20 - and whoops
439:23 - and we can make it do something let's
439:25 - say
439:27 - so for example let's say we have some
439:31 - logic so
439:33 - let's say every frame it just prints out
439:35 - something obviously you would have some
439:38 - more practical logic in here
439:40 - so let me go ahead and type something so
439:43 - let's say
439:45 - our
439:47 - actor is ticking
439:51 - something like that
439:53 - and we could go ahead and have C plus
439:55 - plus classes as well
439:57 - so over here under Tools you can create
440:01 - new C plus class I'm just showing you
440:03 - guys how to do it because we did go over
440:05 - the blueprint itself so you know how to
440:08 - work with blueprint
440:10 - it's just that you're creating it inside
440:12 - this directory and I'll show you guys
440:14 - how to reuse it in another project
440:17 - so head into tools new C plus plus class
440:20 - just like how we would let's say you
440:22 - wanted to create an interface
440:25 - so I just took an example
440:27 - and instead of my interface we can call
440:30 - this one
440:31 - R plugin interface
440:36 - and instead of beginner course you can
440:39 - type in test plugin because this is a
440:42 - separate module in itself and now if I
440:45 - go ahead and create the class
440:47 - you would see that under our source or
440:52 - rather under our plugins folder so I'll
440:54 - just reload the solution under a plugins
440:56 - folder under the source folder now you
440:59 - should be able to see our interface
441:01 - so now you can work with this just like
441:04 - how we would
441:06 - with another file
441:09 - so this is how you would actually go
441:11 - about doing it
441:13 - so now if I just go ahead and close this
441:15 - and rather I'll just close the editor
441:19 - and remember guys make sure your plugin
441:21 - is enabled here if you are not able to
441:23 - see it in the editor make sure you
441:25 - enable this
441:27 - so what you can do is first of all let's
441:30 - see if it actually builds successfully
441:33 - so we'll just create a new function
441:36 - so it's going to be a virtual function
441:38 - because we want to override so virtual
441:42 - void
441:45 - test function
441:49 - and we can go ahead and leave it as is
441:52 - we don't really require a default
441:54 - implementation but we will have one
441:56 - anyways so right click quick actions and
441:59 - create
442:02 - a default implementation
442:04 - and now we should be able to implement
442:06 - this interface so let's make this a u
442:08 - function so you function
442:12 - your function
442:14 - and just to make our job a little bit
442:16 - easier we'll just make it a blueprint
442:17 - implementable event
442:21 - so that we can actually just give the
442:24 - logic in Blueprint itself
442:26 - so this works and now if I just go ahead
442:29 - and build this you should see that both
442:32 - this plugin as well as our whole project
442:35 - will
442:36 - be actually built so it says blueprint
442:39 - implementable events in interfaces must
442:42 - not be declared virtual let's just fix
442:43 - that
442:45 - and now it should build as is
442:50 - just make sure you don't have a
442:51 - definition here because it will look for
442:54 - the definition in Blueprint
443:01 - now let's say I wanted to use this in
443:04 - another project this is how you would go
443:06 - about doing this so open up your editor
443:08 - head into the plugin section again and
443:11 - where you have your plugin over here
443:12 - under project other
443:14 - click on package just select a random
443:17 - folder I'll just select my documents for
443:19 - example
443:20 - and go ahead and package the plugin
443:24 - it will take a little bit of time
443:27 - but once that's done you should be able
443:30 - to implement that in another project so
443:33 - meanwhile while this is actually
443:35 - compiling we can go ahead and create
443:37 - another project so open up your epic
443:39 - games launcher
443:41 - so our packaging is actually complete
443:43 - before the launcher loaded up so you can
443:46 - actually check it in our documents
443:48 - folder so head into test test plugin and
443:51 - you should be able to use this in your
443:53 - projects and I'll show you guys how to
443:55 - do that
443:56 - so just ignore that head into Library
443:59 - let's actually just launch the engine as
444:01 - is
444:03 - and over here we can go ahead and just
444:05 - create a new project
444:07 - so we'll just create a blank project
444:09 - blank with nothing I'll just create
444:11 - blueprint
444:13 - and for the project name
444:16 - uh okay we do have a C plus plus class
444:19 - so it might actually want to rebuild
444:22 - stuff once again so anyways what we'll
444:25 - do is we can
444:27 - create a C plus plus project call this
444:29 - one
444:30 - plugin test
444:33 - and we can go ahead and create it
444:37 - so I'll show you guys how to implement
444:38 - it both in Blueprint and C plus
444:41 - anyways now that we are actually in the
444:44 - process of creating it
444:46 - so it should take a while but eventually
444:49 - once the project is opened up
444:51 - we should be able to import the plugin
444:54 - just like that and I'll show you guys
444:57 - what steps you need to take in order to
444:59 - actually get this in the plugins list
445:02 - now our project has been created so we
445:04 - are in a blank level just we'll just go
445:07 - ahead and create a new map and let's
445:09 - just call this one some level
445:12 - open it up
445:14 - save it
445:15 - and make this the default project
445:18 - settings
445:19 - maps and modes make this the default
445:24 - so that should be good and if you open
445:27 - up your Visual Studio which we will open
445:29 - later we'll close this up
445:31 - and close the editor as well and
445:34 - beginner course will just minimize that
445:36 - for now
445:37 - if I head into my file explorer what I
445:39 - can do is I can copy this over
445:42 - and where I have my other project so I
445:45 - believe I created it under unreal
445:47 - project so plug and test
445:49 - and what you want to do is you want to
445:51 - create a new folder called plugins
445:55 - and paste this over there
445:58 - now what I want you guys to do is right
446:00 - click generate Visual Studio project
446:03 - files
446:05 - so this is actually going to integrate
446:07 - it and once you're done with that if you
446:09 - want to use the plugin content in C plus
446:13 - all you have to do is head into source
446:16 - plug-in test and under plugin test
446:20 - build.cs
446:22 - we don't actually need to come here
446:24 - actually this is for the plugin what's
446:26 - the plugin using so what you have to do
446:27 - is head into your plugin test rather I
446:30 - mean the project head into Source plugin
446:34 - test build.cs
446:36 - and over here
446:38 - so I meant I meant to come here so over
446:42 - here what I want you guys to do is
446:45 - where we have our modules I want you
446:50 - guys to add test plugin
446:54 - uh just don't get confused plug-in test
446:56 - is our unreal project name and test
446:58 - plugin is our plugin name
447:00 - and now I'll show you guys how to
447:02 - implement it so we can go ahead and
447:04 - build this once again
447:06 - so we'll close everything up
447:08 - and we'll just generate the visual
447:10 - studio project files once again
447:13 - and we'll close our beginner course
447:16 - we'll open it up and we'll just create
447:17 - one C plus plus class and maybe a
447:19 - blueprint class
447:21 - so we'll do blueprint first since we are
447:23 - opening the editor anyways
447:25 - so we have some level and if we actually
447:28 - go ahead and create something so let me
447:31 - just create an actor if I head into all
447:34 - classes
447:35 - and if I type in
447:38 - so I'm not sure what I called it so we
447:40 - can head into plugins and check test
447:42 - plugin content some actor so
447:45 - some actor as you can see we get some
447:47 - actor now if you're not getting this it
447:50 - simply means that you haven't enabled it
447:53 - in your plugins so under installed other
447:55 - you should have test plugin
447:57 - and you should have your author name and
448:00 - stuff like that
448:01 - so make sure you have this enabled over
448:03 - here
448:04 - and now if I go ahead and drag this in
448:07 - the world and if I press play as you can
448:09 - see our code which we had in our actor
448:12 - is now working in the other project
448:15 - similarly we can use the interface as
448:17 - well
448:18 - so over here under class settings
448:20 - implemented interfaces we can go ahead
448:23 - and look for our interface
448:25 - I think we called it our plugin
448:27 - interface
448:29 - and we have our test function which we
448:31 - can Implement and we can go ahead and
448:34 - tell
448:35 - something
448:36 - so you could just say test function
448:40 - called
448:43 - in order to implement this however we
448:45 - would require C plus plus since we
448:48 - actually didn't make this blueprint
448:50 - callable however we can still choose to
448:53 - edit it in the source order so if I just
448:55 - head into our source and if I actually
449:00 - go ahead and edit the CPP file we can
449:03 - actually rather in the plugins folder
449:07 - test plugin if I head into the source
449:09 - folder and edit the CPP file
449:12 - or rather the dot hatch file and add the
449:15 - blueprint callable specifier I would
449:17 - still be able to you know use this over
449:20 - here but anyways we will implement it in
449:23 - some class which we create here so I'll
449:26 - just go ahead and close Visual Studio
449:27 - here and I'll go ahead and create
449:32 - something so we can
449:35 - create a new C plus class of type actor
449:37 - we are able to implement this but we
449:40 - can't call it that's the reason we're
449:42 - actually doing it so we'll just call it
449:43 - my actor for now
449:45 - and go ahead and create it
449:51 - so live coding should do its thing
449:56 - so our file should in fact open up in a
449:59 - new window right now
450:02 - and go ahead
450:04 - and just don't mind it opened up in a
450:07 - separate window
450:08 - and now we can feel free to go ahead and
450:11 - include our interface
450:13 - just gone ahead and reopened the
450:15 - solution file here now inside my actor.h
450:19 - since we included the module in the
450:21 - build.cs file we should simply be able
450:23 - to include r
450:25 - plugin interface.h
450:30 - now you should be simply able to inherit
450:33 - the interface by using public I or my R
450:37 - plugin interface and now we have
450:40 - successfully inherited the interface now
450:42 - the since this was a blueprint
450:44 - implementable event you can just go
450:46 - ahead and use it in Blueprint itself and
450:49 - just to make things a bit convenient for
450:50 - us we can head into our R plugin
450:52 - interface.h file under the plugins
450:54 - folder and we can add in the blueprint
450:56 - callable flag
450:58 - so now we can go ahead and actually call
451:00 - it from the blueprint
451:02 - so we can go ahead and run a debugger
451:05 - now so this is how you implement it in C
451:07 - plus plus
451:09 - my main intention here was to show how
451:12 - to include the header file rather than
451:14 - using the interface that is something
451:16 - which we already covered
451:18 - so wait for the editor to load
451:22 - and once the editor is loaded in what we
451:25 - can do is we can go ahead and create a
451:26 - new blueprint class and we can remove
451:28 - this actor first of all otherwise it'll
451:30 - keep printing our actor sticking
451:32 - so go ahead
451:34 - select actor we'll leave this at new
451:37 - blueprint one add this
451:39 - and under the parent class or we could
451:41 - have done it over there itself
451:43 - and select my actor
451:46 - and now again we have our test function
451:50 - and we can again go ahead and Implement
451:52 - our event so we can go ahead and print
451:54 - something let's say
451:56 - test function called
452:01 - or we could have gone ahead and
452:03 - inherited uh my actor instead of some
452:06 - actor here but then again you would have
452:09 - to change some other stuff so we'll just
452:11 - redo this
452:12 - and now if I go ahead and press play
452:14 - nothing's gonna happen headed to your
452:15 - level blueprint and for example just go
452:18 - ahead and get a reference to it and now
452:21 - if I just call in test function
452:25 - test function message this is what we
452:27 - want
452:29 - and now if I go ahead and press play you
452:31 - see we get test function called
452:34 - so this is basically how you do it guys
452:36 - so this is basically how you would use a
452:39 - plugin which you made and implement it
452:42 - in another project and as you guys saw
452:44 - you can absolutely feel free to edit the
452:47 - plugin contents once you have pasted it
452:50 - in this plugin folder
452:52 - foreign
453:00 - libraries now there is one thing to
453:03 - understand before we actually head into
453:05 - implementing them and that is that there
453:08 - are differences between your standard C
453:10 - plus plus API and the unreal C plus plus
453:12 - API a very simple example would be the
453:16 - difference between STD string and F
453:19 - string so in unreal you use F string
453:22 - whereas in standard C plus plus you
453:24 - generally use STD string now
453:27 - interconverting between them is really
453:29 - easy so if you want to implement a third
453:33 - party Library the way you would do it is
453:36 - you would build your third party library
453:38 - inside of a plugin so basically you
453:40 - would put it in a separate folder and I
453:42 - will show you guys the procedure so
453:44 - nothing to worry about that
453:45 - and the the unreal plugin which you will
453:49 - create will act as a wrapper to kind of
453:52 - you know interface between the standard
453:54 - C plus plus and unreal C plus plus API
453:57 - so the way you do it is again create
454:00 - create a new plugin first
454:02 - select this third party Library template
454:05 - because
454:07 - it has most of the important things that
454:09 - you would need in order to actually set
454:11 - it up so again I'll just put gaming for
454:13 - the author and I'll just call it some
454:17 - third party Library
454:20 - Library plugin
454:23 - and over here we can just call this one
454:26 - TPL underscore Plugin or something like
454:29 - that
454:33 - so third party Library plugin so go
454:36 - ahead and create it
454:40 - so now this dialog box should appear
454:43 - over here a rather message box and we'll
454:45 - just click open or okay
454:48 - so basically that was just some code
454:50 - which was written in the example Library
454:53 - now over here we shall not be using
454:57 - their Library so they have actually
454:59 - provided us with a library which we can
455:01 - use as a reference so if I add into
455:03 - plugins TPL plugin Source you see there
455:06 - are two folders here now third part is
455:09 - the folder where you'll have your third
455:10 - party library and TPL plugin is the
455:14 - folder where you would you know have
455:16 - your plugin content
455:19 - and anything uh under this folder would
455:22 - be edited in your project solution file
455:24 - and I'll show you guys what I mean
455:27 - so right now heading to third party
455:29 - third party
455:31 - plug-in live plug-in Library so what we
455:35 - can do is over here as you can see there
455:39 - is an example Library
455:41 - now whichever file says example Library
455:45 - dot something that is basically your
455:49 - actual third party Library so in order
455:51 - to implement our own third party Library
455:54 - we can go ahead and delete whatever they
455:56 - have put over here
455:58 - so we don't need any of this
456:00 - so this is just an example and what they
456:03 - have done is they've used a dll but I'll
456:06 - be showing you guys how to implement a
456:07 - static library and a dll separately so
456:11 - we'll do a static one first so I'll just
456:12 - go ahead and delete all of this
456:15 - now what we are left with is a blank uh
456:19 - folder with just the build.cs file so
456:22 - what you want to do now is open up
456:25 - visual studio
456:29 - and over here you can go ahead and
456:31 - create a new project
456:33 - of type static Library
456:35 - and click next
456:37 - and we'll just call this
456:40 - I don't know
456:42 - test third party library or something
456:46 - so test third party liability
456:50 - so we'll create it under a g
456:53 - repositories or rather we'll just select
456:55 - our solution folder
456:57 - so we'll go ahead and select our
457:01 - beginner course
457:03 - head into
457:05 - the plugins folder PPL plugin Source
457:08 - third party third part TPL plugin
457:11 - Library select this folder and what we
457:14 - can do here is we can check Place
457:17 - solution and project in the same
457:19 - directory so we would have all those
457:21 - project files as they appeared in the
457:24 - example so go ahead and press create
457:28 - now you should see that our library is
457:31 - actually created
457:33 - so if I go ahead and open up
457:37 - this folder over here
457:39 - as you see this folder has been created
457:43 - it's not necessary that you have it over
457:46 - here
457:47 - so you can just go ahead cut this and
457:51 - paste this over here
457:53 - and you can go ahead and delete this
457:54 - folder
457:56 - so it's open in visual studio so I'll
457:58 - just close everything
458:00 - so I'll just save it
458:02 - so we can just cut this and paste it
458:04 - over here so we shouldn't have opened
458:07 - that so we'll just replace it as of now
458:10 - nothing should happen
458:12 - now once you're done with this we can
458:14 - open up our build.cs file
458:18 - and over here you would notice that we
458:20 - have a bunch of stuff which you
458:22 - seriously which I seriously don't expect
458:25 - you to understand uh basically these are
458:28 - for Linux and Mac so you can just go
458:30 - ahead and delete this I'm not going to
458:33 - be showing how to work with DOT so files
458:36 - and stuff so I'm not really a Linux guy
458:38 - so we'll just be working with our
458:42 - Windows Library
458:44 - so we'll not do the dll now so I'll just
458:47 - comment this out
458:49 - we'll do the dll a bit later and what
458:52 - this is is this is basically our
458:55 - library directory
458:58 - and the library file itself
459:00 - now example library.lib was the file
459:04 - which they had created so whatever
459:07 - example Library they had
459:10 - that file was named example library.lib
459:13 - but ours isn't yet here so we can just
459:17 - go ahead and add in some sample code so
459:19 - that we can actually create it
459:21 - so head in here
459:23 - change the configuration to release
459:24 - first things first
459:26 - and head into source files add a new
459:30 - item
459:33 - and over here you can go ahead and
459:35 - create a DOT hatch file because we will
459:37 - need some sort of a header to include it
459:39 - so we can just type in test class we'll
459:42 - just create a class
459:44 - so testclass.h
459:46 - maybe you can create some static method
459:48 - inside
459:51 - and over here uh we can actually move
459:54 - this over to the header file section
459:57 - right click on source file add new item
460:00 - head of source CPP file and we can call
460:03 - this one
460:04 - testclass.cpp
460:08 - and once both of these files are open
460:11 - over here we can just start writing our
460:13 - class so we can call this test class
460:17 - and under the public section we can
460:20 - simply have a method so under public
460:23 - and under private we can have a string
460:25 - variable so STD
460:27 - string
460:29 - and we need to include string obviously
460:32 - so hash include
460:34 - string
460:38 - so we have our STD string we'll just
460:41 - create a variable called
460:44 - maybe test string
460:48 - and we can write a Constructor here to
460:50 - just initialize it so what we can do is
460:53 - we can go ahead and create
460:55 - test class
460:59 - and write the definition for the
461:01 - Constructor the reason I'm not doing it
461:03 - in line over here is because I want to
461:06 - show you guys that the lib file is
461:08 - actually doing something so if we have
461:10 - the definition right here so we wouldn't
461:12 - really need the library file
461:15 - now I can go ahead and create the
461:17 - definition for it
461:21 - and what we can do now is under this
461:25 - we can go ahead and just
461:28 - initialize our string so we can say test
461:31 - string equals
461:36 - this is some test string
461:40 - doesn't really matter what you put in
461:42 - there and we can just have a method so
461:44 - we can have STD
461:47 - string
461:48 - get name maybe
461:52 - now this is going to return that string
461:55 - basically
461:57 - so we can go ahead and test that so we
462:00 - can go ahead and return test string
462:03 - now this should be about it for this
462:06 - so before you go ahead and build it just
462:08 - set up this pch.h file and stuff so go
462:12 - ahead over here instead of test class
462:14 - dot head just include this pch.h
462:18 - and what you would want to do is you
462:19 - would want to come here and just include
462:22 - your test class dot Edge over here so
462:25 - now this should compile so if I go ahead
462:27 - and press build
462:29 - make sure it's in release configuration
462:31 - and it should work so now if you were to
462:34 - head into your TPL plugin Library folder
462:37 - now under this x64 folder which has been
462:40 - created you should find your dot lib
462:42 - file don't worry about all these other
462:44 - files just go ahead and copy this file
462:46 - name which will be the same as your
462:48 - library files name I mean your libraries
462:51 - name
462:52 - so test third partylibrary.lib that is
462:56 - the file which we want to include
462:59 - so now that we are done with this now we
463:01 - should in theory be able to wrap this
463:05 - using our TPL plugin now this is
463:08 - actually the code for our unreal plugin
463:11 - now inside this we'll actually be
463:13 - writing some code in order to just wrap
463:16 - this class whatever we wrote over there
463:20 - so go ahead and head into your beginner
463:23 - course solution
463:25 - that is your main project solution
463:31 - and now if you head into your test
463:34 - plugin
463:37 - or rather the one which you created now
463:40 - so TPL plugin source TPL plugin
463:44 - and we should be able to actually work
463:47 - with this so we'll just do it inside
463:48 - this header file uh as I showed you for
463:52 - the previous plugin if you want to add
463:54 - in more files and stuff you can do it
463:57 - through the project or we can actually
463:58 - do that actually since we have our
464:00 - solution open anyways I mean our unreal
464:02 - project
464:03 - so over here we can go ahead into tools
464:06 - add a new C plus plus class we don't
464:09 - really require an actor so we'll create
464:12 - an object so object
464:15 - create it and we'll call this one
464:18 - wrapper object
464:21 - and this will just be under my TPL
464:24 - plugin
464:25 - so we can close our solution since it
464:27 - will open it up once again and create
464:29 - the class
464:31 - now if you were to open up your solution
464:33 - you should see a wrapper object.cpp and
464:36 - stuff and one more thing uh this is
464:38 - something which you really don't need
464:42 - so now you can just feel free to head
464:45 - into this function here and just delete
464:47 - all this code and over here as well you
464:50 - can go ahead and just delete this make
464:52 - sure you just have the functions and for
464:54 - this one basically we don't have our
464:56 - example library.h we instead have our
464:59 - test class.h
465:01 - so this will work we don't need it here
465:03 - so we aren't going to use it so you can
465:05 - just leave the rest of it as is
465:08 - and now if we were to continue now
465:12 - but now if I were to go ahead and build
465:14 - this so if I just go ahead and hit build
465:18 - now wait for it and now you notice you
465:21 - actually get errors even though you
465:23 - didn't have any code
465:25 - uh the reason is
465:27 - well we don't actually have our uobject
465:30 - module if you get any errors like this
465:32 - cannot open include file and it's
465:34 - something like this basically it's the
465:38 - same thing you haven't included the
465:40 - module so what you have to do is head
465:42 - into your
465:44 - uh TPL plugin
465:47 - undersource you should find your TPL
465:50 - plugin build.cs file and if you were to
465:53 - recall your main build.cs file that is
465:55 - your projects build.cs file so if I head
465:58 - into Source begin a course beginner
466:00 - course build.cs you see there is a
466:02 - module known as score you object and
466:05 - this isn't there in the TPL plugin
466:08 - build.cs so I'll just go ahead and
466:09 - include that and now it should build
466:11 - successfully so if I just click on build
466:14 - now this should build with absolutely no
466:17 - problems
466:18 - so now we can go about implementing a
466:21 - wrapper object basically we are trying
466:23 - to get our test class to work with our
466:25 - actual code here
466:27 - so I'll just do it under the public
466:28 - section so whenever this uh your object
466:32 - that is your wrapper object will be
466:34 - instantiated I want our actual
466:37 - third-party Library object to be
466:39 - instantiated as well so we can go ahead
466:42 - and type in test class
466:44 - class
466:45 - obj
466:47 - equals we had a default Constructor so
466:49 - we'll just call that and the reason we
466:52 - get errors is because we haven't
466:53 - included the header so we can get TPL
466:57 - plugin
466:58 - Library so Library
467:02 - and we call it testclass.h
467:06 - now we shouldn't get that error now we
467:08 - should be able to create our object and
467:10 - now we can go about writing our
467:12 - functions for it so the only difference
467:15 - in the main with the standard C plus
467:18 - plus API and unreals API in our example
467:22 - is that we used STD string over there
467:24 - but we want to use F string so we can
467:27 - write a u function for it so your
467:29 - function we can just call it get name
467:32 - and the return type is going to be F
467:34 - string of course
467:37 - and we can create a definition for it
467:42 - create a definition
467:43 - open it up and inside the F string
467:46 - Constructor we can get our object obj
467:49 - dot get name Dot cstr
467:53 - so C Str
467:56 - so this is how we can just convert it
467:58 - now this is something related to the
468:00 - conversion you can just look into the
468:02 - documentation or the Forum so this is
468:04 - how we would go about converting it and
468:06 - we'll make this one blueprint callable
468:08 - as well just so that we can test it in
468:10 - Blueprint are now successfully we have
468:14 - translated our standard C plus plus
468:15 - function in our third party library and
468:18 - this is now usable in unreal so if I
468:21 - just go ahead and run a debugger here
468:26 - inside our project now we can ignore
468:30 - this and we can head into content and
468:33 - we'll just do it under blueprints go
468:35 - ahead create a new blueprint class and
468:37 - this will be of type wrapper object
468:42 - so we don't find it and we forgot to
468:46 - make this blueprint table once again no
468:48 - issues we can make this blueprint table
468:50 - and you can make it blueprint type as
468:52 - well if you wish so we can go ahead and
468:54 - restart the editor now
468:59 - and now under content blueprints if I
469:02 - right click create a blueprint class and
469:05 - type in wrapper object we should get a
469:07 - wrapper object
469:08 - and we can go ahead and just call it BP
469:11 - underscore wrapper
469:14 - so this is our wrapper class basically
469:18 - now if I were to actually go ahead and
469:22 - call the function we can actually do
469:24 - that so we'll instantiate the object and
469:27 - call it so our function was called get
469:29 - name
469:30 - oops get name
469:33 - call function get name Target is wrapper
469:35 - object and we get a string so we can go
469:38 - ahead and test this method out so in our
469:40 - level blueprint we'll just construct an
469:42 - object so we can ignore this
469:45 - we can go ahead and construct object
469:47 - from class
469:49 - and we can construct our wrapper object
469:53 - so BP wrapper
469:54 - we didn't really need it to be honest
469:56 - but anyways we can go ahead and call the
470:01 - function get name
470:02 - once it's successfully constructed
470:05 - and we can print strings so that we can
470:08 - check if it works
470:11 - so now if I go ahead and press play
470:15 - as you would see I get this is some test
470:18 - string
470:19 - and this is exactly what we put in our
470:22 - third party Library so if I head into
470:24 - third party
470:25 - testclass dot CPP
470:28 - as you can see we had our STD string and
470:31 - we actually called this method through
470:33 - our wrapper class
470:35 - so this is basically how you implement a
470:38 - third-party static Library
470:42 - [Music]
470:46 - so now let's get to dlls now working
470:50 - with dlls is going to be a little more
470:53 - tedious and if you were to take my
470:56 - opinion in Unreal Engine at least it's
470:58 - really not worth the hassle to work with
471:01 - dlls I always prefer just working with
471:04 - you know static libraries or any unreal
471:07 - native plugins but anyways I'll just
471:09 - show you guys with the example itself
471:11 - the procedure is the same head into
471:13 - plugins
471:14 - click on ADD third-party library and
471:17 - we'll just call this gamium and plugin
471:20 - name let's just call it dll test
471:24 - so we're going to create the plugin and
471:27 - it should take us into Visual Studio
471:32 - so we get this message box here
471:36 - so which is from uh the functions given
471:40 - in the dll so
471:42 - just head into your solution Explorer
471:45 - add under your plugins
471:48 - you should find a dll test plugin
471:51 - and if you open up your
471:54 - third party folder you should be able to
471:56 - see the code
471:57 - now we'll just be modifying it in here
472:01 - so we'll just call a function
472:04 - so example Library function let's just
472:06 - head into the definition this is
472:08 - creating a message box
472:10 - similarly we could just have our own
472:11 - function the important bit over here is
472:15 - the export part so basically you have
472:18 - this macro which is going to export the
472:20 - function now
472:22 - the usage of classes isn't really
472:25 - covered here so I'm just going to do
472:27 - that instead of writing my own function
472:29 - obviously you can implement the same
472:31 - thing with your own dll but remember uh
472:34 - the changes to the build.cs files which
472:36 - you have to make so under plugins dll
472:40 - test
472:41 - Source dll test or other third party dll
472:45 - test library and in this build.cs file
472:49 - again you will probably have to change a
472:52 - few parts you can remove this if you are
472:54 - working on your windows
472:56 - so this is over here just change the
473:01 - file name to whatever your dll is
473:04 - and over here for the lib file as well
473:07 - just make sure you change it to whatever
473:09 - your file name is even here as well just
473:12 - do those changes and you should be good
473:14 - to go and the addition of modules will
473:17 - still remain the same so you will still
473:19 - have to include choreo object and stuff
473:22 - we'll do that so not to worry
473:25 - so if you want to actually export a
473:28 - class
473:29 - you would have to do it right here in
473:32 - the dot hatch file you can have the
473:33 - definition separately in the CPP file
473:36 - but I'll show you guys how to actually
473:38 - do it so the way you do it for classes
473:41 - is a bit different for functions you can
473:43 - follow this example and move on
473:46 - but over here let's say I want a class
473:48 - so I can do example Library export now I
473:52 - am assuming we are developing for
473:54 - Windows so I'll just go ahead and delete
473:57 - all these alifs
473:59 - so I won't be having any of that so I'll
474:01 - only have the macro declared even over
474:05 - here as well so I I'll just go ahead and
474:08 - remove all of this and I'm just assuming
474:11 - that everything is
474:13 - for Windows
474:15 - so with that assumption let's continue
474:18 - now if you want a class we can go ahead
474:21 - and declare it and one more thing in
474:24 - your dot h file as well make sure you
474:26 - just have this macro
474:27 - if you want to work with class if you're
474:29 - working only with functions you don't
474:31 - really require
474:33 - so now what you want to do is let's just
474:35 - call this one test class
474:39 - and over here we can go ahead and have
474:41 - some methods
474:43 - so let's say in
474:47 - get num or something and we can have a
474:49 - variable as well so under private
474:54 - we can have in Num
474:58 - and for this we can go ahead and provide
475:01 - a definition for it
475:02 - and one more thing for each definitions
475:07 - so for your class definition here make
475:09 - sure you put in export
475:11 - for methods you would put in import here
475:13 - and export in the definition but since
475:15 - your class definition is here itself
475:17 - make sure you have example Library
475:19 - export
475:21 - or whatever your library name is
475:23 - and we can just go ahead and return num
475:26 - so what we can do is we can write uh
475:30 - we can just say we can just set this to
475:33 - some value
475:34 - what we can do here is we can write a
475:37 - Constructor actually
475:39 - so this class is called test class
475:44 - and we'll just write it in line over
475:46 - here what we can do is num equals
475:52 - can grab in a random number
475:55 - between 0 and 99. so this should work as
475:59 - expected and then I'll get num function
476:02 - should work as well
476:03 - now once you are done with this our
476:07 - dlls example Library should work
476:10 - so what we can do is we can go ahead and
476:13 - before building actually we can create a
476:15 - new file
476:16 - so head into your editor
476:19 - and we can close the solution for now we
476:21 - can build it and close it
476:25 - so we have live coding enabled just
476:27 - ignore that so build it
476:32 - so this should build successfully
476:36 - now if I just head back into my project
476:38 - beginner course
476:40 - and if I head into my you project file
476:42 - here
476:44 - once it loads up you would see the
476:47 - message box as is if you don't want that
476:49 - I'll just show you guys how to disable
476:51 - that if you don't want the message box
476:53 - head into your dll test third party
476:55 - third party library or whatever or
476:58 - rather Source dll test
477:01 - private
477:02 - dlltest.cpp this is the file where it's
477:05 - actually
477:06 - given the function definition so just go
477:10 - ahead open that and edit the file to
477:13 - remove the function definition
477:15 - so let it open up
477:17 - and over here what you would want to do
477:20 - is you would want to remove this
477:22 - function definition
477:24 - so you can remove this and then the
477:26 - message box isn't going to pop up you
477:29 - can remove this as well
477:30 - but that's not going to be called unless
477:33 - it fails so not to worry
477:35 - and even this path as well so if you do
477:39 - require to change it you will have to
477:42 - change it if you are implementing your
477:44 - own make sure you account for all of
477:46 - this
477:47 - so heading back go to tools you see plus
477:51 - plus class all classes object will go
477:55 - ahead and just or we can do actor just
477:57 - to keep things a little more interesting
477:59 - so we can go ahead and create an actor
478:02 - click on next my actor make it under dll
478:07 - test and we can go ahead and create the
478:09 - class
478:11 - so this should open up our solution file
478:15 - and
478:17 - don't mind if live coding fails we'll
478:19 - just close and reopen that not to worry
478:23 - we can go ahead and open the solution
478:25 - file once again so we'll go ahead and
478:27 - close this
478:29 - and once the solution is open we should
478:31 - be able to go ahead and find our file
478:33 - here so under dll test
478:36 - private
478:37 - dlltest.cpp or rather myactor.cpp and we
478:42 - should find all our function definitions
478:43 - and not to worry if you get so many
478:46 - errors it's just to do with the build.cs
478:49 - file once again it's kind of dumb but
478:51 - it's something which you have to deal
478:53 - with
478:54 - so over here make sure you include
478:57 - engine
478:59 - and make sure you include core view
479:01 - object
479:03 - make sure you have these two modules if
479:05 - you want to access gizmet and stuff like
479:07 - that you will need engine
479:08 - if you want to access your your object
479:11 - type you'll need core your object so
479:14 - if you don't have an idea of what
479:16 - contains what you can go ahead and have
479:18 - a look at the engine module in the
479:20 - documentation everything is given over
479:22 - there otherwise you could just follow
479:24 - along
479:25 - so head into now it will build
479:28 - intellisens isn't refreshed yet
479:31 - so head into your myactor.h and we can
479:34 - go ahead and include a header so you can
479:36 - go hash include
479:37 - dll underscore test Library
479:43 - and our header is called example
479:45 - library.h of course if you have your own
479:48 - header that's going to replace this
479:50 - and we shouldn't get any sort of errors
479:53 - here
479:54 - and over here we can just write a
479:56 - function we'll just do it in line so you
479:58 - function make this one blueprint
480:01 - callable to make things simple so
480:03 - blueprint
480:05 - callable and we can call this one
480:09 - void
480:11 - run dll function
480:14 - so I'm not really bothered about the
480:15 - name too much
480:17 - and now what I can do is I can go ahead
480:19 - and write a definition for it we'll just
480:21 - do it over here
480:23 - so from our dll we can go ahead and grab
480:26 - it so the function which we had
480:29 - was called
480:32 - get num so we can go ahead and
480:34 - instantiate an object to that class so
480:37 - our class was called test class
480:41 - just call it obj
480:43 - and we can go ahead and call the
480:45 - function
480:46 - we'll do it in the next line
480:49 - and obj Dot get num we can go ahead and
480:53 - print this by typing in you Kismet
480:57 - system Library
481:00 - print string
481:02 - and we can just pass in at this pointer
481:04 - and we can do F string
481:08 - so it's an integer so from int
481:11 - and this should be good to go
481:14 - now what we can do is we can include
481:16 - Kismet because we don't have the print
481:18 - string function here so hash include
481:20 - Kismet
481:22 - Kismet system Library dot h
481:27 - now this should build successfully
481:29 - assuming we haven't made any mistakes
481:31 - here
481:32 - now it's giving us an error it says test
481:35 - class class type redefinition a simple
481:38 - fix would be just to do pragma once so
481:41 - pragma once and this should build now
481:45 - with no problems now we can go ahead and
481:48 - open up the editor
481:51 - so once we open it up
481:53 - we won't get the message box now because
481:55 - we had disabled that
481:57 - and over here if we just head into a
482:00 - level blueprint for example and make
482:02 - sure under the play mode just change
482:03 - this to Standalone because we had it set
482:06 - to multiply we can go ahead and
482:07 - construct an object from class
482:09 - or rather we can do spawn actors and
482:11 - sets an actor so my actor
482:16 - my actor is what it was called
482:18 - and we can just have a default transform
482:21 - it doesn't really have anything and from
482:23 - this we can go ahead and I'm not sure
482:25 - what the function was called
482:27 - so let me just have a look
482:30 - so our function in my actor was called
482:33 - run dll function so I can go ahead and
482:36 - call that
482:37 - so run
482:38 - dll function
482:41 - so in theory we should get stuff printed
482:44 - over here but this will probably not
482:48 - work now because we haven't actually
482:49 - compiled our library itself which is
482:51 - kind of stupid so heading to dll test
482:56 - so third party dll test Library example
483:00 - Library dot solution
483:03 - and now just click ok
483:06 - and now what you would want to do over
483:08 - here is go ahead and select a release
483:11 - configuration
483:13 - and go ahead and build it
483:15 - oh and yeah make sure you close the
483:18 - editor when doing it that was the error
483:20 - which we got right there now if you were
483:22 - to go ahead and open up your beginner
483:25 - course view project
483:27 - once that's loaded in now we should be
483:30 - able to call the function and it should
483:33 - work as expected so in your level
483:36 - blueprint where you called it run dll
483:39 - function and we can go ahead and click
483:41 - on selected viewport and as you can see
483:44 - we got 95 if I go ahead and play we get
483:47 - 66
483:49 - and we keep getting random numbers every
483:51 - time so our dll actually worked but
483:56 - if you do want to implement your own it
483:59 - is going to be a little more complicated
484:01 - than this even with just including the
484:05 - one which was provided to us with unreal
484:07 - it was a big hassle so make sure you
484:10 - guys uh avoid using dlls I prefer using
484:15 - static libraries or I restrict myself to
484:18 - those for unreal at least
484:20 - so that's it I guess about third party
484:23 - libraries we can go ahead and talk about
484:25 - multiplayer now it's going to get fun
484:27 - guys
484:28 - [Music]
484:33 - now let's talk about networking in
484:36 - Unreal Engine so networking basically in
484:40 - unreal revolves around start topology
484:43 - basically your server client model so
484:46 - basically you have one player or a
484:50 - dedicated machine which acts as a host
484:54 - which we call the server and you have
484:57 - all the other players which are clients
484:59 - now there are two types of servers in
485:03 - Unreal Engine one is a lesson server and
485:05 - another one is a dedicated server in a
485:08 - lesson server the server itself acts as
485:10 - a client as well as the server that is
485:13 - the host whereas in a dedicated server
485:17 - the server only acts as a host and does
485:20 - not have a player controller so these
485:23 - are the two types of servers and
485:25 - basically any data that has to be passed
485:27 - through Network as you can see in this
485:29 - diagram here there is no connection
485:31 - there is no direct connection between
485:33 - two clients always if data has to be
485:36 - passed from client 1 to client 2 or vice
485:39 - versa it has to be routed through the
485:41 - server so that is one thing to note when
485:44 - it comes to networking in Unreal Engine
485:46 - now there are many questions which might
485:49 - arise regarding the efficiency of this
485:52 - and stuff but most games these days work
485:55 - based on this principle and it is in
485:58 - fact very robustly implemented and we
486:00 - will be talking about all the features
486:02 - of unreal networking soon
486:06 - [Music]
486:10 - I have brought up my main menu level
486:12 - here and I just want to demonstrate how
486:16 - you are going to join two Standalone
486:18 - games that is two games on separate
486:20 - computers into one so if you aren't
486:24 - familiar net mode will basically let you
486:26 - choose between the types of servers
486:28 - which I talked about play as client is
486:30 - your dedicated server basically and play
486:33 - as listen server is going to be a server
486:36 - which is also a player along with the
486:38 - other clients Place Standalone will
486:40 - basically mean two separate games and
486:42 - that's what we will be doing
486:44 - now what if you wanted to connect
486:45 - between these two
486:47 - so we'll be using the game instance for
486:49 - it so open up your BP game instance now
486:52 - I am recording this a little bit later
486:54 - so that's the reason you may see a few
486:57 - things which you haven't seen so BP rgi
487:00 - and we can just set up a couple of
487:02 - custom events we'll first of all delete
487:04 - all of this we don't need this
487:07 - so I'm not sure we may have broken some
487:09 - reference
487:11 - doesn't matter so
487:13 - we'll just go ahead and fix that
487:16 - so we'll just delete that
487:18 - and now if I head into rgi and I'll
487:22 - create a custom event now basically
487:24 - connecting to a single game is handled
487:27 - by something known as a session
487:30 - so every time your players are connected
487:32 - unreal actually has something known as a
487:36 - session stored internally we aren't
487:38 - going to be diving into the C plus plus
487:40 - part of this we'll just be doing this in
487:42 - Blueprint but please note that if you
487:45 - want finer control over these properties
487:47 - you would want to work with C plus plus
487:50 - so session is basically what is going to
487:53 - allow your players to connect
487:55 - so let's go ahead and create a session
487:57 - so what we can do is we can do something
488:00 - like create
488:02 - Lobby would be inappropriate I'll just
488:04 - call this one create session
488:07 - and we'll go ahead and type in create
488:09 - session
488:11 - and as you see there is an async task
488:13 - over here
488:14 - and if you guys aren't familiar with
488:16 - this clock symbol and a node like this
488:18 - this is an async task and public
488:21 - connections we'll just set that to two
488:22 - for example so to players and player
488:26 - controller this is for lesson servers if
488:28 - you have a dedicated server you don't
488:30 - have to pass in the player controller
488:32 - but in our case we are passing it in so
488:35 - we are going to use the function get
488:37 - player controller
488:38 - and then use Lan is set to false you
488:42 - could do it if you wish and upon success
488:45 - what you can do is you can go ahead and
488:48 - load a level so open level
488:51 - and we can go ahead and open our
488:54 - beginner course level
488:57 - all right
488:58 - and then what we can do is we can go
489:00 - ahead and create a function
489:02 - to join
489:04 - join session
489:07 - all right I would call this one create
489:09 - match
489:10 - so that it sounds a little more familiar
489:12 - join match
489:16 - so what we can do is we can first of all
489:19 - find sessions
489:20 - so type in find sessions
489:23 - these are the only few functions which
489:25 - are there in this Library so that's the
489:27 - reason I'm not really going over them
489:28 - that much so we can get the player
489:31 - controller and what we can do is Max
489:33 - results you can just set it to something
489:35 - like 100
489:37 - and we're going to check if it's a
489:41 - failure or if it's a success so what we
489:44 - can do is first of all we can get the
489:46 - length
489:48 - so if it's a failure we're just going to
489:50 - print something
489:53 - so we could say
489:56 - failed
489:59 - to join a match
490:03 - and what we can do is we can get the
490:04 - length
490:06 - and if it is greater than zero
490:10 - we'll go ahead and just join the first
490:11 - session obviously you can have your own
490:13 - logic here
490:16 - so each session is going to be one
490:18 - hosted game basically so let's say there
490:21 - are three uh three members in this array
490:25 - or three elements in this array what it
490:28 - basically means is there are three
490:30 - people hosting a match right now that's
490:31 - what it means
490:34 - so now what I can do is I can grab the
490:36 - results
490:38 - and I can get a copy of the first one
490:42 - if the length is greater than 0 and I
490:44 - can go ahead and type in join session
490:48 - all right and here we'll again need to
490:51 - pass in the player controller and note
490:53 - whoops
490:55 - and note that you can only run these
490:58 - session functions either on the player
491:00 - controller or in the game instance you
491:03 - cannot run them on other blueprints it
491:05 - is simply going to fail
491:07 - now once that's done
491:09 - let's say we have no sessions we can go
491:13 - ahead and create a match so create match
491:19 - and on success we don't need to do
491:21 - anything engine will handle it for us
491:23 - over here you can have something like a
491:25 - progress bar or something until on
491:28 - success is called you could probably
491:29 - have some throbber or something like
491:31 - that to show that it's loading same over
491:33 - here
491:35 - so this should be good
491:37 - and something very simple which you
491:39 - could do is inside the main menu
491:43 - so on clicked
491:45 - what I can do is instead of opening it I
491:47 - can grab a reference to my game instance
491:49 - so I can type in get game instance which
491:52 - is a static function and I can cast it
491:54 - to BP rgi this will always succeed I'll
491:58 - just cast it over here I'm not going to
492:00 - bother storing a reference to it as of
492:02 - now
492:03 - and I can go ahead and or actually I'll
492:06 - just do it the right way so I'll just
492:08 - call this one main GI you could call it
492:10 - anything
492:11 - just a reference to our game instance
492:14 - and once we have that we can go ahead
492:17 - and use it and we can go ahead and join
492:19 - match so join match
492:23 - now that that's done if I go ahead and
492:25 - press play if I go ahead and press play
492:27 - here
492:30 - as you can see nothing is really
492:32 - happening but after a while we go ahead
492:36 - and join the session basically we load
492:38 - up the map
492:39 - now now that we have actually created a
492:42 - session and if I press play on the other
492:44 - game here and if I just wait for a while
492:48 - so you would want to disable the input
492:50 - during this time but anyways for now
492:52 - we'll just not do anything you would see
492:55 - that you actually don't join the session
492:57 - the reason is you actually need to be
493:00 - listening for incoming Connections in
493:03 - order to actually be able to join the
493:06 - game and I'll show you guys how to do
493:08 - that
493:09 - over here where you have open level make
493:12 - sure you just put in listen under the
493:14 - options
493:15 - so make sure you do that before you
493:17 - actually do it and one more thing plane
493:20 - editor is crashing my game for some
493:22 - reason so I'm just going to go ahead and
493:25 - I'm going to run this Standalone so
493:29 - Standalone game and Standalone so play
493:32 - Standalone and replace this as a
493:35 - standalone game so I'm not really sure
493:37 - why the issue is happening but this is
493:40 - one way I can test it so if I press play
493:43 - on one of them and if I go ahead and
493:45 - wait
493:47 - so we should land inside a session
493:49 - as expected we are in the level and we
493:52 - are able to do stuff
493:53 - now I'll just go ahead and click on play
493:55 - here
493:57 - in theory if everything is set we should
493:59 - in theory land in the same map so
494:03 - as you can see post login was called on
494:05 - the server and if I were to notice my
494:09 - client has successfully connected over
494:11 - here
494:12 - so as you can see I'm able to play the
494:15 - game like this
494:16 - so this is basically how you connect two
494:18 - clients now let's actually talk about
494:20 - how to set up stuff in multiplayer guys
494:24 - [Music]
494:29 - okay then so if we want to work with
494:31 - multiplayer what we can go ahead and do
494:34 - is we'll start with a new level because
494:36 - if I go ahead and press play with two
494:38 - players here
494:39 - and
494:41 - if I actually close the game you see
494:43 - we'll get a few runtime errors now this
494:46 - is mostly because our code isn't really
494:48 - set up for multiplayer and you will soon
494:50 - understand why
494:52 - so basically now what I want you guys to
494:55 - do is head into your Maps folder create
494:57 - a new level and we'll call this one
495:00 - multiplayer testing
495:05 - so go ahead and open it up
495:08 - so this should be a blank level
495:10 - so I'll just grab in a sky
495:14 - and grab in a directional light here
495:18 - and we should have everything set up
495:21 - and maybe if you want we could have fog
495:26 - and we can just create a simple
495:28 - landscape
495:29 - so head into your mode selection
495:34 - landscape
495:35 - and we can go ahead and create it
495:41 - so I'll just do a little bit of noise so
495:44 - that we have a starting point so that we
495:46 - have some sort of
495:48 - a workable landscape
495:51 - so increase the brush size
495:54 - so the strength is a little too much
495:56 - point of I should be fine
496:01 - so let me just go back
496:10 - okay that should be good for us
496:13 - now what we can do is we can go ahead
496:15 - and talk about multiplayer
496:17 - so the main aspects of multiplayer in
496:21 - unreal are replication and remote
496:24 - procedural calls
496:27 - if you are clear with how to use these
496:29 - two concepts
496:30 - it's pretty simple to code a multiplayer
496:33 - game in Unreal Engine it's much more
496:37 - difficult to do it with general
496:39 - knowledge of networking but with
496:42 - unreal's framework it's really very
496:44 - simple to set up multiplayer
496:46 - we'll discuss both blueprint and C plus
496:49 - plus aspects but first the basics
496:52 - now I want you guys to head into
496:54 - blueprints
496:56 - and under here I want you guys to just
497:00 - select your character and your BPA so I
497:05 - guess this one is where we had physics
497:07 - enabled so if we do yep we have physics
497:10 - enabled so I want you guys to just show
497:13 - the problem with this running
497:15 - multiplayer in general so I'll just go
497:18 - ahead and drag this in
497:19 - and
497:21 - what I can do now
497:23 - is
497:24 - I can go ahead and grab a few player
497:27 - starts here so I'll grab one here grab
497:29 - another here
497:30 - and make sure they're all facing the
497:33 - same direction
497:34 - so what I can do is I can make this one
497:36 - 90.
497:38 - so they're all facing towards this ball
497:40 - right there
497:42 - and now what I'm gonna do is I'm going
497:45 - to change the world settings to use our
497:48 - BP game mode
497:50 - and for the player controller we can
497:52 - ignore that we'll still get the runtime
497:53 - errors
497:55 - so what we can do is we can remove this
497:58 - logic so we'll forget about the HUD for
498:00 - now and if I go ahead and press play
498:03 - now you see the ball has fallen down and
498:07 - it's rolling down the hill over there
498:10 - and as you can see I kicked the ball
498:13 - but if you were to notice
498:16 - the ball is in a completely different
498:18 - position
498:20 - so the ball is over there for me
498:23 - and if I actually head near the ball
498:25 - here
498:27 - you'll see that I am not actually going
498:29 - near the ball on my other screen so if I
498:32 - actually turn around
498:34 - my character is somewhere there and my
498:37 - ball is somewhere over there
498:40 - so as you can see both of these are not
498:42 - in sync now this is something related to
498:44 - the widget nothing much to worry about
498:47 - so basically what I'm trying to say is
498:49 - that these two games which are running
498:53 - on separate windows are not in sync
498:56 - but you notice one thing that your
498:58 - characters are in sync so for example if
499:01 - I go ahead and run forward
499:05 - and if I go ahead and run forward over
499:09 - there and if I actually look up you
499:12 - would see that my characters are in sync
499:14 - it's just that the physics object over
499:17 - there is not in sync
499:19 - so the reason this is happening is
499:22 - because in our character if you head
499:24 - into your class defaults and head into
499:26 - the replication tab you see that these
499:29 - two flags called replicate movement and
499:32 - replicates are enabled
499:34 - basically this is unreal's way of
499:38 - telling us that or rather asking us
499:42 - whether we want this particular class to
499:46 - be in sync with all players when
499:48 - instantiated so let's say we instantiate
499:51 - a BP character it will always be in sync
499:54 - obviously there are conditions you have
499:56 - to instantiate it on the server we'll
499:58 - talk about servers and clients soon
500:01 - so let's head into our actor and try to
500:03 - fix it so head into your class defaults
500:06 - and let's try enabling replicate
500:08 - movement and replicates if I compile and
500:13 - if I go ahead and press play
500:17 - as you can see now the ball is rolling
500:20 - down it's near me and as you can see
500:23 - this seems to be in sync
500:26 - if I go ahead and block this
500:28 - as you can see this is almost completely
500:31 - in sync
500:32 - now uh one of my characters flying is
500:36 - due to the movement mode just ignore
500:38 - that but
500:40 - as far as I can see everything is in
500:43 - sync
500:44 - so this is basically how you get stuff
500:47 - to go in sync in a network game in
500:50 - unreal this is the most basic aspect of
500:53 - it
500:53 - you might see that there are a few more
500:55 - Flags here such as always relevant call
500:59 - pre-replication Net load on client most
501:02 - of these aren't really important we'll
501:04 - just talk a little bit about net curve
501:06 - distance squared and net dormancy and
501:08 - stuff but most of the times 9 out of 10
501:11 - times you'll only mess with replicates
501:13 - and replicate movement sometimes you may
501:16 - need your actor to be always relevant
501:18 - let's say it's something important to
501:20 - your gameplay you will have always
501:21 - relevant enabled
501:23 - so once that said let's also talk about
501:26 - net priority basically the higher the
501:28 - value the more priority is given for
501:31 - this to be updated so let's say you have
501:33 - thousands of actors and your bandwidth
501:36 - is insufficient to actually update all
501:39 - the actors the ones with higher
501:41 - priorities will be updated first
501:43 - basically
501:45 - so now that we know the basics of
501:47 - replication
501:48 - [Music]
501:53 - let's start syncing up some variables
501:56 - so if I head into my actor
501:59 - and if I go ahead and create a variable
502:02 - so we have some float already
502:05 - and what we'll do is on begin play
502:08 - we'll go ahead and set this to some
502:10 - random value
502:11 - so we'll get random So Random float
502:15 - and what we can also do is we can go
502:18 - ahead and print this string
502:21 - all right
502:23 - so let's look at what happens
502:28 - so let's actually delete some of our
502:31 - other methods here so I guess we had
502:33 - some stuff in our character
502:36 - so we'll just stop calling this function
502:39 - and we'll ignore the spawn actor
502:43 - and I'm not sure if anything else is
502:45 - printing something so we'll ignore the
502:46 - left Mouse Button as well now if I press
502:49 - play
502:50 - as you can see we only get our post
502:52 - login and we have 0.809
502:55 - and we have 0.43
502:58 - now clearly this is not what you want
503:01 - you want them to be in sync
503:03 - so if you want variables to be in sync
503:06 - the first thing you'd want to do is you
503:08 - would want to set this replication tab
503:10 - to replicate it
503:12 - now let's go ahead and try that actually
503:15 - so if I press play
503:18 - we still get different values
503:21 - the reason is
503:24 - even though we set the value we need to
503:27 - set it on the server and we also need to
503:30 - wait for the replication cycle to take
503:33 - place
503:34 - basically your value doesn't immediately
503:37 - get replicated instead your value gets
503:40 - replicated in the next replication cycle
503:43 - so every once in a while so in our case
503:46 - if you head into class defaults you see
503:48 - this net update frequency parameter it's
503:51 - set to 100. let's say we set it to
503:53 - something like 10
503:55 - now this variable will be updated after
503:59 - approximately 0.1 seconds obviously it
504:02 - can be less than that but up to 0.1
504:04 - seconds if I make it 100 it's going to
504:06 - be up to 0.01 seconds so it's not
504:08 - instantaneous
504:10 - remember that these two players what we
504:12 - play here
504:14 - they are not running on the same machine
504:16 - so you cannot expect
504:19 - the variable to update immediately
504:22 - so what we can do is we can actually set
504:25 - some logic to update this
504:27 - the principle which actually goes into
504:30 - this is the fact that all your
504:32 - replicated variables need to be set on
504:34 - the server so let's go ahead and do that
504:36 - now just a quick note here the event
504:39 - begin play which is there
504:41 - since this actor is replicated each time
504:45 - one computer out of all the players
504:49 - will spawn the actor so for each
504:52 - computer this begin play will be called
504:54 - so if you didn't get what I mean if I
504:56 - actually simply go ahead and print a
504:58 - string so if I go ahead and type in
505:00 - print
505:01 - and if I print hello and if I press play
505:03 - you would notice that the server and the
505:06 - client print hello
505:08 - what that basically means is as soon as
505:10 - the client logged in that is when the
505:12 - client entered the game this actor was
505:14 - born on the client and begin play was
505:17 - called both on the server as well as the
505:19 - client
505:21 - so what we can do is we can check if we
505:23 - are on the server so we can type in a
505:25 - server
505:27 - and we can do a simple if check
505:29 - if we are the server we can go ahead and
505:33 - set this value
505:34 - so we can go ahead and do that and if we
505:38 - are not the server we can go ahead and
505:40 - print it
505:41 - so one more thing we can do is okay this
505:45 - is going to work let's just do it so we
505:48 - can go ahead and print some float
505:52 - and go ahead and press play
505:55 - as you can see the values are the same
505:57 - in case you guys have any doubts
505:59 - regarding that you can go ahead and plug
506:02 - this in directly
506:04 - like this
506:05 - if I press play Let's see 0.718 0.718
506:10 - the value is the same so basically all
506:13 - your replicated variables need to be set
506:15 - on the server that's the first thing now
506:18 - what if you wanted a client to set the
506:20 - value so your client cannot actually set
506:23 - the value however oh and just another
506:26 - thing this logic is going to work for
506:28 - three players as well so if I go ahead
506:30 - and do this for three players
506:32 - so as you can see all three players have
506:34 - the same value initialize so that's
506:36 - going to work as well okay anyways
506:38 - getting back so let's say
506:41 - now instead of this we wanted a client
506:44 - to actually set the value for us
506:47 - for all the players
506:49 - so the way you do that is through a
506:51 - remote procedural call
506:53 - [Music]
506:57 - so replicating variables this is about
507:00 - it there's really nothing much to it so
507:03 - this is basically how you replicate
507:05 - variables I will get to rep notify
507:08 - so let's say you wanted to call a
507:10 - function when a variable has been
507:13 - replicated
507:15 - instead of replicated you can check this
507:17 - rep notify option so then what's going
507:19 - to happen is when the value of the
507:22 - variable is set this function will
507:24 - actually be called on all the clients so
507:26 - if I go ahead and play
507:28 - Let's see we get a Hello as well along
507:30 - with that
507:32 - so we can just type in rep notify
507:37 - so we get whatever string we put over
507:39 - there so basically that basically shows
507:42 - that our replication logic is working
507:43 - that's pretty much it
507:45 - we can have any other functionality for
507:47 - example let's say you have rep notify on
507:50 - a health variable you can update the
507:52 - health bar so something simple like that
507:55 - now let's go ahead and run this logic
507:57 - from the client so let's say we set this
507:59 - on the client and we already saw that
508:02 - that does not really work that well
508:04 - so what you have to do is you have to
508:06 - use a concept known as a remote
508:07 - procedural calls basically they're just
508:10 - custom events meant for multiplayer in
508:12 - Blueprint so type in custom event
508:16 - and we'll call this one
508:18 - set
508:19 - some float some float is the variable
508:21 - name so we just made a setup for it
508:23 - under this replicates tab set this
508:27 - to run on server
508:29 - now what this is going to do is this is
508:34 - going to ensure that this runs on the
508:36 - server
508:37 - so if you call this from an owning
508:40 - client
508:41 - now we will get to the problem with it
508:44 - and if we run it from an owning client
508:46 - we are going to be able to call this on
508:50 - the server so reliable basically means
508:53 - you want it to run in order so let's say
508:56 - you run two rpcs so it's going to run in
509:00 - the same order if it's reliable if it's
509:01 - not reliable the order may change since
509:04 - it's networked it's not instantaneous
509:06 - so stuff like that can happen so now
509:09 - I'll just make this reliable I'll just
509:11 - go ahead and print a string and I'll
509:13 - call this one server RPC
509:17 - so now what we can do is we can go ahead
509:20 - and we'll not do this set with notify
509:23 - we can go ahead and instead of that we
509:26 - can call our set sum float
509:29 - and let's see if we get anything printed
509:35 - now something weird happens
509:39 - as you can see
509:42 - we are not able to actually call this
509:45 - RPC if I were to actually play this and
509:49 - if I open up the output log here as you
509:52 - see it says warning unit driver process
509:55 - remote function no earning connection
509:57 - for actor BPA C1 this is basically the
510:02 - display name of the actor
510:05 - function sum floor set some float will
510:07 - not be processed
510:09 - what has basically happened here is that
510:13 - unreal basically does not know
510:16 - which client actually owns this actor
510:18 - now this actor isn't owned by anyone
510:22 - and if you were to notice this RPC call
510:25 - it says reliable replicated to server if
510:28 - owning client now this if earning
510:31 - clients client section which is there
510:33 - that is what is causing our server RPC
510:35 - to fail
510:36 - now let's do a similar drill but inside
510:39 - a character so if I were to just create
510:43 - an RPC here so I'll just go ahead and
510:45 - create a custom event oops custom event
510:47 - and I'll just call this one
510:51 - as we underscore test something like
510:54 - that and make this one a server RPC
510:56 - reliable go ahead and we'll just print
510:59 - out a string and we can say RPC called
511:02 - RPC called from character now we want to
511:07 - be able to call this from the client
511:08 - instead of big inflations we are in the
511:11 - character anyway so we can use a more
511:13 - elegant solution maybe on a key press so
511:16 - maybe K on the keyboard because we don't
511:18 - have any other things so okay on the
511:20 - keyboard
511:22 - so find it over there
511:27 - so there is K
511:29 - so when we press it this will obviously
511:32 - run on the client which presses the key
511:34 - we can call SV test
511:37 - so go ahead and play this
511:39 - and if I go ahead and press ok
511:41 - it works on the server and if I were to
511:44 - press K on the client it works on the
511:47 - server too I mean obviously it's a
511:48 - server or PC so the function will run on
511:50 - the server but the point is our RPC
511:54 - worked and our client was able to make
511:56 - the server RPC now what if we wanted to
512:00 - be able to call this
512:02 - so from a client
512:04 - so for this you will basically need to
512:07 - have an owner for this the way you do it
512:09 - is through the spawn actor function so
512:11 - if you have just placed it in the level
512:12 - like that you will have to use the set
512:14 - owner method which again I mean if you
512:17 - were to place something in the level
512:18 - it's pretty obvious you wouldn't have an
512:20 - owner for it but let's just see an
512:23 - example where we use the owner so what
512:26 - we can do is okay we already have a span
512:28 - actor function
512:30 - and for the owner here this is something
512:32 - which I did a bit later so for the owner
512:35 - here go ahead and plug in self so spawn
512:37 - an actor doesn't matter the location and
512:40 - stuff doesn't matter we aren't worried
512:42 - about the actual actor itself we are
512:44 - worried about the RPC
512:45 - so make owner self and now what I want
512:49 - you guys to do is run this only on the
512:53 - client
512:54 - so let's say for example we'll again do
512:57 - it on key press so then that's going to
512:59 - be easy for us to manage so we can
513:01 - manually call it
513:03 - so on key plus what we can do and we
513:06 - want to spawn this on the server
513:07 - obviously we don't want to spawn this on
513:09 - the client because it is replicated
513:11 - remember so you have to spawn it on the
513:14 - server itself even spawning cannot be on
513:17 - the client
513:18 - so make sure you spawn it on the server
513:21 - so is server only if it is the server we
513:25 - are going to spawn it and obviously this
513:28 - will run multiple times because for each
513:31 - player which will be spawned this will
513:33 - run
513:34 - so there's no way for us to actually
513:36 - ensure that it happens only once but
513:39 - nothing to worry
513:40 - so we can just grab a reference to this
513:44 - and we'll need to make this replicated
513:46 - if we want access to it from the client
513:48 - so we'll go ahead and promote this to a
513:51 - variable
513:53 - and we'll call this one obj for example
513:55 - and make this replicated so that we can
513:58 - access it from the client
514:00 - and now when we press the K key we can
514:03 - just check if it is valid I mean it will
514:04 - be but just for a safety check if it is
514:07 - valid we can go ahead and call our RPC I
514:10 - don't know what we called it so we
514:11 - called it set some float
514:14 - so we called it set sum plot
514:18 - go ahead and run this now if I were to
514:21 - press play
514:23 - and if I press K on the keyboard
514:25 - as you see we get server RPC printed
514:29 - so if I were to check this we have
514:31 - server RPC over here and let's just test
514:34 - it on the client as well so go ahead and
514:36 - press K as you can see Server RPC is
514:40 - getting printed so we are able to call
514:42 - it on the client basically the ownership
514:44 - is important generally it's a good thing
514:47 - actually that you wouldn't really
514:49 - require to call any rpcs from actors
514:53 - like this generally you would have rpcs
514:55 - in your character game mode game State
514:57 - stuff like that not in the game mode
514:58 - game mode everything is going to run on
515:00 - the server but for the most commonly
515:04 - used classes networking is already set
515:07 - up for you and in case you wanted to use
515:09 - it for an actor like this I have shown
515:11 - you guys how to do it so this is how you
515:12 - do it make sure you just set the owner
515:14 - so let's say I don't actually set the
515:16 - owner and if I go ahead and press play
515:19 - this will still work actually so if I
515:21 - press k
515:22 - this is going to work but if I do it on
515:25 - the client it's not going to work
515:27 - so that's one thing to note from the
515:30 - client the reason this won't work is
515:32 - because now that we do this so let me
515:34 - just set the owner
515:36 - when I set the owner over here
515:39 - now when I press play I have two
515:42 - characters so one is on the server and
515:44 - the other one is on the client and for
515:47 - both of these characters the begin play
515:49 - is going to run so this is going to run
515:51 - both for the server as well as the
515:53 - client
515:54 - so for the first version everything is
515:56 - going to run fine but when this begin
516:00 - play occurs on the client's version of
516:04 - the character
516:05 - even this character will have a begin
516:07 - play on both the server and the client
516:09 - because since this is networked this
516:13 - character will be spawned both on the
516:14 - server and the client
516:16 - so when the RPC takes when the begin
516:19 - place called on the server for this one
516:21 - that is when the owner property starts
516:24 - mattering to us
516:26 - over here if we don't set self
516:29 - in in which case it it will refer to
516:31 - this particular character
516:34 - in the game
516:36 - our logic is not going to work
516:39 - so that was pretty elaborate in my
516:41 - opinion this is probably something which
516:43 - you wouldn't even require that much but
516:45 - this is basically how you do RPC calls
516:48 - now there's one more type of RPC which I
516:50 - want to hint upon and that is multicast
516:52 - what if now we are now that you're on
516:54 - the server
516:55 - what if you wanted to print this for all
516:58 - the players
516:59 - in which case it's really simple type in
517:01 - custom event and we'll just call this
517:03 - one MC underscore
517:06 - print I mean we actually didn't set the
517:08 - float here which is kinda ironic but
517:11 - we'll just do SV underscore print so SV
517:13 - print
517:16 - so we'll print this and we'll just
517:19 - duplicate this over here and make this a
517:21 - multicast start PC now I generally don't
517:25 - prefer making these reliable generally
517:27 - you would use multicast for things such
517:29 - as particle effects so you wouldn't
517:31 - really need reliable but anyways I'll
517:34 - just do it for this example
517:36 - and we'll call this one multicast
517:41 - so we'll just call MC print and remember
517:44 - multicast star PCS have to be called on
517:46 - the server if they are not called on the
517:48 - server it will only run on that client
517:51 - so it's not going to run on all the
517:53 - others
517:55 - so if I were to press play as you can
517:58 - see we get multicast RPC
518:02 - so this is basically how we would go
518:04 - about doing this now this worked on the
518:06 - servers instance uh obviously because we
518:10 - spawned it over here
518:12 - otherwise it wouldn't work
518:14 - so if I were to just go ahead and press
518:16 - play you would see it works
518:18 - and if we had more players it's going to
518:21 - work again
518:22 - if at three players
518:24 - it's going to print it multiple times so
518:28 - it's going to print it on the server
518:30 - client one and client so we have server
518:33 - RPC multicast RPC and stuff works like
518:37 - that
518:39 - so this is basically how you would go
518:41 - about calling rpcs so you have SV print
518:45 - which is routed to the server and we can
518:49 - actually test that out rather than doing
518:51 - it on begin play that is kind of an
518:52 - incorrect way obviously I showed you
518:55 - guys the right way to do it so this is
518:57 - some sort of logic which you would never
518:59 - use
519:00 - so we'll just ignore all of this go
519:02 - ahead and press play
519:04 - if I press K on the keyboard you see we
519:07 - are calling the RPC if I press K on the
519:09 - client it works as well if I press K on
519:12 - the other client it works as well and
519:15 - all of the players can see the printed
519:17 - string
519:18 - now you can also have the logic the
519:21 - other way around so let's say you are
519:23 - the server and then let's say for
519:25 - example I'm just taking an example here
519:27 - let's say when the game starts you
519:29 - wanted to show a countdown and the
519:32 - widget obviously will be spawned on the
519:34 - individual clients because obviously
519:36 - it's a widget so it has to be spawned on
519:38 - the particular client's computer so for
519:41 - that you will again use a client RPC so
519:44 - I'll just do it over here so let's say
519:47 - when I press the K key we will test this
519:50 - on the server itself client rpcs can
519:53 - only be run from that owning client or
519:56 - the server if you run a client RPC from
519:59 - another client it's not really going to
520:01 - work
520:02 - so in order to do that we'll just create
520:04 - an RPC so we'll make this one cl
520:07 - underscore test
520:09 - and make this run on owning client
520:12 - and what I can do now is I can go ahead
520:15 - and print a string and let let this just
520:18 - be there so if I do CL underscore test
520:22 - and if I were to press play if I
520:25 - actually press K here RPC called from
520:28 - character runs on the server
520:30 - over here as well this runs on the
520:32 - client
520:33 - and over here as well this runs on the
520:35 - client
520:37 - so this is basically how you do it it'll
520:39 - just run on the client
520:40 - but what if you wanted to run this from
520:44 - the server so if you do this through a
520:47 - server RPC it is going to be routed
520:49 - through the server so I'll just do that
520:52 - and show you guys
520:53 - so what we'll just do is we'll just uh
520:56 - diyte ourselves so we can say SV test
520:59 - and this will run on the server we can
521:01 - have another print string and we'll call
521:03 - This One SV for server and over here
521:07 - instead of that we'll call the server
521:09 - RPC
521:10 - and now what we can do is once this is
521:12 - printed we can go ahead and call the
521:14 - client RPC so CL test
521:17 - now if you were to notice if I go ahead
521:20 - and press play
521:21 - if I press K as you can see now both are
521:24 - called on the server so the server RPC
521:27 - work and the client RPC worked but if I
521:29 - do this on a client as you can see the
521:32 - server printed SV and the server again
521:34 - called a function on this client so this
521:38 - is basically how you would go about
521:40 - using client rpcs so for any multiplayer
521:43 - logic this is exactly how you would go
521:46 - about doing this
521:47 - in C plus plus this logic is pretty
521:51 - straightforward there's just a few
521:53 - additional steps for rep notify and uh
521:56 - replicating variables but other than
521:59 - that
522:00 - even the C plus plus part is pretty
522:02 - straightforward so generally you would
522:05 - use blueprint itself for core
522:07 - multiplayer logic unless it's something
522:09 - uh you know fundamental to your game and
522:13 - you want it to work
522:15 - properly like let's say you had like a
522:17 - firing mechanic or something and you
522:19 - don't want any sort of performance
522:22 - issues or any overheads you then you
522:24 - would use C plus plus otherwise you
522:25 - would really just use blueprint for most
522:28 - of the things because it makes things so
522:30 - simple as you can see you don't have to
522:32 - do stuff like opening ports and stuff so
522:36 - all of that is handled by unreal
522:38 - and now let's go ahead and see how to
522:41 - run rpcs in C plus plus
522:46 - [Music]
522:49 - thank you
522:51 - now I've gone ahead and opened up visual
522:55 - studio now we'll just ignore the plugins
522:57 - part right now and we'll head into our
522:59 - source folder beginner course public and
523:03 - we'll head into first of all we'll head
523:05 - into a character
523:06 - now what I want you guys to do here is
523:09 - first of all before you actually use any
523:12 - networking feature just make sure you
523:14 - include
523:15 - net
523:17 - slash unrealnetwork.h
523:20 - dot h
523:22 - make sure you include this header if you
523:25 - do not include this header you will get
523:26 - all sorts of weird errors so make sure
523:29 - you do that
523:30 - now first things first let's talk about
523:33 - variable replication so if you want a
523:36 - variable to be replicated
523:38 - uh you basically have to make it a U
523:41 - property first things first
523:43 - and this one will give the specified
523:46 - blueprint read right as usual to make
523:48 - things simple for us
523:50 - and one more thing which you have to
523:52 - give is you have to give the specifier
523:53 - replicated
523:55 - and we'll make this let's say a float
524:00 - float
524:01 - replicated CPP variable Maybe
524:07 - now one more thing which you have to do
524:09 - this is additional this is not something
524:11 - you have to do in Blueprint but one
524:13 - thing you have to do for the replication
524:15 - logic to work is you have to actually
524:17 - write one function in the CPP file of
524:20 - our character we'll go ahead and do that
524:22 - and then we should be able to make this
524:24 - work directly
524:27 - so I've gone ahead and opened up the
524:30 - documentation so this is the function
524:32 - which we actually need so we can go
524:34 - ahead and copy this and paste it inside
524:37 - our character.cpp files have opened that
524:40 - up and I'll just written a comment
524:43 - called replicating variables go ahead
524:45 - and paste it and we can go ahead and
524:47 - have a definition for it
524:49 - so over here this is going to be acpp
524:53 - underscore character just put your class
524:55 - name followed by the scope resolution
524:57 - operator
524:58 - then you can go ahead and just move
525:01 - everything to one line to keep things
525:02 - clean
525:03 - and over here you would want to run this
525:06 - macro called do rep Lifetime and this
525:09 - takes in two parameters one is the class
525:11 - which is going to be our current class
525:14 - and the variable name the variable name
525:17 - is going to be this
525:20 - oh it's going to be replicated CPP
525:22 - variable
525:23 - now I'm recording this a bit later but
525:25 - one thing that I forgot to mention is
525:27 - make sure you call uh super of this
525:30 - function otherwise you'll get weird
525:32 - classes when you use the weird uh
525:35 - artifacts when you use the derived
525:38 - classes and for the parameter you can
525:40 - just pass this in so make sure you just
525:42 - do that otherwise your movement
525:44 - variables and stuff will not be
525:45 - replicated if you use your BP character
525:47 - so that's one thing to note
525:50 - and now if I were to go ahead and run a
525:53 - debugger we should be able to do it just
525:55 - make sure you close the editor and then
525:56 - run a debugger
525:59 - so as you can see the build succeeded
526:01 - and now we should be in theory able to
526:04 - use this variable as a normal replicated
526:07 - variable in Blueprint
526:09 - so I'll just show you guys replicated
526:12 - variables are shown with those two balls
526:14 - on the top so BP character is inherited
526:17 - from CPP characters so we should have it
526:19 - so if I just type in CPP get replicated
526:22 - CPP variable and as you can see this
526:24 - variable is replicated if I were to
526:26 - actually go ahead and check this
526:30 - variable over here it says cpf net this
526:33 - basically means it's replicated so now
526:37 - this should work like a normal
526:39 - replicated variable
526:40 - now I'll show you guys how to handle our
526:43 - pieces as well
526:46 - so rpcs are simple I'll show you guys
526:50 - how to handle server and multicast rpcs
526:54 - I won't really go over client or PCS
526:56 - they work pretty much the same
526:58 - so I'll go ahead and stop this now
527:01 - and for the for rpcs in C plus plus you
527:06 - need to basically have a u function
527:09 - first of all so create a view function
527:12 - and you cannot make rpcs in C plus plus
527:16 - blueprint callable however you can wrap
527:20 - them inside another function and then
527:21 - make them blueprint callable or whatever
527:23 - so what I'm going to do is I'm going to
527:26 - make call uh put the specifier server
527:31 - and one more thing I am going to make
527:33 - this either reliable or unreliable so
527:36 - this is where you specified
527:37 - so reliable
527:39 - or you can make it unreliable
527:42 - now I can go ahead and actually write
527:47 - something here so let's say void
527:51 - test server RPC underscore CPP just to
527:56 - indicate that this is NC plus plus
527:59 - now what you need to do is you need to
528:01 - Define it over there but also
528:04 - uh rather than defining this you are
528:08 - supposed to Define
528:10 - another function known as the
528:13 - implementation for this
528:16 - so what we are going to do is we are
528:18 - going to just copy this over into the
528:21 - next line This need not be a u function
528:22 - and type in underscore implementation
528:25 - okay just ignore the parentheses there
528:27 - implementation
528:29 - and now what we can do is we can create
528:32 - a definition for this instead so I've
528:34 - already done that so I have the
528:37 - definition for this and we can do
528:39 - something simple such as a print string
528:41 - so you Kismet system Library print
528:43 - string
528:45 - and we can go ahead and print in
528:48 - this is a server RPC from C plus plus
528:54 - now this shouldn't clearly work and if
528:57 - we want to call this RPC what we would
529:00 - do is you can you can just go ahead and
529:03 - call this we don't have to call the
529:04 - implementation we have to call this in
529:07 - order for the implementation to get
529:09 - called on the server or we could just uh
529:12 - do something else such as wrapping it in
529:14 - another function so I'll show you guys
529:16 - both the approaches actually so I'll
529:18 - just do it on begin play so on the
529:21 - gameplay what we'll do is we'll go ahead
529:25 - and we'll actually delete some of this
529:27 - code
529:28 - so we'll delete this and what we can do
529:31 - is over here we can go ahead and check
529:34 - so if we are on the server in fact or if
529:38 - we are not on the server we are going to
529:39 - do it so if is server
529:44 - so I guess it's called GS server I think
529:48 - it's a variable not a method so if this
529:51 - is not a server we are going to call
529:53 - this RPC
529:55 - over here we'll call test server RPC
529:58 - underscore CPP
530:01 - and this will work as expected
530:04 - and we can go ahead and wrap this in a
530:07 - blueprint view function so we'll create
530:09 - a new function
530:11 - make this one
530:13 - blueprint callable
530:18 - and from here what we can do is we can
530:20 - just type in void
530:23 - wrapper for CPP RPC
530:29 - and this one we can just write it like
530:31 - any other function and the RPC will run
530:34 - now what you can do over here is you can
530:37 - go ahead and run this function inside of
530:40 - that
530:41 - so we'll go ahead and call this
530:43 - and since this is blueprint callable we
530:46 - can go ahead and just call this from
530:47 - blueprint
530:48 - also realize that just because of the
530:52 - way the function call works this is not
530:54 - going to run at all
530:56 - no matter what you do it is going to
531:01 - come outside the if
531:03 - so if it comes inside this it's again
531:06 - not going to the condition is again not
531:08 - going to be valid so you're not going to
531:10 - run this function
531:12 - so anyways we'll just run it as is and
531:14 - then we can go ahead and run a debugger
531:18 - so now if I were to actually go ahead
531:20 - and wait for it
531:24 - so once it loads in
531:27 - and I go ahead and press play
531:31 - if I press play right now
531:34 - you'll notice that you get this is a
531:37 - server RPC from C plus plus so we got
531:40 - two server RPC calls one from the client
531:43 - and one from the server
531:46 - now I'll also set up some logic so that
531:49 - we run this during gameplay
531:52 - so under your BP character what we can
531:54 - do is we can run the wrapper so type in
531:56 - wrapper for CPP or PC now if I go ahead
531:59 - and press play and press K on the
532:02 - keyboard as you can see it runs on the
532:04 - server
532:05 - and if I do it on the client that works
532:08 - as well totally as expected now one
532:12 - extra feature which I want to cover in C
532:15 - plus plus rpcs is the validation so if I
532:19 - just type in a comma and type in width
532:22 - okay how my caps lock on with
532:24 - validation
532:26 - now what I can do is I can write a
532:30 - function which returns a Boolean and
532:32 - instead of underscore implementation if
532:34 - I type in underscore validate
532:37 - you can make it so that this function
532:40 - will only run under a certain condition
532:41 - this is especially useful for something
532:44 - like cheat detection so if I were to
532:46 - just create a definition for it
532:49 - and what I can do is if this returns
532:51 - false basically this client which is
532:54 - calling the RPC will get disconnected
532:56 - immediately so I can just do return true
532:58 - for now and this RPC is going to run so
533:01 - if you had something like a health
533:02 - variable or something and you do
533:03 - something like if health is you know
533:06 - less than or equal to 100
533:08 - and
533:10 - or maybe if you had any other conditions
533:13 - so let's say the health you had a set
533:15 - Health function which is an RPC of
533:17 - course so then you would check if it is
533:20 - less than or equal to 100 because you
533:21 - don't want the player to set the health
533:23 - to a value greater than 100 stuff like
533:26 - this but for now we'll just leave this
533:28 - to true this function will run just to
533:31 - Showcase I'm just going to print string
533:33 - once again so this
533:35 - and we'll call this validate
533:39 - and will not do this on begin play soops
533:42 - print string
533:45 - go ahead and run a debugger and before
533:48 - we do that I'll actually just show you
533:50 - guys how to handle rpcs as well I mean
533:53 - rep notify as well
533:55 - so let's say I wanted to make this rep
533:59 - notify I would use the replicated using
534:02 - flag I will do it after this actually
534:06 - now if I were to go ahead and press play
534:09 - as you would see the validate function
534:11 - was also called on the server so the
534:14 - server is going to validate and
534:16 - accordingly it is going to disconnect
534:18 - the client if the condition is not met
534:20 - so that function whatever we saw right
534:22 - there that has to return true in order
534:24 - for the RPC call to take place
534:26 - successfully and for the client to
534:28 - continue stay connected so this is
534:31 - basically validation and now let's talk
534:33 - about rep notify
534:36 - I am back inside the header file and for
534:39 - rep notify over here you can just go
534:41 - ahead and create a function so what do
534:44 - we call this function this need not be
534:45 - your function but you can make it as
534:47 - well so we'll call this one
534:50 - uh on rep it's just a convention to use
534:53 - on rep but it need not be on rep
534:57 - wrapper for CPP let's say
535:00 - for CPP
535:03 - and this one will just be void no need
535:06 - to return anything you could return a
535:09 - value if you wish but there's really
535:10 - nothing much you can do with it
535:12 - go ahead and write a function definition
535:14 - for it
535:16 - now again what we can do is we can go
535:19 - ahead and just print something so we'll
535:21 - just copy this over and rather than
535:23 - validate we'll just print
535:25 - rep notify from C plus plus
535:30 - so now what we can do is now we can feel
535:32 - free to come in here and rather than
535:34 - typing in replicated type replicated
535:36 - using equals and just pass in the
535:40 - function name
535:41 - so you don't have to pass in anything
535:43 - else and this is going to work as you
535:46 - would expect one thing that you would
535:48 - want to do is wherever you call this
535:50 - function uh that will obviously be on
535:53 - the server make sure you call this
535:57 - function as well separately
536:00 - so where you set the variable
536:03 - so we are setting this replicated CPP
536:06 - variable so we'll do that
536:08 - make sure you call this as well so if
536:10 - you are setting this in Blueprint make
536:12 - sure you make this function a u function
536:14 - and make it blueprint callable
536:16 - so we'll do that actually
536:19 - there's one issue with it in C plus plus
536:21 - this is how we would uh the same this
536:25 - thing works in the same way as it works
536:27 - in Blueprint
536:28 - so we'll just do it on our RPC itself
536:31 - anyways we are running the RPC so in the
536:33 - implementation for it
536:35 - will not have the print string rather we
536:38 - will have our ref notify
536:42 - the way you do that is we'll modify the
536:44 - value of the variable if you modify the
536:46 - value automatically rep notify will be
536:49 - called Equals I'll just type Rand mod
536:55 - 19 I just chose a random number over
536:57 - there and what you want to do is you
537:00 - would want to call this function
537:02 - only over here
537:04 - and the rest will be handled for you
537:08 - now we can go ahead and run a debugger
537:12 - and you would see that our rep notify
537:14 - will be called and rep notify from C
537:16 - plus plus is going to be printed it just
537:19 - works just like that
537:21 - so wait for the editor to load in
537:24 - and once we are inside the editor if I
537:27 - go ahead and press play as you can see
537:29 - rep notify from C plus plus and it was
537:32 - called on the client as well since there
537:35 - are two versions of the character here
537:36 - so one on the client and one on the
537:38 - server both of them called it two times
537:40 - so that's the reason we got four prints
537:42 - and the same thing is going to work when
537:44 - we use the wrapper
537:46 - so if I just type in k for example you
537:49 - see the rep notify works so
537:52 - we get the validate rep notify as well
537:55 - as anything else that you would expect
537:57 - so wrap notify on the server and the
537:59 - client
538:01 - and if you want to do the same in
538:03 - Blueprint
538:04 - so you can go ahead and set
538:07 - our replicated CPP variable to something
538:11 - and you would notice something weird
538:14 - uh first of all I have to do it on the
538:16 - server so we'll do it on a server or PC
538:19 - so SV test rather than doing CL test
538:22 - we'll go ahead and set the value of this
538:24 - variable
538:26 - and we can do SV test
538:29 - go ahead and close this
538:32 - and if I were to press K let's just wait
538:34 - for it as you see
538:37 - this rep notify is only called on the
538:39 - client this is not actually called on
538:42 - the server
538:44 - so in order for rep notified to work
538:47 - again once you do this you will have to
538:49 - type in on rep wrapper for CPP
538:53 - so make sure you actually type that
538:57 - so now if I were to go ahead and press K
539:00 - on the keyboard you see it runs both on
539:02 - the server and the client
539:03 - so there's just one extra step which you
539:05 - have to take in C plus plus that is if
539:08 - you have your replicated variable in C
539:10 - plus plus
539:12 - so that's about it for rep notify I
539:15 - guess we have covered almost all aspects
539:16 - of replication uh multicast is something
539:19 - which I'll just talk about so all the
539:23 - same parameters except or here you would
539:25 - have net multicast
539:27 - so don't mind the spelling I mean the
539:30 - capitalization
539:31 - so I have my caps lock on net multicast
539:36 - and this will work as expected you can
539:39 - again have your reliable and validation
539:41 - and stuff like that
539:43 - uh the rest of it will remain exactly
539:46 - the same so you'll have your
539:48 - implementation and you can have your
539:50 - validate if required
539:52 - but you wouldn't really have a validate
539:54 - for a multicast RPC so I'll just go
539:57 - ahead and delete that
539:59 - and this should work just as expected so
540:03 - I'm not going to really show that this
540:05 - is how you would basically set up a
540:06 - multicast RPC and the documentation is
540:09 - there we did the example for the server
540:11 - there are no syntactical changes to this
540:14 - so it should be totally okay so we'll
540:16 - just delete that definition and I guess
540:19 - then we are done with multiplayer guys
540:22 - [Music]
540:27 - now that we are done with covering all
540:29 - aspects of game development in Unreal
540:32 - Engine let's go ahead and actually take
540:35 - a look at how to install Unreal Engine
540:37 - from source so the main part is actually
540:40 - done now we'll be doing a couple of
540:42 - things such as downloading the source
540:45 - looking at how we can build it as well
540:47 - as we'll be going ahead and changing the
540:49 - engine version on our existing project
540:52 - so first of all as I mentioned at the
540:55 - very start of the course make sure you
540:57 - guys do get access to this repository
541:00 - here
541:01 - as of this date the release Branch
541:04 - should have 5.1.0 and you should be able
541:07 - to download the zip file over here so
541:09 - download the zip
541:12 - first of all uh especially when you're
541:15 - installing unreal Source just to avoid
541:18 - you know the permission issues which you
541:20 - are going to get make sure you head into
541:22 - your C drive
541:23 - new folder and just create a folder
541:26 - called unreal Source or something it
541:28 - need not be the C drive just make sure
541:31 - you do it in your SSD if you have one so
541:35 - in my case it's the C drive so that's
541:37 - the reason I'm doing it so I'll just go
541:39 - ahead and install it there so go ahead
541:41 - and extract the files
541:43 - over here under C I'll go ahead and
541:47 - browse the directory over there
541:49 - so see unreal source
541:53 - go ahead extract
541:55 - and extract it under the directory and
541:58 - hit OK
542:03 - now we're just a few steps away in order
542:05 - to install Unreal Engine so first of all
542:08 - go ahead and run your setup batch file
542:11 - and try to run it as an administrator
542:13 - just to ensure it has all the
542:15 - permissions for everything so run the
542:17 - setup batch file as an admin
542:19 - so something like this should show up
542:21 - and once it's completed we'll head into
542:24 - the next step
542:26 - after the setup batch file has completed
542:28 - running you can go ahead and run the
542:30 - generate project
542:32 - files.bat so this file is basically
542:35 - going to generate your Visual Studio
542:36 - solution so let's go ahead and run that
542:39 - again try to run it as an administrator
542:41 - it should work regardless but if you do
542:44 - get any errors just run it as an admin
542:46 - so you should see something like this
542:48 - and this should complete relatively
542:50 - quickly
542:51 - at this point you should be able to see
542:54 - our solution file so go ahead and open
542:56 - it up once the solution is open and you
542:59 - see ready over here at the bottom left
543:01 - hand side what you should do is you
543:04 - should go ahead and head into engine and
543:06 - if it does ask you to install a few more
543:08 - components in Visual Studio make sure
543:10 - you just go ahead and do that just
543:12 - follow along but in my case I've already
543:14 - done that so I'm gonna go ahead right
543:16 - click on you if I and click build
543:19 - now once your build has succeeded
543:22 - under your engine binaries when 64 you
543:25 - should find unreal editor.exe so by
543:29 - default the build configuration is set
543:31 - to development editor if you don't see
543:33 - this it means your build configuration
543:35 - was probably something else and it
543:37 - didn't get built so anyways let's go
543:39 - ahead and open it up and our editor
543:41 - should load up if we do get any errors
543:43 - we can go ahead and debug it now
543:46 - so everything seems to be working fine
543:48 - and it is going to compile some shaders
543:51 - once that's done I'll be right back
543:53 - foreign
544:02 - course project and now I'll show you
544:05 - guys how to change the engine version so
544:07 - headed your beginner course your project
544:09 - file right click switch Unreal Engine
544:11 - version and now you should see Source
544:14 - build at whatever so basically I opened
544:16 - and closed the editor that's it so
544:19 - whatever we did there open unreal
544:21 - editor.exe I just closed it immediately
544:23 - and now I'm back to this location and
544:25 - you should see this so if I hit OK it is
544:28 - going to generate some Visual Studio
544:30 - project files and unless something's
544:33 - horribly wrong it should in theory work
544:35 - out of the box
544:37 - so that's about it and now you can go
544:40 - ahead and just Build Your solution once
544:43 - again because there may be a few API
544:45 - changes which you might have to make so
544:47 - those will be lifted and listed in the
544:49 - output log and as well as in the release
544:51 - notes and the documentation or whatnot
544:54 - so head into your solution
544:58 - now we have switched the Unreal Engine
545:00 - version
545:01 - so now we can go ahead and right click
545:04 - on our beginner course and click on
545:06 - build
545:08 - foreign
545:09 - so we get our first error here and this
545:12 - is actually fairly common so basically
545:15 - we have switched the Unreal Engine
545:16 - version and we have a plug-in over here
545:19 - which is based on the older version of
545:22 - the engine there are two ways to fix it
545:24 - one you can head into the marketplace
545:26 - and reinstall the plugin which is meant
545:29 - for 5.1 or I'll just show you guys the
545:32 - way to do it without up using the
545:34 - marketplace so in the marketplace it's
545:36 - really easy you can just go ahead and
545:37 - update the plugin but over here if you
545:40 - really want to just use the same one
545:43 - what you can do is you can head into
545:45 - your engine installation directory so in
545:47 - my case it is C unreal Source Unreal
545:50 - Engine release engine
545:52 - plugins
545:54 - Marketplace uh it's not here because we
545:57 - haven't yet installed so you'll find it
545:59 - there so we'll go to our previous
546:02 - installation program files Unreal Engine
546:05 - this is where I had it
546:06 - ue5.0 engine
546:09 - plugins
546:10 - and you should find Marketplace
546:13 - and the one we are interested in is low
546:15 - entry extended standard Library
546:18 - you don't need to copy it to the engine
546:20 - installation although you could what
546:23 - I'll do is I'll just take it to the
546:24 - plugins folder over here
546:26 - so over here and under inside the U
546:31 - plugin file we'll do the same
546:33 - modifications
546:35 - over here what we are going to do is
546:38 - under the engine version we are going to
546:40 - type in 5.1.0
546:44 - and now if we go ahead and try to build
546:46 - this once again
546:48 - we shouldn't get that error hopefully
546:52 - so it will take a while and if we do get
546:56 - any errors we'll go ahead and change it
546:59 - or fix those
547:03 - so we have a few errors here and these
547:07 - are mostly the changes which came
547:10 - according to the documentation due to
547:12 - the platform SDK upgrades but it's not
547:16 - really a problem
547:17 - so because I don't think any of you guys
547:20 - unless you guys work for a triple a
547:23 - studio or something I don't think you'll
547:25 - be using this and this is from the
547:26 - plugin this is not something in the
547:28 - engine so nothing to worry so what I can
547:30 - do is we can simply just delete this
547:32 - code and just to return false
547:34 - and even for the Xbox one so we can just
547:37 - do the same thing
547:39 - and I'll tell you guys which file this
547:42 - is it's basically this file right here
547:44 - so in the error list you see platform
547:47 - PS4 whatever so just head into that just
547:50 - double click on that and you will reach
547:53 - there
547:54 - and over here as well
547:57 - so line 264
548:00 - so I feel like
548:03 - this was it so before changing it was in
548:05 - line to 64. so now it's gone a bit up
548:09 - anyways let's try building this once
548:11 - again
548:14 - and as you can see the build has indeed
548:17 - succeeded but once the plugin actually
548:20 - comes for 5.1 what you can basically do
548:22 - is install 5.1 here like in the epic
548:25 - games launcher install the plugin from
548:28 - the marketplace and then you can go
548:30 - ahead and copy that into the plugins
548:32 - folder in the engine level
548:34 - so what you would do is you would have
548:37 - it over here so see unreal Source
548:39 - release
548:41 - an engine plugins
548:44 - over here you would create a new folder
548:47 - called Marketplace or something and then
548:48 - you would like just copy it in
548:50 - anyways we are not really worried about
548:53 - that right now
548:54 - now what we can do is now that it's
548:56 - built successfully we can go ahead and
548:59 - run a debugger and we should be able to
549:01 - run this in 5.1 so I did show you guys
549:03 - multiple things so the errors which you
549:06 - get will actually depend on what plugins
549:09 - you're using and how's your code base
549:12 - and what changes are made to the engines
549:16 - API itself
549:18 - so depending on that you'll have to look
549:20 - at the output log and the error list and
549:22 - do something and there are a few
549:24 - deprecation warnings as well so if you
549:26 - just have a look
549:29 - so I'm not really sure
549:31 - what this is but this will probably be
549:34 - changed soon once the plugin is updated
549:36 - but right now I'm not really worried
549:39 - since it's just a warning so now I can
549:41 - go ahead and run a debugger
549:45 - all right so our project has opened
549:48 - successfully and it is prompting us to
549:50 - change a few project settings in order
549:52 - to actually use Virtual Shadow maps and
549:55 - nanite so that's not really an issue we
549:58 - can head into the project settings
550:00 - uh and over here
550:03 - under it should in theory
550:06 - be here so platforms
550:10 - so let's just search for platforms
550:13 - it'll be under any one of these so
550:17 - platforms
550:19 - windows
550:20 - and you can go ahead and enable Shader
550:23 - Model 6.
550:27 - and over here we can go ahead and
550:31 - I don't think we'll require Shader Model
550:34 - 5 so that should be about it and now you
550:37 - can go ahead and restart the editor all
550:40 - right so now I've restarted the editor
550:42 - and now we are using Unreal 5.1 so
550:45 - that's about it for installing the
550:48 - source and changing your engine version
550:50 - now there are a few more ways you can
550:52 - handle some of the things such as the
550:54 - plugin part but on the whole this is how
550:58 - you do it and if you do want any more
551:00 - specific references you always have the
551:02 - documentation which you can refer and
551:04 - the release notes are maybe the unreal
551:06 - Slackers Discord server so that's about
551:09 - it
551:10 - foreign
551:16 - ly inside the last section of this
551:19 - course and obviously it is about how to
551:22 - package your game
551:23 - so it used to be very simple before so
551:27 - you just go file package project but now
551:30 - it will probably have to just do it
551:32 - through the project launcher which I
551:34 - will show you guys it's really simple so
551:36 - head into tools project launcher
551:39 - and you can use this but I'm going to be
551:42 - using a custom launch profile
551:45 - so go ahead and add
551:47 - create a custom profile
551:49 - and I'll just walk you guys through each
551:51 - option you can give a name to this
551:53 - profile let's say this is for testing
551:55 - let's hit uh you are building this for
551:58 - testing so you can name this profile
551:59 - testing you can reuse this profile for
552:02 - the next time when you package the game
552:04 - as well packaging basically means you
552:06 - make your game or you turn your game
552:08 - into an executable basically
552:11 - now project is going to be beginner
552:13 - course of course and build configuration
552:17 - so debug and development will be used
552:21 - when you're actually you know testing
552:23 - out your game and you're still not yet
552:26 - at a stage where you can
552:28 - uh send it to other people so your print
552:31 - strings and stuff are gonna work but
552:34 - under shipping uh none of your print
552:37 - strings and stuff will work but it will
552:39 - take a bit longer to build
552:41 - and testing is somewhere in between
552:44 - debug development and shipping so it's
552:48 - below shipping but it's above
552:50 - development and debug basically
552:53 - so you can select any one of these I
552:56 - I'll just select shipping
552:58 - and here these are settings you don't
553:01 - need to worry about and about cooking
553:04 - the content you can do either on the fly
553:07 - or buy the book
553:09 - uh basically what on the Fly uh and buy
553:14 - the book is going to differ in is
553:17 - basically if you do buy the book
553:18 - everything is going to be cooked uh
553:22 - beforehand basically so if you if you're
553:25 - packaging your game for shipping most of
553:27 - the times you will have buy the book
553:29 - and you would select windows
553:33 - if you're developing a Windows game
553:35 - obviously if you have anything else
553:37 - let's say you're making an Android game
553:38 - you would select Android and stuff like
553:40 - that and undercook cultures you'll find
553:43 - English somewhere here so en it should
553:46 - be selected by default so en
553:49 - and you can select your Maps which
553:53 - you want to cook so we're using all so
553:55 - we'll just select all but you can choose
553:57 - to cook only
553:58 - selected Maps but note that if you don't
554:02 - cook a certain map you won't be able to
554:04 - open it in game you're going to get
554:06 - errors your game will probably crash now
554:09 - that's one thing to note now the release
554:11 - DLC patching settings these are some
554:14 - things which I'll not go over and under
554:16 - advanced settings as well so you can go
554:20 - ahead and mess with these
554:22 - so
554:24 - you can enable this
554:26 - if you want all the content to go in a
554:29 - single dot pack file
554:31 - stuff like that
554:33 - and everything is pretty
554:35 - self-explanatory
554:38 - next package package and store locally
554:42 - then you can go ahead and give it a path
554:44 - so generally I'd like to do it in the
554:46 - project location
554:48 - saved and I'd like to create a folder
554:51 - called staged builds
554:53 - staged builds have used the project
554:56 - launcher in the in the older versions
554:58 - you probably already know what this is
555:00 - and is this just is this build for
555:03 - distribution to the public we have
555:04 - selected shipping so I would assume it
555:07 - is of course it's again your preference
555:10 - do you wish to Archive
555:12 - can select yes or no doesn't really
555:16 - matter
555:17 - and deploy we can select do not deploy
555:21 - because we aren't actually launching the
555:23 - game
555:24 - so if we select do not deploy basically
555:27 - you can launch it through the executable
555:29 - itself
555:31 - so once that's done you can head back
555:32 - and you can click on launch this profile
555:38 - so now once everything has been
555:40 - completed you can head into the
555:41 - directory over there you should find a
555:43 - Windows folder and you should find your
555:45 - executable right there so open it up and
555:48 - you should launch your game
555:50 - so we will end up in this map right here
555:54 - again you can change your project
555:55 - settings and you can change the default
555:58 - map but anyways our purpose here was to
556:01 - check if the game packages and
556:02 - everything seems to be working the
556:04 - physics simulation works and so on
556:08 - so that's pretty much it
556:14 - [Music]
556:19 - okay guys so this is going to be the
556:23 - last segment of the course as you guys
556:24 - would know and I hope you guys would
556:27 - have enjoyed the course till now and
556:30 - congratulations if you have completed
556:32 - the course still here
556:33 - and the further part is going to be
556:37 - two hours of me creating an entire game
556:40 - so hopefully you guys will enjoy it uh
556:43 - see you in the engine
556:44 - alright guys so this is the last section
556:47 - of the course and this is not actually
556:49 - going to be about you know learning
556:51 - anything new however in this part I will
556:55 - be live demonstrating without any Cuts
556:57 - how to make an endless Runner such as
557:00 - Temple Run or Subway Surfers or any
557:03 - other which you might have played
557:05 - so we'll be taking the most simple
557:08 - approach or at least as far as my
557:12 - knowledge is concerned if you do have
557:13 - anything simpler you can let me know in
557:15 - the comments
557:16 - and hopefully within an hour we'll be
557:19 - able to make the whole game with the
557:21 - menu animations and all that kind of
557:23 - good stuff
557:24 - so let's get started so let me actually
557:28 - have a stopwatch here so that we have
557:30 - track of our time
557:32 - so I'll just create a game it's going to
557:35 - be third person because we'll have the
557:37 - animation blueprint and stuff but
557:39 - anyways I don't think we'll be using
557:41 - that not to worry uh we'll go with blank
557:44 - actually
557:44 - C plus plus and we'll call this one
557:47 - endless Runner
557:52 - create it
557:54 - now this will take a little bit of time
557:59 - and I do have a couple of things being
558:01 - installed in the background and I also
558:03 - have a list of plugins that I'll be
558:05 - using
558:06 - so you guys will have a pretty good idea
558:08 - of what will actually do with plugins
558:11 - and stuff because in the course I think
558:14 - I just went over these briefly but I
558:17 - went in depth about how to actually
558:19 - create your own plugins and stuff
558:21 - anyways so our project will be created
558:25 - soon
558:26 - and this will compile so until then we
558:29 - can go ahead and open up our epic games
558:31 - launcher
558:32 - head into Library
558:34 - and we can close this editor for now
558:37 - until we add everything
558:40 - so what I what I'll do is I'll go ahead
558:42 - and search these one by one so City
558:44 - subway tunnel
558:47 - so I have to create a separate project
558:49 - for this not going to go over that right
558:51 - now
558:52 - so we'll go construction volume
558:55 - so volume 1 and volume 2 will go ahead
558:57 - and add this to endless Runner we'll add
558:59 - this to endless Runner I'll CL I'll
559:01 - clear the cache later it's just taking
559:03 - up storage
559:04 - and we want Ellie extended so early
559:07 - extend it
559:10 - so we have already installed it to 5.0.3
559:13 - so nothing to worry about there
559:15 - so Adventure character whoops
559:20 - so this will be the character which
559:22 - we'll be using and it's going to be
559:23 - hella fun
559:25 - ah we don't have time to actually model
559:27 - our own character that's the reason we
559:29 - are doing this so I'll just go over this
559:30 - real quick so FX variety pack
559:33 - not sure if we will get the effect we
559:36 - need but I'll just add it just in case
559:39 - okay I need to download it yet so we're
559:41 - not gonna do that now so window dialog
559:44 - box
559:46 - so I've already installed it
559:50 - so these two
559:52 - so we'll use this for obstacles and
559:55 - stuff
559:58 - and lastly we'll just have some trees
560:01 - maybe at the side we could have
560:02 - something
560:05 - Stone Pine Forest
560:09 - and go ahead and add it once everything
560:12 - is complete
560:13 - now depending on your system if you have
560:16 - a hard drive or something this process
560:17 - is going to be a little bit slow so this
560:20 - is under my unreal project endless
560:23 - Runner so we'll be using the file
560:25 - explorer for this and I'll just delete
560:27 - this later on
560:31 - so now once the engine is loaded up we
560:33 - can start making our game and we'll go
560:36 - ahead and create a Maps folder first so
560:38 - right click Maps will have only one and
560:41 - all the obstacles will be spawned at
560:44 - runtime dynamically when you're playing
560:46 - the game so we don't really care about
560:48 - having multiple Maps but we'll have two
560:50 - so one is going to be your main menu
560:53 - and the other one is going to be the
560:56 - actual map
560:57 - so I'll go ahead and create the map and
561:00 - I'll call this one game map
561:04 - all right save that and go ahead and
561:06 - open the main menu head into project
561:08 - settings and just change that as well so
561:11 - under your maps and modes you should
561:14 - have open world we'll change that to
561:16 - main menu
561:17 - so editor startup map will be main menu
561:19 - and it's going to be main menu again
561:23 - so editor we can start with our game map
561:25 - actually
561:26 - but the game has to start from main menu
561:29 - so
561:31 - just go ahead and click import doesn't
561:34 - really matter
561:37 - all right
561:39 - now over here we can start making our
561:42 - main menu so right click create a new
561:45 - folder and we'll call this one content
561:47 - once again
561:48 - and inside this will actually create
561:50 - stuff because the main content folder is
561:52 - a bit clogged up
561:54 - so we'll call this one UI and we can
561:56 - create a main menu right click user
561:58 - interface widget blueprint create a user
562:00 - widget and we'll call this one main menu
562:02 - or BP underscore main menu
562:07 - and we'll suffix that with a WB to
562:11 - indicate it's a widget
562:12 - and it's going to be just quick and
562:14 - dirty so we'll add a canvas panel here
562:17 - and at the center we'll just have a
562:20 - start button and an exit button so we'll
562:22 - add in a vertical box
562:24 - so vertical box
562:27 - and over here we can go ahead and make
562:30 - this Center aligned first of all
562:33 - Center align position zero
562:36 - with 0.5 for the alignment value so this
562:39 - is going to make sure everything is
562:41 - centered we can go ahead and increase
562:43 - the size a bit
562:45 - even vertically
562:46 - and we can go ahead and add in two
562:48 - buttons so button one
562:51 - and Ctrl D to duplicate
562:53 - we'll make it so that it fills it and we
562:56 - obviously want the play button to be
562:58 - bigger we don't want our users to exit
563:00 - the game
563:01 - anyways we'll add in the the text here
563:04 - so add in some text add in some text and
563:07 - change the background color for both of
563:09 - these buttons make it almost black
563:13 - maybe not exactly black but almost
563:16 - so I like this shade of color
563:19 - now rename this to play
563:22 - or rather start we can try
563:25 - change the font maybe so the font we'll
563:29 - use is going to be the light one
563:31 - so 40 seems about right
563:35 - make this one 40 as well and this one is
563:37 - going to be light and this one is going
563:40 - to be exit
563:41 - so we can add the functionality as well
563:43 - because this is pretty simple so on this
563:46 - button we'll rename this to exit button
563:49 - or it's really not required I guess
563:51 - so on click
563:54 - and for this one as well we are going to
563:56 - add a non-click this is the start button
563:58 - so I'll just comment this out
564:01 - and for this we can go ahead and execute
564:04 - console command and we can type in exit
564:07 - now our exit button should work we can
564:09 - go ahead and test that first of all we
564:11 - haven't even created the widget so under
564:13 - content we will go ahead and create a
564:17 - new folder and call this one blueprints
564:21 - and we'll have two subfolders here we'll
564:23 - call one as game and the another one as
564:25 - main menu because we'll have different
564:27 - player controllers and stuff for the
564:29 - main menu and the actual game so under
564:31 - main menu right click go ahead and head
564:34 - into blueprint class and create a player
564:36 - controller
564:37 - and we'll call this one BP
564:40 - main menu
564:42 - player controller so this is basically
564:45 - for you know creating the widgets and
564:46 - stuff we'll just use the play controller
564:49 - now under the event graph we can just do
564:51 - it on begin play so we'll create a
564:54 - custom event custom event
564:56 - create main menu
565:00 - and create a widget
565:04 - it's going to be BP main menu widget
565:06 - blueprint and add this to the viewport
565:09 - now we I don't think we really need the
565:12 - reference but we'll just store a
565:13 - reference to it anyways so
565:16 - main menu widget blueprint we'll just
565:19 - have a reference to it
565:20 - and from this we can go ahead and add it
565:22 - to the viewport
565:25 - all right and on begin play we can
565:27 - create the widget so create widget or
565:30 - rather create main menu is the function
565:31 - name
565:33 - so create main menu
565:36 - and now if I compile save it go ahead
565:38 - and press play
565:39 - as you can see nothing happens because
565:41 - we haven't changed the game mode yet so
565:43 - over here we'll create a new game mode
565:44 - so go ahead all classes
565:48 - game mode so we'll create a game mode
565:50 - base
565:51 - so we'll call this one
565:53 - BP underscore main menu game mode
565:58 - now under your world settings go ahead
566:00 - and change your game mode to BP Main
566:02 - menu game mode
566:04 - and over here the player controller can
566:06 - be our BP main menu player controller
566:09 - and now if I go ahead and press play we
566:11 - should get a button start won't do
566:12 - anything but exit is going to work
566:15 - now let's actually head into our game
566:17 - map here so Maps game map will worry
566:21 - about the main menu a bit later so we
566:23 - are in the game up we can go ahead and
566:25 - add our sky so Sky atmosphere Skylight
566:28 - and we can add in our directional light
566:32 - we can also have a fog so we can have
566:35 - exponential height fog and we have
566:38 - everything set up
566:39 - now we could change the time of day as
566:42 - well we'll make this one Dynamic for now
566:44 - so fully Dynamic light because I don't
566:47 - have any time to actually build this so
566:51 - go ahead and rotate it to make it like a
566:54 - morning or evening scene
566:56 - this should be about good not gonna
566:58 - spend too much time on it save it up
567:00 - and over here under content now we can
567:03 - start building the actual level
567:05 - so I'll just go to my blueprints folder
567:09 - here under game I'm going to create the
567:11 - game mode and stuff for this one as well
567:13 - so type in game mode
567:16 - so I'll create gamma BP game mode
567:21 - this one is just going to be called BP
567:23 - game mode because this is for the actual
567:26 - game itself
567:27 - under your world settings go ahead and
567:28 - change that once again so BP underscore
567:31 - game mode will have a CPP game mode if
567:34 - we really require but I'll try to stick
567:36 - with blueprint as much
567:38 - now let's check our time so 10 minutes
567:40 - in
567:41 - now under your game mode will also have
567:43 - a game state to counter score and stuff
567:46 - so game state
567:48 - so game stead base
567:51 - BP underscore
567:53 - game state
567:56 - so we have our game mode oops
567:59 - and we have our game state
568:02 - and now we can also have our character
568:04 - and stuff so we can create that first of
568:07 - all we can just right click blueprint
568:10 - class character and we can type in BP
568:13 - character
568:17 - open it up and we have some basic things
568:20 - already set up for this mesh we'll be
568:23 - using one of these which you bought
568:24 - under man
568:26 - under mesh full we have all these
568:29 - various options so we have four options
568:32 - so we'll be using these four so these
568:34 - four will be the options for the players
568:36 - to choose from That's How we'll do it
568:39 - so we'll create a derived class for this
568:41 - for BP character
568:44 - so under our characters what we can do
568:46 - is I can type in character
568:51 - I'll just move this here
568:53 - and go ahead and type in subclasses
568:58 - so these with this is like your main
569:00 - character
569:01 - so every character is going to be a BP
569:04 - character but then we'll specifically
569:05 - make them choose a mesh
569:08 - so go ahead and create a blueprint Class
569:10 - Type in character
569:13 - and
569:15 - over here we can make it of type BP
569:17 - character
569:18 - and call this one character one we can
569:21 - actually just name them maybe we'll call
569:23 - one Adam duplicate that we'll call One
569:26 - John I'm just giving generic names we
569:28 - had four
569:30 - so we can call one Json and
569:34 - maybe we can call one bill I just chose
569:36 - random names
569:38 - so open this up and for the mesh we can
569:41 - go ahead and start replacing it
569:43 - so head into the location where we had
569:45 - the mesh so this is going to be a first
569:48 - character we'll set up the animation
569:50 - blueprint a bit later
569:52 - so it's a bit off but not to worry we
569:55 - can go ahead and adjust that
569:58 - negative 90.
570:01 - and we can head into the other classes
570:04 - here
570:06 - so under content blueprint game
570:09 - character subclasses we can head into
570:12 - bill
570:14 - and this was called SK manful one so
570:17 - we'll call this SK Man full 2.
570:23 - over here we can select SK Man full
570:25 - three
570:27 - so SK man
570:29 - full three
570:31 - and for this one we can have SK Man full
570:34 - four so SK man
570:37 - full four
570:39 - so that's pretty much all set
570:43 - so I'm not sure if I should just use the
570:45 - default one here so man
570:48 - full one
570:51 - not sure if it'll inherit the transform
570:53 - so I'll just try this I'll compile
570:57 - compile this
571:00 - so if I open the full blueprint editor
571:02 - okay it has inherited the transforms
571:04 - that's a good thing
571:05 - so we don't have to do everything once
571:07 - again
571:08 - all right so we have our character set
571:10 - up
571:11 - uh in our main menu we can go ahead and
571:14 - add a character selection option
571:16 - so head into content uh our actual
571:19 - content folder
571:21 - under the main menu we can have a button
571:23 - somewhere
571:25 - and maybe over here we can type in
571:27 - change character
571:31 - so I'll change the color of this I'm not
571:33 - really worried about the visuals as of
571:35 - now
571:36 - so I'll just go ahead and change this
571:38 - okay I change the color so background
571:41 - color I'll just make this dark again
571:44 - and we can add in some text
571:47 - and we'll call this one
571:50 - change character
571:52 - all right
571:54 - make this a little bit wider
571:58 - so that it's visible for our player so
572:00 - make this one 45 maybe or 35 35 seems
572:05 - good we'll make that one light once
572:07 - again
572:08 - maybe we could make start a bit
572:11 - Bolder so let's start be regular because
572:14 - we want our players to deliberately
572:16 - click Start
572:18 - all right so once you click on the
572:20 - change character menu it should just
572:22 - give us a list and we will create the
572:24 - widget for that
572:26 - now we'll also need a game instance
572:28 - class
572:29 - head into Blueprints and game instances
572:33 - General so we'll create one here so game
572:35 - instance
572:38 - go ahead and call this one main GI or
572:41 - something
572:42 - and under the project settings we can go
572:44 - ahead and change it so game instance
572:48 - oops game instance
572:50 - change that to main GI
572:53 - and over here we can have a variable for
572:56 - selected character
573:00 - and we can change that actually we can
573:03 - change that to be of type BP character
573:06 - class
573:08 - so we have BP character we should see it
573:10 - somewhere here BP character class
573:12 - reference
573:13 - so this is going to be the the character
573:16 - which we have actually selected or we
573:18 - could have it in a struct we'll think
573:19 - about that a bit later
573:21 - now once we have that we can go ahead
573:24 - and start making the actual obstacles
573:26 - and stuff
573:28 - so one thing to note is that we want to
573:30 - make this modular in a way we want to be
573:33 - able to spawn them one after the other
573:36 - let's just go ahead and do that
573:39 - so on when the game starts we want to
573:42 - have a bunch of obstacles
573:44 - and then we'll look at what to do
573:47 - uh we'll work on the obstacles after we
573:50 - work on the animations actually
573:52 - so we'll head into the skeletal mesh we
573:55 - have certain animations
573:57 - so content content blueprint will add
574:01 - into character
574:03 - and we'll create the animation blueprint
574:05 - right here so animation animation
574:08 - blueprint and we'll go ahead and select
574:10 - our ue4 mannequin skeleton
574:13 - this is the one which comes with the
574:16 - pack actually
574:17 - so create
574:18 - and we'll call this one character and
574:21 - MVP
574:25 - open it up and inside this we have a
574:29 - bunch of things so we'll create a state
574:31 - machine
574:33 - doesn't really matter now we can go
574:35 - ahead and have an idle
574:38 - so we'll have idle
574:41 - and we can have we'll create a blank
574:43 - space for this
574:46 - so right click go ahead into animation
574:50 - so basically this is for transitioning
574:53 - between your idle and walk animations
574:56 - blend space
574:58 - and we'll call this one walk run
575:04 - okay
575:06 - over here we'll have few things in the
575:09 - horizontal and the vertical axis
575:11 - horizontal axis is going to be the
575:13 - direction and the vertical axis is going
575:16 - to be the speed
575:17 - so we'll go between 0 and 600 but we'll
575:21 - see if we can do something else a bit
575:23 - later on
575:25 - now open this and we can have our third
575:29 - person walk halfway over here
575:31 - we can have our third person run
575:34 - full way
575:36 - and we can have our third person idle at
575:39 - zero
575:42 - so we transition between these something
575:44 - like this for the direction we'll have a
575:47 - negative 180 and positive 180 obviously
575:50 - so this will be like your angle from
575:52 - your forward Direction that's basically
575:54 - what this is
575:56 - now we can change the animation
575:58 - blueprint after we actually set it up
576:00 - first so for the idle we have our idle
576:03 - animation playing and we should already
576:05 - have this working
576:07 - and we can have this as a new state so
576:10 - walk run
576:12 - we will set up the conditions not to
576:14 - worry
576:16 - oops go ahead and do that
576:19 - so on begin play
576:23 - begin play
576:26 - we can go ahead and get the pawn owner
576:29 - and cast to BP character
576:32 - and we can make this a pure cast because
576:34 - this will succeed
576:36 - or if it doesn't we can go ahead and
576:38 - pull it
576:40 - and once we get access to our character
576:44 - what we can do is we can get access to
576:47 - the speed so get velocity
576:52 - so get velocity
576:57 - and we want the vector length
577:01 - right now we have a vector and we want
577:04 - the magnitude of this vector
577:06 - and we can promote that variable and
577:09 - obviously the magnitude of the Velocity
577:10 - is nothing but speed so speed
577:14 - and we can also have Direction so get
577:18 - actor rotation we'll set it up a bit
577:20 - later actually
577:22 - okay so under the update animation
577:25 - what we can do is
577:27 - we'll need this on every frame so we'll
577:29 - use a reference instead so promote this
577:32 - to a variable
577:33 - and call this one character ref
577:37 - we'll be using this multiple times
577:41 - so we can drag this over there
577:44 - so this will be our speed
577:48 - and also
577:50 - what we can do is we can also get the
577:53 - direction
577:54 - so we can use this function known as
577:56 - calculate Direction
577:59 - and that is what will set the direction
578:02 - to be set Direction
578:04 - so we'll create a new variable called
578:07 - Direction
578:09 - it's going to be a float once again
578:11 - and we're going to set the direction
578:15 - to be equal to whatever this is
578:18 - for the velocity we can just uh grab in
578:22 - or get velocity here
578:24 - and base rotation is going to be the
578:27 - actor's rotation itself
578:29 - so get actor rotation
578:35 - and we can plug this into the velocity
578:37 - as well now what we are basically doing
578:39 - is we're calculating the direction so
578:42 - that we actually input the value
578:44 - correctly in our blend space basically
578:46 - we are not using this value anywhere
578:48 - else so here we can plug in our
578:50 - direction and speed so Direction
578:53 - and speed so these were our vertical and
578:55 - horizontal axis values in our blend
578:58 - space
578:59 - we can also have jump which we will do
579:02 - we have we don't have a state transition
579:05 - so if speed is greater than let's say 10
579:09 - we can go ahead and transition
579:12 - and over here as well if the speed is
579:14 - less than 10 we can transition so
579:17 - rather speed
579:19 - so speed is less than or equal to 10.
579:23 - we can go ahead and transition into this
579:25 - state
579:27 - so now we shouldn't have any of those
579:29 - warnings
579:30 - all right now if I actually create
579:33 - something here
579:35 - so I'll just create a player start so
579:37 - we'll know where to start so player
579:39 - start
579:39 - and I'll just go ahead and box out a
579:42 - simple level
579:43 - so shapes
579:45 - so I'll have a cube
579:48 - and I'll just make this really really
579:50 - big
579:52 - so this is just for testing purposes and
579:55 - for the default Pawn class I'm going to
579:57 - select BP character
579:59 - and let's set up the animation blueprint
580:03 - over here if we go ahead and select our
580:08 - character anime nmbp
580:10 - in theory everything should work fine
580:14 - so our camera is a bit off that's
580:17 - nothing to worry about
580:21 - so under our BP character we need to set
580:24 - up a camera so add a component and this
580:27 - will be of type camera
580:30 - go ahead and add it
580:33 - we can adjust the view that's nothing to
580:35 - worry about
580:36 - and if I go ahead and press play we have
580:39 - our camera here
580:40 - so we can make that a little bit
580:43 - further back
580:46 - maybe tilt it down a bit
580:48 - and I hope this looks good okay so this
580:51 - looks good
580:52 - so we have access none in our character
580:56 - animation blueprint
580:58 - so that's only
581:01 - in the first frame which is happening
581:03 - basically so we can convert this to a
581:06 - validated get
581:08 - that's a simple fix
581:12 - you can go ahead and turn that into
581:13 - validated get go ahead and press play
581:18 - and now we shouldn't get those errors
581:20 - you can set up our moment logic real
581:22 - quick here
581:23 - so if the characters always going to be
581:27 - moving
581:28 - and I think we might have to change the
581:31 - animation blueprint here because we
581:33 - always want him to be running
581:35 - because we don't want him to stop so
581:38 - we'll always have running actually
581:42 - so sorry for that but anyways
581:45 - something we can do
581:47 - so he'll always be running
581:52 - so this is how he'll always be
581:55 - and we can also have you know a copy of
581:57 - this
582:00 - so we'll just copy this over and we can
582:03 - type in run fast we can make this go at
582:07 - a higher speed
582:08 - so there should be a speed multiplier
582:10 - somewhere here
582:12 - so playback speed is what it's called I
582:15 - assume
582:16 - so playback speed
582:22 - so nothing under the details
582:25 - we'll look into that so there's actually
582:28 - an option called playback speed so we
582:30 - are going to increase the speed and make
582:32 - it so that
582:33 - it's actually as if he's running
582:37 - now what we can do
582:42 - is
582:44 - we can head into the character once
582:47 - again
582:48 - and now that we have him running
582:50 - continuously we'll actually do it so
582:53 - that the obstacles in the world actually
582:56 - go backward
582:58 - you can create the blueprint for that
583:00 - now so we're finally heading into the
583:02 - obstacles so
583:03 - we'll spend 25 minutes not done really
583:06 - really that much
583:08 - and again
583:11 - in the blueprints folder we can go ahead
583:13 - and create a new blueprint class we'll
583:16 - do it in the new folder so we'll call
583:18 - this one course rather this will be the
583:22 - obstacle course basically
583:24 - and we'll create a new actor
583:27 - and we'll call this one
583:30 - obstacle
583:32 - underscore base
583:34 - and we can go ahead and create a child
583:37 - blueprint class and we'll call this one
583:38 - obstacle one obstacle 2 and so on
583:41 - so obstacle 2
583:44 - duplicate that duplicate that duplicate
583:47 - that will have five
583:49 - we'll see if it if it gets too hectic
583:51 - we'll reduce this number
583:54 - over here we'll need some sort of a base
583:56 - so we can try using some of the things
583:59 - which we got from the content packs
584:01 - so under hanger I guess we had a road I
584:04 - believe
584:05 - I type in Road
584:08 - we have this which is pretty tileable I
584:10 - believe
584:13 - over here Road set
584:17 - we have this so we can use this
584:22 - just that we'll need to know what's the
584:24 - length of this and stuff
584:26 - I don't think we'll go for nanite or
584:28 - anything
584:30 - this is fine
584:32 - so close some of these which we are not
584:34 - using
584:36 - head back into the obstacle base
584:40 - over here we can go ahead and add in a
584:42 - static mesh
584:44 - and this will be common for everything
584:45 - so head back select that
584:49 - and go ahead and
584:52 - put that in
584:55 - so this is there at the origin
584:58 - but not to worry we'll find a way to fix
585:01 - that
585:03 - so it would have been nice if we had
585:04 - multiple Lanes
585:06 - but we have to live with this right now
585:10 - so I'll just go ahead and re-center this
585:14 - I'm not sure how
585:17 - big this is going to be
585:20 - so I think that is pretty well centered
585:23 - we can go ahead and add an arrow
585:25 - component just for a reference
585:28 - so add in an arrow component
585:31 - attached to the root
585:35 - this one is going to be at the origin
585:37 - obviously
585:39 - just rotate that for our reference
585:43 - or we'll keep the rotation to zero we'll
585:45 - look into the rotation and stuff so
585:47 - we'll duplicate this once again
585:50 - so Ctrl D to duplicate
585:54 - and we'll just have one over there I
585:57 - think one is enough but we'll just have
585:59 - it just in case
586:02 - all right so this is exactly at the end
586:06 - now at first we can spawn for example 10
586:09 - of these
586:11 - and then we can later see what to do
586:15 - we can have something in the side by the
586:17 - way we don't have anything
586:19 - so we'll just add in a plane
586:24 - and for this we can increase the scale
586:28 - of this
586:29 - maybe we can make this 100 I guess
586:34 - okay that's a little too big 50.
586:36 - maybe change it on the Y 50 is a bit too
586:39 - much 40.
586:41 - Maybe 30.
586:43 - 35
586:46 - 2 seems to be about right
586:49 - so it aligned perfectly here
586:52 - and it aligned almost perfectly here as
586:54 - well
586:55 - I can have 32.
587:01 - now this is approximate you can do it
587:04 - accurately when you actually do it
587:09 - so go ahead and duplicate this once
587:12 - again we'll attach it to the root
587:16 - duplicate this will be for the other
587:18 - side
587:23 - all right
587:30 - so we have something on both the sides
587:35 - now if we head into a derived classes we
587:37 - should also have all of those
587:41 - well we can spawn this first of all just
587:43 - for testing it out
587:46 - so open the level blueprint
587:48 - and we can just do a for Loop
587:54 - so for Loop
587:58 - and we can have a loop of length 10
588:01 - let's say
588:06 - we'll select An Origin
588:08 - we'll start from a certain point
588:14 - so Target point
588:17 - we can start here maybe we'll make the Z
588:19 - value of this zero
588:21 - will make the X and Y 0 as well
588:25 - so this is going to be where we start
588:31 - and we can go ahead and start spawning
588:33 - this further on
588:35 - so we'll have access to this target
588:37 - point now so create a reference to
588:39 - Target point
588:41 - so we are going to spawn actor from
588:43 - class and it's going to be BP obstacle
588:49 - I'm not sure what we called it obstacle
588:52 - base
588:53 - this is for testing so it's fine
588:57 - so it can get active location it's going
588:59 - to be zero I'm aware but in case we
589:02 - wanted to change it the logic should
589:04 - still work that's why I'm using the
589:05 - target point
589:07 - so get actor location
589:09 - we'll break this down actually
589:13 - split the struct PIN
589:15 - now the Y and the Z are going to remain
589:18 - zero
589:20 - so I have to see which is the forward
589:22 - axis here actually
589:24 - so in the obstacle base
589:26 - we have y as the forward axis
589:30 - we can rotate everything by 90 degrees
589:32 - if we don't mind
589:34 - you can just rotate everything by 90.
589:38 - oops we change the location
589:43 - so we can change this to 90.
589:48 - and stuff doesn't seem to be working
589:51 - we'll have y as the forward axis in our
589:54 - case don't mind
589:57 - so the x value is going to be 0.
590:01 - we are going to split the struct PIN
590:05 - so we're going to multiply this
590:07 - multiply this by the index
590:10 - and we can go ahead and split this and
590:14 - the Y is going to be this
590:16 - X and the Z are going to remain zero
590:19 - let's go ahead and just test this out so
590:23 - go ahead
590:24 - selected viewport
590:26 - so if I click f8 and if I were to notice
590:32 - we don't have anything
590:37 - so we should have our
590:41 - Target okay we are taking the target
590:43 - points Y location
590:45 - but
590:47 - we need the last obstacles location
590:51 - so we need the value of this actually
590:54 - we need the location of
590:57 - this Arrow
591:00 - so this Arrow
591:03 - so this arrow is going to be located
591:08 - at negative 3200.
591:12 - so we'll just copy the number we'll just
591:14 - brute force it here
591:19 - so we have the target point
591:21 - that's where we start
591:25 - and into
591:28 - 3200
591:31 - so it's negative 3200
591:37 - so I'm not sure if we really need this
591:39 - this is going to be 0 anyways
591:42 - so this into 3200
591:48 - index into 3200 now let's try this
591:54 - okay so our obstacle course is spawned
591:57 - successfully
592:03 - so a bit of an issue with the direction
592:06 - over there but that's totally okay
592:12 - all right so we have
592:15 - that completed so we spawned our initial
592:19 - course
592:21 - so we can grab in our player start first
592:24 - of all and we can rotate that we can
592:27 - delete one of them
592:30 - we can maybe rotate that negative 90
592:32 - degrees
592:35 - so now we should face the right
592:37 - direction
592:39 - now move this a little bit to the left
592:43 - so for reference we'll just have one
592:45 - obstacle
592:50 - so we'll just have obstacle base we'll
592:53 - set everything to zero zero zero zero
592:57 - and we'll base the player start
592:59 - accordingly
593:00 - so our player start just disappeared
593:03 - somewhere
593:05 - okay it's up there
593:07 - so we'll click end to Snap It to the
593:10 - Ground
593:12 - go ahead and do that
593:17 - and now we should in theory be centered
593:20 - hopefully
593:22 - yep we will be centered now
593:25 - now if I go ahead and press play as you
593:28 - can see we are centered
593:30 - now we can also set up the logic to move
593:33 - sideways
593:36 - so we can linear interpolate actually
593:39 - so we'll add in Target points
593:43 - so copy the server we'll copy the
593:47 - X location of this
593:50 - so X is going to be 20.
593:54 - we need 20 here
593:57 - and the Y location
593:59 - really should be the same actually again
594:04 - so Y location should be the same
594:07 - now we have got these in the same spot
594:10 - now we can have few more
594:14 - so these two are equally spaced now we
594:17 - can set up some logic
594:19 - so that we slide between these basically
594:23 - head back into the character to set that
594:25 - logic
594:27 - under your BP character if we press the
594:30 - right arrow we won't do changeable
594:33 - controls so right
594:36 - Arrow
594:37 - so right
594:39 - and we can have left as well
594:42 - so keyboard events left
594:44 - under right and left we can change them
594:48 - so if we press right
594:51 - we also need access to which Target
594:53 - point we are at right now
594:56 - we can have all of these in a blueprint
594:59 - we can have these in the game state
595:03 - content blueprints game game state
595:08 - we can type in
595:10 - will have an enum
595:12 - it's going to be simple
595:14 - so content
595:16 - will create enums so enum
595:21 - right click create an enumeration
595:25 - and over here we'll call this one
595:28 - which side of the road you're in
595:30 - basically so I don't I don't even know
595:31 - what to call this e
595:34 - which side I guess
595:37 - I mean which is kind of stupid but at
595:40 - the same time it's descriptive
595:43 - so it's either going to be left okay or
595:45 - at the center by default so I'll have
595:47 - Center first center left and right
595:53 - so if I save that and head back into my
595:56 - game State now I should be able to
595:57 - create a variable of type which side
596:01 - which side e which side so just my
596:04 - naming convention
596:07 - so we'll call this one
596:10 - with side Maybe
596:14 - all right
596:15 - so we'll have access to this at any
596:18 - given instance
596:19 - and on begin play we can store a
596:21 - reference to this
596:23 - get game state
596:26 - we can go ahead and cast to our BP game
596:29 - state
596:31 - and we'll have a reference to that
596:34 - promote that two variable and call this
596:36 - one game State ref
596:42 - okay
596:44 - now from here when we press right we can
596:48 - first of all get access to the variables
596:50 - the first variable which we need is the
596:53 - only variable which we have right now
596:55 - basically which is the side
596:57 - so we'll type in side
597:01 - and we'll do a simple switch
597:05 - so if we are at the center right now
597:09 - we can go to the right
597:11 - if we are at the left right now
597:15 - we can go ahead and head to
597:18 - the left basically
597:20 - uh if we are at the left we can head
597:23 - into the center if we are at the right
597:25 - we don't need to do anything so
597:27 - basically on Center and left we can do
597:29 - that
597:30 - again we'll copy over this logic
597:38 - depending on which side we don't want to
597:40 - do anything if we are on the left side
597:42 - here in this case
597:45 - and we can linear interpolate on tick
597:51 - so a linear interpolate is what we'll
597:53 - just do so we'll type in lurp
597:56 - and we should find a linear interpolate
598:00 - and we should be able to feed in the
598:02 - alpha we'll think about a logic for that
598:08 - now we'll have access to where we are by
598:11 - default we are at the center
598:19 - just took a small break there now over
598:22 - here we can continue with our side
598:25 - switching logic so we'll actually get
598:28 - hold of all the locations and stuff
598:32 - so by default we are over here
598:35 - so if I press play we are over here
598:38 - but when we want to move we want to move
598:41 - to either this or this
598:45 - so we'll actually have a few variables
598:48 - for this I'm going to be hard coding
598:50 - this but you can have a more elegant
598:52 - solution for all of these
598:55 - so I can go ahead and under my game
598:57 - State itself I can have right location
599:02 - right location
599:04 - center location and left location so
599:07 - I'll duplicate this
599:10 - so I'll call this one left location
599:16 - and I'll call this one Center location
599:22 - and we'll manually set these values
599:28 - so this value over here is negative 230
599:31 - negative 270 and 0. this is the left
599:34 - location so negative 230
599:38 - negative 270
599:43 - to 70 and 0.
599:47 - we can actually save some data I Believe
599:49 - by using floats we only need the we only
599:52 - need to linear interpolate the X
599:54 - Direction so
599:56 - we'll just store the X values of this
600:01 - so
600:04 - this is 270
600:08 - 20 and negative 230 not sure if they're
600:12 - spaced equally I'll just have a look at
600:14 - the top view
600:15 - I want them to be spaced equally
600:18 - so between this and this there is a
600:21 - difference of 250
600:24 - between this and this there is a
600:27 - difference of 250 so yep they are spaced
600:30 - equally
600:33 - okay so the right location is going to
600:36 - be 270.
600:39 - left location is negative 230
600:42 - and this is going to be 20.
600:45 - so I'll just store these like this
600:50 - now what I can do is I can go ahead and
600:54 - actually
600:56 - move the character so I'll try set actor
600:59 - location not sure if this is going to
601:01 - work
601:02 - so if we are at the center we'll try
601:05 - this to try to set this to the right
601:07 - location so we're going left so left
601:11 - left location
601:13 - so we only want to change the X
601:16 - so go ahead and split the struct pin
601:18 - change the left location
601:21 - and the rest is going to be the actors
601:24 - location itself so get actor location
601:27 - go ahead and split this Y and Z will
601:30 - just remain access
601:33 - all right so we can go ahead and try
601:36 - this
601:37 - so if I press the left Arrow
601:41 - so nothing is really happening here
601:44 - so we can see by printing if something
601:47 - is happening
601:50 - so nope we are not actually taking the
601:52 - input something has to do
601:55 - with the input so Arrow
602:01 - left keyboard not really sure I'll I'll
602:04 - try to use a and d for now
602:07 - so a on the keyboard
602:10 - so we'll use wasd
602:14 - so when I press a on the keyboard we can
602:17 - try that a is going to be instead of the
602:19 - left Arrow
602:24 - all right so we did we don't have access
602:27 - to the game State according to this
602:30 - that's mostly because we didn't set it
602:33 - so that's pretty simple to handle so we
602:36 - can change that to BP game instead
602:39 - now over here we can try the left Arrow
602:43 - logic itself
602:45 - so if I type in left
602:47 - not sure what else we have
602:50 - so left is the only thing we have
602:54 - so we can go ahead and try this so left
602:57 - Arrow doesn't seem to work
603:00 - okay left Arrow works
603:02 - so that was the game State issue not
603:05 - our thing
603:08 - so we can use this logic
603:14 - we can linear interpolate instead
603:19 - or we have our
603:21 - interrupt nodes anyways
603:26 - we can have a variable for the Target
603:28 - location so this is where you know we
603:30 - want to get our character so Target X
603:33 - location just to be precise
603:38 - so linear interpolate is going to be a
603:40 - little tough so F in term 2 is what
603:42 - we'll use
603:44 - it's a pure function so F enter up to
603:49 - f f interrupt to constant because we
603:53 - want it to interpolate in a constant
603:55 - rate so Delta time is going to be Delta
603:58 - seconds interrupt speed we can adjust
604:00 - that
604:01 - so we can promote this to a variable and
604:04 - we can call him
604:05 - sideways speed
604:09 - over here we can
604:12 - replace this with the target X location
604:16 - that's going to be the X
604:19 - oh this is an integer we'll make this
604:21 - float
604:25 - so Target X location
604:29 - and
604:31 - current is going to be our current X
604:34 - location
604:38 - so Target is our Target X
604:41 - current is our current X location so
604:45 - current X location
604:47 - so we can get the actors X location
604:50 - again
604:53 - all right
604:55 - so this should be it for the sideways
604:57 - movement
605:00 - and over here we can go ahead and set
605:03 - these
605:05 - if we want to go left we don't want to
605:07 - do anything when we are on the left side
605:10 - all right we can get the game State and
605:14 - we want to go left so left location
605:21 - and we can duplicate that and if we are
605:24 - right we can get the center location
605:30 - okay but the logic isn't done yet I'll
605:33 - get back to it
605:35 - so we can use a select to just make
605:37 - things a little bit more simple
605:42 - so if we are at the center we'll go left
605:44 - if we are at the right we'll go to the
605:47 - center
605:48 - so the logic should make a lot more
605:50 - sense now
605:53 - and we can set
605:56 - this over there
605:58 - move it in
606:05 - similarly we can copy over this Logic
606:08 - for our
606:10 - right
606:17 - so that it simplifies things a bit so if
606:19 - we are on the right we don't want to do
606:20 - anything
606:21 - we'll go to the center if we are on the
606:24 - left
606:24 - and we'll go to the right if we are on
606:27 - the center so get the right location
606:32 - so this is what we'll set it to
606:37 - all right now our logic should work once
606:41 - if I go ahead and press play so if I put
606:44 - put the left Arrow nothing really seems
606:47 - to be happening let's just check out why
606:51 - okay our end of speed is zero
606:54 - okay so now if I try
607:00 - all right nothing really happens so
607:04 - let's try 100.
607:08 - so our actor location
607:12 - seems to be fine
607:14 - so current
607:16 - and Target is okay
607:21 - and now we can go ahead and print hello
607:27 - so we are not changing the location I
607:30 - assume that's what's happening
607:36 - so when I press the left
607:39 - key on the keyboard
607:41 - and when I press the right key so we are
607:43 - changing the target X and the target Y
607:46 - location
607:49 - so we'll try it without the inter first
607:55 - a little bit of debugging will
608:03 - so we can just copy this in
608:09 - so I'll just remove this logic from tick
608:15 - if I hit left or right nothing really is
608:19 - happening
608:23 - so we can print it and check what's
608:25 - going on
608:29 - all right once again
608:31 - the input isn't working we'll use a
608:39 - so we'll go ahead and use a on the
608:41 - keyboard Maybe
608:44 - go ahead and use a
608:48 - so if I type in a
608:51 - the input okay it's just about the
608:54 - window being in focus
608:57 - all right so if I go ahead and run this
609:00 - okay this works now we can try it with
609:03 - the interp logic
609:09 - so now we don't need this
609:20 - okay the speed is just way too less
609:25 - so we can go a bit crazy on this 50
609:27 - Maybe
609:32 - nope still very slow 200
609:40 - okay it's still really slow so 500
609:50 - .
609:53 - okay this is not going to help
609:55 - whoops it's going 50. so if I make this
609:59 - 500
610:03 - okay this is a lot better but maybe 1000
610:06 - would be fine
610:12 - all right so this seems about right
610:18 - but now we need to change our actual
610:20 - State itself
610:21 - so again we'll use this select node
610:24 - right there
610:28 - so if we are in the center
610:36 - we have to set our side so we'll grab a
610:39 - reference to the game state
610:41 - and we'll set the side
610:46 - depending on where we are
610:51 - so if we were at the center and we moved
610:53 - left we'll set our side to left
610:56 - so Center will set it to the left if we
610:58 - were at the left it's going to be left
611:00 - itself if we are at the right we'll make
611:02 - the center
611:05 - copy over the logic
611:09 - Okay so
611:12 - for this
611:14 - so everything will remain the same
611:16 - except when we are on the left and we go
611:19 - right it's going to be Center if we are
611:21 - on the right it's going to remain right
611:23 - if we are at the center it's going to go
611:25 - right
611:29 - okay so now we can go ahead and try this
611:31 - out
611:33 - so something happened with our logic
611:37 - right there
611:39 - okay so we had to get the actors
611:42 - location instead
611:44 - we made it zero so we just sunk under
611:46 - the ground
611:47 - so go ahead right left right left right
611:59 - okay so it is a bit glitchy
612:06 - it is a bit glitchy at times
612:10 - so let's try enabling teleport sometimes
612:13 - that should fix the issue
612:18 - okay when I'm at the right he's moving
612:21 - to the Center for some reason
612:23 - so when I'm at the right and I click
612:25 - right again
612:27 - so the logic is when I'm at the right
612:30 - and I click right again I should still
612:32 - remain at the right when I am at the
612:34 - left I move to the center
612:37 - so let's try that
612:40 - so I go to the right
612:42 - click right again I go to the Center for
612:45 - some reason
612:46 - so when I'm on the right the target
612:50 - shouldn't actually be this it should be
612:52 - the right location itself
612:54 - when I'm on the left this shouldn't be 0
612:56 - this should be the left location itself
612:59 - because you're doing the inter Pawn tick
613:01 - so that's why it's happening
613:03 - left right and Center
613:08 - all right so now our logic is working
613:10 - totally fine and we can stop printing
613:13 - hello it's just annoying at this point
613:17 - okay then I think we exceeded one hour
613:19 - okay we're pretty close
613:21 - but we are left with our last few steps
613:24 - now we have to make the obstacle move
613:26 - which is pretty simple
613:29 - now we can spawn it dynamically instead
613:32 - rather than spawning it or rather just
613:35 - using this
613:36 - I think we are spawning it yep we are
613:40 - so I can press f8 head into my
613:43 - perspective View
613:46 - and now for the magic
613:50 - head to the obstacle blueprint itself
613:54 - course obstacle base
613:57 - we can try this on tick
613:59 - so on tick we want to set the actor's
614:03 - location so we want to change the
614:06 - location of this actor
614:08 - we will get the current location so get
614:11 - the location of this actor so get actor
614:13 - location
614:14 - and
614:16 - when we move forward we are increasing
614:19 - the y basically
614:22 - so when we move forward we are
614:25 - increasing the Y
614:27 - so the logic was wrong okay when we move
614:31 - forward we are going more towards the
614:34 - negative y direction
614:39 - so
614:41 - what we can do is we can go ahead and
614:43 - move it backwards so we want to increase
614:46 - the Y
614:49 - so the x is going to remain constant
614:52 - the X will be as is
614:56 - delete that
614:58 - split the strut pin Z is going to remain
615:01 - constant but Y is going to be y Plus
615:06 - let's just say 1
615:09 - times Delta time Delta seconds let's try
615:12 - Delta seconds itself first this should
615:15 - remain constant for All actors because
615:17 - this is tied to frame rate
615:21 - so I think it's moving but it's moving
615:24 - very very slowly
615:26 - yep it is moving as you can see but it's
615:30 - moving very very slowly
615:32 - so we can just go ahead and multiply
615:34 - this so multiply this by some value
615:39 - let's just say we multiply this by 100
615:45 - so not sure if
615:48 - yep there we have it
615:52 - so as you can notice it's not actually
615:55 - the character that's moving it's the
615:57 - whole obstacle course which is moving
616:01 - and what's weird is our characters
616:03 - actually following it even though we
616:05 - haven't actually attached him over there
616:13 - okay so we can fix the
616:15 - uh X location of the character as well
616:18 - because he seems to be just sliding
616:21 - along
616:24 - so there is actually a setting somewhere
616:26 - here
616:29 - so it shouldn't slide along the surface
616:33 - so something or there
616:37 - character movement Maybe
616:40 - and there is
616:43 - something over here okay ground friction
616:45 - let's try zero on that
616:49 - okay we are just still moving back so if
616:52 - it if I hit f8 actually the whole thing
616:56 - is moving back
616:59 - so instead of that we will just set the
617:01 - uh location the X location every time to
617:05 - be constant
617:07 - or rather the Y location
617:10 - I'm not sure what it was so we'll copy
617:13 - it
617:14 - so Y is negative 270 so negative to 70.
617:19 - I don't want that to change
617:22 - and as you can see our logic is working
617:27 - and it seems like we are moving forward
617:29 - the speed is something which we can
617:31 - worry about a bit later so maybe make
617:33 - this 300
617:36 - and as you can see it feels like
617:38 - they're actually moving but what's
617:40 - actually happening is the whole course
617:42 - is just moving the character is actually
617:45 - standing still
617:47 - so
617:49 - now our man is going forward
617:51 - we can finally go ahead and set up the
617:54 - obstacles itself I guess
617:56 - and add in a jump State obviously
617:59 - because right now he doesn't jump so we
618:01 - can adjust the speed maybe 350 a little
618:03 - more quick would have been nice
618:08 - go ahead
618:11 - okay with that something we'll worry
618:13 - about later
618:16 - now
618:18 - uh for our next step
618:20 - so I don't think we really require
618:22 - teleport so our X Y and Z is all set
618:26 - so for this we'll be using the jump as
618:29 - well so we'll go ahead and create a
618:33 - binding for our space bar
618:35 - space bar and we'll call this one jump
618:41 - and when I release this we are going to
618:43 - stop jumping
618:47 - okay
618:49 - so now we should in theory just go up
618:54 - we can adjust the settings of the jump
618:56 - under our character movement component
618:59 - and we can also have animations so
619:04 - under our animation blueprint we can set
619:06 - it up
619:07 - so content blueprints game character
619:11 - and MVP
619:14 - we can ignore this and we can add a
619:16 - state and this is going to be jump
619:20 - jump start
619:22 - and jump Loop
619:26 - jump Loop
619:29 - all right so jump start
619:33 - jump Loop
619:35 - and we'll see what animations we have
619:40 - and from our jump Loop
619:43 - we want to go back to our run animation
619:46 - basically
619:48 - so jump start is going to be a third
619:51 - person jump
619:54 - and for the transition we'll have we'll
619:58 - check if we are jumping
620:01 - so if we have our character reference
620:03 - here
620:06 - so
620:09 - is there any variable
620:13 - not sure
620:15 - we can try this
620:20 - okay nothing's really happening
620:23 - okay we are getting a runtime error
620:27 - saying we don't have
620:30 - the character ref
620:33 - so we'll only access this in the anim
620:36 - graph
620:39 - so go ahead if this is valid we will go
620:42 - ahead and okay we can check if it is not
620:45 - valid first of all
620:51 - so we only get it once
620:53 - and occasionally it's going not valid
620:57 - so we can promote this two variable and
621:00 - call this one jumping
621:07 - and
621:08 - in our transition
621:12 - you can set it up
621:16 - okay so the variable isn't doing
621:18 - anything
621:23 - so we can head back to the character and
621:27 - create a variable for it in the first
621:28 - place
621:30 - so jumping
621:36 - now we can go ahead and set this to true
621:40 - we can go ahead and set this to false as
621:42 - soon as we release it
621:48 - get jumping
621:54 - okay this logic should work
621:57 - uh this is jump start to jump Loop so
622:00 - when
622:01 - our time remaining for our jump
622:07 - is less than let's say 0.05 seconds
622:11 - we'll enter this transition
622:14 - and jump Loop to third person run when
622:17 - this jumping is false basically
622:21 - so not
622:25 - not Boolean I guess it's called
622:28 - so we'll just invert the value
622:31 - now if I go ahead and press space okay
622:34 - the animation is weird
622:41 - so we can
622:45 - again do and maybe and
622:49 - if the jump Loop has at least played
622:51 - once so jump Loop
622:56 - so we can get access to the jump Loop
622:59 - here
623:01 - so time remaining time
623:04 - remaining for the jump Loop
623:08 - is less than 0.05 we can try this logic
623:17 - okay we just went into a completely
623:19 - random State there again probably some
623:22 - logical error
623:27 - okay so in our jump Loop we haven't fed
623:30 - the animation
623:37 - okay
623:40 - so our jumping logic is working
623:47 - so we can change this to maybe something
623:50 - a little more smaller
623:53 - 0.02 so this is going to feel a lot
623:56 - smoother
624:00 - okay
624:02 - so we are jumping
624:07 - now we can start adding the actual
624:09 - obstacles
624:14 - under the course we can
624:18 - head into obstacle base and over here we
624:20 - don't want anything this is not
624:22 - something we'll actually be spawning
624:24 - obviously
624:25 - obviously what will spawn is going to be
624:28 - these
624:30 - so
624:33 - under obstacle one we can have stuff
624:36 - I'm not even sure at this point if
624:38 - you're able to see the sides we're
624:40 - barely able to see it
624:44 - and we also need to destroy it once we
624:47 - actually reach a certain point
624:49 - and we also need to keep spawning it
624:52 - basically
624:56 - so wherever our player start is
625:02 - so let's go ahead and add a trigger
625:05 - volume
625:09 - so trigger box
625:18 - so the x is going to be 20.
625:24 - the Y is going to be
625:27 - whatever this is and Z is going to be
625:31 - 0 let's say
625:34 - and we'll just increase the extent of
625:37 - the box maybe 500
625:41 - 500 and 500.
625:45 - okay and we'll set the hidden in game to
625:48 - false so hidden in game is false
625:52 - so f8
625:56 - so this can go way ahead
626:07 - so a little more
626:11 - so we can select this trigger box
626:15 - and we can do
626:17 - times two
626:20 - by the way that's a pretty handy thing
626:22 - which you can do in Blueprint
626:25 - so just a little bit more
626:36 - so more
626:44 - okay I want to simulate now
626:46 - so go ahead and simulate
626:56 - okay so as soon as we end overlap on
627:00 - this we want to spawn a new one so
627:03 - go ahead
627:05 - on actor and overlap
627:12 - on actor and develop trigger box we'll
627:14 - try to print first
627:20 - okay
627:21 - so as soon as we go out of this
627:24 - first of all for the last index we'll go
627:27 - ahead and promote this to a variable
627:30 - so we'll call this one last spawn
627:33 - obstacle
627:37 - so we'll always have a reference to that
627:42 - go ahead copy this over
627:45 - so spawn actor
627:47 - we will make use of this
627:50 - remember we had our Arrow component
627:54 - so
627:55 - the the arrow which is there opposite to
627:59 - the origin is what we need
628:00 - game course obstacle base
628:03 - so near the origin we have an arrow and
628:06 - over here as well we have an arrow we'll
628:08 - make use of this Arrow
628:11 - so the location of this Arrow so this is
628:14 - called Arrow one so we'll call this one
628:16 - end
628:17 - so that's a little more descriptive
628:20 - under the level blueprint now
628:24 - so we'll get the end
628:27 - so get and
628:31 - so get and
628:34 - and from end we can
628:37 - get
628:40 - uh get the location
628:42 - so get World location
628:45 - and we can probably copy this over just
628:49 - like that
628:51 - and we can change this to this
628:55 - and the rest of the logic should
628:57 - actually work just like that
629:01 - okay so now
629:04 - if we actually wait for this
629:06 - as soon as this goes away one more is
629:10 - going to be spawned
629:12 - but there's another thing uh we want to
629:15 - destroy it uh once we actually
629:19 - go after a certain point we want to
629:21 - actually just destroy it like once we
629:23 - are behind the player we have no reason
629:25 - to still have it so we can have a
629:27 - trigger box for that once again so 500
629:31 - maybe 500
629:34 - and 500
629:38 - go ahead and over here as well we'll set
629:41 - up begin overlap for this instead
629:44 - so on actor beginner
629:47 - so begin overlap
629:51 - on active begin overlap destroy Act
629:58 - okay let's try this out
630:04 - so I'm not sure where this box is
630:14 - let's unhide it so hidden game
630:18 - set to false
630:22 - okay so in theory we should be
630:24 - destroying it okay we destroyed
630:28 - the Box itself
630:30 - so other actors what we have to destroy
630:37 - whoops
630:38 - we need to take this a little more
630:40 - further back
630:50 - so now if we wait for it to reach there
630:56 - so we are continuously spawning the box
630:59 - over there
631:01 - and if I actually head back into my view
631:04 - I cannot see anything happening
631:07 - and our world is spawning normally
631:10 - how cool
631:15 - so over here we can add a couple of
631:17 - things so obstacle one we can add a few
631:19 - shipping containers Maybe
631:22 - oh we can make it random actually that
631:25 - would be nice
631:27 - if we just make this completely random
631:37 - so somewhere at the center
631:40 - I'm not sure where the center is I think
631:42 - it's negative 1600
631:47 - so this is where the center is going to
631:48 - be
631:52 - oops I moved the end itself so first
631:54 - duplicate it
631:56 - and this is going to be negative 1600
632:00 - this going to be Center obstacle
632:06 - and
632:10 - we can go ahead and duplicate this
632:13 - and this is not going to be called
632:15 - Center obstacle this is going to be
632:17 - called Left obstacle
632:20 - and we can call this one right obstacle
632:26 - so our right obstacle is going to be to
632:29 - the right obviously
632:31 - and our left obstacle is going to be to
632:34 - the left obviously
632:36 - so this is 250 this negative 250.
632:42 - okay
632:44 - so we have set that up we should have
632:46 - done this in the base actually
632:48 - so we'll cut this and we'll paste this
632:50 - in a base
632:54 - so
632:56 - don't mind that
633:00 - now we should have our obstacle both in
633:02 - the base and the others and obviously
633:05 - the logic is going to be in base itself
633:09 - so since we are randomly spawning it
633:11 - it's totally fine
633:13 - we can use the base itself I assume
633:17 - now in the event graph
633:20 - on event begin play
633:24 - we can go ahead and create
633:28 - a static mesh or rather spawn a static
633:30 - mesh at that location
633:32 - for that we'll need a few actor classes
633:35 - so obstacles
633:37 - over here we can delete this
633:41 - and
633:44 - if we play everything should work
633:49 - however
633:51 - under r
633:54 - under this folder we can
633:57 - make a few actors actually
634:00 - so obstacles
634:04 - we'll call this path actually
634:08 - path underscore base in case we need any
634:11 - derived classes
634:14 - now click on blueprint class actor
634:18 - and this is just going to be obstacle
634:21 - one
634:23 - uh few will be dodgable few will be not
634:26 - so we'll make a dodgeable and
634:29 - non-dodgeable obstacles
634:32 - dot double
634:36 - I will just have three for each
634:40 - will create Childs
634:44 - so child
634:45 - Ctrl D Ctrl d
634:49 - and we'll name this one child three so
634:53 - one two three
634:55 - so this one is going to be non-dodgeable
635:00 - so we'll go ahead and create a child
635:03 - Ctrl D Ctrl d
635:07 - and this is going to be Child 3
635:09 - obviously
635:12 - okay
635:13 - so finally we can go ahead and add stuff
635:16 - to these obstacles
635:19 - so optic obstacle dodgeable child one
635:24 - we can instead of the default scene root
635:27 - obviously
635:28 - obstacle dodgable here as well
635:31 - we'll simply have a static mesh
635:34 - so static mesh
635:37 - so that's done
635:40 - I will leave the root it's fine
635:44 - and we can look for some stuff here
635:48 - so we have quite a few meshes so we can
635:51 - have a barrel
635:52 - in one place
635:54 - so we can have boxes we can have barrels
635:56 - we have so many options here
635:58 - so we're going to select this let's say
636:06 - let's try this
636:10 - so in path
636:12 - you want to spawn actor from class
636:22 - so for the class we'll make this
636:24 - obstacle dodgeable
636:30 - so spawn transform is going to be this
636:33 - so oops
636:35 - uh Center obstacle let's try this first
636:38 - so Center obstacle
636:41 - and get word transform
636:46 - go ahead and try this out
636:52 - okay it's just sliding along for some
636:55 - reason
636:59 - and we want to attach it yeah that's the
637:01 - reason so
637:04 - attached to component
637:08 - we want to attach this to our actual
637:11 - plane or we can just uh do it for the
637:17 - root component
637:22 - so now
637:23 - in theory this should work
637:29 - okay so this seems to be working fine
637:33 - uh one more thing we can make this a bit
637:35 - faster actually
637:38 - now we can promote this to variable
637:40 - so speed
637:44 - so we'll make this one 500.
637:51 - okay as soon as we hit something uh we
637:54 - should stop
637:56 - and our game should get over
638:02 - so we'll have event hit here
638:06 - first we'll print something
638:11 - go ahead and test this out
638:17 - so if the other actor is an obstacle
638:22 - pass to obstacle
638:25 - uh we should have made a base class to
638:27 - be honest
638:29 - go ahead and
638:31 - head into content blueprint game
638:35 - course obstacles
638:37 - we'll create one called
638:40 - actor of
638:43 - type obstacle
638:46 - obstacle base
638:49 - and will inherit these from
638:51 - the base classes
638:54 - so class settings
638:58 - so obstacle
639:01 - obstacle base
639:06 - and these will also change
639:09 - so We'll Inherit this from obstacle base
639:12 - so obstacle base
639:16 - obstacle base
639:19 - all right so we can go ahead and cast to
639:22 - obstacle base
639:26 - and we're going to print
639:29 - or rather we can just exit the game
639:30 - execute console command
639:33 - and we'll type in exit let's try this
639:40 - okay our logic is working
639:45 - okay we still hit it
639:47 - so we need a better jumping logic
639:51 - that's that's the problem with our
639:52 - jumping logic it's not our
639:55 - obstacles
639:58 - so
640:00 - under this
640:03 - we can go ahead and change stuff in the
640:07 - character moment so under jump
640:11 - we should
640:13 - have this parameter here so if we change
640:17 - this to 500 for example
640:21 - so now we are able to dodge this
640:22 - obstacle successfully
640:25 - and there are a little bit too far apart
640:28 - I believe
640:30 - these obstacles
640:33 - so what we can do is
640:36 - we can have two actually in each one
640:42 - so go ahead and select all three of
640:45 - these
640:47 - foreign
640:53 - of 3200 so 0.75 into 3200
640:59 - it's going to be 2400 so at negative
641:02 - 2400 we'll have it
641:05 - and we'll go ahead and duplicate this
641:10 - so
641:12 - these
641:13 - and we'll have these at 800.
641:19 - so we'll have a gap of 1600
641:22 - between each obstacle
641:27 - and now if I go ahead and press play
641:31 - we have to set up more logic actually
641:36 - so we are spawning the obstacle
641:38 - dodgeable here now we'll make some
641:41 - non-dodgeable obstacles as well so
641:44 - set up the non-dodgeable one we can have
641:47 - something like a shipping container or
641:48 - something
641:49 - hmm
641:51 - so the way I do it
641:54 - is going to be
641:58 - if I add in a static mesh once again
642:04 - and we'll have
642:07 - a shipping container maybe container
642:12 - okay we have quite a few that's nice
642:20 - let's try with
642:22 - only the non-dodgeable one
642:28 - non-dodgeable
642:34 - other rotations of
642:41 - go ahead and rotate it by 90 degrees
642:55 - okay
642:59 - so this is not exactly on the floor but
643:04 - we can fix that
643:07 - head into the left view okay it is on
643:10 - the floor
643:11 - not sure why
643:16 - it's not on the floor over there
643:23 - you can try just moving it a bit
643:27 - that about fixed our problem
643:30 - and we obviously should be able to move
643:33 - aside and dodge it
643:42 - so
643:43 - we are spawning obstacles
643:48 - and
643:50 - now we can set up a little bit of logic
643:55 - to make this random a little bit
643:58 - uh for dodgeable we can have few more
644:03 - so for dot double
644:05 - we'll leave it as is child one let it be
644:07 - as is child two we can make something
644:09 - else
644:14 - so this static mesh can be
644:18 - we can look over what we have here can
644:21 - have this roadblock thing
644:26 - and change the logic obviously so
644:29 - dot double
644:32 - I think it was child one so child one
644:42 - child two rather child two
644:51 - open it up I mean it is
644:54 - a bit down
644:57 - but you get the point
645:03 - so change that
645:06 - 10 20 we'll just move all of those by 20
645:10 - units
645:22 - and for the third one as well we'll just
645:24 - add one now obviously you can go ahead
645:26 - and
645:28 - make more of this
645:31 - I feel like if we have some sort of a
645:33 - traffic cone or something like that so
645:37 - I'm just looking for what I can have so
645:41 - okay these seem like the perfect choice
645:46 - let's try that
645:48 - again forgot to change it
645:54 - so under my
645:57 - path
645:58 - so course path base
646:02 - we can go ahead and change this to child
646:05 - three
646:07 - to test it
646:09 - again it's a bit low but that's not an
646:12 - issue okay I forgot to get the window in
646:14 - Focus once again
646:16 - that's my fault
646:19 - and we have to move it down I believe
646:26 - so move it down by 20 units
646:37 - okay
646:39 - so we have our dodgable obstacles let's
646:41 - set up our non-dodgeable obstacles as
646:43 - well
646:45 - so in our child one we can again look
646:48 - for what else we have maybe if we have a
646:50 - truck or something
646:52 - nope
646:54 - uh we can look for what we have so
646:56 - construction volume one meshes
647:02 - so
647:04 - can have a fence
647:06 - yeah that's not a bad idea
647:09 - so this is child one so let's child one
647:13 - be the same
647:16 - let's actually open up child two and
647:19 - let's actually open up child three so
647:22 - these are the ones which we'll try to
647:23 - change
647:25 - over here meshes we will select the
647:28 - fence for one
647:33 - uh the rotation can be zero
647:40 - uh change this
647:45 - non-dodgeable child three
647:50 - so it's a little too big
647:57 - so we can scale this down maybe 0.8
648:12 - okay so I don't think you can dodge this
648:15 - one
648:20 - okay we can dodge it when we move aside
648:24 - so we'll just have one last one
648:26 - so for this one so obstacle Child 2
648:30 - I will change it right now so child two
648:33 - these are the various obstacles
648:35 - basically
648:37 - non-dodgeable child to
648:39 - select that and this is child two I
648:42 - assume yeah
648:44 - so we can look for something else which
648:46 - we may have
648:47 - okay this looks like something
648:48 - interesting
648:51 - or light generator whatever this is
648:54 - let's try that
648:57 - I don't think this should be something
649:00 - which you should be able to dodge
649:07 - okay
649:10 - so that works
649:15 - now we can set up some randomizing logic
649:19 - so that we spawn everything in random
649:23 - so this logic is the same we need to
649:26 - select the class basically first we can
649:28 - select a random integer So Random
649:31 - integer
649:32 - so this is going to be
649:34 - the number of random integer in range
649:37 - actually
649:41 - so this is going to be the number of
649:43 - dodgeable obstacles so we need at least
649:46 - one dodgeable obstacle otherwise the
649:48 - game is going to get unplayable so we
649:50 - can either have one or we can have all
649:52 - the way up to three
649:54 - and what we can do
649:57 - is
649:58 - depending on the number now this is
650:00 - going to be number of dodgeable
650:03 - obstacles what we have so promote this
650:05 - to a variable
650:07 - so number of
650:09 - dodgeable
650:11 - obstacles
650:15 - okay so now that we have this if we have
650:20 - only one
650:22 - what we can do is we can select one so
650:26 - number of dodgable obstacles
650:29 - so we can switch on int
650:33 - and we can select something
650:41 - so
650:43 - so we can start at one so start pin type
650:47 - one
650:49 - if we have only one obstacle our logic
650:52 - is going to be really simple so we'll
650:54 - just select a random one over there
650:58 - we need to do this Two Times by the way
651:02 - or multiple times probably I'm not sure
651:08 - so
651:10 - uh we'll have we'll have more obstacles
651:12 - to be honest these are not enough
651:15 - so we'll space them a little more closer
651:21 - copy these
651:24 - right obstacle left obstacle Center
651:28 - obstacle
651:29 - Ctrl D to duplicate and
651:33 - left obstacle two
651:37 - press Center obstacle to okay we didn't
651:39 - duplicate everything
651:41 - so Center
651:43 - left and right
651:46 - so Center left and right
651:49 - Ctrl D to duplicate
651:51 - okay wait we aren't duplicating anything
651:53 - we'll just duplicate this so okay left
651:56 - Center and right
651:59 - you can move this somewhere in the
652:01 - center
652:03 - right at the center
652:06 - and we can space these two equally apart
652:10 - which I believe they already are
652:15 - are they equally spaced yep but
652:19 - we need to space them out a bit more
652:23 - we have 800 for the spacing here
652:29 - so we can select our obstacle one
652:36 - we can try
652:39 - giving you know negative
652:42 - 600 maybe so if I do negative 400
652:48 - so that will be way too much space 500
652:51 - maybe we can try 600.
652:57 - so I have 3200 let's divide it let's
653:00 - take 33 percent of that so calculator
653:09 - so it's somewhere around 1066.
653:16 - so we'll have 600. it's fine if they're
653:19 - not equidistant
653:21 - you can obviously do the math yourself
653:28 - so obstacle
653:30 - this is what we need so one
653:36 - whoops
653:38 - two and three
653:44 - so 3200 minus 600 is going to be 2600.
653:51 - okay now let's see if this works
653:54 - yeah obviously we are not spawning it
653:56 - that's different
654:00 - but now
654:04 - in theory we our logic should work
654:08 - so we can actually Loop through
654:11 - so we can select the number of dodgeable
654:13 - obstacles for each level so we'll have
654:16 - an array of this
654:18 - so we'll create an array so change the
654:21 - type it's fine
654:24 - so we can do for each Loop
654:30 - and for each index we can try
654:34 - and get a random integer
654:40 - so we can
654:41 - set array element
654:45 - so this is the index
654:47 - we can do a simple for Loop so for Loop
654:53 - so from 0 to 2
654:56 - so size to fit we'll do that
655:00 - and we'd actually want to reserve
655:05 - three locations so one two three
655:08 - so we don't need size to fit so
655:12 - in this index we are going to set this
655:15 - item
655:17 - so for all our three levels we have we
655:20 - know the number of obstacles which will
655:22 - be dodgable
655:25 - once we have that number we can go ahead
655:27 - and spawn them
655:31 - so we can have this in an array and
655:33 - randomize them actually
655:37 - anyways don't worry too much about the
655:39 - logic
655:40 - just my logic which I'm making up
655:44 - um
655:45 - we can select this
655:50 - so we can store these in an array
655:54 - so create an array so
655:58 - promote to variable
656:01 - or you can actually just have an array
656:03 - so what are we using this for we're just
656:05 - using this for the location
656:07 - so we can get the transform of this
656:11 - we can only have the transforms in the
656:13 - array that's that would work I guess
656:26 - so first we'll
656:29 - have the transforms go ahead and create
656:33 - an array for
656:36 - transforms
656:41 - transforms one transforms to transforms
656:45 - three we'll need three arrays so
656:48 - will the location is enough for us so
656:51 - array of vectors
656:53 - transforms to
656:56 - transforms three
656:59 - I know I shouldn't be calling them
657:00 - transforms but we'll take a look at the
657:03 - right obstacle
657:04 - uh the first level ones basically
657:08 - so we have this selected so right
657:10 - obstacle one will will go according to
657:13 - naming order
657:16 - transforms one
657:18 - we'll compile this blueprint
657:21 - so we have three elements
657:26 - we can access it right here
657:30 - so the first one is going to be this I'm
657:33 - not sure if we can
657:35 - paste this see if we can
657:37 - we have right obstacle copy this
657:41 - okay we took that so left obstacle
657:44 - copy this and
657:48 - okay
657:49 - the right and the left have okay they
657:51 - don't
657:56 - so paste one has negative 250
658:01 - and the center one will have probably
658:03 - will have probably have zero so we'll
658:05 - paste it we'll have zero over here
658:11 - okay and now that we have this
658:14 - let's grab our obstacle tools or
658:17 - obstacle ones
658:19 - so this is negative 600.
658:22 - one two three negative 600 this will be
658:25 - constant so 1 is going to be 250 another
658:28 - one is going to be negative 250.
658:32 - similarly we can grab our two
658:35 - so negative 1600 this is basically our
658:38 - midpoint
658:40 - negative 1600 250 negative 250
658:47 - and this is about it
658:49 - no
658:52 - once this is done we'll collapse the
658:54 - function
658:55 - so determine
658:58 - number of
659:01 - dodgeable
659:03 - obstacles
659:08 - okay
659:09 - we have the number of dodgeable
659:11 - obstacles now
659:12 - now what we can do is we can Loop
659:15 - through this
659:17 - so for each loop I really wish we could
659:19 - have a two dimensional array for this
659:21 - that would have helped us a lot
659:26 - now
659:28 - what we can do is
659:30 - we can go ahead and randomize this
659:38 - can we not randomize this
659:41 - okay we cannot so we have a plugin which
659:46 - will help us so low entry
659:50 - I can restart
659:52 - save everything
660:13 - all right so
660:15 - back here I think now we should have
660:17 - okay we're coming close to two hours I
660:20 - think this will be done in two hours not
660:22 - one
660:23 - blueprints game uh course pathways
660:29 - and we should have a randomize
660:34 - oops nope we don't
660:38 - so I think we might need a few functions
660:42 - so
660:44 - how do we go about randomizing this we
660:46 - can look at the epic games launcher if
660:48 - we have any plugins
660:51 - so array helpers I guess I had one
660:55 - so we'll go ahead and install this to
660:57 - the engine we can simultaneously use it
661:02 - once we have this so once we actually
661:04 - randomize this
661:06 - uh depending on this
661:09 - we can go ahead and set this so switch
661:14 - on end
661:19 - and
661:21 - will you select for this
661:27 - so just close the editor just to let
661:29 - that happen
661:32 - and now if we go ahead and launch Our
661:35 - Endless Runner
661:45 - okay go to edit
661:50 - plugins so edit plugins
661:54 - and array array helper
661:58 - go ahead and restart
662:05 - so this is the sort of stuff I just hope
662:06 - it doesn't take too long
662:09 - right hopefully we have some sort of a
662:11 - randomized function so randomize
662:15 - okay we still do not have a randomized
662:18 - option option
662:20 - so let's just look for it so randomize
662:24 - array unreal
662:26 - I don't know
662:28 - is it called is it just called something
662:31 - else so okay never mind
662:34 - it's called Shuffle
662:36 - so first of all we'll Shuffle the arrays
662:39 - we'll shuffle all the three we'll do
662:41 - that before we actually set this
662:45 - we'll go ahead Shuffle this
662:49 - go ahead and Shuffle this once again
662:58 - uh we'll put that in the previous
663:00 - function itself
663:03 - so we can go ahead and Shuffle
663:09 - generally I don't recommend you guys uh
663:12 - do array operations in Blueprint but
663:16 - anyways
663:17 - once the slope is completed we can do
663:19 - that
663:20 - and this will go to the return node
663:24 - just for you to understand the flow of
663:27 - logic
663:29 - and now
663:31 - depending on this
663:34 - we can go ahead and spawn them
663:38 - so the array element is going to be the
663:41 - number of obstacles so this switch is
663:44 - going to start from 1 so start index is
663:48 - one
663:49 - you will either have one two or three
663:54 - so if you have one or two way can you
663:58 - select probably
663:59 - copy the server
664:06 - so
664:07 - everything else is zero so we can just
664:09 - leave it as is
664:15 - so we can go ahead and over here
664:18 - if this is one
664:21 - if we have one dot zipper obstacle
664:25 - we can go ahead and spawn
664:27 - just one of them
664:29 - as dodgable so dot double
664:36 - so 1 is going to be dodgable and the
664:38 - spawn transform will just use the first
664:41 - index
664:45 - so we will select
664:51 - so depending on which index it is
664:55 - so transform 1 transform to transform
664:58 - three
664:59 - so option one
665:02 - option two and option three
665:06 - so we'll select any one of these arrays
665:10 - and if we have to spawn only one dot
665:13 - zipple so we can get
665:16 - uh we can get a copy of the first one
665:19 - we'll split the struct pin here and
665:22 - we'll just get this location
665:25 - now we we need to just repeat this logic
665:28 - so Ctrl d
665:33 - and we want to do two non-dodgeable ones
665:41 - so dodgeable and index 1 and 2 are going
665:44 - to be Non DOT triple so non dodgable
665:49 - uh we have to spawn a child class of
665:51 - this so
665:54 - you can use the select once again
665:58 - so Random
666:01 - integer
666:02 - and Max is going to be 2.
666:05 - so it's going to be
666:09 - Max S2 so
666:12 - 1 and 2.
666:15 - so it's random number between 0 and Max
666:19 - minus 1 let's just use random integer
666:22 - and range
666:23 - it's a little bit confusing so minimum
666:25 - is zero maximum is 2.
666:29 - okay
666:31 - and this is going to be dodgable so
666:33 - dodgeable
666:35 - obstacle dot double child one child two
666:40 - and child three
666:45 - this is what we have
666:49 - done
666:52 - and for this one this is non-dodgeable
666:56 - so we'll copy the logic
666:59 - but instead of dodgeable we'll have
667:01 - non-dodgeable
667:03 - so child one
667:08 - child one
667:11 - child two and child three
667:16 - okay
667:18 - and we need this once again so copy over
667:21 - this entire logic
667:28 - all right so this is going to be the
667:30 - same this is going to be for index 2.
667:34 - now if we have 2 we can go ahead and
667:37 - copy this over so Ctrl C and Ctrl V
667:42 - and we can just move this aside
667:46 - so for index 0 it's going to remain the
667:48 - same
667:50 - whoops Ctrl V
667:52 - oops uh copy this
667:56 - Ctrl C and Ctrl V
667:59 - index is still going to remain the same
668:04 - once this is done we need the attach as
668:07 - well we didn't copy over the attach
668:14 - okay so we have to duplicate this whole
668:17 - thing
668:21 - so index is this
668:25 - and index is going to remain the same
668:27 - everywhere
668:28 - so now we need two dot double obstacles
668:31 - so for this one as well we have dodgable
668:33 - and this is going to be index one
668:35 - obviously
668:36 - and for index 2 we can go ahead and have
668:40 - this
668:44 - all right so copy this
668:47 - and again we can pass the index
668:51 - so array index
668:54 - go ahead and pass that in
668:57 - and when we have all three dodgable
669:00 - obstacles
669:01 - uh we'll just go ahead and copy this
669:03 - much Ctrl C and Ctrl V
669:11 - so in case of three this is what we'll
669:13 - do
669:14 - so index is still going to remain the
669:17 - array index
669:18 - Ctrl d
669:20 - and Ctrl d
669:24 - copy this over move the execution pins
669:28 - and the index will obviously just remain
669:31 - the same
669:32 - so the last one is going to remain the
669:35 - same and this is going to be 2 this is
669:37 - going to be 1.
669:39 - and this is going to be 0. so make sure
669:41 - you have 0 1 and 2.
669:46 - okay
669:47 - so now our logic should work
669:50 - and if I were to go ahead and press play
669:55 - okay
669:56 - everything works okay
670:02 - all right so
670:05 - okay we stepped onto something
670:08 - uh we need to make sure this doesn't
670:10 - happen in our first one so
670:16 - okay we have to just ensure that the
670:19 - obstacles aren't spawned in the first
670:22 - one basically
670:27 - so we'll create a Boolean
670:31 - first box
670:35 - so if this is not the first box
670:39 - we'll go ahead and do this
670:45 - so inside the level blueprint
670:49 - under this
670:52 - if we go ahead and refresh nodes uh we
670:55 - have to pass this in so expose on spawn
671:01 - all right so now if I refresh
671:04 - I should get this
671:08 - so only if this is uh index 0
671:13 - so double equal to zero then this is the
671:16 - first box otherwise it's not
671:20 - okay so now our logic is working
671:23 - let's go ahead and play the game now
671:29 - all right
671:32 - so as you guys can see our game is
671:35 - working as expected
671:41 - we don't have a score yet we'll just set
671:43 - it up quickly
671:56 - so as you can see our logic is working
672:03 - so we can set up a scoring system real
672:06 - quick and dirty here
672:09 - content
672:10 - I will do the start thing also it's
672:13 - really simple so
672:15 - go ahead and open level
672:21 - um we call this one game map I believe
672:23 - so Maps
672:25 - game up go ahead and paste that in
672:32 - or we can start from the main menu
672:36 - go ahead and play start
672:38 - and we started the game
672:48 - so as you can see everything is working
672:50 - as expected you could have some stuff at
672:52 - the side
672:53 - and we'll have a scoring system we can
672:55 - have a time-based scoring system
672:58 - so it's the score is going to go up at a
673:00 - constant rate
673:03 - content
673:05 - will create a widget further so
673:11 - user widget
673:13 - and we'll call this one HUD
673:22 - and we'll we'll just simply have a text
673:28 - so we'll wrap this with a canvas panel
673:34 - and this is going to be our score
673:39 - once we will set the game mode and stuff
673:42 - so game map
673:45 - over here we'll have BP uh we don't have
673:48 - a black controller we'll create that
673:51 - game
673:53 - go ahead head into blueprint class
673:54 - player controller BP underscore player
673:58 - controller
674:03 - so you should have BP player controller
674:08 - so on begin play we can go ahead and
674:11 - create the widget
674:13 - so create widget
674:16 - it's going to be HUD
674:19 - and we can go ahead and add to viewport
674:23 - right so let's look at our time we don't
674:25 - have much I think it'll take probably
674:27 - just a little lower two hours but
674:29 - it'll be done
674:32 - so once we create this we can grab a
674:34 - reference
674:35 - so promote this to a variable and we'll
674:38 - call this one HUD now I don't recommend
674:40 - you guys use bindings but I think in
674:43 - this case just to make this real quick
674:45 - I'll use bindings
674:47 - so we can have game State uh on
674:51 - construct we can get reference to the
674:53 - game state so get game state
674:58 - cast to BP game state
675:02 - and what we can do is we can grab a
675:04 - reference to it
675:09 - and we can create a score variable
675:14 - content blueprint
675:16 - uh blueprint main menu I guess no game
675:23 - so game
675:26 - game state
675:29 - and we can have a score
675:32 - so we'll make this an INT 64. so that we
675:35 - can have larger scores so integer 64.
675:39 - and we can have a timer so set timer by
675:43 - function name
675:46 - and
675:48 - it's going to be something which
675:51 - happens every 0.5 seconds let's say
675:55 - and we are going to increment the score
675:57 - so promote to variable
675:59 - score timer
676:01 - and we can have a custom event
676:05 - increment score
676:08 - or increase I'll call it
676:10 - doesn't matter we'll not worry about
676:12 - that
676:13 - we are going to get the score and we'll
676:15 - set it to score plus 2 maybe
676:18 - Plus
676:21 - set score
676:25 - so we'll go ahead and do that copy this
676:27 - put it in the function name make this
676:29 - looping
676:30 - and we can use a binding here so we can
676:34 - bind this
676:36 - you can get the game state
676:38 - you can make this a validated git
676:41 - this is a little more expensive on your
676:43 - computer so don't do this
676:45 - so we can get the score
676:47 - and we can convert this to text
676:52 - you can use a format text node and stuff
676:54 - I'm not really going over that so we'll
676:56 - just do that actually so format text
677:13 - all right
677:15 - and we don't need to convert this
677:19 - if we press play
677:21 - as you can see our score is increasing
677:23 - at a constant rate and you can see it on
677:26 - the top left hand side for those of you
677:28 - on mobile phones and who are not able to
677:31 - see it I'll just make this text a little
677:34 - bigger so 40
677:37 - make this one regular we don't need bold
677:41 - and this should be good
677:45 - so as you can see everything is working
677:48 - fine
677:51 - and you can go ahead and set up any
677:53 - logic if you want if you want to like
677:55 - you know save it or whatever
677:57 - but for now I'm happy with this
678:01 - so that's it for this video guys thanks
678:04 - for watching we do have a complete game
678:06 - and instead of exit you can just show
678:10 - the score on a widget or something I
678:12 - will do that let's not leave it halfway
678:15 - the last part before we just complete it
678:19 - so we'll create a widget
678:22 - and we'll call this one end screen
678:28 - okay we'll add a border
678:31 - wrap this with the canvas panel
678:34 - so we can go ahead and wrap with canvas
678:37 - panel
678:38 - and this border should take up the whole
678:41 - thing so offsets are going to be zero
678:43 - and the brush color is going to be
678:45 - something black black Maybe
678:48 - and we can just go ahead and add some
678:50 - text
678:54 - so we need to align it right at the
678:56 - center so
678:59 - vertical box
679:03 - uh
679:06 - we can use an overlay
679:08 - rather
679:10 - overlay is going to be helpful here
679:13 - so overlay
679:16 - so border is going to be filled
679:20 - the overlay is going to be filled as
679:22 - well
679:25 - so 0 0
679:27 - all right and over here we can have text
679:37 - and there's the advantage of using a
679:39 - canvas panel
679:40 - so 40
679:43 - can make this regular Maybe
679:49 - then go ahead and put score
679:53 - and we can go ahead and
679:57 - give the value
679:59 - so
680:01 - let's go ahead and set that so event
680:03 - construct get game state
680:07 - cost to our BP game State and we can get
680:11 - access to the score variable get score
680:15 - and we can set the text of this
680:20 - so set the text
680:23 - set text
680:26 - and this is going to be about it we'll
680:29 - format it
680:31 - so format text
680:40 - so this is the score
680:45 - so let's go ahead and Center that make
680:48 - it 0.5
680:50 - and make everything else 0 here
680:54 - oops uh the size shouldn't have been
680:57 - zero
681:02 - uh make this one central line
681:06 - and the make sure for any vertical
681:10 - alignment which we have
681:12 - okay nope we don't so I'll just reduce
681:15 - the size of this maybe to 100
681:19 - okay this should be good now if I go
681:22 - ahead and press play nothing will happen
681:24 - because we haven't spawned the end
681:25 - screen
681:26 - uh where we have our event hit in our
681:29 - character
681:32 - so we can cast to obstacle and instead
681:35 - of that we can go ahead and create a
681:37 - widget
681:38 - create a widget end screen
681:42 - and we can add it to the viewport
681:49 - all right
681:50 - let's go ahead and do that
681:53 - so I'm testing the end screen so I'll
681:55 - just die immediately
681:59 - okay so our score is 300 apparently
682:04 - which is nice
682:12 - okay not sure why we didn't exit
682:15 - immediately there
682:18 - uh we need to do once I understood the
682:20 - problem so do once
682:23 - because once we die the game's over
682:26 - don't want to redo that
682:32 - so
682:39 - okay we need to do once from here
682:41 - actually
682:45 - now we just went over the obstacle which
682:48 - was kind of stupid
682:50 - so go ahead and try this out
682:54 - and our score is 280.
682:57 - so that's it for this video guys I hope
683:00 - you guys really enjoyed this entire
683:02 - course I know it's been over 11 hours at
683:06 - this point but hopefully you have
683:08 - learned something new and I hope you
683:11 - enjoyed the last part where we actually
683:13 - made an entire game and we didn't use
683:15 - any C plus plus to be honest
683:18 - so that's about it hope you guys enjoyed
683:21 - and see you guys later goodbye

Cleaned transcript:

Unreal Engine is a 3D computer Graphics game engine that has been used to create many popular games in this full course for beginners tsurav will teach you how to use Unreal Engine 5. surov has seven years of game development experience and has developed multiple games hi there game devs welcome to my beginner to Advanced game development course on Unreal Engine 5. in this course we'll be taking a deep dive into the engine and hopefully by the end of this course you would be able to create a game completely by yourself foreign start developing a game in Unreal Engine some of you guys may have a question on what sort of a system to get for Unreal Engine now the docs is a bit outdated on this page however uh this page whatever is there is uh insufficient in my opinion I have been working on Unreal Engine for almost 7 years now and I feel this system isn't going to be handling anything so 8 gigs of RAM isn't enough and for the video card I would recommend at least going for something like a 1650 or an RTX 3050 if you were to ask me I have worked in unreal for about four to five years with a 1050 TI that totally works however your experience isn't going to be that great and you will have to turn down all the settings as well and for the CPU a ryzen 5 or an Intel i7 would do six cores or higher uh preferably eight or even 12 cores would be better but make sure if you do get more number of cores you scale up the other components as well there are a couple of things for example in Visual Studio uh when you compile a program you will actually need more RAM as you scale up the number of cores on your CPU so that's one thing to note and if you scroll it down you would see this list over here although the system is highly Overkill and the GPU is outdated of course one noteworthy thing is a solid state drive which I highly recommend do not use a hard drive for your active projects the experience isn't going to be that great so with that all being said let's actually start by talking about the installation process now there are two ways in which you can get hands on Unreal Engine one is through the epic games launcher so just search epic games launcher download the launcher and once you actually log in and do the regular sign up stuff you can go ahead and click on Unreal Engine and head into library and you should be able to add an engine version now as of this date the the latest table build is 5.0.3 however 5.1 is in preview and we we shall hopefully upgrade to that it has quite a few exciting features which I would love to show and the other way is to download the source code now you could use git or something and copy the link and clone it like that or you could just download the zip file from here and then there are a bunch of steps to actually install it uh we'll be going through this later in the course and also for more advanced users those of you who will be working with dedicated servers might need the source build as well now if you guys don't have access to this repository you just have to request the permission this is a private repository by default and it's pretty easy to get it and once you do get access to it you will be able to view this page there are quite a few tutorials on YouTube on how to do that so you guys could check any one of those out once you install the unreal editor through the epic games launcher uh you'll also need a code editor in order to work with the c plus files so generally you use visual studio for it now the documentation goes pretty well on what components you need and stuff and if you do need any additional components the installer is going to prompt you and it's pretty straightforward to be honest now you don't require vs 2019 you could use 2022 there is absolutely no issues uh I'll be showing you guys how to set the default code Editor to be vs2022 as well a bit later so that's about it for the code editor I guess now we can go ahead and create a project and let's create a game so I'm in the epic games launcher right now and before we actually launch the engine I just wanted to talk about the installation options try your best even though it looks large to have debugging symbols those are going to help us out later now you can go ahead and click launch once the loading is done you should be inside the unreal project browser where you can create your projects now yours might look a bit different I haven't selected templates so I don't see first person third person and all that however Our intention here is to learn so we aren't really going to use those templates we might look into them a bit later on but for now we'll be starting with a blank project and a couple of noteworthy things two things actually the first thing is the project location I always suggest having an unreal projects folder in your solid state drive and maybe move them to a secondary drive if you're not working on them now for the project defaults everything is fine except blueprint and C plus plus basically every C plus plus project will have blueprint and everything else that you will need to work with the editor however when you select a blueprint project there is one additional step if you want to start working with C plus plus as well please note that blueprint and C plus plus work complementary with each other and every project in my opinion should use a combination of the two and shouldn't be purely C plus plus nor should be purely blueprint so let's create a c plus project and let's leave it at desktop maximum and we didn't download the starter content so we don't have it but that's totally fine we can add it later on now for the project name we can go ahead and name it let's call it beginner to Advanced course or I'll just call it beginner course so let's create that once you open your project a visual studio window like this with your project solution open should be open by default if not head into the editor go to tools and click on open Visual Studio 2022 and here's where I'll just show you guys how to change the default code editor let's say you have a slower computer head into editor preferences and over here type in code editor and you should be able to change it to visual studio code or whatever let's say you do change it to vs code over here under Tools again you should be able to find refresh Visual Studio code project once you do that you should be good to go one thing that you will immediately notice is my editor layout does not look exactly like yours the reason is I have set mine to the Unreal Engine 4 layout so the way you do that is by heading into Windows load layout and this is the one you will probably have and you can hit control space in order to get your content drawer but I feel like it just adds an additional step in viewing your content and I honestly prefer the Unreal Engine 4 layout but it's completely up to you everything else should be in the same place so I'm going to be using the ue4 layout you can choose to use the default one if you wish and in case you want to go full screen here in the ue4 layout just get your viewport into Focus just in case you're wondering the middle large portion of the screen is called the viewport once you get it into Focus hit f11 on your keyboard to go full screen let's start talking about the actual GUI of the unreal editor so the first thing is your menu bar which contains file edit window tools build select and so on these are just the normal options that you would see on in any other computer software so let's say you wanted to save everything you would go go ahead and click save all however there's a key over here as well on the content browser which you will be using more often in this editor and under edit you also have a couple of important things obviously for undo redo and functionality like that you'd prefer the shortcut keys so for example let's say I add in a light over here and I go to edit you could undo that but I just prefer using Ctrl Z and Ctrl y and editor preferences project settings and plugins are a couple of options which you will use quite a bit we will be getting into all of those in detail later on now window as the name suggests has to do with uh your actual GUI so here for example if I wanted to know what game mode I have and again we will be getting into all of that so I can just go to world settings which contains the game mode info so it says game mode override none we can set that to be game mode for example and stuff like that it all depends on what you exactly need you could grab in a second viewport as well in case you needed it stuff like that and under Tools the only thing which we'll probably use here is going to be creating a new C plus plus class and occasionally we might need to refresh our project file and nothing else actually find in blueprints is something handy so in case you have written some blueprint code and you want to find it like in your entire project then it's a useful thing and build is for building your lighting and stuff basically uh baking your lighting select not really sure who would use that because most of the operations are there can be done by shortcut keys so that's your menu bar and under this there's another panel over here where you have another save button and under this select mode option over here you have quite a few options landscape is something which you will use when you're working with you know larger Maps so you can go ahead and create landscapes so what I'll do is I'll create a brand new level to Showcase those things and over here in blueprints this is where you'd access your level blueprint and I will get to what is that a bit later this option right here is mostly for cinematics so let's say I'm making a trailer for your game or something these are the things which you would use and this is just to play your game so if I hit play I can see what the game looks like while you're playing it one more thing let's say you wanted to look at how your game looked while you're playing without actually playing it you can press G on your keyboard and it it's going to go into game mode which will show you exactly how your game will look when it is being played and next up you have this button right here where it allows you to launch the game and stuff will be going into this a bit in detail later on now for those of you guys who have slower computers you can head into settings over here engine scalability settings and you can set Yours to low now how do you check your frame rate you may ask because that's a major concern I feel like you do require about 50 to 60 FPS in order to have a smooth editor experience so the way you check that is by hitting your tailed key under your Escape key that is if you guys aren't familiar once you do that your focus should be in this enter console command window at the bottom of your screen type in stat FPS and you might see that it's locked at 120 if you have a fast computer so what I'll do is I'll type in t dot Max FPS and you can just type in a crazy value like 999. so this is my actual uncapped frame rate now this introduces us to another window this is known as the console now the console is really useful basically almost every setting you see over here and quite a few other settings which we will talk about later can be set using the console it's quite handy let's say you're debugging your game and you don't have an actual button to change your graphic settings you could use the console and change it as well there are many other uses for it for example in multiplayer you can simulate lag and stuff like that in order to represent an actual multiplayer game so that's the console and your output log is your output log so let's say I've printed something it's going to stay on your screen for about two seconds or how much ever you set the duration but the output log is always going to have the print so for example now we haven't gone into blueprints but I'll just print something and show you guys if I just type in print string hello you see you get hello over here but it's gone after two seconds however in the output log you should be able to still see Hello it should be all the way down as you see you get hello now don't worry about all these errors it's really nothing to worry about so that's about it and on the left hand side you have the place actors panel where you know you have various options you'll really not be using this you will generally just drag those from the content browser it just contains the same old things and the recent step may be helpful if you're placing the same object over and over again one thing that you might use this for is for a player start player start is basically where your player is going to spawn just press G on your keyboard if it ever disappears you're probably in game mode if you don't see it and if you want to get close to it like how I did uh make sure that is selected and press F on your keyboard F stands for focus and it's going to go near it the camera is going to go near that now once that's done let's talk about this massive chunk of the screen this is known as the viewport this is where you will actually arrange your level and do stuff so for example if you want to place something you drag that in the viewport and that's going to be added into your level now in order to navigate your viewport there are quite a few methods which you can use one is known as the Maya style navigation where you use alt and your mouse buttons and there are many other styles which I won't get into it's kind of pointless but there is one style which I personally prefer and I feel almost everyone is going to prefer that that is by using your right Mouse button and your wasd this is similar to how you move in video games except you're holding the right Mouse button here so hold down your right Mouse button and you can use your w a s and D keys and move your mouse so this gives you all degrees of freedom so you can rotate you can pan around you can do everything so this is my favorite way of navigating just try it a couple of times it's just a matter of getting the feel of it and if I want to speed up the camera which I will get into later you can use your scroll wheel along with this and your camera speed is going to change there are a couple of options again here now here uh instead of the console command you could use this as well to show your FPS and there are quite a few other options which you would generally not use screen percentage is basically a resolution scale you could set that all the way up there I'd leave mine at 100. and this is to change between perspective and orthographic views let's say you're aligning something from the top you would go to your top orthographic View now you might see everything is wireframe so you can change that here as well go to lit let's say there are shadows interrupting your work you could head into unlit there are many other view modes which you generally use for optimization and things like that but generally you'd stay in lit unlit or wireframe itself maybe a couple of times you might use one of these uh other settings but I've never found myself needing those so that's there and scalability is basically the same thing which we saw over here I can set that to cinematic for example in my case it shouldn't really matter that's about it and in these options on the right hand side this one basically allows you to select objects so let's say I click on this I select this now let me get closer a bit set into perspective so if I click on this I can select it now when I click on something now I'll create another Point light when I click on something and I have it selected if I want to move it I can press W on the keyboard or if I want to rotate it I can press e on the keyboard and if I want to scale it for a light it's kind of useless but it is going to scale the radius I believe so for that I can hit r on my keyboard in order to scale things or you could use these buttons over here so this is for move this is for rotate and this is for scale all right so once that said this button right here changes between uh local and World space now over here if I just drag in a cube for example under shapes you should find Cube and if I change this to local space now when I rotate this Cube you see the Gizmo rotates along with it and now I can move it along its rotation but let's say I wanted to rotate it along with the world's XYZ the way I do that is by heading into World space so now you see it's aligned to the world's XYZ that is your actual coordinate axis but this cube is rotated as you can see so if I want to move it along that rotation I can head into local space again if you are familiar with 3D modeling software these will sound pretty familiar to you the next thing is grid snapping now if I were to come close enough you would see that it's moving in increments it's not moving smoothly that's because grid snapping is enabled and snapping distance is set to 10. so I can just click on this button and disable grid snapping and now you see the object moves smoothly same goes with rotation if I disable that I can smoothly rotate the object if I enable that it's going to rotate in increments of 10 same with the scale as well now this map is pretty huge and it's taking quite a while for me to actually go this far so the way I can actually move faster is by using this camera speed button so if I head into 8 as you see we are moving very fast one more thing is if you scroll while using your right click and wasd basically I'm using that to move if you use right click and wasd and you scroll at the same time you can actually adjust your camera speed so I have my right Mouse button held I have wasd to move and if I scroll forward I'm going to move real fast now let's say scroll backwards I'm going to go slower so you can adjust your camera speed with your scroll wheel as well and of course you can adjust it over here and if you want the camera to be even faster you can go ahead and set this multiplier thing and that's about it now let's actually start creating something so the way you would actually go about doing stuff is creating something under your content folder now you might have some things over here if you have enabled starter content and stuff but in our case we don't have anything so one thing is whenever you create new levels it's always advisable to have a Maps folder in your content folder where you actually put all your Maps so head into this folder and in order to actually create a blank level where you can start making your own right click click on create basic asset level or you can head into file new level anyway is okay and we can call this one beginner course level you could call it anything you want double click on it to open it up and I've already saved it uh it's asking us to save this map actually so actually don't save this now head into your project settings and this is where we start talking about some of the things which you might need the first thing is maps and modes so in order to decide which level is going to open when you start the editor this is where you actually set it so anything associated with your project will be over here so for example your input bindings is something which you'll use a lot so all of those are there in the project settings so we can change the editor startup map to be beginner course level and we can set this to be beginner course level as well close that and if you were to notice there is actually a small note here it says these settings are saved in default engine dot ini which is currently writable what do I mean by that is if I head into my project directory and if I head into config there are actually many config files so for example if I open up default engine.ini it says editor startup map equals and it has the relative path of the map and you have a bunch of other settings as you can see these are useful we will actually talk about console config files in detail later on there are other config files as well most of which you won't use you would mostly just use default engine.ini now heading back to our level you see everything is completely empty now one of the first things that you will need is a sky actually so if you just search in sky you're going to find a skylight Sky atmosphere we are just going to be using a skylight for now and if you just type in atmosphere you'd you get the same Sky atmosphere here so you can go ahead and drag that as well and if you type in fog you'll be able to get exponential height fog now you will see the effects of it if you Tinker around with this yourself basically all of these things just do what they say so exponential height fog is going to add fog and if you want to change the properties of this always head into your details panel and this is where you will adjust all the properties now for something like fog the location and stuff doesn't matter so anything you place the location of it is going to be stored here location rotation and scale just know that location rotation and scale combined in Unreal Engine is known as a transform we'll be using that a lot now let's say you had a light which was fixed and you want the Shadows to just be baked in and you have nothing to calculate dynamically you could set your light to be static or it it goes the same with any other object if you're not going to be moving it it's going to be static stationary is almost like static but there are a couple of things which dynamically changes it's generally used for your directional lights which acts as your sun basically so we can drag that as well so if I type in directional light you see we get everything else that we need if I remove the fog you'd see that the fog went now for example here I have lost my directional light and or any other component so in order to navigate to that you can use this outliner window which will have a list of all the objects that are in your scene you can do quite a few things actually if you want you could select these and you could actually put those in one folder so I can go ahead and right click create a folder and I can just drag those inside this folder you could do that as well in the outliner so now let's say you lose your directional light you can head over here and let's just call this one sky for example let's just call it Sky actors I'll tell you guys why we call them actors a bit later on so you can drag in a sky atmosphere Skylight and stuff like that so these are the basic components of your Sky now if I go ahead and zoom into my directional light press e on my keyboard and rotate it you see the sun moves along with it so let's say we wanted an evening Sky we would use something like this and if you would notice the mobilities that set to stationary you could set it to movable then everything will be calculated dynamically and you won't have to build the lighting you could set it to stationary as well you could set it to static if you don't have any moving objects in your level now let's go ahead and just save everything now let's start actually creating something in our level so first of all remember I told you about the landscape tab this is what you would use if you have a larger world but for our purposes I'll just show you guys how to work with Landscapes even though we aren't really looking for a large world so here you can select your landscape material but you can change it anytime anyways and let's say you wanted a water body or something or let's say you wanted to have multiple multiple layers you know in your landscape you can click on enable edit layers uh and these things are basically a transform and stuff like that and these things are just these options number of components and the overall resolution adjust the size of your landscape so you can play around with that to see uh what the Precision or rather I should say the detail level of the landscape and the size should be depending on that you can increase that or you can go ahead and use a height map I actually have a chart on my channel on how to use height Maps properly in Unreal Engine but for our purposes we'll just create our own so let's just create everything with the default options and let's hit on create so it is going to take a while and once we are done with that we have a landscape now if I go ahead and press play as you can see I can navigate around this landscape just like you can navigate in any other level so now what I'm going to do is I'm going to edit the landscape now these are the tools that we'll be using to edit our landscape so you have to be under landscape mode and under this section over here you would find sculpt you can increase the tool strength you can get the brush type over here as well uh one thing that you will use is probably the alpha brush basically you can have your own mask and stuff but for our purposes we are going to be using the regular old Circle brush so I'll just increase the size now this need not be the limit actually I can set this to 10 000 as well so if I go ahead and do that Let's see we have kind of a mountain here now what if I wanted to randomize the bumpiness in the map I could use noise so you see it's going to be like this but this is overkill so I can go ahead and change the tool strength to something like 0.05 and as you see this is a lot more reasonable so this is what noise does flatten as the name suggests is going to flatten your landscape at that level so let's say select this level everything else is going to go to that level if I use flatten now obviously I can increase your tool strength if you wish completely up to you and there are many other things such as the brush fall off so basically if you want a softer brush so you could use the brush fall off and increase that if you want a completely hard brush you could go ahead and use this but as you can see it produces harsh effects so we aren't going to be using that again completely up to you and erosion is basically if you wanted to create natural looking slopes and stuff so for example so I'll just reset some of these settings here so something like this you could experiment and find out what what each one does but generally you would stick to sculpt smooth flatten Ram and maybe sometimes you would use erosion and you would use noise and let me show what ramp does real quick so if I select ramp and if I go ahead and click somewhere and click in another place and click on ADD ramp you see it Bridges those two locations with a straight line and this is going to be a ramp you could add a ram anywhere like this so I can go ahead and do this and I can click enter or I can press add ramp on the menu over there and it's going to add a ramp now if you had a character or something you can walk over it now again we can use the smooth tool in order to smoothen this out so now these two in this intersection looks seamless so these are basically a landscape editing tools there is not much depth to it and not sure what it is does actually so I've never used eres to be honest you just undo changes if you really had to and one more thing if you wanted to do the inverse of an operation so let's say I am sculpting a landscape so let's say I wanted something like this so I'll increase the tool strength so make that let's say 0.14 now this is one way but what if you wanted a pit instead of a hill the way you do that is by holding shift it's going to reverse the operation and it is going to make a pit same goes for the other tools as well shift is going to be the inverse of the operation so that's about what you'll use in the unreal editor most of the time so now we can start creating our own assets make sure you first of all go into select mode again don't forget that and now we can go ahead and start talking about blueprints foreign so let's start talking about blueprint blueprint basically is the visual scripting language which is used to write game logic in Unreal Engine so blueprint code can be written in many types of assets if you right click go to blueprint class you can write blueprint code in most of these assets and we will get to some of the important ones a bit later for example act upon character player controller game mode there are few others such as the game State player State and so on we'll be getting into all that now the most basic type of blueprint is going to be a level blueprint so if you head into this menu over here click on open level blueprint you would say you'd get a blueprint associated with your level now begin play is as the name suggests something which is called as soon as the game begins or in this case as soon as you open the level please do not interpret begin play as when you click on the play button this is only called once you load into the level so let's say you load it into another level the begin play for that level will be called as well in order to actually start writing code you would use some builtin functions or you could write your own so the way you do it is if you right click for example and if you just type in I don't know let's say set location now let's say you wanted to set the location of something in your level let's actually do that uh since this is object oriented you will need context for everything so you need to know for Which object you're actually moving so for example let's say we have a point light here now one handy thing which I forgot to mention before let's say it's up over here and you want to snap it to the ground you can hit end on your keyboard and it's going to go to the ground level now we have this have that selected and head back into your level blueprint if you right click you get an option create a reference to point light now internally this is a pointer to this object or rather I should say to this actor anything that can be placed in a level is called an actor just remember that now if I drag off of this now I want to get its location let's say for example now the search bar is really useful for that you don't really need to know the function names especially in blueprints so just type in get location and you see get actor location now I can go ahead and print it for example so if I right click and type in print you see print string now this is called a function even this will be called a function so let's say I drag off of this and I type in set actor location again every getter will usually have its own Setter if it can be set so what we are saying what we are implying by this is set the location of this point light to be zero which is what you've defined over here now let's say we just wanted to move it up a bit so we can do plus and on the Z we can do 200 because Z is the up Axis in Unreal Engine and we can set that to be the new location so if I go ahead and press play don't see much uh see mobility of the light is set to stationary so we have to make it movable of course uh remember what I was telling you guys earlier with static and stationary you would assume it to be in the same place but with movable it's fully Dynamic so now if I press play you see it became dimmer in case you guys wanted to see the change if you just press D on your keyboard and left click you get a delay node or you could right click and search for delay but I prefer using D if you press D and left click you get a delay node let's just keep a delay of two seconds and then let's move it up so if I press play as you see it got dimmer because it went up now this blueprint function has a couple of pins on the left so these are called pins the stuff from which you can drag off of now the Triangular one or the pentagonal one I don't know what shape this is the one which drags off the white wires these ones are called execution pins so this function will be executed only when this pin goes from left to right so only when you connect something to it from the left and when this is executed this is going to be called and once this is done this is going to be executed now this one is a function as well get actor location is a function too however it does not have an execution pin you might notice the reason is this is a pure function you can define a pure function whenever you need a function to return immediate values so what I mean by that so for example if I have this hit result and let's say I print this out so I can't print out a hit result I figured so let's just take location now this is just a sweep hit result so let's say we move it somewhere and it collides with something in between it's going to return a hit result if you have sweep enabled uh now if I print this out this value right here is actually cached so let's say I copy a print string and let's say I print this out again set actor location is not going to be called once again this value what you had is going to be cached in your memory however over here if I just drag off of get actor location and let's drag off of this once again so let me drag this over here this value is not cached what I mean is get actor location is executed each time I'm calling this print string wherever I am referring to this value the entire function is going to be called once again and in this case it makes sense because whenever we execute get actor location we want at the live location of of the actor not the location which it was in previously if we go by that logic we would get the location before it was set so we will get the live data using a pure function and the target Works in a similar way we are getting the point lights location so the target is point light now one more thing you might notice is event tick tick is basically a function which is called on every frame so if I just hit print and if I just print out tick for example you'd see it prints it a bunch of times basically every time a new frame is drawn uh the tick function is called now whatever I told you guys is just a vague overview of how blueprint works so I just talked about execution pins and that it's object oriented and types are color coded but now let's actually start talking about them one by one so the first thing you would want to do in any sort of a programming language or if you're writing any code is first of all be able to store data and that's done through variables now the way you create a new variable in Blueprint is by clicking on this little plus icon on the left hand side this menu is available in almost every blueprint so click on the plus icon and you can create a variable now let's just call it my variable for example now over here since blueprint is based on C plus plus obviously you you have to define a type for it so by default it's set to Boolean but you can select any one of the other types I'll go over some of the important ones if you are familiar with C plus plus these things will seem pretty simple to you guys so Boolean is basically a true or false value so for example if I drag my variable and let's say you want to get the value of a variable you can drag it and hit get so this is going to be the value so off of this pin let's say I I type in if we'll get to branching and stuff a bit later but I can do stuff like this since this is a true or false value if this variable is true this execution pin is going to come out if the value is false this execution pin is going to come out so that's basically how it works same way with all the other types so I can click on this variable and change the type to integer which is basically a nonfractional number N64 is basically 64 but integer so let's say you have larger numbers so you would use integer 64. however I don't really find many use cases for it float is a decimal number and then you have name String and text all of which are string types most of the times you would be using string however in some cases you would use name as well for example in tags which we will talk about later and text is mostly used for UI and stuff like that so if whatever you see in menus and things like that uh the text the strings over there are stored as text so that's the data type you'll use now a vector is a struct with three floats in it x y and z now obviously if you don't know what a struct is we will again talk about that no issues Rotator is a similar thing except uh there is a limitation on what values you can have you can only have a value of 0 up until 360. beyond that the Rotator is going to be invalid and transform is basically a struct again which contains a vector a rotator and a vector so location rotation and scale so this is transformed these are the fundamental types which you use most of the time however if you go undestruct you would see there are a lot more you will not use most of these uh some of the common ones that you will use are things such as hit result so hit result is a common one that you'll use now if I compile this and if I go ahead and drag this out and if I go ahead and break and one more thing if you want to get this variable there's a shortcut if you hold Ctrl and drag it you will get the value and if you want to set this variable you can all drag it so that's just a small tip I can give you guys so now bracket result is going to show us all the different variables inside this now similarly you can do that with any other struct if you just drag off of this and try type in break you can do that or with some structs you can you can even do split struct pin or actually with all structs so that's basically another way to see what members are there in the struct so for example uh similar to this this was the same struct over here so you see initial overlap so this is going to be their blocking hit location and things like that so that's basically your struct that's how it works in Blueprint and one different type is going to be our object type variable so for example if I select an actor and this was an object type as well if I drag off of this the variable which is color coded in your sky blue or your light blue color so these are basically object references internally when you write these in C plus plus so let's say you create an object reference for blueprint in C plus you can expose C plus plus variables to blueprint by the way they are stored as pointers so basically it's the memory address to that object now if some of these things sound confusing to you just stick along and watch the course till the end and if you guys still have any confusions make sure you guys do check out a video on pointers and I will go over actors and stuff like that basically uh this variable is going to refer to an actor and since this is a pointer and the default value is none so if I go ahead and click on this you see it says None so what this means is this is not a valid pointer and if we actually had some logic in C plus plus it would throw an exception so that's basically how object types work and you all also have enumerations which are are in in some disguise just your byte which is an unsigned 8bit integer so basically uh for example if I just grab a random enum over here I can do a switch which we'll talk about so basically depending on the value of this variable you can perform your logic so a common thing that you would use it for is let's say you have a weapon in a game and depending on the type so let's say a weapon is fully automatic you would have an enumeration so one of these enumerators is going to be full auto the other one is going to be semiauto the other one is going to be bolt action and depending on that you would execute the appropriate logic so that's one way of using enums there are many applications of course we will get to most of them later now that's about how you basically create variables so now let's actually talk about a few special types of variables namely structs and enums now I did show you what's a struct and Anum but I'm pretty sure it went all over your head if you're a beginner so let's just delete that and click on this variable and hit delete to delete that as well compile and save that now go ahead and right click create a new folder and call it structs and I'm doing this in my content folder uh you could do it in the same place if you want to follow along right click go ahead into Blueprints and create a structure and for now let's just call it my struct now structs by definition in C plus plus is going to be similar to your classes so basically you wrap a bunch of data and methods into a single unit however in Blueprint as a structure purely refers to a collection of variables you cannot have functions for structs in Blueprint sadly however you could just create a library for that so you have blueprint function libraries and you could just create functions for your structs anyways so the way you work with this is you can create a bunch of member variables a very simple example is going to be a 2d Vector Unreal Engine already has a 2d Vector type but just for demonstration purposes let's just create one so let's just call this X and make this of type float because it's a decimal number add in another variable make it of type Y and make this of type float once again so basically my struct is going to contain these two variables now if I head back into my level make sure you save this and if I go ahead and right click somewhere and type in Maestra you see you get an option called Break make and set members so if I go ahead and press break you see you get options X and Y now just like how you create an integer or any other variable you can create a struct as well so let's just call this one I don't know maybe my variable once again and it's going to be of type my struct so my struct is the type so this is our user defined data type now I can go ahead and get this I can right click perform split struct pin once again so this is basically how struct so basically you have one variable which stores multiple variables within it so this can be very handy for example in this hit result you have all these variables now it did not need not be the same type the types can be heterogeneous so I could have an integer over here I could have a string over here so let's say I have a student struct I could store name his role number and stuff like that so just a big example over there so that's basically how structs work in Blueprint so I'll just delete that we don't really need it but we'll keep my strength let's actually have something more descriptive let's say we have name and let's say we have points this makes no sense right now but we can use this a bit later on and you could anytime add a new variable but remember avoid removing variables from structs sometimes they do cause some issues with the blueprint so be careful with that in C plus plus though it won't be too much of a problem since you refer to the members by their names so that's one thing to note now one more thing if you guys want to set the members of a struct what you do is you just type in set members and you can get the struct name that is my struct in our case so we can use this and set the members now over here on the right hand side under default category you can get any one of the variables as pins and you can set the value now obviously you will need to tell it which struct so let's say you created a variable of type my struct so by struct you can go ahead and pass that as the struct reference now this is a reference because this pin over here is diamond in shape or rhombus or whatever that is so that means it's a reference so it is referring to the actual variable that you pass in so it is going to adjust the value of this variable oh we will deal with a lot of structs as we move on however there's one more special type which I would like to mention and those are enumeration so I will right click create a new folder and I'll call this one enums open it up and over here I can head into blueprints again and type in enumeration so this is basically a list of values and you could perform your logic depending on this list so let's just uh create an enum and let's call this one my enum again now over here you can add enumerators which basically are list items so let's say add three items so for example let's take names of fruits so Apple banana let's say and maybe a mango now once you do this these are basically the enumerators which are there and I will show you guys what it actually implies so I'll just go ahead and create a new variable and I'll call this one I don't know let's say fruits choice for example and it's going to be of type my enum now internally ultimately an enumeration is just a number basically it's a number between 0 and 256 so for example over here apple is going to be index to 1. Banana is going to be mapped to 2 and mango is going to be mapped to I mean one and uh mango is going to be mapped to 2 so 0 1 2 so that's how it's going to be internally now obviously you can give a description as well over here in Blueprint uh so if I just drag this in now by default it is set to Apple you can see the default value on the right hand side and we will talk about all these options a bit later on in the variable section so just to be brief uh if you are like creating new objects in your scene uh you would need some of these and for multiplayer and stuff you would need replication and we will talk about them in depth so nothing to worry about now you can cast it to a string so unreal has it built in to give this out as a string so if you see you should get apple printed oops I have something on tick so let's just delete that so nothing's printing uh okay we have a delay of two seconds let's just delete the set actor location stuff and just print this in and we could actually change this as well you can copy this and paste it by hitting Ctrl D so if you click on this and hit Ctrl D you can duplicate it and if you drag off of this you'll see you can perform a switch so basically if the value of fruits choice is Apple it's going to perform this logic so let's just say held it for example and for banana let's just give something else so it honestly doesn't matter copy that over and let's say we give tasty for mango so if I go ahead and press play you should see it says apple and healthy now if I set this value so if I alt drag it and I set this to banana now you should be able to see that it prints the second string so this is basically how enums work and this was actually a bit of a lengthy way I did it there's actually another shortcut you can use in Blueprint in C plus plus though this is the only way you would just type in switch instead of using this node so one more shortcut is if you drag off of this and type in select depending on the value of this enum you can make it do certain things so let me remove the switch here so now what I'm saying is if the value of fruits choice is Apple this is the value that will be passed so in this case I'll just type in one for example and over here I'm going to type 2 and 3. so what we are saying is if the value of this enumeration is Apple it's going to print out one so the value which will be returned here is going to be this value same with the other two choices so if I press play you see it says apple and it says two that's because we had set our choice over here if I change this to Mango over here we are going to get three so that's basically how enumerations work real engine let's start talking about the core scripting features in Blueprint so the first thing that you can do is create functions now a function is basically a block of code which adds functionality to your program so what I mean by that so in order to create a new function you can go ahead and click on this plus icon right here and we could call it whatever we want we could call this one my function and generally speaking you would use Pascal case so basically each word is going to start with an uppercase character so generally that's a convention you use you could use a space as well in Blueprint but generally it's not a good practice now I can call this function from my event graph now if you see you have opened two tabs one is the event graph and one is my function so I can close my function and I can double click on this on the left hand side to open it as well now if I drag this in or if I right click and type in my function you can go ahead and call it so basically this is going to execute my function so let's go ahead and actually do something with it now inside my function this is blank right now I can just go ahead and print a string and we can call this one my function is executed so I think I butchered the spelling but doesn't matter so if I go ahead and press play you see my function is executed now we can also pass in values so I have created this points variable here so just create a new variable and make it of type integer and call it points now if you head into your function and click on this block right here you can actually add input and output parameters so if I click on the plus icon and change the type to integer and I can call this one points so I can take this points value from outside the function so if you look at this now you see I can pass in points so that's pretty handy now I can go ahead and print this out as well so I can print out my function is executed and I can print out points as well and if you double click on the wire you can use the reroute node to keep things a bit clean now if I press play you see you get my function is executed and you get 0. now if I change the value of points for example you see we get that number so this is basically how input parameters work now what if you had some return value now let's say instead of points this was health so let me just call this one Health so compile that and over here if I click on this once again I can add in an output and you see it creates a return node for us so this is basically like your return keyword in C plus plus so when your function goes to this it's going to exit the function and the value whatever you want is going to be returned now you need not have it you can have an empty return node as well now in our case let's just return a Boolean and let's just call it be killed for example and let's change the name of this to be Health as well and we could do a simple if check we will talk about if as soon as we finish functions events and stuff like that so if I can't do that so let me just grab in an if if this value that is our health is less than zero or less than or equal to 0 then what we can do is if it is true and if you type in Ctrl D you can have two return nodes so if our health is less than zero it's going to be true otherwise it's going to be a false now you can go ahead and print this out over here now our health is 32 so we should have false let's say we set our health to be 1 which is invalid of course but we get true so this is how you can return values outside a function now one aspect of functions which I did not cover and I'm recording this a bit later it is going to be local variables so what if you had some variable which you wanted only within a function so let's say for example we have a variable temp for example so let's say you wanted a number to be stored temporarily inside so for that case you would use this local variable option they work exactly the same as you would as it works in C plus plus and one more thing the input parameters whatever you take are also local variables so you can just grab an in and instead of dragging this actually you can right click and type in in and if I just get it so I should find it at the very end of somewhere or rather let me just type it get in so N is a really commonly used word so that's the reason we are getting it so many times here so let's actually change it so let's just type in in one two three let's say so n one two three so you can get it actually so you don't actually have to drag this let's say you have a large blueprint graph you don't have to drag it actually you could you could just do this over here that works totally fine as well even over here actually you could do this and it's totally valid so that's about it for local variables as you use them you will kind of understand their purpose but without a solid example we will not actually be able to tell the use case however once we actually get to the end where we actually create something that is when we'll get to practical examples at the base level those are what functions are and we will go a lot more in depth about functions events and stuff so not to worry about that I'll just go ahead and deleted that let's create a new one once again and now let's talk about the limitations and let's talk about the next type of scripting feature in Blueprint now one limitation that you would see is you cannot add a delay so if I right click and type in delay you actually don't get a delay note the reason is you cannot have latent nodes inside a function in Blueprint so delay is actually a latent function so what I mean by that is it actually takes some time to execute so let's say I cut or copy this and paste it in here you see I cannot do that it says one or more copied notes could not be pasted into this graph so the way you can handle this is you can use a macro now macros and blueprints are more like functions than C plus plus macros so they work a little bit different now if I call this one my macro for example I can go ahead and add a delay so I I can hold down D on my keyboard and left click and I can add in a delay one thing you'll notice is by default it doesn't have any input or output pins you can go ahead and add that but there is another advantage of macros now for example let's say we we have a database on our server and let's say it takes some time to retrieve the data so let's say it takes around 0.5 seconds for your computer to connect to the database and retrieve the data this is just an example it could be anything that takes time for example uh the prime number program takes some time to execute after you go to a larger number so while this is being executed now let's say you just wanted to print out something saying that it's starting and then you want to do something else when it's completed this is where it can come handy now you can type in print string and you can call this one starting now you could come in here and now you would notice this execution pin got disconnected you can't do them parallely but there's a workaround for that you can type in sorry sequence and over here you can just print this out and then you can go ahead and perform this and over here in the output as well you can drag this in and a handy thing which you cannot do in your return node in your function is you can have one more of these so now if I just give a longer delay so that we can recognize it and if I drag in my macro and if I print out strings over here and over here so we'll call this one done and here let's just print starting underscore outside for example so if I press play starting now and starting outside got executed first then after two seconds are done was executed so things like that can be done by macros which you cannot do in functions now the whole point of using our own macros and functions is of course code reusability so let's say I want to call this macro once again I can just type in my macro and I can call it now one difference I would like to mention and then we'll head into the next one which is collapse graphs is with a function let's say I call this my function my function I can actually execute this from another blueprint but this is not true for level blueprints it's a little more tricky to do it from level level blueprints you you guys will understand why once we actually head into classes and stuff but I'll just show you guys a simple example so I'll just create a blueprint here of type actor and we'll talk in depth about this later and let's say I create a function as you can see the same uh features in the blueprint are available here and let's just call it warrant test for example compile that now if I were to get an object reference to new blueprint so I'll just do that by dragging it into the level so I'll drag this and I'll create a reference and if you can notice I can actually call test from here however if I create a macro so let's just call this one test M for test macro you would see even once I save and compile everything I cannot call test m i see test but I don't see test M so that's one more difference between a macro and a function you cannot call a macro from you know uh other blueprints but you can call functions from other blueprints of course if you set the axis specifier to be private in that then you can't call functions either but you can by default now what if you didn't want to reuse them what if you just had this code but this looks a bit messy so you wanted them to be shown as one node let's say this whole thing did something one you could just press C on your keyboard and comment it however there's another feature in unreal called collapsed graphs now you can right click and click on collapse nodes and it's going to create a collapsed graph now you can have inputs and outputs here as well but in my experience I have never really bothered using them and let's just call this one my collapse graph and if I go ahead and type in my collapse graph by right clicking so let's say I type in my collapse graph you see I cannot call it because this is not a function this is just all of this code just stuffed into this collapsed graph so I lost my event graph here you can head back in or you can click on this away so that's basically a collapsed craft that's about it and when we actually use them you will get an idea you can actually have further execution so let's say I have this so it's going to come out of here as well so stuff like that so I'll go ahead and delete that it's not of much relevance now that we have studied about functions macros and collapse graphs let's actually look at implementing the various programming constructs inside blueprint so we'll use the level blueprint again and after this we will get to actually working with blueprint classes now the first thing that you would want to do is do an if check and we already did that several times so if you right click and type in Branch or you could just type in if or you could hold down B on your keyboard and left click that's another shortcut which I like to use you would bring up a branch node so a branch node takes in a Boolean and depending on its value it's either going to go true or false this is an execution pin again so depending on the value of this variable you can go ahead and execute some logic so instead of Health let's say I have B Alive as a variable so if the player is alive for example so put that in so if the player is alive then we are going to go ahead and run this logic otherwise we are going to run this now there's another thing which you can do with booleans which I probably mentioned for enums but you can actually do a select as well so if I go ahead and select you can go ahead and do this so again you can actually get this return value to take it to change depending on the value of this variable so this comes in pretty handy now this is the most basic type and there's nothing much to explain really so you could go ahead and print something and maybe do something else and if he's not alive maybe you can go ahead and you can quit the game or anything like that so that's basically it now the next construct that you'll use is switch now switch is something which we already talked about but we are going to go a bit more in depth now now I'll change this variable to an integer again or rather I'll just undo everything so that we have our integer back okay I've saved it in between so we can't so I'll just change the variable type and for this we are going to rename this to let's say health again now I have health so oops let's just compile that again control drag it now if I drag off of this and type in switch you would see that I get the switch on end node now basically what this means is if I just click on ADD pin and you can also set the start index so let's say you want it to be negative 1 to start with you could do that as well negative 2 for example so what you are basically saying is if the value of health is 1 head into this execution pin otherwise default is basically like an else so if none of these corresponds so let's say we have one two and three if the health is neither one nor two not three it's going to head into default so for example if I just go ahead and print now since our health is 0 and we are starting at 1 we should get hello printed in theory so we get hello if I go ahead and drag off of one you're not going to get anything now the same thing if I just change the value to 1 I change the health variable value to 1. now you should get hello so this is how switch Works generally I would be using this with enumeration so for example we have my inner mother so let's just delete everything in the graph now my enum my enum now if I grab this into the graph and if I then type in switch you see you get the options so if health okay we can rename that to something a little more descriptive so let's just type in some enum so if our enum if some enum is Apple this is going to be executed if some enum is banana this is going to be executed if some enum is mango this is going to be executed so this is basically how switch works so that's about it actually now this was for your selection and to evaluate condition now coming to the iterative constructs let's say you wanted to print numbers from 1 to 10 you can use a loop now if you guys are familiar with CC plus plus these will seem much much easier to deal with there are basically two types of Loop and there is a version of while loop called do while loop so the types are while and far and there is one more type which you use a lot which is for each and we will get to that once we start talking out arrays now if I right click and type in while you see you get while loop so what this basically means is as long as this Boolean is true so I can change this to Boolean once again as long as this is true this value is going this Loop body is going to be executed so for example uh let's say uh let's actually make this a number again let's change this let's say I wanted to print numbers from 0 to 10. so I'd set the sum enum or we'll call this one num we can set num to be equal to 0 by default and now we can do an if check as long as number is less than or equal to 0 or rather 10 we can go ahead and print our number so we can go ahead and type in print string and we can just Ctrl D print it out now obviously the this is an infinite Loop you have to change the value of num itself so what I can do is I can set num to be equal to num Plus 1. so this is one way to do it also if you were to notice if you just drag off of the sentiment plus plus you can actually do increment as well so this is basically like your num plus plus in C plus plus that's how we would interpret that now if I go ahead and press play you should see we get numbers from 0 to 10 as expected so that's basically how you use a while loop and once this Loop is done again you can go ahead and print something so let's say printed numbers printed numbers now you see it prints from 0 to 10 and it just goes to completed this is how we would execute your logic one thing to note though avoid using Loops in your program especially in Blueprint unless the array length is you know less than about a few hundred it's fine but let's say you're dealing with larger data sets please refrain from using Loops in Blueprint uh try to use as much as you can in C plus plus because blueprint if I haven't mentioned yet is slower compared to C plus plus when you call Print string for example this is actually a function called in C plus plus so the actual function of print string is written in C plus plus it actually takes a little bit of processing to actually switch between blueprint and C plus plus blueprint is kind of like your jvm where it actually runs on a virtual machine so blueprint code is going to be comparatively slower than C plus plus but in this case this code is pretty simple so you don't really need to do that we will get to where to use blueprint and C plus plus much much later there's nothing much to worry about for simple games now the other type is going to be a for Loop so if I just type in for Loop you see you get for Loop this is how you basically execute your for Loop however this is a little more or actually much more easier than what you have to do in C plus plus in C plus plus you give an initialization expression an update expression and a conditional expression I am mixed up the order but anyways you get the point and you got to actually give the body of the loop like that but here in Blueprint you just type in a first and the last index which makes it very very simple for you to execute a for Loop and if you were to just drag this in let's say I just type in 0 and 10. and I just go ahead and print this we don't even need a variable at this point we can just grab this and we can go ahead and run this and it's going to print 0 to 10. so this is how you use a for Loop now there is another variation known as the for each Loop which is used similar to range based for Loop in C plus plus to iterate arrays and stuff like that we will talk about that now again the completed works the same way once this Loop is completed executing you can go ahead and print something or execute whatever logic you have so this is your for Loop and there is another variant of for Loop called the for loop with brick so if I just type in for loop with brick you see you get this now let's say I wanted to stop at a certain point let's say uh I mean in this case it's kind of useless to do it but let's say I wanted to stop in between let's say I have some logic we can just grab in some random logic uh let's say this number divided by 15 you know uh we have to make this float remember because integer division works in a different way so let's say this number divided by 15 if it is greater than 3.5 we want to break let's say we have that logic so we are going to print as long as this number divided by 15 is greater than 3.5 so do that if this is true we are going to break whoops and if we go ahead and print this we can just go ahead and print the number instead and once this is completed we can print something else now obviously to tidy this up you can use a reroute node and you can do this so this is one way to keep your blueprint craft ID so we can type in completed so that's done and we have a compiler error it says so okay we'll we'll take that in as a float so convert this pin to a float convert this pin to a float and then let's just do that and let's compile this again save and go ahead and press play now we would see it's 52 so if we actually bring up our calculator so we get 51 by 15 is going to be 3.4 and 52 divided by 15 is going to be 3.466 so that should be the last number so now if I do 53 divided by 15 you see you get 3.53 which is greater than 3.5 so it did not print that foreign to head into R for each Loop now for this we'll need to learn about another data structure now this is a variable right over here where you select the variable type to the right of it you get an option to change it to an array set or a map now an array is basically a collection of homogeneous elements so basically in this case num is now no longer a single number instead it is a collection of numbers and why I say homogeneous is because I can only have integers in this list I can't have 0 and I can't have a string in the next index so basically each item is going to be referenced by an index so the first item which you put in is going to be 0 and stuff like that you can put in any number and if I have to iterate through this I will use a for each Loop now if I go ahead and print this out you would be able to see that I print in all the elements in that array so I printed in 2 and 32. which is what exactly what we have so that's basically how it works now one more thing you can have it of any type in case you guys were confused I'll create a new one for example uh let's just call it one Str array and let's make it of type string and let's compile that and I can go ahead and add a few elements I can I can just type in any set of characters and I could iterate through this as well so I can just drag this in compile that and go ahead and run this program now you see you can print that as well so this basically stores multiple of the data types elements and one more thing since this is an array this is more of a theory thing but the elements here so this string so let's just actually name it one two and three for our reference so 1 is 1 2 and 3 these are actually stored in continuous memory locations so iterating through them is actually a relatively cheap option now unfortunately Unreal Engine does not provide us with a linked list structures in Blueprint we have to implement that ourselves if we needed to but most of the times you'll be using arrays and Maps you will not be using sets or linked lists most of the time however it is Handy to use linked lists in some very rare occasions but we will not be going over that anyways so let's just delete all of this we are done with this so that's basically our array and your for each Loop now you can have an array of structures as well it's totally fine so I guess we called our my struct if I'm not wrong we could have an array of those that's about it basically you could store any type of element now I can go ahead and click on the plus icon and I can add the name and points and it works just as you would expect so I can go ahead and delete this we don't need that anymore foreign now along with your regular if switch and your Loops unreal in blueprints provides us with a a couple of Handy nodes which you might need one of them is called flip flop so what does it mean so flip flop is basically basically this is how a flip flop works if this execution pin goes in once a is going to be executed otherwise if you come here again B is going to be executed so let me actually show you what I mean so if I just drag this in and if I print and let's just say a is executed and now if I just go ahead and given a delay of let's say a second and if I copy this over and let's just type in B is executed give a delay of a second and again head back over there so I'll just use a reroute to make things a little more clear for you guys now make sure you guys do comprehend this logic correctly if I go ahead and press play you would see it says a is executed B is executed and it's going to be alternating like that so that's the use of a flip flop you could use this uh for key presses so let's say you wanted something to happen when you press the key once but you wanted something else to happen when you press the key again so for example let's say you have a scoping in uh thing in your game so let's say a scoping into your weapon let's say the first time when you flip flop to a you want the guy to scope in and when you flip flop to B you want your weapon to scope out so that's basically one place where you can use flip flop so it's pretty simple now one more thing which the engine provides is do once now do ones and there's also a gate node which you might need but I honestly never gotten an actual use case for this so there's nothing much to really worry about this but it's it can come in handy depending on your game especially if you're going for you know puzzle type games maybe not really sure so do ones basically as the name suggests it just allows you to execute this one time so let's say I print the string and I go back to this this is no longer an infinite loop it's just going to execute it once look it just executed hello and that's about it now let's say I want to call this function just once again so what I can do is I can drag this into reset so if anything goes into this reset the function which goes after completed will be allowed to execute once again so that's basically how do once works I don't think there's any explanation required for it so if I do it on tick so basically every frame it's going to allow you to do it once again and if I just go ahead and reexecute this I know this is an infinite Loop but we do have a little bit of a duration for us in the tick so that's how it will work okay so it did stop the execution over there that's a different thing but yeah basically reset is going to let you do that once again so I can actually get a more practical example so let's say we have a delay of 0.2 seconds and we do this I can actually use a sequence so sequence remember the node which we used before so after 0.2 seconds I can go ahead and reset that and after let's say not 0.5 seconds I can try executing that once again so if I go ahead and press play you see it works as expected whatever we spoke until now were just the basics in order to get you started with Unreal Engine but in order to actually practically create a game we need to First go into some background so that we can learn how to use classes and objects now if you guys aren't aware Unreal Engine or any game engine in general is going to be working on the principle of object oriented programming a bit of a background here so there are two main programming methods that we'll talk about now the first one is procedural programming so this is the approach used in languages such as C where basically your approach is mainly using functions so procedures that's what basically procedural programming stands for so you have a main function and you have several other functions now this is the most simplest form of what it could be however you could have a function over here as well so let's say you have function 4 for example and maybe function 4 can call function 2 or vice versa doesn't really matter but basically your whole program is divided into multiple functions and there is some global data on which it operates on so you have some data over here and maybe function three accesses some data here stuff like that could happen in procedural programming however the approach which is used in unreal in objectoriented programming languages such as C plus plus is going to be object oriented programming of course as the name suggests and here we use a principle known as classes and an instance of this class is known as an object so let me be a little more specific here so all the data and functions so for example or in this case this was a method this was the main function so we have one method here another one and we also have some data over here so all of this is going to be encapsulated into a unit known as a class and I will get to some examples later so once we have this encapsulated we can go ahead and create instances of these called objects so basically your class acts as a template for these objects now the first question that pops up in your mind would be why do we use object oriented programming over procedural well it's pretty simple to explain that so if we look at the wrong approach that is procedural programming you would know that you would have a character let's say for example so let's actually talk about a character which you'll have in a game and how we would approach it with both programming methods so in procedural programming you would have a character of course you are not defining any unit known as character but let's say we have a character in a program and you you're going to have several functions so you have move turn jump of course you'll have other functions I just took the most Bare Bones example and obviously you'll have the characters transform and if you guys forgot about what transform is transform is basically location rotation and the scale combined then you're also going to have a velocity for the character health and other variables pertaining to your gameplay however there is one problem which you might notice we do not have a unit which we can recognize as a character so we have several functions let's say we call the move function for example now when we move when we call the move function we actually have no idea which character we are moving so character itself is not actually an entity so we don't have an actual entity known as a character our program just has functions same with the transform we cannot instantiate another character so this code this entire code isn't reusable so that's the problem now what if we head back into the object oriented type so if we head back and if you can see here we have a class and we have instantiated several objects now if you were to actually model a character with this you would have your character class obviously with the above mentioned functions and data I didn't want to rewrite that so you'd have a character class and now that we actually have a unit which we can identify as a character we can go ahead and instantiate a character and let's say we call it character one so we are going to instantiate it so we are going to instantiate it and let's say we have another player let's say an enemy so we can go ahead and reuse that once again and instantiate character too so now we don't have to rewrite all the functions and whenever we are actually writing code we have an idea of which exact character we are referring to so character 2 is actually a real time entity and this is known as an object so character one is an object character two and character 3 all these three are objects now if you were to remember in our blueprint notes we had a Target pin so if I bring in for example set actor location so I'll just use the same node so set actor location now you would notice there is a character pin now if you were to just hover over it it says actor object reference now in our programming approach what this basically means is we have set actor location defined in our class so let's say for example we have something like this so we have our actor class now anything that can be placed in the level is called an actor so let's actually create that so actor so inside this inside actor you actually have a set actor location method so set that to location and not write the whole thing and let's say you instantiate actor one so let's call it A1 for example when you instantiate actor 1 your program needs to know on which actor set actor location has to be called so we have actor 1 so that is our Target so when we call set actor location in our case in a blueprint we call set at the location now it needs to know on which actor it has to perform it so when you call this in the through the target pin in Blueprint that's how we will do it in the Target pin you specify that and the program knows that it has to set a one's location so that's how it basically works foreign so it's time we apply whatever we learned just now so head into your content folder and create a new folder and we'll just call this one blueprints and inside here we'll create all our blueprint classes and we will compare all of them so basically the most Bare Bones one which you can create is an object now please do not confuse this with an actual object we are creating a class and the class name is going to be object we are basically deriving a class from this object class this is how you basically start in Blueprint however as you proceed further you will understand note that this is not an actor so I cannot drag this into a level now if as I mentioned before Unreal Engine already has a 2d Vector structure but just to Showcase what we can do with such classes let me just actually create a 2d Vector so let's just call this one 2D Vector for example now please note you cannot name a type with a number beginning in you know C plus plus however you can do that in Blueprint so let me just call this on Vector 2 for example so if I open this up you you would see you have a standard blueprint editor you have an event graph but you don't have your viewport and stuff like that which you would see in an actor now one more thing you would notice is you don't have an event pick and play so you get an option to add a custom event which is basically like defining a function but it does not return anything and you can call it just like a function and we will be using a lot of custom events so you would get an idea of what I mean now in Vector 2 we are going to have two variables the first two are going to be floats so obviously we'll think about what we can have later on so it's going to be an X and A Y so these are the variables which are encapsulated inside this Vector 2 class note that this is not an object this is a class and when we actually create an instance of this we create a vector too so that's how it basically works now we don't want this X and Y variable to be directly accessible now the reason I wanted this way is for data security now I don't want to be directly able to write any random value to X and Y let's say this was exposed and you could actually change this directly in memory what would happen is now for example let's say I have a vector 2 object so let me just create that so use the construct object function so construct object from class so I think I misspelled that so construct object from class yep there we have it so I'll just delete this and if you go ahead we will get access to our vector 2. so Vector 2 for example now we have a vector 2 object over here so this is actually a vector 2 object we could go ahead and promote that to a variable so it's going to create a variable of that type and let's just call this one R vector now we don't want any other external entity to actually be able to directly set X so this would be prone to lots of exploits basically so that's the reason what you generally do in object oriented is you make this private you see the option over here called private now basically you will not be able to access X and Y from here so now if I type in get X you see I can't get it if I type in set X I cannot set X so that's one way of providing security to the data now what if you just wanted to access the value that's pretty simple you would just go ahead and create a function so you type in get x value for example so get X and get y and we are going to make this PR functions because we are just returning the immediate value and we could add a compact node title and call This One X and we'll call this one y now in the return node we could just go ahead and return the value so return node and we can go ahead and grab our y here and return that and over here as well we can go ahead and return X so grabbing the return node and return X so now if you wanted to access X or Y you can go ahead and type in get X so you will get access to the x value however you will not be able to edit X directly so again for that we can go ahead and create setters so Setters are basically just functions which are going to set the value so let's say I type in set X and I type in set set y I accidentally type text again so set White all right so once that's set we can go ahead and take in the value and this is going to be of type float and we can go ahead and set our y to be equal to that and we can go ahead and type in let it the return node we don't really need it in this case but anyways we'll have it and in our set X function we could do the exact same thing we could add in an input pin and call this one value once again value and we can go ahead and add in a return node whoops we didn't need that now what if you just wanted to set this entire vector now when we set R Vector we are actually just getting a reference to it we are not actually setting our members so we can go ahead and write a function for that again we could get add a get Vector to and we could also have a set Vector too so something like this this was just to show you guys how we would work with classes and objects so for get Vector 2 we can go ahead and actually return the value so we can go ahead and add in the return node and we can get our X and our y so things like that so for a set Vector 2 we can go ahead and all track this or track this once again now obviously please do understand that this is kind of impractical unreal already has a struct built in which handles all this for us I'm just trying to show you an example of how you would actually use it so this is how you do it so now if I type in set Vector 2 you see I can actually set its value and the target is R Vector so we are adjusting this value and we could go ahead and write in a few more functions so for example we could write a function to print the vector to so print vector 2. so we can go ahead and type in print string and we need a word context object however it is going to take the outer object by default I believe but anyways in these contexts what you would want to do with something which I haven't seen much is you would just get the outer object there is a function for this basically the outer object is the object from which the subject was created so in our case it's our level blueprint and we can call the print function from there the reason is it actually needs to know uh where to actually print the string so that's the reason actually so now I can just type in self self refers to this object itself so we can just pass that in now we can go ahead and actually print something so in our case we can get our X and one handy function which you'll use a lot is going to be append so we can go ahead and type in X for the x value give a space and then print out RX move that over there to keep things clean and we can go ahead and do the same for the Y as well so we can go ahead and give a space and we can type in y with a colon and we can go ahead and print that so we have our y we can go ahead and convert that once again and we can go ahead and print that if you right click you can actually remove the extra pin so that's an option available as well so now this is how you do it now if I go ahead and press play obviously we are not calling it anywhere so now now that we have R Vector we can go ahead and call Print vector2 so this is going to print our vector so this is how it works and obviously we can also test out our set functions so we can type in set vector2 and we can just give some random values to this and if we go ahead and print Vector 2 we should get that value so this is basically how we would work with the most basic type of object now this is mostly useful in cases where you only need some data and methods and you want methods basically because in Blueprint you cannot have struct methods so in those cases you would use an object type so we are not going to be messing with this any further now the the next type which you will use is going to be an actor now this is probably the most commonly used type and most of the other types of class official create will also be derived from actor so let me just create that right click go to blueprint class and create an actor it's directly available here or you could search down there so if I create an actor we'll call this one my actor for example now if you were to notice if I drag this I cannot do that because you cannot place a vector 2 in your scene right however I can drag my actor and I can place it in the scene and if I hit F on my keyboard I can actually see it now this is just a visual representation in the editor so that you can actually see it however if you hit G on your keyboard to go to game view it actually won't be seen now if you were to open your actor you would see the editor is a little more complicated than your basic object you have three tabs the viewport the construction script and the event graph where you will be working with most of the time we will separately talk about construction scripts and we'll also get to the viewport but of our relevance is the event graph right now and we will talk a little bit more about actors you would also notice that we have our begin play and tick which we missed in our basic object type class now if we wanted to have multiple of these actors so let's actually do something practical let's say we had a pickup actor in our game so we have pick up actor and it's generally a convention you do something like this BP underscore pickup because more often than not or here if you see the parent class it says actor right so more often than not you will actually create another class of your own in C plus plus so any code that needs to run fast or something you would put that in C plus plus and then you would derive BP pickup from the C plus plus pickup actor so that's why it's a convention I usually name it like this so I can go ahead and grab this so I have BP pickup whoops deleted the wrong thing so I can delete my actor here BP pickup 2 will be created so these two are pickups and both of these contain all the variables and functions which this creates so you can go ahead and edit our blueprint just like how we would usually all right so it's time to dive a little bit more deeper into some of these events and let's actually start writing some practical code so event begin play is called not when the game begins actually that's the wrong way to interpret it however event begin play is called when this actor is instantiated so for example we have our BP pickup here and since this is placed in our level this will get created as soon as our level starts so it is technically called when the game starts however if I just go ahead and print this and let's just call this begin play you would see two begin place because we have two instances of our BP pickup however it need not be called when the game begins it is called when the pickup actor is actually created so when BP pickup is created that is when it is called so let's delete a vector 2 stuff we don't really need it now in order to actually create an actor remember that every actor is going to have a location rotation and scale so that's the reason you cannot just create an object because you do need a certain number of default parameters in order to actually be able to place something in the scene so without a location the engine has no idea of where to place it that's the reason actor exists now if you head back into your level blueprint let's actually give a delay of a few seconds just to show you guys so let's say we give a delay of two seconds and in order to create an actor you call a function known as Pawn actor so spawn actor from class and over here under spawn transform we could just set that to zero for now it's since we don't have any visual representation it doesn't matter honestly so once that's done we can go ahead and select our BP pickup and we can go ahead and compile it now if I press play you see begin play is called but two seconds later another begin place called if you guys couldn't catch that I'll leave a longer delay begin play and another begin play was called and if you would notice in the outliner you would actually notice another instance being created here so if you were to notice there is another BP pickup that is created so that's basically how it works and tick is called every frame however it need not be once again so if I just go ahead or I can just go and reuse it actually so instead of this I'm going to type in tick and now this should be called every frame let's have let's only have one pickup actor and let's go ahead and not spawn this so if you want to disconnect pins like that by the way you can go ahead and press alt over here and it's going to disconnect the pin so we don't need that now if you were to notice it's going to constantly print tick so this should be about 200 to 300 times a second on my computer so if I just type in stat FPS whoops missed that start FPS it's locked at 120 so it's 120 times a second so if you want to increase it actually you can remove the cap by typing in t dot Max FPS space Max FPS give something like 999 or 1000 all right so I don't know I did that now head back into your blueprints under your pickup and under your class defaults you can actually disable your tick so you can go ahead and disable and as you can see nothing's being printed now there's another thing you can actually change this parameter at runtime as well people don't know this but any and all details which are there in this panel over here so let's say for example I go to my class defaults I will definitely be able to change most of these at runtime so for example we have start with tick enabled so we should be able to enable or disable tick at runtime so let's actually just type in tick enabled and as you can see there is actually a function which lets us do it so if I go ahead and actually enable tick first of all and if I go ahead and disable it after one second you would notice that Tech is being printed and a second letter it stops printing tick so that's basically how it works and not only that any and all parameters and you can actually change the tick interval as well let's say it's printing too often you could just set it to 0.5 so it will be roughly 0.5 seconds now as you can see it is not printing as frequently so that's basically one aspect in blueprints that that is Handy to know because any and all settings that will be there will be usually uh exposed as functions to be adjusted at runtime otherwise again you have your class defaults where you can actually set them I think whatever we did till now is clear now so we can go ahead and delete this code we won't be using it as of now so now let's go ahead and actually write some code for the pickup itself so let's say we had an object and we had to pick it up first things first there is no visual representation for the object so let's say we actually just go ahead and oops okay go ahead and press play you would see that you can't actually see anything no if I zoom into this so as you can see you can't actually see this pickup so first of all let's actually add in a model and stuff like that now there is one thing uh the default scene root is not actually required if I delete it I won't be able to however I can actually add in a static mesh now a skeletal mesh is a mesh which contains Burns and stuff like that so basically your characters and anything with animations is going to be a skeletal mesh basically however your models like your pickups and stuff usually are going to be static meshes so that's basically how it works as you use them you will understand so now if I drag this into the default scene root I'll go ahead and delete the visual representation and the static mesh will be replaced now one thing to note when you do this the most high component the component which is the uppermost in the hierarchy over here is called the root component so for example this default scene root is the root component now when I drag the static mesh this is the root component and if physics has to be simulated in our case let's actually try that let's make the pickup fall down and follow the laws of physics so in that case we will need it to be the root component so that's one thing to note now if I go ahead and select a mesh so for example I can just select this random sphere that we have I think it's way too big so yeah we got to adjust that now I can go ahead and enable simulate physics so now if I go ahead and press play you see that it falls like you would expect so we basically simulated physics now we have a visual representation now how are we actually going to pick this up now actually let's select something a little more smaller because I don't think this is convenient okay this seems like a reasonable size so if we go ahead and press play we are simulating physics so absolutely no problem with that and one thing to remember in case you are not simulating physics make sure you do have collision and stuff like that if you if we actually encounter such an issue I will go ahead and show you guys how to deal with that so we have physics now now we can go ahead and set up some logic now we want to be able to pick this up when we overlap it let's say for example so we can do on actor begin overlap so what this says is when another actor overlaps this actor so in our case it's going to be this when it overlaps this actor we can go ahead and perform some logic and Unreal Engine has set this up for us now there is one problem though this is just R Cube which is our model however we don't have an actual bound so our code won't really be able to know when to actually call on actor begin overlap so even if I disable Collision so the way you do that is you can head over here and from physics actor you could go ahead and change it but we do need physics so we can't do that even if we actually bump into this you won't really notice anything happen so if I go ahead and bump it to this nothing is really going to happen now if I actually go ahead and creates a bound so the way you do that is right click or rather go to add and you can type in a sphere I believe sphere Collision yes so when you create a sphere Collision we could call this one bounds you would have created a sphere and you can't see that because the size is too small can go ahead and increase the sphere radius now these are our bounds so as soon as we enter this our on active begin overlap will be triggered so we can go ahead and print it and if you were to notice the Collision preset over here under the details panel select this and head into your Collision preset you see it says overlap all Dynamic and obviously if you select custom you can go ahead and edit each Channel and we will talk about this later so if I go ahead and press play you see we get hello every time we overlap it now hello is going to be printed every time any other actor overlaps this however we want to print hello only if a character overlaps it and it need not be a character as well now in unreal character is actually a derived class of another class known as pawn and I will talk a little more in depth about this right now so basically this is how it's laid out in unreal basically we are looking for a pawn and I will get to that in just about a minute so we can type in pawn and if you were to scroll down you would see cast to pawn so cast is another programming feature now if you were to feed in an object to this you can check whether it is upon object so now if I go ahead and print this out now uh you would go ahead and actually get hello just normally the reason is when you are actually controlling your camera over here you are actually controlling a pawn actor anything that can be possessed by a player controller is known as a pawn and we will talk a little more in depth right now and just to clear your doubts on whether this logic actually work let's say it wasn't a pawn so which means it's not a player basically so if I copy this over and instead of hello let's just print not player and now if I go ahead and press play you'd see you won't get anything and if I overlap it it says hello but if I go ahead and copy this over and let's say I keep it above this and if I press play you see you get not player printed that is because the Box overlapped another box or rather RBP pickup overlapped another BP pickup however those are not characters so this cast right here failed because the object which came from this actor begin overlap was not a pawn hence we got not player printed foreign part of the course I'll just tell you guys the most basic form of inheritance hierarchy which is there and unreal however once we get to the more advanced part I will tell you guys more in depth but as far as what you guys need to know so at the base level the most simplest type of class from which you can instantiate objects is known as object in Blueprint so object is the simplest type and from that the most basic one which you can create is going to be an actor now an actor is basically an object which has a transform and can be placed in the level as you would have figured by now now under this you have various other classes however for the most basic level we are going to be considering only two so there are many more and we will talk about many others where once we actually come to the advanced part but these are the two which you do require to get up and running so the first one under this is going to be your controller so a controller as the name suggests is a class which has functionality for your builtin to take player input and stuff like that and under controller you also have a special type known as a player controller and there are others such as AI controller so you have a player controller so player and I'm just going to put this so play a controller now a player controller is basically a controller which belongs to an actual player you also have other things such as AI controllers which is assigned to CPU players basically so if you have enemies in game for an offline game or something you design an AI controller now another class that you'll need is pun and that's what we talked about so this is called Pawn now a pawn is basically a class which is an actor obviously and can be placed in the level and note that you cannot place a controller in a level although it is derived from actor it is actually an exception controllers player States game states there are a few other classes which are exceptions and you can't place them in the level however pawns can be placed in the level and a pawn is always possessed by a player controller so a player controller is going to be possessing a pawn so when you call the possess function and you give the target as a pawn you are going to be possessing the pawn and one special type of Pawn which has a lot of functionality built in for us already is called a character most of the times you will be working with characters and not puns however you can use puns so by character I mean a character such as a living being basically so generally if you have like a human or if you have like an animal or something like that you would generally use characters however if you have something like a vehicle you would usually stay away from characters because it has some properties which are not realistic for those however it is completely possible to use a character class for something like a vehicle as well so you can possess a character as well there is no harm in that pawn or any derived class of Pawn can be possessed by a player controller foreign we can go ahead and actually create our own character class or I should rather say Pawn class which is also a character class in our case so we can create that as well as a player controller and I'll show you guys how to set those and how we can go about interacting with this pickup using those so right click go ahead and create blueprint class and as you would see you have character and clear controller right here because they are really really common so type in character and let's just type in BP underscore character again you can you can name it appropriately or as per your wish now if I go ahead and open it up you see this looks a little more different and it already has something set up for us and some of these are quite handy especially the character movement component which is there and if I haven't mentioned yet whatever we did here under the component step these are called components basically basically every actor is made up of several components and you can actually create your own components as well and make them behave as you wish but as of now just know that these are just constituents of these this actor and these are the constituents of BP pickup and this is these are the constituents of BP character basically now we haven't set a mesh and we don't really have one so let's just take okay we have a character tutorial PPP and one thing to note this Arrow actually represents the forward direction of the character so you can go ahead and move it down and you can go ahead and rotate it 90 degrees so let let me have snapping enabled so rotate it by negative 90 and you can go ahead and bring him all the way down until I feel it's correct now we don't have any animations but I'm not really sure if we do have an animation blueprint for him so let's just check tutorial animation blueprint I guess tutorial animation blueprint so yeah we do have an animation blueprint for him now if you want to change the default character that you will be using the way you'll do that is by first of all heading into Window World settings make sure that is enabled and then over here on the right hand side head into World settings and under game mode override you can go ahead and set your own game mode now if I were to just select game mode I still cannot edit it so I will get to Game Mode classes later on because they are not that important but for now you can just go ahead and create a new game mode and it could be of type game mode base or it could be of type game mode it doesn't really matter but I would suggest sticking with game mode base and let's just call this one uh BP underscore game mode uh I just did something there so yeah BP underscore game mode that's what we'll call it and now under this we will get our option to select the game mode now since this is our custom or custom made game mode we get the option to select the default Pawn class and over here we can select our BP character and if I save everything and if I go ahead and press play you would see that we have indeed possessed our character and you were to notice that the camera is a bit off so what you can do is you can actually create a camera if I go ahead and type in camera under the component section you can create a camera and you can align it as per your requirement so this should be about correct so I feel rotating this a bit maybe a bit back maybe a bit to the side would be nice so there you have it so this is our character however we are not actually able to move the reason is we haven't actually written the code for it to take our input Now setting up input in unreal is really really easy and I will show you guys the brute force method as well as the proper way to do it so The Brood force method is for example we want W to be able to make us move forward so I can press W and if you just give a space and type in keyboard you would be able to get W and we can make the character move forward so in order to make your character move basically there's a function for us built in already under the character movement and not character movement I believe it's there in our Pawn class I believe or a character class so if you right click and type in add movement input so it's written in our Pawn class we can go ahead and make him move and if you were to notice we have to provide a direction and a scale value scale value is useful if you are on a joystick or something where you can partially press down so let's say you're halfway pushing the joystick uh knob so in that case it would be 0.5 so the scale value can be given through an axis value now if you were to notice ah there is another problem here when I actually plug this in it's not really going to work as you would expect so for our direction we need the forward direction of the character so a very simple way to do that is typing in get forward Vector so get actor forward vector so get actor forward Vector so that's the way you would actually get the word Direction that's how you do it and if you were to notice it's not going to work as expected at all the reason is this has to be called every frame in order to actually work so the way you do it is Type in uh or rather we can do it on event tick for example so if we go ahead and do it on event tick I'm just doing this to show you guys how to do it if I do this now we would see that our character is moving forward now the most obvious question is how am I actually going to set this up so there is something known as an axis mapping which runs every frame basically what add movement input does is it moves you a very very slight amount and by calling this multiple times in a single second you are going to be adding considerable amount of movement now if I head into my project settings and under input this is the right way to do it the Brute Force wave would have been like doing this on tick and I'll just show you this really shouldn't be your option but I'll just show you just in case so for example you could just have a Boolean here and we could just set this to true for example and when you release it we could set this to false now this is wrong so don't really worry about the logic this is just gonna work but you shouldn't really do this so we could do if new variable is true we want to move otherwise we don't want to do anything so if I go ahead and press play I can press W and move but as soon as I release it I'm going to stop this is the Brute Force way to do it but unreal has a much more elegant system to do it so we can go ahead and delete all of this head into our project settings once again and under input you would see action and access mappings now we want an axis mapping because we do want to be able to control the scale and since add movement input is actually a function which depends on the scale value so remember what I told you about the joystick so we can create an access mapping so for things such as jump where there is no scale value so it's either jumping or not jumping so wherever you have a toggle you would have an action mapping wherever you you have some value which goes linearly you would have an access mapping so we can call this one move forward and make that Pascal case and we could have W on the keyboard for that and again for move backward we could reuse this actually so s is going to be moved backward and for the scale value you can make this negative one now if I right click over here and if I type in move forward you would notice that we have an axis mapping so if I grab this into this input event or rather if I bring this into this axis move forward event and for the scale value if I put this under access value now this will work exactly as I would want it to so if I go ahead and press W it's going to work and even s is going to work now for us so this is basically how you do access mappings similarly you could do it for move right so we could have move right or we could call it move sideways and we'd have our A and D keys so we have our a key and we have our D key so D is going to be this one and it's going to be negative 1. so let's actually just test it out so it's not really doing anything because we didn't set up the logic obviously so move sideways whoops axis move sideways so once you have the event set up you can go ahead and add the movement input and again you can get the right Vector of the actor so basically the right direction of the actor is going to be your right Vector so your forward Vector is always in this arrows Direction and your right Vector is going to be a vector in this direction basically so right vector and if I go ahead and press play so it's always one so that's the reason it's happening so if I plug that into the axis value I am moving reverse actually right now so that's just a simple mistake I did here so I can type in minus one for this and I can type in plus one for this now everything should work as expected so if any of your directions are reversed just multiply the access value by 1 now as you can see we are able to move forward left right and all of that good stuff now that is about it for the keyboard input however if you were to notice I really can't rotate the character so let's actually set that up first so first things first head back into your BP character and the functions which we require to set up keyboard input I mean Mouse input for a character is going to be your controller pitch input and your controller your input so controller pitch input and controller your input so these are the functions that we need now again since our Mouse needs to be captured as much as possible because it it has to detect every tiny movement so we again need to create an axis mapping so go ahead into inputs and create two new access mappings and call one look around and the next one call it look up and for this look around is going to be the xaxis of the mouse so type in Mouse X and for this one type in Mouse y so that should be good and over here if I go back and if I type in Access look around and we can go ahead and add your input over here and over here access lookup oops I misspelled that so head back into input so look up now if I go ahead and compile this and press play you would see that I am able to look around however I really am not able to you know look up and down that's mostly because your character isn't really meant to rotate along with it so that's the reason it's happening so if I head into my camera and enable use spawn control rotation and if I press play you see I am able to rotate my camera however there's one small problem here we are again uh doing it reverse so again in that case as I told you guys before just change the scale value to negative 1. now if I go ahead and press play you would be able to see that our camera is working as expected now there is one slight issue though that is uh our view is kind of off which you can fix but when we actually look up our character doesn't seem to be looking up but the reason that's not happening is because you can't just rotate the whole character now if I were to actually go to this uh main tab over here under BP character and if I search for control rotation so if I type in control rotation and if I enable it to use pitch you would actually see that I am in fact able to do that but there is a small problem now if I hit f8 to unpossess my character you see he just rotates like that however we want only his spine to rotate and that is something which we have to set up using an animation blueprint which we will do later so for now we'll just disable this and even for the yaw part you could you could disable this and you could technically do something like this and maybe set up some other logic in order to actually rotate your character but for our purposes we'll only do it for the pitch another tiny thing that I would love to cover here is how do you actually set up different sensitivities because obviously right now the current sensitivity may be a little too much for some for some maybe it's a little too less so the way you do that is just multiply this axis value by your sensitivity value that's basically how you do it so multiply this and multiply this as well press Ctrl D to duplicate that now we could just promote this to a variable however remember that this BP character refers to only the character which we are playing so let's say we are playing a death match or something where your character dies and you respawn with a new character you would have to pass in the variable every time so instead of doing this we are going to set this up in a class which will be common even when your character is destroyed so the class which we'll use and as you would expect is called player controller so go ahead and create BP player controller so make sure everything is in Pascal case now if you open this up now over here we can go ahead and create a variable and call this one sensitivity and now uh this is going to be of type float obviously and let's make this one private and let's create a method to get the sensitivity now this player controller is going to be persistent even after your character dies so that's the reason we're using it and since we need the immediate value this will be pure and for the return value we are just going to return the sensitivity now obviously the reason we're doing it this way is you don't want an external entity to actually modify sensitivity that would be crazy and one more thing make sure you set this value to anything other than zero because if it's zero your mouse obviously will not move so maybe something like 0.5 so once that's done I should be able to set my player controller first of all over here in your game mode override for your BP game mode go ahead and change your black controller to the one you created save that and open up your BP character and now on begin play what we can do is we can actually get our player controller so we can type in get player controller and we can cast this to our as you would guess BP player controller so we are getting our play controller and we are checking if it is a BP player control obviously we set it over there in the game mode so it will be there is no there's no way it's going to head into cast field so we can just right click and make this appear cast so this just helps us save some space in the graph this will be a success for sure and we can go ahead and type in promote to variable and we'll call this one pcrf for player controller ref now go ahead and compile that again you can go ahead and make this one private but honestly it doesn't matter in this case so on begin play we have gone ahead and stored our player controller and from our player controller object we can go ahead and get the sensitivity go ahead and get the sensitivity go ahead and do the same thing over here compile that and if I go ahead and press play you would see our sensitivity works and not only that actually if I go ahead and change the value so let's say I make this point O one or rather point of 5 for example 0.01 would have been too less now as you can see I can make very precise movements so now this sensitivity option definitely works so this is how we would actually go about setting up sensitivity obviously if you really didn't care you could just have a variable here and stuff like that doesn't really matter honestly and there's another thing which you could do is first on begin play itself you could go ahead and pass your sensitivity over here and you could promote this to a variable over here and instead of calling the function every time and make this one private once again instead of calling the function every time you can go ahead and use the sensitivity variable so that's a little more better in terms of performance this is something which you could do as well now remember we are only able to do this because the player controller is always created before your character spawns let's say a player controller is not yet created by the engine you can't actually do this so let's say I go to my player controller and I'm not sure if I can do it on begin play maybe it would work on begin play but technically if I type in get player character and if I type in cost to my BP character and if I go ahead and print the string copy that over and I'll just type failed for this and doesn't matter to be honest and I'll type in success now if I go ahead and press play you see we get success however this happens only because our player controller is probably created or rather the begin play is actually called after the character is created as well however now I'll just show you guys another class now we'll discuss more in depth about this but if I just type in game instance I can go ahead and create a game instance class and this is actually referring to your whole game application so if I type in event init this is when your game starts this is It's not like the begin play where you are actually you know talking about when this entity is created the event in it is actually called uh act when the game starts so that's one difference so over here if I go ahead and put this logic over here and if I go ahead and go to my project settings and change the game instance game instance to new blueprint we'll delete that soon and if I go ahead and press play you see it says failed because our character is not yet created so that's one thing to note the the begin play logic only work because our character is already created now let's say we added a two second delay now this is gonna work so now if I do this it's gonna work because our character is now successfully created so that's basically one thing that you guys need to understand just make sure all your entities are valid before you actually set them and we can go ahead and revert our game instance so again we'll talk about all of this more in depth this is not something which you would really worry about at a beginner level now save everything and that should be good to go to go a little more in depth on the part where you know you'd actually check if this object is created so in our case I mean everything just worked out smoothly but what if it didn't what if this wasn't valid yet because as I told you guys the default value is none what if this wasn't valid well there is a fix for that as well there is actually a function called is valid so if I go ahead and type in is valid there's actually a macro which is created for us so what we can do is we can go ahead and actually do this so if we we can convert this to a normal MPR cast so on begin play we can go ahead and do this we can check if it is valid and if it is not valid we would not want to do anything but I mean if it is valid we want to set the reference obviously but if it is not valid we want to again check after a while and if it is valid obviously uh after setting the reference you would want to go ahead and set the sensitivity and do the regular stuff foreign now how do we actually check once again so for this you would use a technique known as polling so polling is where you repeatedly call a certain function until a certain condition is met and you actually get your desired result so the way you can do this is by using a timer and that takes us to the next important concept now if I right click and type in set timer you would see you you'd get a few nodes over here however the only one which you'll use is set timer by function name set timer by event is kinda pointless in my opinion because even if you do use this you can actually refer to an event by the function name itself so most of the times you would be using set timer by function name so you set timer by function name now it returns as a timer handle which allows us to control this timer and what this basically means is it is going to call the function with a given name so we can right click on this and type in collapse to function and let's call this one for example get references or let's call this one initialize and we don't really need this in the event graph and over here we can copy over this name so what we are basically saying is after certain time call this function once again so we can have a very small time such as 0.01 seconds and make this one looping because if you just uh set this to point on without the looping it's just going to execute it once and we can go ahead and store the handle of the timer so we can call this one initialization timer and once we have that this timer is now set and we could just comment it out and call this one polling for references again you could name it a little more descriptively you could give it a color as well that's one cool feature in unreal honestly you'd never use it but yeah I just showed it and under initialize we need to stop the timer once we actually finish everything so once we finish setting the sensitivity there's no reason for this function to run again so we can go ahead and get our timer handle first of all and if you just type in clear you'd get an option called clear and invalidate timer by handle go ahead and call that this is how you stop the timer copy this and if it is not valid we don't really want to do anything and if the cast failed again we don't really want to do anything so again yeah this cast is bound to fail actually this check is kind of useless in this case so we can just go ahead and do this because if we don't have a player controller this cast will obviously fail but anyways I'll just keep it like this and now if I go ahead and run this what will actually happen is every 0.01 seconds it is going to repeatedly call the function until we have cleared it so once we get all the references we go ahead and clear the function I mean clear the timer there are some key differences though between doing this and using a delay obviously you could have done this as well so you could have done delay and let's say we give 0.01 once again and over here we can go ahead and call initialize and we can go ahead and loop this obviously we can call this first so initialize then after 0.01 seconds we could do this and maybe we could check if we have all the references we could maybe return a Boolean over here or something and do something like that the difference between a delay and a timer is that a timer is going to be very very precise it is going to be precise usually up to micro or even nanoseconds if you have a precise timer this one I believe is precise up to a couple hundred microseconds so as far as my testing is concerned you could use Chrono in C plus plus and actually test it so this is going to be accurate however a delay is going to be very very inaccurate so that's one thing to note if you want something to time accurately you would use a timer or in our case we needed the looping functionality so that's the reason we use the timer since we have built a fundamental idea on how inputs work now we can go ahead and check the other type of input that is input action mapping now before that let's actually just clean this up a little bit so just comment it out and type in movement movement and maybe you could type in movement and Camera maybe so movement and Camera so now we can just group this now head back into your project settings and under input again if you look at action mappings you can go ahead and add one and we can call this one interact and we could set that to the F key now the advantage of using it through the project settings like this rather than brute forcing so you could do F over here as well so if I just type in F and give a space and type in keyboard I can actually do this but this is not the proper way to do it because this uh these action mappings can be actually changed through your ingame settings menus so you can actually create a menu inside the game and allow the user to change or allow the player to change these key bindings so we'll call the call this one interact now so action event interact and this gives us a pretty basic pressed and released option so when we actually press it so we want to be able to pick up an actor now how are we going to actually set this up so first things first remember we had our actor begin overlap instead of doing it here it's always advisable we do it from the character so do your actor begin overlap here actor begin overlap once you call the actor uh begin overlap or here for the other actor instead of casting to a character since we are the character ourselves here because we are inside the character class right now we can cast to the pickup instead now that we have casted to BP pickup we are checking if this is actually a pickup now there is a better way to do it using interfaces but that is a much higher level concept than casting but I will definitely get to that a little later in this course so we'll probably change this to use an interface even that is casting at the very fundamental level but that's a more elegant solution to do things now if this is actually a pickup we can go ahead and actually store it so promote to variable and let's just say let's just call this one nearby pickup nearby pickup and what we can do is on our actor end all app so end overlap over here we can go ahead and again cast it first things first and if it is we can check if it is equal to the nearby pickup and if it is equal to the nearby pickup and we have left its bounds we can go ahead and remove it and invalidate the reference so we can all drag it and we can set it to be equal to none that is going to invalidate a reference so that's about it now once we have our reference what we can do is we can head in our interact function check if this is valid one more way you can do it is by right clicking and converting this to a validated git so if our pickup is valid which means we are near a pickup so what we can do is we can actually call a function for now let's just print out a string let's say so or rather we can just destroy it so type in Destroy and you will get destroy actor if I go ahead and press play and if I go close to it and if I hit interact you see I destroy the pickup and if I do that once again that is not gonna work the reason is once our pickup is destroyed it's no longer valid so what we have to do basically is check once again if we have any pickups nearby so that's actually really easy to do so once we destroy it we know that our nearby pickup isn't actually valid so we can go ahead and set our nearby pickup to the nearest one now how do you check that again using a function so we want to see if we are overlapping so type in overlapping and you already see you actually get options for get overlapping actors which is exactly what we need and for the class filter it's obviously going to be BP pickup and over here we get an array of actor references instead of getting all of them we can just get the first one this is an array so obviously we have to get the first index of the array so once we get that we can go ahead and cast this to BP pickup once again and it is going to be successful all the time so we can just make this a pure cast because we are actually using the class filter here and then we can go ahead and set the nearby pickup so now our logic should work for both the pickup so if I hit f one of the pickups got destroyed so I shouldn't have moved back actually so if I press f one got destroyed if I press F again the other one got destroyed as well and there are no errors so this is basically how you do something like a pickup now obviously before you destroy it let's say you had some properties let's say for example let's say this was a health portion or something which gave your player a couple of Health points so we can add in I don't know let's say health points obviously you will have a better inheritance hierarchy and we will get into that so Health points make this a float let's say we have 10 so what we can do is for now we can just go ahead and print it so we can grab this Health points and we can just print it out so move all of this logic a bit over there to make space we can just print that before destroying it make sure you call Print before destroy otherwise you're going to get a log error now if I go nearby if I press f we are going to get 10 printed every time so that's basically how you do it however let's say you wanted to change some of these properties depending on which pickup it is now apart from having these as a variable you can go ahead and check these two options called instance editable and expose on spawn what these will do is allow us to edit these properties when we actually spawn it so let's say we spawn a pickup for example so over here let's say I do spawn actor let's have a spawn a pickup you see we actually get an option to change our health points so we could do something like 90 for example and for the spawn transform we can just uh get a random location let's say uh let me just add in something for us to recognize so something which you would use for such a case is called a Target point so I can use a Target point so this will represent a target a point in space you can copy this over and we can go ahead and paste it in or okay maybe we can't do that here you can do it in the details panel so one one five zero uh negative whatever this value is and 650. so 650. and we have health points set to 90 over there now as you would see we actually spawn another pickup now if I go ahead and pick these up you get 10 but when I go near this I get 90. however it need not be restricted to spawning it through the blueprint you can actually edit Expos on spawn variables right here as well so even when you're placing them in the level you could have this to be 20 for example so if I go nearby you would see 10 20 and this one is obviously going to be 90. so stuff like that which you can do using expose on spawn you can expose any variable on spawn and they will be passed right into the actor and the value which you pass in would be set to that variable and now we can go ahead and remove this logic that was just for showcasing purposes and we can go ahead and collapse system function and call this one whoops call this one pickup and along with this maybe we could also have something like door open or something let's say this is not valid we could go ahead and perform door open or something like that we could go to the return node and we could have a sequence node here so first we would check for a pickup and we could also do something like a door open or maybe anything else probably maybe if you had some sort of an interaction system with a player or something so you could interact with the other player stuff like that which you can do using these input bindings and using the overlap events foreign events now I will show you guys how to do it the better way with interfaces later but this is the Brute Force way and if you have maybe one two or maybe three or not more than four interactions you could use this method itself the one which we did with casting so this is totally okay for small things now let's actually do it so right click create a new actor and let's call this one interaction actor maybe we could just uh nudge it or something so let's say we have we have another static mesh make that the root component and we need some sort of bound so sphere Collision Maybe and for the mesh let's just take a cone for example and also I've gone ahead and deleted the code which we had inside BP pickup since we are not using it and over here go ahead and simulate physics make sure you don't forget that and we can go ahead and okay maybe we can have a smaller one for example so I'm not really sure I'm just looking for any mesh that's available to us because we haven't imported ours okay this is way too big okay this sphere seems like a reasonable size we can go ahead and increase our bounds that's about it and once again over here we can head into our BP character and what we can do is we can copy our the same logic so instead of nearby pickup we are going to have something else so if this cast fails so if whatever we are nearby is not a pickup we can check if this is actually an interaction actor so we can do cast to interaction actor and again other actor is what we are checking if it is the interaction actor we can go ahead and promote this to variable and call this one interaction actor again I prefer going with Pascal case all right now when we actually go away from it we can again do the same cast so we can copy this over we can paste it and for this actor if it is equal to the interaction actor which we were nearby so copy this over grab in the interaction actor if it was in fact the interaction actor then we can go ahead and invalidate it and set that to be equal to none so that should be about it now over here in the interaction logic we can go ahead and check if this is valid right click convert to validated get so if we are near an interaction actor uh what we can do is we can instead of destroying let's actually add impulse so add impulse so add impulse so ins so we want to add impulse to the root component here which is simulating physics basically these are the physics functions you have impulse Force dark and all sorts of stuff obviously you could spend some time and study those but we'll not get into that so we have a sphere here so static mesh is the root component so we need to get the static mesh if I go ahead and scroll all the way down I should see get static mesh now this variable refers to the component even components are objects so you can just get them as variables and for the impulse what we can do is we can go ahead and get the forward direction of a character get forward vector now you could change it according to y'all this is logic based so it's nothing much really and you can multiply this by a certain value so you can make this one a float and change this to a float make this let's say something like 10 000 something big Maybe get active forward Vector multiply that by ten thousand and that should be good to go now we can collapse this to a function and we can call this one nudge ball or something because the sphere looks like a ball so nudge ball Maybe and if I go ahead and press play okay we have a compilation error so we can check what's that so it says let's read the arrow first of all okay it was just uh it just compiled it in the wrong order it compiled character before this so it didn't know what static mesh was now we should be able to go ahead and play this and first of all we don't have an interaction actor let's actually create one go ahead and press play now if I go ahead and bump into this oops I shouldn't have bumped into that if I press F on my keyboard when I'm overlapping it uh the bounce is a little too small let me just increase that so increase the radius don't scale it up and one more thing if you want to see the bounds just for testing purposes you can set this flag called hidden in game to false so now it is going to be visible in the game as well so if I look around yeah there we have it so we can enter our bounds and now if I press F on the keyboard you see we actually not jit so the force is way too small so I can go ahead and make this something like 50 000 let's say so if I go ahead and press F over here you see we are actually not doing it so this is the way you would set up interaction using casting obviously you can use interfaces to simplify things a little bit but yeah this is the basic idea all right so in order to understand whatever I just told now in case it went above your head please do Tinker around and try some of the functions yourself using the context sensitive and the and the search bar basically so when you right click and let's say you drag something off of this you can go ahead and type any random function so for example if I just press a you get a bunch of functions maybe you could have a look at all of these maybe have a look at documentation and maybe try out some of your own logic and try out something else maybe add in another actor to do something else with maybe add in a door and make it open or something so you guys should be able to try it out yourself and once you are actually done with that now we can go ahead and talk about the next part now until now we talked about the basics and I'm pretty sure you can write some basic game logic with whatever we have done already but there are a couple of functions which the engine provides us which is going to make our job a lot easier the first one and one of the most commonly used ones which I would like to talk about is Ray casting now if you guys are familiar with other engines you guys would know what a raycast is but in Unreal Engine you call it a line dress so if I right click and call line Trace so you see you get a bunch of options the one you'll use most of the time is line Trace by Channel multi is basically used when you have penetration and stuff when you are detecting multiple hits in the same line I'll I'll tell you guys what's line Trace first so line Trace is basically a function which lets us draw a line from a given starting point to a given ending point and in between these two points if you are actually hitting anything you are going to get it as a hit result so I can get access to the hit location and in case you want to see the line itself you can change this draw debug type enum and make this for duration and if you guys wondered this is an enumeration that's the reason we are getting these options so none for one frame for duration and persistent are the enumerators so if we select for duration we are going to get the line for some time persistent means the line is going to be shown to us forever until you close the game of course so let's actually do something with this so let's actually set up an input event let's say when we click our left Mouse button so we can type in left Mouse now I'm just setting this up brood Force because I don't really know what exactly we are going to set up once we actually get to the examples we'll do that now for the start location you can choose the camera's location of the player because this is where you would be seeing stuff so you can select the camera's location for example so if I go ahead and get the start location the way you do that is there are a couple of ways you could do this and you could do get location so you can get get World location and you could use this as a starting point and the way you would go forward towards the center of your screen is going to be first of all by getting the forward vector so you can get the forward Vector of this camera and multiply this by a certain value Again by a float uh we'll do that add that to the starting location so starting location plus forward Vector into a certain number of a certain number that is going to be your end and we can go ahead and change this to a float and we can do let's say 50 000. I mean the number is arbitrary obviously unreal uses centimeters remember that so anything that you type in will be in centimeters so 50 000 centimeters is going to be divided by 100 so it's going to be like 500 meters now if I go ahead and Press Play If I press my left Mouse button you see you get a line drawn over there so if I press f8 you see I can actually see the line which was drawn so the red thing which you see that is the line which was drawn and as you can see uh where where it hit the surface it actually registered a hit and in order to show that there is one more thing which you can do actually Oh and about the other options Trace channel is something we'll talk about later but basically you can do stuff like ignoring several uh types of objects so let's say you had a shooter game and let's say you wanted to like ignore teammates you could use it for that but you'd use tags for that as well but there are several other use cases camera is another thing depending on what type of objects you want to you want the hit to detect you would do that and actually if you were to notice if I select my mesh and if I scroll down to the Collision part so I'll just type in Collision instead of searching for it like this so Collision you have to notice it says character mesh for the preset and over here if you see there is actually visibility and camera so what you can do is you can actually make it block certain things so now let's say I wanted this line Trace which is using visibility right now to block it I would have to change this to custom and make this one block visibility so then I would be able to I would be able to make this line block it stuff like that which you could do now obviously I'll change it back to character mesh we didn't do anything but still so over here change it back to character mesh and let's say you wanted to ignore the camera Channel you could do that as well now let's say you wanted to just Mark the place where you actually hit so now we have access to the hit location so there is a function called Draw debug sphere you can actually draw many other shapes but sphere is the one which you'll use most often and the center is obviously the place where you hit it so out hit location and radius 100 maybe we can have 10 seconds for the duration and thickness let's just say two units line color let's set that to maybe something like a greenish yellow or something now if I go ahead and Press Play If I left click you see it's drawing a sphere where it actually hit it and you could change some of the properties let's say you wanted a more details here I don't know why you would want that though and maybe reduce the radius of the sphere you could do that as well so as you can see we are registering a hit over there so that's what it's basically showing us so this is how you do a line Trace basically you draw a line from one end to the other and you can detect hits obviously for shooting a weapon and stuff like that you use it now there is another way you can actually determine the start and end location now whatever logic you have here is fine if you only have one camera but what if you had a first person view and a third person view for example let's say you had two cameras you cannot check which camera you are using and stuff that would make the logic complicated so the way you do it is you would use a function called get player camera manager now this is going to get the current camera which you're using and it's going to be an actor so we can just type in get actor location and this is going to be your camera's location so let's say you switch between cameras this is going to work universally regardless of which camera you're using however since in this logic we are using this camera's reference let's say we had another camera this logic is not going to work it is going to work with respect to this camera so instead of this I can go ahead and replace it and we can get the actor for Vector again get actor forward vector and we can replace this by this and we can go ahead and delete it and the rest of the logic Remains the Same obviously and now if I were to press play you would see that the logic does not work okay we didn't plug it in so the actor location is going to be the start of course not zero press play and the logic works exactly the same one more thing you'll notice is that the line Trace is going exactly to the center of our screen if you were to notice that's one more thing the reason it's happening like that is because we are going from the center of our Viewpoint and going exactly forward to the view so that's the reason it's actually going right at the center of the screen and if you add a Crosshair in game it would land right at the center so this was recasting there are many other options as well such as hit actor so you can cast it so let's say we cast it to pick up for example so we can check if we actually hit the pickup so if we actually did hit a pickup what we can do in fact is we can go ahead and run some logic let's say we destroy it so I'm just showing you guys one more example to make things clear so if I press play so that's not the pickup so nothing happened but if I hit a pickup as you can see we are destroying it so something like a gun all this is fine but we do not have any sort of a user interface now apart from the lighting needs to be rebuilt then you can actually delete that by typing in disable all screen messages so oops I didn't type that so disable all screen messages so you can go ahead and type that and it's going to remove that so there's nothing much really we don't even have a simple health bar so we can go ahead and add a couple of components on screen so in order to create widgets on the screen if you want user interfaces the way you do that is using widget blueprints so let's get to that inside your content folder I want you guys to create a new folder and we can call this one UI and inside this we can call this one for example HUD to denote heads up display now open it up and inside this folder right click and create a widget blueprint by heading into user interface now you could do it through the blueprint class menu as well type in widget blueprint you should you should find a widget blueprint somewhere over here so user widget is the one actually so go ahead and select that and we can call this one HUD BP underscore HUD generally I also like to add underscore WB to represent widget blueprint but if we are going to have separate folders for each one it's not really required open it up and you will get a blank canvas and you'll have two tabs over here on the top you have a designer and a graph as well so what we'll be using most of the time is the designer and to add the logic for it we are going to use the graph if you guys have used the QT framework in C plus plus the functions and stuff work pretty similarly over here but since this is going to be in Blueprint it's going to be much much easier to comprehend now the most basic type of widget that you can add is a canvas panel so add in a canvas panel before this actually used to come by default without you having to actually add it now you won't worry about most of the settings actually the only thing that you'll worry about is custom or fill screen actually these are the only two which you'll most probably use custom is basically used if you have stuff like drop down and you're making like a child widget for something and I will show you guys examples for that when we go to the higher level part so for now we'll use fill screen so this is going to take up the entire screen now in order to actually create this now there is nothing but we we can just create it nonetheless generally it's not advisable to create it in in the character widgets usually would be created in something a little more persistent such as a player controller so we have one setup already so we make sure you set that in the game mode open it up and we could do it on begin play add in a custom event and this is where you actually use custom events so you could use a function no harm with that but let's use custom events this is what you would use them for so we are going to be calling this one for example create HUD and we can call that so create HUD over here we can go ahead and type in create widget we'll get to select it so BP HUD does what we want to create and we can promote this to a variable and call this one HUD or you could call it hardref if you really want to be that specific now we have a reference to the HUD however we still haven't actually created it we have just internally stored it but if you want to show it on the screen type in add to viewport so now this should be added to your screen however there is there is another thing which you could do actually there is another option called add to player screen however this is not really used that much so this is usually used for split screen and stuff like that will not get into this so you'll use add to viewport most of the times all right so now under your HUD for the health bar obviously we need a progress bar so type in progress bar and unreal has everything built in for us so let's add it at the bottom left hand side of the screen that's the reason I chose the canvas panel so that we can easily uh just drag stuff in with other types of widget it's usually like a layout which you create so it's going to be harder for you to just move things around all right so let's add the progress bar and on the right hand side under the details panel we can rename it we can call this one health bar and we can set all sorts of parameters maybe we can make this one 350 by 45 and over here you'll see another tab called anchors now anchor is basically telling you the position with respect to it basically for example let's say set it to bottom left in this case bottom left is ideal so this is going to be your 0 comma 0 and with respect to that your Y and your other values are going to be set so when I say the anchor is at the bottom left and my position is 88 what I mean is I have placed this progress bar 88 units to the right of this anchor and Y is basically your vertical Direction so minus 120 is 120 units upwards basically and size X and size y will remain the same alignment is basically telling you what to take as this the reference point so if I make this 0.5 you see it's going to Center off so it's the distance between this and the center now same with the Y so if I type in 0.5 it will move a little bit down or up actually because it was over here so now the point shifted over there so it moved a bit up and if you want to Center something exactly at the center of the screen so for example across here so you would set the anchor to be this the center one and over here you will change the alignment to 0.5 and set the position to 0 and 0. now this is going to be perfectly centered regardless of your resolution now another reason to actually use this so let me just actually move this back so zero zero another reason to use anchors is for different resolutions let's say you had an 800 by 600 screen let's say somebody is playing with that and you had a progress bar over here let's say you left it at the default anchor let's say you didn't actually modify the anchors this widget is actually going to go outside the player screen however if you change the anchor to the bottom right now this widget is minus 461 and minus 137 relative to the bottom right corner so then it will always be inside the screen so that's another reason to use anchor so I'll go ahead and undo all of that so that should be good now if I go ahead and create this so in apply controller on begin play we are actually creating it now if I go ahead and press play you see we see our progress bar and since we have our anchor over here you see it always stays at the same relative position on the screen the next thing that you obviously want to do is actually bring in the values of Health from the character to the actual widget so it's actually pretty simple to do that so let's go step by step there are quite a few ways you in which you can do it so if you would have created the widget on the character it would have been simple to just pass in the health value to the widget however since we have done it in the player control there is an extra step but nothing to be worried about so now let's create an event in the player controller so that we can actually interact with the widget so we can call this one update health for example so type in custom event and call this one update help and for the new value we can go ahead and add in an input and it's going to be of type float obviously and we'll call this one new health now over here in the progress bar we can go ahead and create another event or we could even directly adjust it here so we could get the HUD and over here we could type in first of all let's check if our progress bar is a variable make sure it's set to is variable otherwise you won't be able to access it so if once that is variable get the health bar and again this is where your blue print menu is going to help you a lot now you want to set the percentage so type in set percent you will go ahead and get this node now in case you guys don't know this percent is going to be a value between 0 and 1 and our health is a value between 0 and 100 so let's just divide this by 100. so do that or you could make your health variables store 0 to 1 that works too all right so you can do that or you could have a custom event inside your BP HUD that works too so let's head back into a character now and what we can do is we can actually do something so let's say when we actually pick something up let's say we reduce our health for example so we can head into our interaction so when we pick it up let's say we reduce our health by 10 maybe now if it is valid we destroy it and we invalidate the nearby pickup and let's reduce our health by 10. so create a health variable first of all now health is a variable which is dependent on which character you are in so that's why we are creating it in the character make this private over here make this variable private and we can go ahead and set the health to be equal to whoops we can go ahead and set the health to be equal to health minus 10. and we don't want it to actually go below zero so we can go ahead and clamp the value so we can call this one clamp so clamp float minimum is 0 maximum is 100 obviously so I can go ahead and set it now if our health is zero so if our health is less than or equal to 0 if you don't clamp it you can check for less than or equal to so let's do that actually so if our health is less than or equal to 0 whoops less than or equal to zero we can go ahead and just kill our player so instead of killing it let's just exit the game instead so we can call we can execute a console command so type in execute console command and this one will simply type in exit it's going to exit the game even quit works now this is something which you might need multiple times so what we can do instead of this is we can actually make a set Health function because we want to exit the game even if our health is reduced for some other reason so here in this case we picked it up so our health reduced but we want to be able to reuse this so right click collapse the store function and call this one set health now let's say you don't want this to be able to call it on the other blueprints so let's say you want to only be able to call it in this BP character you can make it a macro instead and obviously we need the health value so grab in health and head back into your event graph pick up over here we can go ahead and pass in the health so this is going to handle everything for us and let's actually make this a larger value let's say 40. so on our third pickup in theory we should exit our game and if it is not less than or equal to zero uh we can go ahead and update the progress bar first things first and remember we had our play controller reference now we can go ahead and use that so regardless of what we do we want to update the helper I mean we'll exit over here so we don't need to update it so we can type in update health and new health is going to be our health variable now some people might show you how to do this using a binding so you can actually go into your progress bar and you can type in bind and create a binding however this is very very inefficient and it is going to run on tick so actually don't really bother using that do it the way I am showing you guys this is the proper way to do it however there is a good there is a small chance that it might miss it might not update but that's nothing to worry about it's going to be like one in a million maybe so it honestly doesn't matter so once that said we should be good to go and make sure by default your health is set to 100 and once just update the progress bar once you set the player controller reference because we are not actually setting the health by default uh in the heart you could set it however what if a player disconnected from a match and is coming back so you don't want it to be 100 because you'll be creating the widget once again right so set it once you get the player controller so in our initialize function once we get the play controller reference we can go ahead and set that and we'll clear the timer at the last order doesn't matter here since this function is already being executed the order honestly doesn't matter but we can do it like this now if I go ahead and press play you'd see our health is set to 100 and if I go closer okay let me just speed that up a bit so if I interact with this nothing happens but if I go ahead and interact with this our health reduces my health reduced and now we exit the game the third time we do that so this is basically how you work with widgets so if you want to update it you would just use one of the functions which are there in one of these widgets and what if you wanted text obviously you just search accordingly type in text and you should be able to find text so let's actually type in the actual health value so over here what we can do is we can just give 100 by default or we could leave it a text block and set it normally so over here get back into your play controller and in your update Health function we can go ahead and grab our text I don't know if it's set variable so it is not set to be variable so we can type this one Health text now you should be able to access health text from the player controller once you set that to its variable so grab in our HUD Health text so get your health text and over here we can go ahead and set the text to be equal to the health value itself now there is a special node which you'll use a lot called format text so this is very simple actually use curly braces and type in health it will make a pin for you whatever you type in curly braces will be a pin and the first one let's just put a plus over there because it's usually usually health is denoted with a plus before so your current so your text is basically going to be plus along with a health appended with your health so let me just show that actually so grab in your new health you can grab in any sort of pin by the way now if I go ahead and press play you see it says plus hundred because it took plus and the actual health value itself now I apologize I do realize that the screen is a little bit black and white so now it should be fine so you have plus and you have your health similarly you could you could do something like maybe hyphens so it's just going to append it as is you can go ahead and mess around with it a little bit let's say you wanted another parameter you could put curly braces once again and type this one maybe something and over here you can go ahead and make make a little a little string or a text so let's just say hi for example so it's going to print plus 100 space High if I put a hyphen here it's going to take it as is so plus 100 hyphen height so stuff like that which you can do using this format text node and it's really handy in my opinion so now if I go ahead and press play we have our health bar now we could do a little more of Designing so head back into your HUD and you can actually wrap this around with a border if you right click and type in wrap with you can wrap it with a border and actually have a border color and stuff so I can select this and make sure you set your padding to whatever you want padding is basically the spacing you give so if I change the padding in this case so if I change this to 10 you'd see that you're giving more space on all directions I'll just set it to something like 5 Maybe and I'll make this one black so not content color that's going to be a progress Parts color instead go to brush color and change that to something dark Maybe and over here as well let's just change the fill color to Green because that's more appropriate for your health widget so change that to something a bit more greener now if I go ahead and press play you'll be able to see we get the appropriate color and our health bar updates as normal under text updates as well so that's basically it so that's the basics of widget blueprints we will talk a lot more in depth about this as we move further but now you guys should have a pretty basic idea on how to create stuff now the palette is something which I want you guys to explore so check boxes a checkbox and you won't use most of these most often you'll use text slider button image border and images as it says it's an image and one more which you might use if you want something like a username password menu is a text box so you can grab in a text box and this will allow the user to enter any text inside stuff like that now I want to cover widgets in a little more detail so let's actually create another level called main menu and let's accelerate transition to this level using a widget so like you click the play button in your widget and then you would enter this level let's do that now first we can go ahead and create our map so heading to content maps right click create a new level and we can call this one main menu open it up or rather let's just be a little more descriptive call this one main menu level open it up and this should be blank and that's really none of our concern head into UI create a new folder and we'll call this one main menu over here go to user interface widget blueprint and go ahead and select user widget now we can start making our main menu so we can call this one BP underscore main menu open the widget and we can just have a canvas panel again add in a button we can Center it first of all so make it 0.5 and 0.5 and set the positions to be zero we can increase the size a little bit maybe we could make that something like 350 by 100 Maybe maybe 450 again size is your personal preference and we can make the background black so background color change that to something darker maybe something like a dark gray we can go in and add in some text and we can call this one play now you can change the font as well by the way under font uh you can actually import your own custom fonts will not get into that but it's actually pretty simple to do it we'll try to get into that in the later part of the course but I'm not really sure if I will so maybe change that to regular increase the font size to 35 let's say this should be good now head into your event graph and let's call this one play button so select the button and then under the details panel rename that now if you select the play button variable you should get a bunch of events including on clicked on pressed on release all of these are as they stand obviously maybe if you have a sound effect or something you could play it on on hovered or there's another way actually where you can play sound effect when you hover your mouse so over here if I just type in Hover I should be able to find Howard sound let's just play uh so maybe let's just play this I mean it doesn't make any sense but anyways and I think there is a clicked sound or a pla press sound I guess it's called so we can play press sound so click on button and what we can do is on click we can go ahead and open our map so we can type in open level and we can do by object reference so over here let's just select our level beginner course level and that should be good now if I go ahead and press play as you see nothing happens because we haven't created the widget yet now since this is a widget which is the only thing in this level you could simply go ahead and create the widget here on begin play so create widget create widget BP main menu add to viewport we don't really need to store it because we are not actually calling any functions so if I press play you can see it and when we hover over it you see you get the sound effect however one thing you would notice is if you actually have your focus on the window you can't see a mouse cursor so the way you do that is first of all get your player controller so type in get player controller this is a static function so in inside any actor basically you can get your player controller reference and from here there's actually a variable called set show mouse cursor so show mouse cursor is the variable set that to true and another thing which you can do actually is change the input mode to UI only so that it only focuses on this widget there is another option called game and UI only we'll use that set input mode to game and UI only grab in the player controller reference and that should be good so we can just reroute it double click on the PIN to reroute it and now if I go ahead and press play you see even when I focus it I can still see my mouse cursor now if I press play you see we transition to the level now we obviously spawned at 0 comma zero comma zero so that's the reason that happened now if you want to fix that you can go ahead and add in a player start where your default player will spawn so now if I head back into the main menu play it if I head in we will spawn where our player start was but one thing you'll notice is uh we still haven't actually got rid of the mouse focusing part so your mouse isn't behaving like how it should so what we can do is on begin play now we are in a main menu level head into our beginner course level generally you do it on your player controller so BP black controller and what you can do is you can set input mode game only and we can get a reference to self and you can also set show mouse cursor to false so set show mouse cursor make that false now if I go ahead and press play okay I mean that wasn't what I intended now head back into your main menu go ahead and press play now you see your mouse is going to behave normally so that's basically how you deal with it now you can do your normal gameplay stuff so that's how you would actually create you would actually interact with your actual levels and stuff your transition levels and stuff using widget blueprints so head back into UI main menu and if we take a look at our code it's really simple and a widget as well it's really simple so that's about it now let's say we wanted to have more than one option and let's say we wanted to layer them vertically so if you want to add multiple rows you can go ahead and use something known as a vertical box so if I right click on this type in wrap width and use a vertical box you can go ahead and get this now the vertical box will automatically use the same anchor as we used for the child but nonetheless just something which you can change the size y to something big Maybe and press Ctrl D to duplicate this button now over here I can type in exit let's say and again on clicked we can change that so play button one is not appropriate we'll change that to exit button so exit button and on clicked we can go ahead and execute console command and we can type in exit so that should be good to go and you'll notice one thing it's just taking up a fixed amount of space and it's not actually filling it properly so if you want to do that you can select both of these and select fill now let's say you wanted your play button to occupy more amount of space than exit so you can increase this uh what a text box which is available to you so if I hit 2 and the exit button has one on this option basically they are occupying space in the ratio two is to one that's basically what it means so you don't want your place to exit obviously so you'd make the play button bigger so this is how you do it now if I press play now the same logic is copied over the reason why the sound is playing even for the exit button is because we copied over the code so that's why so all the sound effects as well is copied so as you can see press sound and hover sound are actually the same in both of these now if I press play I press exit we are going to quit the game if I press play We load into this level so that's pretty cool so that's about it for this part foreign talking about another feature which blueprint offers that is blueprint function libraries now let's say you wanted to have some functions which might be used in multiple places but are not relative to a certain object so in that case you would use a blueprint function Library so let me actually show you guys an example so head into blueprints and or maybe we could create another folder let's call this one function libraries open it up and over here right click head into Blueprints and select blueprint function Library and we can call this one my or our blueprint function Library now inside here you would notice that we actually have functions options to write functions so for example let's say we have something generic so for example let's say uh we have a vector and let's say we wanted to normalize it now obviously there is a normalized function already but I'm just taking an example now normalizing a vector is a general operation it's not relative to any object so we can type in normalize and for the input obviously we are going to take in a vector so take in a vector and we can type this one in maybe uh now once we have the vector we are going to first of all get the magnitude of this Vector the way you get magnitude of a vector in Blueprint is by typing in Vector length so get Vector length now this is this is the magnitude of the vector so we can divide this vector by the magnitude so that is going to normalize the vector for us and once we actually do that we can go ahead and return it so this is going to be the return value and obviously we'll make it a pure function now let's just call this one normalize underscore hours because I I think there is another function called normalize so just so that it's understandable for us now head back into any one of your blueprints let's say our level blueprint and over here if we just type in normalize so we already had a normalized function but I just took the example underscore RS you see we actually get our function and this is not relative to any object so you can call this pretty much Everywhere You Wish so this is basically our blueprint function Library you just go on creating functions so once that's all settled now what if you wanted to use some code or some assets created by somebody else there is actually a huge Marketplace called the unreal Marketplace and you can access it through the epic games launcher so if I head into my epic games launcher head into Marketplace under the Unreal Engine section you would see that you get a massive library of assets and there are a bunch of free ones as well like I I really mean a lot of free assets so what if you wanted to use them so that is where using plugins and other content packs comes in handy so how you do it is really simple actually so for example I know one which is very handy it's called low entry I believe oops low entry so I actually have it in my library so so it's by this publisher actually so low entry low entry standard Library this is the one which I'm using this is really useful so once you search it up and you can look it up in the marketplace and there are many Forums on Reddit and stuff talking about which plugins are good and stuff so you can go ahead and install it according to your needs so let's say I wanted some weapon models for prototyping you could just type in weapon and you're going to get weapon packs the way you install it is by clicking on this install to engine button I've already done that so that's why it shows that I can't now over here in my plugins panel now I should be able to access it over here under installed or if you just search it up you would be able to find it and you can enable it so low entry extended standard library and I need to restart the editor so let me go ahead and do that now that it's done I can go ahead and use the content in the plugin now how do I know what content is there there will actually be a documentation and source code and stuff available so you could just look it up so there will be a place where the documentation is given so you have a preview over here then you also have access to the source code and a bunch of stuff you could also take a look at this over here so maybe let's say we wanted to use uh some function here so for example I type in is debug build let's say I wanted to see if I am currently in a debug build so I can type in is debug build whoops debug build and as you can see I can use the function now this was a plugin which has to be installed to the engine however we will also look at other types of plugins such as let's say I type in weapon for example I needed a weapon pack so I actually have some in the library you could find a free one so you can head under free and you can look for it but again now in my library I actually have some weapon packs if I want to install those it's actually really simple so FPS weapons bundle this is one thing which I have so I can go ahead and add this to a project and it does say none of my projects are compatible but plugins like these actually it doesn't really matter if you are using a later version then what is supported as long as you're using a later version than that it should be totally good to go so click on show all projects and you can go ahead and select this and you can change the version to the latest available one and you can go ahead and add it now just another thing in case you don't have a plugin of this sort so the one which we saw last time so let's search for low entry once again so let's say we have a plugin of this sort which you install to the engine but you actually don't have the appropriate version so the way would actually go about upgrading your version is actually really simple people haven't made any tutorials on this I don't see any Forum or anything talking about that either so basically you just come into your Unreal Engine installation directory so I go to program files Unreal Engine this is where I have it and over here under engine plugins and the marketplace ones will be in the marketplace and for example I go to low entry extended standard Library I can right click on this U plugin file and I can actually open it with any text editor or I can open it with something like vs code so I'll open it with Visual Studio inside the U plugin file you should see something a little like this so you don't have to worry about any of these things the only thing is the engine version let's say it was there for 4.27 and you are using 5 and if you want to make it compatible and let's say you're getting build errors you could just go ahead and change 4.27 to 5.0.0 so let's say it was 4.27.0 by default so you can go ahead and change it to 5.0.0 whoops y dot or dot O So stuff like that all right so that's about it there isn't really that much depth to plugins I mean I will talk about creating plugins and stuff integrating thirdparty libraries a bit later on in the advanced part of this course but now let's go ahead and actually talk about a recently release tool and which is quite handy in my opinion and those are the modeling tools first of all in your plugin section make sure your plugin is enabled so make sure modeling tools editor mode plugin is enabled and if you don't want to separately drag your model in the level and edit it then you can press this as well ah now if you check your content browser uh make sure you have some sort of a 3D model make sure you have some sort of a static mesh so you can import that from your 3D software so I just got one in from the engine content so what I did was basically actually I'll just go ahead and delete that and redo it so delete that and delete this folder as well save everything now I just search for SM underscore usually it's a convention to name it SM underscore for static mesh under content I just went ahead and created a new folder so new folder and I called it models open it up and just paste it in uh just using the one from the engine content now you can drag it in the level and start editing it by heading into this tab right here and heading into modeling so we have a bunch of options the first few are for creating objects but some of the useful ones are for example moving the pivot so let's say you didn't want this to rotate along the center you can go ahead and type pivot and you can move this point over here now if I rotate it it's going to rotate along this point and these changes are actually applied to this so even if I just drag in another ball these changes will be applied to that so just be careful while using them of course you can undo them at any point so just save that and sculpt is basically to deform the shape so something like this and again you can use shift the same principle works over here as well as we did with the landscape editing so stuff like that then descalp does a similar thing just works a little bit differently so I can just drag it like this I'm not sure what I did there but yeah so I'm not really here to talk about the tools in detail but just to give you an overview of how to actually use it so you could experiment around with all of these so if you type in accept so now we have the ship obviously this is it just messed up with the UV map and the materials and stuff but anyways that was not our point now a couple of useful things first of all creating shapes so if I just type in stair over here and if I head into this and I can actually make it a curved staircase I can actually increase the number of stairs I can decrease the step height so I can increase the curve angle for example then I can decrease the step height so I can make it something like 10 maybe place that and type in complete now if I go ahead and press play you would be able to see that I can actually use my stairs so that works well so stuff like that and now shapes are pretty obvious obviously just create a box do stuff with that and now you might be wondering where these are stored over here just check uh what is selected under this under the new asset location if it is selected to Global in your content folder folder there should be a underscore generated folder in my case it was set to World relative so wherever you have your map over here this you should see a underscore generated folder and if you open it up you should be able to see your static meshes so for example we have this stair which we just created and we can drag this in so this is going to come in really really handy for many people in my opinion now not only that it provides us with several other cool features I'll just showcase one of them actually so if you head into your modeling tools once again so I'll just close it and open it up again so I'll open up the modeling tools and if I type in poly extrude you can actually draw a shape so if I just click somewhere drag a point do something like this and if I join them now I would be able to create something like this so let's say I wanted to create a castle wall or something you could do that and the good part about this is this is UV map by default you don't have to actually you remap it the UVS are pretty good so you can directly go ahead and apply a texture and it is going to look decent generally if you create a weird shape like this in a 3D modeling software you separately have to go through the effort of UV mapping it so that the textures don't look distorted but in this case you are good to go so that's about it for the modeling tools so you can mess around with those these are really you know specific to what you're doing so according to what you would need you would use the appropriate tools but it is there now even over here you can change the Pivot Point let's say for example so I'll just show you guys once again so modeling if I select pivot and if I move this over and press accept you would see that the pivot point mode over there so that's about it so let's move on to the next part so what I'm going to be talking about next is kind of the basics of what we did till now so basically we worked with these models over here basically these are called Static meshes so any and all 3D models which you get in the engine without any sort of animations or anything those will generally be static meshes uh any mesh with some sort of Animation is going to be a skeletal mesh basically so stuff like characters gun models and those are going to be your skeletal meshes anything which simulate physics or which does not have animations so for example the staircase may be a weapon model in a pickup blueprint stuff like that are going to be static meshes so they are recognized by a light blue color in the content browser so if I head into models you see it has a light blue color coding and this indicates that it's a static mesh now we will dive into skeletal meshes a little more in depth later on but for now I'll just head into static meshes there are a couple of things which I would like to cover first one is enabling nanite now if I head into wireframe mode so now I can actually see all of the vertices in space foreign now say I have many of the Spheres and in this case I have more than six thousand so six thousand four hundred and eighty so your first question over here is how's the performance still this great that is thanks to nanite so if you right click on your model and enable nanite over here if you right click and click on enable you will enable nanite now if I go ahead and disable this you would see that the performance dips immediately so that's one thing about nanite so as you can see it's really not playable at this point now if I mean obviously this is highly unrealistic and moreover it will depend more on your computer as well so if I go ahead and enable nanite now and if I press play as you can see even with so many spheres right in front of me it's absolutely not affecting performance now we are not here to talk about the actual technology involved in nanite so that's the reason I'm not telling anything else but this is basically it currently in 5.0.3 there are a few limitations for example let's say I wanted to use this on a tree you probably cannot because trees contain leaves and leaves used masked materials and those are not yet supported on nanite and it but they will be supported in 5.1 so very very soon you would be able to use them so that's about it there are few material features which you can't use and we will talk about materials so stuff like dithering and stuff you will have to just disable those notes if you want to use nanite but for most objects or stuff like walls or maybe if you have an insane level something like this nanite is going to come in handy so that's about nanite by now one thing that we would have probably noticed is that any and all objects in the scene actually have some sort of a material on them so for example this has some neon blue texture on it and it seems to be glowing and this box right here has some sort of checkerboard and same with the ground so what's up with that so basically those are materials and that's what gives the color and all the other roughness related properties of a given surface now let's actually go about seeing how to create a material and apply it on objects so let's just use a cube for example in order to demonstrate using materials so let me just grab in a cube and I'll just place it in the scene now this has a material basic shape material you can actually explore this by clicking on this search icon over here so we'll actually go to the directory where the material is stored but in our case let's create a new folder called materials and let's go ahead and open it up right click and create a new material or you can head into materials and create a new material here now the most important ones are just materials and material instances the rest are just stuff which you might need in specific circumstances so we'll take a look at material and let's call this one our material now applying a material on a surface is actually really simple now we aren't going to be dealing with multiple materials on a single object in this part of the course we will try to deal with it later on but for now we won't be doing anything so by default you get this Checker material so I'll just drag this in and you can in order to apply it you just drag it basically on the surface that's how you do it or if you want to apply it to a static mesh in general so let's say I wanted all of the uh okay whatever this object is so let's say I wanted all of this object to have our material so what I do is I head into the static mesh and over here I'm going to select our material so let me go back so all content materials are material you can select that and you can click on this Arrow icon which will use our material so now it's actually using our material so we haven't seen any change because we don't have anything set up in the material but the way you actually start working with this is by using these nodes so this pin right here is as the name suggests the base color now how do you define a base color so the most basic node over here is going to be a constant so whoops I press C on the keyboard I'm supposed to press 1 on the keyboard and left click and you see you get this node here which allows you to enter value now generally you would enter a value between 0 and 1 but in some cases you would enter higher and lower values so in this case if I just plug this in the base color and you can see it's compatible so you would see that our material is fully black now it's just a fully black material what if I increase this a bit now save that again as you can see it became a lighter shade of gray so one is going to be white so this is basically a gradient 0 is black and one is white what if you wanted to give a color so you'd hold three on your keyboard and left click then you'd get something known as a constant three Vector this is basically our r g and B value so red green and blue so you can go ahead if you wanted red you could do 100 and as you can see you get a red color material and it's applied to all the objects which are using our material so that's about it for base color now if you want to bring in any textures I recommend this website called cc0 textures so open it up now it's renamed to ambient CG keep forgetting about that so if you just head in and you can just grab in any texture so just I'll just grab in the lowest resolution one so I can open it up in my folder over there and over here I'll just drag it into images for now I just have it set up like this so I'm just going to extract it and over here you see you get a bunch of textures if you want to import it in the engine it's really simple actually to import any asset B textures models or whatever so we'll create a new folder and we'll import it so textures open it up and if I go ahead and drag this for example so I can just select all of these and I can go ahead and drag this in my content browser and we can go ahead and save it now if I want to apply this texture to this material now first of all we'll see which one is the base color sometimes these textures are labeled as Albedo but Albedo is basically a base color without any sort of uh Shadow related information that's basically what it means without any other sort of detailing it's just the raw color so if I drag this in the base color I can do that now you could do this as well totally fine so this is how you would bring in a texture now if I go ahead and look into my level you see we have this wood texture on our little wall here now what if I wanted to tile this texture a little better now let's say I wanted to make this bigger or smaller you'd use something known as a texture coordinate so you type in text chord and you're gonna see texture coordinate plug that into the UVs and now let's say I press 0.1 your texture will now be scaled 10 times you and we are basically like your X and Y to be very vague now we zoomed in way too much so let's let's make two now so now you see it's going to be more tiled so now if you would see you would have a more tiled material so if I make this three for example and if I go ahead and save this you would see that it'll be even more tiled so I can make this 3.5 I can increase the value and it's going to be more tiled so I can click apply save and I should be able to see there are more number of Tricks now I'll I'll just set this to one once again and save that and as you can see it's applied to our level now this may be fine but what if you wanted more details let's say you wanted to make this very glossy so in that case you can use the roughness node now the roughness is basically a zero to one value so you can again use a constant if you want so 0 is going to be fully reflective now you could use the specular Channel as well but most of the times you will only use roughness it's very rare that you'll actually mess with the specular channel so now if I go ahead and apply this you'd see that it's very glossy and if that's not really that clear drag in a point light just move this and as you can see it's reflecting everything over there you see the little point over there so that's showing roughness 0 now if I change this to 1 for example and if I hit save you'd see that it's not reflecting the light at all so that's the use of the roughness Channel now obviously this is some sort of a wood floor texture so obviously it will be depending on the grains of what's there over there so how you would set it up is by using a roughness map now generally in in websites such as cc0 or ambient CG now as it's called you would get something known as a roughness map basically the brighter parts of the image are where the light is reflected more the darker parts of the image are where light is not reflected so let's say there is a fully black area here so that's where all the light is going to be reflected so I might have told it the other way around basically the more bright the color the more the roughness now if I drag this in use this in the roughness Channel as you can see this gives us a little more definition now as you can see at the borders over there you can clearly see that the roughness map is doing something so this is about roughness similarly normal is basically uh your depth so as you can see this texture although it has a bit of roughness it looks completely flat now if I go ahead and add in the normal map so if I just snap this to the left and bring in my unreal editor on the right and if I go ahead and apply my normal map here and if I hit apply as you can see you would see a little bit of a depth over there now if you can't really see it that's probably because this is pretty subtle so you can use something known as a multiply basically it's just going to multiply the value of each pixel in this texture so multiply this you can use a constant or you can set the value over here itself in the multiply node so if I type in 100 let's say for example so now you would be able to see a little bit of the depth over there but since this sort of a texture isn't really containing much of depth so you won't really see it there are other ways to increase the depth of a normal map but that's not the point of this tutorial so basically normal map is for your depth if you are into PBR rendering you'll probably already know all this stuff ambient occlusion is basically like your depth in your crevices and stuff it's kind of hard to explain it there's actually a comment here so simulate the self shadowing that happens within crevices of a surface basically that's what ambient occlusion is so in stuff like trees and rocks ambient occlusion is something which would play a major role on this sort of a texture it's really not going to do much so this is about the basics of materials now obviously this is completely wrong because we only have a texture coordinate for that one texture so make sure you plug everything in so just plug everything in now if you go ahead and apply and save that now you'd be able to see that it's applied properly this had a subtle effect from the start itself so that's the reason you couldn't really see anything wrong with it so we created a basic material here now for any of these you can actually use your constants but most of the time except base color you won't be using constants you will be using textures now that's the very basics of materials there are a lot you can do let's say you wanted to make this thing glow so let me just remove all of this stuff let's say I just wanted a glowing neon green color so let me just get a constant pre vector so the same right click search menu exists in the material editor as well drag that in the base color and what you want to do is first you can grab in a constant and maybe let's say you have 10 this has to be a value greater than 1. so let's say I have 2 for example so now you'd see that it's completely glowing white in color now if you wanted it to Glow in this color itself what you do is you would actually get this and you would multiply this by 2. so you would multiply this by two now if I go ahead and press save you see it's glowing in sort of green color so this is basically called an emissive material because it emits light and it's pretty cool to look at by adjusting the value you multiplied with you adjust the intensity now one problem which you might have noticed here is every time we want to change a value so for example we want to make this less bright let's say 1.5 now every time we have to apply and save this what if we could dynamically change this that's where material instances come in is basically like your derived class in your C plus plus inheritance but to put that in short basically you create another asset known as a material instance which is subordinate to this material and you can edit all the parameters in it so I can right click on our material and create the material instance and let's just keep it as the engine has suggested now instead of applying our material we'll apply our material instance nothing has changed obviously however if I head into our material instance now I can change the parameters over here the first thing you might notice is there is nothing to change so how do you do that basically you would have to head in here right click and convert it to a parameter so any constant or any texture which you convert to a parameter will be a value which you can change so this is going to be called brightness let's say brightness and this one is going to be called color so right click convert to parameter and call this one color now apply and save it now if I open up my instance you would see that you get two parameters and now I can edit them so now if I press 2 you see the changes are live so zero works one two not point three so I can adjust my values just like this and I can change the color as well and it's updating dynamically so for the most part you will be using material instances for this purpose itself so these were the basics of materials now you could Tinker around a bit look into the documentation and create something yourself now we haven't talked too much about the other type of mesh that is the skeletal mesh so let's talk about that now now if I go ahead and press play actually you'd see that we have a character over here which is moving around now the animations aren't actually complete if you were to notice he's just sliding around he's not actually doing anything now how do you define the logic where you know if you are moving above a certain speed maybe let's say you start moving you want to play an animation how do you define that so that is where you use an animation blueprint and that is what I was searching at the start of this course when we actually did the character so head into your character over here one thing that you would notice is if I just head into mesh and if I just click on the search icon on the animation blueprint it actually takes us to a folder inside the engine directory where there is an animation blueprint which actually does something over here so this is how the animations are actually controlled and we'll create one from scratch we can reuse these animations no problem so head into your content folder not the engine so content and for now we can just head into our models folder and over here let's assume we had our character here so let's call that tutorial character because I guess that's what it was called tutorial TPP I guess I'll just open it up right click create under animation create an animation blueprint and select the skeleton now now I'm assuming you have a little bit of knowledge of what's a skeleton what are bones and stuff so at least that much would be required if you want to understand this basically know that each joint which you have each uh point which can hinge basically is going to be our bone so I am not clear about that if I head into the actual skeletal mesh so if I head into this one so I'm not sure what it's called and this one let's leave it at new and MBP so let's PPP I guess so this is the skeletal mesh now if I were to just click on this and if I head into the skeleton view you'd see for example this is going to be your index so if I rotate it you can see that we can actually control it index 2 is going to be the further part of the finger stuff like that I'm not actually applying these changes so that's totally okay and for example if I take the pelvis I can go ahead and rotate the entire thing because that's the root that's the reason it's happening if I take spine is going to rotate the back stuff like that let's say you wanted to rotate it a little something like this so you could make him Bend forward stuff like that so this is a skeletal mesh and output pause over here in the anim graph as soon as you open the animation blueprint this is what determines what pose here and by default it'll just take a tpose or whatever pose it was in when you imported the model so let's apply our animation blueprint to a character so head into your character select the mesh and for the animation blueprint let's select new nmbp or whatever that was called so new anim blueprint so as you can see we are stuck in a tpose right now and let's start applying animations now in order to add an animation the most basic way you could do it is you can simply drag in this animation and you can play it so this is going to be the idle animation and these are animations which the engine has provided so I haven't really done anything here so if you have your own character you would have your own animations but as you can see there is really no logic that you can Define over here so the way you do that is by first of all we can start by creating a state machine this is the most basic thing you can do in an anime blueprint so basically you can use your variables over here to determine Logic on how to change between animations let me show you with an example so we'll just leave it at New State machine for now or we can call this one uh walk run Maybe idle walk run let's say just name it appropriately and now if I compile I'll be in a t pose again now entry is where you would start so obviously if nothing's really happening you you'd want to idle so head into tutorial Idol if you were to notice it just outputs the animation because this is something like your return node basically head back into your ideal walk run State machine now if I compile as you would see it's playing behind the animation and if I press play actually this is going to work now we want another state so right click add State and this one is going to be called walk slash run now this is a shortcut way to do it like I'm not doing a separate Walk and Run face I will do a separate Walk and Run state after I do this so we want to be able to transition from idle to walk run so drag in an arrow and when we stop we actually want to be able to go back as well and I will show you what I mean by that now if I head into walk run and if I drag this animation you would see that he's not actually heading into walk run so what you can do is you can just set this to true for example and you would see that he will be in this walk run state so what this basically is is if this Boolean is true the character will be able to transition from this animation to this basically so how do you do that we can actually set uh set up some logic here so we can say is moving for example this is not how you do it I'm just showing you guys the basics so if he is moving we want to transition to the run face so idle walk run we have that now in the event graph we'll actually set up the logic to get is moving because remember we only have the variable but we are not actually setting the value so every time the animation updates so that's going to be every frame what we can do is we can try get Pawn owner basically that's going to be our character reference and we can cast it to our uh I don't know what it was called BP character I guess cast it to that don't do a cast on update actually you can actually uh do it on I guess it's called start uh there's an equivalent of begin play actually event blueprint begin play so on this node you can actually cast it and you can store a reference and use that don't cast to it every frame it's not efficient so you can promote that to a variable and call this one character reference so character reference and once we have that stored what we can do is we can use that if this is valid of course so convert to validated get if our character reference is valid uh what we'll do is we will get the speed so how you get the speed is by getting the velocity so velocity get velocity and we are going to get the vector length and if this Vector length is greater than zero it means we are moving so now if I compile you see his idle but now if I press play if I start moving you see the animation triggers but now he's not going back and that is where the transition comes in we have set up the logic to go from idle to walk run but the engine doesn't know when to come back so a very simple thing you can do is put this back and if he is not moving so you can type in an exclamation so if he is not moving then we can go ahead and transition back now if I press play as you can see it's working just fine now there are only two animations here but what if you wanted to blend between them what if you wanted a walk face let's say so the way you do it is by using a blend space so what a blend space is is basically transitioning between two animations and I'll just show that I'm not really going to talk too much in depth about animations and stuff but I I guess you you guys kind of get the basic idea let's say you had like a jumping animation so what you do is you'd have another Boolean for uh the jump State and in this state machine here you'd create a new state and call this one jumping and then you would transition from this and you would go back stuff like that that's basically how you do it uh now if we wanted to set up our blend space as I told you guys so head into your models TP tutorial TPP and let's just right click animation and let's create a blend space so now we can select a skeleton and we'll call this one walk run for example so walk run if you have a separate walking animation you can inject it in but for now we won't now in the access settings here this is what you will actually be using so your vertical axis is like your speed basically I mean it's a convention you can interchangeably use this but you can use the vertical axis as speed so basically you see the value of 0 to 100 so that's what it is so we can type in speed because we can use this name later on and for the horizontal axis we can call this One Direction and it's going to be from minus 180 to Plus 180. over here for Speed we can go 0 to whatever maximum speed by default at 600 so we'll go go with that and we don't have sideways animations otherwise on the left here you can place your sideways animations I'll just show you with these ones so obviously when your speed and direction is zero you would be idling and walk forward is going to be over here now if I hold down shift and if I walk through this so whoops so I might just leave that over there so at 0 and 0. and hold Ctrl actually hold Ctrl and if you notice you're transitioning between the animation so if I play as you see now if you're walking slowly so let's say I leave it at here so when my speed is 373 and my direction is whatever that is this is how the animation is going to play now if you want this to change a little bit you can actually uh increase or decrease the values over here and smoothing time is basically for your transition time so how long it will take to transition from one animation to the other generally I just leave it at zero I've had no issues honestly now in our animation blueprint instead of this we can use our walk around blend space all right you can connect this blend space to the output now we would see that you have to provide the direction and speed and doing that is actually pretty simple so head into your event graph and what you basically do is you grab your character reference over here and from this we can actually get the velocity so velocity get velocity and then from here we can get the vector length so basically the magnitude of the vector all right uh once we get that for the direction actually uh we have a node called calculate Direction which requires uh the velocity and I will tell you what to do next so we need direction and speed so we can promote these two variables so promote to variable we can call this one Direction and we can call this one speed and if the character is valid we can set the direction and speed over here in the direction for the velocity we can just directly grab in this pin over here and then what we can do is we can get after rotation now if I hit compile and if I go ahead and plug these in over here in my blend space layer then in my transition over here so walk run to idle instead of not moving what we can do is we can get the speed and if it is less than a certain value so if it is less than let's say about 10 so then we will enter this transition similarly if the speed is greater than 10 we'll enter this transition so if the speed is greater than 10 so then we can go ahead and transition into the walk run state so once we change that we should have our logic working so now if I go ahead and press play as you can see the walk run animations are working so that's about it now we have finished animating the character with some basic animation blueprints so that's all there is to it obviously there are many more things you can do with this animation blueprint of course you can you can have sprinting as well so if you would have Sprint uh you would you know have another state called Sprint and then you would plug it in according to what logic you want basically all you have to take care of is when your character can transition into States and make sure it's not going to be in two states at the same time that's about it and in the event graph uh anything that has to update so for example the speed of the character those can be done over here on blueprint update animation event so now I I think this is more than enough for blueprints and I I think with this much of blueprint knowledge you would be able to make an entire game assuming of course you would be ready to look into the documentation a bit and look into what the various functions do if you actually play around with whatever we did plus look at a few extra functions you can create an entire game and now for the more keen ones out of you here we are going to head into C plus plus now we'll be taking a deep dive into the more advanced features of the engine now not to worry for those people who don't know C plus plus I will also be brushing through some of the prerequisites that you need in C plus plus in order to get started honestly there's not much to do with the language most of it would just be function calls and stuff like that so anyways without any more further delay let's actually start learning C plus plus for unreal now I will be going through the basics now now let's just talk a little bit about the prerequisite knowledge of C plus plus which you'll need to actually understand the further part of the course I do still recommend you learn C plus plus separately but I will get you guys what you need for unreal because it's really not that important to know the language more so you need to know the features which we actually will make use of in unreal so I'll just create an empty console application here so it's just going to be a blank application with in the terminal now I won't even use this I'll just use an empty project template so I'll just search for empty in Visual Studio of course I mean we have it right here so just go click next and doesn't really matter I'll just look for a folder so I'm just going to create it there and click create so just leave all the settings at default none of these would matter for now now once I've created this I'll just go ahead and set up the basic stuff which you need for C plus plus so first of all you'll need a C plus plus file with a main function in it so just to uh just for my reference I'm going to name it main.cpp and we need a main function we'll not get into that now so int Main and we're just going to return 0. now I'll not get into this but the feature which first of all we'll need is to include code from other files now if you want to do that you would do hash include and inside angular brackets or inside double quotes depending on the situation you would include the actual header file so let's say I have a header file so I'll create one so go ahead and call this I don't know header.h let's just leave it as is and pragma once basically means uh this header file will only be included once so you won't have circular dependencies and stuff basically but anyways let's go ahead and type some code so in order to create variables that's the first thing you'll need apart from including so including this header file is simple so in double quotes you can put header dot h or you could even use angular brackets you know generally you would use that only for like standard C plus plus stuff but both of them will work so if you want to include header.h through this you might have to add it in the include paths so will not do that we will stick with this so let's say something standard C plus plus such as IO stream so I misspelled that IO stream I can go ahead and do this or if I have something standard C for example windows dot h so I can do that so for standard C plus plus libraries you would not use dot h for standard C1 so you'll use dot h so for example if you want cmath that's going to be without a dot h or it could do maths.h this is the cmat library so stuff like this for now we'll include adder so whoops so header dot h now this should work and later on I will be showing you guys how to include unreal headers that's not an issue so this main function I just like to go over basically our program is going to start from here but again as I told you guys when you're developing a game in unreal you'd really not worry about the main function that is handled in the engine so if you actually go through the engine Source you will find somewhere where you have int Main and there is there will be a wild rope while loop which actually runs the game so we'll not talk about that so let's write some code so first of all creating variables and before we do that one thing to note is that these are just text files honestly you can put the same code in a header and a c plus file it it really doesn't matter by putting dot hatch you just indicate that you want to include it as a header so that's the only reason both of these are technically just text files and can be opened with any text editor such as notepad notepad plus plus Visual Studio or Visual Studio code honestly doesn't matter so if you want to create a variable you can first of all head into CPP reference to know the basic types but if you want to create an integer for example you type in int space your variable name so for example we'll have my integer and if you type in equals you can assign any initial value to it you actually don't need to do that you can do this a bit later as well but you have to do it inside of a function or something so if I just put my integer equals 12 and make sure you end everything with a semicolon this is not going to work because even though you have this line here you are not executing this at all so remember I told you guys uh the program starts from the main function so over here if I put my integer equals 12 this is going to work why this works is because we have included header.net so it's as if it just copied over all of this content and pasted it in instead of this hash include now similarly you can have other types which we discussed so you can upload float X for example and you can have many other types so for example if you wanted a string you would put in STD string in unreal you use F string but again now we are getting an error that's simply because you have to include string so these are the few additional complexities which come with C plus plus so STD string my string equals let's say test string and you can go ahead and set the value again test string so not sure what we call that so okay my string is what we called it so my string equals and you can assign any value to it or you could even use the Constructor for this anyways this is how you create variables like this data type variable name equals value need not be defined initialized as soon as you create the variable you can do it later as well but it's always a good practice to do it now one more thing is that these variables can be printed out which you will not use in unreal you'll use the print string function to print it on the viewport but in in a console application you do something like STD C out and you would go ahead and print my string for example again we're not using this in unreal so that's the reason I'm not really covering this so the error is because we haven't included the header which contains this function so you can go ahead and include IO stream and if you go ahead and run a debugger here as you see we get 232 printed because that was our string again if we just delete this part you would see we will get test string and we can also print my integer like this so we get 12 so this is how we would go about printing stuff and what if you wanted to write your own function so what if you have like 10 lines of code and you wanted it to be in be called once so basically you can create a function with this syntax so if you want to create a function what you do is you put the return type let's say we create an addition function so our result is going to be an integer so the return type is in space your function name so in our case let's just descriptively name it add and in the bracket you would put the Val put the variables which you know it should take from outside so in order to add two numbers we will need two numbers first of all so we are going to pass two integers so the same way in which you created a variable and in the same way in which you know you would handle anything else you just to enter a comma into B so you separate arguments through a comma so what this basically means is when I call add so when I say add and I put my parentheses so this is how you call a function so if you want to execute add this is how you do it and you'll end it with the semicolon now inside the bracket you would put the values of A and B so in my case if I just put in 12 and 43 and I'll just take some some random numbers now the result of this is going to be returned here and in fact instead of you can set it inside the variable so if I do my integer equals add of 1342 comma 43 so whatever value will be returned here that will be set inside my integer now if you want to actually write the logic for this so it's simply to return a plus b something like this so this is how you do a function but honestly you don't need the syntax since we'll we like we actually have a simpler way to actually write functions we'll be using classes mostly so you shouldn't really bother too much about all this and with that being said let me just show you guys how to create a class so I'll do it in my header so for example I'll just do a class called student and I'll open up my curly braces just follow along with the syntax it's just a matter of getting used to it so under private so these were the private variables which we talked about in Blueprint as well so I can say we have a name and let's say we have his Mark so and marks something simple like that and under the public section we can have some methods so we can say STD string oops and we can call this one get name and instead of writing the definition over here like this so this is similar to what we did here it's just that it is inside the class now what we can do is we can only have the Declaration here like this so only the name is given here but we can actually have a defined outside this class itself so I can do this and I can go ahead and actually make another function so I can say in get marks so now you can also go ahead and Define this outside the class how you do that is you would use this syntax I'm not talking in depth about this mostly because there's a shortcut to do it which I will talk about so s3d string and what what was a class called student followed by two colons you do get name and you can write your function definition over here so you can go ahead and return I guess it was called name so name and similarly you can provide a definition for the marks as well so int student get marks and you can go ahead and write the definition for it return locks so basically you are going to get the marks from this now if you want to instantiate a student so let's say you wanted to create a student object from this remember we talked about classes and objects so you just to student let's just call him S1 for example and you can do S1 dot get name now dot is what you'd use to refer to the members inside a class in unreal though when you create objects you generally have a pointer to it so basically the memory address of it is a pointer nothing much to worry really so I'll just show you guys a way to create it so if I type in student pointer instead equals new S1 basically we are Dynamic new student so new student basically we are dynamically creating this and instead of the actual variable name we have a pointer to it pretty much now nothing much to worry about you just put a star instead of just referring to student and if you want to refer to something through a pointer you do S1 instead of putting a DOT now if you were to do dot you see it just got replaced with an arrow so you'd refer it with an arrow so something like this so if we actually just create a method to set the marks so I'll just do void set marks and it's going to be in the parameter which we need so end marks so we'll take this value from outside and we can say marks okay we are using this again so we can type in marks with a lowercase so marks equals marks so what we can do is we can say S1 dot set marks or rather with the arrow set marks and we can just say 56 for example just a random number and we can print it by typing in stdc out and we can print this so run a debugger and as you can see we got 56 printed so we successfully set the marks so this is how we would call functions which are defined inside a class and you will need to call them through an object because you need to instantiate them first of all this is something which you will not do in unreal you would use the function such as spawn actor and stuff in order to actually create objects but anyways this was just something I showed you guys now with this much you can pretty much do it if there's anything else such as for loops and stuff you can just follow along and look at the syntax that's pretty much it and if statements are also easy so you just do if and you would have the condition in the bracket so let's say the marks is greater than 56 so I can do S1 get marks S1 get marks greater than let's say 35 then we can go ahead and print that the student has passed so stdc out and I can say past so if I do this as you would see we get 56 and passed obviously this is not in a new line but that's pretty easy to do so you can do STD ndl and now you'd see 56 passed so with this much basic C plus plus you can actually follow along but again I do recommend you separately learn a bit of C plus plus before you come in the upcoming sections of this course is going to be for intermediate and advanced users so before you actually get started I recommend you guys do a few things first of all spend maybe a few days actually exploring the engine a little bit more may be creating a tiny game or something and secondly make sure you do know the basics of object oriented programming in c plus plus so stuff like your classes and you know uh stuff like structs functions and variables and the the basic stuff basically if you guys are familiar with that much of C plus plus and you have used the engine a little bit you would be able to follow along with the further part of the course so in order to start coding in C plus plus for unreal head into tools and open your Visual Studio project by clicking on that button over there and you should be in some sort of a file over here now you may have something blank so we'll just close that now under your games folder you should see your project name here and this is where you actually start working with stuff now we don't have anything actually under this we are going to be having our source files so you don't actually create it here in unreal in unreal you actually have the option to just generate all the boilerplate code for you you can do that by heading into tools and by typing in new C plus plus class now over here you get various options now if you have something really simple if you have some pure C plus plus logic you could just create an empty class and you could just sticker around it's just going to create a Constructor Destructor and it's going to write the class definition for you along with no macros just the standard C plus plus one but the most basic useful thing that you'll use in unreal is going to be your object so under all classes if you select object this is going to be equivalent to your object in blueprints however when you actually create it so if I just create it uh just select public and this is just to determine where your CPP file will be whether it will be in the public folder or the private folder now over here we can just call this CPP object so let's not confuse ourselves let's just call it CPP underscore yeah object is fine so this is not an object this is the class which is named CPP object please don't get confused with that so create a class and now as you can see you have some really basic code and one thing you might not have noticed is okay live coding is on that's a different story but what you might notice is it already has several things such as it has included some header files here these are just unreal standard header files and you will need them and you might have seen a few extra macros as well so this is a uclass macro and inside these these actually taken arguments too now these are useful for the unreal header tool basically when you compile this it happens in two phases basically your unreal header tool sets up stuff which are specific to your objects for unreal called your objects and in order to implement those features it does certain extra steps so when you get a compiler error it could be either from that or from your standard C plus compiler anyways that shouldn't be much of a problem to you guys now if you might have noticed even though we called it CPP object it's prefixed with a u and we have inherited it from U object now why is it like this now basically any object that you create that is a derived class of your object must have the prefix U and even object has the prefix u in Blueprint it is just shown as object however in theory it is actually U object and similarly for actors so let's actually create an actor as well so we can head back into the editor tools new C plus plus class and as you can see you see pretty much the same stuff over here but these are the two important ones object and actor now obviously character pawn and stuff like that are important but they don't have any specific prefixes so I I'll be talking about them a bit later and obviously we'll talk in depth about the inheritance hierarchy so I'll select actor and let's call this one CPP underscore actor create that and live coding if it works properly it should in theory compile it for us now if we actually open it up and reload this you would see you find something which looks a little bit overwhelming if you're looking at it from the first time but if you ignore this macro and if you ignore this comment here I don't even know why this comment exists because if you have come to an extent where you can write or interpret this code I don't think you need to know that a Constructor sets the default value so we'll just delete that comment and begin Place basically our event begin playing blueprint same thing uh tick is again your tick and blueprint you can delete the comment now this code looks a lot more cleaner now this is a virtual function and if you were to notice it's not called CPP actor it's called ACP actor basically every actor is prefixed with an A and the actor class itself as well all right now that we have established a basic understanding on creating a blueprint equivalent actors and objects let's look at the inheritance hierarchy in unreal in a little more detail now I'm not covering everything over here now I have left a few things such as interfaces and I'm not going into each class I'm just talking about the ones that you'll use in almost every project so that should cover things for you if you need anything in specific the documentation should help you if you understand this much so at the base level you have your object of course you have your typical basic C plus plus class but we are not getting into that now under that I can categorize a these into three main other classes which you'll use now there are many others but you won't really use them the first one and which you probably expected is a actor now an actor or a actor as it's called in C plus plus is something which can be placed in the scene so if you want to place something in the scene and write the code in C plus plus you would create an a actor or in the menu or in the unreal editor it's referred to as actor everywhere now similar to pawn you have a pawn which is basically something which can be possessed by a controller so basically you can control it and it need not be you it could be an AI as well so maybe you could write some code for Bots or something so you would use spawn in that case and if you have something specific like a humanoid character or something generally for most of the things which will be Pawn you generally use character so if you need a movement component and stuff like that you would use character some functionality is already set up in your character which is not set up in Pawn so something such as adding your controller pitch and your input and you know many other functions which we will talk about as we use them so that's where you'll use character this might be clear now a controller is basically an actor which takes an input now you cannot place a controller in a level obviously it sounds a bit stupid to place a controller in a level but basically uh each player will have his own controller and to be specific he will have a player controller if it's an AI or something you have something known as an AI controller but again we are not getting into that we it's really not that common to use it a controller will basically take your input now although you can set up your input bindings in other actor blueprints controller is the right one to actually hard code bindings and stuff like that generally when you create widgets which are not associated with your character you would create them inside your player controller blueprint generally you create a player controller you don't create a controller and that's about it for what you'll use for the most part and if we actually head into more gameplay oriented classes you have a info the reason I put this is because this was this was just a wrapper for you know these classes which you'll use you'll never create an info actor so ignore this this just for your reference over here you'd see a game mode base as the name suggests game mode base it's basically your game mode so anything any code logic regarding your game mode will be there in this and obviously it's really simple for me to just tell it like this but once I take a couple of examples it's going to be crystal clear for you guys and there is also an a game mode class which is inherited from this and it has some additional functionality for the most part we will stick with a game mode base but again you can feel free to use a game mode similarly a game State base and a game State now you might ask what's the difference between these two the main difference is that game mode exists only on the server in multiplayer games whereas game State exists both on the server and client so things like match timers which you would want all the players to be able to see as well you'd have them stored in the game State and maybe some other variables which you only want to use as a means of calculating something in game so stuff which will only be there on the server and multiplayer games or something which is core to your fundamental gameplay so something like maybe you know switching to another level when you enter place or something I mean it depends on the game honestly can't just tell what you would do with it just like that but basically game mode game state work together hand in hand now there's one more actually called the player State now the player state is really special because this is replica this is replicated by default to all the clients in multiplayer we upload in detail about multiplayer later on but for now just know that player state is going to be kind of the class which you'll use for anything that all the players must know at all points of time and generally you'd store info common to a given player which other players need to know uh stuff like your player name would be there in your play State because all other players need to be able to access your player name at any point of time so I just gave you an example you could be creative with it and do whatever you want now one thing you might have noticed over here for the last one which I'll talk about under your object is are actually two more uh game instances as the name suggests your game's instance so this is talking about your game as a whole and not anything inside the game so instead of begin play actually you have something known as event in it here so let's say you call something off of event init that actually runs well before your level actually loads so we'll look into examples again if you have anything pertaining to the game which has to sustain between level transitions let's say you move from your main menu to your actual gameplay level if you want stuff to sustain between them let's say you wanted a variable to sustain in that case you'd use the game instance because the game instance will not be destroyed between levels but when you transition from one level to the other all the actors and all the widgets everything else that you could possibly think of are going to be destroyed now speaking of widgets we have multiple classes here which you will probably never even touch even widget to be honest you will never touch in C plus plus it's very rare that you re you would require a C plus plus class for a widget so your user visit is the class which you'll use of course in the editor it's going to be referred to as user widget so this is how you would create widgets but honestly it's too much of a pain to work with widgets in C plus for something that's just you know very simple you could just work with other Blueprints and just have a blueprint widget which you would interact with stuff like that so that's about it actually now the way I'd practically use this is you'd have one C plus Base Class so for example we can have for a character we can have one character and we can go ahead and derive one so let's say we call this one R character so let's say it is a we'll just call it CPP as a convention ACP underscore our character I'll just call it our care for now now what you do is you would have core functionality written inside this class so for example your movement maybe maybe if you have a first person shooter game you're firing logic basically stuff that is Mission critical for the game and stuff which would break if they don't execute so for that you write it in C plus plus but other cosmetic things which you don't really require and it's fine if it executes a bit late stuff like you know uh creating widget maybe uh let's say you have a Crosshair on the screen maybe updating its position uh if you have a dynamic Crosshair that is or maybe you know stuff which is not essential like effects spawning FX so if you have stuff like that which is not really Mission critical it's fine uh if it's a bit slow and maybe if you don't have too many Loops so if you have many Loops in your code blueprint generally run slower I will talk about why that is and stuff so what you do is you'd have the core functionality in your base class and then uh you would create a blueprint class which I'm marking in yellow and we you'll call this one BP underscore r car now this is just a convention I use you could call it anything you could simply call this one r car so this is going to be our blueprint class and this is what you'll spawn in the level so since this is inherited from this BPR car will have all the properties of acpp Archer similarly you do that for all the other classes and that's how you would work hand in hand with blueprint and C plus plus blueprint is going to make your coding a lot easier so it's basically your visual scripting language so it's going to be very simple to write game logic but when it comes to finer control and when it comes to using other libraries when it comes to doing machine critical stuff you would use C plus plus so that's basically how you use blueprint and C plus plus hand in hand of course this is a very indepth topic and we are going to be talking about this in the future now let's actually go ahead and work a little bit more on whatever we learned till now so now that we know about the basic inheritance hierarchy let's actually start creating stuff on our own now the first thing which you might want to create are variables now for our case just for reference we'll be using our CPP object.h but anyways you don't have to use this you can you can do this inside the actor as well so stuff like that will remain the same most of the time you will not have anything in the global scope you will create everything inside of your class itself so the rest of your file maybe if you are creating a new struct or something you'd use it but most of the times you will be doing stuff inside the class so let's create a variable now you could do your normal C plus plus syntax thing so for example let me just create an integer so by using int let's say our integer variable all right you could initialize it here or in the Constructor now one thing that you might know is that since this is private are derived classes hence any blueprint class which we create out of this cannot access a variable so in order to actually access it there are two ways I'll be showing you guys both the ways so I'll I'll type in our private integer variable because we made it private this is how you would ideally do it I'm just uh explaining you guys each thing but you could you could you know brush through if you are already aware of object oriented programming but anyways it will give you a learning experience nonetheless now another way you could do it is you could create a variable in the public section so we'll call this one r public integer variable now this is good if you want to access it everywhere however it's really not you know appropriate to do it this way because if you have it in public any other class can just straight up modify this variable which is not good for us let's say you have something like your character speed or something it's very easy to misinterpret that maybe accidentally change the value so it's better to have Getters and Setters instead now this is how you would work with a public variable I know you guys are still waiting for the unreals reflection system so all these macros which is EU class use truck your property I'll tell you about all those not to worry foreign is that since this is private in order for other classes to access it we actually need to define a method so we can call this one int get our private hint we called it increaser order so let's call it like this now we also probably need a Setter so set our private integer now we don't have a function definition so if the reason I told you guys at the beginning that you don't really need to know too much C plus plus is that once you know how to write the Declaration you could just right click quick actions and you could just create a definition like this same way with our Setter function oh and this has to be void because we aren't actually returning anything you could make it bull so let's say you have a condition where you can't set it so let's say for a health variable you can't set it to 101 so then you would do those checkings and stuff but in our case we'll just use void head into the file here and instead of this we will return this variable so not public we'll return our private integer variable now this is how you would set it up for the private variable and this is the proper way to do it also uh currently none of these use unreals reflection system now if I just run a debugger so it's going to launch the editor make sure it's set to development editor in the configuration so wait for that to build and once it's done building it should start the editor now in order to actually use this over here and actually check stuff uh in Blueprint so what you would do is you would right click go to blueprint class and type in CPP underscore object but you see that it's not visible now the reason it's not visible but our actor was visible because by default All actors if you were to go into this file by default All actors are going to be marked as blueprintable so if I actually head into uh the actor over here and if I actually look into this U class macro you see it says blueprintable so what we need to do is in our object if we want to use this in Blueprint that is inside this uclass macro type in blueprint table now this is how you expose your view objects to blueprint so let's say anything is not accessible in this menu over here okay under all classes it probably means you haven't marked it as blueprintable so let's stop the debugger and run it again so wait for it to compile then once the editor loads up we should be able to use our CPP underscore object class so give it a second for it to load and now if I head back into blueprints right click blueprint class CPP underscore object you see that it's usable and this one will call it BP underscore object now if I just right click and if I want to access the function so we have get our private integer so get R and as you can see there is really nothing the reason is unreal doesn't really know that you want this to come in the editor basically you're not utilizing uh the unreal standard macros which enable you to do it so how you do it is for variables what you do for a public variable here we are going to type in U property and in the arguments will use a parameter known as blueprint read write now when you put this in the arguments basically what you're saying is you want this to be readable and writeable in Blueprint let's say you only wanted to be able to read it you do blueprint read only now how do I know how to do this basically you can just head into your browser and type in you property ue4 audio A5 oops not properties so yep your property so basically you have to go to the documentation page and as you can see there should be a list of specifiers somewhere over here there is so all of these are the specifiers so let's say you wanted a function to be blueprint callable you do that that is blueprint PR as well I'll be showing you guys the common ones but you can have a look at all of these the documentation is King now for a private variable actually we don't need to make this Au property however you could choose to make it now if you want to use these Getters and Setters which will technically you know enable us to use our private variable our get function will be pure of course so we are going to use a u function now now view function is another macro again you could have a look at it so here if I head into U function over here you see again there is documentation which talks in depth about this we will be looking at the common ones anyways this one will be blueprint pure blueprint PR means those green nodes which we saw without any execution pins so if I actually head into any blueprint these types of nodes basically without this execution pin that's going to be our Pure function and I talked a lot in depth about it when I talked about Blueprints and stuff now this one will be a u function as well and this one will just be blueprint callable all right now we can go ahead and run a debugger now we should be able to access this now live coding is a bit finicky that's the reason I'm not using it otherwise I would have chose to use it now let me just create that I didn't actually save it so CPP underscore object we'll call this one BP underscore object save that this time if I open it up now and if I type in get our private integer you see we get this function which gives us access to the value similarly set our private integer also works but it's kinda useless we actually didn't set up any functionality so let's just take in a parameter parameters are pretty simple except references everything else is going to be the same for parameters like how you do in standard C plus plus so you could type in in new value and over here as well we could just head into the definition and change that and then we could do our private or our public it should be nope it should be private so our private integer variable equals new value now that should fix things so we should have our logic corrected over there but that's not really our concern right now what if you wanted to take a value by reference now this is passed by value and it will work you could try it out not really going to waste my time to show it if you actually want your value to be passed by reference you use this macro known as U param ref and then you use an ampersand over here so copy this do the same thing in your CPP and now if I go ahead and actually build this once again and and in my object if I go ahead and type set our private integer you see it's taking in by reference if you hover over it it says new value integer by reference so this is how you do pass by reference I just showed that this is one thing which is a little different from C plus plus you can't just use an ampersand however if you use an ampersand it is going to take it as a second return value in Blueprint basically like your out parameters so let me show you guys what I mean by that so if I do this now this is wrong logically this is wrong I know that but anyways I'm just showing you guys what's gonna happen so if I go ahead and run a debugger once again this time it's going to take it as an output rather than an input if I open my BP object again and if I type in let's say set r private integer you see the new value goes out basically this is how you handle multiple return values as well you could just do pass by reference and in Blueprint it's going to interpret it as an out parameter in our case uh your param ref was the correct choice so we are going to do that undo this over here as well so that's about it oops just correct that also if you guys want to access your public variable you can just directly use our public variable so our public integer variable so it's directly accessible to us but one thing you might notice is that unlike these variables here it does not let you edit the default value and stuff now there is one reason for that that's because you again need to set a flag in order to do it remember the you property macro or here you have to type in edit anywhere in order to be able to do it so edit anywhere if I can spell that correctly if I actually do this and run a debugger once again I should be able to use our public integer variable and set its default value now if you were to see under the class defaults we have an option to set the default value or when we even get our public integer variable you see that we can set our default value so this is basically how you expose that to blueprint I suggest that you guys now try it with a few more functions of yourself and maybe you know check how they work in the editor and stuff once that's done let's talk about the next type that is ustruct so basically if you want to create structs for the Unreal Engine you need to use the macro known as you struct now generally I prefer doing it inside this dot h file for your project so you will have a file like this but you really don't need to you could do it in any file so for example let me just do it in our CPP object.h file it could be really anywhere unreal is going to recognize it for you so I'll just do it above our U class so I'll just type in struct and if you guys don't know what struct is uh well you got to learn that before it's basically like a class but uh by default all its members are public but remember when you are working with the Unreal Engine you don't really work with struct methods you only work with variables and any methods you'll have you'll have it in another class as static functions so that's how you work with it anyways I will show you guys what I mean by that real soon so for example let's just create a struct known as let's say book this is obviously highly impractical but just as a basic example and for the variables we could have maybe a string now remember in Unreal Engine the variable you use is not STD string so you don't use STD string actually what you use is called fstring which is unreal string type obviously most of the string types are just interconvertible at any point of time so if you are using a third party library or something you can convert it so F string is the string type in unreal so if I type in F string let's say name and maybe we can have an integer for number of pages and we can have a float for rating all right we have a really basic struct over here now if I go ahead and build this actually so I'll close my editor if I go ahead and build this you would see that it would build successfully however obviously uh as you would expect you cannot access this struct in the editor because we haven't used the unreal macros so in order to use this in the editor you you call you struct and inside the parameters what you do is you would make this blueprint type so this is what you use to expose truck to blueprints now if I actually run a debugger right here so you would find that there are a few build errors so what this is is this is not your C plus plus compiler error basically there are a few rules in order to use structs in unreal similar to how you have a u prefix for all structs you need to have an F prefix so now if I go ahead and run this in the editor it's going to be visible as book you see that we get another error now it says expected a generated body now if you notice our class here it has a generated body similarly for our struct as well for all U structs we are supposed to be having a generated ustruct body so it's going to set stuff up for the editor for us basically so now if I go ahead and build this you should see that we compiled successfully and we open up the editor right now but you will soon notice one problem again which you probably would have guessed if you would have seen these so the so if I just head into my object for example and if I if I type in let's say I create a new variable and call this one book one and I get the type book you see I can access this there's no issue but if I right click I can't actually split the struct pins now if you actually hover over this cannot split the struct pin it may be missing blueprint exposed properties so what is it basically tells us is we actually need to Mark these as you property as well so the same macro can be used here as well so you property and there's a little bit of an issue with the indentation there don't mind so your property again make this one a you property depending on what you want let's say we don't want to be able to change the name so let's make that blueprint read only so then we won't be able to change it now if I stop debugging and open the editor once again now if I go ahead and take a look and if I drag this in right click and split struct pin I am able to split it now if you drag this in and if you want to edit the members you would use the set members function and obviously you can have number of pages and rating as a parameter and we set name as not being editable since we did blueprint read only as you can see we don't have that available as a pin so this is basically how you use structs in C plus plus now the way you use it in C plus plus is pretty much the same like how you would by the way if you want struct methods you can use them but you cannot write U functions inside stock that's the thing so if I actually go ahead and try it basically I'll show it to you guys so if I had in here type in let's say void test function and I'll just give it a simple body here and I won't do anything now we would see that it will build successfully there won't be any issues so as you can see it builds but if I actually make this a u function I won't I won't even give any parameters if I just make this a u function as you would see it says use trucks cannot contain you functions so how do you actually do stuff with it so how do you actually operate on structs basically what you do is instead of having the U function here you would have it inside either a function Library class or you would have it inside some other object and make it a static function maybe so let me actually show that so let's create a test function so for example let's create a u function here so U function and what we can do is we can make this blueprint callable and over here instead of just declaring a regular function let's do a static function static void test and now we want to operate on this truck so if you want to operate it similar to your objects what you could do is you could simply create your own Target pin so the way you do it is fbook Target and obviously you would make that a reference so you param and in the brackets you would have ref so you would pass this as a reference and then you could work with it inside so I can write the definition here as well but just to be a bit cleaner so quick actions so whoops quick actions and I can create the definition uh now now that we've actually come this far I'll just show you guys how to print strings so it's not like blueprint where you directly just call you know print string and this is not gonna work so I can't just do this so let's just say test function called for example I actually cannot do this uh the very simple reason being that in Blueprint unreal actually Imports or rather includes all your headers for you as per necessity but basically that doesn't happen here so it's not exactly headers but you get the point so in order to use print string so how you would go about searching for functions is you do something like this so you do print string unreal C plus plus this is how you just search it up and you would look for the one which says docs.unreal engine.com and you would head in here and it says it tells you the include file so copy this path paste this in no not path rather the include and now we would see you have all the various parameters some of which are optional there are only two parameters which actually need but anyways now what we can do is now you notice that you are not able to call it but that's because this is actually a static function once again so what you do is you do you Kismet system Library and followed by a scope resolution print string and now we would see that it still shows an error that's because you actually need to pass in a world context object because it doesn't really know you know where to uh output the string like how to show it on the screen so in order for it to know that you actually need to pass in an object if this wasn't a static function you would just use this so if if this were inside an actor and it's not static you'd use this but it says this may only be used inside a nonstatic member function so what we can do is we can just pass in a u object pointer over here or rather we'll just pass in an actor pointer so a actor pointer now remember when you work in C plus plus any object any actor anything that you have which is enclosed in a class basically any class if you want to use them you would use a pointer to it you will never refer to it as a actor it'll always be a pointer just remember that so an actor is just to give you know some context to it so we can just type in context for example it could be an object as well I assume so if I type in context here now we would see that the error is gone but obviously we change the function signature you could make this a u object pointer I believe and now what we can do is we can copy this over head back into our function declaration and put that in so now our error should go now if I go ahead and actually run this now if I head in to Blueprints and BP object or here if I call test for example I think it's called test as you can see now we can operate on this truck and for the context we can what we can do is simply we can plug any you know outer object in so I'll just actually do that so I'll open up the level blueprint so for the context what we can do is we can go ahead and get a reference to sell and for the Target what we would do is we would go ahead and actually get a struct so instead of this I'll just create a struct so I'll just call this truck for example and it's going to be of type book so we can use that and now this function is going to operate on this truck so this is just a basic way you can do it now if I go ahead and press play after three seconds you should see something being printed test function called as you can see that works so that's pretty much how we would handle struct methods so that pretty much covers the basics of using structs in unreal C plus plus now the next thing is obviously enumerations and that should be about it and then we can start you know working with a little more complicated things at the base level enumerations in Blueprint and C plus plus work the same but in order to create them in C plus plus you can do the same thing actually you can do enum this one doesn't really need to have a prefix by the way so for example let's just say fruit uh fruit list let's just call it and inside that we can have our list items so let's say we have apple let's say we have our mango and let's say we have a banana stuff like that make sure I just end everything with a comma now again the same thing this is not exactly exposed to blueprint but in order to actually expose this you you use the same specifier as your use struct but instead you type in you enum if you use the U in a macro and if you add in the parameter blueprint type now this would be usable in Blueprint but if you wanted to give it a different you know name for it in Blueprint so if you wanted to give a display name to this basically what you do is you'd use another macro known as you meta and over here you change display name equals and you put in the string so in our case uh let's just call this one apple underscore underscore one maybe so just for you just for me to demonstrate that it works now if I actually run the editor and I can just go ahead into any blueprint and I can operate on that so I can say switch on whatever we call that fruit list as you can see instead of Apple it actually shows apple one and mango and banana is just shown as this generally what you do is you would simply have the display name to just display exactly what this list item was so you would simply have this and you would have mango over here generally you would just leave it like this banana so this is how you would go about doing it now we have brushed through the basics of Unreal Engine C plus plus of course if you want to know what function calls to use for your gameplay specific needs you could refer the documentation and later on when we actually take an example we will look into some of the common ones so it's not really that you have to refer the docs for everything I will be going through many of them now over here let's actually do a quick exercise let's try to translate this into C plus plus now if you were to notice this entire thing is actually purely in Blueprint and let's say we wanted our code to run faster or for whatever reason we needed it to be in C plus plus so let's actually go ahead and translate that so it's really simple uh let's start step by step so we have our get player camera manager function let's see which header file we need so it says Target is gameplay Statics right so this tells us that we need gameplay static so if I head into Chrome and if I type in gameplay Statics poe4 or ue5 you see you actually get the documentation page so over here we can get access to which header file we need so Kismet gameplay statics.net so stuff like that let's actually go about doing it now for the cast node we need a C plus plus class because all are C plus plus classes will not have access to the blueprint classes but all our blueprint classes will have access to the C plus ones so you cannot access a blueprint class from C plus so that's one disadvantage now let's go about doing this so I'm just showing you guys one example obviously we will talk about a few of the common ones such as spawning actors and stuff which are really common now let's start in the editor so let's go ahead and actually create the classes that we need so first of all we need a base class for our BP character so go head into tools new C plus plus class character and call this one CPP underscore character of course you can name it descriptively if you wanted create the class head back in and we need a couple more things actually so one thing that we need is the pickup class itself so type in actor and call this one CPP pickup all right create the class now what I want you guys to do is head into BP pickup and over here under class settings for the parent class I want you guys to select CPP pickup and over here as well I want you guys to select BP CPP character so CPP underscore character I want you guys to select that now what this basically means is that you are inheriting this BP character class from CPP character so everything that's there in CPP character will also be there in VP character basically this is your inheritance now let's head back in let's just reload this and I think we can close the editor for now or actually we might need that for reference so let's actually open up the character so we need a camera manager and from our header file we from our documentation we know that we need this header file so inside our character.h because that's where we wrote it always when you're including header files you need to do it above the generator.h so over here Kismet gameplay statics.h and let's just uh do this in the public section and let's have a look so when we press our left Mouse button we get the player camera manager so let's try calling that static function so go ahead let's actually create the function let's call this one I don't know what do we call this so we're just tracing and destroying so let's call this one remove pickup or something so avoid remove pickup all right we don't really require any parameters now let's go ahead and create a definition for it so whoops let's just head in and it has created the definition for us so let's go ahead and get that that's a static function so you gameplay Statics get player camera manager and over here what we can do is for the world context object since this is an actor characters are actors so you can just use this generally you just use this and player index as 0 since we have only one controller per screen so we got the camera manager and from this we need the actor location as well as the forward vector so what we do is let's actually just store it in a temporary variable so we can type Auto Temp equals and we can store this in a variable and what you can do is we can go ahead and get the actor location so this is a pointer again so temp with the pointer operator we can get the actor location we have forward Vector here let's do that as well and temp get actor location now this might actually warn us right now uh to use the get camera location function so as you can see use get camera location instead so get camera location just spell that correctly and now we have access to these locations and what we are doing is we are basically plugging this into the line Trace so what I can do right now over here to simplify things is we have a forward vector we grab that in and we multiplied by a float so the operator is already overloaded so we multiply that by 50 000 in our case so let's just do that and if we head back into our blueprint so we add that to our camera location so plus our camera location so you could just do a plus again so plus our camera location we can put these in parentheses just to be a little more clear on what we're actually doing so we can delete this line we have that next what we have is our line Trace so if you just hover over this you see it says Target is gizmit system library and I know this header file so I'll just do it for you guys anyways uh what we are doing is going to be correct so let's close this up so it's going to be Kismet Kismet system Library you could have a look at the documentation as well so Kismet Kismet system Library and if we include that our error should go and if I open up the CPP file once again now we should be able to call the line Trace function so you Kismet system Library line Trace if I do that I should find line Trace single and for the parameters we have a bunch of them so first one is the world context object which is going to be this again and next we have the start and the end location we look into all of that so this and our start location is going to be our camera location so what we can do is we can actually store this in a variable right now so what we can do is we can type in auto camera location equals get camera location now for the start we can go ahead and type in camera location and then we have our end so again we can store this in another variable so Auto End Lock location or let's just call this one end equals whatever calculation we just did right there so end and is what we called it then the next parameter we have is a trace type query which is the trace channel so this is what you see over here now over here uh this is a little bit peculiar in C plus plus so if I just do e Trace type query so e Trace type query and if I take a look you get something like one two three so on basically these are what you define in the project settings so if I actually head into my project settings and just type in Trace you would be able to see that you get Trace channels by default we actually get to uh that is visibility and camera so if we just do a trace type query one that is going to be your visibility and then if we take a look we have a Boolean for dress complex we don't really want to dress for complex collisions here so let's just do 0 or that is false and over here we have a parameter which we actually don't need and we also have a few more I guess we'll just use the ones which we absolutely need so actors to ignore we can just create an empty area and we can just pass that in so tra actor pointer and I will get to TRS don't worry basically this is like your STD Vector in standard C plus plus uh instead of that the one used in unreal is called tra so all the same functions exist inside this as well instead of dot size you have you know dot num there are a few names which have changed but it this is pretty much like your STD vector and let's just call this one ignore and we'll just pass that in so ignore and the next parameter is uh e draw debug Trace so basically whether you want to see the line trace or not so we draw debug Trace whoops and over here we have for duration for one frame persistent uh let's keep that for duration for now all right once that is done we have our head result which we are going to Output so we'll just create another variable so if hit result and we'll call this one hit or out hit or whatever and what we can do is we can just pass hit over here and once we have our hit result we have B ignore self yeah we want to ignore ourselves and don't really need the dress color because this has a default value so that's about it basically so we can go ahead and close this so I feel these parameters should be enough and once this function is completed we should have access to everything that we can possibly think of so the first thing uh that we are going to do is we are going to cast it to the pickup now in order for us to work with this first of all we need to include the header file so hash include because we don't know what CPP pickup is so we'll just do CPP ickup.h so this should compile because it is in the same folder and once we actually include the file what we can do is we can simply cast it now you won't use a dynamic cast here unreal actually has some things built in for us so we can get our hit so if hit dot actor dot get actor if this is valid now at this point if we haven't actually hit any actor with our line Trace basically this if is going to be false and we are not going to execute this code however if we have hit the actor we can go ahead and cast it to our pickup so if we can go ahead and cast it so this is going to be acpp pickup this is how you cast in unreal C plus plus basically you have a cast function and over here we can just pass in the actor so if this actor is valid so again the pointer is going to be pointing to an actor if it is actually valid in that case what we can do is we can go ahead and destroy this actor so hit not get actor and we can call the destroy function that's about it and just to make sure what we can do is we can just print it so UK is mid system Library print string and over here we can just pass in this instead for the world context object and we can print destroyed a pickup and we can go ahead and terminate that so now in order for us to actually be able to call this from blueprint uh we'll set up input and stuff a bit later in Blueprint it has a couple of extra steps so in order to expose this to blueprint field again use a u function and make this one blueprint callable make sure I get the case right and just indent that and now if I go ahead and close my editor and run a debugger now the editor should load up and if we open up our character we can get rid of all this code and I don't know what we call this so we called it remove pickup I don't even know why we call this but we can call remove pickup remove pickup now if I go ahead and press play and if I left click as you can see our logic actually works and okay this is not a pickup this was just a cube so that's the reason it didn't work but anyways the line Trace works now the reason it's working is because BP pickup is also a CPP pickup because we inherited from it so that's the reason what's happening is when we actually cast it over here uh we are actually successfully casting to our CPP pickup as well even though that was a BP pickup so that's basically how we translate it now we can go ahead and clear out some stuff this was just for clarity so instead of using the camera location as a separate variable we can go ahead and copy the server similarly for n we could just do the same and if we have anything else we could do that as well so we don't have anything else we can go ahead and close this up we'll we'll leave this temp variable because having such a long line everywhere is going to be a little bit weird but again you could you could do this so you could just place this instead of temp wherever temp is going to be there you could go ahead and get the player camera manager and do that but in this case actually using temp would be a better solution so we'll just stick with using temp so we have brushed through quite a bit regarding C plus plus and as we create stuff we will go through more things now what if apart from a pickup we also needed to cast some other thing so let's say let's actually create another actor so let's do it with our interaction actor itself so let's go ahead and open it up not sure why we've used it so let's just hit Ctrl f to find and let's just find interaction so so we are basically nudging it so what are you basically doing is we are again casting so I have to just check where it is so if we are overlapping so that's what we are doing so let's actually remove this logic and let's actually have the destroy logic itself so remove this and remove this or actually we could keep this now if you wanted to do it with your cast so what you would have to do is you have to cast to interaction actor if this fails and then destroy it and this for the most part will work so let me just go ahead and drag that in forget about the C plus plus logic and as you can see this works and even this works however one thing you might notice is let's say in an actual game obviously we'll have many such actors not just an interaction and a pickup actor so in that case you will have to perform many cars and casting is expensive for your computer's performance so the way you get around this is instead of casting multiple times you could cast to an interface and in unreal blueprint there's actually a very elegant system implemented we'll be talking about both the blueprint and C plus versions of interfaces now so in order to handle this problem what we can do is we can actually create an interface so I'll show you guys step by step to implement this exact logic uh using an interface and we can actually have separate logic as well for both the interaction and the pickup Factor so head into your blueprints right click blueprints blueprint interface and let's just call this one I don't know destruct I guess uh generally I have a Convention of calling it BPI underscore and we can call this one destruct pickup Maybe all right and we don't need anything for the input but anyways now the way you actually use this is for whichever actor that needs to be casted to so for example we are casting to our pickup and our interaction actor so we would head into both of these and under your class settings under implemented interfaces we can go ahead and Implement BPI destruct and do the same thing for the interaction actor head into class settings DPI destruct basically at at the fundamental level what this is doing is it is inheriting this interface along with actor so basically your interface is also class internally in C plus plus I will show you guys the C plus plus version which will make things a little more clear but instead of doing all this what we can do is we can call destruct or I guess I call it pickup so let's just call it destruct in general to compile and save that so we call this destruct and now if I actually go ahead and press play I mean nothing's going to happen because although we have destruct as you can see we can't really Define the logic here the way you define the logic is for example we can head into pickup under interfaces right click Implement event and if I go ahead and just print a string and I can type in destructing pickup and if I go ahead and destroy it so destroy actor and Target will be self and I'll do the same for the interaction actor so implement this event oops paste this in and we can do destructing whatever this is interaction after so now you should be able to see that both of these different implementations are actually called so if I press play you see our pickup is destroyed and if I actually click on this side our interaction actors also destroyed so this is how you basically use interfaces instead of casting basically what it's doing internally even though this looks like we got rid of casting is instead of casting to our interaction actor it casts to the interface because interaction actor implements that interface the cast is going to succeed and the function will be executed the situation where the cast fails is automatically handled in the engine now how do you do the same exact thing in C plus plus you may ask it's pretty simple actually you just use the concept of multiple inheritance in C plus plus so tools create a new C plus plus class and over here what you have to do is Select unreal interface and we can just call this my interface for example and create the class it should load up visual studio for you so just reload that and over here you should be able to see my interface.h and my interface.cpp basically this is where you would write the function definitions and you can go ahead and Define it in your various classes so what you do is for example let's just have this function work for both the pickup and you know our whatever that was interaction actor so let's say we want this function to work for both of them so let's go ahead and do that using an interface we'll actually get rid of the C plus plus logic so we'll get rid of that and what we got to do is first of all uh since we are actually casting to the interface here we can go ahead and include the header for that so hash include over here uh we can go okay we are including pickup already so what we can go ahead and do is we can go ahead and include this interface in the pickup so not after a generated before the generated dot h and this is going to be my interface dot h and over here where you see public a actor I put in a comma and type in public I my interface I is basically the prefix which is used for interfaces just remember that so my interface in the editor is going to correspond to IMI interface in C plus so let's actually write our function so let's call this void disrupt Maybe and we can go ahead and add in our implementations so we can right click first of all and make this one virtual right click actions create a definition for it this is just going to be like your default implementation so now let's say we wanted to implement this function in another class it's really simple to do it now that we have a virtual function here we can head into our pickup.h and over here along with this we can type in Virtual void and I don't know what the function was so I'll just copy this over do the same thing in the pickup and since we are actually overriding a base class method what we can do is we can use the keyword override uh now if I go ahead and right click quick actions create a definition head in here and now let's say we do the same thing so let's say we do U Kismet system Library print string this and let's just say destroyed pickup from C plus plus and we need to include Kismet of course so let's just do that real quick so let me just copy this over because let's just do this in the dot h file so now we can go ahead and actually destroy it so we can say this destroy or rather you can just call destroy all right so we can go ahead and test this logic but remember it's not going to work for our interaction actor because we again don't have another C plus class for it so let's actually create that too so new C plus plus class actor let's just call it for example I don't know CPP underscore interaction active okay so we'll create the class and what we can do is we can again implement this so in order to implement the interface so I'll just stop the editor there so in order to implement the interface we'll do the same thing what we did for pickup so if you head into the header here copy this over head into your interaction actor implement the interface and again we need the header file so what we can do is we can do hash include uh whatever this is so we have my interface.h and then we can go ahead and implement this event by using virtual void destruct which was a function name and we are overriding a base class method so override and now we can go ahead and create the definition for it and over here we can go ahead and print the string again we can do that by simply including Kismet again so let me just copy it over oops I'd copied that so head back into your pickup where we had included it copy that paste that back in and let's just copy over the code from our pickup you can have different code as well I'm just showing you guys as an example on how to use it so we'll change what we print so destroyed interaction actor from CPP and this should work also just head back into your CPP file your CPP character and where we cast it to the pickup what you basically do is instead of casting to the pickup you cast to the interface since we inherited the interface so it's going to be I my interface and make sure you actually include the header file I've already done that so somewhere over here we have included pickup.h already and pickup.h already implements the interface and we have included the header so we don't really need it so we can cast to this interface and instead of destroying and printing what we can do is we can utilize this so we can have this separately so we'll just do Auto temp equals I mean I'm doing uppercase temp because we've already used lowercase temp here and temp is going to be valid because the cost has succeeded so what we can do is we can call destruct from here all right now we can go ahead and run a debugger now if I head back into my character connect this up uh hit play and you should see that we say destroyed pickup from CPP but the interaction actor doesn't work that's because we haven't actually set up the parent class over here so go ahead and change that to CPP underscore interaction actor and we could rename this as well BP interaction actor all right so if I go ahead and press play the pickup works and as you can see destroyed interaction actor from CPP so that's pretty much it that's how you use interfaces and later on we will also be seeing more practical examples this was probably a good one but still will actually implement this in our actual game now let's look at another case where you know you want to call blueprint functions from C plus plus now this almost seems impossible because your C plus plus classes aren't actually aware of what blueprint classes exist but actually it is it's really simple too so what you do you could use it in any actor any object even in the interface if you want but I'll just show you guys in the character by just printing something so the way you actually call blueprint from C plus plus is like this so you just write the normal function so let's just call this void test BP func let's say and now what you got to do is you have to use the U function a macro and you can make this blueprint callable or not but the specifier that you need is called blueprint implementable event so now you can have the function declaration over here you can actually have parameters too so we can test that if you want so in X let's say so now if I actually run this you won't actually get a compile error because unreal or automatically generates the definition for you and you can Define it in Blueprint so if I open up my BP character and under functions under overrideable if you just have a look you will have test BP func and as you can see I can actually implement this over here and we also got our input parameter so we can just go ahead and print a string we can either call this through blueprint or we could even call this through C plus plus let me show you guys by calling it through C plus plus so I'll do it on begin play so what was a function called again test BP func and you would see that this is actually implemented so let's type in 100 for example and this will work and in the meantime now I would like to show you guys one more thing that you can do I just wanted to show you guys that yes you can actually do this you can actually implement it in Blueprint but there is a possibility that you have some C plus code but then you also have some blueprint code which you want to be executed so in that case what you would do is you would use another type known as blueprint native event so we'll just copy over this function and let's call this one test BP native funk and let's just have something else for example let's say we'll have a float and for this actually what you need to do is you need to have another function called The implementation of this function so that is going to be what you define in C plus plus and this is going to be our function name in Blueprint so in order to explain what I mean instead of implementable type in Native now if you compile this you'll actually get an error so what you're supposed to do is not create a definition however you are supposed to create an implementation for this so the way you do it is you just copy over the signature and instead of the same function name you type in underscore implementation whoops implementation so what you can do now is for the implementation you can go ahead and create the definition head into your definition and we can go ahead and print something so let's say we go ahead and print for example let's just say C plus plus implementation called and we can close that in and for a blueprint implementation we can set that up in Blueprint no issues so that should be it now you can go ahead and actually compile this once again so apologies I just made a few typos over here so so let me just copy Implement over here so implementation and do the same in the CPP file as well so underscore implementation and now you should have no problems so if we head into a BP character and we can go ahead and override both of them so test bpfunk we can go ahead and print it actually uh this is our blueprint implementation and we called it from C plus plus so okay we'll just go ahead and print it we are calling it from C plus plus so what should be expected is 100 is going to be printed even the native event you can call it from C plus plus I'll just do it over here so first of all let me Implement that in Blueprint so Implement that go ahead and just print that that shouldn't be that hard and just grab in our begin play here and instead of okay let's just spawn this let's keep all of this logic and we can go ahead and since we made it blueprint callable whatever this was and we'll just take in some random value now if I compile and if I go ahead and press play as you can see we get 100 as well as our four two three four three printed now your obvious question is why didn't the C plus plus implementation get called so if we if I actually go ahead and delete this and if I were to press play now we would see our C plus plus implementation is called but that's not really that useful isn't it unless you just have some sort of a default implementation so what you actually need to do in order to get the C plus plus version called is right click on the Node and type in add call to parent function now it is going to call the C plus version now if I go ahead and press play as you can see it calls the C plus C plus plus implementation the blueprint implementation as well along with it so that is basically how it works now if I if you were to do this as you can see we call the C plus function along with the parameters of course as well as the blueprint function what you are calling here is actually the blueprint function if it does not find an implementation it is going to use the parent class version of the function remember that foreign discussed everything which was foundational in order to actually start developing in C plus plus however we do lack a little bit of knowledge regarding you know the implementation of various data structures in unreal now apart from just using normal variables you would use arrays and Maps there are others such as sets linked lists and stuff but for games you would honestly just use arrays and Maps most of the time so in order to implement arrays in unreal so you don't use a static array I mean value could but you don't use static arrays uh you don't really use the STD Vector as well you could use a 3D Vector but you can't expose them to blueprint and stuff or you would have to write your own wrapper class now if you guys don't know what I'm talking about I'm basically referring to the standard template library in C plus plus but in unreal instead of STD Vector we actually have another type known as template array or tra so the way you create that so let's create a variable in C plus plus let's do that in the public section we're just doing it for demonstration so I'll just make a U property and make this one blueprint read write and add it anywhere so edit anywhere and over here what we can do is instead let's say we have an array of integers so the way you do it is you type in t array and as a template argument you would give the type as integer and let's just call this our end array all right now template array is actually internally something like your STD Vector so if I actually Ctrl click on this this is actually a class which implements it and the methods which are associated with this are pretty simple we will go ahead and check all of this so similar to the STD vector class in standard C plus plus tra has a bunch of functions which gives us info about various things so let's actually set some stuff up so in order to initialize this array so what we do basically we can do it in the Constructor or right here we'll do it in the Constructor just to keep things clean so we'll call R and array equals and within curly braces we can just give some values so I'll just initialize it with some random values all right so now let's go ahead and look at how to add stuff to this so similar to add and in place we have methods for that over here as well so we can type in R int array Dot add and now we can go ahead and add an item so let's say for example I want to add 12. so our fifth element here that is at index 4 is going to become 12. and this array is going to be resized since it is similar to an STD vector now similarly also have M plus so constructing an element in place basically dot m Plus this is like your M plus back function in STD vector so I'll just add in some random element over there now our array is going to be 23 6 43 64 12 and 4. now what if I wanted to remove something so I can type in R int array and I can remove either at index so dot remove I can either remove an element by using the remove function so let's say I wanted to remove 23 I'm gonna remove 23. and R and array whoops R and array dot remove at is going to let us remove something at a given index so let's say I choose zero so now it's going to remove 6 because we already removed 22 so 6 is our first index so 6 is going to be removed all right so we did all of these but now what if we wanted to reserve some memory for our array so what if you didn't want it to resize and search for memory so even those functions are available so let's call The Reserve function before all of this so our end array dot Reserve whoops Reserve and we can as we can see we have four elements five six and we remove two so we have to so we can reserve for but at Max we have six elements so let's Reserve six so we can call that and stuff so these are the most common ones that you'll use I won't really use all the other methods but again you can just refer the documentation if you really need it now we can go ahead and iterate through this array through a range based for Loop just like how you can with any of the STL data structure so you can go ahead and do for Loop Auto we can just call this one element and we can pass in the array just like how you would pass an STD Vector so R and array and what we can do is we can go ahead and print it out by calling the print string function so you Kismet system Library print string you know that drill by now so now in order to print an integer you actually use this function which is a static member of the F string class so F string from int is what you use and you can go ahead and type in Le here now remember if you wanted to print a float you would use this function known as sanitize float now it's going to cast it implicitly anyway so even float works for this and you also have other functions for converting between various data types you could again have a look at either the F string class or you could go ahead and just search it up on the documentation so if I actually head in over here so we have our sanitized plot here we have two hex blob from hex blob we have we have various functions basically so we have from int as you can see you can go through this class see the return type and look at what the function does and then you can go ahead and implement it accordingly so now I'm in the editor if I open up my BP character and if I actually head back over here we had made this blueprint read write so we should be able to access our and array so if I just type in our int array so as you can see we get it just like any other blueprint variable and since we initialized it in a Constructor we already have certain values now in begin play if we go ahead and iterate through this so I'll just do that we'll uh not call this function anymore now we have an idea of what that is so we have already set it up actually so we we have done it over here so we're printing stuff in our begin playing C plus plus so we don't have to set it up actually so if I go ahead and press play as you can see we have 4 12 64 43 in reverse order that is 43 64 12 and 4. and let's actually walk through the logic so we have 23 6 43 64. and we went ahead and added 12 and 4 so 12 and 4 should be our last elements and we remove 23 and we removed six so our RS should be 43 64 12 and 4. and if we go ahead and look at our logic here and our output so we see that we get 43 64 12 and 4. so this is basically how you use the tra class functions so this is exactly the same as your STD Vector but there are a couple differences in the function names and most importantly from a readability perspective all of these functions use Pascal case so it's readable compared to the standard C plus plus stuff which uses underscores which is not really that readable so this is how we would it return array obviously you could use a full length iterator but there is no actual purpose to do it as per my experience anyways let's head into the next part now and take a look at how else we can iterate through this through your standard C style for Loop so I won't be actually showing you guys the output since it's obvious that it's going to work so you just do something like for INT I equals 0 I less than where now this is where we talk about another method in this class so we do I less than R and array dot num this is similar to the size function in the standard template libraries STD vector and we can do I plus plus so we can just increment I go to I plus plus or I plus equals 1. now instead of Ali since this is not a range base for Loop we can get our array and we can get the ith element now this is going to work exactly the same apart from RS the other data structure that you would use in a game is going to be Maps well there are linked lists and other data structures which you really won't use that very much in games even maps to be honest you just use it maybe a couple of times in your entire project but anyways in order to create a map in unreal basically you you use the type T map so if I just copy of the U property macro and in the next line you can go ahead and create a map and if you guys know about Maps basically it's just a key value pair so for example you can have two strings as key and value and you could have something like a username password key value pair something like that so let's just create a simple one let's say we map a string to a float so it's case sensitive obviously and we can call this one R map now you can't just initialize a map like how you would initialize an array so you would have to call the add or the MPS function multiple times that's just how you would do it so our in Array or rather R map dot add and what we can do is we can pass in the string and the float so let's say pi and 3.14 then we can go ahead and call add once again so we'll just go ahead and do all of this in our begin play so let's just find some other number let's say num1 for example let's just grab in a random value now once that's done you have other methods but you aren't really going to be using them for anything but I'll just show you guys how to iterate through this and how to retrieve the key and the value so that's what you'll be using this most for now let's say I wanted to access an element though you could do something like this so let's just print out uh what the index num1 will contain so copy this over and instead of R and array of I what we can do is we can get our map our map of num1 basically num1 is the key here and basically by doing this you're getting the value of it so in our case we mapped num1 to 43.4543 and if you want to iterate through this we can use a range best for Loop here as well so we could just say Auto element and we can pass in our map and what we can do is we can get the element so we'll print this so we'll copy the code over once again so we'll print both the key and the value so let's just create a string variable temporarily and the way you get the key of this so each element in this map is going to be a key value pair so Le is going to be a key value pair what we can do is we can do Dot key in order to get the key and if we want the value we can go ahead and do Le dot value the way we'll do that here is we'll just append the string so basically we'll concatenate the two strings so what you can do is temp dot append and let's just put a call on Just for visual purposes and we can do temp dot append and since our value is going to be a float we can do F string sanitize float and we can go ahead and get arm value so Le dot value that is going to be a float now we can go ahead and rather than printing this we can go ahead and print in temp so we also learned how to concatenate strings on the way so this is how you would iterate through this this is how you would get a key of a given element in the map and this is how you get the value now remember you cannot have two keys of the same value so let's say I actually create another uh element with the key num1 it's going to throw an exception you can't actually do that so now we'll actually stop printing our array now that we are done with that so if I go ahead and run a debugger now since everything is set up now if I go ahead and press play you would see that we get Pi 3.14 and num143.4543 and as you can see we also get our four three dot four five four three uh that printed first because we had printed our map of num1 so basically the key here is num1 and we basically asked for the corresponding value it is just as if you asked for R int array of one it's pretty much something like that so basically instead of the index you would pass in the key that's basically how you use this operator here now this is basically how you iterate through it now you could you know do many other things with the map but for the most part you'd just be using it to store key value pairs generally it's useful for having a track of you know game users and stuff like that they're really very odd audios cases for maps you wouldn't really use it that often so I'll leave this over here now when it comes to designing your game once you're actually aware about all the things that we just discussed over here up until Maps in order to actually Implement them in an appropriate and efficient manner you would use the classes which the engine provides us so we'll be going through some of the most important ones which will be used in all of the games and there are other derived classes of it the ones which I showed you guys in the flowchart previously when I showed the inheritance hierarchy those are the ones that we will be discussing in detail there are other classes we'll just be brushing through few with whichever are important but if they are not we are going to be just skipping through them but if we ever use them in the last part of the course we'll be having a look at them in depth once again so now let's start talking about actors now at this beginning of this video I actually talked a little bit about actors basically anything that can be placed in the level is an actor so that definition still holds good but it is incomplete there is another thing which an actor can do and that is it can tick now you guys have probably seen the tick function so let's open up an actor actually let's create one because all of these have their own base classes so let's create a pure actor in Blueprint we'll do one in C plus plus as well pretty soon or actually we probably have it so let's call this one BP underscore a let's say I just created this for the sake of it now if I were to actually have a look over here you would see that you have three tabs and the event graph is where you worked on for the most part but we haven't actually gone in depth into all of these little details so first let's actually go from the top so what we have here is the class settings and most of the times you'll just use it to implement an interface or change its base class but other than that you aren't going to be using it now under class defaults you have a bunch of things which actually Define what an actor actually can do now if you were to look at actor tick you have several options start with tick enabled tick interval and you also have several other things now we did talk about this one so I'll I'll not be talking about that but anyways all of these are selfexplanatory and one thing which you won't see in any other type of blueprint other than actors is the replication tab ly if you check this replicates tab this actor will be eligible to be used in multiplayer what I mean by that is that when you spawn this on the server which we will get to when we talk about multiplayer basically all your other clients can see too by clients I am referring to players in this Con context and we have settings regarding that now these are just the flags these are pretty selfexplanatory hidden in game and visible stuff like that and under the Collision tab these are things which we again talked about but there are a couple more things which an actor provides us the first one is your damage now if let's say you have you wanted this actor to be destroyed so let's actually do that let's go ahead and create an object so let's add in a model here so let's say we add in a sphere I don't know uh maybe simulate physics on this or let's let's leave it as is what we can do is unreal actually provides us with default logic to apply damage to this so if I type in event damage you see we get three of these nodes Point damage radial damage and any damage so any damage is going to refer to all types of Damages Point damage is going to be your damage through a line trace or something generally radial damage is going to be something where you know you damage this actor through grenade or something like that so you would have you know a distance and stuff like that so if I just press this so you have your origin so that's going to be where your grenade landed for example so it need not be a grenade could be anything else just give an example so from that point uh if as you go further away your damage is going to decrease stuff like that so let's just do event any any damage so any damage what we can do is over here we can go ahead and simply print this out rather just to demonstrate that that this actually works now by default unreal does not give you any health variable you got to do that yourself and one thing you might have noticed is this little icon over here at the top right hand side of any damage basically that property is called blueprint Authority only what it means is that you can only call this on the server so you cannot call this on the clients obviously you don't want your players to be handling the damage and stuff but anyways let's actually go ahead and work on this logic so when we left click we do the line Trace thingy so let's bring up the line Trace logic once again so what we can do is we can line Trace by Channel and we get our camera manager get player camera manager get the after location this is some stuff which we've already done then we get the forward vector and we multiply this by a certain value so let's just convert this to a float and let's multiply this by let's say 50 000. we are going to add this together and we can plug that into end and the start and from our output we can go ahead and call apply damage so there are multiple nodes apply damage apply Point damage and apply radial damage will do apply Point damage you could just do apply damage and base damage let's just give it a value of 30. or just to keep things a little more interesting so Random float in range so let's just say anything between 20 and 50 Maybe so it's just going to select a random number and damage doctor is going to be the hit actor obviously and damage causer is going to be self damage type is something we won't be talking about and hit info we could just pass in this whole hit result so what we can do is instead of doing this we can recombine this pass this in here and we can go ahead and break this separately so type in Brick and pass the hit actor once again to the damage actor and we can collapse this as is hit from Direction basically uh that is going to be something which isn't really going to affect your damage but once you know the damage doctor's location you can actually find the direction towards it basically so what we can do is you can do something like this so basically use this node called find unit Direction so unit Direction so get unit Direction so it's going to be from our start to our location and this is going to be our hit from Direction so basically uh this is a position vector and this is a position Vector as well so we can subtract it to get a vector joining those two points basically and now it should compile if you really don't want to use this you can go ahead and split this and this is going to work as well it's just going to construct a vector in place so we'll recombine that and use that and if I go ahead and press play nothing's gonna happen but if I actually drag our BPA here and if I go ahead and press play so as you can see we are applying some random amount of damage so not sure why the lag exists but anyways now once that's done the next thing that an actor provides us and also just one one more note here so now we are talking about the blueprint version of this we'll also look at C plus plus stuff a bit bit later there are a few things that I would like to go over in C plus plus as well so the next thing is hit events now remember we had done the overlap for a character so somewhere over here so similar to that you also have hit events so you just type in event hit and this is how we set up hit events you also have hit events for each individual component so if I click on the sphere if I scroll down I can actually do on component hit as well that works too now other is going to be the actor which actually hit this and other component is basically the component of the other actor which hit it my component is going to be the component in this sector which actually hit the other actor and hit location is the hit location of course and we also get a hit result so way too much for what you need so that's generally the reason why when I actually work on these things I I just create an interface myself because generally you really don't require all of these things in order for your damage logic to work anyways I'll show you guys how this is gonna work so if I just go ahead and print this and one handy node here is you can actually get this and if you can type in get display name and you're going to get the display name of the object basically if my character bumps into this so let me do that real quick okay I can't it's too high so let's bring that down so if I actually bump into this as you can see you get BP character the reason it's printing it so many times is because we are in contact with it for quite some time so when we are in contact and we are sliding on it each frame it counts a new hit basically that's the reason it's happening all right so the next thing that I would like to touch upon when it comes to actors is the construction script so this is similar to your default Constructor in C plus plus now there is a way to actually uh get an equivalent of a parameterized Constructor I will get to that both in Blueprint and C plus plus but first let's work with this so let's say I drag this in now every time I update this actor the construction script is actually called so let me just show you guys so if I just go ahead and print string and if I go ahead and move this actually so first let me compile that save it and now if I head back as you can see every time I move it it actually prints hello basically every time you spawn this actor or you update this actor in the level this construction script is called at runtime it's only going to be called when you actually spawn it but over here in the editor whenever you move it it's going to be called each time there's actually an option somewhere in the class settings so run construction script on drag so you can disable that if you don't want that to happen so it's it's only going to call it once you finish placing it I'll just leave it as is now if you want a parameterized Constructor basically let's say you wanted to set a variable so let's call this uh I don't know maybe some float variable and we'll make this of type float now if you want to actually set the value of this outside like a parameterized Constructor first select this variable and head into this option right there select instance editable and expose on spawn now what you've essentially done is your basically exposed this when you actually call the spawn act a function so if I just head into my character and spawn this on begin play so I'll just leave this BP pickup and let me just do this actor instead so BP underscore a now Health points is not a parameter so you can alt click that to delete the pin now as you can see we can select some float so I can set this to whatever I want now this is something which we touched upon however there is an equivalent of this in C plus plus as well but it is a little more complicated than this so if we actually head into our Visual Studio solution all right so now that we are in C plus plus now let's actually test it out with our CPP underscore actor so let's go ahead and spawn this from our character or if we have anything else we could try that as well so our interaction actor maybe if we could try that so we can spawn our interaction actor now if we go ahead and head in here inside our character's header file so we can go ahead and include that as well so hash include and we can go ahead and include CPP interactionactor.h now let's actually create a function or we can do it on begin play so head into begin play now after we are done with this or we can actually just remove this logic we aren't really using this the way you spawn actors in C plus plus is by calling the spawn actor function from world so in order to get your world you call this function known as get word and from here you can go ahead and call spawn actor and this actually takes in a template argument and this is going to be the type which this spawn actor function will return so it is going to be acpp interaction actor and I could just spawn it like that it's going to take in all the default parameters you can actually set up subclasses and stuff so let's say instead of CPP interaction actor you want it to spawn some derived class of it which is there in Blueprint you could do that totally so let's say I wanted to spawn BP interaction actor and not CPP interaction actor so we can actually test that theory actually so BP interaction actors pond I mean the spelling doesn't really matter here so let's delete whatever's there in the level so BP interaction actor so interaction actor so I'll just go ahead and delete that now if I press play I'm not really getting that so what I can do this is going to spawn your CPP interaction actor but if we actually have a variable here which stores the exact class which we are spawning so we can do that right there so you property make this one edit anywhere and make this one blueprint read write as well now what we can do is we can go ahead and pass this in so the type which you use is T sub class of and obviously we are looking for a derived class of acpp interaction actor so we'll just copy that over so this is going to be prefixed with an a and we'll call this one class to spawn or rather we can call it actor to spawn now this will be available to us in our blueprint now one thing to remember you have to make sure it is actually valid so if r reference is valid here so our subclass is basically so if this class reference so if actor to spawn is valid only then we are actually going to be spawning this actor and over here in the arguments list you can go ahead and pass this in and paste this in and you can also pass in a transform optionally but I won't be doing that now let's actually pass in some parameters so if you want to pass in a parameter using your deferred spawn actor as I would call it as the function is called so we can actually do that with the same thing so let's create a variable here which we would want to edit so under the public section we can go ahead and create a new property we don't need this to be blueprint read write or anything so we can call this one in some variable and the way you would set default values for this is if I go ahead and write the function again so this is how it's spawn an actor here you would have what's going to be returned so if I actually do Auto temp equals spawn actor interaction actor basically this temp will be of type ACP interaction actor pointer so pointer to this point actor will be uh returned now what what we can do is we can spawn another one actually so we'll just do Auto temp one equals we can just go ahead and copy this and instead of this we can do spawn actor deferred and just make sure to get the spelling right so spawn actor deferred so for this one we have to pass in the transform so we can just uh write a Constructor over here so F transform and that should compile but once you call this function the actor is actually not spawned now since we have a pointer to our actor we can go ahead and call this function known as finished spawning so if I type in Finish spawning this is going to actually complete the spawning process now you can just again pass in the default transform so once this is done our spawning would actually be complete and in between this is where you can actually set your variables so you don't have a parameterized Constructor but now we can go ahead and set our some variables so some variable equals 100. obviously temp one and now what we can do is in our interaction actor we can go ahead and just print it on begin play so you Kismet system Library print string and we can go ahead and continue with this and go ahead and print in F string from end and we can pass in our value here so some variable is what we want and that should be about it now if we go ahead and run a debugger here everything should work as expected just make sure you close the editor before you actually build it so so now if we go ahead and press play we shouldn't see any print strings and this proves that our if check here is actually working if we would have removed this if check our engine would have crashed since this actor to spawn class reference would be invalid anyways we can set that since we have exposed it to blueprint so in our character I assume so this is in CPP character so it's going to be inherited into BP character and under your class defaults over here you should be able to find your variable so CPP character under the third section here actor to spawn and we can select our BP interaction actor if I go ahead and press play now as you can see we get two prints along with one zero and one hundred for our Pond actors now the first ones are 0 because in our first Pawn actor function we actually didn't set any of the values so this was our class X Pawn actor and in the second one we actually use the Deferred spawn actor which let us set the default values before calling the construction script so this is basically how we would simulate the parameterized Constructor in Unreal Engine in both blueprint as well as C plus plus now the next class that I would like to mention here is going to be the character class and we have used that quite a bit so if we just open up our BP character for example which is a character class so we have inherited from CPP character just to keep things clean and just create a new character here and let let this just be called new character Maybe now open it up now if I were to just look at the parent class it says character and character is actually a derived class of Pawn so basically every character is a pawn and pawn is a derived class of actors so when I'm talking about characters I am collectively referring to both pawns and characters basically every character is going to be a pawn now the reason why I especially wanted to mention this even though this is technically just a derived class of factor and probably probably many other classes which I'll mention further are derived class of factors is due to this character movement component now this allows you to do various things now if you were to just go ahead and look into these parameters you can actually have a pretty basic idea on what you can do at the beginning of the course if you remember I had mentioned that you can actually use functions to modify almost any of these values not all but most of these values at runtime so for example now let's just take our BP character for example and let's go ahead and press play and we know that we're using this so we are walking forward but what if this feels a little bit too fast for you now this is where our character movement component is going to help us so the maximum speed of this character is actually set by a variable inside here so if I just drag this in and if I type in set max walk speed as you can see we are able to set some value over here so I'll just do this on begin play you could do it somewhere else as well but let's say we wanted him to go only at 500 default is 600 by the way now if I go ahead and press play you see that he moves a little bit more slowly now if you feel this is a now one more thing is that the animation will also slow down along with his speed so that's not something which you should really be seeing in this example so we are moving slower let's say we wanted him to move a little more fast so let's say we have 1000 we can go ahead and set the speed and now we walk much much faster so stuff like this and one more useful thing which the character movement component provides us is movement modes so if I just type in movement mode and get movement mode you can actually see this is an enumeration we can just do switch to see what are the enumerators here as you can see we have walking nav mesh walking which is for AI basically falling swimming flying and Custom now there are various things you could even do with this uh apart from switching between them you can actually set the movement mode so for example if I just change this to Flying for example and if I go ahead and press play now you will notice that this behaves a little bit differently now if the movement mode is flying if I go further as you would see he's actually floating in the air so when you actually set this movement mode to Flying basically it also allows you to take vertical movement input so apart from your move forward and backward you could also do up and down so let me actually do that so where we have our add movement input instead of forward if I do up Vector so get actor up Vector if I just do something like this and if I go ahead and hit W as you can see we can actually go up and down as well so this is something cool which you could do and there are a few functions which I would specifically like to talk about right now and one of them is launch character launch character so let's say I wanted to implement a jump pad or something so let's just do it after a delay so delay of about 2 seconds and we can go ahead and give something for the launch velocity let's just give 10 000 Maybe now if I go ahead and press play as you can see we were launched in the air I mean I just gave a really high value for the launch velocity let's say we give something like 3000 Maybe if I go ahead and press play as you can see we are launched in the air so if you had something like a jump pad or something which you wanted to implement this is a really cool way to do this and the best part about all this is this is actually networked by default most of this logic if you just run on the server is just going to run well for multiplayer as well so that's one thing so launch character and stuff like that there are actually many other functions which you would have access to one way to actually take advantage of the context sensitive menu is if you just drag off of self and if you can just head into character you can actually look into various functions over here this is what I find useful you can act apart from launch character few more functions which I would like to go over or Crouch so if you set your movement mode to crouch and make sure you have you can Crouch so there should be an option somewhere here so Crouch should be under character movement can Crouch make sure that is true otherwise it's not gonna work make sure this is true and if you go ahead and hit Crouch and one thing that I would like to show you guys is by setting this hidden in game to false so let this be visible in the game now if I go ahead and take a look at this as you can see everything seems normal here let's actually just disable some of this logic all right so I'll go ahead and Crouch so if I go ahead and Crouch as you can see our capsule whatever we had is actually shrunk this is basically our Collision now so let's say you couldn't pass under some things now you can actually so I'll just drag this a little bit below average character height so let's say about this much and our walking speed is also very less even though we set it to thousand manually now as you can see our Collision is only up to the capsule you can change the height by the way so if I just type in Crouch I should find Crouch half height you can actually increase that no issues with that and as you can see now this has a separate Max walk speed so stuff like this is already implemented for you in the engine now all you have to do if you really want to learn more is just browse through this list just look at something which might be useful so let's say you're doing multiplayer but have a look at this now this is not something which would really be that helpful to be honest but there may be a few settings which you might actually find helpful now there are many many more things which you can do and if you aren't able to actually write a certain mechanic using these nine out of 10 times you're just doing it wrong it's just one out of maybe 10 20 times that the engine is actually deficient of features so just like this you could go ahead and explore this for yourself all of those parameters which we saw in Blueprint are also accessible in C plus plus there is nothing special really so for example let's say I wanted to crouch so I can just type in Crouch as you can see the method Crouch exists here as well ah not only that if I want to access my character movement based functionality there is actually a get function for it so get character movement is the function name so this is going to return a U character movement component pointer so once we actually have access to that so let's say Auto Temp 2 equals okay it's in a different scope so we can reuse temp so Auto Temp equals get character movement and now we can use this variable in order to just call our regular functions so for example if we want to change a movement mode so we can type in whatever the function was over here so movement mode so set movement mode was the function name set movement mode now clearly it's not happy with us using this type but fix for this pointer to incomplete class type so the simple fix for this is to just look up the documentation for the header here we don't have the character movement component header file so we'll just paste that in our dot h and now if you go ahead and look at this this should work and now we get the options for the parameters so for this let's actually type in e movement mode and we have move flying for example and then new custom mode we can just set this to zero so like this you can set the movement mode in C plus plus so stuff like this is going to be analogous to both blueprint as well as C plus plus however note that some of these headers aren't actually included by default so make sure you just go ahead and include them before you start working with them so we are inside the BP player controller class and we have dealt with this before but going a little bit more deeper player controllers or controllers in general are designed to handle input so if we actually bring in an input binding so for example I just type in w on the keyboard so what's going to happen is this input will actually be taken over our input bindings which we set up in a character so if I just print a string we'll actually not move instead we'll be printing hello so that's one thing to note other than that the mouse interface has several important functions such as show mouse cursor enable click events enable mouse over events and stuff like that all these are selfexplanatory one thing to note is that your Pawn or your character obviously is going to be possessed by a player controller and without apply controller you can not actually control your character and all of these are actually set inside your game mode so which black controller class you use is decided by your game mode class which we will talk about soon game mode game State player State and play controller all of these work in conjunction a player controller is going to possess a pawn which you can control now once that said there are a few other functions which are important here such as set input mode game only which will take your game input basically and when you have set input mode game and UI only so in that case you are going to be able to interact with widgets as well as take player input in the game similarly UI only is going to disable your keyboard input entirely so stuff like that functionality regarding input is available in your player controller despite using all of the above mentioned classes it is technically impossible to set up a well playable game so we have a few more classes which actually set up the whole framework to actually start developing the game logic itself and those are game mode game State and the player State now the play State isn't that important but the game mode and game state will provide you with all the functionality that you need in order for your gameplay logic to work so we have already created a game mode know that every level will have one game mode and you have to set that and the important part here is these classes this can be set over here in the world settings and upon class is as as expected BP character however this can be changed at runtime in the sense you can possess a different Pawn the default is going to remain the same but you can call the possess function on your play controller so let me actually show that so let's say I'm on new character right now so now I can't move or do anything however if I head into my game mode and let's say after begin play I just give a delay of few seconds so delay and I give let's say three seconds or two seconds and I get my player controller now note this is a single player game so this works otherwise anything that you do will be with respect to the server game mode in a multiplayer game will only exist on the server that's one thing to note so from here we can type in possess and what we can do is we can just spawn a character so where our player start is you can just copy this over let's say or you can have a Target Point instead so just type in Target point drag this in and get the location so we have something like 10 negative 11420 so head into the game mode class for an actor select BP character for example so BP underscore character and for the transform negative 11 420 and we'll do 350 for the Z and for the pawn this is going to be the pawn which we will possess now if I go ahead and press play wait for two seconds and as you can see we have possessed our BP character so stuff like this you can easily set up in your game mode so anything such as this which is handled on the server is done in the game mode but the game mode isn't really limited to this the game mode has several functions such as post login and you also have other things such as on log out so this is basically when you join the game in a multiplayer game this is basically when you leave the game or you disconnect so you'll still have all the references available to you so that's where you'll use the game mode foreign however let's say you wanted to store something like a timer now the timer has to be in sync with everyone so obviously it has to be on the server but all your other players must be able to read it at least so in that case you use a class known as game state which does the exact same thing so if I just type in game state I'm going to use Game State base game state is basically game State based with a few extra functions so let's call this one DP underscore gamestate oops BP game state open it up and ignore the viewport and stuff doesn't really matter and once you have this over here we can have something like a match timer so I'll create a new variable and call this one timer so I'll make the subtype integer over here we can go ahead and start the timer so set timer by function name we can go ahead and create a simple custom event here so custom event and we can go ahead and call this one for example timer increment you can copy the name paste that in we want it to run every one second we want it to be looping and it has to run till the end of the game so we can do timer plus plus now this uh value of timer over here can be read by your widgets and stuff like that so there's actually a function which you can use for this so let's do that in our widget head into your UI HUD BP HUD and where we have our stuff set up so let's actually revert our character settings so change the character to BP character and over here for the spawn actor as well we'll remove that for now for now we'll forget about it over here where we actually create our HUD this is where we have our reference so what we can do is we can actually create some more text here so we can type in timer so whoops you can type in text drag in some text here maybe just increase the font a bit and we can go ahead and have has to be light anchor it to the top right hand side and instead of this we can go ahead and set this to be whatever the timer is so in our game state every time this happens we have to update it so what we can do is we can get our player controller here we don't have a reference to it currently so get player controller we'd have to cast it to our BP player controller cross to BP player controller now we can do this on begin play and we can store a reference in a multiply again this is not going to work obviously so promote this to variable and type in pcrf maybe for play controller f you can go ahead and update okay we have a update Health function we can create an update timer function so custom event update timer and this should work as is so give the timer value to this so type in timer get a reference to your HUD make sure this is variable and we'll call this one timer text make sure you compile this so timer text set text and we can set this to be whatever this timer reads obviously you can use format text and you can make this show minutes seconds and stuff like that so we have our timer so we can do format text so format text we can have minutes colon seconds something like this so make this in curly braces and our timer by 60 is going to be our minutes and our timer mod 60 is going to be seconds however we also have one more parameter which we need to take care of is if this value is less than 10 we want to append a 0 at the start so divide so rather convert this to a string first so to string and once we have the string we can check if this is actually less than 10 and if it is less than 10 you can use a select instead so select so if it is true and if it's false we need separate things so if this is going to be greater than 10 which means this is going to be false so we directly want to print that out but let's say this is less than 10 we want to append a 0 here so append type in 0 and then we want to print the seconds so some simple logic like this now we can go ahead and test this out and if you were to look at the top right hand corner it does not update because we have to set the game State as well so if I just select BP underscore game State over here and if I go ahead and press play this should technically work but it's not so let's have a look under our BP games that we have our black controller and we are actually not calling the update function so update timer now this function should work as normal so the timer is going to be the value which we get over here and on begin play we can just set the timer to zero so we'll just call the update timer function once I go ahead and press play as you can see our timer works and it increments every second and if we just give it a little bit of time so we have a runtime error here we'll take care of that so it says assessment trying to read property HUD this so this error is in apply controller the reason is uh when the game state is actually created the player controller isn't actually yet created so that's the reason why or rather the player controller is created too but the HUD does not get created so once this begin place called our heart is created so a simple fix for this is to get a validated get and if it is valid we are going to set this text and we shouldn't get any errors now anyways as soon as we create this HUD we can go ahead and update the timer oops update time and we can set it to zero for a timer variable we can actually set it to some higher value right now so that we go ahead and test out the minutes part of it so let's just set this to something 65 it should start at one minute and five seconds so one minute and six seconds seven eight nine ten and our logic works properly so for stuff like this you would use the game state now the game mode is going to drive the actual logic itself behind your game functionality but let's say you wanted to access all the players information you would do that through the player State class so I'll just be vague about it and if you right click in your game State and type get layer array you can actually get an array of player States so you can actually Loop through this in fact and we can get stuff like the player name so get player name and for multiplayer games you can get the unique net ID so for these things basically any details which all players need to have access of at all points of time those are the things which your player state will hold so that's about it basically and one last class that we have left to talk about which is important is going to be our game instance then we can head into more advanced stuff and we can have an example project created unlike all the other classes which we spoke about till now the game instance is kind of special the game instance behaves very differently compared to all of these classes so if I actually just open up my game mode for example so I will open up the main menu first things first maps and our main menu level and now in my uh game mode I'll just go ahead and print stuff so I'll just print host login and I'll just type in log out maybe so log out and we can also have event destroyed event end play so we'll just go ahead and print stuff over here as well so destroyed I'm just doing this in the game mode but this could be in any other class and this is going to be end play all right so if I go ahead and press play right now and if I go ahead and press play as you can see our post login was called and as soon as I close it or rather I should switch levels because if I close the game the logic isn't really going to be executed so I'll just type in open main menu level as you can see our logout function was called so what I'm trying to say here is that this game mode class will not persist between levels so once you log out this game mode reference whatever we have is not going to persist now forget about the game mode reference you can't even access it from anywhere else so let me actually show you guys using the game instance the special thing about the game instance is that when you switch levels your game instance will still remain the same when you open up the game an instance of the game instance is created so basically an object of type game instance is instantiated and that is going to remain the same so go to blueprint Class Type in game instance and over here we can name this our game instance our rgi anything you want you could put a BP underscore you can have a C plus plus class as well but I don't really find the point in having a base class for this one now instead of begin play we'll actually find events such as event in it so this is when your game actually starts so if I go ahead and print this out if I type in init and if I head into my project settings type in game instance I can actually change this to bprgi if I press play and if I press play again or rather I'll head into the level and do it if I press play you'll notice that init isn't even printed here in the console but it was printed way before everything else that's why it's way down at the bottom over there the reason is even before the viewport was properly spawned and even before it started logging stuff the event in it was actually called so the event and it basically refers to when you start the game not when you open up a level or not when you create something else now one thing which I want to show you guys is I'll head into blueprint head into our game instance I'm going to go ahead and call the get game mode function and I'll go ahead and promote this to a variable and let's not name it it's fine and then what I want to do is after a while so let's say I switch from one level to the other now I'm going to go from this level to the main menu level so I'll head into main menu level and in the level blueprint here I'll just access the game instance get game instance and we can cast it to bprji this can always be a pure cast because it will never fail and over here get whatever the variable was called I think it was called new variable zero and we can go ahead and right click and convert this to a validated get we can go ahead and print it and we can say not valid and this is going to be if it is valid so valid so if I go ahead and I'll actually leave a bit of a delay here oops delay let's say about a second not more than that so if I go ahead and head into my level again and if I press play as you can see everything works normally but I'm going to go ahead and type in open main menu level and as you can see I get not valid so what this exactly means is that our game mode object which was created when we loaded the level because game mode objects are specific to a given level as soon as we change the level our BP game mode object was destroyed and whatever game mode we had over here in our main menu level so this is none so it's just going to take game mode base so that object was created however our game instance was still the same so if I actually store a reference to the game instance somewhere else that is still going to be completely valid throughout our game so anything that is persistent between levels you would have it set in the game instance generally you would handle save games and stuff like that through the game instance because even if a player exits a level your save game logic and stuff should be able to work and stuff like settings and all those things are what you would put inside the game instance anything related to file handling will also be put in the game instance and many other things regarding networking uh in general outside the game is going to be in the game instance for example a database you could handle it through the other classes as well but this is going to be the safest way since this class is going to have itself instantiated throughout the program in in our case the game and even when you actually exit the game we have events shutdown rather than event destroyed or event end play so if I just type in print string and if I just exit nothing's really going to happen because the viewport is already destroyed by the time the shutdown is called so stuff like that let's say you had to close out some connections or something you could do that through your event shutdown let's say you have a database or something like that just give give an example anything that's persistent between levels you would use the game instance and one thing which should be obvious by now but I wanted to mention is each player in a multiplayer game will have his own game instance and you cannot put ingame networking code in this you can put networking code but whatever's outside the game if you have any ingame networking code you there is absolutely no reason to use the game instance there is no use of calling rpcs through the game instance since one player's game instance is in nowhere related to the other players game instance so if I actually start two instances of the game let's say I have two players even though they may be connected your game instances will be different so this player will have a different game instance unlike the game State or the game mode where it's going to be common for one game so let's say two players are connected both of them will have one game modern game stat in common which will be created on the server but in a game like this game instances will not be the same so I should have done listen server or client so Standalone in Standalone even game mode game State and classes like that will be different because in Standalone you are not actually connected but in any case your game instances are never associated with each other so with all the knowledge that you have now you should be able to create an entirely complete single player game in Unreal Engine 5. of course you will need to refer the documentation at times at times you will need to mess around with stuff but this much of knowledge should be enough for you to create a complete Game completely functional game using all of unreal score features however I am aware that I didn't touch upon particle effects and audio that sounds uh we will take a look at that when we actually create a practical game I am not a VFX artist nor am a sound design personally so that's the reason I didn't touch over them but we will go over some resources which you can use and I'll just talk about what I do to actually get hands on those resources now that's done we can go ahead and start talking about plugins until now we just implemented plugins which were there in the marketplace or if you have a plugin from GitHub or something you would download it and maybe just paste it inside your project so if I had in here you just create a plugins folder and paste that in there that's simple but what if you wanted to create your own plugin if you wanted to do that and this topic is very less discussed so not many people actually talk about this stuff so you're in luck because we are talking about this in detail now so head into plugins click on ADD and you see many options now we won't be worrying about the editor plugins those are for more advanced users and if you are in a state where you're creating editor plugins I really don't know what is the reason for you to watch this course so we won't be touching upon this we'll be looking at third party libraries later on we'll be looking at blank content only in Blueprint library now blueprint library is selfexplanatory it'll just contain a blueprint function Library let's say you wanted some functions for a vector or something maybe you are implementing another data structure for which you want functions you could have a blueprint Library and content only is basically the type of plugin where you know you'd have models and stuff like that without any code basically but the one which we'll be doing is blank and just give an author name in my case I'll give gaming and description this is my first plugin well it's not but just for the sake of giving a description and let's call this one test plugin and go ahead and create it so the plugin has been created and we have Visual Studio open however before we actually start working on it I want to touch upon one topic that is the build.cs file basically everything you have in the engine is divided into modules so the core functionality of the engine is like core choreo object and engine so now that you have actually created your plugin your plugin as well will have a build.cs file if actually open the folder over there so plugins test plugin and if I head into Source test plugin I have a build.cs file here and I have content binary stuff like that so what this basically is is this plugin itself is actually a modulant in itself so if I want to use this plugin in C plus plus let's say I should go ahead and include that module so I can do that by typing in a comma and we can type in test plugin this concept will be more clear once we actually Implement a thirdparty libraries when we Implement a thirdparty Library you actually have a separate module for the library as well as your plugin as a whole basically a plugin acts as a wrapper so that it can interface with Unreal Engine because unreal standard API does differ a little bit compared to your standard C plus plus what you do generally so you'd use the plugin as sort of a wrapper to you know interconvert types so let's say you wanted to convert all the STD strings into s f strings which is there in unreal so stuff like that so you would have the plugin as a wrapper and you would interface that uh through the plugin inside the engine so let's actually take a look at our plugin now now that we have a basic idea of build.cs in our editor we already have our test plugin content folder open we can work with this normally but anything we created uh inside here will be actually packaged inside our plugin so for example let's create an actor class so let's just call it some actor and whoops and we can make it do something let's say so for example let's say we have some logic so let's say every frame it just prints out something obviously you would have some more practical logic in here so let me go ahead and type something so let's say our actor is ticking something like that and we could go ahead and have C plus plus classes as well so over here under Tools you can create new C plus class I'm just showing you guys how to do it because we did go over the blueprint itself so you know how to work with blueprint it's just that you're creating it inside this directory and I'll show you guys how to reuse it in another project so head into tools new C plus plus class just like how we would let's say you wanted to create an interface so I just took an example and instead of my interface we can call this one R plugin interface and instead of beginner course you can type in test plugin because this is a separate module in itself and now if I go ahead and create the class you would see that under our source or rather under our plugins folder so I'll just reload the solution under a plugins folder under the source folder now you should be able to see our interface so now you can work with this just like how we would with another file so this is how you would actually go about doing it so now if I just go ahead and close this and rather I'll just close the editor and remember guys make sure your plugin is enabled here if you are not able to see it in the editor make sure you enable this so what you can do is first of all let's see if it actually builds successfully so we'll just create a new function so it's going to be a virtual function because we want to override so virtual void test function and we can go ahead and leave it as is we don't really require a default implementation but we will have one anyways so right click quick actions and create a default implementation and now we should be able to implement this interface so let's make this a u function so you function your function and just to make our job a little bit easier we'll just make it a blueprint implementable event so that we can actually just give the logic in Blueprint itself so this works and now if I just go ahead and build this you should see that both this plugin as well as our whole project will be actually built so it says blueprint implementable events in interfaces must not be declared virtual let's just fix that and now it should build as is just make sure you don't have a definition here because it will look for the definition in Blueprint now let's say I wanted to use this in another project this is how you would go about doing this so open up your editor head into the plugin section again and where you have your plugin over here under project other click on package just select a random folder I'll just select my documents for example and go ahead and package the plugin it will take a little bit of time but once that's done you should be able to implement that in another project so meanwhile while this is actually compiling we can go ahead and create another project so open up your epic games launcher so our packaging is actually complete before the launcher loaded up so you can actually check it in our documents folder so head into test test plugin and you should be able to use this in your projects and I'll show you guys how to do that so just ignore that head into Library let's actually just launch the engine as is and over here we can go ahead and just create a new project so we'll just create a blank project blank with nothing I'll just create blueprint and for the project name uh okay we do have a C plus plus class so it might actually want to rebuild stuff once again so anyways what we'll do is we can create a C plus plus project call this one plugin test and we can go ahead and create it so I'll show you guys how to implement it both in Blueprint and C plus anyways now that we are actually in the process of creating it so it should take a while but eventually once the project is opened up we should be able to import the plugin just like that and I'll show you guys what steps you need to take in order to actually get this in the plugins list now our project has been created so we are in a blank level just we'll just go ahead and create a new map and let's just call this one some level open it up save it and make this the default project settings maps and modes make this the default so that should be good and if you open up your Visual Studio which we will open later we'll close this up and close the editor as well and beginner course will just minimize that for now if I head into my file explorer what I can do is I can copy this over and where I have my other project so I believe I created it under unreal project so plug and test and what you want to do is you want to create a new folder called plugins and paste this over there now what I want you guys to do is right click generate Visual Studio project files so this is actually going to integrate it and once you're done with that if you want to use the plugin content in C plus all you have to do is head into source plugin test and under plugin test build.cs we don't actually need to come here actually this is for the plugin what's the plugin using so what you have to do is head into your plugin test rather I mean the project head into Source plugin test build.cs and over here so I meant I meant to come here so over here what I want you guys to do is where we have our modules I want you guys to add test plugin uh just don't get confused plugin test is our unreal project name and test plugin is our plugin name and now I'll show you guys how to implement it so we can go ahead and build this once again so we'll close everything up and we'll just generate the visual studio project files once again and we'll close our beginner course we'll open it up and we'll just create one C plus plus class and maybe a blueprint class so we'll do blueprint first since we are opening the editor anyways so we have some level and if we actually go ahead and create something so let me just create an actor if I head into all classes and if I type in so I'm not sure what I called it so we can head into plugins and check test plugin content some actor so some actor as you can see we get some actor now if you're not getting this it simply means that you haven't enabled it in your plugins so under installed other you should have test plugin and you should have your author name and stuff like that so make sure you have this enabled over here and now if I go ahead and drag this in the world and if I press play as you can see our code which we had in our actor is now working in the other project similarly we can use the interface as well so over here under class settings implemented interfaces we can go ahead and look for our interface I think we called it our plugin interface and we have our test function which we can Implement and we can go ahead and tell something so you could just say test function called in order to implement this however we would require C plus plus since we actually didn't make this blueprint callable however we can still choose to edit it in the source order so if I just head into our source and if I actually go ahead and edit the CPP file we can actually rather in the plugins folder test plugin if I head into the source folder and edit the CPP file or rather the dot hatch file and add the blueprint callable specifier I would still be able to you know use this over here but anyways we will implement it in some class which we create here so I'll just go ahead and close Visual Studio here and I'll go ahead and create something so we can create a new C plus class of type actor we are able to implement this but we can't call it that's the reason we're actually doing it so we'll just call it my actor for now and go ahead and create it so live coding should do its thing so our file should in fact open up in a new window right now and go ahead and just don't mind it opened up in a separate window and now we can feel free to go ahead and include our interface just gone ahead and reopened the solution file here now inside my actor.h since we included the module in the build.cs file we should simply be able to include r plugin interface.h now you should be simply able to inherit the interface by using public I or my R plugin interface and now we have successfully inherited the interface now the since this was a blueprint implementable event you can just go ahead and use it in Blueprint itself and just to make things a bit convenient for us we can head into our R plugin interface.h file under the plugins folder and we can add in the blueprint callable flag so now we can go ahead and actually call it from the blueprint so we can go ahead and run a debugger now so this is how you implement it in C plus plus my main intention here was to show how to include the header file rather than using the interface that is something which we already covered so wait for the editor to load and once the editor is loaded in what we can do is we can go ahead and create a new blueprint class and we can remove this actor first of all otherwise it'll keep printing our actor sticking so go ahead select actor we'll leave this at new blueprint one add this and under the parent class or we could have done it over there itself and select my actor and now again we have our test function and we can again go ahead and Implement our event so we can go ahead and print something let's say test function called or we could have gone ahead and inherited uh my actor instead of some actor here but then again you would have to change some other stuff so we'll just redo this and now if I go ahead and press play nothing's gonna happen headed to your level blueprint and for example just go ahead and get a reference to it and now if I just call in test function test function message this is what we want and now if I go ahead and press play you see we get test function called so this is basically how you do it guys so this is basically how you would use a plugin which you made and implement it in another project and as you guys saw you can absolutely feel free to edit the plugin contents once you have pasted it in this plugin folder foreign libraries now there is one thing to understand before we actually head into implementing them and that is that there are differences between your standard C plus plus API and the unreal C plus plus API a very simple example would be the difference between STD string and F string so in unreal you use F string whereas in standard C plus plus you generally use STD string now interconverting between them is really easy so if you want to implement a third party Library the way you would do it is you would build your third party library inside of a plugin so basically you would put it in a separate folder and I will show you guys the procedure so nothing to worry about that and the the unreal plugin which you will create will act as a wrapper to kind of you know interface between the standard C plus plus and unreal C plus plus API so the way you do it is again create create a new plugin first select this third party Library template because it has most of the important things that you would need in order to actually set it up so again I'll just put gaming for the author and I'll just call it some third party Library Library plugin and over here we can just call this one TPL underscore Plugin or something like that so third party Library plugin so go ahead and create it so now this dialog box should appear over here a rather message box and we'll just click open or okay so basically that was just some code which was written in the example Library now over here we shall not be using their Library so they have actually provided us with a library which we can use as a reference so if I add into plugins TPL plugin Source you see there are two folders here now third part is the folder where you'll have your third party library and TPL plugin is the folder where you would you know have your plugin content and anything uh under this folder would be edited in your project solution file and I'll show you guys what I mean so right now heading to third party third party plugin live plugin Library so what we can do is over here as you can see there is an example Library now whichever file says example Library dot something that is basically your actual third party Library so in order to implement our own third party Library we can go ahead and delete whatever they have put over here so we don't need any of this so this is just an example and what they have done is they've used a dll but I'll be showing you guys how to implement a static library and a dll separately so we'll do a static one first so I'll just go ahead and delete all of this now what we are left with is a blank uh folder with just the build.cs file so what you want to do now is open up visual studio and over here you can go ahead and create a new project of type static Library and click next and we'll just call this I don't know test third party library or something so test third party liability so we'll create it under a g repositories or rather we'll just select our solution folder so we'll go ahead and select our beginner course head into the plugins folder PPL plugin Source third party third part TPL plugin Library select this folder and what we can do here is we can check Place solution and project in the same directory so we would have all those project files as they appeared in the example so go ahead and press create now you should see that our library is actually created so if I go ahead and open up this folder over here as you see this folder has been created it's not necessary that you have it over here so you can just go ahead cut this and paste this over here and you can go ahead and delete this folder so it's open in visual studio so I'll just close everything so I'll just save it so we can just cut this and paste it over here so we shouldn't have opened that so we'll just replace it as of now nothing should happen now once you're done with this we can open up our build.cs file and over here you would notice that we have a bunch of stuff which you seriously which I seriously don't expect you to understand uh basically these are for Linux and Mac so you can just go ahead and delete this I'm not going to be showing how to work with DOT so files and stuff so I'm not really a Linux guy so we'll just be working with our Windows Library so we'll not do the dll now so I'll just comment this out we'll do the dll a bit later and what this is is this is basically our library directory and the library file itself now example library.lib was the file which they had created so whatever example Library they had that file was named example library.lib but ours isn't yet here so we can just go ahead and add in some sample code so that we can actually create it so head in here change the configuration to release first things first and head into source files add a new item and over here you can go ahead and create a DOT hatch file because we will need some sort of a header to include it so we can just type in test class we'll just create a class so testclass.h maybe you can create some static method inside and over here uh we can actually move this over to the header file section right click on source file add new item head of source CPP file and we can call this one testclass.cpp and once both of these files are open over here we can just start writing our class so we can call this test class and under the public section we can simply have a method so under public and under private we can have a string variable so STD string and we need to include string obviously so hash include string so we have our STD string we'll just create a variable called maybe test string and we can write a Constructor here to just initialize it so what we can do is we can go ahead and create test class and write the definition for the Constructor the reason I'm not doing it in line over here is because I want to show you guys that the lib file is actually doing something so if we have the definition right here so we wouldn't really need the library file now I can go ahead and create the definition for it and what we can do now is under this we can go ahead and just initialize our string so we can say test string equals this is some test string doesn't really matter what you put in there and we can just have a method so we can have STD string get name maybe now this is going to return that string basically so we can go ahead and test that so we can go ahead and return test string now this should be about it for this so before you go ahead and build it just set up this pch.h file and stuff so go ahead over here instead of test class dot head just include this pch.h and what you would want to do is you would want to come here and just include your test class dot Edge over here so now this should compile so if I go ahead and press build make sure it's in release configuration and it should work so now if you were to head into your TPL plugin Library folder now under this x64 folder which has been created you should find your dot lib file don't worry about all these other files just go ahead and copy this file name which will be the same as your library files name I mean your libraries name so test third partylibrary.lib that is the file which we want to include so now that we are done with this now we should in theory be able to wrap this using our TPL plugin now this is actually the code for our unreal plugin now inside this we'll actually be writing some code in order to just wrap this class whatever we wrote over there so go ahead and head into your beginner course solution that is your main project solution and now if you head into your test plugin or rather the one which you created now so TPL plugin source TPL plugin and we should be able to actually work with this so we'll just do it inside this header file uh as I showed you for the previous plugin if you want to add in more files and stuff you can do it through the project or we can actually do that actually since we have our solution open anyways I mean our unreal project so over here we can go ahead into tools add a new C plus plus class we don't really require an actor so we'll create an object so object create it and we'll call this one wrapper object and this will just be under my TPL plugin so we can close our solution since it will open it up once again and create the class now if you were to open up your solution you should see a wrapper object.cpp and stuff and one more thing uh this is something which you really don't need so now you can just feel free to head into this function here and just delete all this code and over here as well you can go ahead and just delete this make sure you just have the functions and for this one basically we don't have our example library.h we instead have our test class.h so this will work we don't need it here so we aren't going to use it so you can just leave the rest of it as is and now if we were to continue now but now if I were to go ahead and build this so if I just go ahead and hit build now wait for it and now you notice you actually get errors even though you didn't have any code uh the reason is well we don't actually have our uobject module if you get any errors like this cannot open include file and it's something like this basically it's the same thing you haven't included the module so what you have to do is head into your uh TPL plugin undersource you should find your TPL plugin build.cs file and if you were to recall your main build.cs file that is your projects build.cs file so if I head into Source begin a course beginner course build.cs you see there is a module known as score you object and this isn't there in the TPL plugin build.cs so I'll just go ahead and include that and now it should build successfully so if I just click on build now this should build with absolutely no problems so now we can go about implementing a wrapper object basically we are trying to get our test class to work with our actual code here so I'll just do it under the public section so whenever this uh your object that is your wrapper object will be instantiated I want our actual thirdparty Library object to be instantiated as well so we can go ahead and type in test class class obj equals we had a default Constructor so we'll just call that and the reason we get errors is because we haven't included the header so we can get TPL plugin Library so Library and we call it testclass.h now we shouldn't get that error now we should be able to create our object and now we can go about writing our functions for it so the only difference in the main with the standard C plus plus API and unreals API in our example is that we used STD string over there but we want to use F string so we can write a u function for it so your function we can just call it get name and the return type is going to be F string of course and we can create a definition for it create a definition open it up and inside the F string Constructor we can get our object obj dot get name Dot cstr so C Str so this is how we can just convert it now this is something related to the conversion you can just look into the documentation or the Forum so this is how we would go about converting it and we'll make this one blueprint callable as well just so that we can test it in Blueprint are now successfully we have translated our standard C plus plus function in our third party library and this is now usable in unreal so if I just go ahead and run a debugger here inside our project now we can ignore this and we can head into content and we'll just do it under blueprints go ahead create a new blueprint class and this will be of type wrapper object so we don't find it and we forgot to make this blueprint table once again no issues we can make this blueprint table and you can make it blueprint type as well if you wish so we can go ahead and restart the editor now and now under content blueprints if I right click create a blueprint class and type in wrapper object we should get a wrapper object and we can go ahead and just call it BP underscore wrapper so this is our wrapper class basically now if I were to actually go ahead and call the function we can actually do that so we'll instantiate the object and call it so our function was called get name oops get name call function get name Target is wrapper object and we get a string so we can go ahead and test this method out so in our level blueprint we'll just construct an object so we can ignore this we can go ahead and construct object from class and we can construct our wrapper object so BP wrapper we didn't really need it to be honest but anyways we can go ahead and call the function get name once it's successfully constructed and we can print strings so that we can check if it works so now if I go ahead and press play as you would see I get this is some test string and this is exactly what we put in our third party Library so if I head into third party testclass dot CPP as you can see we had our STD string and we actually called this method through our wrapper class so this is basically how you implement a thirdparty static Library so now let's get to dlls now working with dlls is going to be a little more tedious and if you were to take my opinion in Unreal Engine at least it's really not worth the hassle to work with dlls I always prefer just working with you know static libraries or any unreal native plugins but anyways I'll just show you guys with the example itself the procedure is the same head into plugins click on ADD thirdparty library and we'll just call this gamium and plugin name let's just call it dll test so we're going to create the plugin and it should take us into Visual Studio so we get this message box here so which is from uh the functions given in the dll so just head into your solution Explorer add under your plugins you should find a dll test plugin and if you open up your third party folder you should be able to see the code now we'll just be modifying it in here so we'll just call a function so example Library function let's just head into the definition this is creating a message box similarly we could just have our own function the important bit over here is the export part so basically you have this macro which is going to export the function now the usage of classes isn't really covered here so I'm just going to do that instead of writing my own function obviously you can implement the same thing with your own dll but remember uh the changes to the build.cs files which you have to make so under plugins dll test Source dll test or other third party dll test library and in this build.cs file again you will probably have to change a few parts you can remove this if you are working on your windows so this is over here just change the file name to whatever your dll is and over here for the lib file as well just make sure you change it to whatever your file name is even here as well just do those changes and you should be good to go and the addition of modules will still remain the same so you will still have to include choreo object and stuff we'll do that so not to worry so if you want to actually export a class you would have to do it right here in the dot hatch file you can have the definition separately in the CPP file but I'll show you guys how to actually do it so the way you do it for classes is a bit different for functions you can follow this example and move on but over here let's say I want a class so I can do example Library export now I am assuming we are developing for Windows so I'll just go ahead and delete all these alifs so I won't be having any of that so I'll only have the macro declared even over here as well so I I'll just go ahead and remove all of this and I'm just assuming that everything is for Windows so with that assumption let's continue now if you want a class we can go ahead and declare it and one more thing in your dot h file as well make sure you just have this macro if you want to work with class if you're working only with functions you don't really require so now what you want to do is let's just call this one test class and over here we can go ahead and have some methods so let's say in get num or something and we can have a variable as well so under private we can have in Num and for this we can go ahead and provide a definition for it and one more thing for each definitions so for your class definition here make sure you put in export for methods you would put in import here and export in the definition but since your class definition is here itself make sure you have example Library export or whatever your library name is and we can just go ahead and return num so what we can do is we can write uh we can just say we can just set this to some value what we can do here is we can write a Constructor actually so this class is called test class and we'll just write it in line over here what we can do is num equals can grab in a random number between 0 and 99. so this should work as expected and then I'll get num function should work as well now once you are done with this our dlls example Library should work so what we can do is we can go ahead and before building actually we can create a new file so head into your editor and we can close the solution for now we can build it and close it so we have live coding enabled just ignore that so build it so this should build successfully now if I just head back into my project beginner course and if I head into my you project file here once it loads up you would see the message box as is if you don't want that I'll just show you guys how to disable that if you don't want the message box head into your dll test third party third party library or whatever or rather Source dll test private dlltest.cpp this is the file where it's actually given the function definition so just go ahead open that and edit the file to remove the function definition so let it open up and over here what you would want to do is you would want to remove this function definition so you can remove this and then the message box isn't going to pop up you can remove this as well but that's not going to be called unless it fails so not to worry and even this path as well so if you do require to change it you will have to change it if you are implementing your own make sure you account for all of this so heading back go to tools you see plus plus class all classes object will go ahead and just or we can do actor just to keep things a little more interesting so we can go ahead and create an actor click on next my actor make it under dll test and we can go ahead and create the class so this should open up our solution file and don't mind if live coding fails we'll just close and reopen that not to worry we can go ahead and open the solution file once again so we'll go ahead and close this and once the solution is open we should be able to go ahead and find our file here so under dll test private dlltest.cpp or rather myactor.cpp and we should find all our function definitions and not to worry if you get so many errors it's just to do with the build.cs file once again it's kind of dumb but it's something which you have to deal with so over here make sure you include engine and make sure you include core view object make sure you have these two modules if you want to access gizmet and stuff like that you will need engine if you want to access your your object type you'll need core your object so if you don't have an idea of what contains what you can go ahead and have a look at the engine module in the documentation everything is given over there otherwise you could just follow along so head into now it will build intellisens isn't refreshed yet so head into your myactor.h and we can go ahead and include a header so you can go hash include dll underscore test Library and our header is called example library.h of course if you have your own header that's going to replace this and we shouldn't get any sort of errors here and over here we can just write a function we'll just do it in line so you function make this one blueprint callable to make things simple so blueprint callable and we can call this one void run dll function so I'm not really bothered about the name too much and now what I can do is I can go ahead and write a definition for it we'll just do it over here so from our dll we can go ahead and grab it so the function which we had was called get num so we can go ahead and instantiate an object to that class so our class was called test class just call it obj and we can go ahead and call the function we'll do it in the next line and obj Dot get num we can go ahead and print this by typing in you Kismet system Library print string and we can just pass in at this pointer and we can do F string so it's an integer so from int and this should be good to go now what we can do is we can include Kismet because we don't have the print string function here so hash include Kismet Kismet system Library dot h now this should build successfully assuming we haven't made any mistakes here now it's giving us an error it says test class class type redefinition a simple fix would be just to do pragma once so pragma once and this should build now with no problems now we can go ahead and open up the editor so once we open it up we won't get the message box now because we had disabled that and over here if we just head into a level blueprint for example and make sure under the play mode just change this to Standalone because we had it set to multiply we can go ahead and construct an object from class or rather we can do spawn actors and sets an actor so my actor my actor is what it was called and we can just have a default transform it doesn't really have anything and from this we can go ahead and I'm not sure what the function was called so let me just have a look so our function in my actor was called run dll function so I can go ahead and call that so run dll function so in theory we should get stuff printed over here but this will probably not work now because we haven't actually compiled our library itself which is kind of stupid so heading to dll test so third party dll test Library example Library dot solution and now just click ok and now what you would want to do over here is go ahead and select a release configuration and go ahead and build it oh and yeah make sure you close the editor when doing it that was the error which we got right there now if you were to go ahead and open up your beginner course view project once that's loaded in now we should be able to call the function and it should work as expected so in your level blueprint where you called it run dll function and we can go ahead and click on selected viewport and as you can see we got 95 if I go ahead and play we get 66 and we keep getting random numbers every time so our dll actually worked but if you do want to implement your own it is going to be a little more complicated than this even with just including the one which was provided to us with unreal it was a big hassle so make sure you guys uh avoid using dlls I prefer using static libraries or I restrict myself to those for unreal at least so that's it I guess about third party libraries we can go ahead and talk about multiplayer now it's going to get fun guys now let's talk about networking in Unreal Engine so networking basically in unreal revolves around start topology basically your server client model so basically you have one player or a dedicated machine which acts as a host which we call the server and you have all the other players which are clients now there are two types of servers in Unreal Engine one is a lesson server and another one is a dedicated server in a lesson server the server itself acts as a client as well as the server that is the host whereas in a dedicated server the server only acts as a host and does not have a player controller so these are the two types of servers and basically any data that has to be passed through Network as you can see in this diagram here there is no connection there is no direct connection between two clients always if data has to be passed from client 1 to client 2 or vice versa it has to be routed through the server so that is one thing to note when it comes to networking in Unreal Engine now there are many questions which might arise regarding the efficiency of this and stuff but most games these days work based on this principle and it is in fact very robustly implemented and we will be talking about all the features of unreal networking soon I have brought up my main menu level here and I just want to demonstrate how you are going to join two Standalone games that is two games on separate computers into one so if you aren't familiar net mode will basically let you choose between the types of servers which I talked about play as client is your dedicated server basically and play as listen server is going to be a server which is also a player along with the other clients Place Standalone will basically mean two separate games and that's what we will be doing now what if you wanted to connect between these two so we'll be using the game instance for it so open up your BP game instance now I am recording this a little bit later so that's the reason you may see a few things which you haven't seen so BP rgi and we can just set up a couple of custom events we'll first of all delete all of this we don't need this so I'm not sure we may have broken some reference doesn't matter so we'll just go ahead and fix that so we'll just delete that and now if I head into rgi and I'll create a custom event now basically connecting to a single game is handled by something known as a session so every time your players are connected unreal actually has something known as a session stored internally we aren't going to be diving into the C plus plus part of this we'll just be doing this in Blueprint but please note that if you want finer control over these properties you would want to work with C plus plus so session is basically what is going to allow your players to connect so let's go ahead and create a session so what we can do is we can do something like create Lobby would be inappropriate I'll just call this one create session and we'll go ahead and type in create session and as you see there is an async task over here and if you guys aren't familiar with this clock symbol and a node like this this is an async task and public connections we'll just set that to two for example so to players and player controller this is for lesson servers if you have a dedicated server you don't have to pass in the player controller but in our case we are passing it in so we are going to use the function get player controller and then use Lan is set to false you could do it if you wish and upon success what you can do is you can go ahead and load a level so open level and we can go ahead and open our beginner course level all right and then what we can do is we can go ahead and create a function to join join session all right I would call this one create match so that it sounds a little more familiar join match so what we can do is we can first of all find sessions so type in find sessions these are the only few functions which are there in this Library so that's the reason I'm not really going over them that much so we can get the player controller and what we can do is Max results you can just set it to something like 100 and we're going to check if it's a failure or if it's a success so what we can do is first of all we can get the length so if it's a failure we're just going to print something so we could say failed to join a match and what we can do is we can get the length and if it is greater than zero we'll go ahead and just join the first session obviously you can have your own logic here so each session is going to be one hosted game basically so let's say there are three uh three members in this array or three elements in this array what it basically means is there are three people hosting a match right now that's what it means so now what I can do is I can grab the results and I can get a copy of the first one if the length is greater than 0 and I can go ahead and type in join session all right and here we'll again need to pass in the player controller and note whoops and note that you can only run these session functions either on the player controller or in the game instance you cannot run them on other blueprints it is simply going to fail now once that's done let's say we have no sessions we can go ahead and create a match so create match and on success we don't need to do anything engine will handle it for us over here you can have something like a progress bar or something until on success is called you could probably have some throbber or something like that to show that it's loading same over here so this should be good and something very simple which you could do is inside the main menu so on clicked what I can do is instead of opening it I can grab a reference to my game instance so I can type in get game instance which is a static function and I can cast it to BP rgi this will always succeed I'll just cast it over here I'm not going to bother storing a reference to it as of now and I can go ahead and or actually I'll just do it the right way so I'll just call this one main GI you could call it anything just a reference to our game instance and once we have that we can go ahead and use it and we can go ahead and join match so join match now that that's done if I go ahead and press play if I go ahead and press play here as you can see nothing is really happening but after a while we go ahead and join the session basically we load up the map now now that we have actually created a session and if I press play on the other game here and if I just wait for a while so you would want to disable the input during this time but anyways for now we'll just not do anything you would see that you actually don't join the session the reason is you actually need to be listening for incoming Connections in order to actually be able to join the game and I'll show you guys how to do that over here where you have open level make sure you just put in listen under the options so make sure you do that before you actually do it and one more thing plane editor is crashing my game for some reason so I'm just going to go ahead and I'm going to run this Standalone so Standalone game and Standalone so play Standalone and replace this as a standalone game so I'm not really sure why the issue is happening but this is one way I can test it so if I press play on one of them and if I go ahead and wait so we should land inside a session as expected we are in the level and we are able to do stuff now I'll just go ahead and click on play here in theory if everything is set we should in theory land in the same map so as you can see post login was called on the server and if I were to notice my client has successfully connected over here so as you can see I'm able to play the game like this so this is basically how you connect two clients now let's actually talk about how to set up stuff in multiplayer guys okay then so if we want to work with multiplayer what we can go ahead and do is we'll start with a new level because if I go ahead and press play with two players here and if I actually close the game you see we'll get a few runtime errors now this is mostly because our code isn't really set up for multiplayer and you will soon understand why so basically now what I want you guys to do is head into your Maps folder create a new level and we'll call this one multiplayer testing so go ahead and open it up so this should be a blank level so I'll just grab in a sky and grab in a directional light here and we should have everything set up and maybe if you want we could have fog and we can just create a simple landscape so head into your mode selection landscape and we can go ahead and create it so I'll just do a little bit of noise so that we have a starting point so that we have some sort of a workable landscape so increase the brush size so the strength is a little too much point of I should be fine so let me just go back okay that should be good for us now what we can do is we can go ahead and talk about multiplayer so the main aspects of multiplayer in unreal are replication and remote procedural calls if you are clear with how to use these two concepts it's pretty simple to code a multiplayer game in Unreal Engine it's much more difficult to do it with general knowledge of networking but with unreal's framework it's really very simple to set up multiplayer we'll discuss both blueprint and C plus plus aspects but first the basics now I want you guys to head into blueprints and under here I want you guys to just select your character and your BPA so I guess this one is where we had physics enabled so if we do yep we have physics enabled so I want you guys to just show the problem with this running multiplayer in general so I'll just go ahead and drag this in and what I can do now is I can go ahead and grab a few player starts here so I'll grab one here grab another here and make sure they're all facing the same direction so what I can do is I can make this one 90. so they're all facing towards this ball right there and now what I'm gonna do is I'm going to change the world settings to use our BP game mode and for the player controller we can ignore that we'll still get the runtime errors so what we can do is we can remove this logic so we'll forget about the HUD for now and if I go ahead and press play now you see the ball has fallen down and it's rolling down the hill over there and as you can see I kicked the ball but if you were to notice the ball is in a completely different position so the ball is over there for me and if I actually head near the ball here you'll see that I am not actually going near the ball on my other screen so if I actually turn around my character is somewhere there and my ball is somewhere over there so as you can see both of these are not in sync now this is something related to the widget nothing much to worry about so basically what I'm trying to say is that these two games which are running on separate windows are not in sync but you notice one thing that your characters are in sync so for example if I go ahead and run forward and if I go ahead and run forward over there and if I actually look up you would see that my characters are in sync it's just that the physics object over there is not in sync so the reason this is happening is because in our character if you head into your class defaults and head into the replication tab you see that these two flags called replicate movement and replicates are enabled basically this is unreal's way of telling us that or rather asking us whether we want this particular class to be in sync with all players when instantiated so let's say we instantiate a BP character it will always be in sync obviously there are conditions you have to instantiate it on the server we'll talk about servers and clients soon so let's head into our actor and try to fix it so head into your class defaults and let's try enabling replicate movement and replicates if I compile and if I go ahead and press play as you can see now the ball is rolling down it's near me and as you can see this seems to be in sync if I go ahead and block this as you can see this is almost completely in sync now uh one of my characters flying is due to the movement mode just ignore that but as far as I can see everything is in sync so this is basically how you get stuff to go in sync in a network game in unreal this is the most basic aspect of it you might see that there are a few more Flags here such as always relevant call prereplication Net load on client most of these aren't really important we'll just talk a little bit about net curve distance squared and net dormancy and stuff but most of the times 9 out of 10 times you'll only mess with replicates and replicate movement sometimes you may need your actor to be always relevant let's say it's something important to your gameplay you will have always relevant enabled so once that said let's also talk about net priority basically the higher the value the more priority is given for this to be updated so let's say you have thousands of actors and your bandwidth is insufficient to actually update all the actors the ones with higher priorities will be updated first basically so now that we know the basics of replication let's start syncing up some variables so if I head into my actor and if I go ahead and create a variable so we have some float already and what we'll do is on begin play we'll go ahead and set this to some random value so we'll get random So Random float and what we can also do is we can go ahead and print this string all right so let's look at what happens so let's actually delete some of our other methods here so I guess we had some stuff in our character so we'll just stop calling this function and we'll ignore the spawn actor and I'm not sure if anything else is printing something so we'll ignore the left Mouse Button as well now if I press play as you can see we only get our post login and we have 0.809 and we have 0.43 now clearly this is not what you want you want them to be in sync so if you want variables to be in sync the first thing you'd want to do is you would want to set this replication tab to replicate it now let's go ahead and try that actually so if I press play we still get different values the reason is even though we set the value we need to set it on the server and we also need to wait for the replication cycle to take place basically your value doesn't immediately get replicated instead your value gets replicated in the next replication cycle so every once in a while so in our case if you head into class defaults you see this net update frequency parameter it's set to 100. let's say we set it to something like 10 now this variable will be updated after approximately 0.1 seconds obviously it can be less than that but up to 0.1 seconds if I make it 100 it's going to be up to 0.01 seconds so it's not instantaneous remember that these two players what we play here they are not running on the same machine so you cannot expect the variable to update immediately so what we can do is we can actually set some logic to update this the principle which actually goes into this is the fact that all your replicated variables need to be set on the server so let's go ahead and do that now just a quick note here the event begin play which is there since this actor is replicated each time one computer out of all the players will spawn the actor so for each computer this begin play will be called so if you didn't get what I mean if I actually simply go ahead and print a string so if I go ahead and type in print and if I print hello and if I press play you would notice that the server and the client print hello what that basically means is as soon as the client logged in that is when the client entered the game this actor was born on the client and begin play was called both on the server as well as the client so what we can do is we can check if we are on the server so we can type in a server and we can do a simple if check if we are the server we can go ahead and set this value so we can go ahead and do that and if we are not the server we can go ahead and print it so one more thing we can do is okay this is going to work let's just do it so we can go ahead and print some float and go ahead and press play as you can see the values are the same in case you guys have any doubts regarding that you can go ahead and plug this in directly like this if I press play Let's see 0.718 0.718 the value is the same so basically all your replicated variables need to be set on the server that's the first thing now what if you wanted a client to set the value so your client cannot actually set the value however oh and just another thing this logic is going to work for three players as well so if I go ahead and do this for three players so as you can see all three players have the same value initialize so that's going to work as well okay anyways getting back so let's say now instead of this we wanted a client to actually set the value for us for all the players so the way you do that is through a remote procedural call so replicating variables this is about it there's really nothing much to it so this is basically how you replicate variables I will get to rep notify so let's say you wanted to call a function when a variable has been replicated instead of replicated you can check this rep notify option so then what's going to happen is when the value of the variable is set this function will actually be called on all the clients so if I go ahead and play Let's see we get a Hello as well along with that so we can just type in rep notify so we get whatever string we put over there so basically that basically shows that our replication logic is working that's pretty much it we can have any other functionality for example let's say you have rep notify on a health variable you can update the health bar so something simple like that now let's go ahead and run this logic from the client so let's say we set this on the client and we already saw that that does not really work that well so what you have to do is you have to use a concept known as a remote procedural calls basically they're just custom events meant for multiplayer in Blueprint so type in custom event and we'll call this one set some float some float is the variable name so we just made a setup for it under this replicates tab set this to run on server now what this is going to do is this is going to ensure that this runs on the server so if you call this from an owning client now we will get to the problem with it and if we run it from an owning client we are going to be able to call this on the server so reliable basically means you want it to run in order so let's say you run two rpcs so it's going to run in the same order if it's reliable if it's not reliable the order may change since it's networked it's not instantaneous so stuff like that can happen so now I'll just make this reliable I'll just go ahead and print a string and I'll call this one server RPC so now what we can do is we can go ahead and we'll not do this set with notify we can go ahead and instead of that we can call our set sum float and let's see if we get anything printed now something weird happens as you can see we are not able to actually call this RPC if I were to actually play this and if I open up the output log here as you see it says warning unit driver process remote function no earning connection for actor BPA C1 this is basically the display name of the actor function sum floor set some float will not be processed what has basically happened here is that unreal basically does not know which client actually owns this actor now this actor isn't owned by anyone and if you were to notice this RPC call it says reliable replicated to server if owning client now this if earning clients client section which is there that is what is causing our server RPC to fail now let's do a similar drill but inside a character so if I were to just create an RPC here so I'll just go ahead and create a custom event oops custom event and I'll just call this one as we underscore test something like that and make this one a server RPC reliable go ahead and we'll just print out a string and we can say RPC called RPC called from character now we want to be able to call this from the client instead of big inflations we are in the character anyway so we can use a more elegant solution maybe on a key press so maybe K on the keyboard because we don't have any other things so okay on the keyboard so find it over there so there is K so when we press it this will obviously run on the client which presses the key we can call SV test so go ahead and play this and if I go ahead and press ok it works on the server and if I were to press K on the client it works on the server too I mean obviously it's a server or PC so the function will run on the server but the point is our RPC worked and our client was able to make the server RPC now what if we wanted to be able to call this so from a client so for this you will basically need to have an owner for this the way you do it is through the spawn actor function so if you have just placed it in the level like that you will have to use the set owner method which again I mean if you were to place something in the level it's pretty obvious you wouldn't have an owner for it but let's just see an example where we use the owner so what we can do is okay we already have a span actor function and for the owner here this is something which I did a bit later so for the owner here go ahead and plug in self so spawn an actor doesn't matter the location and stuff doesn't matter we aren't worried about the actual actor itself we are worried about the RPC so make owner self and now what I want you guys to do is run this only on the client so let's say for example we'll again do it on key press so then that's going to be easy for us to manage so we can manually call it so on key plus what we can do and we want to spawn this on the server obviously we don't want to spawn this on the client because it is replicated remember so you have to spawn it on the server itself even spawning cannot be on the client so make sure you spawn it on the server so is server only if it is the server we are going to spawn it and obviously this will run multiple times because for each player which will be spawned this will run so there's no way for us to actually ensure that it happens only once but nothing to worry so we can just grab a reference to this and we'll need to make this replicated if we want access to it from the client so we'll go ahead and promote this to a variable and we'll call this one obj for example and make this replicated so that we can access it from the client and now when we press the K key we can just check if it is valid I mean it will be but just for a safety check if it is valid we can go ahead and call our RPC I don't know what we called it so we called it set some float so we called it set sum plot go ahead and run this now if I were to press play and if I press K on the keyboard as you see we get server RPC printed so if I were to check this we have server RPC over here and let's just test it on the client as well so go ahead and press K as you can see Server RPC is getting printed so we are able to call it on the client basically the ownership is important generally it's a good thing actually that you wouldn't really require to call any rpcs from actors like this generally you would have rpcs in your character game mode game State stuff like that not in the game mode game mode everything is going to run on the server but for the most commonly used classes networking is already set up for you and in case you wanted to use it for an actor like this I have shown you guys how to do it so this is how you do it make sure you just set the owner so let's say I don't actually set the owner and if I go ahead and press play this will still work actually so if I press k this is going to work but if I do it on the client it's not going to work so that's one thing to note from the client the reason this won't work is because now that we do this so let me just set the owner when I set the owner over here now when I press play I have two characters so one is on the server and the other one is on the client and for both of these characters the begin play is going to run so this is going to run both for the server as well as the client so for the first version everything is going to run fine but when this begin play occurs on the client's version of the character even this character will have a begin play on both the server and the client because since this is networked this character will be spawned both on the server and the client so when the RPC takes when the begin place called on the server for this one that is when the owner property starts mattering to us over here if we don't set self in in which case it it will refer to this particular character in the game our logic is not going to work so that was pretty elaborate in my opinion this is probably something which you wouldn't even require that much but this is basically how you do RPC calls now there's one more type of RPC which I want to hint upon and that is multicast what if now we are now that you're on the server what if you wanted to print this for all the players in which case it's really simple type in custom event and we'll just call this one MC underscore print I mean we actually didn't set the float here which is kinda ironic but we'll just do SV underscore print so SV print so we'll print this and we'll just duplicate this over here and make this a multicast start PC now I generally don't prefer making these reliable generally you would use multicast for things such as particle effects so you wouldn't really need reliable but anyways I'll just do it for this example and we'll call this one multicast so we'll just call MC print and remember multicast star PCS have to be called on the server if they are not called on the server it will only run on that client so it's not going to run on all the others so if I were to press play as you can see we get multicast RPC so this is basically how we would go about doing this now this worked on the servers instance uh obviously because we spawned it over here otherwise it wouldn't work so if I were to just go ahead and press play you would see it works and if we had more players it's going to work again if at three players it's going to print it multiple times so it's going to print it on the server client one and client so we have server RPC multicast RPC and stuff works like that so this is basically how you would go about calling rpcs so you have SV print which is routed to the server and we can actually test that out rather than doing it on begin play that is kind of an incorrect way obviously I showed you guys the right way to do it so this is some sort of logic which you would never use so we'll just ignore all of this go ahead and press play if I press K on the keyboard you see we are calling the RPC if I press K on the client it works as well if I press K on the other client it works as well and all of the players can see the printed string now you can also have the logic the other way around so let's say you are the server and then let's say for example I'm just taking an example here let's say when the game starts you wanted to show a countdown and the widget obviously will be spawned on the individual clients because obviously it's a widget so it has to be spawned on the particular client's computer so for that you will again use a client RPC so I'll just do it over here so let's say when I press the K key we will test this on the server itself client rpcs can only be run from that owning client or the server if you run a client RPC from another client it's not really going to work so in order to do that we'll just create an RPC so we'll make this one cl underscore test and make this run on owning client and what I can do now is I can go ahead and print a string and let let this just be there so if I do CL underscore test and if I were to press play if I actually press K here RPC called from character runs on the server over here as well this runs on the client and over here as well this runs on the client so this is basically how you do it it'll just run on the client but what if you wanted to run this from the server so if you do this through a server RPC it is going to be routed through the server so I'll just do that and show you guys so what we'll just do is we'll just uh diyte ourselves so we can say SV test and this will run on the server we can have another print string and we'll call This One SV for server and over here instead of that we'll call the server RPC and now what we can do is once this is printed we can go ahead and call the client RPC so CL test now if you were to notice if I go ahead and press play if I press K as you can see now both are called on the server so the server RPC work and the client RPC worked but if I do this on a client as you can see the server printed SV and the server again called a function on this client so this is basically how you would go about using client rpcs so for any multiplayer logic this is exactly how you would go about doing this in C plus plus this logic is pretty straightforward there's just a few additional steps for rep notify and uh replicating variables but other than that even the C plus plus part is pretty straightforward so generally you would use blueprint itself for core multiplayer logic unless it's something uh you know fundamental to your game and you want it to work properly like let's say you had like a firing mechanic or something and you don't want any sort of performance issues or any overheads you then you would use C plus plus otherwise you would really just use blueprint for most of the things because it makes things so simple as you can see you don't have to do stuff like opening ports and stuff so all of that is handled by unreal and now let's go ahead and see how to run rpcs in C plus plus thank you now I've gone ahead and opened up visual studio now we'll just ignore the plugins part right now and we'll head into our source folder beginner course public and we'll head into first of all we'll head into a character now what I want you guys to do here is first of all before you actually use any networking feature just make sure you include net slash unrealnetwork.h dot h make sure you include this header if you do not include this header you will get all sorts of weird errors so make sure you do that now first things first let's talk about variable replication so if you want a variable to be replicated uh you basically have to make it a U property first things first and this one will give the specified blueprint read right as usual to make things simple for us and one more thing which you have to give is you have to give the specifier replicated and we'll make this let's say a float float replicated CPP variable Maybe now one more thing which you have to do this is additional this is not something you have to do in Blueprint but one thing you have to do for the replication logic to work is you have to actually write one function in the CPP file of our character we'll go ahead and do that and then we should be able to make this work directly so I've gone ahead and opened up the documentation so this is the function which we actually need so we can go ahead and copy this and paste it inside our character.cpp files have opened that up and I'll just written a comment called replicating variables go ahead and paste it and we can go ahead and have a definition for it so over here this is going to be acpp underscore character just put your class name followed by the scope resolution operator then you can go ahead and just move everything to one line to keep things clean and over here you would want to run this macro called do rep Lifetime and this takes in two parameters one is the class which is going to be our current class and the variable name the variable name is going to be this oh it's going to be replicated CPP variable now I'm recording this a bit later but one thing that I forgot to mention is make sure you call uh super of this function otherwise you'll get weird classes when you use the weird uh artifacts when you use the derived classes and for the parameter you can just pass this in so make sure you just do that otherwise your movement variables and stuff will not be replicated if you use your BP character so that's one thing to note and now if I were to go ahead and run a debugger we should be able to do it just make sure you close the editor and then run a debugger so as you can see the build succeeded and now we should be in theory able to use this variable as a normal replicated variable in Blueprint so I'll just show you guys replicated variables are shown with those two balls on the top so BP character is inherited from CPP characters so we should have it so if I just type in CPP get replicated CPP variable and as you can see this variable is replicated if I were to actually go ahead and check this variable over here it says cpf net this basically means it's replicated so now this should work like a normal replicated variable now I'll show you guys how to handle our pieces as well so rpcs are simple I'll show you guys how to handle server and multicast rpcs I won't really go over client or PCS they work pretty much the same so I'll go ahead and stop this now and for the for rpcs in C plus plus you need to basically have a u function first of all so create a view function and you cannot make rpcs in C plus plus blueprint callable however you can wrap them inside another function and then make them blueprint callable or whatever so what I'm going to do is I'm going to make call uh put the specifier server and one more thing I am going to make this either reliable or unreliable so this is where you specified so reliable or you can make it unreliable now I can go ahead and actually write something here so let's say void test server RPC underscore CPP just to indicate that this is NC plus plus now what you need to do is you need to Define it over there but also uh rather than defining this you are supposed to Define another function known as the implementation for this so what we are going to do is we are going to just copy this over into the next line This need not be a u function and type in underscore implementation okay just ignore the parentheses there implementation and now what we can do is we can create a definition for this instead so I've already done that so I have the definition for this and we can do something simple such as a print string so you Kismet system Library print string and we can go ahead and print in this is a server RPC from C plus plus now this shouldn't clearly work and if we want to call this RPC what we would do is you can you can just go ahead and call this we don't have to call the implementation we have to call this in order for the implementation to get called on the server or we could just uh do something else such as wrapping it in another function so I'll show you guys both the approaches actually so I'll just do it on begin play so on the gameplay what we'll do is we'll go ahead and we'll actually delete some of this code so we'll delete this and what we can do is over here we can go ahead and check so if we are on the server in fact or if we are not on the server we are going to do it so if is server so I guess it's called GS server I think it's a variable not a method so if this is not a server we are going to call this RPC over here we'll call test server RPC underscore CPP and this will work as expected and we can go ahead and wrap this in a blueprint view function so we'll create a new function make this one blueprint callable and from here what we can do is we can just type in void wrapper for CPP RPC and this one we can just write it like any other function and the RPC will run now what you can do over here is you can go ahead and run this function inside of that so we'll go ahead and call this and since this is blueprint callable we can go ahead and just call this from blueprint also realize that just because of the way the function call works this is not going to run at all no matter what you do it is going to come outside the if so if it comes inside this it's again not going to the condition is again not going to be valid so you're not going to run this function so anyways we'll just run it as is and then we can go ahead and run a debugger so now if I were to actually go ahead and wait for it so once it loads in and I go ahead and press play if I press play right now you'll notice that you get this is a server RPC from C plus plus so we got two server RPC calls one from the client and one from the server now I'll also set up some logic so that we run this during gameplay so under your BP character what we can do is we can run the wrapper so type in wrapper for CPP or PC now if I go ahead and press play and press K on the keyboard as you can see it runs on the server and if I do it on the client that works as well totally as expected now one extra feature which I want to cover in C plus plus rpcs is the validation so if I just type in a comma and type in width okay how my caps lock on with validation now what I can do is I can write a function which returns a Boolean and instead of underscore implementation if I type in underscore validate you can make it so that this function will only run under a certain condition this is especially useful for something like cheat detection so if I were to just create a definition for it and what I can do is if this returns false basically this client which is calling the RPC will get disconnected immediately so I can just do return true for now and this RPC is going to run so if you had something like a health variable or something and you do something like if health is you know less than or equal to 100 and or maybe if you had any other conditions so let's say the health you had a set Health function which is an RPC of course so then you would check if it is less than or equal to 100 because you don't want the player to set the health to a value greater than 100 stuff like this but for now we'll just leave this to true this function will run just to Showcase I'm just going to print string once again so this and we'll call this validate and will not do this on begin play soops print string go ahead and run a debugger and before we do that I'll actually just show you guys how to handle rpcs as well I mean rep notify as well so let's say I wanted to make this rep notify I would use the replicated using flag I will do it after this actually now if I were to go ahead and press play as you would see the validate function was also called on the server so the server is going to validate and accordingly it is going to disconnect the client if the condition is not met so that function whatever we saw right there that has to return true in order for the RPC call to take place successfully and for the client to continue stay connected so this is basically validation and now let's talk about rep notify I am back inside the header file and for rep notify over here you can just go ahead and create a function so what do we call this function this need not be your function but you can make it as well so we'll call this one uh on rep it's just a convention to use on rep but it need not be on rep wrapper for CPP let's say for CPP and this one will just be void no need to return anything you could return a value if you wish but there's really nothing much you can do with it go ahead and write a function definition for it now again what we can do is we can go ahead and just print something so we'll just copy this over and rather than validate we'll just print rep notify from C plus plus so now what we can do is now we can feel free to come in here and rather than typing in replicated type replicated using equals and just pass in the function name so you don't have to pass in anything else and this is going to work as you would expect one thing that you would want to do is wherever you call this function uh that will obviously be on the server make sure you call this function as well separately so where you set the variable so we are setting this replicated CPP variable so we'll do that make sure you call this as well so if you are setting this in Blueprint make sure you make this function a u function and make it blueprint callable so we'll do that actually there's one issue with it in C plus plus this is how we would uh the same this thing works in the same way as it works in Blueprint so we'll just do it on our RPC itself anyways we are running the RPC so in the implementation for it will not have the print string rather we will have our ref notify the way you do that is we'll modify the value of the variable if you modify the value automatically rep notify will be called Equals I'll just type Rand mod 19 I just chose a random number over there and what you want to do is you would want to call this function only over here and the rest will be handled for you now we can go ahead and run a debugger and you would see that our rep notify will be called and rep notify from C plus plus is going to be printed it just works just like that so wait for the editor to load in and once we are inside the editor if I go ahead and press play as you can see rep notify from C plus plus and it was called on the client as well since there are two versions of the character here so one on the client and one on the server both of them called it two times so that's the reason we got four prints and the same thing is going to work when we use the wrapper so if I just type in k for example you see the rep notify works so we get the validate rep notify as well as anything else that you would expect so wrap notify on the server and the client and if you want to do the same in Blueprint so you can go ahead and set our replicated CPP variable to something and you would notice something weird uh first of all I have to do it on the server so we'll do it on a server or PC so SV test rather than doing CL test we'll go ahead and set the value of this variable and we can do SV test go ahead and close this and if I were to press K let's just wait for it as you see this rep notify is only called on the client this is not actually called on the server so in order for rep notified to work again once you do this you will have to type in on rep wrapper for CPP so make sure you actually type that so now if I were to go ahead and press K on the keyboard you see it runs both on the server and the client so there's just one extra step which you have to take in C plus plus that is if you have your replicated variable in C plus plus so that's about it for rep notify I guess we have covered almost all aspects of replication uh multicast is something which I'll just talk about so all the same parameters except or here you would have net multicast so don't mind the spelling I mean the capitalization so I have my caps lock on net multicast and this will work as expected you can again have your reliable and validation and stuff like that uh the rest of it will remain exactly the same so you'll have your implementation and you can have your validate if required but you wouldn't really have a validate for a multicast RPC so I'll just go ahead and delete that and this should work just as expected so I'm not going to really show that this is how you would basically set up a multicast RPC and the documentation is there we did the example for the server there are no syntactical changes to this so it should be totally okay so we'll just delete that definition and I guess then we are done with multiplayer guys now that we are done with covering all aspects of game development in Unreal Engine let's go ahead and actually take a look at how to install Unreal Engine from source so the main part is actually done now we'll be doing a couple of things such as downloading the source looking at how we can build it as well as we'll be going ahead and changing the engine version on our existing project so first of all as I mentioned at the very start of the course make sure you guys do get access to this repository here as of this date the release Branch should have 5.1.0 and you should be able to download the zip file over here so download the zip first of all uh especially when you're installing unreal Source just to avoid you know the permission issues which you are going to get make sure you head into your C drive new folder and just create a folder called unreal Source or something it need not be the C drive just make sure you do it in your SSD if you have one so in my case it's the C drive so that's the reason I'm doing it so I'll just go ahead and install it there so go ahead and extract the files over here under C I'll go ahead and browse the directory over there so see unreal source go ahead extract and extract it under the directory and hit OK now we're just a few steps away in order to install Unreal Engine so first of all go ahead and run your setup batch file and try to run it as an administrator just to ensure it has all the permissions for everything so run the setup batch file as an admin so something like this should show up and once it's completed we'll head into the next step after the setup batch file has completed running you can go ahead and run the generate project files.bat so this file is basically going to generate your Visual Studio solution so let's go ahead and run that again try to run it as an administrator it should work regardless but if you do get any errors just run it as an admin so you should see something like this and this should complete relatively quickly at this point you should be able to see our solution file so go ahead and open it up once the solution is open and you see ready over here at the bottom left hand side what you should do is you should go ahead and head into engine and if it does ask you to install a few more components in Visual Studio make sure you just go ahead and do that just follow along but in my case I've already done that so I'm gonna go ahead right click on you if I and click build now once your build has succeeded under your engine binaries when 64 you should find unreal editor.exe so by default the build configuration is set to development editor if you don't see this it means your build configuration was probably something else and it didn't get built so anyways let's go ahead and open it up and our editor should load up if we do get any errors we can go ahead and debug it now so everything seems to be working fine and it is going to compile some shaders once that's done I'll be right back foreign course project and now I'll show you guys how to change the engine version so headed your beginner course your project file right click switch Unreal Engine version and now you should see Source build at whatever so basically I opened and closed the editor that's it so whatever we did there open unreal editor.exe I just closed it immediately and now I'm back to this location and you should see this so if I hit OK it is going to generate some Visual Studio project files and unless something's horribly wrong it should in theory work out of the box so that's about it and now you can go ahead and just Build Your solution once again because there may be a few API changes which you might have to make so those will be lifted and listed in the output log and as well as in the release notes and the documentation or whatnot so head into your solution now we have switched the Unreal Engine version so now we can go ahead and right click on our beginner course and click on build foreign so we get our first error here and this is actually fairly common so basically we have switched the Unreal Engine version and we have a plugin over here which is based on the older version of the engine there are two ways to fix it one you can head into the marketplace and reinstall the plugin which is meant for 5.1 or I'll just show you guys the way to do it without up using the marketplace so in the marketplace it's really easy you can just go ahead and update the plugin but over here if you really want to just use the same one what you can do is you can head into your engine installation directory so in my case it is C unreal Source Unreal Engine release engine plugins Marketplace uh it's not here because we haven't yet installed so you'll find it there so we'll go to our previous installation program files Unreal Engine this is where I had it ue5.0 engine plugins and you should find Marketplace and the one we are interested in is low entry extended standard Library you don't need to copy it to the engine installation although you could what I'll do is I'll just take it to the plugins folder over here so over here and under inside the U plugin file we'll do the same modifications over here what we are going to do is under the engine version we are going to type in 5.1.0 and now if we go ahead and try to build this once again we shouldn't get that error hopefully so it will take a while and if we do get any errors we'll go ahead and change it or fix those so we have a few errors here and these are mostly the changes which came according to the documentation due to the platform SDK upgrades but it's not really a problem so because I don't think any of you guys unless you guys work for a triple a studio or something I don't think you'll be using this and this is from the plugin this is not something in the engine so nothing to worry so what I can do is we can simply just delete this code and just to return false and even for the Xbox one so we can just do the same thing and I'll tell you guys which file this is it's basically this file right here so in the error list you see platform PS4 whatever so just head into that just double click on that and you will reach there and over here as well so line 264 so I feel like this was it so before changing it was in line to 64. so now it's gone a bit up anyways let's try building this once again and as you can see the build has indeed succeeded but once the plugin actually comes for 5.1 what you can basically do is install 5.1 here like in the epic games launcher install the plugin from the marketplace and then you can go ahead and copy that into the plugins folder in the engine level so what you would do is you would have it over here so see unreal Source release an engine plugins over here you would create a new folder called Marketplace or something and then you would like just copy it in anyways we are not really worried about that right now now what we can do is now that it's built successfully we can go ahead and run a debugger and we should be able to run this in 5.1 so I did show you guys multiple things so the errors which you get will actually depend on what plugins you're using and how's your code base and what changes are made to the engines API itself so depending on that you'll have to look at the output log and the error list and do something and there are a few deprecation warnings as well so if you just have a look so I'm not really sure what this is but this will probably be changed soon once the plugin is updated but right now I'm not really worried since it's just a warning so now I can go ahead and run a debugger all right so our project has opened successfully and it is prompting us to change a few project settings in order to actually use Virtual Shadow maps and nanite so that's not really an issue we can head into the project settings uh and over here under it should in theory be here so platforms so let's just search for platforms it'll be under any one of these so platforms windows and you can go ahead and enable Shader Model 6. and over here we can go ahead and I don't think we'll require Shader Model 5 so that should be about it and now you can go ahead and restart the editor all right so now I've restarted the editor and now we are using Unreal 5.1 so that's about it for installing the source and changing your engine version now there are a few more ways you can handle some of the things such as the plugin part but on the whole this is how you do it and if you do want any more specific references you always have the documentation which you can refer and the release notes are maybe the unreal Slackers Discord server so that's about it foreign ly inside the last section of this course and obviously it is about how to package your game so it used to be very simple before so you just go file package project but now it will probably have to just do it through the project launcher which I will show you guys it's really simple so head into tools project launcher and you can use this but I'm going to be using a custom launch profile so go ahead and add create a custom profile and I'll just walk you guys through each option you can give a name to this profile let's say this is for testing let's hit uh you are building this for testing so you can name this profile testing you can reuse this profile for the next time when you package the game as well packaging basically means you make your game or you turn your game into an executable basically now project is going to be beginner course of course and build configuration so debug and development will be used when you're actually you know testing out your game and you're still not yet at a stage where you can uh send it to other people so your print strings and stuff are gonna work but under shipping uh none of your print strings and stuff will work but it will take a bit longer to build and testing is somewhere in between debug development and shipping so it's below shipping but it's above development and debug basically so you can select any one of these I I'll just select shipping and here these are settings you don't need to worry about and about cooking the content you can do either on the fly or buy the book uh basically what on the Fly uh and buy the book is going to differ in is basically if you do buy the book everything is going to be cooked uh beforehand basically so if you if you're packaging your game for shipping most of the times you will have buy the book and you would select windows if you're developing a Windows game obviously if you have anything else let's say you're making an Android game you would select Android and stuff like that and undercook cultures you'll find English somewhere here so en it should be selected by default so en and you can select your Maps which you want to cook so we're using all so we'll just select all but you can choose to cook only selected Maps but note that if you don't cook a certain map you won't be able to open it in game you're going to get errors your game will probably crash now that's one thing to note now the release DLC patching settings these are some things which I'll not go over and under advanced settings as well so you can go ahead and mess with these so you can enable this if you want all the content to go in a single dot pack file stuff like that and everything is pretty selfexplanatory next package package and store locally then you can go ahead and give it a path so generally I'd like to do it in the project location saved and I'd like to create a folder called staged builds staged builds have used the project launcher in the in the older versions you probably already know what this is and is this just is this build for distribution to the public we have selected shipping so I would assume it is of course it's again your preference do you wish to Archive can select yes or no doesn't really matter and deploy we can select do not deploy because we aren't actually launching the game so if we select do not deploy basically you can launch it through the executable itself so once that's done you can head back and you can click on launch this profile so now once everything has been completed you can head into the directory over there you should find a Windows folder and you should find your executable right there so open it up and you should launch your game so we will end up in this map right here again you can change your project settings and you can change the default map but anyways our purpose here was to check if the game packages and everything seems to be working the physics simulation works and so on so that's pretty much it okay guys so this is going to be the last segment of the course as you guys would know and I hope you guys would have enjoyed the course till now and congratulations if you have completed the course still here and the further part is going to be two hours of me creating an entire game so hopefully you guys will enjoy it uh see you in the engine alright guys so this is the last section of the course and this is not actually going to be about you know learning anything new however in this part I will be live demonstrating without any Cuts how to make an endless Runner such as Temple Run or Subway Surfers or any other which you might have played so we'll be taking the most simple approach or at least as far as my knowledge is concerned if you do have anything simpler you can let me know in the comments and hopefully within an hour we'll be able to make the whole game with the menu animations and all that kind of good stuff so let's get started so let me actually have a stopwatch here so that we have track of our time so I'll just create a game it's going to be third person because we'll have the animation blueprint and stuff but anyways I don't think we'll be using that not to worry uh we'll go with blank actually C plus plus and we'll call this one endless Runner create it now this will take a little bit of time and I do have a couple of things being installed in the background and I also have a list of plugins that I'll be using so you guys will have a pretty good idea of what will actually do with plugins and stuff because in the course I think I just went over these briefly but I went in depth about how to actually create your own plugins and stuff anyways so our project will be created soon and this will compile so until then we can go ahead and open up our epic games launcher head into Library and we can close this editor for now until we add everything so what I what I'll do is I'll go ahead and search these one by one so City subway tunnel so I have to create a separate project for this not going to go over that right now so we'll go construction volume so volume 1 and volume 2 will go ahead and add this to endless Runner we'll add this to endless Runner I'll CL I'll clear the cache later it's just taking up storage and we want Ellie extended so early extend it so we have already installed it to 5.0.3 so nothing to worry about there so Adventure character whoops so this will be the character which we'll be using and it's going to be hella fun ah we don't have time to actually model our own character that's the reason we are doing this so I'll just go over this real quick so FX variety pack not sure if we will get the effect we need but I'll just add it just in case okay I need to download it yet so we're not gonna do that now so window dialog box so I've already installed it so these two so we'll use this for obstacles and stuff and lastly we'll just have some trees maybe at the side we could have something Stone Pine Forest and go ahead and add it once everything is complete now depending on your system if you have a hard drive or something this process is going to be a little bit slow so this is under my unreal project endless Runner so we'll be using the file explorer for this and I'll just delete this later on so now once the engine is loaded up we can start making our game and we'll go ahead and create a Maps folder first so right click Maps will have only one and all the obstacles will be spawned at runtime dynamically when you're playing the game so we don't really care about having multiple Maps but we'll have two so one is going to be your main menu and the other one is going to be the actual map so I'll go ahead and create the map and I'll call this one game map all right save that and go ahead and open the main menu head into project settings and just change that as well so under your maps and modes you should have open world we'll change that to main menu so editor startup map will be main menu and it's going to be main menu again so editor we can start with our game map actually but the game has to start from main menu so just go ahead and click import doesn't really matter all right now over here we can start making our main menu so right click create a new folder and we'll call this one content once again and inside this will actually create stuff because the main content folder is a bit clogged up so we'll call this one UI and we can create a main menu right click user interface widget blueprint create a user widget and we'll call this one main menu or BP underscore main menu and we'll suffix that with a WB to indicate it's a widget and it's going to be just quick and dirty so we'll add a canvas panel here and at the center we'll just have a start button and an exit button so we'll add in a vertical box so vertical box and over here we can go ahead and make this Center aligned first of all Center align position zero with 0.5 for the alignment value so this is going to make sure everything is centered we can go ahead and increase the size a bit even vertically and we can go ahead and add in two buttons so button one and Ctrl D to duplicate we'll make it so that it fills it and we obviously want the play button to be bigger we don't want our users to exit the game anyways we'll add in the the text here so add in some text add in some text and change the background color for both of these buttons make it almost black maybe not exactly black but almost so I like this shade of color now rename this to play or rather start we can try change the font maybe so the font we'll use is going to be the light one so 40 seems about right make this one 40 as well and this one is going to be light and this one is going to be exit so we can add the functionality as well because this is pretty simple so on this button we'll rename this to exit button or it's really not required I guess so on click and for this one as well we are going to add a nonclick this is the start button so I'll just comment this out and for this we can go ahead and execute console command and we can type in exit now our exit button should work we can go ahead and test that first of all we haven't even created the widget so under content we will go ahead and create a new folder and call this one blueprints and we'll have two subfolders here we'll call one as game and the another one as main menu because we'll have different player controllers and stuff for the main menu and the actual game so under main menu right click go ahead and head into blueprint class and create a player controller and we'll call this one BP main menu player controller so this is basically for you know creating the widgets and stuff we'll just use the play controller now under the event graph we can just do it on begin play so we'll create a custom event custom event create main menu and create a widget it's going to be BP main menu widget blueprint and add this to the viewport now we I don't think we really need the reference but we'll just store a reference to it anyways so main menu widget blueprint we'll just have a reference to it and from this we can go ahead and add it to the viewport all right and on begin play we can create the widget so create widget or rather create main menu is the function name so create main menu and now if I compile save it go ahead and press play as you can see nothing happens because we haven't changed the game mode yet so over here we'll create a new game mode so go ahead all classes game mode so we'll create a game mode base so we'll call this one BP underscore main menu game mode now under your world settings go ahead and change your game mode to BP Main menu game mode and over here the player controller can be our BP main menu player controller and now if I go ahead and press play we should get a button start won't do anything but exit is going to work now let's actually head into our game map here so Maps game map will worry about the main menu a bit later so we are in the game up we can go ahead and add our sky so Sky atmosphere Skylight and we can add in our directional light we can also have a fog so we can have exponential height fog and we have everything set up now we could change the time of day as well we'll make this one Dynamic for now so fully Dynamic light because I don't have any time to actually build this so go ahead and rotate it to make it like a morning or evening scene this should be about good not gonna spend too much time on it save it up and over here under content now we can start building the actual level so I'll just go to my blueprints folder here under game I'm going to create the game mode and stuff for this one as well so type in game mode so I'll create gamma BP game mode this one is just going to be called BP game mode because this is for the actual game itself under your world settings go ahead and change that once again so BP underscore game mode will have a CPP game mode if we really require but I'll try to stick with blueprint as much now let's check our time so 10 minutes in now under your game mode will also have a game state to counter score and stuff so game state so game stead base BP underscore game state so we have our game mode oops and we have our game state and now we can also have our character and stuff so we can create that first of all we can just right click blueprint class character and we can type in BP character open it up and we have some basic things already set up for this mesh we'll be using one of these which you bought under man under mesh full we have all these various options so we have four options so we'll be using these four so these four will be the options for the players to choose from That's How we'll do it so we'll create a derived class for this for BP character so under our characters what we can do is I can type in character I'll just move this here and go ahead and type in subclasses so these with this is like your main character so every character is going to be a BP character but then we'll specifically make them choose a mesh so go ahead and create a blueprint Class Type in character and over here we can make it of type BP character and call this one character one we can actually just name them maybe we'll call one Adam duplicate that we'll call One John I'm just giving generic names we had four so we can call one Json and maybe we can call one bill I just chose random names so open this up and for the mesh we can go ahead and start replacing it so head into the location where we had the mesh so this is going to be a first character we'll set up the animation blueprint a bit later so it's a bit off but not to worry we can go ahead and adjust that negative 90. and we can head into the other classes here so under content blueprint game character subclasses we can head into bill and this was called SK manful one so we'll call this SK Man full 2. over here we can select SK Man full three so SK man full three and for this one we can have SK Man full four so SK man full four so that's pretty much all set so I'm not sure if I should just use the default one here so man full one not sure if it'll inherit the transform so I'll just try this I'll compile compile this so if I open the full blueprint editor okay it has inherited the transforms that's a good thing so we don't have to do everything once again all right so we have our character set up uh in our main menu we can go ahead and add a character selection option so head into content uh our actual content folder under the main menu we can have a button somewhere and maybe over here we can type in change character so I'll change the color of this I'm not really worried about the visuals as of now so I'll just go ahead and change this okay I change the color so background color I'll just make this dark again and we can add in some text and we'll call this one change character all right make this a little bit wider so that it's visible for our player so make this one 45 maybe or 35 35 seems good we'll make that one light once again maybe we could make start a bit Bolder so let's start be regular because we want our players to deliberately click Start all right so once you click on the change character menu it should just give us a list and we will create the widget for that now we'll also need a game instance class head into Blueprints and game instances General so we'll create one here so game instance go ahead and call this one main GI or something and under the project settings we can go ahead and change it so game instance oops game instance change that to main GI and over here we can have a variable for selected character and we can change that actually we can change that to be of type BP character class so we have BP character we should see it somewhere here BP character class reference so this is going to be the the character which we have actually selected or we could have it in a struct we'll think about that a bit later now once we have that we can go ahead and start making the actual obstacles and stuff so one thing to note is that we want to make this modular in a way we want to be able to spawn them one after the other let's just go ahead and do that so on when the game starts we want to have a bunch of obstacles and then we'll look at what to do uh we'll work on the obstacles after we work on the animations actually so we'll head into the skeletal mesh we have certain animations so content content blueprint will add into character and we'll create the animation blueprint right here so animation animation blueprint and we'll go ahead and select our ue4 mannequin skeleton this is the one which comes with the pack actually so create and we'll call this one character and MVP open it up and inside this we have a bunch of things so we'll create a state machine doesn't really matter now we can go ahead and have an idle so we'll have idle and we can have we'll create a blank space for this so right click go ahead into animation so basically this is for transitioning between your idle and walk animations blend space and we'll call this one walk run okay over here we'll have few things in the horizontal and the vertical axis horizontal axis is going to be the direction and the vertical axis is going to be the speed so we'll go between 0 and 600 but we'll see if we can do something else a bit later on now open this and we can have our third person walk halfway over here we can have our third person run full way and we can have our third person idle at zero so we transition between these something like this for the direction we'll have a negative 180 and positive 180 obviously so this will be like your angle from your forward Direction that's basically what this is now we can change the animation blueprint after we actually set it up first so for the idle we have our idle animation playing and we should already have this working and we can have this as a new state so walk run we will set up the conditions not to worry oops go ahead and do that so on begin play begin play we can go ahead and get the pawn owner and cast to BP character and we can make this a pure cast because this will succeed or if it doesn't we can go ahead and pull it and once we get access to our character what we can do is we can get access to the speed so get velocity so get velocity and we want the vector length right now we have a vector and we want the magnitude of this vector and we can promote that variable and obviously the magnitude of the Velocity is nothing but speed so speed and we can also have Direction so get actor rotation we'll set it up a bit later actually okay so under the update animation what we can do is we'll need this on every frame so we'll use a reference instead so promote this to a variable and call this one character ref we'll be using this multiple times so we can drag this over there so this will be our speed and also what we can do is we can also get the direction so we can use this function known as calculate Direction and that is what will set the direction to be set Direction so we'll create a new variable called Direction it's going to be a float once again and we're going to set the direction to be equal to whatever this is for the velocity we can just uh grab in or get velocity here and base rotation is going to be the actor's rotation itself so get actor rotation and we can plug this into the velocity as well now what we are basically doing is we're calculating the direction so that we actually input the value correctly in our blend space basically we are not using this value anywhere else so here we can plug in our direction and speed so Direction and speed so these were our vertical and horizontal axis values in our blend space we can also have jump which we will do we have we don't have a state transition so if speed is greater than let's say 10 we can go ahead and transition and over here as well if the speed is less than 10 we can transition so rather speed so speed is less than or equal to 10. we can go ahead and transition into this state so now we shouldn't have any of those warnings all right now if I actually create something here so I'll just create a player start so we'll know where to start so player start and I'll just go ahead and box out a simple level so shapes so I'll have a cube and I'll just make this really really big so this is just for testing purposes and for the default Pawn class I'm going to select BP character and let's set up the animation blueprint over here if we go ahead and select our character anime nmbp in theory everything should work fine so our camera is a bit off that's nothing to worry about so under our BP character we need to set up a camera so add a component and this will be of type camera go ahead and add it we can adjust the view that's nothing to worry about and if I go ahead and press play we have our camera here so we can make that a little bit further back maybe tilt it down a bit and I hope this looks good okay so this looks good so we have access none in our character animation blueprint so that's only in the first frame which is happening basically so we can convert this to a validated get that's a simple fix you can go ahead and turn that into validated get go ahead and press play and now we shouldn't get those errors you can set up our moment logic real quick here so if the characters always going to be moving and I think we might have to change the animation blueprint here because we always want him to be running because we don't want him to stop so we'll always have running actually so sorry for that but anyways something we can do so he'll always be running so this is how he'll always be and we can also have you know a copy of this so we'll just copy this over and we can type in run fast we can make this go at a higher speed so there should be a speed multiplier somewhere here so playback speed is what it's called I assume so playback speed so nothing under the details we'll look into that so there's actually an option called playback speed so we are going to increase the speed and make it so that it's actually as if he's running now what we can do is we can head into the character once again and now that we have him running continuously we'll actually do it so that the obstacles in the world actually go backward you can create the blueprint for that now so we're finally heading into the obstacles so we'll spend 25 minutes not done really really that much and again in the blueprints folder we can go ahead and create a new blueprint class we'll do it in the new folder so we'll call this one course rather this will be the obstacle course basically and we'll create a new actor and we'll call this one obstacle underscore base and we can go ahead and create a child blueprint class and we'll call this one obstacle one obstacle 2 and so on so obstacle 2 duplicate that duplicate that duplicate that will have five we'll see if it if it gets too hectic we'll reduce this number over here we'll need some sort of a base so we can try using some of the things which we got from the content packs so under hanger I guess we had a road I believe I type in Road we have this which is pretty tileable I believe over here Road set we have this so we can use this just that we'll need to know what's the length of this and stuff I don't think we'll go for nanite or anything this is fine so close some of these which we are not using head back into the obstacle base over here we can go ahead and add in a static mesh and this will be common for everything so head back select that and go ahead and put that in so this is there at the origin but not to worry we'll find a way to fix that so it would have been nice if we had multiple Lanes but we have to live with this right now so I'll just go ahead and recenter this I'm not sure how big this is going to be so I think that is pretty well centered we can go ahead and add an arrow component just for a reference so add in an arrow component attached to the root this one is going to be at the origin obviously just rotate that for our reference or we'll keep the rotation to zero we'll look into the rotation and stuff so we'll duplicate this once again so Ctrl D to duplicate and we'll just have one over there I think one is enough but we'll just have it just in case all right so this is exactly at the end now at first we can spawn for example 10 of these and then we can later see what to do we can have something in the side by the way we don't have anything so we'll just add in a plane and for this we can increase the scale of this maybe we can make this 100 I guess okay that's a little too big 50. maybe change it on the Y 50 is a bit too much 40. Maybe 30. 35 2 seems to be about right so it aligned perfectly here and it aligned almost perfectly here as well I can have 32. now this is approximate you can do it accurately when you actually do it so go ahead and duplicate this once again we'll attach it to the root duplicate this will be for the other side all right so we have something on both the sides now if we head into a derived classes we should also have all of those well we can spawn this first of all just for testing it out so open the level blueprint and we can just do a for Loop so for Loop and we can have a loop of length 10 let's say we'll select An Origin we'll start from a certain point so Target point we can start here maybe we'll make the Z value of this zero will make the X and Y 0 as well so this is going to be where we start and we can go ahead and start spawning this further on so we'll have access to this target point now so create a reference to Target point so we are going to spawn actor from class and it's going to be BP obstacle I'm not sure what we called it obstacle base this is for testing so it's fine so it can get active location it's going to be zero I'm aware but in case we wanted to change it the logic should still work that's why I'm using the target point so get actor location we'll break this down actually split the struct PIN now the Y and the Z are going to remain zero so I have to see which is the forward axis here actually so in the obstacle base we have y as the forward axis we can rotate everything by 90 degrees if we don't mind you can just rotate everything by 90. oops we change the location so we can change this to 90. and stuff doesn't seem to be working we'll have y as the forward axis in our case don't mind so the x value is going to be 0. we are going to split the struct PIN so we're going to multiply this multiply this by the index and we can go ahead and split this and the Y is going to be this X and the Z are going to remain zero let's go ahead and just test this out so go ahead selected viewport so if I click f8 and if I were to notice we don't have anything so we should have our Target okay we are taking the target points Y location but we need the last obstacles location so we need the value of this actually we need the location of this Arrow so this Arrow so this arrow is going to be located at negative 3200. so we'll just copy the number we'll just brute force it here so we have the target point that's where we start and into 3200 so it's negative 3200 so I'm not sure if we really need this this is going to be 0 anyways so this into 3200 index into 3200 now let's try this okay so our obstacle course is spawned successfully so a bit of an issue with the direction over there but that's totally okay all right so we have that completed so we spawned our initial course so we can grab in our player start first of all and we can rotate that we can delete one of them we can maybe rotate that negative 90 degrees so now we should face the right direction now move this a little bit to the left so for reference we'll just have one obstacle so we'll just have obstacle base we'll set everything to zero zero zero zero and we'll base the player start accordingly so our player start just disappeared somewhere okay it's up there so we'll click end to Snap It to the Ground go ahead and do that and now we should in theory be centered hopefully yep we will be centered now now if I go ahead and press play as you can see we are centered now we can also set up the logic to move sideways so we can linear interpolate actually so we'll add in Target points so copy the server we'll copy the X location of this so X is going to be 20. we need 20 here and the Y location really should be the same actually again so Y location should be the same now we have got these in the same spot now we can have few more so these two are equally spaced now we can set up some logic so that we slide between these basically head back into the character to set that logic under your BP character if we press the right arrow we won't do changeable controls so right Arrow so right and we can have left as well so keyboard events left under right and left we can change them so if we press right we also need access to which Target point we are at right now we can have all of these in a blueprint we can have these in the game state content blueprints game game state we can type in will have an enum it's going to be simple so content will create enums so enum right click create an enumeration and over here we'll call this one which side of the road you're in basically so I don't I don't even know what to call this e which side I guess I mean which is kind of stupid but at the same time it's descriptive so it's either going to be left okay or at the center by default so I'll have Center first center left and right so if I save that and head back into my game State now I should be able to create a variable of type which side which side e which side so just my naming convention so we'll call this one with side Maybe all right so we'll have access to this at any given instance and on begin play we can store a reference to this get game state we can go ahead and cast to our BP game state and we'll have a reference to that promote that two variable and call this one game State ref okay now from here when we press right we can first of all get access to the variables the first variable which we need is the only variable which we have right now basically which is the side so we'll type in side and we'll do a simple switch so if we are at the center right now we can go to the right if we are at the left right now we can go ahead and head to the left basically uh if we are at the left we can head into the center if we are at the right we don't need to do anything so basically on Center and left we can do that again we'll copy over this logic depending on which side we don't want to do anything if we are on the left side here in this case and we can linear interpolate on tick so a linear interpolate is what we'll just do so we'll type in lurp and we should find a linear interpolate and we should be able to feed in the alpha we'll think about a logic for that now we'll have access to where we are by default we are at the center just took a small break there now over here we can continue with our side switching logic so we'll actually get hold of all the locations and stuff so by default we are over here so if I press play we are over here but when we want to move we want to move to either this or this so we'll actually have a few variables for this I'm going to be hard coding this but you can have a more elegant solution for all of these so I can go ahead and under my game State itself I can have right location right location center location and left location so I'll duplicate this so I'll call this one left location and I'll call this one Center location and we'll manually set these values so this value over here is negative 230 negative 270 and 0. this is the left location so negative 230 negative 270 to 70 and 0. we can actually save some data I Believe by using floats we only need the we only need to linear interpolate the X Direction so we'll just store the X values of this so this is 270 20 and negative 230 not sure if they're spaced equally I'll just have a look at the top view I want them to be spaced equally so between this and this there is a difference of 250 between this and this there is a difference of 250 so yep they are spaced equally okay so the right location is going to be 270. left location is negative 230 and this is going to be 20. so I'll just store these like this now what I can do is I can go ahead and actually move the character so I'll try set actor location not sure if this is going to work so if we are at the center we'll try this to try to set this to the right location so we're going left so left left location so we only want to change the X so go ahead and split the struct pin change the left location and the rest is going to be the actors location itself so get actor location go ahead and split this Y and Z will just remain access all right so we can go ahead and try this so if I press the left Arrow so nothing is really happening here so we can see by printing if something is happening so nope we are not actually taking the input something has to do with the input so Arrow left keyboard not really sure I'll I'll try to use a and d for now so a on the keyboard so we'll use wasd so when I press a on the keyboard we can try that a is going to be instead of the left Arrow all right so we did we don't have access to the game State according to this that's mostly because we didn't set it so that's pretty simple to handle so we can change that to BP game instead now over here we can try the left Arrow logic itself so if I type in left not sure what else we have so left is the only thing we have so we can go ahead and try this so left Arrow doesn't seem to work okay left Arrow works so that was the game State issue not our thing so we can use this logic we can linear interpolate instead or we have our interrupt nodes anyways we can have a variable for the Target location so this is where you know we want to get our character so Target X location just to be precise so linear interpolate is going to be a little tough so F in term 2 is what we'll use it's a pure function so F enter up to f f interrupt to constant because we want it to interpolate in a constant rate so Delta time is going to be Delta seconds interrupt speed we can adjust that so we can promote this to a variable and we can call him sideways speed over here we can replace this with the target X location that's going to be the X oh this is an integer we'll make this float so Target X location and current is going to be our current X location so Target is our Target X current is our current X location so current X location so we can get the actors X location again all right so this should be it for the sideways movement and over here we can go ahead and set these if we want to go left we don't want to do anything when we are on the left side all right we can get the game State and we want to go left so left location and we can duplicate that and if we are right we can get the center location okay but the logic isn't done yet I'll get back to it so we can use a select to just make things a little bit more simple so if we are at the center we'll go left if we are at the right we'll go to the center so the logic should make a lot more sense now and we can set this over there move it in similarly we can copy over this Logic for our right so that it simplifies things a bit so if we are on the right we don't want to do anything we'll go to the center if we are on the left and we'll go to the right if we are on the center so get the right location so this is what we'll set it to all right now our logic should work once if I go ahead and press play so if I put put the left Arrow nothing really seems to be happening let's just check out why okay our end of speed is zero okay so now if I try all right nothing really happens so let's try 100. so our actor location seems to be fine so current and Target is okay and now we can go ahead and print hello so we are not changing the location I assume that's what's happening so when I press the left key on the keyboard and when I press the right key so we are changing the target X and the target Y location so we'll try it without the inter first a little bit of debugging will so we can just copy this in so I'll just remove this logic from tick if I hit left or right nothing really is happening so we can print it and check what's going on all right once again the input isn't working we'll use a so we'll go ahead and use a on the keyboard Maybe go ahead and use a so if I type in a the input okay it's just about the window being in focus all right so if I go ahead and run this okay this works now we can try it with the interp logic so now we don't need this okay the speed is just way too less so we can go a bit crazy on this 50 Maybe nope still very slow 200 okay it's still really slow so 500 . okay this is not going to help whoops it's going 50. so if I make this 500 okay this is a lot better but maybe 1000 would be fine all right so this seems about right but now we need to change our actual State itself so again we'll use this select node right there so if we are in the center we have to set our side so we'll grab a reference to the game state and we'll set the side depending on where we are so if we were at the center and we moved left we'll set our side to left so Center will set it to the left if we were at the left it's going to be left itself if we are at the right we'll make the center copy over the logic Okay so for this so everything will remain the same except when we are on the left and we go right it's going to be Center if we are on the right it's going to remain right if we are at the center it's going to go right okay so now we can go ahead and try this out so something happened with our logic right there okay so we had to get the actors location instead we made it zero so we just sunk under the ground so go ahead right left right left right okay so it is a bit glitchy it is a bit glitchy at times so let's try enabling teleport sometimes that should fix the issue okay when I'm at the right he's moving to the Center for some reason so when I'm at the right and I click right again so the logic is when I'm at the right and I click right again I should still remain at the right when I am at the left I move to the center so let's try that so I go to the right click right again I go to the Center for some reason so when I'm on the right the target shouldn't actually be this it should be the right location itself when I'm on the left this shouldn't be 0 this should be the left location itself because you're doing the inter Pawn tick so that's why it's happening left right and Center all right so now our logic is working totally fine and we can stop printing hello it's just annoying at this point okay then I think we exceeded one hour okay we're pretty close but we are left with our last few steps now we have to make the obstacle move which is pretty simple now we can spawn it dynamically instead rather than spawning it or rather just using this I think we are spawning it yep we are so I can press f8 head into my perspective View and now for the magic head to the obstacle blueprint itself course obstacle base we can try this on tick so on tick we want to set the actor's location so we want to change the location of this actor we will get the current location so get the location of this actor so get actor location and when we move forward we are increasing the y basically so when we move forward we are increasing the Y so the logic was wrong okay when we move forward we are going more towards the negative y direction so what we can do is we can go ahead and move it backwards so we want to increase the Y so the x is going to remain constant the X will be as is delete that split the strut pin Z is going to remain constant but Y is going to be y Plus let's just say 1 times Delta time Delta seconds let's try Delta seconds itself first this should remain constant for All actors because this is tied to frame rate so I think it's moving but it's moving very very slowly yep it is moving as you can see but it's moving very very slowly so we can just go ahead and multiply this so multiply this by some value let's just say we multiply this by 100 so not sure if yep there we have it so as you can notice it's not actually the character that's moving it's the whole obstacle course which is moving and what's weird is our characters actually following it even though we haven't actually attached him over there okay so we can fix the uh X location of the character as well because he seems to be just sliding along so there is actually a setting somewhere here so it shouldn't slide along the surface so something or there character movement Maybe and there is something over here okay ground friction let's try zero on that okay we are just still moving back so if it if I hit f8 actually the whole thing is moving back so instead of that we will just set the uh location the X location every time to be constant or rather the Y location I'm not sure what it was so we'll copy it so Y is negative 270 so negative to 70. I don't want that to change and as you can see our logic is working and it seems like we are moving forward the speed is something which we can worry about a bit later so maybe make this 300 and as you can see it feels like they're actually moving but what's actually happening is the whole course is just moving the character is actually standing still so now our man is going forward we can finally go ahead and set up the obstacles itself I guess and add in a jump State obviously because right now he doesn't jump so we can adjust the speed maybe 350 a little more quick would have been nice go ahead okay with that something we'll worry about later now uh for our next step so I don't think we really require teleport so our X Y and Z is all set so for this we'll be using the jump as well so we'll go ahead and create a binding for our space bar space bar and we'll call this one jump and when I release this we are going to stop jumping okay so now we should in theory just go up we can adjust the settings of the jump under our character movement component and we can also have animations so under our animation blueprint we can set it up so content blueprints game character and MVP we can ignore this and we can add a state and this is going to be jump jump start and jump Loop jump Loop all right so jump start jump Loop and we'll see what animations we have and from our jump Loop we want to go back to our run animation basically so jump start is going to be a third person jump and for the transition we'll have we'll check if we are jumping so if we have our character reference here so is there any variable not sure we can try this okay nothing's really happening okay we are getting a runtime error saying we don't have the character ref so we'll only access this in the anim graph so go ahead if this is valid we will go ahead and okay we can check if it is not valid first of all so we only get it once and occasionally it's going not valid so we can promote this two variable and call this one jumping and in our transition you can set it up okay so the variable isn't doing anything so we can head back to the character and create a variable for it in the first place so jumping now we can go ahead and set this to true we can go ahead and set this to false as soon as we release it get jumping okay this logic should work uh this is jump start to jump Loop so when our time remaining for our jump is less than let's say 0.05 seconds we'll enter this transition and jump Loop to third person run when this jumping is false basically so not not Boolean I guess it's called so we'll just invert the value now if I go ahead and press space okay the animation is weird so we can again do and maybe and if the jump Loop has at least played once so jump Loop so we can get access to the jump Loop here so time remaining time remaining for the jump Loop is less than 0.05 we can try this logic okay we just went into a completely random State there again probably some logical error okay so in our jump Loop we haven't fed the animation okay so our jumping logic is working so we can change this to maybe something a little more smaller 0.02 so this is going to feel a lot smoother okay so we are jumping now we can start adding the actual obstacles under the course we can head into obstacle base and over here we don't want anything this is not something we'll actually be spawning obviously obviously what will spawn is going to be these so under obstacle one we can have stuff I'm not even sure at this point if you're able to see the sides we're barely able to see it and we also need to destroy it once we actually reach a certain point and we also need to keep spawning it basically so wherever our player start is so let's go ahead and add a trigger volume so trigger box so the x is going to be 20. the Y is going to be whatever this is and Z is going to be 0 let's say and we'll just increase the extent of the box maybe 500 500 and 500. okay and we'll set the hidden in game to false so hidden in game is false so f8 so this can go way ahead so a little more so we can select this trigger box and we can do times two by the way that's a pretty handy thing which you can do in Blueprint so just a little bit more so more okay I want to simulate now so go ahead and simulate okay so as soon as we end overlap on this we want to spawn a new one so go ahead on actor and overlap on actor and develop trigger box we'll try to print first okay so as soon as we go out of this first of all for the last index we'll go ahead and promote this to a variable so we'll call this one last spawn obstacle so we'll always have a reference to that go ahead copy this over so spawn actor we will make use of this remember we had our Arrow component so the the arrow which is there opposite to the origin is what we need game course obstacle base so near the origin we have an arrow and over here as well we have an arrow we'll make use of this Arrow so the location of this Arrow so this is called Arrow one so we'll call this one end so that's a little more descriptive under the level blueprint now so we'll get the end so get and so get and and from end we can get uh get the location so get World location and we can probably copy this over just like that and we can change this to this and the rest of the logic should actually work just like that okay so now if we actually wait for this as soon as this goes away one more is going to be spawned but there's another thing uh we want to destroy it uh once we actually go after a certain point we want to actually just destroy it like once we are behind the player we have no reason to still have it so we can have a trigger box for that once again so 500 maybe 500 and 500 go ahead and over here as well we'll set up begin overlap for this instead so on actor beginner so begin overlap on active begin overlap destroy Act okay let's try this out so I'm not sure where this box is let's unhide it so hidden game set to false okay so in theory we should be destroying it okay we destroyed the Box itself so other actors what we have to destroy whoops we need to take this a little more further back so now if we wait for it to reach there so we are continuously spawning the box over there and if I actually head back into my view I cannot see anything happening and our world is spawning normally how cool so over here we can add a couple of things so obstacle one we can add a few shipping containers Maybe oh we can make it random actually that would be nice if we just make this completely random so somewhere at the center I'm not sure where the center is I think it's negative 1600 so this is where the center is going to be oops I moved the end itself so first duplicate it and this is going to be negative 1600 this going to be Center obstacle and we can go ahead and duplicate this and this is not going to be called Center obstacle this is going to be called Left obstacle and we can call this one right obstacle so our right obstacle is going to be to the right obviously and our left obstacle is going to be to the left obviously so this is 250 this negative 250. okay so we have set that up we should have done this in the base actually so we'll cut this and we'll paste this in a base so don't mind that now we should have our obstacle both in the base and the others and obviously the logic is going to be in base itself so since we are randomly spawning it it's totally fine we can use the base itself I assume now in the event graph on event begin play we can go ahead and create a static mesh or rather spawn a static mesh at that location for that we'll need a few actor classes so obstacles over here we can delete this and if we play everything should work however under r under this folder we can make a few actors actually so obstacles we'll call this path actually path underscore base in case we need any derived classes now click on blueprint class actor and this is just going to be obstacle one uh few will be dodgable few will be not so we'll make a dodgeable and nondodgeable obstacles dot double I will just have three for each will create Childs so child Ctrl D Ctrl d and we'll name this one child three so one two three so this one is going to be nondodgeable so we'll go ahead and create a child Ctrl D Ctrl d and this is going to be Child 3 obviously okay so finally we can go ahead and add stuff to these obstacles so optic obstacle dodgeable child one we can instead of the default scene root obviously obstacle dodgable here as well we'll simply have a static mesh so static mesh so that's done I will leave the root it's fine and we can look for some stuff here so we have quite a few meshes so we can have a barrel in one place so we can have boxes we can have barrels we have so many options here so we're going to select this let's say let's try this so in path you want to spawn actor from class so for the class we'll make this obstacle dodgeable so spawn transform is going to be this so oops uh Center obstacle let's try this first so Center obstacle and get word transform go ahead and try this out okay it's just sliding along for some reason and we want to attach it yeah that's the reason so attached to component we want to attach this to our actual plane or we can just uh do it for the root component so now in theory this should work okay so this seems to be working fine uh one more thing we can make this a bit faster actually now we can promote this to variable so speed so we'll make this one 500. okay as soon as we hit something uh we should stop and our game should get over so we'll have event hit here first we'll print something go ahead and test this out so if the other actor is an obstacle pass to obstacle uh we should have made a base class to be honest go ahead and head into content blueprint game course obstacles we'll create one called actor of type obstacle obstacle base and will inherit these from the base classes so class settings so obstacle obstacle base and these will also change so We'll Inherit this from obstacle base so obstacle base obstacle base all right so we can go ahead and cast to obstacle base and we're going to print or rather we can just exit the game execute console command and we'll type in exit let's try this okay our logic is working okay we still hit it so we need a better jumping logic that's that's the problem with our jumping logic it's not our obstacles so under this we can go ahead and change stuff in the character moment so under jump we should have this parameter here so if we change this to 500 for example so now we are able to dodge this obstacle successfully and there are a little bit too far apart I believe these obstacles so what we can do is we can have two actually in each one so go ahead and select all three of these foreign of 3200 so 0.75 into 3200 it's going to be 2400 so at negative 2400 we'll have it and we'll go ahead and duplicate this so these and we'll have these at 800. so we'll have a gap of 1600 between each obstacle and now if I go ahead and press play we have to set up more logic actually so we are spawning the obstacle dodgeable here now we'll make some nondodgeable obstacles as well so set up the nondodgeable one we can have something like a shipping container or something hmm so the way I do it is going to be if I add in a static mesh once again and we'll have a shipping container maybe container okay we have quite a few that's nice let's try with only the nondodgeable one nondodgeable other rotations of go ahead and rotate it by 90 degrees okay so this is not exactly on the floor but we can fix that head into the left view okay it is on the floor not sure why it's not on the floor over there you can try just moving it a bit that about fixed our problem and we obviously should be able to move aside and dodge it so we are spawning obstacles and now we can set up a little bit of logic to make this random a little bit uh for dodgeable we can have few more so for dot double we'll leave it as is child one let it be as is child two we can make something else so this static mesh can be we can look over what we have here can have this roadblock thing and change the logic obviously so dot double I think it was child one so child one child two rather child two open it up I mean it is a bit down but you get the point so change that 10 20 we'll just move all of those by 20 units and for the third one as well we'll just add one now obviously you can go ahead and make more of this I feel like if we have some sort of a traffic cone or something like that so I'm just looking for what I can have so okay these seem like the perfect choice let's try that again forgot to change it so under my path so course path base we can go ahead and change this to child three to test it again it's a bit low but that's not an issue okay I forgot to get the window in Focus once again that's my fault and we have to move it down I believe so move it down by 20 units okay so we have our dodgable obstacles let's set up our nondodgeable obstacles as well so in our child one we can again look for what else we have maybe if we have a truck or something nope uh we can look for what we have so construction volume one meshes so can have a fence yeah that's not a bad idea so this is child one so let's child one be the same let's actually open up child two and let's actually open up child three so these are the ones which we'll try to change over here meshes we will select the fence for one uh the rotation can be zero uh change this nondodgeable child three so it's a little too big so we can scale this down maybe 0.8 okay so I don't think you can dodge this one okay we can dodge it when we move aside so we'll just have one last one so for this one so obstacle Child 2 I will change it right now so child two these are the various obstacles basically nondodgeable child to select that and this is child two I assume yeah so we can look for something else which we may have okay this looks like something interesting or light generator whatever this is let's try that I don't think this should be something which you should be able to dodge okay so that works now we can set up some randomizing logic so that we spawn everything in random so this logic is the same we need to select the class basically first we can select a random integer So Random integer so this is going to be the number of random integer in range actually so this is going to be the number of dodgeable obstacles so we need at least one dodgeable obstacle otherwise the game is going to get unplayable so we can either have one or we can have all the way up to three and what we can do is depending on the number now this is going to be number of dodgeable obstacles what we have so promote this to a variable so number of dodgeable obstacles okay so now that we have this if we have only one what we can do is we can select one so number of dodgable obstacles so we can switch on int and we can select something so so we can start at one so start pin type one if we have only one obstacle our logic is going to be really simple so we'll just select a random one over there we need to do this Two Times by the way or multiple times probably I'm not sure so uh we'll have we'll have more obstacles to be honest these are not enough so we'll space them a little more closer copy these right obstacle left obstacle Center obstacle Ctrl D to duplicate and left obstacle two press Center obstacle to okay we didn't duplicate everything so Center left and right so Center left and right Ctrl D to duplicate okay wait we aren't duplicating anything we'll just duplicate this so okay left Center and right you can move this somewhere in the center right at the center and we can space these two equally apart which I believe they already are are they equally spaced yep but we need to space them out a bit more we have 800 for the spacing here so we can select our obstacle one we can try giving you know negative 600 maybe so if I do negative 400 so that will be way too much space 500 maybe we can try 600. so I have 3200 let's divide it let's take 33 percent of that so calculator so it's somewhere around 1066. so we'll have 600. it's fine if they're not equidistant you can obviously do the math yourself so obstacle this is what we need so one whoops two and three so 3200 minus 600 is going to be 2600. okay now let's see if this works yeah obviously we are not spawning it that's different but now in theory we our logic should work so we can actually Loop through so we can select the number of dodgeable obstacles for each level so we'll have an array of this so we'll create an array so change the type it's fine so we can do for each Loop and for each index we can try and get a random integer so we can set array element so this is the index we can do a simple for Loop so for Loop so from 0 to 2 so size to fit we'll do that and we'd actually want to reserve three locations so one two three so we don't need size to fit so in this index we are going to set this item so for all our three levels we have we know the number of obstacles which will be dodgable once we have that number we can go ahead and spawn them so we can have this in an array and randomize them actually anyways don't worry too much about the logic just my logic which I'm making up um we can select this so we can store these in an array so create an array so promote to variable or you can actually just have an array so what are we using this for we're just using this for the location so we can get the transform of this we can only have the transforms in the array that's that would work I guess so first we'll have the transforms go ahead and create an array for transforms transforms one transforms to transforms three we'll need three arrays so will the location is enough for us so array of vectors transforms to transforms three I know I shouldn't be calling them transforms but we'll take a look at the right obstacle uh the first level ones basically so we have this selected so right obstacle one will will go according to naming order transforms one we'll compile this blueprint so we have three elements we can access it right here so the first one is going to be this I'm not sure if we can paste this see if we can we have right obstacle copy this okay we took that so left obstacle copy this and okay the right and the left have okay they don't so paste one has negative 250 and the center one will have probably will have probably have zero so we'll paste it we'll have zero over here okay and now that we have this let's grab our obstacle tools or obstacle ones so this is negative 600. one two three negative 600 this will be constant so 1 is going to be 250 another one is going to be negative 250. similarly we can grab our two so negative 1600 this is basically our midpoint negative 1600 250 negative 250 and this is about it no once this is done we'll collapse the function so determine number of dodgeable obstacles okay we have the number of dodgeable obstacles now now what we can do is we can Loop through this so for each loop I really wish we could have a two dimensional array for this that would have helped us a lot now what we can do is we can go ahead and randomize this can we not randomize this okay we cannot so we have a plugin which will help us so low entry I can restart save everything all right so back here I think now we should have okay we're coming close to two hours I think this will be done in two hours not one blueprints game uh course pathways and we should have a randomize oops nope we don't so I think we might need a few functions so how do we go about randomizing this we can look at the epic games launcher if we have any plugins so array helpers I guess I had one so we'll go ahead and install this to the engine we can simultaneously use it once we have this so once we actually randomize this uh depending on this we can go ahead and set this so switch on end and will you select for this so just close the editor just to let that happen and now if we go ahead and launch Our Endless Runner okay go to edit plugins so edit plugins and array array helper go ahead and restart so this is the sort of stuff I just hope it doesn't take too long right hopefully we have some sort of a randomized function so randomize okay we still do not have a randomized option option so let's just look for it so randomize array unreal I don't know is it called is it just called something else so okay never mind it's called Shuffle so first of all we'll Shuffle the arrays we'll shuffle all the three we'll do that before we actually set this we'll go ahead Shuffle this go ahead and Shuffle this once again uh we'll put that in the previous function itself so we can go ahead and Shuffle generally I don't recommend you guys uh do array operations in Blueprint but anyways once the slope is completed we can do that and this will go to the return node just for you to understand the flow of logic and now depending on this we can go ahead and spawn them so the array element is going to be the number of obstacles so this switch is going to start from 1 so start index is one you will either have one two or three so if you have one or two way can you select probably copy the server so everything else is zero so we can just leave it as is so we can go ahead and over here if this is one if we have one dot zipper obstacle we can go ahead and spawn just one of them as dodgable so dot double so 1 is going to be dodgable and the spawn transform will just use the first index so we will select so depending on which index it is so transform 1 transform to transform three so option one option two and option three so we'll select any one of these arrays and if we have to spawn only one dot zipple so we can get uh we can get a copy of the first one we'll split the struct pin here and we'll just get this location now we we need to just repeat this logic so Ctrl d and we want to do two nondodgeable ones so dodgeable and index 1 and 2 are going to be Non DOT triple so non dodgable uh we have to spawn a child class of this so you can use the select once again so Random integer and Max is going to be 2. so it's going to be Max S2 so 1 and 2. so it's random number between 0 and Max minus 1 let's just use random integer and range it's a little bit confusing so minimum is zero maximum is 2. okay and this is going to be dodgable so dodgeable obstacle dot double child one child two and child three this is what we have done and for this one this is nondodgeable so we'll copy the logic but instead of dodgeable we'll have nondodgeable so child one child one child two and child three okay and we need this once again so copy over this entire logic all right so this is going to be the same this is going to be for index 2. now if we have 2 we can go ahead and copy this over so Ctrl C and Ctrl V and we can just move this aside so for index 0 it's going to remain the same whoops Ctrl V oops uh copy this Ctrl C and Ctrl V index is still going to remain the same once this is done we need the attach as well we didn't copy over the attach okay so we have to duplicate this whole thing so index is this and index is going to remain the same everywhere so now we need two dot double obstacles so for this one as well we have dodgable and this is going to be index one obviously and for index 2 we can go ahead and have this all right so copy this and again we can pass the index so array index go ahead and pass that in and when we have all three dodgable obstacles uh we'll just go ahead and copy this much Ctrl C and Ctrl V so in case of three this is what we'll do so index is still going to remain the array index Ctrl d and Ctrl d copy this over move the execution pins and the index will obviously just remain the same so the last one is going to remain the same and this is going to be 2 this is going to be 1. and this is going to be 0. so make sure you have 0 1 and 2. okay so now our logic should work and if I were to go ahead and press play okay everything works okay all right so okay we stepped onto something uh we need to make sure this doesn't happen in our first one so okay we have to just ensure that the obstacles aren't spawned in the first one basically so we'll create a Boolean first box so if this is not the first box we'll go ahead and do this so inside the level blueprint under this if we go ahead and refresh nodes uh we have to pass this in so expose on spawn all right so now if I refresh I should get this so only if this is uh index 0 so double equal to zero then this is the first box otherwise it's not okay so now our logic is working let's go ahead and play the game now all right so as you guys can see our game is working as expected we don't have a score yet we'll just set it up quickly so as you can see our logic is working so we can set up a scoring system real quick and dirty here content I will do the start thing also it's really simple so go ahead and open level um we call this one game map I believe so Maps game up go ahead and paste that in or we can start from the main menu go ahead and play start and we started the game so as you can see everything is working as expected you could have some stuff at the side and we'll have a scoring system we can have a timebased scoring system so it's the score is going to go up at a constant rate content will create a widget further so user widget and we'll call this one HUD and we'll we'll just simply have a text so we'll wrap this with a canvas panel and this is going to be our score once we will set the game mode and stuff so game map over here we'll have BP uh we don't have a black controller we'll create that game go ahead head into blueprint class player controller BP underscore player controller so you should have BP player controller so on begin play we can go ahead and create the widget so create widget it's going to be HUD and we can go ahead and add to viewport right so let's look at our time we don't have much I think it'll take probably just a little lower two hours but it'll be done so once we create this we can grab a reference so promote this to a variable and we'll call this one HUD now I don't recommend you guys use bindings but I think in this case just to make this real quick I'll use bindings so we can have game State uh on construct we can get reference to the game state so get game state cast to BP game state and what we can do is we can grab a reference to it and we can create a score variable content blueprint uh blueprint main menu I guess no game so game game state and we can have a score so we'll make this an INT 64. so that we can have larger scores so integer 64. and we can have a timer so set timer by function name and it's going to be something which happens every 0.5 seconds let's say and we are going to increment the score so promote to variable score timer and we can have a custom event increment score or increase I'll call it doesn't matter we'll not worry about that we are going to get the score and we'll set it to score plus 2 maybe Plus set score so we'll go ahead and do that copy this put it in the function name make this looping and we can use a binding here so we can bind this you can get the game state you can make this a validated git this is a little more expensive on your computer so don't do this so we can get the score and we can convert this to text you can use a format text node and stuff I'm not really going over that so we'll just do that actually so format text all right and we don't need to convert this if we press play as you can see our score is increasing at a constant rate and you can see it on the top left hand side for those of you on mobile phones and who are not able to see it I'll just make this text a little bigger so 40 make this one regular we don't need bold and this should be good so as you can see everything is working fine and you can go ahead and set up any logic if you want if you want to like you know save it or whatever but for now I'm happy with this so that's it for this video guys thanks for watching we do have a complete game and instead of exit you can just show the score on a widget or something I will do that let's not leave it halfway the last part before we just complete it so we'll create a widget and we'll call this one end screen okay we'll add a border wrap this with the canvas panel so we can go ahead and wrap with canvas panel and this border should take up the whole thing so offsets are going to be zero and the brush color is going to be something black black Maybe and we can just go ahead and add some text so we need to align it right at the center so vertical box uh we can use an overlay rather overlay is going to be helpful here so overlay so border is going to be filled the overlay is going to be filled as well so 0 0 all right and over here we can have text and there's the advantage of using a canvas panel so 40 can make this regular Maybe then go ahead and put score and we can go ahead and give the value so let's go ahead and set that so event construct get game state cost to our BP game State and we can get access to the score variable get score and we can set the text of this so set the text set text and this is going to be about it we'll format it so format text so this is the score so let's go ahead and Center that make it 0.5 and make everything else 0 here oops uh the size shouldn't have been zero uh make this one central line and the make sure for any vertical alignment which we have okay nope we don't so I'll just reduce the size of this maybe to 100 okay this should be good now if I go ahead and press play nothing will happen because we haven't spawned the end screen uh where we have our event hit in our character so we can cast to obstacle and instead of that we can go ahead and create a widget create a widget end screen and we can add it to the viewport all right let's go ahead and do that so I'm testing the end screen so I'll just die immediately okay so our score is 300 apparently which is nice okay not sure why we didn't exit immediately there uh we need to do once I understood the problem so do once because once we die the game's over don't want to redo that so okay we need to do once from here actually now we just went over the obstacle which was kind of stupid so go ahead and try this out and our score is 280. so that's it for this video guys I hope you guys really enjoyed this entire course I know it's been over 11 hours at this point but hopefully you have learned something new and I hope you enjoyed the last part where we actually made an entire game and we didn't use any C plus plus to be honest so that's about it hope you guys enjoyed and see you guys later goodbye
