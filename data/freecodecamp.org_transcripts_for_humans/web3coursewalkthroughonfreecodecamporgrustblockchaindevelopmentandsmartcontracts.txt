With timestamps:

00:00 - most of you are probably aware that on
00:02 - freecodcamp.org
00:03 - we have a comprehensive and interactive
00:05 - curriculum to help you learn full stack
00:08 - web development well we're constantly
00:10 - adding new certifications and our new
00:12 - web3 curriculum is ready for you to try
00:15 - it's still in development but we now
00:16 - have five integrated projects ready for
00:18 - you to complete
00:20 - in this video you will watch free code
00:21 - camp team members sean and tom complete
00:24 - the projects
00:26 - so get ready to learn more about web3
00:28 - and see if you can follow along with
00:30 - sean and tom as they work through the
00:32 - projects
00:33 - welcome free code camp this is the web 3
00:36 - curriculum tom and i are running through
00:39 - the integrated projects that we have
00:41 - ready
00:42 - and
00:43 - in front of us we have the article that
00:46 - shows you how to run the free code camp
00:48 - uh web3 curriculum in your local vs code
00:50 - setup
00:52 - it walks you through
00:54 - what projects are available as
00:56 - well as how you can run the course
01:00 - once more projects are ready you will be
01:01 - able to sign up for updates
01:03 - and
01:05 - just listen to your emails because once
01:07 - we start releasing
01:09 - you'll get updates on those
01:12 - so
01:13 - to get started we can head to our
01:15 - terminal
01:16 - and we just need to
01:18 - get clone the repo which is in
01:22 - github at free code camp
01:26 - web three curriculum
01:34 - yeah it mentions in the instructions
01:35 - there um
01:37 - kind of specifically what to do i think
01:41 - so there's a few prerequisites obviously
01:43 - uh vs code
01:46 - and then
01:47 - uh docker is the main one i guess
01:49 - because this all runs in docker so
01:53 - you have to install those two things for
01:54 - sure
01:56 - and then once you get those few
01:57 - prerequisites installed in the article
01:59 - then you can i guess just clone the repo
02:01 - and run it or something like that
02:04 - we'll share we'll share a link to the
02:06 - instructions
02:08 - to get it set up in the description
02:10 - there so
02:12 - and once we make sure that we have
02:15 - docker running
02:17 - we can add vs code open up command
02:19 - palette and say remote containers
02:22 - rebuild and reopen in container
02:24 - now this usually does take a while but
02:28 - what i like to do
02:30 - is either go make myself something to
02:32 - drink or just watch
02:34 - the terminal
02:35 - as it builds
02:46 - okay is that it ready
02:49 - yeah i think um
02:51 - this is what i typically see when it's
02:53 - ready is that the last thing it installs
02:56 - that last extension there
02:58 - okay awesome so now we can use the
03:01 - free code
03:02 - camp extension
03:05 - to
03:05 - [Music]
03:06 - run the course
03:12 - first we'll prep the course
03:18 - and you can see what it's doing if you
03:20 - head into the terminal
03:22 - labeled free code cam run course
03:26 - but you really don't need to worry about
03:28 - what's in there
03:32 - so
03:35 - let us
03:37 - again you are introduced with the
03:39 - landing page which describes the course
03:43 - there will be a link to frequently asked
03:45 - questions just in case you get stuck or
03:47 - are confused with how to start
03:50 - as you can see there are quite a few
03:51 - projects that we have coming soon here
03:54 - currently the projects that are ready
03:55 - are what we are calling the integrated
03:57 - projects
03:59 - the integrated projects are like
04:00 - certification projects on the
04:03 - free codecam forward slash learn
04:05 - platform in that
04:07 - you don't learn anything
04:10 - through the course
04:11 - you are prepared through practice
04:13 - projects
04:16 - you get taught the content that you need
04:17 - in order to complete the integrated
04:19 - project so the integration project just
04:20 - has a bunch of user stories that you are
04:22 - expected to
04:23 - complete in order to go through this
04:31 - all right i got this loaded up and what
04:35 - i'm going to try and do is go through
04:37 - this first available project
04:39 - it's called build a video game
04:41 - marketplace blockchain um so you click
04:43 - on it and you come to the instructions
04:46 - here
04:47 - and then it gives you the files there
04:53 - okay
04:54 - so i guess we're gonna create a
04:55 - blockchain for video game marketplace
04:58 - uh where we can buy and sell items and
05:00 - we're gonna work within this folder
05:02 - so i'm gonna just go in there to start
05:08 - and
05:09 - um
05:11 - okay it says json files will store
05:14 - information about your blockchain um
05:16 - there are functions in blockchain
05:17 - helpers for reading and writing to them
05:20 - you'll need to look at those to see what
05:21 - arguments they need and what they do
05:22 - they're already included in the files
05:24 - where you need them
05:26 - um the items you can buy or sell are in
05:28 - items.json
05:31 - so
05:33 - we've got this items.js and i can buy
05:35 - some stuff there
05:38 - many of the files are finished for you
05:40 - you only need to add code in
05:42 - this handful of files
05:45 - and run terminal commands and finish all
05:47 - the user stories and pass the tests
05:52 - okay so
05:55 - your blockchain will be stored in
05:57 - blockchain.json
05:59 - you can initialize by running node init
06:01 - blockchain um
06:03 - okay there's there's just a bunch of
06:04 - users here that'll explain to you what
06:06 - to do
06:08 - um
06:09 - no generate wallets so we can create
06:11 - some wallets
06:15 - yeah
06:17 - mining
06:18 - blocks hashes oh geez there's a lot of
06:21 - stuff here
06:23 - um
06:24 - so
06:28 - these these this blockchain.json is
06:30 - going to hold our blockchain and then we
06:33 - already looked at items um
06:37 - transactions is going to hold
06:38 - transactions and wallets is going to
06:39 - hold wallets and then there's kind of
06:40 - examples here of what they're going to
06:42 - end up looking like
06:44 - blockchain has some things there
06:48 - and etc okay
06:53 - um let's just see if we can't pass one
06:55 - of these
06:58 - tests or something
07:01 - oh
07:02 - look at that
07:04 - that looks good
07:06 - um
07:08 - actually
07:10 - whatever i'll just leave it
07:12 - um
07:14 - first one let's see
07:16 - you can initialize running node in it
07:18 - blockchain should replace everything in
07:21 - blockchain.json with an array that has
07:23 - one object the genesis block it should
07:25 - have a hash property of zero
07:27 - okay i think this one's not too
07:29 - difficult
07:32 - so
07:35 - we've got two helper functions here
07:37 - right blockchain right transactions um
07:40 - should replace everything
07:42 - right block chain
07:52 - and that's this block equals to
07:57 - so obviously the genesis block is the
07:59 - first block in the blockchain which you
08:01 - often have to hard code because you'll
08:03 - find
08:04 - it doesn't have a previous hash so you
08:05 - can't
08:06 - really generate a
08:09 - hash for it
08:13 - yeah so i have a hash of zero and a
08:15 - previous hash of null
08:21 - and then
08:22 - the blockchain we're going to save
08:24 - that but uh
08:27 - blockchain should look like this
08:31 - and i think
08:34 - running that should do that okay
08:40 - we could run it and see what it looks
08:41 - like let me see what does my blockchain
08:43 - look like
08:46 - node
08:48 - blockchain there it is
08:50 - let's see there must be a test that goes
08:52 - along with it
08:54 - um running
08:59 - all right we got the first one to pass
09:02 - should replace everything so same thing
09:05 - replace transactions.json with an empty
09:07 - array um
09:10 - currently it's empty but uh
09:14 - if i go here right transaction so
09:20 - right transactions
09:24 - just like that
09:30 - yeah these helper functions they just
09:32 - kind of write to the file i guess and
09:34 - get things from the files
09:36 - the json
09:38 - if we wanted to see what those helper
09:39 - functions looked like
09:41 - just in case maybe the name doesn't
09:42 - describe them fully
09:44 - where do we see that this is all on this
09:46 - blockchain helpers file um there's a
09:49 - bunch of
09:52 - get and write blockchain
09:54 - um it's pretty much just
10:01 - well there's quite a few here i guess
10:03 - getting balances and stuff um
10:06 - but yeah you um should say here do not
10:09 - change code in this file so you don't
10:10 - need to change anything
10:13 - um and it may mention some things about
10:16 - some of them
10:18 - elsewhere maybe in the instructions
10:26 - okay
10:28 - what do we got next
10:30 - running nodegeneratewallet
10:33 - with the username should add a user as a
10:37 - key in waltz.json with a public key and
10:39 - a private key properties the value
10:41 - should be a public private keypair and
10:43 - hex format
10:45 - is the font so let's see what this one
10:46 - looks like we have no wallets and
10:49 - [Music]
10:51 - generate wallet okay so we're going to
10:54 - get a command
10:56 - argument from the command line
10:59 - um new wallet name
11:01 - so
11:03 - public and private i know there's
11:05 - instructions on how to do this um
11:08 - generate a key pair okay
11:11 - so
11:13 - let's go const key pair equals vc.gen
11:18 - key pair
11:21 - um ec is already here for us
11:26 - and then
11:29 - get some information from the keys
11:33 - there's the user story on this one
11:36 - to watch out for those type of
11:39 - did i have a
11:40 - typo yeah
11:44 - um
11:47 - should be able to create a wallet
11:50 - well let's see what the examples look
11:51 - like here we go wallet name public
11:54 - private there we go that helps
11:56 - okay so
11:58 - mouse public
12:00 - equals
12:04 - um
12:08 - get hex follow key from key pair
12:15 - okay i think that's right
12:17 - on
12:19 - private equals
12:22 - air that get
12:26 - private
12:29 - hex and then
12:33 - get wallets so we don't want to
12:34 - completely replace
12:40 - um the wallets we want to add to it so
12:45 - i think
12:46 - house wallets equals get wallets
12:52 - um
12:55 - so
12:56 - i guess we can probably just
13:01 - skip some validation and do
13:04 - wallets dot
13:07 - new wallet name
13:14 - so what validation would you do
13:17 - i would make sure there's not a name
13:20 - already in the wallet
13:22 - right this is the only thing here
13:25 - and
13:26 - typically wallets aren't stored like
13:28 - this this is just for this project
13:33 - so you can see it and have access to all
13:34 - the public and private keys
13:36 - um okay so while it's in a wallet name
13:40 - so we've got um
13:41 - public key and private key
13:44 - public
13:46 - key
13:47 - equals
13:50 - public
13:52 - well it's
13:53 - dot new while named up private key
13:58 - equals private
14:03 - um
14:05 - are those keywords
14:09 - public and private so i'm getting
14:11 - underlines
14:13 - private is a reserve word
14:26 - okay and then we should just do
14:29 - right
14:30 - wallets
14:33 - and then if i say that
14:36 - open my walls names yeah
14:39 - node
14:41 - so this is all in the instructions when
14:42 - i have it somewhat memorized um but yeah
14:45 - you can
14:46 - create a wallet with this it says so
14:49 - we're going to try that generate wallet
14:51 - me
14:53 - there's
14:56 - not set
14:57 - i was wondering if you needed to make
14:59 - that
15:00 - um
15:01 - dynamic
15:03 - yeah
15:05 - okay so
15:07 - equals
15:09 - what's that new name
15:17 - i'll just do this
15:27 - this work
15:32 - public key equals
15:34 - pub
15:40 - i'm not used to this keyboard
15:50 - i think just remember new wallet name
15:53 - is not the name of the key you want oh
15:56 - is that my problem
15:58 - yeah obviously
16:00 - thank you um
16:09 - that should work
16:10 - i think
16:13 - no more errors did or you must be
16:15 - straying her buffer now what
16:19 - invalid argument well when you're
16:21 - writing wallets
16:23 - you don't seem to be doing anything with
16:25 - the wallet you just created
16:28 - oh gosh
16:31 - okay well it's equal get wallets
16:33 - wallets your wallet's name well it's
16:36 - worthwhile uh okay well it's thank you
16:41 - you gotta look maybe i should have put
16:44 - more
16:46 - information there okay i think it worked
16:50 - it worked
16:51 - ha awesome
16:54 - i think the fun thing about these
16:55 - projects is you get to
16:57 - you know try out what you're
16:59 - making
17:01 - as many times as you want
17:07 - yeah you're cutting out a little but
17:09 - yeah i got you
17:11 - okay so we got one more thing done
17:13 - hopefully
17:16 - running the wallets creating wallet
17:18 - works
17:20 - and it has key pairs
17:21 - when you generate a wallet it should add
17:23 - a transaction at the end of the
17:25 - transactions array
17:27 - it should have a buyer address
17:29 - property of null and um buyer just
17:32 - property of null and seller address
17:35 - that is the public key of the new wallet
17:38 - okay so let's look at this
17:40 - ad transaction i assume
17:44 - go back to generate wallet get
17:46 - transactions write transactions okay so
17:48 - we'll just we wrote that
17:51 - const
17:53 - transactions
17:56 - let's get transactions
18:02 - and then
18:04 - i guess const new
18:07 - transaction
18:08 - equals
18:10 - something
18:12 - then
18:16 - transactions
18:18 - dot push
18:21 - transaction
18:24 - transactions dot
18:26 - right transactions
18:28 - right um transactions right transactions
18:42 - and then this transaction
18:46 - it should add a
18:49 - transaction at the end of the
18:50 - transactions or the transaction buyer
18:52 - address of null okay
19:02 - seller
19:08 - public key of the new wallet my price of
19:11 - 40.
19:12 - so
19:12 - public key
19:14 - i'll just go like that
19:17 - price
19:19 - 40.
19:22 - i suppose the
19:28 - i don't know
19:30 - um but let's see what happens there okay
19:32 - that didn't work either now now the old
19:34 - one's broken
19:37 - um new transaction equals that
19:41 - transactions
19:44 - you need to watch out for what you
19:45 - actually named some of your variables
19:50 - why don't you just tell me what the
19:51 - answer is you see something don't you
19:55 - seller address
19:56 - pub
20:00 - there is that what you were looking at
20:02 - yeah
20:08 - okay so now when i look at my wallets
20:11 - um wallets we got two wallets
20:14 - and
20:16 - transactions we've got nothing in there
20:18 - so i'm gonna just
20:20 - like that one
20:26 - i don't have a trackpad
20:29 - where's my trackpad
20:31 - um
20:33 - well okay let's look third wallet test
20:36 - okay we got a test wallet added that and
20:38 - now we have a transaction
20:41 - all right
20:44 - um
20:46 - running line my block should add an
20:48 - object to the end of the blockchain.json
20:51 - array
20:53 - with the correct hash previous hash
20:55 - nonce and transaction properties oh boy
20:59 - so this
21:01 - one sounds a little trickier
21:05 - um
21:07 - after you run should be an empty array
21:12 - hmm
21:20 - so i guess we're going to need a const
21:24 - new block type thing
21:31 - hash previous
21:33 - hash
21:37 - transactions
21:42 - and something like that we'll see
21:47 - equals
21:51 - so
21:52 - we've got helper functions
21:56 - let's use those get blocked
22:00 - blockchain
22:03 - last
22:04 - block
22:07 - block chain
22:09 - so you want to get the last block so we
22:11 - can get the previous hash
22:13 - so the blockchain is going to have this
22:14 - and we're going to want to get
22:17 - this hash
22:20 - so we can put it on the next block and
22:22 - it'll be the previous hash value of the
22:24 - next block so last block equal
22:26 - blockchain
22:27 - blockchain
22:29 - dot length
22:32 - oh
22:35 - this one
22:37 - blockchain blockchain dot like that
22:39 - sounds right
22:42 - um
22:45 - just comment this out once
22:49 - also that log last block let's make sure
22:52 - that's working
22:56 - there it is okay so it's working
22:59 - nice yeah
23:03 - i wonder if you don't
23:05 - need to worry about
23:07 - mutating blockchain
23:09 - you just pop it off the end
23:16 - i mean in
23:20 - this now you probably don't want to do
23:23 - that right you would need to put it back
23:25 - when you go back to write the block
23:27 - chain
23:30 - uh yes because you can't you can't
23:32 - remove a block
23:35 - okay previous equal last
23:38 - block dot hash so we got one thing down
23:41 - i think
23:44 - um
23:47 - not i think we're gonna have to look at
23:50 - the rest of the things for that now okay
23:53 - so hash and nots those are gonna be
23:58 - tricky transactions let's
24:02 - after you run
24:03 - it should be an empty right okay we can
24:06 - add that one quick
24:08 - const
24:09 - actually we should just be able to write
24:11 - transactions
24:15 - like that
24:17 - think
24:18 - so
24:19 - assuming everything gets mined
24:22 - correctly we can
24:24 - make that an empty array um
24:28 - i want to go up to these user sources i
24:30 - think there's some information
24:35 - generate a wallet okay so it looks like
24:36 - we kind of got
24:38 - a large portion of the top done
24:44 - um
24:48 - okay
24:50 - the hash should be creating using
24:54 - child56
24:55 - okay concatenating the nonce the
24:58 - previous the hash of the previous block
25:03 - okay so yes we need to do some sort of
25:05 - loop here
25:06 - i guess let hash equals this
25:11 - well and then i know there's something
25:12 - in here about it having to start with
25:17 - some zeros there we go the hash
25:22 - and yeah what knots equals let's just
25:25 - start with zero
25:27 - so while
25:29 - hash
25:33 - starts with
25:38 - zero zero
25:43 - um
25:44 - create new hash
25:46 - hash equals
25:53 - shot 256.
25:57 - and then i think
25:59 - how to work with keys shout out to
26:03 - right there there it is
26:06 - can i copy that
26:10 - there we go okay content to hash
26:14 - it says up here
26:19 - um
26:25 - the hash okay
26:28 - concatenating the knots
26:31 - nonce
26:32 - plus
26:34 - previous block
26:36 - last
26:37 - block dot hash
26:39 - plus
26:44 - a stringified version of whatever is in
26:46 - transactions.json oh geez look at this
26:49 - they copied
26:50 - i could have just copied this whole
26:52 - thing
26:52 - just need to read
26:56 - um transactions
26:58 - there's some dots there
27:00 - i don't have transactions
27:03 - oh i think i do no i don't
27:06 - it's
27:07 - transactions
27:11 - okay so
27:16 - and then we want to probably do
27:18 - nonce plus plus
27:22 - we'll start
27:23 - okay yeah so it's gonna keep going until
27:26 - it starts with two zeros
27:29 - nonsense be one two three four five
27:33 - um
27:35 - uh
27:36 - okay apparently that should be the hash
27:38 - of the last one
27:42 - okay that looks right
27:44 - um
27:46 - yeah do you have everything for your new
27:47 - block now
27:48 - um
27:51 - now it's hash
27:55 - transactions is that just a jason
27:59 - i think so yeah
28:03 - yeah that looks right
28:06 - let's see if it works so
28:09 - the transactions are supposed to go
28:10 - empty
28:12 - and we're supposed to get a new block i
28:13 - guess node mine block
28:18 - um we did not get a new block because i
28:20 - did not write it but i did delete the
28:22 - transactions
28:25 - um new block equals this uh
28:30 - blockchain equal get blockchain
28:32 - blockchain
28:35 - dot
28:37 - push
28:39 - new
28:41 - clock
28:44 - and
28:45 - right blockchain
28:48 - blockchain
28:51 - here we go
28:53 - now we don't have any transactions but
28:55 - um you know what i'm just going to
28:57 - generate another wallet quick test two
29:00 - now we have a transaction
29:05 - and yet another wallet
29:08 - okay let's see if that
29:10 - worked note mine block all right no more
29:13 - transactions and we have a block
29:16 - three hundred dollars
29:19 - um
29:19 - [Music]
29:21 - and then i guess i can come
29:24 - run these tests and see what is passing
29:27 - for me
29:35 - uh running note mind blocks
29:40 - hash previous hash nonce did i do
29:42 - something wrong what have we got here
29:44 - previous hash zero that looks correct
29:49 - hash that looks correct knots looks
29:51 - correct
29:53 - oh boy
29:54 - something is missing
30:04 - transactions i'm wondering now
30:07 - if you go back to your
30:09 - your little algorithm for calculating
30:13 - the hash
30:15 - because i remember coming across this a
30:17 - lot while doing
30:19 - um
30:20 - learning about the
30:23 - cryptography of
30:25 - blockchains
30:27 - looking at the nonce that you're
30:28 - calculating the hash with and then the
30:30 - final nonce that you're ending up with
30:32 - oh geez
30:34 - let's just
30:39 - we'll just do it first
30:44 - [Music]
30:46 - it's probably what's the right way to do
30:48 - it
30:50 - tell me the right way to do it
30:51 - [Music]
30:54 - okay let's see what happened
30:56 - i'm just gonna get my cat still then
30:59 - okay um
31:05 - something isn't working
31:10 - while not
31:15 - we know the internet has an obsession
31:17 - with cats so this is archie
31:26 - did you pass that test
31:27 - no
31:30 - i wonder what the test is doing should
31:32 - add an object
31:35 - well i mean the one thing i can think is
31:36 - you're not
31:38 - if the hash the nonce needs to be zero
31:40 - you're never actually testing that
31:45 - what's that
31:46 - say if the nonce is ever zero you're
31:48 - never
31:49 - calculating the hash based on that
31:50 - because you're always
31:52 - starting with one
31:55 - kind of a probability of thing that
31:56 - that's
31:58 - probably not going to happen but
32:00 - with the nonce
32:01 - it'll go it just goes until it finds one
32:04 - if zero but you know the checking zero
32:06 - well that's fine because if zero works
32:09 - it'll just go to one
32:11 - and check one and then it'll go to two
32:12 - or three whatever until it finds one
32:14 - that works
32:18 - and then you can use that one
32:22 - uh i don't know i know what i'm gonna
32:24 - try though
32:26 - i'm hey
32:30 - ans hash
32:33 - wait did it pass running node my blocks
32:35 - down object
32:38 - and transaction property transactions
32:42 - transactions
32:45 - hmm
32:56 - do you need to add a transaction anyway
33:01 - i don't know i feel like that one should
33:03 - have passed
33:05 - well if you go to the console is it
33:07 - saying anything
33:09 - there you go now you're thinking
33:13 - uh
33:14 - i don't think we've even seen the
33:15 - console yet
33:16 - um yeah
33:18 - okay
33:20 - running on mine block let's see what it
33:22 - says here the hash of the new block
33:23 - should be able to be recreated
33:26 - with these things expected zero zero six
33:29 - maybe you're right what's the
33:32 - to equal
33:34 - zero
33:35 - d so what one
33:38 - so my hash has two zeros
33:43 - i can't get back very easily i need my
33:46 - touch
33:47 - trackpad
33:50 - um
33:52 - so it's expecting only one zero
34:01 - no it's just saying it's supposed to be
34:02 - able to be recreated
34:19 - dot hash
34:21 - that should have been
34:24 - correct
34:26 - json.stringify
34:28 - transactions
34:32 - hmm
34:34 - i'm gonna
34:36 - check where you are
34:42 - doing the dot two string
34:50 - okay so what's transactions.json
34:54 - online
35:00 - oh there it is
35:03 - yeah
35:04 - oh stupid
35:09 - transactions not transactions not json
35:11 - did it say that and i should have copied
35:13 - and pasted
35:16 - not say that in the
35:20 - instructions it did say that there's a
35:22 - bug
35:24 - no
35:26 - well kind of a bug
35:28 - it's a bug uh okay let's try it again
35:31 - let's see if that works
35:36 - console
35:39 - running node mine block there it is we
35:42 - got another one
35:45 - thank you for that help
35:47 - um
35:52 - okay
35:55 - so
35:56 - do you mind writing that down you want
35:58 - to take a note of that oh what are you
36:00 - doing
36:01 - yeah we'll take a note of that
36:04 - um
36:09 - okay
36:10 - running node by item so we need to buy
36:13 - and sell items
36:16 - uh i'm already know about so we're going
36:18 - to run this command by item with one of
36:21 - our wallet private keys and the item we
36:23 - want to buy and we need to add a
36:24 - transaction for it
36:28 - with the correct buy or just sell
36:30 - address price unboxing so this is the
36:32 - test text there must be more information
36:34 - up here
36:36 - so but i know we're going to need
36:40 - cons let's call it new transaction
36:44 - what's this and we're probably gonna
36:46 - need
36:48 - transactions equals get
36:52 - transactions
36:53 - you know it's always satisfying
36:56 - when uh
36:58 - you come across a problem like we just
37:00 - had and then
37:02 - you start to think that maybe you have
37:04 - an issue with your tests
37:06 - and then
37:07 - find out that your test is working
37:14 - okay
37:15 - transaction when you buy an item yada
37:17 - yada
37:21 - so the buyer address should be the
37:23 - matching public key for the private key
37:25 - entered so it looks like we're going to
37:26 - get a private key and we need to find
37:29 - public key from that
37:33 - because pub probably is probably the
37:35 - keyword and russ isn't it
37:39 - yeah
37:40 - it is
37:41 - um
37:42 - so i have some poor
37:44 - variable name choices maybe um so get
37:48 - key pair from private
37:52 - uh equal
37:55 - different key
38:03 - public keys because we got we should
38:06 - have key from probably get key pair from
38:08 - private so that'll give us a key pair
38:11 - so that'll actually be key pair
38:14 - and then we need i think
38:18 - we need to
38:21 - get
38:22 - hex public key from key pair that should
38:25 - work right here
38:28 - so
38:40 - um
38:41 - i'm just going to
38:43 - console
38:51 - that shouldn't do anything
38:55 - save that um
38:58 - so i should be able to run
39:00 - node
39:03 - i
39:04 - item and enter
39:07 - a
39:09 - private key
39:12 - so if i grab this private key
39:19 - and run it
39:20 - oh come on
39:22 - why can't i paste
39:26 - copy paste
39:29 - i should get a log
39:31 - with the public key
39:34 - that is the public key that matches that
39:36 - works okay
39:39 - so we have a public key
39:44 - um
39:49 - okay we need to run that
39:53 - so okay
39:57 - fire
40:00 - press
40:03 - public key
40:06 - seller
40:08 - address null
40:12 - price should be the purchase price of
40:14 - the item bought
40:16 - item bot equals that so
40:19 - get item price
40:22 - what does that do
40:25 - get out of price item items so it looks
40:28 - like
40:31 - it returns the price
40:34 - i think you can just do
40:36 - get
40:38 - right here
40:40 - right in the object
40:43 - item price
40:44 - item bot
40:47 - um
40:53 - signature should use the buyer's key
40:55 - pair to sign oh geez
41:01 - signature
41:02 - equals
41:04 - buyer's key pair
41:07 - keep hair dot sign
41:13 - here we go
41:15 - what kind of content do we need
41:19 - by concatenation buyer address price in
41:21 - item bot
41:25 - and these helper functions are really
41:28 - just making a lot better aren't they
41:34 - yeah uh
41:44 - i lost it price item bot okay
41:47 - price plus item bot
41:49 - okay so we should have a signature
41:53 - and we need to add it probably down here
41:55 - we don't want that why would i do that i
41:57 - think
41:58 - thank god for linting
42:05 - it'd be terrible
42:09 - okay so
42:12 - supposed to add an object to the
42:14 - transactions transactions dot push
42:19 - new transaction
42:22 - right transactions transactions
42:27 - save it and we will i'm going to open up
42:30 - this
42:32 - transactions and see if i can do
42:35 - this again node by item
42:38 - and
42:40 - we'll try an icon
42:45 - but i wanted to see
42:47 - this
42:48 - notebook
42:50 - oh
42:54 - something's out of order
42:58 - buyer address equals public key buyer
43:00 - address um
43:02 - so i should be able to just do public
43:04 - key there
43:08 - bank
43:10 - price is not defined
43:12 - get item price
43:16 - um
43:16 - [Music]
43:18 - price
43:19 - okay yeah
43:27 - it
43:28 - item price item bought
43:36 - yeah that wasn't very smart there was it
43:40 - let's try it again
43:43 - yeah i think i spent 10 or 15 minutes
43:45 - yesterday on a bug that was caused by
43:49 - a trailing comma in json
43:53 - yeah so at least your error messages are
43:55 - telling you you know exactly what's
43:57 - wrong mine was telling me unexpected
43:59 - token
44:01 - now
44:03 - well
44:05 - didn't it give you like a red line
44:07 - around it and it's just really small and
44:09 - you can find it didn't get a red line
44:11 - around it
44:12 - no i think i was editing in nano so
44:15 - oh yeah
44:17 - no anything
44:19 - okay
44:20 - so i think this one should be working
44:23 - we bought an item and it was there
44:28 - so
44:32 - mind block no buy item
44:38 - buyer seller
44:40 - signatures well let's see what happened
44:41 - with this transaction buyer seller price
44:44 - signature
44:47 - buyer seller price item we're missing an
44:50 - item
44:52 - i wonder what the console would have
44:53 - told you
44:55 - we'll check it out here in a second
44:57 - yeah
44:59 - i'm always interested if it's
45:03 - assertions are specific enough
45:05 - seven
45:09 - i mean i don't know this one might be a
45:11 - little
45:13 - i really
45:14 - need my trackpad for this oh i have to
45:16 - scroll down here i guess that's not bad
45:18 - i just go scroll down a little further
45:21 - um expected 2 to equal 3. that's not all
45:25 - that helpful
45:27 - are you asserting the length of the
45:30 - object's properties yeah i guess
45:32 - probably huh
45:33 - yeah
45:38 - um
45:41 - and then somewhere in there i suppose i
45:43 - checked the rest of it
45:45 - yeah that's not or maybe i should check
45:47 - something
45:49 - anyway
45:50 - um
45:52 - i think it'll work now
45:56 - and since i'm just
46:00 - all right i'm still failing
46:02 - let me see if i buy an item again what
46:05 - now what
46:07 - icons we got item
46:12 - higher chests
46:22 - to read
46:24 - read my own stuff
46:28 - still nothing
46:30 - itembot signature
46:36 - [Music]
46:38 - let's run it one more time
46:46 - what
46:47 - i notice your transactions aren't
46:50 - um
46:51 - clearing
46:54 - oh you're not running mind block that's
46:56 - why
46:57 - yeah
47:00 - seller address i don't see any typos
47:06 - signature
47:07 - hmm
47:13 - let's see if that console's changed
47:15 - because
47:19 - it's adding an item
47:21 - it's going to say the same thing isn't
47:22 - it
47:27 - that's not helpful um
47:33 - buyer address
47:39 - buy item
47:46 - enterprise so the price is correct
47:49 - signature i wonder if that's off public
47:52 - key
47:54 - fire address that's the same thing that
47:57 - shouldn't matter
48:00 - signature let's see what that signature
48:02 - is supposed to be
48:05 - you buy an item
48:06 - signature
48:08 - sign concatenation of the buyer address
48:13 - price
48:14 - and item bot
48:18 - in that order in hex format
48:33 - we've got to keep here
48:34 - keep here that sign
48:38 - i mean the signature's here so
48:44 - um
48:46 - cellular address it's supposed to be
48:47 - null right
48:54 - seller address should be no price should
48:57 - be the purchase price
48:59 - 10. i wonder if that's supposed to be a
49:00 - string no
49:03 - let me see this example
49:06 - transactions
49:08 - yeah it all looks correct
49:12 - [Music]
49:18 - hmm
49:22 - transactions we're pushing it
49:28 - get address balance
49:31 - is there a caveat in there that i'm
49:33 - supposed to make sure they have a
49:37 - enough funds
49:40 - well it sounds like it's saying you're
49:41 - still not pushing the correct number of
49:43 - objects
49:49 - that is what it's saying
49:51 - but
50:00 - you know what i think it might be
50:02 - yeah
50:03 - something to do with the balance
50:05 - the test is checking if it's got enough
50:07 - balance or something
50:12 - so i'm gonna go
50:13 - i'm gonna start over
50:15 - i'm gonna reinitialize my blockchain
50:23 - and
50:24 - because the account i'm using is this
50:25 - one that i created that doesn't have any
50:27 - funds
50:30 - and add the funds until those other
50:34 - that there were uh it's like a
50:36 - i guess a
50:37 - reward transaction for
50:39 - creating a wallet
50:42 - node generate wallet
50:45 - just put me in there see now i'm going
50:47 - to have
50:50 - transaction with the funds i created
50:52 - those other wallets before those
50:54 - transactions were in there so
50:56 - i don't know why that would that why
50:58 - would that have anything to do with it i
50:59 - don't know
51:01 - i'm gonna run these tests again see if
51:03 - it still came back
51:06 - yeah there it is i'm gonna look at my
51:09 - solution
51:13 - see if there's anything
51:16 - well i can't think of anything
51:20 - transactions price buyer keeper key from
51:23 - private
51:31 - signature
51:39 - it looks the same
51:41 - for the most part very similar
51:46 - copy it over
51:56 - still nothing oh
51:59 - i didn't save the file
52:01 - i wonder if i wasn't saving the file
52:05 - i need to turn on autosave
52:08 - there it passed
52:10 - so now we don't even know if we're i'm
52:12 - going to undo this and see
52:15 - if it's working undo save
52:18 - and then run it
52:23 - no no it's not passing i wonder what i'm
52:25 - missing on this one
52:28 - fire is just cilantro's
52:37 - keep hair
52:48 - all right um we have to do the cell item
52:51 - thing still so
52:55 - we'll give it another try over there i'm
52:57 - just gonna use my solution for now
52:58 - because it's passing
53:02 - um
53:05 - i feel like it didn't have anything to
53:06 - do with the balance but maybe i'll dig
53:08 - into the test later and see if
53:14 - i
53:17 - wonder when you sign it the
53:19 - concatenation it matters the order
53:20 - doesn't it
53:23 - did you have the order correct
53:25 - i did
53:26 - i double checked it
53:30 - public key price item bought
53:32 - buy your address
53:36 - public key
53:39 - yeah
53:40 - okay
53:42 - wow
53:45 - do you have to do the check for the the
53:48 - balance in order to pass that one
53:52 - it doesn't
53:54 - say anything about it
53:59 - should not add a transaction if the
54:00 - address it does not have a
54:03 - maybe
54:05 - it's right there i didn't look at the
54:07 - second one
54:10 - get this one
54:15 - run the test
54:19 - okay these both fail yeah maybe i'll
54:22 - just try transaction equal that
54:24 - transaction number so
54:26 - let's try it once
54:28 - yeah
54:30 - get address balance um
54:33 - cons balance
54:36 - equals get address balance
54:40 - public key
54:44 - if
54:51 - um balance than or
54:53 - equal to
54:55 - price
54:59 - we'll
55:01 - add the transact uh push transaction and
55:05 - write the transactions
55:07 - let's try that once and see
55:09 - maybe that was it
55:14 - there it is
55:17 - wow
55:18 - you want me to take a note of that
55:20 - um
55:22 - i mean there might be a reason that's
55:23 - happening perhaps
55:26 - yeah sure take a note um
55:32 - yeah i don't like that but
55:36 - maybe i'll put that user story first
55:40 - that's probably what i would do
55:47 - um okay running the cell item so what
55:50 - else did we get we've got a cell item
55:52 - i should have at least three wallets in
55:54 - my wallet so jason so that's what i was
55:56 - gonna do here me you
56:00 - i three wallets i should be able to pass
56:03 - that one
56:09 - um
56:12 - three loss okay and then at the end here
56:15 - we got a
56:17 - oh they are valid nice at the end we
56:19 - gotta add a bunch of blocks and
56:21 - transactions okay sell item
56:23 - let's try this all item one let's keep
56:25 - keep moving
56:27 - keep me on keep me on task sean
56:32 - yeah well you're almost there
56:34 - i'm almost there
56:35 - um
56:40 - so we need to sell item
56:42 - address private key and item so the the
56:45 - command will have the private key
56:50 - and an item
56:51 - and we gotta add another transaction
56:53 - with the buyer address so let me go to
56:56 - my buy item once
56:58 - i just do a little
57:00 - this is going to be a bad idea but i'm
57:02 - going to copy this over here
57:04 - a new transaction
57:07 - transactions
57:08 - i'm just i'm just all over the map with
57:10 - my code too just
57:12 - hacking away
57:15 - okay let's move some of these up to the
57:24 - top um well i don't think we need a
57:27 - price on this one but
57:30 - okay so the buyer address is going to be
57:31 - null this time
57:34 - seller address should be
57:36 - public
57:37 - key i believe
57:40 - quick buyer just seller just price and
57:42 - item sold price
57:44 - item sold and then i believe we actually
57:48 - don't add a signature to this one
57:51 - because we're selling an item back to
57:54 - the game
57:57 - or maybe we do i don't know
58:00 - oh it does say signature
58:02 - yes so we do need
58:03 - i don't know what i was talking about
58:06 - um
58:08 - there's something you don't need a
58:09 - signature for though i thought
58:12 - i don't remember
58:13 - oh it was the reward transactions
58:21 - um okay so i'm gonna
58:24 - scroll up to the sell item
58:27 - thing here so we're supposed to add that
58:29 - buyer address should be null seller just
58:31 - be the
58:33 - matching public key for the private key
58:34 - hundreds so we've got a
58:37 - seller private key that comes in
58:40 - and we have to keep here
58:42 - there and then their public key
58:45 - okay so we got the public key
58:49 - um
58:52 - price should be five less than the
58:54 - purchase price of the item
58:57 - so we have item sold
58:59 - price
59:00 - equals get item price i should just be
59:03 - able to go minus five
59:05 - there
59:07 - um
59:10 - signature should use seller key pair to
59:12 - catenate seller
59:14 - address
59:15 - price and item sold
59:18 - um so public key should still work price
59:24 - items sold
59:28 - there we go um
59:31 - you shouldn't need uh
59:38 - shouldn't need anything here
59:42 - i'm wondering if there's supposed to be
59:43 - something
59:47 - that makes sure they have the item
59:49 - before they can sell it but i don't see
59:51 - anything written
59:54 - well you might need to check your actual
59:55 - user stories
59:57 - no maybe
59:58 - i only kind of skimmed over them
60:07 - seller address
60:10 - yeah i don't see i'm selling i'm not
60:17 - okay
60:19 - so we do
60:20 - if
60:21 - um
60:24 - what is it
60:26 - get address items
60:29 - um i should be able to
60:33 - address
60:34 - cons
60:35 - items equals get address items
60:40 - on the key
60:43 - i think
60:45 - so
60:47 - i'm gonna cancel log
60:50 - items
60:52 - here
60:57 - and nothing should be happening because
60:58 - i'm not writing any files so
61:03 - what i want to do
61:04 - is
61:05 - get an item to somebody somehow
61:10 - transactions we don't have any items yet
61:13 - so node buy item
61:18 - and i want to see if
61:21 - when you buy an item
61:24 - you should be able to buy an item by
61:25 - running by private key item
61:29 - okay
61:35 - private key
61:39 - let's do a different item this time
61:43 - a spray
61:47 - i think it worked
61:50 - actions
61:51 - there it is okay so now we have a spray
61:52 - we can sell let's just add
61:55 - another one we have two
61:58 - um
61:59 - and it says that the transaction pool is
62:01 - included
62:04 - uh the items are so this should be
62:06 - included so if i go node
62:09 - sell item
62:12 - um
62:26 - that private key
62:29 - get in there
62:33 - get item price item bot minus five yeah
62:36 - maybe i can't do that
62:41 - um oh it's because i didn't put in an
62:43 - item
62:47 - no
62:48 - oh is it can i not do that either
62:54 - what is it you see something you need to
62:57 - tell me
62:59 - it's not item bought
63:03 - item sold
63:06 - all right
63:09 - all right
63:11 - although i'm not inputting an item here
63:14 - okay so there we go we've got my items
63:16 - here they are
63:17 - that worked everything worked
63:20 - so i need to say if
63:24 - uh not items
63:29 - items
63:31 - item sold
63:34 - greater than zero
63:37 - or actually you know what let's just do
63:39 - if items i am sold greater than one so
63:42 - if you have at least one
63:45 - you can then
63:48 - do something
63:52 - transactions dot
63:54 - push
63:58 - come on
64:00 - new
64:02 - transaction
64:05 - transaction start right
64:08 - now you keep wanting to do that
64:10 - oh it's just
64:13 - it feels natural okay
64:15 - yeah
64:17 - there
64:18 - i think that'll work let's see what
64:19 - happens if i sell one of these sprays
64:24 - console like my items but that was
64:26 - before it actually changed
64:28 - transactions
64:32 - yeah there it is
64:35 - and i can i think there's the helper
64:37 - function here
64:40 - i thought items
64:42 - gift items
64:44 - oh yeah there's a little
64:47 - you can run that to gift items let's run
64:49 - that ones
64:51 - gift items
64:53 - i think it should work
64:56 - now
64:57 - it sends an item to every wallet
65:01 - around item
65:03 - yep free item to every wallet
65:06 - okay
65:07 - that's a funny drop
65:10 - um
65:12 - i wanted to check the balance
65:14 - or get address info there we go
65:17 - node get
65:20 - uh address
65:22 - info and i think if i just do the name
65:26 - there we go
65:27 - so we can we have some info there
65:31 - it has a balance of 20
65:33 - and a few items
65:37 - there we go
65:38 - that's kind of nice um
65:42 - and let's see if the selling test passed
65:48 - across our fingers here
65:51 - no
65:53 - no big fail
65:56 - so i don't
66:01 - what dude let me
66:04 - know it's cell item actually i'm just
66:06 - gonna
66:07 - node
66:09 - mine block
66:11 - should clear out the transactions and
66:13 - then
66:16 - sell item okay so now i just have
66:21 - none
66:23 - i thought it was working before i must
66:25 - not have that item
66:31 - what address is that
66:35 - um
66:38 - okay
66:39 - node
66:43 - you're also saying if it's greater than
66:44 - one hey
66:47 - note items that item sold if it's
66:49 - greater than or equal to one
66:52 - there we go thank you
67:00 - there it is
67:03 - um
67:04 - and yet it did not pass but i guess that
67:07 - was probably the problem so let's try it
67:09 - again
67:13 - there it is it passed
67:15 - all right
67:16 - there's off by one errors
67:19 - um
67:20 - and now we just need to add a bunch of
67:23 - transactions and
67:25 - stuff like
67:26 - that so
67:29 - node
67:30 - node mine block
67:33 - just pop these open i'm going to pop
67:35 - these open here so we can see what's
67:37 - going on
67:40 - blockchain
67:46 - if you got a blockchain here what looks
67:48 - like about three blocks
67:51 - no
67:54 - i hit them
67:56 - and we need wallets
67:58 - so i think if i grab a key
68:03 - hotkeys don't work
68:08 - excuse me
68:11 - free
68:14 - action work
68:15 - there it is so this person is buying a
68:17 - spray two sprays
68:20 - that one didn't work because we don't
68:22 - have enough money
68:24 - sure we'll just mine it
68:30 - this person
68:33 - node
68:34 - by item
68:39 - paste
68:42 - uh i'll do icon
68:46 - just make three transactions
68:48 - to buy some icons we'll just mine
68:51 - another block
68:56 - node
68:57 - gift items
68:59 - node gift items
69:03 - block
69:05 - yeah you can see it it keeps adding
69:07 - to this array blockchain and
69:10 - transactions so it's kind of neat um
69:14 - and
69:15 - i wonder how many more we need let's see
69:17 - if i have any passing i don't think
69:18 - that's enough though
69:20 - i just add a bunch of addresses
69:23 - two addresses minor block
69:33 - we're gonna we're gonna do this
69:37 - mode cell item
69:43 - that's
69:46 - uh
69:47 - icon
69:50 - both
69:53 - line block
69:55 - generate wallet this is what you want
69:57 - this is what you want
70:00 - um sean right now we have our own
70:03 - wallets
70:04 - 40 coins each
70:07 - um
70:10 - node mine block
70:11 - let's see how far we got
70:17 - ten blocks
70:20 - no
70:21 - gift items
70:23 - mine black
70:30 - does not tell you in the console how
70:31 - close you are
70:33 - no
70:39 - okay that's gotta be enough
70:46 - there we go
70:48 - nice
70:51 - oh one project down
70:57 - okay let's move on to the next project
71:02 - um
71:06 - yeah we finished this one
71:08 - and the next one is uh build a
71:10 - fundraising smart contract
71:13 - so it's going to be
71:16 - kind of similar and that's got a bunch
71:17 - of json files and stuff
71:20 - where you put your blockchain in there
71:24 - um
71:25 - okay let's see what it says here it says
71:27 - i need to create and deploy a smart
71:28 - contract that raises funds for my
71:30 - startup the goal is to raise 150 tokens
71:32 - before the seventh block is mined
71:35 - you have some boilerplate code and
71:38 - files um i should not need to change any
71:41 - of the boilerplate code the fundraising
71:43 - contract folder is the only place i need
71:45 - to write code so i have this folder
71:47 - which is going to be my contract
71:50 - and the rest of this stuff is
71:54 - not stuff i need to change anyway
71:57 - okay the initial state it's the an
72:00 - object my contract will store js files
72:02 - in that folder
72:03 - [Music]
72:05 - um
72:06 - will be run by the contract
72:09 - on transaction will run when a
72:11 - transaction is sent to the address of my
72:13 - contract and the on new block will run
72:17 - when a new block is mined
72:20 - and then it says that
72:23 - the files or the functions on the
72:25 - contract can only run if the status of
72:27 - the
72:28 - contract is open
72:31 - so
72:34 - yeah this is my contract state object
72:38 - and i presume there's going to be some
72:40 - sort of status
72:43 - open or maybe that
72:45 - automatically gets added
72:53 - okay
72:57 - the only two helper functions your
72:58 - contract files can use are add
73:00 - transaction and update contract state
73:04 - they're already added in your contract
73:06 - files
73:08 - okay so we've got an on new block file
73:11 - that will run when
73:13 - new block is added and this on
73:15 - transaction will run when
73:19 - a transaction is set to the contract
73:22 - address and then these other files is
73:24 - just
73:26 - showing all the things you can use in
73:28 - any other file you're gonna need to add
73:30 - here i know we're going to need to add a
73:31 - couple i think
73:34 - uh it says there's a number of variables
73:35 - that we passed your contract files
73:37 - uh
73:39 - ones available are already defined there
73:41 - and those two files uh
73:43 - yeah so it says there
73:46 - then we can use those variables um
73:49 - and here's the command to deploy your
73:51 - contract
73:53 - it says it will create a contract
73:55 - address and put the contract itself in
73:58 - the smart contracts
74:02 - json
74:03 - thing
74:08 - and then it will get added to the
74:09 - blockchain the next time i mine a block
74:11 - after it's deployed you can run the
74:13 - contract files with this
74:15 - command
74:18 - um
74:20 - yeah
74:22 - and there's some notes here says mining
74:23 - a block creates a reward transaction
74:25 - with a random address from wall such as
74:30 - okay
74:35 - these are stories bonus hints
74:37 - there's a lot of hints
74:40 - so there's
74:41 - gonna be a lot of like
74:43 - okay
74:45 - hence do this first i'm gonna do this
74:47 - first because it says do this first
74:48 - there's a there's an example contract
74:53 - for you to
74:55 - okay do this first it will help you
74:56 - understand how contrast there's an
74:57 - example contract for you to play with to
74:59 - see what it can do keep your eye on your
75:00 - json files and run these commands
75:02 - um so we've got like transactions
75:07 - smart contracts maybe blockchain
75:12 - we want to
75:15 - i'm in the wrong folder from before so i
75:18 - better make sure i switch
75:20 - build a
75:24 - run this initialize blockchain okay we
75:27 - got a block
75:29 - node
75:31 - deploy contract example
75:35 - contract because that's the name of the
75:36 - folder here
75:38 - and then a private key from the wallets
75:41 - private key let's go with this one
75:47 - um
75:49 - okay so we should have a message i guess
75:53 - your contract has been deployed at the
75:55 - address
75:57 - it will be added to the blockchain on
75:59 - the next block as well cool
76:01 - nice
76:02 - so
76:03 - there it is and it has my like functions
76:08 - from the example contract folder
76:12 - and the state of the contract i guess so
76:16 - node
76:18 - block i'll do that
76:21 - now it moved over there it's blocked in
76:26 - a transaction a private key from all its
76:29 - transaction okay so
76:32 - so do you want to explain what's in that
76:35 - functions object
76:38 - it's the code from these
76:40 - files these javascript files
76:43 - so you're just
76:45 - taking the code as a string and sticking
76:48 - it all on one line
76:50 - yeah
76:51 - yeah
76:53 - it works
76:55 - it's uh
76:57 - i mean it's
76:58 - it's pretty similar to how i mean not
77:00 - maybe not that part of it is but
77:03 - it's kind of similar to real smart
77:04 - contracts and that
77:06 - the code goes on to the blockchain
77:09 - and that's i guess more the purpose of
77:11 - of kind of some of this is to get the
77:13 - concepts across
77:16 - i don't know
77:17 - i think it's nice
77:19 - i think it
77:20 - definitely
77:22 - helps for debugging
77:30 - all right um
77:33 - let's
77:34 - try and do
77:35 - a little more here node
77:37 - add
77:38 - private key from wallets
77:41 - um so the contract is now like a
77:45 - different address
77:47 - and this person this wallet created it
77:51 - so you could still use that wallet
77:55 - to send things to the contract now
78:00 - um probably from almost example contract
78:02 - address and i'm pretty sure nobody has
78:05 - any coins
78:09 - or maybe they do i don't know
78:12 - so i have to use zero for the amount
78:19 - then some
78:20 - thing hopefully to the
78:22 - there you go
78:23 - so i sent
78:25 - xero
78:26 - to the contract address
78:29 - and it says someone set a transaction
78:32 - it is running it's on transaction file
78:35 - here's what the transaction looks like
78:37 - and if you look at the example contract
78:40 - this one
78:41 - it has all that information you get
78:46 - a transaction that came in and just a
78:48 - couple logs
78:50 - okay so it ran that file
78:56 - and then you can also run
78:59 - contract example contract to just get
79:01 - favorite number
79:04 - okay node run contract
79:09 - temple contract address should be that
79:13 - it
79:15 - before it
79:18 - i spell that right
79:20 - no you're missing the you in favorite
79:22 - huh
79:25 - okay
79:26 - look at this we got running this file
79:30 - favorite number is 10
79:33 - and then we can set it
79:37 - is your your favorite number actually 10
79:41 - no i don't have a favorite number
79:48 - example contract
79:51 - no it's actually 11 that's why we're
79:54 - going to change it to 11.
79:58 - favorite
79:59 - number
80:01 - yeah
80:07 - i'm kind of missing
80:11 - uh like you usually you need a private
80:14 - key you know to
80:15 - update state
80:18 - right to the blockchain i guess we don't
80:20 - in this one
80:22 - which is fine
80:24 - but i ran that and
80:27 - now it should be
80:34 - there it is and
80:35 - if you were to look through
80:37 - some of these
80:38 - blockchain files you'd see all that kind
80:40 - of happening
80:41 - like i guess
80:45 - there's the transaction okay this the
80:47 - smart contract transactions basically
80:49 - transactions go in their own
80:51 - file
80:53 - um
80:54 - let's see what happens when i mine a
80:56 - block
80:59 - yeah and then everything from both these
81:01 - files gets
81:03 - moved over to the blockchain yeah let's
81:05 - try to get a
81:08 - random reward on a new block his mind
81:11 - and he
81:13 - yeah so smart contracts kind of have
81:15 - their own area here
81:18 - um but i guess typically on real
81:20 - blockchains they're just regular
81:22 - transactions but yeah who are you
81:28 - nothing
81:30 - okay
81:34 - let's okay
81:36 - let's try and
81:38 - get this
81:39 - going
81:40 - fundraising contract so
81:44 - the initial state should have a status
81:46 - set to open
81:49 - and
81:53 - a
81:55 - description
81:59 - to
82:02 - smart contract
82:04 - your contract should have a get
82:05 - description file
82:08 - uh so we're gonna
82:10 - we these are the new files we need to
82:12 - make new file get description
82:16 - dot js
82:19 - and update description so it doesn't
82:20 - make those two updates
82:30 - and
82:30 - console.log
82:35 - i don't know if i can copy that maybe
82:37 - that's a good thing
82:43 - i'm just mumbling to myself here
82:46 - what's going on over there sean
82:50 - i'm just watching you seeing how
82:53 - the master does it
82:55 - creating smart contracts
82:57 - yep
82:59 - um
83:01 - keep your eyes open for those tables i'm
83:03 - good at that
83:04 - yeah i think that's why mostly here
83:09 - um
83:10 - so get description
83:13 - console.log
83:19 - here's the description
83:27 - of the fun
83:32 - contract and then
83:34 - description here
83:37 - probably
83:39 - contract state dot
83:42 - description
83:44 - so the contract state will be
83:46 - the object here
83:49 - yeah
83:51 - but we need to actually deploy the
83:53 - contract for any of this to work
83:56 - i don't think i need
84:05 - any of that i think we just need this
84:07 - one
84:11 - okay
84:12 - updates the description
84:17 - um
84:18 - updates the description so
84:23 - update contract state
84:26 - um
84:35 - i wonder if i should look in here i
84:38 - think
84:40 - i wonder if it's explained in here
84:46 - what that function needs
84:58 - remember you can just go to the you can
84:59 - hover over the function
85:01 - definition and then
85:03 - control click all
85:05 - command click
85:08 - not convinced you can in these ones but
85:10 - maybe what do you do command clicked
85:13 - there
85:15 - who do i press
85:17 - um
85:18 - i'm not sure what it is on mac if it but
85:20 - don't mind it's control and then i click
85:22 - on it and it takes me to the definition
85:25 - although no you have dynamic imports so
85:27 - it might not do that
85:33 - so
85:36 - update contracts did and why
85:40 - update contract state address state
85:43 - there we go
85:45 - okay contract address contract address
85:50 - and then comma
85:53 - we need
85:55 - a new
85:56 - thing
86:03 - something from there
86:05 - args
86:08 - go with zero for now
86:13 - i don't think i need i think you could
86:14 - just console log it couldn't you
86:18 - yeah we'll throw that in there anyway
86:26 - doesn't need
86:30 - any of that
86:35 - or
86:39 - that
86:42 - a contract address no
86:47 - it needs the whole state object
86:53 - so it would be
87:01 - contract state contract
87:07 - contract state dot
87:11 - description
87:14 - equals
87:18 - um
87:19 - args zero maybe i'm gonna go with that
87:23 - but i don't know we'll see what it says
87:33 - let's make sure we save the file
87:38 - um
87:40 - and then
87:42 - let's attempt to
87:45 - deploy it i think maybe
87:49 - sure
87:50 - so i'm going to follow the
87:52 - commands from deploying the example
87:54 - contract
87:58 - here we're going to reinitialize
88:00 - deploy
88:04 - prising contract
88:07 - and then a private key
88:15 - based
88:16 - there we have it
88:18 - so let's just
88:21 - align that to the block chain
88:25 - and then
88:27 - we should be able to run these functions
88:30 - node
88:33 - run contract
88:43 - it's description.js
88:49 - the description that worked
88:52 - and then
88:57 - date description
89:02 - new description
89:05 - network
89:08 - yeah look at that arc zero
89:16 - working
89:17 - nice
89:25 - well let's see if the test passed i
89:26 - guess huh
89:27 - look at all these we got past already
89:30 - wow
89:33 - how many left to do
89:38 - not too many
89:40 - nine ten
89:42 - oh this one's past two
89:44 - this one's past two
89:46 - your fundraising contract should be
89:48 - deployed in mine's election
89:50 - all right okay
89:53 - so running the commands to play your
89:56 - contract
89:58 - and sending it the 150 tokens
90:02 - created transactions
90:06 - so
90:08 - our contract needs to
90:12 - raise 150 tokens
90:14 - before the seventh block is mined
90:18 - and if it
90:22 - does
90:25 - we need to create a transaction that
90:27 - sends all the funds donated
90:30 - from the contract to the address of the
90:33 - creator
90:38 - and then also set the status
90:41 - to closed
90:44 - and if we
90:50 - do not raise the 150 before seven blocks
90:55 - we
90:56 - need to send
90:59 - the transactions back to the
91:03 - people that sent them to us
91:07 - okay
91:09 - so you have to keep that all in state
91:11 - now use sent what
91:16 - so
91:17 - initial state
91:23 - i guess um
91:26 - maybe
91:27 - donated
91:33 - transactions
91:35 - and then maybe an array
91:40 - and a
91:46 - um
91:49 - raised maybe like a number
92:01 - status description
92:05 - i think that might be enough
92:09 - so you definitely need to keep track of
92:11 - all the transactions
92:13 - that come in
92:15 - so we can send them back
92:18 - and
92:19 - i think that'll work
92:22 - i don't know if we need to keep track of
92:23 - the raised or not
92:26 - you could just look through the
92:27 - transactions i suppose
92:33 - so that sounds like an optimization
92:35 - thing that
92:36 - you may or may not want to do
92:42 - yeah
92:43 - okay so this on new transaction comes
92:47 - when our contract gets a
92:50 - donation
92:53 - so we're going to need to if we get a
92:55 - transaction what do we need to do
92:58 - put it in
93:00 - the state
93:04 - also
93:11 - add two raised or something add the
93:14 - funds to raise i'll just keep track of
93:16 - it for the heck of it i don't know
93:19 - i need it um
93:28 - and then we need to check if we have the
93:32 - 150
93:35 - send
93:39 - all funds to
93:42 - contract creator
93:46 - something like that maybe
93:52 - um
94:00 - yeah i'd go with that
94:03 - okay so
94:08 - contract state
94:11 - so a transaction comes in let me
94:13 - console.log
94:16 - transaction fill that in there what does
94:19 - a transaction look like when it comes in
94:22 - yeah
94:23 - probably an amount
94:28 - and the address would be the contract
94:30 - address and the from address would be
94:37 - um whoever sends it
94:45 - so
94:50 - this is tricky
94:54 - update contract state
94:56 - contract
94:58 - address new state
95:03 - um
95:06 - the state has a
95:10 - transactions object so you know what i'm
95:12 - just gonna go
95:14 - we have this contract state here so i'm
95:16 - just gonna contract
95:20 - state
95:22 - transactions
95:25 - not
95:26 - push
95:28 - this work
95:32 - no
95:33 - transaction
95:35 - what's that transaction that came in
95:42 - and then
95:46 - we could also do contract
95:51 - say dot
95:53 - is
95:54 - plus equal
95:59 - transaction dot amount maybe
96:02 - i'm not sure you can plus equals on a
96:06 - property
96:08 - you can't
96:11 - thanks
96:13 - um
96:14 - contract state.raise um equals
96:20 - wait
96:22 - yeah you can
96:23 - can't you
96:25 - contract it dot raised
96:27 - plus equals
96:29 - so you can try yeah
96:35 - i don't see why not
96:37 - maybe i don't know
96:40 - um where am i at here
96:43 - okay so
96:45 - we've got a few things happening update
96:47 - contract state
96:49 - add to raised
96:52 - and then should i attempt to do this
96:54 - right now or should i
97:00 - there are helper functions for
97:04 - running contract
97:07 - earning contract
97:11 - playing contract wallet um
97:16 - i thought there's one for
97:18 - getting just the whole state
97:26 - i'm gonna do
97:31 - i'm just gonna do this once
97:35 - throw another one in there why not
97:41 - it stayed console.log
97:44 - contacts
97:55 - we're gonna do that
97:56 - let's just see what happens i should be
97:58 - able to deploy this
98:00 - and we'll see a transaction we'll do
98:04 - that
98:05 - update the state and then we'll be able
98:07 - to check it with that other file
98:10 - okay so
98:12 - um
98:13 - go back
98:15 - reinitialize and then redeploy
98:21 - and
98:24 - find the block
98:27 - and what we want to do is send a
98:30 - transaction to it so
98:33 - if i look at transactions there's one
98:36 - there
98:38 - i suppose i could send zero to it
98:42 - let's mine another block
98:44 - so now
98:45 - somebody has 50. this person
98:49 - public key that's their public key
98:50 - though
98:52 - wallets
98:56 - zero four one two
98:59 - so here's their private key
99:03 - to be able to go
99:08 - add a transaction
99:10 - from this person this is probably all in
99:13 - the instructions it's just i kind of
99:15 - have it memorized
99:17 - um
99:20 - helpers maybe down here add transaction
99:23 - i guess okay we already went through
99:25 - that
99:27 - um so we take the private key
99:32 - and then
99:33 - the
99:35 - to address which would be the contract
99:37 - address
99:42 - very large address
99:47 - i made sure to make them as big as i
99:49 - could
99:51 - yeah that always seemed like it when i
99:54 - looked at these
99:56 - no i did the opposite actually but
100:00 - okay so we have problems um
100:08 - is my transaction though the transaction
100:10 - came in
100:12 - yeah
100:14 - undefined 15 new state well that is the
100:17 - problem
100:24 - contract address
100:28 - contract state
100:31 - all right let's try it again
100:36 - initialize
100:39 - deploy
100:43 - unlock let's do that twice we have a
100:46 - transaction
100:48 - node add transaction
100:53 - um
100:54 - private key private key very key
100:58 - here we got this person0416
101:07 - um contract address
101:15 - and
101:17 - 50.
101:19 - i think it worked
101:20 - okay
101:23 - so what files have changed
101:25 - this one right here
101:27 - transaction showed up from
101:31 - that person to the contract address this
101:34 - is we just sent this to the contract
101:37 - and it did some things there with
101:39 - signatures
101:41 - um
101:42 - and then the contract ran this
101:45 - file here
101:47 - yeah
101:48 - so we got this log of the transaction
101:51 - that came in
101:53 - and then if we say get
101:56 - state now
101:57 - it should all be
101:58 - updated node
102:01 - run contract
102:04 - east
102:07 - getstate.js
102:11 - it is smart
102:13 - status open transactions
102:16 - nice
102:17 - okay awesome
102:20 - so
102:22 - now we need to do like if
102:27 - if contract
102:32 - contract state dot raise greater than or
102:35 - equal to 150
102:39 - um
102:46 - send all phones to creator just like i
102:48 - put right there
102:51 - um so we need to
102:54 - add
102:55 - transaction
103:02 - creator address
103:06 - so i suppose that would be their
103:08 - public key
103:10 - of the creator
103:13 - and private key
103:18 - well
103:19 - wouldn't you first
103:22 - send if wouldn't you first put all the
103:25 - transactions into the blockchain
103:28 - that the contract has stayed for and
103:31 - then
103:32 - send a transaction from the
103:34 - contract to the owner
103:39 - say that again
103:42 - so
103:43 - your contract state has a bunch of
103:45 - transactions in it you need to mine
103:47 - those
103:48 - so that the contract address has those
103:50 - funds
103:52 - and then you need to
103:54 - from the contract address send
103:56 - a transaction
103:58 - to the owner
104:02 - well
104:04 - i'm just storing the transaction
104:05 - information in the contract state the
104:08 - actual transactions are also going into
104:11 - the transaction they're already going
104:12 - through right cool right so they're
104:15 - already going on to the blockchain
104:18 - okay
104:19 - i just need the information so that if
104:21 - my contract
104:25 - does not
104:27 - succeed
104:29 - i can
104:30 - send all this stuff back and i probably
104:32 - probably only need like
104:35 - the from address
104:37 - and the amount from each transaction
104:45 - that would be enough to send it back
104:48 - so i'm gonna
104:51 - i'm gonna do that i think
104:53 - on transaction
104:57 - you know what i'm not gonna do that
105:00 - all right um
105:03 - so
105:04 - what was i looking at here this private
105:06 - key i presume
105:09 - is that the private key
105:11 - of the contract itself maybe
105:16 - that's kind of hacky but
105:18 - you can
105:19 - [Music]
105:25 - yeah you need to you need to sign it
105:27 - from the contract
105:28 - no
105:29 - yeah
105:32 - and so
105:36 - i wanted to find this function and see
105:39 - what it looks like
105:41 - add transaction
105:44 - somewhere
105:48 - you know what there's this thing you can
105:50 - find
105:56 - right in here somewhere
106:00 - private key to address amount
106:04 - add transaction
106:07 - private key
106:10 - to address creator address
106:13 - amount
106:16 - contract state dot raise
106:20 - that sounds right
106:27 - so you're definitely sending everything
106:29 - through
106:30 - even if it's over the goal
106:35 - yeah
106:37 - yeah isn't that how real fundraisers
106:39 - work you can raise you know you set a
106:41 - goal of something
106:43 - ten thousand but you can also raise much
106:45 - more
106:47 - like a lot of future
106:50 - pretty sure that's awful have you ever
106:51 - watched shark tank
106:53 - no maybe not
106:58 - i have and that's what they say on shark
106:59 - tank
107:02 - we raised twenty thousand on a goal of
107:04 - ten thousand that's what i
107:06 - say um well i mean if you have let's say
107:11 - you raise 140 from previous transactions
107:13 - and then somebody wants to donate
107:15 - another 100 to get to 240.
107:19 - where would that other money go who
107:20 - would get it well i don't know i'm used
107:23 - to things like kickstarter where you
107:26 - have a goal of
107:28 - 10 000 but then some of these
107:31 - you know some kickstarters they have a
107:33 - goal of
107:34 - 10 000 and they get a million
107:38 - i'm pretty sure that they don't get to
107:40 - use the million
107:44 - all right
107:45 - it doesn't matter
107:46 - that's how this one works
107:48 - okay yeah
107:50 - um
107:52 - so
107:54 - i think this file might be done and i
107:57 - don't even know i'm just gonna click
107:58 - this run test
108:00 - let's see what happens maybe that one
108:02 - will pass
108:04 - running and send it there it is so if
108:07 - the 150 tokens get sent
108:10 - yeah
108:11 - it worked
108:13 - nice
108:15 - oh but i also need to
108:19 - so
108:24 - add a transaction i guess i need to
108:26 - update
108:28 - contract
108:31 - state dot status equals
108:34 - close maybe i think that's what i'm
108:36 - supposed to do
108:38 - and update contract state just
108:42 - copy
108:43 - um
108:45 - would just move that line to the bottom
108:47 - of the file
108:50 - all right
108:51 - yeah
109:00 - that's good girl
109:01 - yep
109:02 - is it supposed to be a capital c
109:06 - here
109:07 - no they're closed
109:09 - um
109:09 - [Music]
109:12 - what did these users say no it does not
109:14 - look like it
109:18 - okay i guess we'll run the test then i'm
109:20 - gonna have to go through that process of
109:23 - deploying
109:28 - there it is
109:30 - now we need
109:31 - yeah
109:32 - now we need to
109:35 - do this other one on new block
109:40 - this is whatever block it's mined we
109:41 - need to
109:44 - if block
109:46 - length
109:47 - greater than 7 or something
109:51 - send all
109:53 - transactions back to
109:57 - donors i guess
110:00 - yeah something like that
110:02 - okay
110:04 - in my mind you should count
110:07 - the block number from when the contract
110:09 - is deployed and then seven after that
110:14 - you definitely should that sounds better
110:17 - obviously it could
110:19 - be tough to
110:20 - do things with time or something which
110:22 - is what you really would probably want
110:24 - to do
110:25 - yeah
110:28 - yeah that would have been that would
110:29 - have been better
110:31 - why don't you tell me that sooner
110:35 - all right
110:39 - this is this is how it is though for now
110:42 - and
110:43 - yeah that's a bonus to hear if i was
110:46 - going to go through this they can
110:49 - at the end switch up their their
110:51 - contract so that it
110:53 - finds out the block that it was deployed
110:55 - and then
110:58 - the logic is seven after
111:00 - it's deployed block
111:02 - now
111:03 - i like that
111:08 - um
111:13 - so we're gonna have
111:15 - contract
111:17 - state.transactions
111:20 - uh
111:21 - for each maybe
111:24 - what the heck is that
111:29 - maybe some sort of loop to go over all
111:31 - these
111:32 - transactions
111:35 - um
111:38 - a transaction
111:40 - and it was the
112:02 - we got the private key
112:05 - so this is
112:06 - from
112:07 - the contract
112:10 - to
112:11 - tx dot
112:15 - from address
112:16 - i think
112:18 - and
112:21 - to mix that amount
112:24 - that looks right
112:27 - i think so
112:29 - so yeah if
112:34 - blockchain length which comes in
112:43 - running the commands to deploy your
112:45 - contract and mine seven blocks so
112:56 - i think there's a note in here
112:59 - about
113:02 - something when this is actually run
113:05 - it says in
113:07 - immediately after the block is mined
113:09 - yeah is that what it says
113:11 - yeah
113:12 - so it should be
113:14 - greater than or equal to seven i think
113:26 - um
113:29 - okay
113:32 - is that it
113:35 - i can't be it
113:38 - we need to also if block change
113:41 - do
113:43 - update you know screw this
113:45 - copy this
113:52 - contract state let's just do
113:54 - if watching length not greater than
113:56 - seven
114:00 - and
114:05 - contracts not already closed
114:09 - uh
114:11 - not equal to
114:13 - closed it's kind of sketchy
114:17 - condition there
114:21 - should work
114:24 - yeah
114:26 - not good enough for me
114:29 - um
114:30 - so if it's not closed
114:33 - update to contracts dude
114:36 - contract state.status
114:39 - equals closed
114:45 - and i'm around the test
114:47 - i might be missing something but it
114:50 - looks pretty good
114:54 - there it is
114:57 - wow
115:01 - all right apparently my functions are
115:03 - working
115:04 - yeah
115:05 - now we need to kind of start over and
115:09 - deploy it and actually send it enough
115:11 - transactions i think like it says the
115:14 - current state the
115:17 - status closed and a description oh it
115:21 - says description
115:24 - your contract should have had at least
115:26 - 150 tokens sent to it
115:29 - and it should have added a transaction
115:31 - sending all the
115:32 - tokens back to the creator or to the
115:34 - greater whatever
115:36 - so
115:37 - we have to kind of do that i'm just
115:39 - going to start over
115:40 - initialize
115:44 - deploy
115:47 - i'm just going to mine how many do i
115:49 - need 150
115:52 - so like six blocks so i can
115:56 - have tokens descend
115:58 - just flooding the market here
116:03 - block chained up jason all those wait
116:05 - what
116:08 - where are my transactions oh they're
116:09 - there they're here i just didn't scroll
116:11 - down
116:14 - so now i should be able to go we
116:16 - deployed it
116:17 - um
116:21 - node add transaction from
116:26 - wallets
116:31 - private key
116:35 - to
116:39 - um
116:42 - oh geez
116:54 - copy
116:55 - paste
116:57 - it's like the slowest copying and
116:59 - pasting you'll ever see
117:03 - paste okay so from somebody
117:06 - to the contract let's see it
117:08 - a person doesn't have any money figures
117:18 - from
117:19 - this person
117:23 - no
117:33 - there
117:34 - okay that should work
117:38 - transaction to the contract
117:41 - so i think if i just
117:43 - do it again
117:45 - do you have three
117:47 - no no you're out of money
117:50 - all right well that should be enough for
117:52 - this
117:53 - oh that's only two
117:55 - actually 100 it's supposed to be 150.
118:00 - that
118:01 - first one was one of these
118:04 - well now you've mined too many blocks
118:05 - haven't you
118:08 - no it says your blockchain should have
118:09 - at least six blocks oh maybe i have
118:12 - because at some point it's gonna
118:16 - oh no
118:17 - at some point it's gonna send the money
118:19 - back
118:20 - oh yeah crap
118:25 - you're right
118:26 - um
118:28 - just delete the last json
118:34 - yeah that that could potentially work a
118:36 - little hack but
118:38 - node add
118:40 - transaction
118:44 - ah i know that transaction we're gonna
118:46 - go like this
119:01 - did it work did i get did it happen
119:05 - and cine logs
119:07 - um
119:10 - ours 150 i think
119:12 - yeah i wonder if i need to mine the
119:14 - block
119:17 - i don't think so
119:19 - maybe i maybe i mined too many blocks
119:22 - already and you were right
119:25 - let me
119:27 - know to run
119:36 - might be in here
119:38 - contract wallets
119:41 - i think i use the public
119:46 - address i'll paste it in there let's say
119:49 - get state.js
119:51 - closed
119:55 - now
119:56 - i blew it
120:02 - all right we're gonna start over yet
120:04 - again
120:05 - yay
120:06 - specialize
120:09 - maybe you don't mind six blocks just
120:12 - minding three
120:14 - oh i'm pranking
120:18 - we have
120:21 - zero blocks now we have one block
120:24 - two blocks three blocks
120:27 - we do four so that we have
120:31 - enough coins
120:32 - on the blockchain it should be
120:36 - there's our first block you could also
120:38 - just manually edit one of the
120:40 - um
120:41 - wallets to have 100
120:44 - or 200. no you can't
120:49 - there's a test that checks that your
120:50 - blockchain's valid
120:56 - i could change the function that
121:00 - yes
121:01 - um
121:02 - it's node add transaction from
121:09 - private key
121:14 - i realized yeah my hotkeys are working
121:18 - to
121:20 - the contract
121:25 - and
121:27 - 50.
121:31 - okay you're out of money
121:35 - um
121:37 - we'll try you
121:55 - that should be it
121:58 - transacted
122:01 - there it is the
122:02 - 150 wow
122:06 - now if i run the test is that it
122:11 - no you don't have six blocks
122:13 - oh
122:15 - your contract should have had at least
122:17 - 100 seconds and should have added a
122:19 - transaction sending all the contracts i
122:21 - wonder
122:23 - oh boy none of that looks good
122:26 - maybe i just need to mine it
122:29 - yeah
122:34 - before you reach this xbox be sure to
122:36 - edit the description
122:40 - that's true huh thanks
122:42 - okay so what have i got here i don't
122:43 - even know
122:47 - i'm not gonna worry about it
122:49 - let's let's do this node
122:52 - run
122:53 - contract
122:56 - contract
123:01 - address
123:03 - i think he's the public key
123:11 - um
123:12 - update description
123:15 - dot js
123:18 - smart contract
123:21 - to raise funds for my startup
123:27 - oh fine one more block
123:30 - press their fingers
123:33 - you cannot update the state of a
123:35 - contract that is not open what
123:40 - oh
123:44 - whoever created this is just
123:48 - evil
123:52 - i guess i wanted you to go through all
123:54 - of this i gotta do it again
123:57 - unbelievable
124:01 - okay
124:03 - i guess it's some good practice so we
124:05 - deployed our contract i'm gonna
124:07 - node my block
124:11 - imagine how much easier this would have
124:12 - been
124:13 - if your addresses were a reasonable
124:15 - length
124:16 - [Music]
124:18 - or if my hotkeys were even working
124:21 - my hotkeys are
124:23 - i can't paste into the terminal i don't
124:25 - know why
124:27 - with ctrl v or whatever
124:32 - i don't know
124:34 - so we have my contract so the first
124:37 - thing we're going to do run contract
124:41 - contract
124:42 - address
124:44 - update
124:46 - description
124:47 - dot js
124:49 - smart
124:50 - contract raise
124:54 - funds for
124:56 - i
125:00 - start up
125:08 - i'm going to just run the tests and
125:12 - see if
125:16 - make sure it's passing before something
125:19 - crazy happens in the current state
125:23 - oh well
125:25 - yeah that's that's pretty rough there
125:28 - now let me tell you the problem because
125:32 - someone's going to come along they're
125:33 - going to forget the period at the end of
125:35 - that description
125:37 - and
125:38 - they're going to mine all of their
125:40 - blocks
125:41 - and they're going to fail that last test
125:45 - all part of it
125:46 - yeah
125:48 - okay so if you check the console though
125:50 - you can probably see whether it's
125:52 - failing because of the description or
125:53 - because the status property is closed
125:57 - yeah you might be able to
126:00 - so you get that
126:05 - contract address
126:09 - paste
126:11 - 50
126:14 - money i
126:18 - can't address info so i mean i could be
126:19 - doing that
126:23 - but i'm just
126:24 - copying
126:31 - probably the same
126:33 - same time to do both
126:38 - so you have all the money or i forgot to
126:41 - mine a block or something
126:46 - oh i definitely mind blocks
126:59 - who has the money
127:01 - what's going on here
127:04 - we've got a blockchain
127:08 - 50 50 50. somebody's got money
127:12 - it's
127:13 - it's probably the
127:16 - yeah
127:18 - that worked
127:26 - i know
127:37 - name of address
127:41 - count your property is not divine
127:47 - saying get water to dress is returning
127:49 - undefined
127:54 - all right you want to make a note of
127:55 - that one too
127:57 - yeah
127:59 - oh no never mind i just had a typo
128:03 - it's a capital m
128:05 - okay
128:09 - okay so here is the public address
128:13 - and the balance
128:15 - for me
128:16 - did i not do it right
128:20 - private key
128:23 - i'll copy it
128:31 - i swear i did this already
128:47 - transactions
128:50 - i don't see any
128:53 - node get address info
128:56 - i don't see any 150 transactions yet so
129:00 - or whatever coins
129:03 - so let's do this one
129:15 - paste
129:19 - there
129:21 - should be it a little anticlimactic but
129:27 - no to get
129:32 - it's gonna try and run the account i'm
129:34 - gonna do it node run
129:37 - run contract
129:45 - copy
129:47 - paste
129:49 - get state touches
129:52 - the transactions are all still there
129:55 - close smart contract
129:57 - good thing i didn't have a period
129:58 - missing or something let's find let's
130:00 - find out maybe there's typo
130:03 - come on fingers crossed
130:05 - oh it's still failing
130:13 - this should all be that those two should
130:14 - be working a smart contract to raise
130:17 - funds for my startup
130:21 - get to the console
130:25 - sure
130:33 - yeah this is not going to be helpful
130:35 - like
130:38 - expected thank you did you mind the
130:40 - block
130:43 - maybe not
130:45 - yeah
130:47 - maybe i need to do that let's try it
130:52 - this one say
130:56 - actual open expected closed
131:05 - all right let's try it maybe i just
131:07 - needed to mine it
131:10 - come on
131:15 - it was
131:18 - whew
131:21 - wow
131:23 - well we got another one
131:27 - so
131:28 - nice work
131:36 - all right um
131:38 - the next project is this peer-to-peer
131:41 - network
131:44 - so let's just try and check it out
131:48 - um
131:53 - that's
131:54 - so
131:55 - when i click on it it starts me down
131:57 - here
131:59 - yeah it's because it's a
132:02 - single page app
132:04 - so the scroll location is staying the
132:07 - same
132:11 - okay so
132:14 - yeah it's pretty minor but
132:17 - i guess what we're gonna try and do here
132:19 - is build a peer-to-peer network
132:22 - sort of
132:25 - what gave that away
132:28 - that was the title right
132:33 - it's distributed
132:37 - so
132:39 - we're gonna be working in this folder
132:42 - um we have some boilerplates we don't
132:44 - need to change any of that an old one
132:46 - folder right here represents
132:49 - a node on the network the files in it
132:51 - will be cloned and used to run all the
132:52 - other nodes in the network you only need
132:54 - to change the index.js file
133:00 - um
133:08 - so we're going to use websockets and
133:10 - websocket servers to create a website
133:12 - server in here and it's going to listen
133:14 - for incoming connections and it's going
133:17 - to
133:19 - connect to all the other nodes on the
133:20 - network uh
133:24 - so
133:25 - once we think we have this file finished
133:27 - what we're going to do is run this clone
133:29 - node
133:31 - thing to copy it
133:34 - and then
133:37 - run a bunch of different nodes i
133:42 - guess and so we have to have at least
133:45 - three nodes
133:49 - and we need to create a websocket server
133:53 - and so basically all the servers are
133:55 - gonna connect to each other
133:59 - we have these like known peers which are
134:02 - kind of like entry points to the network
134:05 - and then once one of the sockets
134:10 - connects to one of those entry points
134:13 - it will handshake with the
134:18 - server and the server will send it the
134:20 - list of all of its connected addresses
134:24 - so and then from there it will connect
134:26 - to every other node on the network
134:31 - so we're basically
134:33 - simulating a
134:35 - creating
134:36 - a flood sub
134:38 - network
134:41 - um
134:42 - protocol
134:47 - sure
134:52 - um
134:54 - yeah uh
134:56 - i don't know to be honest that's
134:59 - i'm gonna i'm gonna go with it sure
135:03 - um
135:04 - so
135:05 - we're gonna have to have some
135:08 - server
135:09 - listening
135:12 - um
135:14 - when it starts it should attempt to open
135:16 - soccer
135:17 - so it should attempt to
135:20 - connect to
135:23 - known
135:25 - peers
135:28 - uh when i saw your connection when a
135:31 - connection to server is established
135:36 - okay so we're going to try and connect
135:37 - to these and if we
135:40 - find a connection
135:42 - we need to send it a string object
135:46 - that says this type
135:50 - and shake
135:53 - data
135:57 - ray
136:00 - so it looks like we have
136:03 - the address of the server here
136:08 - um
136:10 - data should be an array of addresses
136:12 - that your server is connected to
136:14 - including the server's owners so data
136:20 - connected addresses that's what we need
136:23 - um
136:26 - my
136:28 - yes
136:31 - connected
136:32 - addresses
136:36 - something like that
136:41 - when a server receives the above message
136:43 - it should attempt to open socket
136:46 - connections so
136:51 - when i connect to a server i send it
136:54 - this
136:55 - and when my server receives this
136:59 - so
137:00 - something like
137:01 - server
137:04 - dot on
137:06 - and shake
137:11 - connect
137:13 - yeah
137:14 - do all
137:17 - data
137:19 - um
137:20 - [Music]
137:24 - you should keep track of all the
137:26 - addresses the server is connected to you
137:28 - can use that
137:29 - when a socket disconnects
137:32 - you should remove it
137:35 - so i guess
137:37 - that would be possibly like socket dot
137:40 - on
137:42 - clothes i think
137:46 - move from
137:48 - rey
137:49 - something like
137:54 - you should keep track of the servers you
137:56 - are attempting to make make connections
137:58 - do not try to make more than one
138:00 - connection to the same server
138:03 - okay
138:05 - and then after you connect remove it
138:10 - there's some issue i remember adding
138:11 - that there's some issue that was
138:14 - causing an infinite loop of
138:16 - servers connecting to each other
138:19 - yeah
138:21 - uh server should never attempt to create
138:23 - a connection to its own address you
138:25 - should clone your node one folder at
138:26 - least two times all of your nodes should
138:28 - have the exact same code with the
138:29 - exception of the env file um you should
138:32 - have at least real three nodes running
138:34 - use those ports
138:37 - all of your
138:38 - nodes should have an open socket
138:40 - connection to all other nodes um
138:43 - there's a bonus there hints adding
138:45 - console logs
138:47 - can really help
138:49 - websocket servers
138:51 - okay here this looks
138:53 - promising
138:55 - copy i can't even copy from there can i
138:58 - yes i can
139:01 - server
139:02 - port so
139:07 - make this server
139:08 - and the part is going to be
139:13 - my
139:15 - port
139:18 - and then server.on connection
139:22 - so
139:23 - to create a server listening on the
139:25 - given port i wonder
139:28 - so that's listening already server.on
139:30 - connection
139:44 - log
139:49 - connection three
139:51 - seed
139:56 - that
139:58 - socket that on message runs when i suck
140:01 - it sends a message to your server
140:04 - nest it within the connection function
140:14 - you want to make a note of this i'm
140:16 - missing closing parentheses right here
140:26 - so we have a string that comes in that's
140:33 - console.log
140:36 - message received
140:40 - and i'll just go plus data string i
140:43 - think that'll be
140:45 - this
140:49 - for sure
140:51 - so
140:58 - and how to work with sockets so here's
141:00 - like your server
141:04 - and then
141:05 - you kind of want a second thing which is
141:08 - opening
141:08 - a socket connection to the server
141:12 - from the server
141:14 - yeah so you want to act as a server a
141:17 - websocket server and as a websocket
141:18 - client
141:19 - pretty much
141:22 - um
141:27 - uh
141:29 - let's run the test
141:31 - i got one
141:33 - nice
141:36 - um
141:41 - okay when a node opens the socket
141:43 - connection
141:45 - so the first thing we want to do
141:47 - is try to connect i know i need a
141:49 - connect function so i need like this
141:51 - function
141:52 - connect address that's what i'm going to
141:55 - do
141:58 - and
142:07 - the first thing we want to do is up here
142:09 - anyway um
142:11 - we need to attempt to open
142:15 - a connection to all those addresses so
142:22 - something like
142:28 - known appears that
142:32 - each
142:34 - here
142:36 - connect
142:41 - here
142:45 - council log
142:51 - something to connect to
142:55 - here
142:56 - address
142:59 - save it and we'll just see if anything
143:01 - happens
143:03 - so i have to go actually into this
143:07 - node one folder and then i can run
143:12 - that okay
143:15 - and something is running you're
143:18 - attempting to connect
143:20 - and it is still running it is not
143:23 - stopping running
143:27 - but
143:29 - successfully made a for each call
143:32 - loop
143:35 - um
143:38 - so
143:41 - if we want some catches here if address
143:45 - not equal to my
143:48 - address so we don't want to try and
143:49 - connect to
143:52 - our own address and
143:56 - and we're not
143:59 - something to connect to it
144:03 - and
144:05 - not attempting
144:09 - clues address i think that should work
144:15 - so we can actually test that
144:18 - i'll leave that console log in there and
144:28 - this first node has a
144:31 - port of
144:33 - 4001 i think yeah
144:37 - that's
144:39 - my own address so we'll not attempt to
144:41 - connect that
144:43 - to only attempt to connect to that one
144:48 - all right
144:49 - so
144:54 - attempt
144:57 - attempting to connect
144:59 - addresses dot push
145:02 - we are now attempting to connect to an
145:04 - address
145:08 - yeah when
145:11 - i went through this i remember i wanted
145:13 - to use
145:15 - sets
145:17 - just because i think it
145:21 - works quite well when you have
145:24 - elements that you don't want to repeat
145:26 - and
145:28 - that you want to easily remove
145:34 - so that's just a
145:35 - did it work
145:38 - did it work or not
145:40 - yeah no it works it's just you need to
145:41 - remember when you're
145:43 - passing it through the api to
145:46 - i think sets have a two array method or
145:48 - else you just have to say array from and
145:50 - then pass the set in
145:52 - yeah
145:53 - yeah
145:56 - okay
145:59 - so when a socket connection to a server
146:02 - is established send a message to the so
146:06 - i think
146:09 - we want to move this handshake message
146:12 - and
146:13 - trying to connect and then
146:17 - once we do connect we want to
146:21 - send this
146:22 - um
146:25 - you go to these helper
146:27 - syntax
146:29 - server sockets
146:32 - so think we do yeah that looks right
146:37 - so all in here we're going to try to
146:40 - connect to this address
146:46 - on open on close on air
146:52 - runs when any connection is served has
146:54 - been established so that sounds
146:56 - promising
147:04 - so i should in here want to send this
147:09 - message
147:13 - suck it dots and
147:23 - that some data
147:27 - wanted to be
147:31 - i just go
147:35 - i can't go like that
147:39 - is it jason that stringify or is it
147:42 - something to string i think string of
147:45 - fireworks here yeah it's jason
147:49 - yeah that's what i do whenever i'm
147:51 - working with websockets
147:55 - um
147:59 - i think i'm missing
148:01 - another one of these
148:11 - maybe i'll just
148:13 - give myself a little
148:18 - more
148:22 - formatting there and i don't know why
148:23 - i'm getting four spaces that is
148:26 - no good
148:29 - but i can handle it for now
148:32 - okay so let's uh let's throw
148:35 - that's a log
148:38 - connection
148:40 - open so you know what else we need to do
148:43 - a
148:46 - attempting to connect to addresses
148:52 - splice or something
148:55 - and then find
149:00 - press
149:02 - one that won't work with it
149:06 - no i think you need to do the
149:09 - attempting to connect addresses dot find
149:12 - index
149:26 - yeah it's the index something
149:34 - um
149:37 - so can i
149:42 - do
149:47 - something
149:49 - to
149:50 - connect
149:52 - addresses dot index
149:56 - of
150:03 - i think that'll work
150:07 - let's see how many off for one errors
150:08 - there are
150:18 - so and then
150:20 - we want to
150:22 - go to connected addresses dot push i
150:25 - think
150:26 - address so we have now connected
150:30 - action open
150:39 - and then suck it dot
150:44 - on
150:47 - clothes
151:00 - it
151:01 - on
151:04 - here
151:17 - i'm probably just i'll just throw some
151:20 - console out i'll pull that log
151:23 - they're connecting
151:26 - to
151:28 - run through that there
151:32 - tempting
151:40 - i'm gonna remove it from this
151:47 - um
151:50 - and then on close
151:52 - we should just
152:19 - addresses
152:22 - from there
152:31 - it's going well i think although it may
152:34 - all crash and burn on me but we'll see
152:40 - i'm trying to think all of the things
152:42 - that fire the
152:44 - error event
152:45 - that's emitting area event
152:48 - for sockets because
152:50 - what happens if you splice and index of
152:53 - returns negative one
152:58 - so right now you're treating it as if on
153:01 - error only happens when there hasn't
153:04 - when
153:05 - on open hasn't happened
153:07 - now
153:08 - um
153:10 - here
153:12 - i don't know what splice does if
153:13 - attempting to
153:14 - connect dot index of returns negative
153:17 - one
153:19 - because it might
153:20 - start from the
153:23 - the back of the array and then just
153:25 - remove some random last element
153:29 - drawn here
153:35 - um
153:50 - i'm gonna
153:53 - bring this tab over
153:57 - i think you're on to something
154:03 - so if i splice a negative one
154:06 - one
154:08 - this turns into this
154:13 - so it removed june for some reason the
154:16 - last
154:18 - yeah
154:20 - so
154:24 - i think
154:26 - yeah i would i would take that
154:28 - attempting to connect address out
154:31 - and make sure that it's not negative one
154:35 - yeah i like that
154:39 - just
154:41 - if
154:51 - if uh
154:53 - index greater than or equal to zero
155:14 - like that and probably
155:19 - i feel like i wonder if i should do the
155:21 - same thing here
155:25 - i think it would always be in here if
155:27 - it's closing
155:31 - we're gonna leave it
155:32 - watch it crash
155:35 - yeah
155:37 - so
155:43 - we start up
155:45 - we try to connect to the known peers
155:46 - none of them will be running right now
155:50 - so nothing's gonna happen
155:52 - yeah
155:54 - and then
155:57 - message received
155:59 - so the message that we receive should be
156:01 - this message handshake
156:04 - yeah um
156:06 - and then
156:08 - well do you want to
156:10 - i
156:12 - i think you also have to parse that
156:14 - message into
156:17 - yeah
156:18 - if you wanted to um but you want to just
156:21 - create a bunch of nodes
156:23 - and test it out
156:25 - see what happens
156:27 - yeah
156:28 - because they should try to connect to
156:29 - each other shouldn't they
156:32 - um
156:33 - yeah they should send some messages
156:35 - around yeah okay so there's some helper
156:38 - functions to run
156:42 - to clone it
156:44 - i'm in the node 1 folder so i actually
156:47 - have to
156:50 - back out here and then i go known clone
156:53 - node
156:55 - i might
156:56 - do it twice so we have three so now we
156:59 - have three
157:01 - and look over here and split this up
157:10 - and then now i gotta
157:16 - go into each folder
157:19 - cd node 2
157:22 - arc
157:25 - cd
157:26 - node
157:27 - 3
157:29 - and run
157:30 - the thing
157:33 - we've got problems
157:41 - i know
157:46 - attempting to connect a dress
157:51 - dresses
157:58 - um
158:05 - so
158:09 - you gotta go back you can't just copy
158:11 - the code over to the different notes
158:12 - which is probably the way to go
158:17 - but you can also
158:22 - use this uh
158:23 - node delete nodes which will delete the
158:26 - things there you go node
158:29 - clone
158:32 - on
158:34 - tv node two
158:38 - i would have tried running the first one
158:39 - before
158:40 - cleaning them again but
158:49 - it's syntax error
159:00 - what's here
159:02 - cannot find name attempting to connect
159:06 - attempting to connect
159:10 - addresses
159:15 - attempting to connect
159:17 - addresses
159:23 - that's a typo in the
159:25 - boilerplate code attempt
159:29 - i think i'll edit that
159:33 - that is a problem
159:36 - attempting it's everywhere oh no
159:46 - attempting
159:52 - attempt attempt
159:55 - ding
159:56 - okay we'll save it
160:00 - run okay we
160:02 - awesome nice catch
160:05 - um
160:07 - we are attempting to connect to 4003 we
160:10 - got an error
160:12 - because i have to let my captain i'm not
160:15 - running all right
160:34 - note index
160:38 - oh it did it connected
160:42 - attempting to connect to so this one
160:44 - tried to connect to both this is 4002.
160:48 - air connecting to 4003 that one's not
160:51 - running connection to 4003
160:53 - open connection open
160:57 - connection
161:00 - to
161:06 - open
161:08 - okay
161:09 - so we had
161:11 - a connection opened
161:13 - 4001 and then we received a message on
161:16 - 4001.
161:23 - um
161:26 - received a message
161:30 - here and it's got
161:32 - both addresses
161:36 - and so
161:37 - [Music]
161:40 - um
161:43 - i guess
161:44 - const
161:45 - data equals json.parse
161:48 - data
161:52 - um
161:55 - not quite
161:59 - whoops
162:01 - dated too
162:04 - not quite
162:05 - date a string oh there we go
162:10 - okay i don't like this anyway because
162:14 - the field is data um
162:17 - we'll go message
162:20 - and then
162:26 - um
162:27 - message that oh what the heck was that
162:34 - but again
162:35 - i have a typo
162:38 - just that data got for each
162:42 - address
162:46 - connect
162:54 - let me see how many times you'll do this
162:56 - okay
163:03 - like is that all i need
163:06 - that might be enough
163:25 - all right well let's try it
163:27 - so they should connect to each other i'm
163:29 - gonna
163:30 - re-close this one
163:33 - um
163:40 - delete my nodes
163:44 - clone them
163:46 - again
163:49 - node
163:50 - index will run this one so
163:55 - it's running
163:56 - why does it print closed there at the
163:58 - end
164:02 - connection closed
164:04 - connection closed
164:08 - um
164:09 - so there it is your
164:13 - um
164:14 - air connecting so first it goes to error
164:20 - and then it goes to close for some
164:22 - reason
164:25 - well
164:27 - i suppose that makes sense because it
164:28 - connects or does it
164:30 - connect well attempts to connect right
164:34 - it doesn't actually connect until it
164:36 - gets a response i presume
164:41 - yeah i don't know why it would close if
164:42 - it hasn't
164:43 - opened
164:47 - no i don't know
164:49 - oh well
164:51 - number two um node index so now
164:55 - we are in a loop oh
164:58 - no that's fun
165:02 - up
165:02 - somebody help
165:08 - crash it trash it
165:12 - okay we're alive
165:16 - um
165:18 - that's quite funny
165:23 - so
165:25 - if address not equal my address and not
165:28 - attempting to connect addresses that
165:30 - includes address
165:34 - socket.on close on air
165:45 - let me see what it says over here
166:00 - um
166:04 - you should add what the heck happened i
166:06 - can't even see my terminals to find out
166:11 - um
166:18 - so
166:20 - i had a
166:21 - server
166:22 - listening
166:24 - i started up the first one
166:33 - and then i started up
166:36 - the first one tried to connect but it
166:38 - didn't make any connections because
166:40 - there's nothing else to connect to the
166:41 - second one opened
166:44 - and connected to the first one
166:49 - and sent the first one this message
166:52 - its own address
166:54 - yes just its own address
166:57 - and so then the first one
167:00 - tried to connect to the second one
167:07 - which should assuming you want to not do
167:09 - the connect if
167:11 - it's already connected
167:14 - so
167:16 - yes you need another
167:17 - yeah
167:18 - yes i do that is the problem
167:24 - perfect that's teamwork right there
167:32 - yeah don't think there's anything wrong
167:34 - with that
167:36 - if connected it and
167:39 - okay
167:40 - i'm
167:42 - doing this with my eyes closed okay
167:45 - if
167:46 - address not equal to my address and if
167:48 - not
167:51 - then just if not connected
167:54 - it's okay
167:58 - all right let's try it again
168:04 - um
168:15 - okay we've got several nodes
168:18 - and
168:20 - run that one
168:21 - okay that looks
168:23 - good
168:27 - cd node two
168:31 - index
168:33 - okay okay i think that's good
168:37 - so this one got a message
168:41 - with the two addresses and then it
168:43 - attempted to make a connection there and
168:46 - it opened one
168:47 - all right
168:49 - let's see what happens here
168:52 - um
168:54 - cd
168:57 - three
169:05 - okay
169:13 - oh that'll break
169:27 - oh we've got a whole bunch running
169:32 - four nodes running all connected to each
169:34 - other and i think that should pass
169:38 - well no infinite loops is a good sign
169:48 - crossing my fingers i see a lot of x's
170:06 - message
170:09 - do i need to do more
170:11 - here
170:24 - on close on error send data
170:28 - that really looks
170:30 - good go ahead
170:32 - well
170:33 - i'm just thinking so the server
170:38 - it's only connecting
170:42 - when it receives a message
170:58 - does the
171:07 - so you have
171:08 - on open you're sending something
171:22 - don't you want to send from the server
171:26 - the
171:27 - connected addresses
171:29 - not from the client
171:36 - this kind of is the whole thing is the
171:39 - server
171:40 - you can call it a client and now that
171:42 - makes
171:43 - sense for typical websocket stuff
171:48 - well that that it
171:50 - the
171:51 - um
171:59 - so
172:00 - when you say new websocket that that's a
172:03 - websocket client
172:05 - yeah when you say new web socket server
172:07 - that's a
172:10 - websocket server so
172:13 - i'm thinking
172:17 - when the server
172:19 - receives a connection
172:22 - they should send the server should send
172:24 - here are all my connected addresses
172:34 - you might be right
172:36 - didn't read any of this hardly
172:38 - um
172:46 - oh i did read through it pretty good
172:49 - if sorry
172:51 - so when you connect to a server you
172:52 - should send it a message with these
172:58 - but
173:06 - the server doesn't need to because
173:10 - what you're basically doing
173:12 - right now is
173:14 - if you start up node 5
173:18 - then
173:19 - it's not connected to anything
173:22 - but it's
173:23 - whoever first it makes a handshake with
173:25 - it's saying here are my connected
173:26 - addresses
173:29 - as opposed to
173:30 - connecting and the server saying here's
173:32 - everything i'm connected to
173:39 - so note 5 would send it
173:43 - it would start up it would connect to
173:46 - this first one
173:49 - and send it its own address
173:53 - and the first one
173:55 - would receive it
173:57 - and then attempt to connect back to it
174:02 - and then when the first one connects
174:04 - back to five
174:06 - it would then send
174:08 - all the connected addresses
174:10 - where five would
174:13 - then then attempt to connect to two
174:15 - three and four
174:22 - maybe that's not the right way to go but
174:26 - what is there anything in the console
174:27 - that's
174:29 - giving
174:30 - reason for the failures
174:34 - i'm doubtful
174:41 - this is not
174:44 - so that says it's crashing
174:50 - that's throwing
174:53 - um the tests pretty much just try to
174:55 - make connections to all the different
174:56 - things and see what the handshakes come
174:58 - back is
175:00 - yeah it's not reaching the assertions
175:06 - which is why it's just an empty object
175:13 - do you think
175:14 - i'm i mean it seems like it seemed like
175:20 - it was working they were all connected
175:22 - to each other so it seemed like that
175:23 - they
175:25 - should have passed and that it was
175:27 - working as it should have been right or
175:30 - no
175:31 - maybe i'm missing something
175:33 - um
175:35 - we'll start start node four up again
175:38 - let me close
175:39 - everything
175:41 - oh
175:42 - there we go
175:44 - so node one
175:51 - um
175:53 - not quite
175:56 - over
176:06 - cd node one
176:08 - node index
176:17 - node two
176:19 - started
176:20 - attempted to connect to
176:24 - one
176:25 - and three
176:26 - error on three
176:30 - and one worked
176:32 - yep
176:33 - and then the message received is i am
176:36 - connected
176:38 - to one and two
176:48 - oh yeah okay so it's it's my address and
176:50 - connected addresses
176:53 - yeah yeah
176:55 - that should be right
176:59 - yeah um i think that that makes sense
177:02 - cd node
177:04 - three
177:12 - let's see what this one said
177:15 - it gets a little busy here
177:17 - yeah
177:18 - um attempting to connect to one
177:21 - one open
177:22 - and then it sent me
177:27 - all these
177:29 - yep
177:30 - attempting to connect to two
177:36 - and the first one received these two
177:39 - which seems right
177:42 - yeah
177:44 - attempting to connect to two
177:47 - and it did open and then it received so
177:49 - 2 sent it back this
177:51 - then stopped because it was already
177:53 - connected to all those
178:01 - message type handshake data
178:07 - i see something
178:09 - i see something
178:11 - in there
178:17 - i see something
178:18 - oh yeah yeah yeah yeah okay so i'm gonna
178:21 - this time
178:24 - i'm going to
178:26 - copy
178:33 - code
178:58 - me
179:02 - okay i think that looked great
179:05 - tess i think
179:07 - it's patina thing would show up in the
179:08 - console though
179:11 - nice
179:13 - we got it
179:15 - if i run the test again
179:17 - there they go
179:23 - well
179:24 - how long did we spend on a typo
179:29 - about the average time you usually spend
179:31 - on a typo
179:40 - awesome that's three down
179:47 - so moving on to
179:50 - the
179:52 - fourth project
179:55 - which is
179:57 - building a web through client side
179:58 - package for your d-app
180:01 - and in this project we're going to be
180:03 - building a client-side package that's in
180:06 - the form of a class that can be used to
180:07 - interact with a web3 provider which
180:10 - would basically be your network for a
180:13 - blockchain
180:14 - we can see the files we have here
180:17 - the
180:18 - class is in this
180:20 - index.js file that we need to build out
180:23 - we can see an example of a provider here
180:27 - which is basically just a rest api
180:29 - consisting of some routes that you would
180:31 - interact with in rpc calls
180:35 - and
180:39 - so
180:41 - we should first cd into
180:44 - the build a web 3 client side package
180:50 - 3.
180:52 - and we have the boilerplate
180:54 - in the index.js file
180:57 - and we can see an example of the way
180:59 - that this api that we're building out is
181:01 - going to be used
181:03 - in this example client
181:04 - where we are importing the class
181:09 - and we can see some methods on this api
181:11 - such as set client address
181:14 - init smart contract
181:16 - [Music]
181:17 - and we can see that basically the api
181:18 - just uses this to interact with
181:21 - uh the
181:22 - smart contracts that we'll be building
181:24 - out where we can call the methods
181:26 - that might exist with a smart contract
181:29 - and there's an example idl that we pass
181:31 - into initsmart contract that we can
181:36 - find
181:38 - here and this is
181:40 - very basic ideal which is
181:45 - basically a schema of your smart
181:47 - contract it tells you
181:48 - in these instructions it's basically the
181:50 - methods of the smart contract we have a
181:52 - setclick
181:54 - method and a getcontract account method
181:56 - the args expected for the setclick
181:58 - method is
182:00 - one argument that is of type string
182:02 - and there are no arguments to the get
182:04 - contract account method
182:09 - the user stories
182:10 - that we will be completing
182:13 - let's
182:14 - just go for it so
182:17 - we know that we will be
182:20 - we need a method that is set client
182:22 - address
182:27 - and that takes in an address
182:30 - and doesn't return anything and what
182:32 - this method does is it sets the class
182:35 - address property to the given address so
182:38 - that's
182:38 - the start address
182:40 - to give an address
182:42 - which means that we need to construct
182:45 - our class
182:50 - with some address that i'll set for null
182:56 - okay we'll call that one down the next
182:59 - method
183:00 - is call
183:03 - and it accepts an rpc call
183:06 - object
183:08 - and it returns a promise so we know that
183:11 - this is asynchronous
183:16 - and
183:17 - what this does is makes a post to the
183:20 - call smart contracts
183:22 - route
183:24 - on the ahref of the provider property
183:28 - so
183:30 - this class will have
183:33 - a provider property
183:36 - that will be equal to
183:38 - something
183:41 - and
183:43 - we will want
183:46 - to
183:48 - make a fetch
183:51 - to this route which
183:55 - what we can do is
183:58 - the provider
184:00 - href
184:02 - and it is to the call
184:06 - in fact
184:10 - and then we want this to be
184:15 - first method
184:19 - which means we will have a body and the
184:21 - body of the post should be the rpc call
184:23 - object literal and the address property
184:25 - of the web3 class
184:27 - so we need a body here
184:30 - and let's just
184:34 - create a body that is
184:37 - the rpc call
184:40 - and
184:43 - the address
184:45 - of the class
184:50 - i remember when going through this that
184:52 - i struggled with the
184:55 - the url there that when you make that
184:56 - call smart contract it doesn't need the
184:58 - forward
185:03 - right slash
185:04 - so
185:05 - we do have a link down here to the
185:09 - url api of
185:12 - its basic javascript api that also
185:14 - exists in node
185:15 - and
185:17 - if you play around with it a bit you
185:18 - you'll kind of figure out that calling
185:21 - atriff it always appends to the end
185:24 - of the string the forward slash
185:27 - i i suppose the smarter thing to do here
185:29 - would be to
185:30 - um
185:32 - i know i know you would use the
185:35 - path api to the path module and the join
185:39 - method and you would join these two
185:42 - paths together um
185:44 - problem my head i can't think of how to
185:46 - do that with the url api but i'm sure
185:48 - there is a way
185:51 - so
185:57 - now we
185:58 - need to
186:01 - the call should return the result
186:02 - property of the response
186:04 - or throw an error if the response
186:06 - contains an error
186:08 - property so
186:13 - what we need to do is get out
186:16 - the response which is
186:23 - s
186:26 - and if response dot error
186:30 - into throw
186:33 - this will just throw a new error that is
186:35 - that error
186:40 - otherwise
186:43 - we want to return response dot result
186:49 - so that should be that method done
186:54 - and now we need an init smart contract
186:56 - method
186:58 - so we can see this also
187:00 - would there be a way to desire to
187:03 - interrupt there'd be a way to just to
187:05 - make sure it's working other than just
187:07 - like running the tests
187:11 - that's a good question um
187:13 - so
187:15 - it would be a bit difficult uh you would
187:16 - need to get
187:18 - the provider up and running so what you
187:20 - can do is create a new terminal just
187:24 - you don't need to create a new terminal
187:25 - you can start the provider
187:27 - by
187:28 - saying node node provider dot js
187:34 - leave
187:35 - and we can see here what warp does is
187:38 - it
187:39 - starts the provider it deploys
187:42 - the smart contract with just a test
187:43 - smart contract
187:45 - that is located in this package file
187:47 - and then it starts listening on port 301
187:51 - so i suppose we would need to set the
187:53 - provider here
187:56 - [Music]
187:58 - and we could
188:01 - manually do that with
188:04 - new
188:05 - url
188:09 - http
188:11 - localhost
188:14 - v01
188:18 - so from then we could actually just
188:21 - write some tests ourselves so
188:24 - if we wanted to
188:29 - uh let's just do something simple
188:45 - so we could set the client address here
188:47 - and we could just make a thumb
188:51 - and then we could console.log
188:56 - e web3 dot
188:59 - address
189:02 - i think
189:04 - if we did that
189:05 - we can open ourselves a new
189:10 - terminal here
189:14 - and
189:16 - we could
189:19 - run this in node and it should work so
189:23 - except it is a module but we'll see what
189:24 - happens
189:26 - node
189:31 - there it is
189:33 - so we have tested
189:35 - that creating the class works it
189:38 - has starts with an address of null and
189:40 - the provider is this url
189:42 - object and then we change the client
189:46 - address from null to tom and we can see
189:48 - we printed out there
189:50 - if we wanted to do a test on the call
189:53 - we could
189:56 - and yeah say web3.call and we would need
190:00 - to pass in an rpc call
190:02 - uh what that would require
190:04 - is
190:06 - well we could look at it from the
190:08 - provider's perspective
190:12 - the
190:13 - [Music]
190:14 - call method in this case
190:16 - makes supposed to call smart contract so
190:18 - he has cool smart contract
190:20 - it gets from the body an id method args
190:24 - and address so if we wanted to we could
190:26 - just add in
190:28 - an id
190:31 - 0
190:33 - args would be
190:35 - let's leave it as an empty array
190:38 - method
190:41 - we'll probably just get this wrong and
190:42 - we can say test
190:44 - what else do we need
190:46 - address so the address would be the web3
190:48 - dot
190:50 - address
190:53 - you can pretend that that works
190:56 - and this is an async method so let's
190:58 - just get the response out of that
191:02 - and console.log
191:06 - e response
191:08 - and we run our script again
191:12 - and we get an error
191:14 - which is very fun
191:17 - where is this error in json.pass so
191:21 - actually while we're debugging debugging
191:23 - debugging
191:25 - console.log the response here
191:29 - and
191:32 - we'll check why that is happening
191:35 - this is the response it looks like it's
191:36 - just the old average um http response
191:41 - and so why is json.parts not working
191:43 - probably because we need to use the
191:47 - weight res.json method
191:56 - and
192:01 - let's not console.log that
192:08 - okay so we get a response from the
192:10 - server here which is smart contract with
192:12 - id undefined not found
192:17 - why is it saying id undefined not found
192:20 - that is a very good question because we
192:21 - have defined it as zero
192:26 - but clearly that just doesn't exist and
192:29 - we can see
192:30 - here also in the provider it's it's
192:33 - logging out those errors
192:37 - um
192:39 - so
192:40 - let's clear that for now and we will
192:42 - come back to it
192:50 - that is a bit more involved than i would
192:51 - hope it to be
192:55 - you can see it it basically if you get
192:58 - an idea of what going what's going on in
192:59 - the background you need to provide a
193:00 - running
193:01 - and then you can just run the script
193:02 - using node and it all works and fetch
193:05 - works in the fetch api works in node
193:07 - version
193:08 - i think it's 17 and above so
193:12 - 18 is
193:14 - officially released so that is what the
193:16 - docker image is running on
193:21 - i feel like that would help
193:23 - it would have helped me when i was
193:25 - playing with this is kind of a way to to
193:27 - test it more
193:29 - and see if it's working or not
193:32 - other than just kind of writing the code
193:36 - and hoping
193:40 - now that that is a good point it's
193:41 - probably something we can add on to this
193:42 - in future prs uh to make it more
193:45 - user-friendly and just a bit more a bit
193:47 - clearer obviously i think once you've
193:49 - gone through the practice projects and
193:50 - you've learned a bit of content and you
193:52 - understand rpc calls better as well as
193:54 - you know having built out your own
193:55 - provider it makes a lot of sense what is
193:57 - happening here where the fetches are
193:59 - going and what's being returned
194:02 - but
194:03 - until then we can definitely try and
194:04 - make it better
194:09 - so
194:10 - if this in its smart contract what we
194:12 - need to do here is we need to
194:14 - take in the idl which is your
194:18 - um your smart contract signature
194:21 - and we need to
194:23 - basically turn that into callable
194:25 - methods
194:26 - so we can start by we know we want to
194:28 - return
194:30 - the smart contracts methods
194:34 - and that means we want an object
194:37 - and we will want to
194:39 - here's an example if we have an idl with
194:41 - these instructions where we have these
194:43 - different methods defined by the handles
194:46 - get favorite number and set favorite
194:47 - number
194:48 - you can see that after we initialize the
194:50 - smart contract it returns a smart
194:52 - contract object
194:54 - that has these properties the set
194:56 - favorite number method
194:59 - and sorry the get favorite number method
195:01 - and the set figure number method
195:05 - so what we will want to do
195:07 - is
195:09 - for each instruction
195:13 - of the idl
195:19 - loop over that and add the handle to the
195:22 - smart contract
195:24 - so we want to put in the instruction dot
195:27 - handle
195:30 - we need to set that equal to
195:33 - a function because that's what the
195:35 - instructions are they're just functions
195:37 - and
195:38 - in some of the cases the functions will
195:40 - be asynchronous
195:42 - they don't have to be but they can be so
195:44 - we just add the async method there and
195:46 - we know that there are some args that
195:47 - this will accept but we don't know how
195:49 - many
195:55 - we've defined it as a function
195:57 - now
196:02 - what we need to do is
196:06 - the callable method should return a
196:08 - promise okay so that's
196:10 - set here in async and it resolves the
196:12 - result of the core method somewhere in
196:13 - here we are calling the start
196:16 - call
196:18 - and we are returning it so
196:20 - let's not call
196:24 - except we are
196:26 - waiting that because call is
196:28 - is
196:31 - and
196:33 - from here
196:35 - we need to construct the rpc call
196:38 - so just as we did
196:40 - down here when we passed in the
196:41 - obviously call to the core method we are
196:44 - wanting to
196:48 - construct this out of
196:50 - where am i
196:52 - yep
196:53 - we want an rpc call
196:57 - we need an id
196:59 - which actually
197:01 - is inside before loop
197:05 - and
197:06 - even more so we need it to be
197:10 - inside the function and we get from the
197:13 - instruction
197:17 - it's actually from
197:18 - the idle itself it has a property id
197:25 - passing the id of the smart contract so
197:27 - that the
197:29 - giver provider or
197:30 - um in our case
197:32 - more likely validator will be running
197:34 - the actual code of the smart contract
197:35 - needs to be able to find the smart
197:36 - contract on the blockchain so we pass in
197:38 - the id
197:40 - and
197:41 - what else did we need we needed
197:43 - args and a method so the method
197:46 - we
197:47 - know is the instruction handle
197:52 - and
197:54 - the
197:56 - aux is the argus that passed into the
197:59 - parameter
198:01 - of the function
198:06 - and did we need anything else
198:09 - so
198:11 - the address is done by the call property
198:13 - itself we actually didn't even need to
198:15 - include that
198:16 - um
198:17 - it's not it's overwritten anyway
198:21 - see when we wrote this out the body
198:23 - added the address for us
198:25 - so it's just the rpc call here and we
198:27 - can pass the rpc call into
198:32 - this one
198:35 - now
198:37 - what we need to do at the end of in a
198:39 - smart contract is return this object
198:40 - that we have just recreated created
198:48 - okay
198:56 - are you happy with that though
198:57 - i think so
198:58 - [Applause]
199:01 - okay
199:02 - well we are moving on to create this get
199:04 - balance method if if you ran the test
199:07 - would it would it pass those
199:10 - or is there
199:12 - we can try and run the tests definitely
199:15 - it's always a good idea uh run the test
199:16 - as often as you can
199:18 - and hope things don't break
199:24 - so we're on the tests and we are
199:28 - failing absolutely everything
199:31 - there are a lot of tests yes actually if
199:33 - you're wanting more information you can
199:34 - probably read the test text yourself
199:37 - we can
199:39 - look at why it's failing and it seems
199:41 - that something is erroring out in our
199:43 - code
199:45 - i think
199:47 - one of our
199:50 - issues that i definitely know of
199:52 - is when we are creating
199:57 - our
200:00 - web3 class
200:03 - um yeah we need to actually pass in
200:07 - and i'm pretty sure i had it written
200:09 - here somewhere
200:10 - yes
200:13 - remember it
200:15 - it's a initializer or something
200:19 - yes
200:22 - you get the address from that the
200:24 - provider address from that
200:30 - i never know where it is
200:32 - um
200:34 - i wonder if it's in the
200:36 - castle
200:37 - so
200:38 - in here we need the provider
200:41 - address and we just replaced this hard
200:44 - coding that we did for our testing
200:47 - better
200:49 - and the wonder if changing that will
200:50 - allow us to pass any of these tests
200:52 - isn't it is it provider that
200:55 - hr for url or something or is it just
200:57 - provider
200:59 - well the constructor just accepts a
201:01 - string
201:02 - okay and we turn that into our url
201:04 - ourself
201:05 - okay
201:06 - and
201:07 - we're still failing all of those so i
201:08 - think one of the better things we can do
201:10 - is finish out the api here
201:13 - just so we don't get any crashes and we
201:16 - will be defining a transfer method
201:20 - that takes in
201:22 - an object
201:24 - and let's just say from to
201:28 - amount so this is
201:31 - all to transfer from one address to
201:33 - another address a certain amount
201:38 - and if we do that
201:41 - see what
201:44 - running the tests
201:46 - does nothing
201:50 - we can look into what is actually
201:51 - happening by reading the
201:54 - server output
201:56 - so web 3 is not defined
202:03 - which means we are not exporting this
202:05 - well
202:06 - we need to make sure
202:08 - let's just comment about our tests for
202:10 - now
202:16 - okay there we go so our tests were
202:17 - messing up
202:18 - the output there i'm not exactly sure
202:21 - why but we
202:25 - we will leave it like that
202:28 - so we are actually passing
202:30 - first five here
202:32 - we're exporting our class we are
202:35 - so your web3 class should have a
202:36 - provider property that is an instance of
202:38 - url constructed from the initializer
202:40 - argument that's what we've just done
202:42 - here in the constructor
202:45 - and we have the say client address
202:47 - defined correctly
202:50 - there is an asynchronous method
202:53 - with the handle call we have done that
202:56 - and call makes a post to
202:59 - this route
203:03 - so what we are not doing is post
203:06 - call smart contract should have a body
203:08 - including the json stringified version
203:10 - of the rpc object literal so we are not
203:13 - stringifying our body
203:17 - it's always something to remember
203:25 - okay
203:27 - and let's keep going so
203:30 - we need a content type header set to
203:33 - application
203:34 - json
203:36 - so that would be in the headers
203:40 - and we need
203:43 - [Music]
203:46 - never remember if this actually needs to
203:48 - be capitalized in a certain way so we'll
203:50 - just try it out
203:53 - and we are sending through json
203:56 - it looks like the it's capitalized in
203:59 - the
204:00 - text and the instructions
204:03 - so if you read your instructions
204:04 - correctly
204:06 - then you will probably have a better
204:08 - time passing the test thank you tom
204:12 - so the request should have a body
204:14 - including the
204:16 - json stringified version of address we
204:20 - are doing that yes he has address
204:23 - the core method should return a promise
204:25 - yes we are doing that if the response
204:27 - contains error throw yes oh we are
204:29 - passing that excellent
204:31 - we're passing all of these
204:35 - and then down here we are failing
204:39 - one of the internal tests where it's
204:40 - actually testing out the api
204:43 - so if we go to 17
204:45 - in the console we can probably see why
204:48 - and these used to be in
204:50 - numerical order but for some reason they
204:52 - are no longer and it seems that it's
204:54 - just crashing there so
204:58 - let's run the tests and see if we're
204:59 - passing any more
205:01 - yes we are
205:05 - almost there
205:07 - and now we need to actually to find out
205:08 - the get balance api
205:11 - so we need to make a post this is more
205:13 - of the same that we did in the call so
205:15 - i'm actually just going to copy paste
205:16 - this
205:22 - we are
205:24 - matt this is fine so
205:27 - instead of a fetch to call smart
205:29 - contract we are making a fetch
205:31 - to
205:32 - get balance
205:37 - and the get balance request should have
205:39 - a body including the stringified version
205:41 - of address so there's no obc call here
205:44 - there is just address
205:47 - and
205:48 - we can see back in the function
205:51 - definition
205:54 - that address is optional
205:56 - so
205:56 - we need to fall back
205:58 - to
206:01 - well if the argument isn't passed in
206:02 - here then we need to fall back
206:05 - to the
206:06 - classes address
206:13 - and we also need content type here
206:15 - excellent we've done that
206:18 - balance method should return a promise
206:19 - that resolves with the result
206:22 - i think we are doing that resolves with
206:24 - the result yes
206:27 - and
206:28 - if it contains an error throw that error
206:31 - we are doing that
206:33 - okay let's see if we're passing those
206:34 - tests
206:40 - okay
206:44 - and we are so now we need to just do
206:46 - transfer and i think that is again more
206:48 - of the same
206:51 - except now instead of address
206:54 - we need
206:56 - the from to an amount in the body and we
206:59 - need to json stringify this so
207:02 - if we change
207:04 - body to
207:07 - just from to
207:09 - an amount
207:11 - we didn't need to destructure it here
207:12 - but that's fine we'll leave it
207:16 - and instead of get balance we are
207:18 - changing this too
207:25 - okay
207:27 - let's run with this
207:31 - and i wonder if that's it
207:33 - no what are we failing
207:39 - if the response body contains an error
207:41 - property transfer throws an error with
207:42 - the value of the error property
207:45 - are we not doing that
207:50 - looks like it
207:51 - well then let's go to the console and
207:53 - see what
207:56 - expected missing required fields
208:01 - to equal missing required fields from no
208:05 - that's you're not destructuring
208:07 - correctly or something there in that
208:09 - body i think body equals from 21 oh that
208:12 - looks right
208:14 - so in this case we're saying from is
208:16 - undefined
208:18 - but it's expected from to be null
208:23 - expected from to be null so actually i
208:26 - wonder
208:28 - what we want from to be is
208:32 - our address
208:38 - so you know what we should probably
208:39 - actually read the user stories
208:42 - i wonder if
208:44 - it says the body should be jason's
208:46 - string of my body okay you are doing
208:48 - that
208:49 - i suspect we need to actually say from
208:52 - and this needs to be
208:54 - either from yeah
208:56 - or this dot
208:58 - address
209:02 - and that something's just wrong there
209:04 - but yeah
209:05 - that might work
209:06 - yeah we might need to make that actually
209:08 - clear in the
209:10 - tests and things there we go okay
209:13 - so we passed all of those
209:16 - that was quite involved but got there in
209:18 - the end
209:23 - and
209:24 - yeah
209:30 - okay on to the
209:32 - final integrated project
209:36 - and this one is
209:37 - build a smart contract in rust
209:40 - so for this project
209:42 - we need to create and deploy a smart
209:45 - contract using rust
209:46 - that keeps track of how many users have
209:49 - clicked a button
209:51 - very fun
209:53 - and
209:54 - our boilerplate starts us with a rust
209:57 - library consisting of unit tests and
210:00 - integration tests that we are expected
210:01 - to pass
210:03 - so let's get that up here
210:07 - nice so we can see where we need to edit
210:08 - our code and these are the unit tests
210:10 - the integration tests are in the tests
210:12 - directory
210:14 - we can see those here
210:16 - if we ever need to actually look at
210:18 - those
210:20 - so
210:24 - boilerplate already contains the
210:25 - necessary crates to complete the user
210:27 - stories
210:28 - but we need to import them into the code
210:31 - and you will be required to define
210:33 - structs and functions matching those
210:34 - used in the tests
210:36 - and we should only need to work in this
210:39 - lib.rs file
210:42 - so actually let's just cd into that
210:44 - directory cd into bold
210:48 - a yeah what are we smart
210:51 - american rust
210:53 - and
210:54 - we might as well just run cargo test
210:57 - lub to get this all going
211:00 - that seems to working well
211:03 - and here are the user stories
211:07 - not too many
211:09 - some useful resources about wasm and
211:12 - rust in general
211:15 - and some tips
211:20 - okay
211:22 - so let's get started
211:25 - our smart contract uses wesenpac to
211:27 - compile the rust code to javascript for
211:29 - node.js um we already have wesempac
211:31 - installed
211:32 - so that is fine and we'll need to build
211:35 - our smart contract data using it
211:38 - the smart contract exports an initialize
211:40 - function that returns this funny result
211:44 - so we will need to export using the
211:48 - public keyword to make the function
211:49 - public and it is a function and we want
211:51 - to initialize it
211:55 - and this function takes no arguments
211:57 - and it returns this
211:59 - new result
212:03 - public function initialize
212:06 - with an s
212:09 - okay so we are returning that result and
212:13 - what we can do for now is just say okay
212:18 - something
212:20 - and i think
212:23 - you see here in the user story it's this
212:25 - function returns a context wrapped in a
212:26 - js value
212:28 - whatever that means um
212:31 - this will probably help us
212:33 - wrap a value image s value using
212:35 - the from survey
212:38 - implementation on js valley but for now
212:41 - i will just continue with the api and
212:43 - build out
212:45 - ob functions so we also need to export a
212:48 - setclick method
212:52 - that accepts a js value with the context
212:54 - type
212:56 - okay so we need some sort of
213:00 - context type in there but it's a js
213:02 - value it's not context
213:05 - because it is coming from the javascript
213:09 - interface
213:11 - and we are returning again the results
213:21 - and what does this so this
213:24 - function also accepts a string as the
213:26 - second argument so we need to remember
213:28 - that
213:29 - and
213:31 - which is the address of the user who
213:33 - clicked the button so
213:36 - and strings across
213:39 - rust and javascript are
213:42 - relatively similar in that they're just
213:44 - strings
213:46 - so we need
213:48 - and i keep forgetting the fn keyword
213:58 - get contract account it returns it
214:01 - accepts a js value with context type so
214:04 - we can just context
214:06 - this value
214:09 - and return
214:11 - anything
214:17 - okay
214:20 - and this function returns an account
214:23 - wrapped in a js value again something
214:26 - that we may not know what means so let's
214:28 - just add some
214:30 - use to this
214:32 - i enjoy doing that because we can run
214:36 - the tests probably from here
214:38 - what is this this is just like a little
214:40 - rust
214:42 - filler function that stops it stops it
214:45 - from crashing or something
214:47 - pretty much exactly that yeah so
214:49 - normally if you have a um a linter going
214:51 - with this as well
214:53 - then
214:54 - it prevents the linter from saying
214:56 - hey you have unused stuff and hey
214:59 - you know you say you're returning this
215:01 - but you're not actually returning
215:02 - anything so
215:03 - i find the to do macro quite useful um
215:06 - but i remember that i actually need to
215:08 - import resin bind in and we can use the
215:12 - prelude to get
215:14 - all of that fun stuff that we've used
215:16 - our js value in jsera and
215:20 - yeah let's run the tests with this and
215:21 - just see if we pass any of the
215:22 - integration tests but it looks like we
215:25 - erroring out because of this
215:29 - so when in doubt
215:31 - to do
215:35 - i guess so
215:38 - so we are still not compiling because we
215:40 - need to actually define the account
215:43 - and context structs
215:46 - which we have definitions for over here
215:49 - so
215:50 - your library should export a struct
215:52 - named account
215:54 - so let's just do that yeah so struct
215:58 - account
216:01 - and it has the following fields total
216:03 - clicks
216:05 - and that is a u64
216:08 - as well as clickers which is a
216:12 - vector of strings and these will these
216:16 - strings will be the addresses
216:18 - of the clickers
216:20 - other than that we need
216:24 - context
216:26 - and that has
216:28 - a base account field
216:31 - which is an
216:32 - account easy
216:35 - and i think we need to make these public
216:40 - vector that's just an array or what
216:43 - a vector it's yes it's it's a list
216:47 - but it's
216:49 - it it's pretty much an array but more
216:51 - specifically it's dynamically allocated
216:54 - so you don't have to
216:56 - know the the size of it beforehand
217:03 - sounds good
217:05 - okay let's see if that makes the
217:07 - compiler happy enough no it does not why
217:12 - ah okay so we need
217:14 - to do some more imports
217:19 - in order for us to
217:22 - what's the word crossover between the
217:23 - javascript and the rust
217:25 - or in this case wasm
217:28 - interface we actually need to
217:31 - serialize and deserialize
217:34 - the structures that we have so we are
217:37 - going to import d serialize and
217:39 - serialize
217:42 - and then from there we need to annotate
217:44 - our functions
217:47 - that
217:48 - we implement the
217:51 - we derive the traits for them so we can
217:53 - use
217:56 - the attribute
217:57 - and derive serialize and be serialized
217:59 - for both of these
218:04 - okay i wonder if that is enough
218:07 - one day we will pass these tests
218:10 - okay it looks like i actually need to
218:12 - spell correctly
218:17 - okay so we we are passing something so
218:19 - it's useful to know
218:21 - we have here
218:24 - some unused variables and
218:29 - we are passing all
218:31 - seven
218:32 - unit tests
218:34 - excellent so let's move on to just
218:37 - do the integration tests
218:39 - and that is wesmpac test
218:43 - firefox headless
218:46 - and you can run this in the browser
218:49 - but
218:51 - it just outputs the exact same
218:52 - information that goes in the terminal
218:53 - here so you might as well
218:55 - run it headless
219:00 - and while that's going we can see what
219:02 - else we need to do here
219:08 - so at some point we need to deploy the
219:10 - package using node node
219:12 - deploy.js so using the script
219:15 - and we need to pass in the path to our
219:17 - package directory
219:18 - and we should run
219:22 - node node smart contract
219:25 - passing in a contract id
219:27 - set click and clicker name to add at
219:30 - least three clickers to the contract
219:33 - okay we'll get to that later right now
219:35 - it looks like we just have a bunch of
219:37 - wasm errors probably because we are not
219:40 - annotating our functions that we're
219:42 - exporting
219:43 - as
219:46 - something for asm2
219:52 - and maybe now we can actually get
219:54 - somewhere with these tests
219:57 - although we're technically still not
219:58 - returning anything so where's them will
220:00 - complain
220:04 - we can
220:07 - for some more of these user stories
220:10 - so this function returns a context
220:11 - wrapped in ajs value so we need to
220:14 - create a context here is our context
220:16 - so what we can do is just say let
220:18 - context equal
220:21 - context and this has a base account
220:24 - which
220:25 - value is account
220:27 - and we need to start this with some same
220:29 - numbers i would assume so we can do
220:32 - little clicks zero no one has clicked
220:34 - initially
220:36 - or when we initialize the contract node
220:38 - will have clicked
220:39 - and for clickers
220:41 - we will do an empty vector
220:46 - that looks about right
220:48 - except
220:49 - we now need to wrap that
220:56 - in a js value so
220:58 - we go back down here to the tips we can
221:00 - see
221:03 - this value
221:04 - has the from survey implementation
221:07 - and we can pass in
221:14 - a context
221:16 - with our context
221:19 - um and we want a result out of this so
221:21 - we just need to
221:24 - say okay
221:27 - i'll
221:30 - i don't have a letter for this but i
221:31 - remember that from certainly expects a
221:33 - reference to the context so we just need
221:35 - to
221:36 - little hamburgers handy
221:39 - is that like a
221:40 - is it like a return then it says okay
221:44 - it's the return
221:46 - so
221:47 - in rust we have implicit and explicit
221:49 - returns and basically if you leave out
221:51 - the semicolon then it's an implicit
221:53 - return
221:55 - this is
221:57 - standard
221:58 - uh basically if there's no
222:01 - ambiguation as to
222:04 - where you're returning in your in this
222:05 - case your functions then
222:08 - you implicitly return but if there is
222:10 - ambiguation maybe you have some other
222:13 - if something then you'd it's better to
222:15 - explicitly say hey i could actually
222:17 - return from
222:19 - location
222:20 - but okay you're just wrapping
222:24 - something
222:25 - into a result
222:26 - so
222:30 - it's
222:32 - it's just a type here we're saying
222:36 - that our type returns and in this case
222:38 - this case we're returning okay if for
222:40 - some reason this initialize
222:44 - uh some had some other logic and
222:48 - infinite going as we expected
222:50 - so in this case then we could instead of
222:54 - wrapping it in okay we would wrap it in
222:55 - error
222:57 - and
222:58 - you know we might want to do this but in
222:59 - this case because the function is so
223:01 - simple there's not actually anything
223:02 - going on in here that wouldn't
223:04 - fail during
223:06 - compile time
223:08 - there's no reason to have an error
223:10 - variant of the result
223:15 - so let's move on to something slightly
223:17 - more complex the
223:21 - set click function
223:23 - are we doing with this
223:26 - we are
223:32 - well i suppose we need to find out by
223:39 - um fulfilling the user stories in the
223:45 - integration tests there we go so if i go
223:50 - we know we want to return
223:53 - the
223:56 - context so let's just do the same thing
223:58 - as above let's
224:00 - do that
224:00 - over
224:02 - and we're not doing anything here but at
224:04 - least this will compile
224:07 - and in here we need to return the
224:10 - account
224:12 - you can see
224:15 - that the get contract account function
224:18 - it returns an account wrapped in the js
224:21 - value now the account is inside the
224:22 - context
224:24 - so
224:25 - we actually need to access the base
224:27 - account
224:28 - field
224:29 - and we can say let account
224:34 - or in this case
224:35 - yup netaccount equal to
224:39 - we'd actually first need to get the
224:40 - context out so
224:43 - i think
224:45 - we define context and say that this is
224:48 - of type context
224:50 - and then we can
224:51 - [Music]
224:53 - use context dot
224:56 - day so into sur day is
225:01 - derived implemented full context
225:04 - on a js value because we have explicitly
225:07 - derived it as part of the
225:10 - i always forget if it's serialization or
225:12 - deserialization when you're moving this
225:14 - way
225:16 - um
225:18 - but anyway and we are just using this
225:21 - operator to propagate the error out into
225:24 - a result if interstellar day fails to
225:27 - derive it
225:28 - ah sorry to deterioraze it
225:31 - and then we need the account so let
225:33 - account equal to
225:35 - context dot base account
225:39 - and we want to
225:40 - wrap that js
225:43 - value from
225:45 - survey
225:48 - and pass a reference to the account
225:51 - let's see if
225:52 - that allows the tests to run
225:56 - no
225:58 - and it's because from surday
226:02 - returns
226:04 - a result
226:05 - so we need to unwrap that and we can
226:07 - just
226:15 - okay so
226:16 - unwrapping all of these
226:19 - from survey calls that's not how you
226:21 - underwrite
226:26 - we can
226:28 - see if that
226:31 - tests to run
226:33 - no because we
226:35 - have something that requires sized
226:37 - context
226:39 - serialize is not implemented for js
226:42 - value
226:45 - we are not trying to
226:48 - where are we over here
226:56 - this is an interesting error
226:58 - um
227:00 - i think one of the things we need to do
227:02 - is in order to get the
227:06 - account out we are actually just taking
227:08 - a reference
227:15 - and that might be all we need here
227:21 - okay
227:22 - that wasn't it
227:24 - okay where's the error line 30 okay
227:28 - okay so we've said this and no so we
227:30 - need to let context equal
227:34 - text equal to
227:36 - context
227:39 - so they
227:41 - that's what it wanted
227:47 - maybe okay so it's running tests
227:50 - we passed four nice
227:54 - we passed
227:57 - another eight and then we failed some so
228:02 - let's look at this we are
228:04 - it's a lot of output here
228:08 - but we can see that other than the
228:10 - warnings we passed the four tests
228:14 - result
228:16 - to do with the initialize
228:18 - function so the initialized integration
228:19 - tests we're passing those
228:21 - he said click we are passing
228:24 - all of those which is surprising
228:27 - oh no
228:29 - we are failing this one
228:31 - so it needs to push clicker and
228:33 - increment total clicks
228:36 - so
228:37 - what we need to do is we need the
228:40 - account out of this account equal to
228:44 - you want to mutate this because we need
228:45 - to increment the
228:46 - clickers context dot
228:50 - you want base account
228:52 - and
228:54 - then we need the account dot total
228:57 - clicks
228:59 - it equals one that's
229:01 - plus equals one
229:04 - and we need to push accounts dot
229:06 - clickers
229:08 - push
229:10 - the address
229:12 - so
229:14 - that should be all we need there
229:19 - and
229:23 - now let's see if we pass any more tests
229:24 - with that
229:28 - you can't borrow this as mutable because
229:29 - we didn't
229:31 - declare it as mutable
229:34 - that's why we did that there it is
229:38 - shouldn't need that
229:45 - okay
229:47 - some more tests passing initialize
229:51 - past all of those tests
229:53 - set click
229:54 - we increment it and we push it
229:56 - okay so what are we fading
230:01 - nothing
230:04 - is that all we needed
230:06 - well let's find out by running the test
230:08 - here
230:13 - okay so we passed the unit tests there
230:18 - passed initialized integration tests set
230:20 - click integration tests
230:22 - get contract account integration tests
230:24 - but we have not yet deployed our smart
230:26 - contract
230:28 - so
230:29 - let's do that by running node
230:32 - node deploy.js
230:35 - and the path to our package directory
230:37 - okay so we need a package directory
230:40 - how do we do that we need to build it
230:41 - first
230:43 - so we need wax and pack
230:47 - and
230:49 - we have any more information about that
230:53 - build your smart contract with node.js
230:54 - as the target so
230:56 - we need to wasn't back build
230:59 - and to pass in node.js as the target
231:04 - and
231:05 - click return
231:08 - this doesn't crash
231:12 - okay something's happened it says that
231:15 - your wasm package is ready to publish
231:18 - at this location
231:21 - so
231:22 - if we just double check yes the package
231:23 - is there
231:25 - what we
231:26 - then need to do
231:28 - is just run that node node deploy
231:31 - face and the path to the package is
231:36 - uh just
231:40 - it's just packaged
231:41 - i think
231:43 - okay we hit that and we get a bunch of
231:44 - errors
231:48 - maybe
231:53 - we need to
231:53 - [Music]
231:54 - point it to the file
231:56 - we can drop directly oh yes
232:00 - oh a
232:02 - smart contract in rust dot
232:05 - yes
232:06 - okay
232:08 - that's done something
232:10 - um let's what would the wasm file be the
232:14 - contract
232:17 - so
232:19 - the fun thing about bull building the
232:21 - package like this using wasm
232:23 - using
232:24 - ryzen pack
232:25 - is that
232:28 - because we are interfacing with the
232:30 - javascript api
232:33 - uh you can see with the js value here
232:35 - we
232:37 - need more information than just the wasm
232:39 - we need
232:42 - to do a whole bunch of memory
232:45 - allocation and stuff
232:47 - and that's done in javascript so that
232:50 - when we import the package
232:52 - it's
232:54 - we can import it as javascript and the
232:56 - javascript code then
232:58 - uses
233:01 - whatever wasm webassembly
233:04 - um module in order to import the
233:06 - instance here
233:08 - and then re-export it you can do this
233:11 - manually
233:12 - but as you can see there's actually
233:13 - quite a lot of stuff that you still need
233:20 - so
233:21 - and that's only because we're
233:22 - interfacing with the javascript okay if
233:25 - we weren't then we could just
233:27 - run and use the dot wasm as
233:32 - your yield average by
233:34 - byte code
233:36 - um so we've deployed that if we run the
233:38 - test we pass that it's deployed
233:42 - and you should add at least three
233:43 - different clickers to your contract
233:44 - state so this we need to
233:48 - run this command to add at least three
233:50 - clicks to the contract so let's do that
233:53 - node node
233:54 - smart contract.js the contract id we can
233:57 - see here that the smart contract
233:59 - deployed with id0
234:01 - so let's add zero
234:03 - and we want to set clicks
234:06 - so we pass in the name of the function
234:08 - which is cyclic and the clicker name
234:11 - let's add tom
234:16 - and i think what we can do is we can
234:18 - view our blockchain
234:20 - in
234:21 - node
234:22 - data blockchain
234:24 - so we have here clickers dom nice
234:28 - we can add another clicker let's add
234:31 - myself
234:32 - that done that's mind another block and
234:34 - the clickers are now turtle clicks two
234:37 - and clickers tom
234:39 - and then let's add
234:41 - a mud
234:43 - another block
234:47 - so
234:48 - that
234:49 - should be it
234:56 - yes excellent

Cleaned transcript:

most of you are probably aware that on freecodcamp.org we have a comprehensive and interactive curriculum to help you learn full stack web development well we're constantly adding new certifications and our new web3 curriculum is ready for you to try it's still in development but we now have five integrated projects ready for you to complete in this video you will watch free code camp team members sean and tom complete the projects so get ready to learn more about web3 and see if you can follow along with sean and tom as they work through the projects welcome free code camp this is the web 3 curriculum tom and i are running through the integrated projects that we have ready and in front of us we have the article that shows you how to run the free code camp uh web3 curriculum in your local vs code setup it walks you through what projects are available as well as how you can run the course once more projects are ready you will be able to sign up for updates and just listen to your emails because once we start releasing you'll get updates on those so to get started we can head to our terminal and we just need to get clone the repo which is in github at free code camp web three curriculum yeah it mentions in the instructions there um kind of specifically what to do i think so there's a few prerequisites obviously uh vs code and then uh docker is the main one i guess because this all runs in docker so you have to install those two things for sure and then once you get those few prerequisites installed in the article then you can i guess just clone the repo and run it or something like that we'll share we'll share a link to the instructions to get it set up in the description there so and once we make sure that we have docker running we can add vs code open up command palette and say remote containers rebuild and reopen in container now this usually does take a while but what i like to do is either go make myself something to drink or just watch the terminal as it builds okay is that it ready yeah i think um this is what i typically see when it's ready is that the last thing it installs that last extension there okay awesome so now we can use the free code camp extension to run the course first we'll prep the course and you can see what it's doing if you head into the terminal labeled free code cam run course but you really don't need to worry about what's in there so let us again you are introduced with the landing page which describes the course there will be a link to frequently asked questions just in case you get stuck or are confused with how to start as you can see there are quite a few projects that we have coming soon here currently the projects that are ready are what we are calling the integrated projects the integrated projects are like certification projects on the free codecam forward slash learn platform in that you don't learn anything through the course you are prepared through practice projects you get taught the content that you need in order to complete the integrated project so the integration project just has a bunch of user stories that you are expected to complete in order to go through this all right i got this loaded up and what i'm going to try and do is go through this first available project it's called build a video game marketplace blockchain um so you click on it and you come to the instructions here and then it gives you the files there okay so i guess we're gonna create a blockchain for video game marketplace uh where we can buy and sell items and we're gonna work within this folder so i'm gonna just go in there to start and um okay it says json files will store information about your blockchain um there are functions in blockchain helpers for reading and writing to them you'll need to look at those to see what arguments they need and what they do they're already included in the files where you need them um the items you can buy or sell are in items.json so we've got this items.js and i can buy some stuff there many of the files are finished for you you only need to add code in this handful of files and run terminal commands and finish all the user stories and pass the tests okay so your blockchain will be stored in blockchain.json you can initialize by running node init blockchain um okay there's there's just a bunch of users here that'll explain to you what to do um no generate wallets so we can create some wallets yeah mining blocks hashes oh geez there's a lot of stuff here um so these these this blockchain.json is going to hold our blockchain and then we already looked at items um transactions is going to hold transactions and wallets is going to hold wallets and then there's kind of examples here of what they're going to end up looking like blockchain has some things there and etc okay um let's just see if we can't pass one of these tests or something oh look at that that looks good um actually whatever i'll just leave it um first one let's see you can initialize running node in it blockchain should replace everything in blockchain.json with an array that has one object the genesis block it should have a hash property of zero okay i think this one's not too difficult so we've got two helper functions here right blockchain right transactions um should replace everything right block chain and that's this block equals to so obviously the genesis block is the first block in the blockchain which you often have to hard code because you'll find it doesn't have a previous hash so you can't really generate a hash for it yeah so i have a hash of zero and a previous hash of null and then the blockchain we're going to save that but uh blockchain should look like this and i think running that should do that okay we could run it and see what it looks like let me see what does my blockchain look like node blockchain there it is let's see there must be a test that goes along with it um running all right we got the first one to pass should replace everything so same thing replace transactions.json with an empty array um currently it's empty but uh if i go here right transaction so right transactions just like that yeah these helper functions they just kind of write to the file i guess and get things from the files the json if we wanted to see what those helper functions looked like just in case maybe the name doesn't describe them fully where do we see that this is all on this blockchain helpers file um there's a bunch of get and write blockchain um it's pretty much just well there's quite a few here i guess getting balances and stuff um but yeah you um should say here do not change code in this file so you don't need to change anything um and it may mention some things about some of them elsewhere maybe in the instructions okay what do we got next running nodegeneratewallet with the username should add a user as a key in waltz.json with a public key and a private key properties the value should be a public private keypair and hex format is the font so let's see what this one looks like we have no wallets and generate wallet okay so we're going to get a command argument from the command line um new wallet name so public and private i know there's instructions on how to do this um generate a key pair okay so let's go const key pair equals vc.gen key pair um ec is already here for us and then get some information from the keys there's the user story on this one to watch out for those type of did i have a typo yeah um should be able to create a wallet well let's see what the examples look like here we go wallet name public private there we go that helps okay so mouse public equals um get hex follow key from key pair okay i think that's right on private equals air that get private hex and then get wallets so we don't want to completely replace um the wallets we want to add to it so i think house wallets equals get wallets um so i guess we can probably just skip some validation and do wallets dot new wallet name so what validation would you do i would make sure there's not a name already in the wallet right this is the only thing here and typically wallets aren't stored like this this is just for this project so you can see it and have access to all the public and private keys um okay so while it's in a wallet name so we've got um public key and private key public key equals public well it's dot new while named up private key equals private um are those keywords public and private so i'm getting underlines private is a reserve word okay and then we should just do right wallets and then if i say that open my walls names yeah node so this is all in the instructions when i have it somewhat memorized um but yeah you can create a wallet with this it says so we're going to try that generate wallet me there's not set i was wondering if you needed to make that um dynamic yeah okay so equals what's that new name i'll just do this this work public key equals pub i'm not used to this keyboard i think just remember new wallet name is not the name of the key you want oh is that my problem yeah obviously thank you um that should work i think no more errors did or you must be straying her buffer now what invalid argument well when you're writing wallets you don't seem to be doing anything with the wallet you just created oh gosh okay well it's equal get wallets wallets your wallet's name well it's worthwhile uh okay well it's thank you you gotta look maybe i should have put more information there okay i think it worked it worked ha awesome i think the fun thing about these projects is you get to you know try out what you're making as many times as you want yeah you're cutting out a little but yeah i got you okay so we got one more thing done hopefully running the wallets creating wallet works and it has key pairs when you generate a wallet it should add a transaction at the end of the transactions array it should have a buyer address property of null and um buyer just property of null and seller address that is the public key of the new wallet okay so let's look at this ad transaction i assume go back to generate wallet get transactions write transactions okay so we'll just we wrote that const transactions let's get transactions and then i guess const new transaction equals something then transactions dot push transaction transactions dot right transactions right um transactions right transactions and then this transaction it should add a transaction at the end of the transactions or the transaction buyer address of null okay seller public key of the new wallet my price of 40. so public key i'll just go like that price 40. i suppose the i don't know um but let's see what happens there okay that didn't work either now now the old one's broken um new transaction equals that transactions you need to watch out for what you actually named some of your variables why don't you just tell me what the answer is you see something don't you seller address pub there is that what you were looking at yeah okay so now when i look at my wallets um wallets we got two wallets and transactions we've got nothing in there so i'm gonna just like that one i don't have a trackpad where's my trackpad um well okay let's look third wallet test okay we got a test wallet added that and now we have a transaction all right um running line my block should add an object to the end of the blockchain.json array with the correct hash previous hash nonce and transaction properties oh boy so this one sounds a little trickier um after you run should be an empty array hmm so i guess we're going to need a const new block type thing hash previous hash transactions and something like that we'll see equals so we've got helper functions let's use those get blocked blockchain last block block chain so you want to get the last block so we can get the previous hash so the blockchain is going to have this and we're going to want to get this hash so we can put it on the next block and it'll be the previous hash value of the next block so last block equal blockchain blockchain dot length oh this one blockchain blockchain dot like that sounds right um just comment this out once also that log last block let's make sure that's working there it is okay so it's working nice yeah i wonder if you don't need to worry about mutating blockchain you just pop it off the end i mean in this now you probably don't want to do that right you would need to put it back when you go back to write the block chain uh yes because you can't you can't remove a block okay previous equal last block dot hash so we got one thing down i think um not i think we're gonna have to look at the rest of the things for that now okay so hash and nots those are gonna be tricky transactions let's after you run it should be an empty right okay we can add that one quick const actually we should just be able to write transactions like that think so assuming everything gets mined correctly we can make that an empty array um i want to go up to these user sources i think there's some information generate a wallet okay so it looks like we kind of got a large portion of the top done um okay the hash should be creating using child56 okay concatenating the nonce the previous the hash of the previous block okay so yes we need to do some sort of loop here i guess let hash equals this well and then i know there's something in here about it having to start with some zeros there we go the hash and yeah what knots equals let's just start with zero so while hash starts with zero zero um create new hash hash equals shot 256. and then i think how to work with keys shout out to right there there it is can i copy that there we go okay content to hash it says up here um the hash okay concatenating the knots nonce plus previous block last block dot hash plus a stringified version of whatever is in transactions.json oh geez look at this they copied i could have just copied this whole thing just need to read um transactions there's some dots there i don't have transactions oh i think i do no i don't it's transactions okay so and then we want to probably do nonce plus plus we'll start okay yeah so it's gonna keep going until it starts with two zeros nonsense be one two three four five um uh okay apparently that should be the hash of the last one okay that looks right um yeah do you have everything for your new block now um now it's hash transactions is that just a jason i think so yeah yeah that looks right let's see if it works so the transactions are supposed to go empty and we're supposed to get a new block i guess node mine block um we did not get a new block because i did not write it but i did delete the transactions um new block equals this uh blockchain equal get blockchain blockchain dot push new clock and right blockchain blockchain here we go now we don't have any transactions but um you know what i'm just going to generate another wallet quick test two now we have a transaction and yet another wallet okay let's see if that worked note mine block all right no more transactions and we have a block three hundred dollars um and then i guess i can come run these tests and see what is passing for me uh running note mind blocks hash previous hash nonce did i do something wrong what have we got here previous hash zero that looks correct hash that looks correct knots looks correct oh boy something is missing transactions i'm wondering now if you go back to your your little algorithm for calculating the hash because i remember coming across this a lot while doing um learning about the cryptography of blockchains looking at the nonce that you're calculating the hash with and then the final nonce that you're ending up with oh geez let's just we'll just do it first it's probably what's the right way to do it tell me the right way to do it okay let's see what happened i'm just gonna get my cat still then okay um something isn't working while not we know the internet has an obsession with cats so this is archie did you pass that test no i wonder what the test is doing should add an object well i mean the one thing i can think is you're not if the hash the nonce needs to be zero you're never actually testing that what's that say if the nonce is ever zero you're never calculating the hash based on that because you're always starting with one kind of a probability of thing that that's probably not going to happen but with the nonce it'll go it just goes until it finds one if zero but you know the checking zero well that's fine because if zero works it'll just go to one and check one and then it'll go to two or three whatever until it finds one that works and then you can use that one uh i don't know i know what i'm gonna try though i'm hey ans hash wait did it pass running node my blocks down object and transaction property transactions transactions hmm do you need to add a transaction anyway i don't know i feel like that one should have passed well if you go to the console is it saying anything there you go now you're thinking uh i don't think we've even seen the console yet um yeah okay running on mine block let's see what it says here the hash of the new block should be able to be recreated with these things expected zero zero six maybe you're right what's the to equal zero d so what one so my hash has two zeros i can't get back very easily i need my touch trackpad um so it's expecting only one zero no it's just saying it's supposed to be able to be recreated dot hash that should have been correct json.stringify transactions hmm i'm gonna check where you are doing the dot two string okay so what's transactions.json online oh there it is yeah oh stupid transactions not transactions not json did it say that and i should have copied and pasted not say that in the instructions it did say that there's a bug no well kind of a bug it's a bug uh okay let's try it again let's see if that works console running node mine block there it is we got another one thank you for that help um okay so do you mind writing that down you want to take a note of that oh what are you doing yeah we'll take a note of that um okay running node by item so we need to buy and sell items uh i'm already know about so we're going to run this command by item with one of our wallet private keys and the item we want to buy and we need to add a transaction for it with the correct buy or just sell address price unboxing so this is the test text there must be more information up here so but i know we're going to need cons let's call it new transaction what's this and we're probably gonna need transactions equals get transactions you know it's always satisfying when uh you come across a problem like we just had and then you start to think that maybe you have an issue with your tests and then find out that your test is working okay transaction when you buy an item yada yada so the buyer address should be the matching public key for the private key entered so it looks like we're going to get a private key and we need to find public key from that because pub probably is probably the keyword and russ isn't it yeah it is um so i have some poor variable name choices maybe um so get key pair from private uh equal different key public keys because we got we should have key from probably get key pair from private so that'll give us a key pair so that'll actually be key pair and then we need i think we need to get hex public key from key pair that should work right here so um i'm just going to console that shouldn't do anything save that um so i should be able to run node i item and enter a private key so if i grab this private key and run it oh come on why can't i paste copy paste i should get a log with the public key that is the public key that matches that works okay so we have a public key um okay we need to run that so okay fire press public key seller address null price should be the purchase price of the item bought item bot equals that so get item price what does that do get out of price item items so it looks like it returns the price i think you can just do get right here right in the object item price item bot um signature should use the buyer's key pair to sign oh geez signature equals buyer's key pair keep hair dot sign here we go what kind of content do we need by concatenation buyer address price in item bot and these helper functions are really just making a lot better aren't they yeah uh i lost it price item bot okay price plus item bot okay so we should have a signature and we need to add it probably down here we don't want that why would i do that i think thank god for linting it'd be terrible okay so supposed to add an object to the transactions transactions dot push new transaction right transactions transactions save it and we will i'm going to open up this transactions and see if i can do this again node by item and we'll try an icon but i wanted to see this notebook oh something's out of order buyer address equals public key buyer address um so i should be able to just do public key there bank price is not defined get item price um price okay yeah it item price item bought yeah that wasn't very smart there was it let's try it again yeah i think i spent 10 or 15 minutes yesterday on a bug that was caused by a trailing comma in json yeah so at least your error messages are telling you you know exactly what's wrong mine was telling me unexpected token now well didn't it give you like a red line around it and it's just really small and you can find it didn't get a red line around it no i think i was editing in nano so oh yeah no anything okay so i think this one should be working we bought an item and it was there so mind block no buy item buyer seller signatures well let's see what happened with this transaction buyer seller price signature buyer seller price item we're missing an item i wonder what the console would have told you we'll check it out here in a second yeah i'm always interested if it's assertions are specific enough seven i mean i don't know this one might be a little i really need my trackpad for this oh i have to scroll down here i guess that's not bad i just go scroll down a little further um expected 2 to equal 3. that's not all that helpful are you asserting the length of the object's properties yeah i guess probably huh yeah um and then somewhere in there i suppose i checked the rest of it yeah that's not or maybe i should check something anyway um i think it'll work now and since i'm just all right i'm still failing let me see if i buy an item again what now what icons we got item higher chests to read read my own stuff still nothing itembot signature let's run it one more time what i notice your transactions aren't um clearing oh you're not running mind block that's why yeah seller address i don't see any typos signature hmm let's see if that console's changed because it's adding an item it's going to say the same thing isn't it that's not helpful um buyer address buy item enterprise so the price is correct signature i wonder if that's off public key fire address that's the same thing that shouldn't matter signature let's see what that signature is supposed to be you buy an item signature sign concatenation of the buyer address price and item bot in that order in hex format we've got to keep here keep here that sign i mean the signature's here so um cellular address it's supposed to be null right seller address should be no price should be the purchase price 10. i wonder if that's supposed to be a string no let me see this example transactions yeah it all looks correct hmm transactions we're pushing it get address balance is there a caveat in there that i'm supposed to make sure they have a enough funds well it sounds like it's saying you're still not pushing the correct number of objects that is what it's saying but you know what i think it might be yeah something to do with the balance the test is checking if it's got enough balance or something so i'm gonna go i'm gonna start over i'm gonna reinitialize my blockchain and because the account i'm using is this one that i created that doesn't have any funds and add the funds until those other that there were uh it's like a i guess a reward transaction for creating a wallet node generate wallet just put me in there see now i'm going to have transaction with the funds i created those other wallets before those transactions were in there so i don't know why that would that why would that have anything to do with it i don't know i'm gonna run these tests again see if it still came back yeah there it is i'm gonna look at my solution see if there's anything well i can't think of anything transactions price buyer keeper key from private signature it looks the same for the most part very similar copy it over still nothing oh i didn't save the file i wonder if i wasn't saving the file i need to turn on autosave there it passed so now we don't even know if we're i'm going to undo this and see if it's working undo save and then run it no no it's not passing i wonder what i'm missing on this one fire is just cilantro's keep hair all right um we have to do the cell item thing still so we'll give it another try over there i'm just gonna use my solution for now because it's passing um i feel like it didn't have anything to do with the balance but maybe i'll dig into the test later and see if i wonder when you sign it the concatenation it matters the order doesn't it did you have the order correct i did i double checked it public key price item bought buy your address public key yeah okay wow do you have to do the check for the the balance in order to pass that one it doesn't say anything about it should not add a transaction if the address it does not have a maybe it's right there i didn't look at the second one get this one run the test okay these both fail yeah maybe i'll just try transaction equal that transaction number so let's try it once yeah get address balance um cons balance equals get address balance public key if um balance than or equal to price we'll add the transact uh push transaction and write the transactions let's try that once and see maybe that was it there it is wow you want me to take a note of that um i mean there might be a reason that's happening perhaps yeah sure take a note um yeah i don't like that but maybe i'll put that user story first that's probably what i would do um okay running the cell item so what else did we get we've got a cell item i should have at least three wallets in my wallet so jason so that's what i was gonna do here me you i three wallets i should be able to pass that one um three loss okay and then at the end here we got a oh they are valid nice at the end we gotta add a bunch of blocks and transactions okay sell item let's try this all item one let's keep keep moving keep me on keep me on task sean yeah well you're almost there i'm almost there um so we need to sell item address private key and item so the the command will have the private key and an item and we gotta add another transaction with the buyer address so let me go to my buy item once i just do a little this is going to be a bad idea but i'm going to copy this over here a new transaction transactions i'm just i'm just all over the map with my code too just hacking away okay let's move some of these up to the top um well i don't think we need a price on this one but okay so the buyer address is going to be null this time seller address should be public key i believe quick buyer just seller just price and item sold price item sold and then i believe we actually don't add a signature to this one because we're selling an item back to the game or maybe we do i don't know oh it does say signature yes so we do need i don't know what i was talking about um there's something you don't need a signature for though i thought i don't remember oh it was the reward transactions um okay so i'm gonna scroll up to the sell item thing here so we're supposed to add that buyer address should be null seller just be the matching public key for the private key hundreds so we've got a seller private key that comes in and we have to keep here there and then their public key okay so we got the public key um price should be five less than the purchase price of the item so we have item sold price equals get item price i should just be able to go minus five there um signature should use seller key pair to catenate seller address price and item sold um so public key should still work price items sold there we go um you shouldn't need uh shouldn't need anything here i'm wondering if there's supposed to be something that makes sure they have the item before they can sell it but i don't see anything written well you might need to check your actual user stories no maybe i only kind of skimmed over them seller address yeah i don't see i'm selling i'm not okay so we do if um what is it get address items um i should be able to address cons items equals get address items on the key i think so i'm gonna cancel log items here and nothing should be happening because i'm not writing any files so what i want to do is get an item to somebody somehow transactions we don't have any items yet so node buy item and i want to see if when you buy an item you should be able to buy an item by running by private key item okay private key let's do a different item this time a spray i think it worked actions there it is okay so now we have a spray we can sell let's just add another one we have two um and it says that the transaction pool is included uh the items are so this should be included so if i go node sell item um that private key get in there get item price item bot minus five yeah maybe i can't do that um oh it's because i didn't put in an item no oh is it can i not do that either what is it you see something you need to tell me it's not item bought item sold all right all right although i'm not inputting an item here okay so there we go we've got my items here they are that worked everything worked so i need to say if uh not items items item sold greater than zero or actually you know what let's just do if items i am sold greater than one so if you have at least one you can then do something transactions dot push come on new transaction transaction start right now you keep wanting to do that oh it's just it feels natural okay yeah there i think that'll work let's see what happens if i sell one of these sprays console like my items but that was before it actually changed transactions yeah there it is and i can i think there's the helper function here i thought items gift items oh yeah there's a little you can run that to gift items let's run that ones gift items i think it should work now it sends an item to every wallet around item yep free item to every wallet okay that's a funny drop um i wanted to check the balance or get address info there we go node get uh address info and i think if i just do the name there we go so we can we have some info there it has a balance of 20 and a few items there we go that's kind of nice um and let's see if the selling test passed across our fingers here no no big fail so i don't what dude let me know it's cell item actually i'm just gonna node mine block should clear out the transactions and then sell item okay so now i just have none i thought it was working before i must not have that item what address is that um okay node you're also saying if it's greater than one hey note items that item sold if it's greater than or equal to one there we go thank you there it is um and yet it did not pass but i guess that was probably the problem so let's try it again there it is it passed all right there's off by one errors um and now we just need to add a bunch of transactions and stuff like that so node node mine block just pop these open i'm going to pop these open here so we can see what's going on blockchain if you got a blockchain here what looks like about three blocks no i hit them and we need wallets so i think if i grab a key hotkeys don't work excuse me free action work there it is so this person is buying a spray two sprays that one didn't work because we don't have enough money sure we'll just mine it this person node by item paste uh i'll do icon just make three transactions to buy some icons we'll just mine another block node gift items node gift items block yeah you can see it it keeps adding to this array blockchain and transactions so it's kind of neat um and i wonder how many more we need let's see if i have any passing i don't think that's enough though i just add a bunch of addresses two addresses minor block we're gonna we're gonna do this mode cell item that's uh icon both line block generate wallet this is what you want this is what you want um sean right now we have our own wallets 40 coins each um node mine block let's see how far we got ten blocks no gift items mine black does not tell you in the console how close you are no okay that's gotta be enough there we go nice oh one project down okay let's move on to the next project um yeah we finished this one and the next one is uh build a fundraising smart contract so it's going to be kind of similar and that's got a bunch of json files and stuff where you put your blockchain in there um okay let's see what it says here it says i need to create and deploy a smart contract that raises funds for my startup the goal is to raise 150 tokens before the seventh block is mined you have some boilerplate code and files um i should not need to change any of the boilerplate code the fundraising contract folder is the only place i need to write code so i have this folder which is going to be my contract and the rest of this stuff is not stuff i need to change anyway okay the initial state it's the an object my contract will store js files in that folder um will be run by the contract on transaction will run when a transaction is sent to the address of my contract and the on new block will run when a new block is mined and then it says that the files or the functions on the contract can only run if the status of the contract is open so yeah this is my contract state object and i presume there's going to be some sort of status open or maybe that automatically gets added okay the only two helper functions your contract files can use are add transaction and update contract state they're already added in your contract files okay so we've got an on new block file that will run when new block is added and this on transaction will run when a transaction is set to the contract address and then these other files is just showing all the things you can use in any other file you're gonna need to add here i know we're going to need to add a couple i think uh it says there's a number of variables that we passed your contract files uh ones available are already defined there and those two files uh yeah so it says there then we can use those variables um and here's the command to deploy your contract it says it will create a contract address and put the contract itself in the smart contracts json thing and then it will get added to the blockchain the next time i mine a block after it's deployed you can run the contract files with this command um yeah and there's some notes here says mining a block creates a reward transaction with a random address from wall such as okay these are stories bonus hints there's a lot of hints so there's gonna be a lot of like okay hence do this first i'm gonna do this first because it says do this first there's a there's an example contract for you to okay do this first it will help you understand how contrast there's an example contract for you to play with to see what it can do keep your eye on your json files and run these commands um so we've got like transactions smart contracts maybe blockchain we want to i'm in the wrong folder from before so i better make sure i switch build a run this initialize blockchain okay we got a block node deploy contract example contract because that's the name of the folder here and then a private key from the wallets private key let's go with this one um okay so we should have a message i guess your contract has been deployed at the address it will be added to the blockchain on the next block as well cool nice so there it is and it has my like functions from the example contract folder and the state of the contract i guess so node block i'll do that now it moved over there it's blocked in a transaction a private key from all its transaction okay so so do you want to explain what's in that functions object it's the code from these files these javascript files so you're just taking the code as a string and sticking it all on one line yeah yeah it works it's uh i mean it's it's pretty similar to how i mean not maybe not that part of it is but it's kind of similar to real smart contracts and that the code goes on to the blockchain and that's i guess more the purpose of of kind of some of this is to get the concepts across i don't know i think it's nice i think it definitely helps for debugging all right um let's try and do a little more here node add private key from wallets um so the contract is now like a different address and this person this wallet created it so you could still use that wallet to send things to the contract now um probably from almost example contract address and i'm pretty sure nobody has any coins or maybe they do i don't know so i have to use zero for the amount then some thing hopefully to the there you go so i sent xero to the contract address and it says someone set a transaction it is running it's on transaction file here's what the transaction looks like and if you look at the example contract this one it has all that information you get a transaction that came in and just a couple logs okay so it ran that file and then you can also run contract example contract to just get favorite number okay node run contract temple contract address should be that it before it i spell that right no you're missing the you in favorite huh okay look at this we got running this file favorite number is 10 and then we can set it is your your favorite number actually 10 no i don't have a favorite number example contract no it's actually 11 that's why we're going to change it to 11. favorite number yeah i'm kind of missing uh like you usually you need a private key you know to update state right to the blockchain i guess we don't in this one which is fine but i ran that and now it should be there it is and if you were to look through some of these blockchain files you'd see all that kind of happening like i guess there's the transaction okay this the smart contract transactions basically transactions go in their own file um let's see what happens when i mine a block yeah and then everything from both these files gets moved over to the blockchain yeah let's try to get a random reward on a new block his mind and he yeah so smart contracts kind of have their own area here um but i guess typically on real blockchains they're just regular transactions but yeah who are you nothing okay let's okay let's try and get this going fundraising contract so the initial state should have a status set to open and a description to smart contract your contract should have a get description file uh so we're gonna we these are the new files we need to make new file get description dot js and update description so it doesn't make those two updates and console.log i don't know if i can copy that maybe that's a good thing i'm just mumbling to myself here what's going on over there sean i'm just watching you seeing how the master does it creating smart contracts yep um keep your eyes open for those tables i'm good at that yeah i think that's why mostly here um so get description console.log here's the description of the fun contract and then description here probably contract state dot description so the contract state will be the object here yeah but we need to actually deploy the contract for any of this to work i don't think i need any of that i think we just need this one okay updates the description um updates the description so update contract state um i wonder if i should look in here i think i wonder if it's explained in here what that function needs remember you can just go to the you can hover over the function definition and then control click all command click not convinced you can in these ones but maybe what do you do command clicked there who do i press um i'm not sure what it is on mac if it but don't mind it's control and then i click on it and it takes me to the definition although no you have dynamic imports so it might not do that so update contracts did and why update contract state address state there we go okay contract address contract address and then comma we need a new thing something from there args go with zero for now i don't think i need i think you could just console log it couldn't you yeah we'll throw that in there anyway doesn't need any of that or that a contract address no it needs the whole state object so it would be contract state contract contract state dot description equals um args zero maybe i'm gonna go with that but i don't know we'll see what it says let's make sure we save the file um and then let's attempt to deploy it i think maybe sure so i'm going to follow the commands from deploying the example contract here we're going to reinitialize deploy prising contract and then a private key based there we have it so let's just align that to the block chain and then we should be able to run these functions node run contract it's description.js the description that worked and then date description new description network yeah look at that arc zero working nice well let's see if the test passed i guess huh look at all these we got past already wow how many left to do not too many nine ten oh this one's past two this one's past two your fundraising contract should be deployed in mine's election all right okay so running the commands to play your contract and sending it the 150 tokens created transactions so our contract needs to raise 150 tokens before the seventh block is mined and if it does we need to create a transaction that sends all the funds donated from the contract to the address of the creator and then also set the status to closed and if we do not raise the 150 before seven blocks we need to send the transactions back to the people that sent them to us okay so you have to keep that all in state now use sent what so initial state i guess um maybe donated transactions and then maybe an array and a um raised maybe like a number status description i think that might be enough so you definitely need to keep track of all the transactions that come in so we can send them back and i think that'll work i don't know if we need to keep track of the raised or not you could just look through the transactions i suppose so that sounds like an optimization thing that you may or may not want to do yeah okay so this on new transaction comes when our contract gets a donation so we're going to need to if we get a transaction what do we need to do put it in the state also add two raised or something add the funds to raise i'll just keep track of it for the heck of it i don't know i need it um and then we need to check if we have the 150 send all funds to contract creator something like that maybe um yeah i'd go with that okay so contract state so a transaction comes in let me console.log transaction fill that in there what does a transaction look like when it comes in yeah probably an amount and the address would be the contract address and the from address would be um whoever sends it so this is tricky update contract state contract address new state um the state has a transactions object so you know what i'm just gonna go we have this contract state here so i'm just gonna contract state transactions not push this work no transaction what's that transaction that came in and then we could also do contract say dot is plus equal transaction dot amount maybe i'm not sure you can plus equals on a property you can't thanks um contract state.raise um equals wait yeah you can can't you contract it dot raised plus equals so you can try yeah i don't see why not maybe i don't know um where am i at here okay so we've got a few things happening update contract state add to raised and then should i attempt to do this right now or should i there are helper functions for running contract earning contract playing contract wallet um i thought there's one for getting just the whole state i'm gonna do i'm just gonna do this once throw another one in there why not it stayed console.log contacts we're gonna do that let's just see what happens i should be able to deploy this and we'll see a transaction we'll do that update the state and then we'll be able to check it with that other file okay so um go back reinitialize and then redeploy and find the block and what we want to do is send a transaction to it so if i look at transactions there's one there i suppose i could send zero to it let's mine another block so now somebody has 50. this person public key that's their public key though wallets zero four one two so here's their private key to be able to go add a transaction from this person this is probably all in the instructions it's just i kind of have it memorized um helpers maybe down here add transaction i guess okay we already went through that um so we take the private key and then the to address which would be the contract address very large address i made sure to make them as big as i could yeah that always seemed like it when i looked at these no i did the opposite actually but okay so we have problems um is my transaction though the transaction came in yeah undefined 15 new state well that is the problem contract address contract state all right let's try it again initialize deploy unlock let's do that twice we have a transaction node add transaction um private key private key very key here we got this person0416 um contract address and 50. i think it worked okay so what files have changed this one right here transaction showed up from that person to the contract address this is we just sent this to the contract and it did some things there with signatures um and then the contract ran this file here yeah so we got this log of the transaction that came in and then if we say get state now it should all be updated node run contract east getstate.js it is smart status open transactions nice okay awesome so now we need to do like if if contract contract state dot raise greater than or equal to 150 um send all phones to creator just like i put right there um so we need to add transaction creator address so i suppose that would be their public key of the creator and private key well wouldn't you first send if wouldn't you first put all the transactions into the blockchain that the contract has stayed for and then send a transaction from the contract to the owner say that again so your contract state has a bunch of transactions in it you need to mine those so that the contract address has those funds and then you need to from the contract address send a transaction to the owner well i'm just storing the transaction information in the contract state the actual transactions are also going into the transaction they're already going through right cool right so they're already going on to the blockchain okay i just need the information so that if my contract does not succeed i can send all this stuff back and i probably probably only need like the from address and the amount from each transaction that would be enough to send it back so i'm gonna i'm gonna do that i think on transaction you know what i'm not gonna do that all right um so what was i looking at here this private key i presume is that the private key of the contract itself maybe that's kind of hacky but you can yeah you need to you need to sign it from the contract no yeah and so i wanted to find this function and see what it looks like add transaction somewhere you know what there's this thing you can find right in here somewhere private key to address amount add transaction private key to address creator address amount contract state dot raise that sounds right so you're definitely sending everything through even if it's over the goal yeah yeah isn't that how real fundraisers work you can raise you know you set a goal of something ten thousand but you can also raise much more like a lot of future pretty sure that's awful have you ever watched shark tank no maybe not i have and that's what they say on shark tank we raised twenty thousand on a goal of ten thousand that's what i say um well i mean if you have let's say you raise 140 from previous transactions and then somebody wants to donate another 100 to get to 240. where would that other money go who would get it well i don't know i'm used to things like kickstarter where you have a goal of 10 000 but then some of these you know some kickstarters they have a goal of 10 000 and they get a million i'm pretty sure that they don't get to use the million all right it doesn't matter that's how this one works okay yeah um so i think this file might be done and i don't even know i'm just gonna click this run test let's see what happens maybe that one will pass running and send it there it is so if the 150 tokens get sent yeah it worked nice oh but i also need to so add a transaction i guess i need to update contract state dot status equals close maybe i think that's what i'm supposed to do and update contract state just copy um would just move that line to the bottom of the file all right yeah that's good girl yep is it supposed to be a capital c here no they're closed um what did these users say no it does not look like it okay i guess we'll run the test then i'm gonna have to go through that process of deploying there it is now we need yeah now we need to do this other one on new block this is whatever block it's mined we need to if block length greater than 7 or something send all transactions back to donors i guess yeah something like that okay in my mind you should count the block number from when the contract is deployed and then seven after that you definitely should that sounds better obviously it could be tough to do things with time or something which is what you really would probably want to do yeah yeah that would have been that would have been better why don't you tell me that sooner all right this is this is how it is though for now and yeah that's a bonus to hear if i was going to go through this they can at the end switch up their their contract so that it finds out the block that it was deployed and then the logic is seven after it's deployed block now i like that um so we're gonna have contract state.transactions uh for each maybe what the heck is that maybe some sort of loop to go over all these transactions um a transaction and it was the we got the private key so this is from the contract to tx dot from address i think and to mix that amount that looks right i think so so yeah if blockchain length which comes in running the commands to deploy your contract and mine seven blocks so i think there's a note in here about something when this is actually run it says in immediately after the block is mined yeah is that what it says yeah so it should be greater than or equal to seven i think um okay is that it i can't be it we need to also if block change do update you know screw this copy this contract state let's just do if watching length not greater than seven and contracts not already closed uh not equal to closed it's kind of sketchy condition there should work yeah not good enough for me um so if it's not closed update to contracts dude contract state.status equals closed and i'm around the test i might be missing something but it looks pretty good there it is wow all right apparently my functions are working yeah now we need to kind of start over and deploy it and actually send it enough transactions i think like it says the current state the status closed and a description oh it says description your contract should have had at least 150 tokens sent to it and it should have added a transaction sending all the tokens back to the creator or to the greater whatever so we have to kind of do that i'm just going to start over initialize deploy i'm just going to mine how many do i need 150 so like six blocks so i can have tokens descend just flooding the market here block chained up jason all those wait what where are my transactions oh they're there they're here i just didn't scroll down so now i should be able to go we deployed it um node add transaction from wallets private key to um oh geez copy paste it's like the slowest copying and pasting you'll ever see paste okay so from somebody to the contract let's see it a person doesn't have any money figures from this person no there okay that should work transaction to the contract so i think if i just do it again do you have three no no you're out of money all right well that should be enough for this oh that's only two actually 100 it's supposed to be 150. that first one was one of these well now you've mined too many blocks haven't you no it says your blockchain should have at least six blocks oh maybe i have because at some point it's gonna oh no at some point it's gonna send the money back oh yeah crap you're right um just delete the last json yeah that that could potentially work a little hack but node add transaction ah i know that transaction we're gonna go like this did it work did i get did it happen and cine logs um ours 150 i think yeah i wonder if i need to mine the block i don't think so maybe i maybe i mined too many blocks already and you were right let me know to run might be in here contract wallets i think i use the public address i'll paste it in there let's say get state.js closed now i blew it all right we're gonna start over yet again yay specialize maybe you don't mind six blocks just minding three oh i'm pranking we have zero blocks now we have one block two blocks three blocks we do four so that we have enough coins on the blockchain it should be there's our first block you could also just manually edit one of the um wallets to have 100 or 200. no you can't there's a test that checks that your blockchain's valid i could change the function that yes um it's node add transaction from private key i realized yeah my hotkeys are working to the contract and 50. okay you're out of money um we'll try you that should be it transacted there it is the 150 wow now if i run the test is that it no you don't have six blocks oh your contract should have had at least 100 seconds and should have added a transaction sending all the contracts i wonder oh boy none of that looks good maybe i just need to mine it yeah before you reach this xbox be sure to edit the description that's true huh thanks okay so what have i got here i don't even know i'm not gonna worry about it let's let's do this node run contract contract address i think he's the public key um update description dot js smart contract to raise funds for my startup oh fine one more block press their fingers you cannot update the state of a contract that is not open what oh whoever created this is just evil i guess i wanted you to go through all of this i gotta do it again unbelievable okay i guess it's some good practice so we deployed our contract i'm gonna node my block imagine how much easier this would have been if your addresses were a reasonable length or if my hotkeys were even working my hotkeys are i can't paste into the terminal i don't know why with ctrl v or whatever i don't know so we have my contract so the first thing we're going to do run contract contract address update description dot js smart contract raise funds for i start up i'm going to just run the tests and see if make sure it's passing before something crazy happens in the current state oh well yeah that's that's pretty rough there now let me tell you the problem because someone's going to come along they're going to forget the period at the end of that description and they're going to mine all of their blocks and they're going to fail that last test all part of it yeah okay so if you check the console though you can probably see whether it's failing because of the description or because the status property is closed yeah you might be able to so you get that contract address paste 50 money i can't address info so i mean i could be doing that but i'm just copying probably the same same time to do both so you have all the money or i forgot to mine a block or something oh i definitely mind blocks who has the money what's going on here we've got a blockchain 50 50 50. somebody's got money it's it's probably the yeah that worked i know name of address count your property is not divine saying get water to dress is returning undefined all right you want to make a note of that one too yeah oh no never mind i just had a typo it's a capital m okay okay so here is the public address and the balance for me did i not do it right private key i'll copy it i swear i did this already transactions i don't see any node get address info i don't see any 150 transactions yet so or whatever coins so let's do this one paste there should be it a little anticlimactic but no to get it's gonna try and run the account i'm gonna do it node run run contract copy paste get state touches the transactions are all still there close smart contract good thing i didn't have a period missing or something let's find let's find out maybe there's typo come on fingers crossed oh it's still failing this should all be that those two should be working a smart contract to raise funds for my startup get to the console sure yeah this is not going to be helpful like expected thank you did you mind the block maybe not yeah maybe i need to do that let's try it this one say actual open expected closed all right let's try it maybe i just needed to mine it come on it was whew wow well we got another one so nice work all right um the next project is this peertopeer network so let's just try and check it out um that's so when i click on it it starts me down here yeah it's because it's a single page app so the scroll location is staying the same okay so yeah it's pretty minor but i guess what we're gonna try and do here is build a peertopeer network sort of what gave that away that was the title right it's distributed so we're gonna be working in this folder um we have some boilerplates we don't need to change any of that an old one folder right here represents a node on the network the files in it will be cloned and used to run all the other nodes in the network you only need to change the index.js file um so we're going to use websockets and websocket servers to create a website server in here and it's going to listen for incoming connections and it's going to connect to all the other nodes on the network uh so once we think we have this file finished what we're going to do is run this clone node thing to copy it and then run a bunch of different nodes i guess and so we have to have at least three nodes and we need to create a websocket server and so basically all the servers are gonna connect to each other we have these like known peers which are kind of like entry points to the network and then once one of the sockets connects to one of those entry points it will handshake with the server and the server will send it the list of all of its connected addresses so and then from there it will connect to every other node on the network so we're basically simulating a creating a flood sub network um protocol sure um yeah uh i don't know to be honest that's i'm gonna i'm gonna go with it sure um so we're gonna have to have some server listening um when it starts it should attempt to open soccer so it should attempt to connect to known peers uh when i saw your connection when a connection to server is established okay so we're going to try and connect to these and if we find a connection we need to send it a string object that says this type and shake data ray so it looks like we have the address of the server here um data should be an array of addresses that your server is connected to including the server's owners so data connected addresses that's what we need um my yes connected addresses something like that when a server receives the above message it should attempt to open socket connections so when i connect to a server i send it this and when my server receives this so something like server dot on and shake connect yeah do all data um you should keep track of all the addresses the server is connected to you can use that when a socket disconnects you should remove it so i guess that would be possibly like socket dot on clothes i think move from rey something like you should keep track of the servers you are attempting to make make connections do not try to make more than one connection to the same server okay and then after you connect remove it there's some issue i remember adding that there's some issue that was causing an infinite loop of servers connecting to each other yeah uh server should never attempt to create a connection to its own address you should clone your node one folder at least two times all of your nodes should have the exact same code with the exception of the env file um you should have at least real three nodes running use those ports all of your nodes should have an open socket connection to all other nodes um there's a bonus there hints adding console logs can really help websocket servers okay here this looks promising copy i can't even copy from there can i yes i can server port so make this server and the part is going to be my port and then server.on connection so to create a server listening on the given port i wonder so that's listening already server.on connection log connection three seed that socket that on message runs when i suck it sends a message to your server nest it within the connection function you want to make a note of this i'm missing closing parentheses right here so we have a string that comes in that's console.log message received and i'll just go plus data string i think that'll be this for sure so and how to work with sockets so here's like your server and then you kind of want a second thing which is opening a socket connection to the server from the server yeah so you want to act as a server a websocket server and as a websocket client pretty much um uh let's run the test i got one nice um okay when a node opens the socket connection so the first thing we want to do is try to connect i know i need a connect function so i need like this function connect address that's what i'm going to do and the first thing we want to do is up here anyway um we need to attempt to open a connection to all those addresses so something like known appears that each here connect here council log something to connect to here address save it and we'll just see if anything happens so i have to go actually into this node one folder and then i can run that okay and something is running you're attempting to connect and it is still running it is not stopping running but successfully made a for each call loop um so if we want some catches here if address not equal to my address so we don't want to try and connect to our own address and and we're not something to connect to it and not attempting clues address i think that should work so we can actually test that i'll leave that console log in there and this first node has a port of 4001 i think yeah that's my own address so we'll not attempt to connect that to only attempt to connect to that one all right so attempt attempting to connect addresses dot push we are now attempting to connect to an address yeah when i went through this i remember i wanted to use sets just because i think it works quite well when you have elements that you don't want to repeat and that you want to easily remove so that's just a did it work did it work or not yeah no it works it's just you need to remember when you're passing it through the api to i think sets have a two array method or else you just have to say array from and then pass the set in yeah yeah okay so when a socket connection to a server is established send a message to the so i think we want to move this handshake message and trying to connect and then once we do connect we want to send this um you go to these helper syntax server sockets so think we do yeah that looks right so all in here we're going to try to connect to this address on open on close on air runs when any connection is served has been established so that sounds promising so i should in here want to send this message suck it dots and that some data wanted to be i just go i can't go like that is it jason that stringify or is it something to string i think string of fireworks here yeah it's jason yeah that's what i do whenever i'm working with websockets um i think i'm missing another one of these maybe i'll just give myself a little more formatting there and i don't know why i'm getting four spaces that is no good but i can handle it for now okay so let's uh let's throw that's a log connection open so you know what else we need to do a attempting to connect to addresses splice or something and then find press one that won't work with it no i think you need to do the attempting to connect addresses dot find index yeah it's the index something um so can i do something to connect addresses dot index of i think that'll work let's see how many off for one errors there are so and then we want to go to connected addresses dot push i think address so we have now connected action open and then suck it dot on clothes it on here i'm probably just i'll just throw some console out i'll pull that log they're connecting to run through that there tempting i'm gonna remove it from this um and then on close we should just addresses from there it's going well i think although it may all crash and burn on me but we'll see i'm trying to think all of the things that fire the error event that's emitting area event for sockets because what happens if you splice and index of returns negative one so right now you're treating it as if on error only happens when there hasn't when on open hasn't happened now um here i don't know what splice does if attempting to connect dot index of returns negative one because it might start from the the back of the array and then just remove some random last element drawn here um i'm gonna bring this tab over i think you're on to something so if i splice a negative one one this turns into this so it removed june for some reason the last yeah so i think yeah i would i would take that attempting to connect address out and make sure that it's not negative one yeah i like that just if if uh index greater than or equal to zero like that and probably i feel like i wonder if i should do the same thing here i think it would always be in here if it's closing we're gonna leave it watch it crash yeah so we start up we try to connect to the known peers none of them will be running right now so nothing's gonna happen yeah and then message received so the message that we receive should be this message handshake yeah um and then well do you want to i i think you also have to parse that message into yeah if you wanted to um but you want to just create a bunch of nodes and test it out see what happens yeah because they should try to connect to each other shouldn't they um yeah they should send some messages around yeah okay so there's some helper functions to run to clone it i'm in the node 1 folder so i actually have to back out here and then i go known clone node i might do it twice so we have three so now we have three and look over here and split this up and then now i gotta go into each folder cd node 2 arc cd node 3 and run the thing we've got problems i know attempting to connect a dress dresses um so you gotta go back you can't just copy the code over to the different notes which is probably the way to go but you can also use this uh node delete nodes which will delete the things there you go node clone on tv node two i would have tried running the first one before cleaning them again but it's syntax error what's here cannot find name attempting to connect attempting to connect addresses attempting to connect addresses that's a typo in the boilerplate code attempt i think i'll edit that that is a problem attempting it's everywhere oh no attempting attempt attempt ding okay we'll save it run okay we awesome nice catch um we are attempting to connect to 4003 we got an error because i have to let my captain i'm not running all right note index oh it did it connected attempting to connect to so this one tried to connect to both this is 4002. air connecting to 4003 that one's not running connection to 4003 open connection open connection to open okay so we had a connection opened 4001 and then we received a message on 4001. um received a message here and it's got both addresses and so um i guess const data equals json.parse data um not quite whoops dated too not quite date a string oh there we go okay i don't like this anyway because the field is data um we'll go message and then um message that oh what the heck was that but again i have a typo just that data got for each address connect let me see how many times you'll do this okay like is that all i need that might be enough all right well let's try it so they should connect to each other i'm gonna reclose this one um delete my nodes clone them again node index will run this one so it's running why does it print closed there at the end connection closed connection closed um so there it is your um air connecting so first it goes to error and then it goes to close for some reason well i suppose that makes sense because it connects or does it connect well attempts to connect right it doesn't actually connect until it gets a response i presume yeah i don't know why it would close if it hasn't opened no i don't know oh well number two um node index so now we are in a loop oh no that's fun up somebody help crash it trash it okay we're alive um that's quite funny so if address not equal my address and not attempting to connect addresses that includes address socket.on close on air let me see what it says over here um you should add what the heck happened i can't even see my terminals to find out um so i had a server listening i started up the first one and then i started up the first one tried to connect but it didn't make any connections because there's nothing else to connect to the second one opened and connected to the first one and sent the first one this message its own address yes just its own address and so then the first one tried to connect to the second one which should assuming you want to not do the connect if it's already connected so yes you need another yeah yes i do that is the problem perfect that's teamwork right there yeah don't think there's anything wrong with that if connected it and okay i'm doing this with my eyes closed okay if address not equal to my address and if not then just if not connected it's okay all right let's try it again um okay we've got several nodes and run that one okay that looks good cd node two index okay okay i think that's good so this one got a message with the two addresses and then it attempted to make a connection there and it opened one all right let's see what happens here um cd three okay oh that'll break oh we've got a whole bunch running four nodes running all connected to each other and i think that should pass well no infinite loops is a good sign crossing my fingers i see a lot of x's message do i need to do more here on close on error send data that really looks good go ahead well i'm just thinking so the server it's only connecting when it receives a message does the so you have on open you're sending something don't you want to send from the server the connected addresses not from the client this kind of is the whole thing is the server you can call it a client and now that makes sense for typical websocket stuff well that that it the um so when you say new websocket that that's a websocket client yeah when you say new web socket server that's a websocket server so i'm thinking when the server receives a connection they should send the server should send here are all my connected addresses you might be right didn't read any of this hardly um oh i did read through it pretty good if sorry so when you connect to a server you should send it a message with these but the server doesn't need to because what you're basically doing right now is if you start up node 5 then it's not connected to anything but it's whoever first it makes a handshake with it's saying here are my connected addresses as opposed to connecting and the server saying here's everything i'm connected to so note 5 would send it it would start up it would connect to this first one and send it its own address and the first one would receive it and then attempt to connect back to it and then when the first one connects back to five it would then send all the connected addresses where five would then then attempt to connect to two three and four maybe that's not the right way to go but what is there anything in the console that's giving reason for the failures i'm doubtful this is not so that says it's crashing that's throwing um the tests pretty much just try to make connections to all the different things and see what the handshakes come back is yeah it's not reaching the assertions which is why it's just an empty object do you think i'm i mean it seems like it seemed like it was working they were all connected to each other so it seemed like that they should have passed and that it was working as it should have been right or no maybe i'm missing something um we'll start start node four up again let me close everything oh there we go so node one um not quite over cd node one node index node two started attempted to connect to one and three error on three and one worked yep and then the message received is i am connected to one and two oh yeah okay so it's it's my address and connected addresses yeah yeah that should be right yeah um i think that that makes sense cd node three let's see what this one said it gets a little busy here yeah um attempting to connect to one one open and then it sent me all these yep attempting to connect to two and the first one received these two which seems right yeah attempting to connect to two and it did open and then it received so 2 sent it back this then stopped because it was already connected to all those message type handshake data i see something i see something in there i see something oh yeah yeah yeah yeah okay so i'm gonna this time i'm going to copy code me okay i think that looked great tess i think it's patina thing would show up in the console though nice we got it if i run the test again there they go well how long did we spend on a typo about the average time you usually spend on a typo awesome that's three down so moving on to the fourth project which is building a web through client side package for your dapp and in this project we're going to be building a clientside package that's in the form of a class that can be used to interact with a web3 provider which would basically be your network for a blockchain we can see the files we have here the class is in this index.js file that we need to build out we can see an example of a provider here which is basically just a rest api consisting of some routes that you would interact with in rpc calls and so we should first cd into the build a web 3 client side package 3. and we have the boilerplate in the index.js file and we can see an example of the way that this api that we're building out is going to be used in this example client where we are importing the class and we can see some methods on this api such as set client address init smart contract and we can see that basically the api just uses this to interact with uh the smart contracts that we'll be building out where we can call the methods that might exist with a smart contract and there's an example idl that we pass into initsmart contract that we can find here and this is very basic ideal which is basically a schema of your smart contract it tells you in these instructions it's basically the methods of the smart contract we have a setclick method and a getcontract account method the args expected for the setclick method is one argument that is of type string and there are no arguments to the get contract account method the user stories that we will be completing let's just go for it so we know that we will be we need a method that is set client address and that takes in an address and doesn't return anything and what this method does is it sets the class address property to the given address so that's the start address to give an address which means that we need to construct our class with some address that i'll set for null okay we'll call that one down the next method is call and it accepts an rpc call object and it returns a promise so we know that this is asynchronous and what this does is makes a post to the call smart contracts route on the ahref of the provider property so this class will have a provider property that will be equal to something and we will want to make a fetch to this route which what we can do is the provider href and it is to the call in fact and then we want this to be first method which means we will have a body and the body of the post should be the rpc call object literal and the address property of the web3 class so we need a body here and let's just create a body that is the rpc call and the address of the class i remember when going through this that i struggled with the the url there that when you make that call smart contract it doesn't need the forward right slash so we do have a link down here to the url api of its basic javascript api that also exists in node and if you play around with it a bit you you'll kind of figure out that calling atriff it always appends to the end of the string the forward slash i i suppose the smarter thing to do here would be to um i know i know you would use the path api to the path module and the join method and you would join these two paths together um problem my head i can't think of how to do that with the url api but i'm sure there is a way so now we need to the call should return the result property of the response or throw an error if the response contains an error property so what we need to do is get out the response which is s and if response dot error into throw this will just throw a new error that is that error otherwise we want to return response dot result so that should be that method done and now we need an init smart contract method so we can see this also would there be a way to desire to interrupt there'd be a way to just to make sure it's working other than just like running the tests that's a good question um so it would be a bit difficult uh you would need to get the provider up and running so what you can do is create a new terminal just you don't need to create a new terminal you can start the provider by saying node node provider dot js leave and we can see here what warp does is it starts the provider it deploys the smart contract with just a test smart contract that is located in this package file and then it starts listening on port 301 so i suppose we would need to set the provider here and we could manually do that with new url http localhost v01 so from then we could actually just write some tests ourselves so if we wanted to uh let's just do something simple so we could set the client address here and we could just make a thumb and then we could console.log e web3 dot address i think if we did that we can open ourselves a new terminal here and we could run this in node and it should work so except it is a module but we'll see what happens node there it is so we have tested that creating the class works it has starts with an address of null and the provider is this url object and then we change the client address from null to tom and we can see we printed out there if we wanted to do a test on the call we could and yeah say web3.call and we would need to pass in an rpc call uh what that would require is well we could look at it from the provider's perspective the call method in this case makes supposed to call smart contract so he has cool smart contract it gets from the body an id method args and address so if we wanted to we could just add in an id 0 args would be let's leave it as an empty array method we'll probably just get this wrong and we can say test what else do we need address so the address would be the web3 dot address you can pretend that that works and this is an async method so let's just get the response out of that and console.log e response and we run our script again and we get an error which is very fun where is this error in json.pass so actually while we're debugging debugging debugging console.log the response here and we'll check why that is happening this is the response it looks like it's just the old average um http response and so why is json.parts not working probably because we need to use the weight res.json method and let's not console.log that okay so we get a response from the server here which is smart contract with id undefined not found why is it saying id undefined not found that is a very good question because we have defined it as zero but clearly that just doesn't exist and we can see here also in the provider it's it's logging out those errors um so let's clear that for now and we will come back to it that is a bit more involved than i would hope it to be you can see it it basically if you get an idea of what going what's going on in the background you need to provide a running and then you can just run the script using node and it all works and fetch works in the fetch api works in node version i think it's 17 and above so 18 is officially released so that is what the docker image is running on i feel like that would help it would have helped me when i was playing with this is kind of a way to to test it more and see if it's working or not other than just kind of writing the code and hoping now that that is a good point it's probably something we can add on to this in future prs uh to make it more userfriendly and just a bit more a bit clearer obviously i think once you've gone through the practice projects and you've learned a bit of content and you understand rpc calls better as well as you know having built out your own provider it makes a lot of sense what is happening here where the fetches are going and what's being returned but until then we can definitely try and make it better so if this in its smart contract what we need to do here is we need to take in the idl which is your um your smart contract signature and we need to basically turn that into callable methods so we can start by we know we want to return the smart contracts methods and that means we want an object and we will want to here's an example if we have an idl with these instructions where we have these different methods defined by the handles get favorite number and set favorite number you can see that after we initialize the smart contract it returns a smart contract object that has these properties the set favorite number method and sorry the get favorite number method and the set figure number method so what we will want to do is for each instruction of the idl loop over that and add the handle to the smart contract so we want to put in the instruction dot handle we need to set that equal to a function because that's what the instructions are they're just functions and in some of the cases the functions will be asynchronous they don't have to be but they can be so we just add the async method there and we know that there are some args that this will accept but we don't know how many we've defined it as a function now what we need to do is the callable method should return a promise okay so that's set here in async and it resolves the result of the core method somewhere in here we are calling the start call and we are returning it so let's not call except we are waiting that because call is is and from here we need to construct the rpc call so just as we did down here when we passed in the obviously call to the core method we are wanting to construct this out of where am i yep we want an rpc call we need an id which actually is inside before loop and even more so we need it to be inside the function and we get from the instruction it's actually from the idle itself it has a property id passing the id of the smart contract so that the giver provider or um in our case more likely validator will be running the actual code of the smart contract needs to be able to find the smart contract on the blockchain so we pass in the id and what else did we need we needed args and a method so the method we know is the instruction handle and the aux is the argus that passed into the parameter of the function and did we need anything else so the address is done by the call property itself we actually didn't even need to include that um it's not it's overwritten anyway see when we wrote this out the body added the address for us so it's just the rpc call here and we can pass the rpc call into this one now what we need to do at the end of in a smart contract is return this object that we have just recreated created okay are you happy with that though i think so okay well we are moving on to create this get balance method if if you ran the test would it would it pass those or is there we can try and run the tests definitely it's always a good idea uh run the test as often as you can and hope things don't break so we're on the tests and we are failing absolutely everything there are a lot of tests yes actually if you're wanting more information you can probably read the test text yourself we can look at why it's failing and it seems that something is erroring out in our code i think one of our issues that i definitely know of is when we are creating our web3 class um yeah we need to actually pass in and i'm pretty sure i had it written here somewhere yes remember it it's a initializer or something yes you get the address from that the provider address from that i never know where it is um i wonder if it's in the castle so in here we need the provider address and we just replaced this hard coding that we did for our testing better and the wonder if changing that will allow us to pass any of these tests isn't it is it provider that hr for url or something or is it just provider well the constructor just accepts a string okay and we turn that into our url ourself okay and we're still failing all of those so i think one of the better things we can do is finish out the api here just so we don't get any crashes and we will be defining a transfer method that takes in an object and let's just say from to amount so this is all to transfer from one address to another address a certain amount and if we do that see what running the tests does nothing we can look into what is actually happening by reading the server output so web 3 is not defined which means we are not exporting this well we need to make sure let's just comment about our tests for now okay there we go so our tests were messing up the output there i'm not exactly sure why but we we will leave it like that so we are actually passing first five here we're exporting our class we are so your web3 class should have a provider property that is an instance of url constructed from the initializer argument that's what we've just done here in the constructor and we have the say client address defined correctly there is an asynchronous method with the handle call we have done that and call makes a post to this route so what we are not doing is post call smart contract should have a body including the json stringified version of the rpc object literal so we are not stringifying our body it's always something to remember okay and let's keep going so we need a content type header set to application json so that would be in the headers and we need never remember if this actually needs to be capitalized in a certain way so we'll just try it out and we are sending through json it looks like the it's capitalized in the text and the instructions so if you read your instructions correctly then you will probably have a better time passing the test thank you tom so the request should have a body including the json stringified version of address we are doing that yes he has address the core method should return a promise yes we are doing that if the response contains error throw yes oh we are passing that excellent we're passing all of these and then down here we are failing one of the internal tests where it's actually testing out the api so if we go to 17 in the console we can probably see why and these used to be in numerical order but for some reason they are no longer and it seems that it's just crashing there so let's run the tests and see if we're passing any more yes we are almost there and now we need to actually to find out the get balance api so we need to make a post this is more of the same that we did in the call so i'm actually just going to copy paste this we are matt this is fine so instead of a fetch to call smart contract we are making a fetch to get balance and the get balance request should have a body including the stringified version of address so there's no obc call here there is just address and we can see back in the function definition that address is optional so we need to fall back to well if the argument isn't passed in here then we need to fall back to the classes address and we also need content type here excellent we've done that balance method should return a promise that resolves with the result i think we are doing that resolves with the result yes and if it contains an error throw that error we are doing that okay let's see if we're passing those tests okay and we are so now we need to just do transfer and i think that is again more of the same except now instead of address we need the from to an amount in the body and we need to json stringify this so if we change body to just from to an amount we didn't need to destructure it here but that's fine we'll leave it and instead of get balance we are changing this too okay let's run with this and i wonder if that's it no what are we failing if the response body contains an error property transfer throws an error with the value of the error property are we not doing that looks like it well then let's go to the console and see what expected missing required fields to equal missing required fields from no that's you're not destructuring correctly or something there in that body i think body equals from 21 oh that looks right so in this case we're saying from is undefined but it's expected from to be null expected from to be null so actually i wonder what we want from to be is our address so you know what we should probably actually read the user stories i wonder if it says the body should be jason's string of my body okay you are doing that i suspect we need to actually say from and this needs to be either from yeah or this dot address and that something's just wrong there but yeah that might work yeah we might need to make that actually clear in the tests and things there we go okay so we passed all of those that was quite involved but got there in the end and yeah okay on to the final integrated project and this one is build a smart contract in rust so for this project we need to create and deploy a smart contract using rust that keeps track of how many users have clicked a button very fun and our boilerplate starts us with a rust library consisting of unit tests and integration tests that we are expected to pass so let's get that up here nice so we can see where we need to edit our code and these are the unit tests the integration tests are in the tests directory we can see those here if we ever need to actually look at those so boilerplate already contains the necessary crates to complete the user stories but we need to import them into the code and you will be required to define structs and functions matching those used in the tests and we should only need to work in this lib.rs file so actually let's just cd into that directory cd into bold a yeah what are we smart american rust and we might as well just run cargo test lub to get this all going that seems to working well and here are the user stories not too many some useful resources about wasm and rust in general and some tips okay so let's get started our smart contract uses wesenpac to compile the rust code to javascript for node.js um we already have wesempac installed so that is fine and we'll need to build our smart contract data using it the smart contract exports an initialize function that returns this funny result so we will need to export using the public keyword to make the function public and it is a function and we want to initialize it and this function takes no arguments and it returns this new result public function initialize with an s okay so we are returning that result and what we can do for now is just say okay something and i think you see here in the user story it's this function returns a context wrapped in a js value whatever that means um this will probably help us wrap a value image s value using the from survey implementation on js valley but for now i will just continue with the api and build out ob functions so we also need to export a setclick method that accepts a js value with the context type okay so we need some sort of context type in there but it's a js value it's not context because it is coming from the javascript interface and we are returning again the results and what does this so this function also accepts a string as the second argument so we need to remember that and which is the address of the user who clicked the button so and strings across rust and javascript are relatively similar in that they're just strings so we need and i keep forgetting the fn keyword get contract account it returns it accepts a js value with context type so we can just context this value and return anything okay and this function returns an account wrapped in a js value again something that we may not know what means so let's just add some use to this i enjoy doing that because we can run the tests probably from here what is this this is just like a little rust filler function that stops it stops it from crashing or something pretty much exactly that yeah so normally if you have a um a linter going with this as well then it prevents the linter from saying hey you have unused stuff and hey you know you say you're returning this but you're not actually returning anything so i find the to do macro quite useful um but i remember that i actually need to import resin bind in and we can use the prelude to get all of that fun stuff that we've used our js value in jsera and yeah let's run the tests with this and just see if we pass any of the integration tests but it looks like we erroring out because of this so when in doubt to do i guess so so we are still not compiling because we need to actually define the account and context structs which we have definitions for over here so your library should export a struct named account so let's just do that yeah so struct account and it has the following fields total clicks and that is a u64 as well as clickers which is a vector of strings and these will these strings will be the addresses of the clickers other than that we need context and that has a base account field which is an account easy and i think we need to make these public vector that's just an array or what a vector it's yes it's it's a list but it's it it's pretty much an array but more specifically it's dynamically allocated so you don't have to know the the size of it beforehand sounds good okay let's see if that makes the compiler happy enough no it does not why ah okay so we need to do some more imports in order for us to what's the word crossover between the javascript and the rust or in this case wasm interface we actually need to serialize and deserialize the structures that we have so we are going to import d serialize and serialize and then from there we need to annotate our functions that we implement the we derive the traits for them so we can use the attribute and derive serialize and be serialized for both of these okay i wonder if that is enough one day we will pass these tests okay it looks like i actually need to spell correctly okay so we we are passing something so it's useful to know we have here some unused variables and we are passing all seven unit tests excellent so let's move on to just do the integration tests and that is wesmpac test firefox headless and you can run this in the browser but it just outputs the exact same information that goes in the terminal here so you might as well run it headless and while that's going we can see what else we need to do here so at some point we need to deploy the package using node node deploy.js so using the script and we need to pass in the path to our package directory and we should run node node smart contract passing in a contract id set click and clicker name to add at least three clickers to the contract okay we'll get to that later right now it looks like we just have a bunch of wasm errors probably because we are not annotating our functions that we're exporting as something for asm2 and maybe now we can actually get somewhere with these tests although we're technically still not returning anything so where's them will complain we can for some more of these user stories so this function returns a context wrapped in ajs value so we need to create a context here is our context so what we can do is just say let context equal context and this has a base account which value is account and we need to start this with some same numbers i would assume so we can do little clicks zero no one has clicked initially or when we initialize the contract node will have clicked and for clickers we will do an empty vector that looks about right except we now need to wrap that in a js value so we go back down here to the tips we can see this value has the from survey implementation and we can pass in a context with our context um and we want a result out of this so we just need to say okay i'll i don't have a letter for this but i remember that from certainly expects a reference to the context so we just need to little hamburgers handy is that like a is it like a return then it says okay it's the return so in rust we have implicit and explicit returns and basically if you leave out the semicolon then it's an implicit return this is standard uh basically if there's no ambiguation as to where you're returning in your in this case your functions then you implicitly return but if there is ambiguation maybe you have some other if something then you'd it's better to explicitly say hey i could actually return from location but okay you're just wrapping something into a result so it's it's just a type here we're saying that our type returns and in this case this case we're returning okay if for some reason this initialize uh some had some other logic and infinite going as we expected so in this case then we could instead of wrapping it in okay we would wrap it in error and you know we might want to do this but in this case because the function is so simple there's not actually anything going on in here that wouldn't fail during compile time there's no reason to have an error variant of the result so let's move on to something slightly more complex the set click function are we doing with this we are well i suppose we need to find out by um fulfilling the user stories in the integration tests there we go so if i go we know we want to return the context so let's just do the same thing as above let's do that over and we're not doing anything here but at least this will compile and in here we need to return the account you can see that the get contract account function it returns an account wrapped in the js value now the account is inside the context so we actually need to access the base account field and we can say let account or in this case yup netaccount equal to we'd actually first need to get the context out so i think we define context and say that this is of type context and then we can use context dot day so into sur day is derived implemented full context on a js value because we have explicitly derived it as part of the i always forget if it's serialization or deserialization when you're moving this way um but anyway and we are just using this operator to propagate the error out into a result if interstellar day fails to derive it ah sorry to deterioraze it and then we need the account so let account equal to context dot base account and we want to wrap that js value from survey and pass a reference to the account let's see if that allows the tests to run no and it's because from surday returns a result so we need to unwrap that and we can just okay so unwrapping all of these from survey calls that's not how you underwrite we can see if that tests to run no because we have something that requires sized context serialize is not implemented for js value we are not trying to where are we over here this is an interesting error um i think one of the things we need to do is in order to get the account out we are actually just taking a reference and that might be all we need here okay that wasn't it okay where's the error line 30 okay okay so we've said this and no so we need to let context equal text equal to context so they that's what it wanted maybe okay so it's running tests we passed four nice we passed another eight and then we failed some so let's look at this we are it's a lot of output here but we can see that other than the warnings we passed the four tests result to do with the initialize function so the initialized integration tests we're passing those he said click we are passing all of those which is surprising oh no we are failing this one so it needs to push clicker and increment total clicks so what we need to do is we need the account out of this account equal to you want to mutate this because we need to increment the clickers context dot you want base account and then we need the account dot total clicks it equals one that's plus equals one and we need to push accounts dot clickers push the address so that should be all we need there and now let's see if we pass any more tests with that you can't borrow this as mutable because we didn't declare it as mutable that's why we did that there it is shouldn't need that okay some more tests passing initialize past all of those tests set click we increment it and we push it okay so what are we fading nothing is that all we needed well let's find out by running the test here okay so we passed the unit tests there passed initialized integration tests set click integration tests get contract account integration tests but we have not yet deployed our smart contract so let's do that by running node node deploy.js and the path to our package directory okay so we need a package directory how do we do that we need to build it first so we need wax and pack and we have any more information about that build your smart contract with node.js as the target so we need to wasn't back build and to pass in node.js as the target and click return this doesn't crash okay something's happened it says that your wasm package is ready to publish at this location so if we just double check yes the package is there what we then need to do is just run that node node deploy face and the path to the package is uh just it's just packaged i think okay we hit that and we get a bunch of errors maybe we need to point it to the file we can drop directly oh yes oh a smart contract in rust dot yes okay that's done something um let's what would the wasm file be the contract so the fun thing about bull building the package like this using wasm using ryzen pack is that because we are interfacing with the javascript api uh you can see with the js value here we need more information than just the wasm we need to do a whole bunch of memory allocation and stuff and that's done in javascript so that when we import the package it's we can import it as javascript and the javascript code then uses whatever wasm webassembly um module in order to import the instance here and then reexport it you can do this manually but as you can see there's actually quite a lot of stuff that you still need so and that's only because we're interfacing with the javascript okay if we weren't then we could just run and use the dot wasm as your yield average by byte code um so we've deployed that if we run the test we pass that it's deployed and you should add at least three different clickers to your contract state so this we need to run this command to add at least three clicks to the contract so let's do that node node smart contract.js the contract id we can see here that the smart contract deployed with id0 so let's add zero and we want to set clicks so we pass in the name of the function which is cyclic and the clicker name let's add tom and i think what we can do is we can view our blockchain in node data blockchain so we have here clickers dom nice we can add another clicker let's add myself that done that's mind another block and the clickers are now turtle clicks two and clickers tom and then let's add a mud another block so that should be it yes excellent
