With timestamps:

00:00 - i'm talking to you today about web
00:01 - assembly and asking the question uh is
00:04 - this going to be the death of javascript
00:06 - and yeah it might not be the best meetup
00:09 - to ask a question like that if you feel
00:11 - like throwing something at me that's
00:12 - fine just wait till the end that's all
00:14 - cool
00:16 - so i'm going to start off in typical
00:17 - fashion with a brief history of the web
00:19 - and i'm i know the web is a complex
00:22 - complex set of technologies i'm mostly
00:23 - going to be looking at javascript and as
00:26 - i think most people have worked with
00:27 - javascript for a while know the language
00:30 - itself was invented in a very short
00:31 - space of time by a chap called brendan
00:33 - ike he invented it in just 10 days
00:36 - and
00:37 - back in 1995 the web was a very very
00:39 - different place it wasn't the kind of
00:41 - dynamic single page app react type
00:45 - environment that we know right now it
00:46 - was mostly static pages the occasional
00:49 - form and javascript was there to just
00:51 - add a little bit of interactivity on top
00:53 - of an otherwise pretty static web
00:56 - since then other languages have come
00:58 - along and java applets activex flash you
01:01 - might have used some of these
01:02 - silverlight my apologies if you've used
01:04 - that dart and so on and that's it that's
01:06 - the history of the web done because 2018
01:10 - it's still javascript it's still only
01:12 - javascript javascript is the only
01:14 - language which is officially supported
01:16 - by the web
01:18 - but the interesting thing is the way
01:20 - that we're using javascript has changed
01:22 - a lot in the 20 odd years since it was
01:24 - originally invented
01:26 - i guess
01:27 - without going into too much detail one
01:29 - of the things that's that that i've
01:31 - observed is that we collectively we
01:32 - write a lot of javascript and when i say
01:35 - a lot i mean a lot of javascript and
01:38 - just the other day i i started up a new
01:40 - react app so i used the create react app
01:42 - package so this is me creating a new
01:44 - application uh and then finding all the
01:48 - the javascript files within the project
01:49 - and doing a line count 79 000 lines of
01:52 - javascript
01:54 - that's a lot of javascript
01:56 - and the thing is we we're we're using
01:58 - javascript uh for far more than just
02:01 - adding interactivity on web pages which
02:03 - is the world that brendan ike uh was was
02:05 - creating javascript for we're using it
02:07 - as build tools we're using it on the
02:10 - server we're using it on mobile devices
02:12 - we're using it all over the place
02:14 - but the weird thing is
02:16 - the way that we're using the language
02:18 - itself has changed quite a bit
02:20 - many years ago i guess when i first
02:21 - started using javascript it was quite
02:23 - simple you'd open up a text editor you'd
02:25 - write some javascript it would be served
02:27 - over http and exactly the code that you
02:29 - you had written would be executed within
02:31 - the browser
02:33 - that doesn't happen very often these
02:34 - days typically the code that you write
02:36 - will be transpiled it will be minified
02:39 - it will be bundled it will go through
02:41 - all kinds of really quite advanced
02:42 - transformations and by the time it lands
02:44 - in your browser it will look a bit like
02:46 - a garbled mess
02:48 - and that's led a few people to consider
02:50 - javascript to be the assembly language
02:52 - of the web it's it's a compilation
02:54 - target as well as the language we use uh
02:57 - to write our applications
02:59 - but this is where sorry move my cursor
03:02 - this is where
03:03 - the problems start to surface because
03:05 - javascript actually isn't a very good
03:08 - assembly language and it's no surprise
03:10 - again reflecting on the context within
03:11 - which it was invented in the first place
03:13 - it was never designed to be an assembly
03:15 - language it was never designed to be a
03:17 - compilation target
03:20 - and to understand why it's a bad uh
03:22 - compilation target why it's not a good
03:24 - assembly language you have to understand
03:26 - a little bit more about how javascript
03:28 - is executed within the browser so this
03:31 - is a diagram that i took from a a
03:33 - mozilla blog post where they were giving
03:35 - a
03:36 - a rough overview of how javascript is
03:38 - executed within the browser so the first
03:40 - bit on the left-hand side is a bunch of
03:42 - characters come along over http and
03:44 - they're parsed into a thing called an
03:46 - abstract syntax tree it's a it's a
03:48 - tree-like representation of your code
03:51 - after that
03:52 - it it generates some by byte code which
03:54 - is then run within an interpreter and
03:56 - then this is where the really clever
03:58 - stuff starts happening many years ago
04:00 - that was it that was the way that
04:01 - javascript was executed these days a lot
04:04 - of work has gone into optimizing
04:06 - javascript so what will happen is the
04:08 - runtime will start to look at your code
04:11 - look at the execution and make certain
04:12 - assumptions if you've got a function
04:14 - that is always called with a pair of
04:16 - integers for example it will generate an
04:19 - optimized version of that and the
04:20 - execution of that function will become
04:22 - faster and i think it was the um safari
04:25 - browser has something like four
04:26 - different tiers of optimization and your
04:28 - code sort of moves up and down these
04:31 - tiers so as it as it can spot
04:33 - optimizations it moves up a tier but if
04:35 - the assumptions it makes about your code
04:37 - is false it has to push it back down
04:39 - again
04:40 - it's really really complicated and as
04:43 - you can imagine this isn't an efficient
04:44 - uh compilation target
04:47 - and how how does this actually manifest
04:49 - itself
04:50 - one of the things that as a javascript
04:52 - developer most of us or pretty much all
04:54 - of us are concerned about is the
04:56 - execution speed of our our code within
04:58 - the browser and there's the
05:00 - one of the most important things
05:02 - something that people have been focusing
05:03 - on a lot recently is is the time to
05:05 - interactive the time it takes to load
05:07 - all your code and actually start doing
05:08 - something and this is a timeline that i
05:11 - shamelessly borrowed from this fantastic
05:13 - blog post by lynn clark it's it's well
05:15 - worth the read she does an excellent job
05:17 - of describing
05:18 - why webassembly is needed but i'm just
05:19 - grabbing this diagram here this is a
05:21 - timeline that approximates the execution
05:24 - of javascript within your browser so the
05:26 - first thing it does is it has to parse
05:28 - your parse your javascript the next is
05:31 - it has to compile and optimize it and
05:33 - then potentially it will have to
05:34 - re-optimize it and then afterwards
05:36 - you've got a certain amount of execution
05:38 - and garbage collection
05:41 - the timeline you see here the the pass
05:42 - time the compile time the optimized time
05:44 - has a significant impact on how long it
05:47 - takes for your application to actually
05:49 - execute and be interactive so this is
05:51 - again why i'm saying that javascript
05:53 - isn't a good
05:54 - assembly language this isn't
05:57 - if you were designing it from scratch
05:58 - you wouldn't design it like this
06:01 - and i guess this this little quote here
06:04 - i think summarizes it quite nicely this
06:06 - is a quote from the team that created
06:08 - webassembly and they mentioned that the
06:09 - web has become the most ubiquitous
06:11 - application platform ever and yet by
06:13 - historical accidents the only natively
06:15 - supported programming language for that
06:17 - platform is javascript and this is
06:19 - coming from a bunch of guys who are uh
06:21 - web developers and they love javascript
06:23 - so it's not that they're not against the
06:25 - javascript languages
06:27 - itself but the the situation we've found
06:30 - ourselves is is a weird quirk of of
06:32 - history
06:34 - so that brings me onto webassembly if
06:36 - you look at the webassembly
06:37 - specification the webassembly website
06:40 - they describe it as a new portable size
06:42 - and load time efficient format suitable
06:44 - for compilation to the web so it was
06:47 - designed specifically to solve some of
06:49 - the problems i've been talking about
06:52 - now
06:53 - hands up if you've heard of asm js
06:55 - before
06:56 - okay that's that's good so an
06:59 - interesting part of the history of
07:00 - webassembly is quite tightly related to
07:03 - asm.js don't worry if you've not heard
07:05 - of it before it doesn't matter i'll give
07:07 - you a quick illustration of what it is
07:09 - and hopefully that will help you
07:10 - understand some of the design goals of
07:12 - webassembly
07:14 - so asmjs was a a bit of an experiment it
07:17 - was actually a bit of a wacky idea that
07:19 - was uh created by mozilla i think around
07:21 - about five years ago and at that point
07:23 - in time there were various other
07:26 - plug-in-like technologies being uh
07:28 - considered
07:29 - in the standard plug-in model is you
07:31 - take some other runtime and you kind of
07:34 - bolt it onto the side of the browser
07:35 - that's how that's how plugins worked and
07:37 - at that time there were other people
07:39 - considering other plug-in style models
07:41 - whereas the mozilla team came up with
07:43 - this slightly crazy idea of why don't we
07:45 - create this sort of virtual runtime that
07:47 - sits within the javascript virtual
07:49 - machine so they said okay we need memory
07:51 - so we'll just have an array that can be
07:53 - our memory we need instructions so we'll
07:55 - create effectively patterns within our
07:57 - javascript that represent those
07:59 - instructions so i'll quickly illustrate
08:01 - what it is and then show you why that is
08:03 - a great demonstration of a slightly
08:05 - better way of doing things
08:06 - so here's a here's a bit of code this is
08:08 - some asm.js code
08:11 - don't don't worry too much about the
08:12 - detail at the top this is a a um
08:16 - a function written in c that does your
08:18 - standard fibonacci calculation i'm
08:20 - compiling it using a tool called m
08:22 - script and into asm.js and that's what
08:25 - you see at the bottom there so asmjs is
08:28 - javascript but it's a particularly
08:30 - peculiar looking kind of javascript i'll
08:32 - highlight a few things i won't go into
08:34 - all the details but the first thing
08:35 - you'll see here is the reassignment of
08:37 - the arguments to this function so a
08:40 - equals plus a so typically you'd use
08:42 - that to kind of coerce something to be a
08:43 - number b equals b or zero which means
08:47 - that it's exactly the same as it was
08:48 - previously these are type hints these
08:51 - are telling the runtime that
08:53 - one of these is a float and one is an
08:55 - integer you can see at the bottom it's
08:56 - returning plus c again you can see the
08:59 - pattern here that res
09:00 - in my c code is a float you can see that
09:03 - we've got in the javascript code a for
09:05 - loop asm.js doesn't support for loops
09:08 - here you've got a do while instead
09:11 - so
09:12 - that all looks a bit crazy and you might
09:14 - be asking why on earth would you do that
09:17 - getting back to the way that javascript
09:20 - executes within the browser you can see
09:21 - what they were trying to achieve with
09:22 - asm.js so what happens with within a
09:25 - browser that understands it well firstly
09:28 - if the browser doesn't understand asm.js
09:30 - it doesn't matter it's just plain old
09:31 - javascript and it executes as normal
09:34 - however if the javascript recognizes
09:36 - asm.js and it does that by looking at
09:38 - this use asm literal string at the top
09:41 - what it does is it starts doing the
09:43 - usual thing it passes it into an
09:45 - abstract syntax tree but then
09:47 - immediately it spots the patterns it
09:49 - effectively reads the asm.js assembly
09:52 - language and immediately is able to push
09:54 - it right up the um right up to quite a
09:57 - highly optimized version of the code
09:59 - skipping some of the quite
10:01 - time-consuming interpreter steps and
10:03 - optimization steps
10:05 - so as you can imagine this is quite a
10:07 - neat idea but i think asm.js was only
10:09 - ever put together as a a technical proof
10:13 - of concept because one of the things
10:14 - they could never get around is the very
10:16 - first bit at the beginning the parsing
10:19 - the javascript language and as you can
10:20 - see
10:21 - it's asmjs is itself pretty verbose so
10:24 - as you can imagine parsing it to the
10:26 - abstract syntax tree has got quite a lot
10:28 - of overhead
10:29 - but asm.js was a great proof of concept
10:32 - that there might be a better way of
10:33 - doing things
10:35 - and their early demos were really quite
10:37 - impressive the m script and tool they
10:39 - use also had
10:41 - logic in it to convert opengl code into
10:44 - webgl code and they were able to take
10:46 - some game engines and do some pretty
10:48 - impressive things
10:51 - so
10:53 - asmjs pointed pointed people towards a a
10:56 - different and interesting approach to
10:58 - solving this problem which was quite
10:59 - different to the standard sort of
11:00 - plug-in model as a result the
11:03 - webassembly working group was formed and
11:05 - it was formed in 2015 with with
11:07 - representation from all the main browser
11:09 - vendors and a bunch of others and
11:12 - quite impressively within the space of
11:14 - two years they managed to design their
11:17 - mvp scope for web assembly and and get
11:19 - it released in the wild so
11:21 - in november last year um it was turned
11:23 - on in all brows all major browsers
11:25 - without the need for flags so it's
11:27 - officially out there in the wild it's
11:28 - also in node version 8 and and beyond
11:32 - and
11:32 - just earlier this month w3c published
11:35 - their first public draft as well so they
11:37 - managed to get this done in a very short
11:38 - space of time and i think it was mostly
11:40 - because asmjs effectively created a
11:43 - blueprint to demonstrate some of the
11:45 - concepts here
11:47 - so i've talked a lot about webassembly
11:49 - but i haven't actually shown you any
11:51 - webassembly so i thought the best way to
11:52 - do that was to actually
11:54 - show some code and talk around the code
11:56 - just so you get a better idea of what it
11:58 - actually looks like in in real life so
12:01 - switching to code this is obviously
12:03 - where it all goes horribly wrong um
12:06 - okay
12:07 - so i'm going to start with a very very
12:08 - simple example this is a function that
12:11 - adds two numbers together and even
12:13 - though this is visual
12:15 - vs code that's actually c which is
12:17 - horrible and dirty and makes me want to
12:19 - wash my hands but there you go there's
12:21 - an add function and what happens is with
12:23 - my build my tool chain i'm not going to
12:25 - go into too much detail about that
12:27 - my tool chain is compiling that into
12:30 - webassembly and there are two distinct
12:32 - formats that you can use to view your
12:33 - web assembly the the obvious one
12:36 - is oh tiny tiny
12:39 - is in hex so the output of webassembly
12:43 - is a binary format so again uh recalling
12:46 - how javascript is is processed by your
12:48 - browser it no longer has to pass the
12:50 - characters into an abstract syntax tree
12:52 - it's a compact binary format
12:55 - but the more useful way of looking at it
12:57 - is the um actually they've changed the
13:00 - file extension for this it's the watt
13:01 - format web assembly text format it's a
13:04 - shame they didn't go for webassembly
13:06 - text format wtf as an extension that
13:09 - would have been awesome
13:10 - but anyway
13:13 - this is my c code so i'm adding two two
13:15 - numbers together and this is what it
13:17 - looks like as web assembly so
13:21 - a few little bits and pieces here we've
13:23 - got the concept of memory so memory
13:25 - within webassembly is very similar to
13:26 - the memory concept they invented with
13:28 - asm.js memory is a contiguous array of
13:32 - bytes and that memory is actually shared
13:34 - between the webassembly runtime and the
13:35 - javascript runtime so you can you can
13:38 - make rights to the webassembly memory
13:40 - from your javascript code
13:43 - it defines functions it's got
13:45 - a whole load of instructions there are
13:48 - about 60 odd instructions and it works
13:50 - as a stack machine if you've done any if
13:52 - you've done any programming with some
13:54 - kind of assembly language of some sort
13:56 - the full instruction set will look quite
13:58 - familiar to you
14:00 - webassembly can also export and import
14:03 - functions so you can export a javascript
14:06 - function from your webassembly module
14:08 - so you can export a webassembly function
14:10 - from your module and invoke it from
14:12 - javascript and vice versa you can import
14:14 - a javascript module so that it can be
14:16 - executed by your javascript
14:18 - so that's that's my web assembly and
14:20 - we've got the binary format and i'll
14:22 - show you how it's actually loaded
14:24 - instantiated and instantiated and
14:26 - executed now because i can't be bothered
14:28 - by with creating a html page to house
14:30 - this i'm just doing it within node but
14:32 - it's pretty similar within the browser
14:34 - so we're we're loading the webassembly
14:37 - binary format and we're constructing a
14:39 - module from it and then from the module
14:41 - we're creating an instance from the
14:44 - instance we can invoke the exported
14:46 - functions so here if i execute add it
14:49 - tells me that two add three equals five
14:52 - so here i've gone from javascript
14:54 - it's executed a webassembly function
14:56 - within the webassembly virtual machine
14:58 - and return the result
14:59 - that's all all pretty straightforward
15:02 - i'll show you now some of the areas
15:05 - where it gets a little bit tricky and
15:07 - now i feel like i'm showing you a bit of
15:08 - a tip of the iceberg in that it's not a
15:11 - simple case of just writing a whole load
15:13 - of code in webassembly um creating an
15:15 - api layer and invoking it from
15:16 - javascript at the moment it's relatively
15:18 - challenging to do that
15:20 - one of the reasons for doing that is
15:21 - that webassembly has a very small number
15:24 - of built-in types it only has four types
15:26 - and they're all numeric so it's got two
15:28 - floating points and two integer types
15:30 - what that means is if you want to do
15:32 - something with
15:33 - something a little bit more advanced
15:34 - like strings it gets quite complicated
15:36 - so my next little demo is just something
15:39 - which returns a simple string from my
15:41 - webassembly function and renders it from
15:43 - javascript so i'll just um
15:46 - pop back there okay so this is my c code
15:49 - so what i've done is i've created a a
15:51 - hellowasm string which is referenced as
15:54 - a
15:55 - character pointer and i've got a
15:56 - function which is get message ref so
15:59 - what that's doing is is
16:01 - returning the reference to the message
16:03 - if we look at the compiled output it's a
16:05 - little bit more complicated this time
16:07 - we've got these things called data
16:08 - sections within our webassembly module
16:10 - and these are basically ways of
16:12 - instantiating your webassembly module
16:15 - memory to a known state and here you can
16:17 - see it's actually writing hello wasm
16:20 - it's writing something else which i
16:22 - think is the offset to
16:25 - uh actually i'm not sure i'll have to
16:26 - check that it's writing something else
16:30 - and here is how it's actually executed
16:32 - within javascript and here you can see
16:34 - that simply by um changing it from an
16:36 - example based on integer types to
16:38 - strings things get a little bit more
16:40 - complicated so we've seen this bit of
16:41 - code before this loads our webassembly
16:44 - binary and instantiates a mod module but
16:47 - now to return the string the
16:50 - the get message ref function isn't
16:52 - returning a string it's returning an
16:54 - integer which is an index to the
16:56 - location of that string within linear
16:58 - memory so i'm having to get hold of a
17:00 - reference to my linear memory
17:02 - create a create a buffer and iterate
17:05 - over that buffer populating it with
17:08 - going by byte across my linear memory
17:10 - reading the data out and if i execute it
17:13 - and
17:15 - it does indeed say hello wasm and that's
17:19 - by all means not an exhaustive
17:21 - exhaustive demonstration of webassembly
17:22 - but hopefully it gives you a bit of a
17:24 - feel for how whether how you use a web
17:26 - assembly module from from within
17:28 - javascript and some of the current
17:30 - limitations that there are so a little
17:32 - bit more on the webassembly architecture
17:33 - so webassembly itself is a stack machine
17:35 - as i mentioned it has four built-in
17:37 - types
17:38 - 67 instructions
17:40 - importantly it's designed to support
17:42 - streaming compilation so there are some
17:44 - features that are specific to
17:46 - webassembly which reflect the context
17:48 - it's used within
17:49 - for the vast majority of use cases your
17:51 - code is being streamed over http so it
17:54 - makes sense that webassembly can be
17:56 - compiled in in a streaming fashion and
17:58 - what that means is your your browser is
18:01 - able to chop up the webassembly module
18:03 - and compile it in parallel on multiple
18:05 - threads so again it's been designed to
18:07 - be very very fast
18:08 - it all also has some very simple
18:10 - validation rules
18:12 - javascript and any other web-based
18:13 - language has a lot of validation rules
18:15 - that ensure security webassembly is just
18:18 - the same but again they've been designed
18:20 - in such a way that they can be processed
18:22 - and in serial as it's streamed in and as
18:24 - i mentioned before exports imports
18:26 - functions and has a concept of shared
18:28 - linear memory with javascript
18:31 - now
18:32 - one of the first questions that people
18:34 - ask when they look at webassembly is oh
18:35 - great this is going to be super duper
18:37 - performance it's going to be really
18:38 - really fast and i must admit i've read a
18:41 - lot of blog posts which makes some quite
18:43 - um
18:44 - quite impressive and to be honest quite
18:46 - incorrect claims about the performance
18:48 - of webassembly i've seen blog posts
18:49 - claiming that it's a hundred times
18:51 - faster than javascript
18:53 - unfortunately most of those blog posts
18:54 - suffer from the classic problem of doing
18:56 - micro benchmarking and either bench
18:58 - benchmarking the wrong thing as well so
19:01 - what i did was created a slightly more
19:03 - representative test case i created a a
19:05 - mandelbrot and rendered that using c
19:08 - javascript and a bunch of different
19:11 - mechanisms for for
19:13 - generating webassembly modules and i
19:15 - perfor i compared the performance of
19:17 - them and as you can see the black line
19:19 - here is the native performance so that's
19:22 - my c code uh compiled directly on my mac
19:25 - and executed natively
19:28 - and the interesting observation
19:29 - immediately is wow javascript is really
19:32 - really fast it's only about 20 slower
19:35 - rendering a mandelbrot and that's
19:37 - because of the many many years that's
19:38 - gone into compiler opt the runtime
19:41 - optimization for javascript
19:43 - disappointingly when i ran it within
19:45 - webassembly it was actually a little bit
19:47 - slower and using wasm assembly script
19:50 - and a few other different approaches i
19:52 - eventually through a number of
19:53 - optimizations managed to make it just a
19:56 - little bit faster than javascript so i
19:58 - must admit i was a little bit
19:59 - disappointed by that result
20:01 - i've had a look at other benchmarks and
20:03 - other results and most importantly the
20:06 - the paper that was published by the
20:07 - webassembly team the uh the accepted
20:11 - sort of general feeling is that web
20:13 - assembly should be around about 20 to 30
20:15 - percent faster at runtime execution than
20:18 - javascript but
20:20 - because javascript is is really quite
20:22 - fast there are there isn't that much of
20:24 - a performance gain to be made where they
20:26 - expect webassembly to beat javascript
20:28 - significantly is the parse time and the
20:32 - initial compilation time so the time to
20:34 - interactive with webassembly should
20:36 - theoretically be a lot less than with
20:38 - javascript
20:40 - so in the future one of the things i
20:42 - mentioned was that webassembly was
20:43 - developed over a really quite short
20:45 - space of time and partly that was
20:47 - because they had asmjs as a kind of
20:50 - reference implementation
20:52 - another reason is the current
20:53 - webassembly release is very much an mvp
20:56 - they were
20:57 - quite aggressive about ensuring that
20:59 - they had a very small set of features so
21:02 - they could release quickly and the idea
21:04 - is that they're going to be releasing
21:05 - new features over the over the coming
21:07 - years so some of the things that it
21:08 - doesn't have at the moment is a garbage
21:10 - collector and i'll explain why that's a
21:12 - bit bit of a pain later on
21:14 - in the future it will also have
21:15 - threading support a thing called host
21:17 - bindings which is a way as i showed you
21:20 - the interface between javascript and
21:21 - webassembly is a little complicated at
21:23 - the moment and if you want to start
21:24 - doing dom manipulation from webassembly
21:27 - that's hard with host bindings in the
21:29 - future that will become a lot easier
21:32 - so one of the final things i want to
21:34 - look at is um web assembly language
21:36 - support and what some people are
21:38 - actually doing with the language so i
21:39 - showed you a little bit of writing a bit
21:41 - of c code as a way to show you what
21:43 - webassembly actually looks like the text
21:46 - format and so on but most people aren't
21:48 - going to write webassembly in its its
21:51 - machine code well in its binary format
21:53 - or in the text format most people are
21:55 - going to want to use a language maybe c
21:58 - maybe not rust go people are going to be
22:01 - using other languages and treating
22:03 - webassembly as a compilation target so
22:05 - i'm going to quickly
22:07 - look at the different
22:08 - languages and their current level of
22:10 - support
22:12 - so the first one is c or c plus plus and
22:14 - this is the the very first language that
22:16 - that gains webassembly support and again
22:18 - that's due to its heritage from asm.js
22:22 - there's a tool called mscrypton that you
22:23 - can use to compile c to web assembly and
22:26 - m script and does a lot more than just
22:29 - um a straightforward compilation it has
22:31 - as i've mentioned it's got the opengl to
22:34 - webgl bindings and it's got a whole load
22:36 - of other things that make it quite easy
22:39 - to take an existing c code base and
22:41 - compile it to webassembly and put all
22:43 - the glue that's required around it to
22:45 - actually make it work
22:47 - as i mentioned it was originally used to
22:49 - create the asm.js concept
22:52 - some of the practical things i've seen
22:54 - people do with it there's a there's a
22:56 - company that have a thing called ps pdf
22:58 - kit um it's basically a pdf renderer and
23:02 - um just last year they started exploring
23:05 - the use of webassembly so they've got a
23:06 - c plus code base and they explored the
23:10 - use of webassembly as a way of of using
23:12 - exactly the same code base to do pdf
23:14 - rendering on the web and they they found
23:16 - it quite a good experience they managed
23:18 - to create something which i think
23:20 - they're going to actually ship as a as a
23:22 - product and with very good performance
23:26 - this one's a fun one uh
23:28 - jsc so
23:30 - the
23:32 - javascript core which is the javascript
23:34 - machine that runs within within webkit
23:37 - is itself written in c plus plus now
23:39 - using m scriptin you can compile c plus
23:42 - to webassembly so what that means is you
23:45 - can take javascript core
23:47 - compile it to webassembly and then run
23:49 - it on top of your javascript virtual
23:51 - machine so what this is is um the
23:54 - the uh safari javascript virtual machine
23:58 - compiled to web assembly running on
23:59 - chrome which is great
24:02 - it's exactly what you need finally um
24:06 - one thing you'll probably notice here is
24:08 - at the moment
24:09 - a lot of people are essentially
24:11 - experimenting with this technology there
24:13 - aren't you won't find a huge number of
24:15 - really practical use cases yet i think
24:18 - that's still to come although
24:20 - where i work at scotlogic we've done a
24:22 - bit of work with a company called active
24:24 - financial and they provide
24:28 - they provide market data for people that
24:29 - need high frequency data so people that
24:31 - are doing um algorithmic trading for
24:34 - example and all of their distribution
24:36 - logic all their serialization logic is
24:38 - written in c and c plus plus and they've
24:40 - been getting a lot of requests from from
24:42 - their their clients who want to start
24:43 - using it consuming this data from within
24:46 - javascript either
24:48 - perhaps aws and a lambda function or
24:50 - perhaps within the browser so we help
24:52 - them take their c plus code compile it
24:54 - to webassembly and use exactly the same
24:57 - code to
24:59 - to to parse their packets of data and
25:02 - deliver their high frequency uh data to
25:04 - the web so that's something that we were
25:05 - able to achieve with webassembly
25:09 - uh
25:10 - oh that should say c sharp that's a
25:12 - mistake anyway so c c plus plus that's
25:15 - the story um java and c sharp these ones
25:18 - are a little bit more challenging
25:19 - because as you're i'm sure you're aware
25:21 - java and c-sharp are languages that both
25:23 - rely on garbage collection whereas c c
25:26 - plus you manually manage the life cycle
25:29 - of your objects
25:30 - and because webassembly doesn't have
25:32 - garbage collection yet that means it's a
25:34 - it's quite a a problem it's quite a
25:37 - challenge to take java and c sharp code
25:39 - and compile it to webassembly
25:40 - there's an experimental project called
25:42 - blazer
25:44 - that's become an official i think
25:45 - asp.net
25:47 - experiment
25:48 - which uses mono some of you may be aware
25:51 - of mono as a way to run java and c-sharp
25:54 - within webassembly and what they're
25:55 - doing is they're experimenting with a
25:57 - couple of different ways of doing it one
25:59 - of one of them is interpreted mode so
26:01 - they've basically taken the runtime and
26:03 - compiled it to webassembly and they're
26:05 - executing they're executing c-sharp dlls
26:08 - directly within the browser the other
26:10 - one is ahead of time compilation so
26:12 - they're actually compiling the dll
26:14 - directly to webassembly and they're
26:16 - they're experimenting with these two
26:17 - side by side
26:19 - blazer is a project that wraps around
26:21 - mono's webassembly support and it's a
26:23 - fully featured single-page application
26:25 - framework so there's a lot of c-sharp
26:27 - developers getting quite excited about
26:29 - the potential of blazer
26:30 - i don't have anything practical to show
26:32 - on on c-sharp and blazer because it's
26:34 - very very new and i don't think anyone's
26:36 - done anything practical with it quite
26:37 - yet
26:39 - so i guess one of the final ones to talk
26:41 - about is is javascript so why
26:44 - why shouldn't you compile javascript to
26:46 - webassembly and then there's a lot of
26:47 - people writing react applications and
26:50 - all kinds of other
26:51 - based applications and and you look at
26:53 - the features you get with webassembly
26:54 - and you think yeah i'd like some of that
26:56 - i'd like my javascript to to pass more
26:59 - quickly to be optimized immediately so
27:01 - there are a lot of people trying to find
27:03 - creative ways to compile javascript
27:06 - to webassembly and obviously there are
27:08 - even more challenges there so firstly
27:10 - you need a garbage collector secondly
27:12 - it's not statically typed so you've got
27:14 - typing as a bit of an issue
27:16 - there are a couple of projects i've been
27:17 - keeping an eye on that
27:19 - are trying to tackle this first is
27:21 - called walt which is a javascript like
27:23 - syntax for webassembly so what they've
27:25 - done is they've taken that text-based
27:27 - format which i've shown you and tried to
27:29 - map it as closely as possible to
27:31 - javascript so it's it's a thin veneer on
27:33 - top of the webassembly text format
27:36 - the other one that i've actually had a
27:37 - bit of a go with is assembly script so
27:39 - in order to solve the typing issue
27:41 - that's pretty straightforward with
27:42 - javascript these days you've got things
27:44 - like flow and typescript that introduce
27:46 - typing so with typescript you can
27:49 - enforce typing of your code and use a
27:51 - very similar
27:52 - compilation path that you do for c and c
27:55 - plus
27:56 - and at the moment that project is is in
27:59 - its early stages and they're currently
28:01 - awaiting news of when garbage collection
28:03 - will appear within webassembly to make
28:05 - some fairly critical design decisions
28:07 - about how they how they tackle that
28:09 - i've actually got a bit of a demo uh
28:11 - hopefully i typed in the wi-fi password
28:15 - so has anyone used d3 before
28:17 - yeah cool yeah everyone loves d3 so this
28:20 - is a d3 force layout but what i've done
28:23 - is i've taken d3 force layout and taken
28:26 - all the algorithmic code and rewritten
28:28 - it using typescript and compiled it to
28:30 - webassembly so basically the um the
28:33 - standard sort of end body algorithm and
28:36 - the kind of hooks law spring concepts
28:38 - are all being computed here within
28:40 - webassembly using typescript and it was
28:42 - quite an interesting experiment for me
28:44 - to see how easy it is to take
28:46 - a a javascript application that wasn't
28:48 - written in typescript add type
28:50 - information to it and then compile it to
28:52 - webassembly and work out how to manage
28:55 - the interface between the two so
28:56 - actually if you scroll down uh
28:59 - if you scroll if i scroll down you can
29:01 - see it's got it it supports exactly the
29:03 - same api as d3 itself but all the
29:06 - computations being done in webassembly
29:08 - that
29:09 - that was good fun i enjoyed that
29:10 - actually i'm going one thing i'm going
29:12 - to do
29:13 - is i'm going to get rid of that demo
29:14 - because it's got a memory leak
29:18 - yeah i know
29:20 - the final one i want to briefly touch on
29:22 - is is rust um has anyone used rust here
29:25 - before
29:26 - no
29:27 - definitely the wrong room for that oh a
29:29 - few yeah so rust is is
29:31 - gaining popularity quite quickly if you
29:34 - ever have a look at the sort of
29:36 - metrics stack overflow does a survey
29:39 - every year and they do quite a lot of
29:40 - data analysis and rust seems to be a
29:43 - programming language that makes people
29:45 - really really really happy so it's a
29:47 - modern language it's a very very popular
29:49 - language
29:50 - significantly here it doesn't require a
29:52 - garbage collector it's got quite an
29:54 - interesting memory model that has the
29:56 - concept of ownership so every every
29:58 - object that's allocated on the heap is
30:00 - only ever owned by one reference at one
30:02 - point in time which makes it very very
30:04 - easy to reason about memory and clean up
30:06 - memory
30:07 - it's hard getting your head around it
30:08 - initially but it's a good concept
30:11 - so within rust what they did was they
30:13 - used the m script and tool chain and are
30:15 - actually investing time in creating some
30:16 - better tool chains
30:18 - and i found this quote actually from
30:20 - someone within the russ community who
30:22 - says we're poised to be the language of
30:24 - choice for for webassembly and the
30:26 - reason for that is it's a much loved
30:28 - language and because it doesn't need a
30:30 - garbage collector it's actually in a
30:31 - great position for for being compiled to
30:33 - webassembly right now
30:35 - so um i had a bit of a play with it
30:37 - myself i created a a chip 8 emulator so
30:40 - chip 8 is a
30:42 - a pretty old um
30:44 - engine for for playing arcade games i
30:47 - say engine it was it was one of the very
30:49 - first virtual machines actually it was
30:51 - developed by someone who at the time
30:53 - came up with a concept for a virtual
30:56 - machine for playing games that could
30:58 - then be incorporated into a number of
31:00 - the the current computers at the time it
31:02 - was a great idea it wasn't terribly
31:04 - successful but it's great for people who
31:06 - who want to experiment with creating
31:08 - emulators because it's actually quite a
31:10 - simple machine to emulate so for me this
31:12 - was great fun having a go at rust i'd
31:15 - not used rust before so trying to do
31:17 - rust write an emulator which i'd not do
31:19 - before and then compile that to
31:20 - webassembly that that kept me up a lot
31:22 - of nights but that was good fun but
31:24 - having said that um
31:26 - people are doing some really practical
31:28 - and useful stuff with rust and
31:30 - webassembly and again a lot of this is
31:32 - coming out coming from mozilla
31:34 - so in a very recent blog post um they've
31:37 - talked about some of the work they've
31:38 - done on source maps so source maps uh
31:41 - is if you if you're not aware of what
31:43 - source maps is source maps is a
31:44 - technology that allows you to map that
31:47 - highly mangled version of the code that
31:49 - runs in your browser to the source code
31:51 - that you created in the first place so
31:53 - source maps are a way of mapping from
31:55 - one representation of code to another
31:57 - and source maps as you can imagine quite
32:00 - computationally intensive but the most
32:02 - popular source maps uh library that
32:05 - supports um parsing and understanding
32:07 - source maps is all written in javascript
32:10 - and the team behind it decided to take
32:12 - some of the most
32:14 - performance critical logic rewrite it in
32:17 - rust compile it to webassembly and then
32:19 - evaluate the performance and you can see
32:21 - here one of the performance metrics they
32:23 - were looking at was the time it takes
32:26 - from
32:27 - setting a break point to be able to
32:29 - actually inspect your code so basically
32:31 - to be able to to
32:33 - pass i don't know if pause is the right
32:34 - word but understand the source maps and
32:36 - map the breakpoint back to your original
32:38 - code and as you can see here the
32:40 - webassembly performance i know the text
32:42 - is a bit small there at the bottom but
32:43 - the web assembly performance is these
32:46 - little blue clusters so a couple of
32:48 - observations the first one is clearly
32:50 - webassembly is is quite a bit faster in
32:53 - the order of two to three times faster
32:55 - but another interesting aspect here is
32:57 - the javascript performance you'll see
32:59 - quite a spread in performance and that
33:01 - is because again of the nature of the
33:03 - way that javascript is executed it goes
33:05 - through
33:06 - multiple tiers of of optimization where
33:08 - it might be optimized and then
33:10 - de-optimized and what that means is your
33:12 - runtime performance isn't terribly
33:14 - predictable whereas within webassembly
33:16 - the runtime performance is highly
33:18 - predictable in comparison so that was
33:20 - that was a fantastic blog post and a
33:22 - really interesting read and the
33:24 - interesting thing is
33:26 - even though this was done as an
33:27 - experiment and if they're happy with it
33:29 - if all the unit tests run they can put
33:31 - that in production now and everyone who
33:33 - uses source maps directly or indirectly
33:36 - is then going to receive the performance
33:38 - boost
33:40 - so finally um i want to do a bit of
33:42 - crystal ball gazing
33:45 - so as i've shown you that the current
33:47 - state of webassembly is
33:49 - is is variable depending on language and
33:51 - in terms of what people are doing with
33:53 - it again there's lots and lots of
33:55 - experimentation but now i think we're
33:57 - starting to see the signs of where it's
33:59 - actually going to be used in future and
34:01 - how it's practically going to be used
34:03 - so
34:04 - my prediction for 2018 is as you can
34:06 - imagine lots more creativity mostly
34:09 - coming out of of languages like rust but
34:11 - we're also seeing a lot of creativity
34:13 - with c sharp i have a feeling the swift
34:15 - community are going to be very very keen
34:17 - on this because swift has a lot of
34:19 - common attributes with rust it's a
34:21 - modern language it's quite a pleasant
34:23 - language to use and also using um arc
34:26 - ultimately yeah automatic reference
34:28 - counting it's got a memory model that's
34:29 - quite compatible with webassembly
34:32 - also within 2018 uh i don't know if
34:34 - you've noticed two days ago there was a
34:36 - new webpack release version four and
34:38 - that included webassembly support so
34:40 - webassembly as a top chain now allows
34:43 - you to import rust directly within your
34:46 - code and web assembly webassembly sorry
34:47 - webpack because it's magic will do its
34:49 - magic and the right thing will pop out
34:51 - the other end
34:52 - hopefully if you get your configuration
34:54 - right
34:56 - so yeah
34:58 - if you get configuration right it's
34:59 - great if it's not right then it's hell
35:01 - but um
35:03 - i also think that within 2018 you'll
35:06 - start to see webassembly sneaking into
35:08 - your daily workflow without actually
35:10 - knowing it so as i showed you right back
35:12 - at the beginning when i create a react
35:14 - application it adds 79 000 lines of
35:18 - javascript to my machine and most of
35:20 - that code is is being used at build time
35:23 - very little of it is actually being used
35:24 - at runtime i think that 79 000 is going
35:27 - to start going down as people start to
35:30 - use web assembly to hit performance
35:32 - critical parts of your of your tooling
35:34 - another thing i think you're going to
35:35 - start seeing is native node modules
35:38 - using webassembly i don't know about you
35:40 - but i find it quite frustrating that the
35:42 - workflow involved in using node modules
35:44 - that have native code there's a lot of
35:45 - friction there
35:47 - now
35:48 - there isn't a terribly good reason to do
35:49 - that anymore you can actually ship
35:50 - webassembly instead
35:53 - so 2019
35:55 - within webassembly itself i'm pretty
35:58 - sure we'll start to see garbage
35:59 - collection host binding threading we'll
36:01 - start to see webassembly itself become a
36:03 - lot more powerful
36:05 - as a result c sharp and java some of the
36:08 - languages that require a garbage
36:09 - collector will become first-class
36:11 - citizens of the sort of webassembly
36:13 - ecosystem
36:14 - i think we're also going to start seeing
36:16 - um
36:17 - wasm ui frameworks so we're going to
36:19 - start seeing ui frameworks that are
36:20 - targeted that are entirely written as
36:23 - web assembly and and and geared towards
36:26 - um perhaps c-sharp or java developers
36:29 - and we're already starting to see that i
36:31 - saw a project which was called asm dom
36:33 - which was a virtual dom so modeling the
36:35 - react concept a virtual dom written in c
36:37 - plus plus compiling the web webassembly
36:40 - whereas next year i think that'll
36:41 - actually start to become a practical
36:43 - option
36:44 - also i think we'll see more of our our
36:47 - general plumbing move to webassembly for
36:49 - example again using react as an example
36:51 - it does some computationally intensive
36:52 - tasks to do the dom diffing why not put
36:55 - that in web assembly uh others other
36:57 - frameworks for example there's a thing
36:59 - called the glimmer vm which is a
37:00 - templating engine which i is in one of
37:02 - the ui frameworks whose name i can't
37:04 - remember but i'm pretty sure that will
37:06 - move to webassembly as well
37:08 - interestingly though i think we're going
37:10 - to start seeing rust go swift and other
37:13 - languages start to gain some web market
37:15 - share
37:16 - you might think that's a good thing you
37:17 - might think that's a bad thing but i
37:19 - honestly think it's going to start
37:20 - happening
37:22 - 2020 and beyond again i'm going to go
37:24 - back to that quote the web has become
37:26 - the most ubiquitous platform ever yet
37:28 - historically
37:30 - by accident the only language that is
37:32 - supported by the browser is javascript i
37:34 - think in 2020 we're going to see
37:36 - that that being challenged um javascript
37:39 - will no longer be the only language of
37:41 - the browser and the web
37:43 - i also think people are going to start
37:45 - making significant progress towards
37:47 - compiling javascript directly to
37:49 - webassembly again for the very reason
37:51 - that javascript is a perfectly good
37:53 - language for writing web applications
37:55 - there's absolutely nothing wrong with it
37:57 - but at the same time as javascript
37:59 - developers start seeing rust developers
38:01 - and
38:02 - swift developers benefit from
38:04 - webassembly they're going to be wanting
38:05 - to get some of that as well
38:07 - my gut feeling is that the javascript
38:10 - language itself will start to
38:13 - move towards some of the typescript
38:14 - concepts to allow webassembly
38:16 - compilation if you've been following the
38:18 - way that typescript has evolved over
38:20 - time typescript has deliberately stayed
38:23 - on a relatively convergent path with the
38:25 - javascript language itself i have a
38:27 - feeling that some of these features
38:28 - typing for example might become a first
38:30 - class feature of javascript
38:32 - in order to allow us to compile to
38:33 - webassembly
38:35 - finally
38:36 - i guess it regretfully i do honestly
38:39 - think javascript's popularity will
38:40 - decrease a little bit
38:42 - is anyone going to throw anything at me
38:44 - quite yet now maybe leave it a little
38:46 - bit i'm a big javascript fan myself
38:48 - honest no but i do honestly think um
38:51 - javascript has got a monopoly at the
38:52 - moment and and the web platform is
38:54 - ubiquitous it
38:56 - i don't i think it's a safe bet that
38:58 - javascript will start to have a bit of a
39:01 - fight with some of these other languages
39:03 - but
39:04 - at the same time i think the reach of
39:05 - the web will increase
39:07 - even more so i think through progressive
39:10 - web apps so progressive web apps
39:12 - are currently talked about mostly within
39:14 - the context of mobile but progressive
39:16 - web apps make a lot of sense on the
39:17 - desktop as well so i think a combination
39:19 - of progressive web apps and the ability
39:21 - of webassembly to allow you to do
39:23 - computationally intensive complex
39:24 - operations will mean things like
39:26 - photoshop for example will become a
39:29 - progressive web app i think things like
39:31 - autocad the autocad team already are
39:34 - looking at webassembly i think the
39:36 - ubiquity of the web will increase or the
39:38 - ubiquity of javascript will
39:40 - and webassembly will increase and move
39:42 - more onto the desktop
39:44 - so yeah that that pretty much brings me
39:46 - to the end web assembly and the death of
39:48 - javascript and i'm going to say
39:51 - no it's it's not going to die but i
39:52 - think it's got a real fight in its hands
39:55 - and if you disagree you can start
39:56 - throwing things at me right now
39:59 - [Applause]

Cleaned transcript:

i'm talking to you today about web assembly and asking the question uh is this going to be the death of javascript and yeah it might not be the best meetup to ask a question like that if you feel like throwing something at me that's fine just wait till the end that's all cool so i'm going to start off in typical fashion with a brief history of the web and i'm i know the web is a complex complex set of technologies i'm mostly going to be looking at javascript and as i think most people have worked with javascript for a while know the language itself was invented in a very short space of time by a chap called brendan ike he invented it in just 10 days and back in 1995 the web was a very very different place it wasn't the kind of dynamic single page app react type environment that we know right now it was mostly static pages the occasional form and javascript was there to just add a little bit of interactivity on top of an otherwise pretty static web since then other languages have come along and java applets activex flash you might have used some of these silverlight my apologies if you've used that dart and so on and that's it that's the history of the web done because 2018 it's still javascript it's still only javascript javascript is the only language which is officially supported by the web but the interesting thing is the way that we're using javascript has changed a lot in the 20 odd years since it was originally invented i guess without going into too much detail one of the things that's that that i've observed is that we collectively we write a lot of javascript and when i say a lot i mean a lot of javascript and just the other day i i started up a new react app so i used the create react app package so this is me creating a new application uh and then finding all the the javascript files within the project and doing a line count 79 000 lines of javascript that's a lot of javascript and the thing is we we're we're using javascript uh for far more than just adding interactivity on web pages which is the world that brendan ike uh was was creating javascript for we're using it as build tools we're using it on the server we're using it on mobile devices we're using it all over the place but the weird thing is the way that we're using the language itself has changed quite a bit many years ago i guess when i first started using javascript it was quite simple you'd open up a text editor you'd write some javascript it would be served over http and exactly the code that you you had written would be executed within the browser that doesn't happen very often these days typically the code that you write will be transpiled it will be minified it will be bundled it will go through all kinds of really quite advanced transformations and by the time it lands in your browser it will look a bit like a garbled mess and that's led a few people to consider javascript to be the assembly language of the web it's it's a compilation target as well as the language we use uh to write our applications but this is where sorry move my cursor this is where the problems start to surface because javascript actually isn't a very good assembly language and it's no surprise again reflecting on the context within which it was invented in the first place it was never designed to be an assembly language it was never designed to be a compilation target and to understand why it's a bad uh compilation target why it's not a good assembly language you have to understand a little bit more about how javascript is executed within the browser so this is a diagram that i took from a a mozilla blog post where they were giving a a rough overview of how javascript is executed within the browser so the first bit on the lefthand side is a bunch of characters come along over http and they're parsed into a thing called an abstract syntax tree it's a it's a treelike representation of your code after that it it generates some by byte code which is then run within an interpreter and then this is where the really clever stuff starts happening many years ago that was it that was the way that javascript was executed these days a lot of work has gone into optimizing javascript so what will happen is the runtime will start to look at your code look at the execution and make certain assumptions if you've got a function that is always called with a pair of integers for example it will generate an optimized version of that and the execution of that function will become faster and i think it was the um safari browser has something like four different tiers of optimization and your code sort of moves up and down these tiers so as it as it can spot optimizations it moves up a tier but if the assumptions it makes about your code is false it has to push it back down again it's really really complicated and as you can imagine this isn't an efficient uh compilation target and how how does this actually manifest itself one of the things that as a javascript developer most of us or pretty much all of us are concerned about is the execution speed of our our code within the browser and there's the one of the most important things something that people have been focusing on a lot recently is is the time to interactive the time it takes to load all your code and actually start doing something and this is a timeline that i shamelessly borrowed from this fantastic blog post by lynn clark it's it's well worth the read she does an excellent job of describing why webassembly is needed but i'm just grabbing this diagram here this is a timeline that approximates the execution of javascript within your browser so the first thing it does is it has to parse your parse your javascript the next is it has to compile and optimize it and then potentially it will have to reoptimize it and then afterwards you've got a certain amount of execution and garbage collection the timeline you see here the the pass time the compile time the optimized time has a significant impact on how long it takes for your application to actually execute and be interactive so this is again why i'm saying that javascript isn't a good assembly language this isn't if you were designing it from scratch you wouldn't design it like this and i guess this this little quote here i think summarizes it quite nicely this is a quote from the team that created webassembly and they mentioned that the web has become the most ubiquitous application platform ever and yet by historical accidents the only natively supported programming language for that platform is javascript and this is coming from a bunch of guys who are uh web developers and they love javascript so it's not that they're not against the javascript languages itself but the the situation we've found ourselves is is a weird quirk of of history so that brings me onto webassembly if you look at the webassembly specification the webassembly website they describe it as a new portable size and load time efficient format suitable for compilation to the web so it was designed specifically to solve some of the problems i've been talking about now hands up if you've heard of asm js before okay that's that's good so an interesting part of the history of webassembly is quite tightly related to asm.js don't worry if you've not heard of it before it doesn't matter i'll give you a quick illustration of what it is and hopefully that will help you understand some of the design goals of webassembly so asmjs was a a bit of an experiment it was actually a bit of a wacky idea that was uh created by mozilla i think around about five years ago and at that point in time there were various other pluginlike technologies being uh considered in the standard plugin model is you take some other runtime and you kind of bolt it onto the side of the browser that's how that's how plugins worked and at that time there were other people considering other plugin style models whereas the mozilla team came up with this slightly crazy idea of why don't we create this sort of virtual runtime that sits within the javascript virtual machine so they said okay we need memory so we'll just have an array that can be our memory we need instructions so we'll create effectively patterns within our javascript that represent those instructions so i'll quickly illustrate what it is and then show you why that is a great demonstration of a slightly better way of doing things so here's a here's a bit of code this is some asm.js code don't don't worry too much about the detail at the top this is a a um a function written in c that does your standard fibonacci calculation i'm compiling it using a tool called m script and into asm.js and that's what you see at the bottom there so asmjs is javascript but it's a particularly peculiar looking kind of javascript i'll highlight a few things i won't go into all the details but the first thing you'll see here is the reassignment of the arguments to this function so a equals plus a so typically you'd use that to kind of coerce something to be a number b equals b or zero which means that it's exactly the same as it was previously these are type hints these are telling the runtime that one of these is a float and one is an integer you can see at the bottom it's returning plus c again you can see the pattern here that res in my c code is a float you can see that we've got in the javascript code a for loop asm.js doesn't support for loops here you've got a do while instead so that all looks a bit crazy and you might be asking why on earth would you do that getting back to the way that javascript executes within the browser you can see what they were trying to achieve with asm.js so what happens with within a browser that understands it well firstly if the browser doesn't understand asm.js it doesn't matter it's just plain old javascript and it executes as normal however if the javascript recognizes asm.js and it does that by looking at this use asm literal string at the top what it does is it starts doing the usual thing it passes it into an abstract syntax tree but then immediately it spots the patterns it effectively reads the asm.js assembly language and immediately is able to push it right up the um right up to quite a highly optimized version of the code skipping some of the quite timeconsuming interpreter steps and optimization steps so as you can imagine this is quite a neat idea but i think asm.js was only ever put together as a a technical proof of concept because one of the things they could never get around is the very first bit at the beginning the parsing the javascript language and as you can see it's asmjs is itself pretty verbose so as you can imagine parsing it to the abstract syntax tree has got quite a lot of overhead but asm.js was a great proof of concept that there might be a better way of doing things and their early demos were really quite impressive the m script and tool they use also had logic in it to convert opengl code into webgl code and they were able to take some game engines and do some pretty impressive things so asmjs pointed pointed people towards a a different and interesting approach to solving this problem which was quite different to the standard sort of plugin model as a result the webassembly working group was formed and it was formed in 2015 with with representation from all the main browser vendors and a bunch of others and quite impressively within the space of two years they managed to design their mvp scope for web assembly and and get it released in the wild so in november last year um it was turned on in all brows all major browsers without the need for flags so it's officially out there in the wild it's also in node version 8 and and beyond and just earlier this month w3c published their first public draft as well so they managed to get this done in a very short space of time and i think it was mostly because asmjs effectively created a blueprint to demonstrate some of the concepts here so i've talked a lot about webassembly but i haven't actually shown you any webassembly so i thought the best way to do that was to actually show some code and talk around the code just so you get a better idea of what it actually looks like in in real life so switching to code this is obviously where it all goes horribly wrong um okay so i'm going to start with a very very simple example this is a function that adds two numbers together and even though this is visual vs code that's actually c which is horrible and dirty and makes me want to wash my hands but there you go there's an add function and what happens is with my build my tool chain i'm not going to go into too much detail about that my tool chain is compiling that into webassembly and there are two distinct formats that you can use to view your web assembly the the obvious one is oh tiny tiny is in hex so the output of webassembly is a binary format so again uh recalling how javascript is is processed by your browser it no longer has to pass the characters into an abstract syntax tree it's a compact binary format but the more useful way of looking at it is the um actually they've changed the file extension for this it's the watt format web assembly text format it's a shame they didn't go for webassembly text format wtf as an extension that would have been awesome but anyway this is my c code so i'm adding two two numbers together and this is what it looks like as web assembly so a few little bits and pieces here we've got the concept of memory so memory within webassembly is very similar to the memory concept they invented with asm.js memory is a contiguous array of bytes and that memory is actually shared between the webassembly runtime and the javascript runtime so you can you can make rights to the webassembly memory from your javascript code it defines functions it's got a whole load of instructions there are about 60 odd instructions and it works as a stack machine if you've done any if you've done any programming with some kind of assembly language of some sort the full instruction set will look quite familiar to you webassembly can also export and import functions so you can export a javascript function from your webassembly module so you can export a webassembly function from your module and invoke it from javascript and vice versa you can import a javascript module so that it can be executed by your javascript so that's that's my web assembly and we've got the binary format and i'll show you how it's actually loaded instantiated and instantiated and executed now because i can't be bothered by with creating a html page to house this i'm just doing it within node but it's pretty similar within the browser so we're we're loading the webassembly binary format and we're constructing a module from it and then from the module we're creating an instance from the instance we can invoke the exported functions so here if i execute add it tells me that two add three equals five so here i've gone from javascript it's executed a webassembly function within the webassembly virtual machine and return the result that's all all pretty straightforward i'll show you now some of the areas where it gets a little bit tricky and now i feel like i'm showing you a bit of a tip of the iceberg in that it's not a simple case of just writing a whole load of code in webassembly um creating an api layer and invoking it from javascript at the moment it's relatively challenging to do that one of the reasons for doing that is that webassembly has a very small number of builtin types it only has four types and they're all numeric so it's got two floating points and two integer types what that means is if you want to do something with something a little bit more advanced like strings it gets quite complicated so my next little demo is just something which returns a simple string from my webassembly function and renders it from javascript so i'll just um pop back there okay so this is my c code so what i've done is i've created a a hellowasm string which is referenced as a character pointer and i've got a function which is get message ref so what that's doing is is returning the reference to the message if we look at the compiled output it's a little bit more complicated this time we've got these things called data sections within our webassembly module and these are basically ways of instantiating your webassembly module memory to a known state and here you can see it's actually writing hello wasm it's writing something else which i think is the offset to uh actually i'm not sure i'll have to check that it's writing something else and here is how it's actually executed within javascript and here you can see that simply by um changing it from an example based on integer types to strings things get a little bit more complicated so we've seen this bit of code before this loads our webassembly binary and instantiates a mod module but now to return the string the the get message ref function isn't returning a string it's returning an integer which is an index to the location of that string within linear memory so i'm having to get hold of a reference to my linear memory create a create a buffer and iterate over that buffer populating it with going by byte across my linear memory reading the data out and if i execute it and it does indeed say hello wasm and that's by all means not an exhaustive exhaustive demonstration of webassembly but hopefully it gives you a bit of a feel for how whether how you use a web assembly module from from within javascript and some of the current limitations that there are so a little bit more on the webassembly architecture so webassembly itself is a stack machine as i mentioned it has four builtin types 67 instructions importantly it's designed to support streaming compilation so there are some features that are specific to webassembly which reflect the context it's used within for the vast majority of use cases your code is being streamed over http so it makes sense that webassembly can be compiled in in a streaming fashion and what that means is your your browser is able to chop up the webassembly module and compile it in parallel on multiple threads so again it's been designed to be very very fast it all also has some very simple validation rules javascript and any other webbased language has a lot of validation rules that ensure security webassembly is just the same but again they've been designed in such a way that they can be processed and in serial as it's streamed in and as i mentioned before exports imports functions and has a concept of shared linear memory with javascript now one of the first questions that people ask when they look at webassembly is oh great this is going to be super duper performance it's going to be really really fast and i must admit i've read a lot of blog posts which makes some quite um quite impressive and to be honest quite incorrect claims about the performance of webassembly i've seen blog posts claiming that it's a hundred times faster than javascript unfortunately most of those blog posts suffer from the classic problem of doing micro benchmarking and either bench benchmarking the wrong thing as well so what i did was created a slightly more representative test case i created a a mandelbrot and rendered that using c javascript and a bunch of different mechanisms for for generating webassembly modules and i perfor i compared the performance of them and as you can see the black line here is the native performance so that's my c code uh compiled directly on my mac and executed natively and the interesting observation immediately is wow javascript is really really fast it's only about 20 slower rendering a mandelbrot and that's because of the many many years that's gone into compiler opt the runtime optimization for javascript disappointingly when i ran it within webassembly it was actually a little bit slower and using wasm assembly script and a few other different approaches i eventually through a number of optimizations managed to make it just a little bit faster than javascript so i must admit i was a little bit disappointed by that result i've had a look at other benchmarks and other results and most importantly the the paper that was published by the webassembly team the uh the accepted sort of general feeling is that web assembly should be around about 20 to 30 percent faster at runtime execution than javascript but because javascript is is really quite fast there are there isn't that much of a performance gain to be made where they expect webassembly to beat javascript significantly is the parse time and the initial compilation time so the time to interactive with webassembly should theoretically be a lot less than with javascript so in the future one of the things i mentioned was that webassembly was developed over a really quite short space of time and partly that was because they had asmjs as a kind of reference implementation another reason is the current webassembly release is very much an mvp they were quite aggressive about ensuring that they had a very small set of features so they could release quickly and the idea is that they're going to be releasing new features over the over the coming years so some of the things that it doesn't have at the moment is a garbage collector and i'll explain why that's a bit bit of a pain later on in the future it will also have threading support a thing called host bindings which is a way as i showed you the interface between javascript and webassembly is a little complicated at the moment and if you want to start doing dom manipulation from webassembly that's hard with host bindings in the future that will become a lot easier so one of the final things i want to look at is um web assembly language support and what some people are actually doing with the language so i showed you a little bit of writing a bit of c code as a way to show you what webassembly actually looks like the text format and so on but most people aren't going to write webassembly in its its machine code well in its binary format or in the text format most people are going to want to use a language maybe c maybe not rust go people are going to be using other languages and treating webassembly as a compilation target so i'm going to quickly look at the different languages and their current level of support so the first one is c or c plus plus and this is the the very first language that that gains webassembly support and again that's due to its heritage from asm.js there's a tool called mscrypton that you can use to compile c to web assembly and m script and does a lot more than just um a straightforward compilation it has as i've mentioned it's got the opengl to webgl bindings and it's got a whole load of other things that make it quite easy to take an existing c code base and compile it to webassembly and put all the glue that's required around it to actually make it work as i mentioned it was originally used to create the asm.js concept some of the practical things i've seen people do with it there's a there's a company that have a thing called ps pdf kit um it's basically a pdf renderer and um just last year they started exploring the use of webassembly so they've got a c plus code base and they explored the use of webassembly as a way of of using exactly the same code base to do pdf rendering on the web and they they found it quite a good experience they managed to create something which i think they're going to actually ship as a as a product and with very good performance this one's a fun one uh jsc so the javascript core which is the javascript machine that runs within within webkit is itself written in c plus plus now using m scriptin you can compile c plus to webassembly so what that means is you can take javascript core compile it to webassembly and then run it on top of your javascript virtual machine so what this is is um the the uh safari javascript virtual machine compiled to web assembly running on chrome which is great it's exactly what you need finally um one thing you'll probably notice here is at the moment a lot of people are essentially experimenting with this technology there aren't you won't find a huge number of really practical use cases yet i think that's still to come although where i work at scotlogic we've done a bit of work with a company called active financial and they provide they provide market data for people that need high frequency data so people that are doing um algorithmic trading for example and all of their distribution logic all their serialization logic is written in c and c plus plus and they've been getting a lot of requests from from their their clients who want to start using it consuming this data from within javascript either perhaps aws and a lambda function or perhaps within the browser so we help them take their c plus code compile it to webassembly and use exactly the same code to to to parse their packets of data and deliver their high frequency uh data to the web so that's something that we were able to achieve with webassembly uh oh that should say c sharp that's a mistake anyway so c c plus plus that's the story um java and c sharp these ones are a little bit more challenging because as you're i'm sure you're aware java and csharp are languages that both rely on garbage collection whereas c c plus you manually manage the life cycle of your objects and because webassembly doesn't have garbage collection yet that means it's a it's quite a a problem it's quite a challenge to take java and c sharp code and compile it to webassembly there's an experimental project called blazer that's become an official i think asp.net experiment which uses mono some of you may be aware of mono as a way to run java and csharp within webassembly and what they're doing is they're experimenting with a couple of different ways of doing it one of one of them is interpreted mode so they've basically taken the runtime and compiled it to webassembly and they're executing they're executing csharp dlls directly within the browser the other one is ahead of time compilation so they're actually compiling the dll directly to webassembly and they're they're experimenting with these two side by side blazer is a project that wraps around mono's webassembly support and it's a fully featured singlepage application framework so there's a lot of csharp developers getting quite excited about the potential of blazer i don't have anything practical to show on on csharp and blazer because it's very very new and i don't think anyone's done anything practical with it quite yet so i guess one of the final ones to talk about is is javascript so why why shouldn't you compile javascript to webassembly and then there's a lot of people writing react applications and all kinds of other based applications and and you look at the features you get with webassembly and you think yeah i'd like some of that i'd like my javascript to to pass more quickly to be optimized immediately so there are a lot of people trying to find creative ways to compile javascript to webassembly and obviously there are even more challenges there so firstly you need a garbage collector secondly it's not statically typed so you've got typing as a bit of an issue there are a couple of projects i've been keeping an eye on that are trying to tackle this first is called walt which is a javascript like syntax for webassembly so what they've done is they've taken that textbased format which i've shown you and tried to map it as closely as possible to javascript so it's it's a thin veneer on top of the webassembly text format the other one that i've actually had a bit of a go with is assembly script so in order to solve the typing issue that's pretty straightforward with javascript these days you've got things like flow and typescript that introduce typing so with typescript you can enforce typing of your code and use a very similar compilation path that you do for c and c plus and at the moment that project is is in its early stages and they're currently awaiting news of when garbage collection will appear within webassembly to make some fairly critical design decisions about how they how they tackle that i've actually got a bit of a demo uh hopefully i typed in the wifi password so has anyone used d3 before yeah cool yeah everyone loves d3 so this is a d3 force layout but what i've done is i've taken d3 force layout and taken all the algorithmic code and rewritten it using typescript and compiled it to webassembly so basically the um the standard sort of end body algorithm and the kind of hooks law spring concepts are all being computed here within webassembly using typescript and it was quite an interesting experiment for me to see how easy it is to take a a javascript application that wasn't written in typescript add type information to it and then compile it to webassembly and work out how to manage the interface between the two so actually if you scroll down uh if you scroll if i scroll down you can see it's got it it supports exactly the same api as d3 itself but all the computations being done in webassembly that that was good fun i enjoyed that actually i'm going one thing i'm going to do is i'm going to get rid of that demo because it's got a memory leak yeah i know the final one i want to briefly touch on is is rust um has anyone used rust here before no definitely the wrong room for that oh a few yeah so rust is is gaining popularity quite quickly if you ever have a look at the sort of metrics stack overflow does a survey every year and they do quite a lot of data analysis and rust seems to be a programming language that makes people really really really happy so it's a modern language it's a very very popular language significantly here it doesn't require a garbage collector it's got quite an interesting memory model that has the concept of ownership so every every object that's allocated on the heap is only ever owned by one reference at one point in time which makes it very very easy to reason about memory and clean up memory it's hard getting your head around it initially but it's a good concept so within rust what they did was they used the m script and tool chain and are actually investing time in creating some better tool chains and i found this quote actually from someone within the russ community who says we're poised to be the language of choice for for webassembly and the reason for that is it's a much loved language and because it doesn't need a garbage collector it's actually in a great position for for being compiled to webassembly right now so um i had a bit of a play with it myself i created a a chip 8 emulator so chip 8 is a a pretty old um engine for for playing arcade games i say engine it was it was one of the very first virtual machines actually it was developed by someone who at the time came up with a concept for a virtual machine for playing games that could then be incorporated into a number of the the current computers at the time it was a great idea it wasn't terribly successful but it's great for people who who want to experiment with creating emulators because it's actually quite a simple machine to emulate so for me this was great fun having a go at rust i'd not used rust before so trying to do rust write an emulator which i'd not do before and then compile that to webassembly that that kept me up a lot of nights but that was good fun but having said that um people are doing some really practical and useful stuff with rust and webassembly and again a lot of this is coming out coming from mozilla so in a very recent blog post um they've talked about some of the work they've done on source maps so source maps uh is if you if you're not aware of what source maps is source maps is a technology that allows you to map that highly mangled version of the code that runs in your browser to the source code that you created in the first place so source maps are a way of mapping from one representation of code to another and source maps as you can imagine quite computationally intensive but the most popular source maps uh library that supports um parsing and understanding source maps is all written in javascript and the team behind it decided to take some of the most performance critical logic rewrite it in rust compile it to webassembly and then evaluate the performance and you can see here one of the performance metrics they were looking at was the time it takes from setting a break point to be able to actually inspect your code so basically to be able to to pass i don't know if pause is the right word but understand the source maps and map the breakpoint back to your original code and as you can see here the webassembly performance i know the text is a bit small there at the bottom but the web assembly performance is these little blue clusters so a couple of observations the first one is clearly webassembly is is quite a bit faster in the order of two to three times faster but another interesting aspect here is the javascript performance you'll see quite a spread in performance and that is because again of the nature of the way that javascript is executed it goes through multiple tiers of of optimization where it might be optimized and then deoptimized and what that means is your runtime performance isn't terribly predictable whereas within webassembly the runtime performance is highly predictable in comparison so that was that was a fantastic blog post and a really interesting read and the interesting thing is even though this was done as an experiment and if they're happy with it if all the unit tests run they can put that in production now and everyone who uses source maps directly or indirectly is then going to receive the performance boost so finally um i want to do a bit of crystal ball gazing so as i've shown you that the current state of webassembly is is is variable depending on language and in terms of what people are doing with it again there's lots and lots of experimentation but now i think we're starting to see the signs of where it's actually going to be used in future and how it's practically going to be used so my prediction for 2018 is as you can imagine lots more creativity mostly coming out of of languages like rust but we're also seeing a lot of creativity with c sharp i have a feeling the swift community are going to be very very keen on this because swift has a lot of common attributes with rust it's a modern language it's quite a pleasant language to use and also using um arc ultimately yeah automatic reference counting it's got a memory model that's quite compatible with webassembly also within 2018 uh i don't know if you've noticed two days ago there was a new webpack release version four and that included webassembly support so webassembly as a top chain now allows you to import rust directly within your code and web assembly webassembly sorry webpack because it's magic will do its magic and the right thing will pop out the other end hopefully if you get your configuration right so yeah if you get configuration right it's great if it's not right then it's hell but um i also think that within 2018 you'll start to see webassembly sneaking into your daily workflow without actually knowing it so as i showed you right back at the beginning when i create a react application it adds 79 000 lines of javascript to my machine and most of that code is is being used at build time very little of it is actually being used at runtime i think that 79 000 is going to start going down as people start to use web assembly to hit performance critical parts of your of your tooling another thing i think you're going to start seeing is native node modules using webassembly i don't know about you but i find it quite frustrating that the workflow involved in using node modules that have native code there's a lot of friction there now there isn't a terribly good reason to do that anymore you can actually ship webassembly instead so 2019 within webassembly itself i'm pretty sure we'll start to see garbage collection host binding threading we'll start to see webassembly itself become a lot more powerful as a result c sharp and java some of the languages that require a garbage collector will become firstclass citizens of the sort of webassembly ecosystem i think we're also going to start seeing um wasm ui frameworks so we're going to start seeing ui frameworks that are targeted that are entirely written as web assembly and and and geared towards um perhaps csharp or java developers and we're already starting to see that i saw a project which was called asm dom which was a virtual dom so modeling the react concept a virtual dom written in c plus plus compiling the web webassembly whereas next year i think that'll actually start to become a practical option also i think we'll see more of our our general plumbing move to webassembly for example again using react as an example it does some computationally intensive tasks to do the dom diffing why not put that in web assembly uh others other frameworks for example there's a thing called the glimmer vm which is a templating engine which i is in one of the ui frameworks whose name i can't remember but i'm pretty sure that will move to webassembly as well interestingly though i think we're going to start seeing rust go swift and other languages start to gain some web market share you might think that's a good thing you might think that's a bad thing but i honestly think it's going to start happening 2020 and beyond again i'm going to go back to that quote the web has become the most ubiquitous platform ever yet historically by accident the only language that is supported by the browser is javascript i think in 2020 we're going to see that that being challenged um javascript will no longer be the only language of the browser and the web i also think people are going to start making significant progress towards compiling javascript directly to webassembly again for the very reason that javascript is a perfectly good language for writing web applications there's absolutely nothing wrong with it but at the same time as javascript developers start seeing rust developers and swift developers benefit from webassembly they're going to be wanting to get some of that as well my gut feeling is that the javascript language itself will start to move towards some of the typescript concepts to allow webassembly compilation if you've been following the way that typescript has evolved over time typescript has deliberately stayed on a relatively convergent path with the javascript language itself i have a feeling that some of these features typing for example might become a first class feature of javascript in order to allow us to compile to webassembly finally i guess it regretfully i do honestly think javascript's popularity will decrease a little bit is anyone going to throw anything at me quite yet now maybe leave it a little bit i'm a big javascript fan myself honest no but i do honestly think um javascript has got a monopoly at the moment and and the web platform is ubiquitous it i don't i think it's a safe bet that javascript will start to have a bit of a fight with some of these other languages but at the same time i think the reach of the web will increase even more so i think through progressive web apps so progressive web apps are currently talked about mostly within the context of mobile but progressive web apps make a lot of sense on the desktop as well so i think a combination of progressive web apps and the ability of webassembly to allow you to do computationally intensive complex operations will mean things like photoshop for example will become a progressive web app i think things like autocad the autocad team already are looking at webassembly i think the ubiquity of the web will increase or the ubiquity of javascript will and webassembly will increase and move more onto the desktop so yeah that that pretty much brings me to the end web assembly and the death of javascript and i'm going to say no it's it's not going to die but i think it's got a real fight in its hands and if you disagree you can start throwing things at me right now
