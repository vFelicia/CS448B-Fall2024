With timestamps:

00:00 - [Music]
00:02 - hey folks we are back again with another
00:04 - c plus plus audio tutorial today we are
00:07 - going to build this plug-in from scratch
00:08 - using modern c plus and the juice
00:11 - framework check the description for
00:13 - links to the repository and to download
00:15 - the final build okay what is this thing
00:18 - this is the little brother of my new
00:19 - audio plug-in and course for programming
00:21 - for musicians where you can learn to
00:22 - build these other plugins
00:25 - also where you can learn modern c plus
00:27 - and the juice framework taught from the
00:28 - context of writing audio software in a
00:30 - mentored environment
00:32 - in programming for musicians you are not
00:34 - following videos you are not watching
00:36 - someone else code and you are not
00:37 - copying them either you are coding it
00:40 - yourself from a design spec and i'm
00:42 - reviewing your work every step of the
00:44 - way
00:44 - alright enough about those let's learn
00:46 - about what we are going to build today
00:48 - this is a 3-band compressor audio signal
00:51 - is split into three discrete bands and
00:53 - compression is applied to each band
00:55 - separately
00:56 - the bottom of the gui contains the
00:58 - controls for the selected band you'll
00:59 - find standard compressor controls here
01:01 - attack release threshold and ratio on
01:03 - the right side you'll find buttons to
01:05 - mute solo or bypass an individual audio
01:07 - band these buttons are helpful for
01:09 - dialing in an individual compressor or
01:11 - hearing how it is affecting the overall
01:13 - audio signal the band select buttons are
01:15 - on the left these control which
01:17 - compressor is being controlled remember
01:19 - we have three of them
01:21 - in the middle of the gui are the global
01:22 - controls you'll find input trim on the
01:24 - left crossover controls in the middle
01:26 - and output trim on the right
01:28 - crossover sliders control where the
01:30 - audio is split into the 3-band
01:32 - the top portion of the gui features a
01:34 - spectrum analyzer which shows us what we
01:36 - are hearing where the crossovers are in
01:38 - the frequency spectrum and what our
01:40 - thresholds are set to as well as the
01:42 - current gain reduction per band at the
01:44 - very top of the gui you'll find the
01:46 - analyzer bypass button on the left this
01:48 - button turns off the fft analysis in the
01:50 - spectrum analyzer
01:52 - finally we have the global bypass button
01:54 - on the right which disables or enables
01:56 - all three compressors simultaneously we
01:59 - are going to learn to build all of the
02:00 - dsp that's going on in the background we
02:02 - are going to learn how to build this gui
02:05 - okay that's the feature set for this
02:06 - plugin and for this course my name is
02:08 - chuck i go by the name matcat music on
02:11 - youtube instagram and twitter once again
02:13 - check the description for links to the
02:15 - repository and where to download the
02:16 - final builds let's get started and write
02:19 - a multi-band compressor using modern c
02:21 - plus plus and the juice framework from
02:23 - scratch
02:23 - [Music]
02:31 - welcome to this tutorial teaching the
02:32 - simple multiband compressor if you
02:34 - happen to get stuck during uh any part
02:36 - of the setup or in the actual tutorial
02:39 - itself grab any free product from
02:41 - programming for musicians you will be
02:43 - sent an invite link to a slack workspace
02:45 - where you can send me a message directly
02:48 - i will help you get unstuck we can work
02:50 - on error messages if you have setup
02:52 - issues that sort of thing all right on
02:54 - with the show
02:56 - hey folks welcome to this tutorial
02:58 - documenting how to build this three-band
03:01 - compressor
03:02 - before we start building anything we
03:04 - need to have a working development
03:06 - environment that is what we're going to
03:08 - do first i'm going to show how to do
03:10 - this for mac and then how to do this for
03:13 - windows
03:14 - here is what we are going to accomplish
03:15 - in this first part of the course we're
03:18 - going to install the ide which could be
03:20 - xcode or visual studio we're going to
03:23 - clone the juice framework we're going to
03:24 - build producer create a project and then
03:26 - create a repository for the project
03:29 - then we're going to build and run the
03:31 - standalone app version of the project
03:33 - then we're going to set up audio plug
03:35 - and host we're going to configure the
03:37 - ide to launch audio plug and host
03:40 - whenever we build and run the project
03:42 - then we're going to configure audio
03:44 - plugin host so it can load our plugin
03:46 - and set up a filter graph so audio will
03:48 - run through our plugin then we are going
03:51 - to set up an audio file player so that
03:53 - we can actually play audio files through
03:55 - our plugin then we are going to
03:57 - configure audio plugin host to use the
03:59 - audio file player plugin to send audio
04:01 - into our plugin and out to our sound
04:04 - card if you are a windows user you can
04:06 - skip ahead to the time stamp shown below
04:09 - for your steps all right let's begin the
04:12 - first thing we need is xcode now i have
04:14 - already downloaded and installed xcode
04:16 - but if you haven't there are two ways
04:18 - you can get it number one is to get it
04:20 - from the app store just go here and
04:22 - search xcode oops
04:24 - search here xcode this is going to get
04:27 - the version that is
04:29 - the most recent version that is
04:30 - available for most people to get if you
04:33 - have an older computer the other way you
04:35 - can do it is to grab a
04:38 - apple developer account
04:40 - these are free you only need to pay for
04:42 - the account if you are code signing okay
04:45 - so
04:46 - if you don't
04:47 - um if you're not planning on signing any
04:49 - of your binaries you can just go to
04:51 - developer.apple.com
04:52 - developer.apple.com
04:56 - uh sign up for a free account
04:58 - and then
04:59 - uh sign on in
05:01 - all right once you are signed on in go
05:03 - to downloads
05:05 - click on more
05:08 - and then search for xcode all right
05:11 - you will see all of the versions of
05:13 - xcode that have ever been released
05:15 - xcode 11 12 13
05:18 - keep scrolling on down there's 11.7
05:22 - there's 11.4
05:24 - xcode 4.6.2 xcode 10 11.
05:29 - all that stuff so if you're running an
05:30 - older version of mac os and you cannot
05:33 - get um you cannot run xcode
05:36 - 12 or xcode13 this is what you can do
05:39 - we have successfully grabbed xcode and
05:42 - our next thing to do is to clone the
05:45 - juice repository
05:47 - navigate
05:48 - to
05:51 - juce github.comuce framework slash juc
05:56 - we are going to clone using fork which
05:58 - is a get gui
06:00 - you can grab that from
06:02 - https colon slash fork dot dev
06:07 - once you've got fork
06:08 - go ahead and launch it now we need to
06:10 - configure
06:11 - where fork looks for all of its
06:14 - repositories so go to the fork menu go
06:17 - to preferences
06:18 - and you're going to specify the default
06:21 - source folder in my case i am putting
06:23 - all of my code
06:25 - here in my users folder in a folder
06:27 - called programming okay
06:30 - once you've got that configured
06:32 - you can go
06:33 - back to we can close this we can go back
06:35 - to github we can copy this url right
06:37 - here click the green button for code um
06:40 - copy this url
06:41 - and then go to fork file
06:44 - clone it's going to automatically
06:46 - populate this url
06:48 - if it doesn't that's fine you can just
06:51 - paste it
06:52 - click clone
06:53 - now if fork if you're running an older
06:55 - version of mac os and it throws some
06:57 - kind of errors at you
06:59 - you need to install the swift runtime so
07:02 - again you can grab that
07:05 - you can grab that either you can grab
07:07 - that from the developer your developer
07:09 - account
07:11 - go to your account
07:14 - go to downloads
07:16 - search for more
07:18 - and swift
07:20 - somewhere in here is it here there it is
07:22 - swift's uh runtime support for command
07:24 - line tools this is what you need to
07:25 - install
07:26 - that will make fork run
07:29 - again this is only if you have an older
07:31 - version of mac
07:32 - juice has been around for like a decade
07:34 - or so i'm not quite sure how long um by
07:37 - default it checks out the master branch
07:39 - but the master branch
07:41 - there's quite a few commits
07:44 - that have happened between when the
07:46 - master branch was released and when the
07:47 - developer branch which contains the most
07:49 - recent fixes had its most recent commit
07:52 - push to it
07:53 - so we want to check out the develop
07:54 - branch so go ahead and double click on
07:56 - origin developer that'll check out a
07:58 - branch
08:00 - and now we've got the latest set of
08:03 - changes in producer
08:05 - all right our next step is to build
08:07 - producer which will create juice
08:09 - projects for us okay so just click open
08:12 - in finder your little button right there
08:16 - navigate to the juice
08:19 - extras folder
08:21 - the producer folder and the builds
08:23 - folder and then mac os x
08:27 - double click on the juicer file
08:33 - this is going to open up xcode if this
08:35 - is the first time launching xcode it may
08:37 - ask you to install
08:39 - it may ask you to install additional
08:42 - command line tools just click yes
08:46 - and then get it to this point all right
08:49 - i've already built this a few times
08:50 - because i was doing test runs in this
08:51 - video
08:53 - what we want to do is go to the product
08:55 - menu and choose build
08:57 - now we can watch what it's doing uh
08:59 - during the compilation process by
09:02 - clicking on this button right here of
09:04 - these buttons right here it's the
09:05 - rightmost one and just click on this and
09:08 - it will take us to this report showing
09:10 - us what is being compiled while it is
09:12 - being compiled
09:15 - we just need to wait for it to finish
09:17 - all right currently compiling
09:19 - gui basics linking signing there we go
09:22 - build succeeded all right we are done
09:23 - with xcode for right now go ahead and
09:25 - close the project
09:27 - all right navigate to the builds folder
09:31 - in the debug folder is where you will
09:32 - find the produced binary double click on
09:35 - this to launch producer
09:38 - producer is here
09:40 - now the first thing we need to do is
09:41 - turn on gpl mode if we go to file
09:44 - by default it might be on it may not be
09:46 - on
09:47 - choose sign in
09:49 - and select gpl mode now the next thing
09:52 - to do is to
09:53 - customize where the juice paths are
09:57 - because this was cloned to the
10:00 - to a location other than the users
10:02 - folder pro juicer is not going to be
10:05 - able to find the modules
10:07 - so go to the globalpaths menu choice
10:10 - under producer
10:11 - and we need to set our path to juice
10:14 - okay
10:15 - so that's over here
10:17 - and all we need to do is find our juice
10:19 - folder which in my case is in this
10:21 - programming directory
10:22 - matcap music programming there's the
10:25 - juice folder whoops
10:27 - mad cat music
10:29 - programming
10:31 - juice
10:32 - open
10:33 - all right now we need to do the same
10:34 - thing for the juice modules
10:37 - modules are found inside of the juice
10:39 - folder so
10:41 - we just need to navigate to that
10:43 - and then choose open again this is like
10:45 - programming
10:47 - juice
10:48 - modules
10:50 - okay once we've done that we're good to
10:51 - go here now we can create an audio
10:54 - plugin in the simple eq video there were
10:57 - a lot of comments of people who created
10:58 - an audio application
11:00 - we do not want an audio application we
11:02 - want to create a basic plugin
11:05 - okay
11:07 - the first thing to do is set the name
11:09 - we're going to do simple mb comp short
11:12 - for simple multiband compressor and
11:14 - click create project we just need to
11:16 - choose a valid place to save the project
11:18 - so i'm going to save it into my
11:20 - programming folder
11:22 - okay next we need to make sure that the
11:24 - plugin copy step is enabled so click on
11:27 - exporters click on debug and scroll down
11:30 - for the plug-in copy step
11:32 - make sure it is enabled
11:35 - all right the next thing to do is to set
11:38 - the c plus plus version to c plus 17.
11:41 - click this little gear icon for project
11:43 - settings
11:44 - and scroll down to the bottom
11:46 - and then up a little bit
11:48 - we can change the c plus plus language
11:50 - standard here change it to c plus plus
11:52 - 17.
11:53 - finally let's set the company name
11:55 - that's up at the top i'm going to put
11:57 - matcat music llc
11:59 - when we scan for plugins in audio plug
12:02 - and host
12:03 - this is
12:04 - our plug this is how our plugin will
12:06 - show up it will show up under the name
12:08 - of whatever we put here
12:10 - all right now we can click save and open
12:13 - in ide
12:14 - let's create a repository next
12:17 - let's go over to fork
12:19 - in fork we're going to choose file
12:21 - create new local repository
12:24 - and then we just need to pick this
12:26 - directory
12:28 - notice that there are a ton of files
12:30 - that are unstaged
12:33 - okay we need to customize the git ignore
12:35 - file for this project and we're doing
12:37 - this because we don't want any of these
12:39 - files that producer automatically
12:41 - generates every time we save the project
12:43 - to be stored in the repository again
12:45 - they're auto-generated so there's no
12:47 - reason for us to keep track of how they
12:49 - changed
12:50 - okay so right click on one of these
12:52 - files i'm going to right click on this
12:53 - builds directory and choose ignore
12:56 - custom pattern
12:57 - now i'm going to type some stuff here
12:59 - the first thing i'm going to type is
13:00 - star star slash builds
13:02 - that's going to ignore everything in the
13:04 - builds directory next i'm going to just
13:06 - type star star
13:08 - whoops star star
13:10 - juice
13:10 - library code that's going to ignore
13:13 - everything in the juice library code
13:14 - folder
13:15 - and then because this is mac i'm going
13:17 - to type star star
13:19 - dot ds store
13:21 - that's going to ignore the ds store
13:23 - files which are generated by mac os
13:26 - every time you customize the view of a
13:29 - folder
13:30 - all right add to git ignore
13:33 - now we only have six files
13:34 - awesome we've got our four
13:36 - source folders and our ignore file and
13:39 - then the juicer file for the project
13:41 - now we can stage these by clicking this
13:43 - button right here to stage all
13:47 - and now we can make our initial commit
13:50 - initial
13:51 - commit
13:54 - all right
13:55 - every time we click save and open in ide
13:57 - it's not going to produce new changes
13:59 - it's only when we change source code
14:01 - that it will do that
14:02 - all right we can go back to producer
14:05 - and we can choose save and open in ide
14:08 - let's build and run the standalone app
14:10 - version
14:10 - first of all change the scheme right
14:12 - here to the standalone plugin
14:15 - and then click the play button to build
14:17 - and run
14:19 - all right we can watch the build happen
14:22 - again go to the report navigator click
14:24 - on the entry with the spinning wheel
14:28 - all right build succeeded we're waiting
14:30 - for it to run
14:32 - this is the default audio plug-in
14:35 - that comes from producer running within
14:37 - a standalone plug-in app
14:39 - it is our job to customize the dsp and
14:41 - the graphics but let's not get ahead of
14:43 - ourselves
14:45 - we need to set up a test bed that we can
14:47 - use to run audio through our plug-in so
14:49 - let's set that up next
14:52 - go ahead and close this
14:54 - all right we can close this project as
14:56 - well
14:57 - close project
14:59 - if you uh were not aware i am doing this
15:01 - in a virtual machine that has nothing
15:02 - set up in it
15:03 - um that's just to show you if you've
15:05 - never done this before here's how you
15:06 - can get set up real quickly
15:08 - show me later never okay all right the
15:12 - first thing to do is to set up audio
15:14 - plug and host we need to navigate to
15:16 - that folder okay so users folder
15:19 - programming it's inside the juice folder
15:22 - it's under extras it's audio plugin host
15:25 - open up the juicer file
15:27 - save and open in ide
15:29 - and build it
15:31 - product build
15:34 - linking build succeeded okay close the
15:36 - project once building is
15:38 - complete we are going to configure our
15:41 - plug-in project to launch audio
15:43 - plug-and-host every time we use the vst3
15:46 - scheme all right we can close this
15:48 - juicer file let's go back to our simple
15:50 - multiband compressor
15:52 - and open this up
15:54 - all right we can make this full screen
15:56 - now
15:57 - go to the xcode project we're going to
16:00 - edit the vst3 scheme okay click on this
16:03 - guy to select it
16:04 - and now edit the scheme
16:08 - all right we're going to change the
16:09 - executable from none
16:11 - to audio plug-in host so choose other
16:15 - and we're going to search for audio
16:17 - plug-in host
16:20 - there it is
16:21 - click choose
16:23 - now let's see close this now we just
16:26 - need to run this and that's going to
16:27 - launch audio plug-in host
16:30 - well first it has to build the vst3
16:32 - version
16:33 - linking build succeeded okay launching
16:35 - audio plug-in host
16:37 - there's audio plug-and-host yes you can
16:39 - use my microphone
16:41 - okay the first thing we need to do is
16:43 - configure audio plugin host to load our
16:44 - plugin
16:45 - go to the options menu
16:48 - and click edit the list of available
16:50 - plugins
16:51 - we're going to scan
16:53 - all right so choose options
16:56 - and scan for new or updated vst3 plugins
17:00 - that's fine
17:03 - there's our compressor right there
17:04 - simple mb comp
17:05 - okay we can close this window
17:08 - now that our plug-in has been found we
17:10 - can load it into the filter graph so
17:11 - right-click select it from the pop-up
17:14 - again this is where you set your company
17:16 - name and there's your compressor now if
17:18 - we double click this
17:20 - it looks the same as the standalone
17:22 - version
17:23 - cool
17:24 - let's wire it up to the output
17:26 - go like this click right there
17:29 - click right there and drag that okay
17:31 - right now any audio that our plugin
17:33 - produces will go to the sound card
17:37 - all right now we're not going to hear
17:38 - anything because there's nothing feeding
17:40 - audio into our plugin so let's do that
17:42 - next and then the other thing is if we
17:45 - go to options we can change our audio
17:47 - device settings
17:48 - again i'm running this in parallels so
17:51 - it's using a virtual machine and the
17:53 - virtual machine devices okay
17:56 - let's set up audio file
17:58 - player next
18:01 - we can save this
18:03 - and we want to save this into our
18:06 - we want to save this with our project
18:09 - so let's see where's my documents full
18:11 - not documents we want to save this with
18:12 - our programming programming simple
18:14 - multiband comp this is like um
18:18 - simple mb comp test
18:21 - testbed
18:22 - cool that'll work
18:24 - we can quit audio plug-in host for now
18:28 - in the previous tutorial video that i
18:30 - created the simple eq tutorial i used
18:32 - apple's au audio file player let me show
18:35 - you what that looks like let me see if
18:36 - that's even on here
18:38 - hey i just wanted to interject i'm
18:40 - editing this video the next day
18:42 - the au audio file player does show up on
18:45 - a default installation of mac
18:48 - you just need to scan for audio units
18:50 - and it will be there
18:52 - so if i do that then i can scan and
18:53 - it'll show up under apple
18:55 - au audio file player
18:58 - there it is okay this is what i used in
19:00 - simple eq all right i just wanted to let
19:02 - you know that this stuff does come on
19:04 - here if you do
19:05 - have um a fresh install of the operating
19:08 - system you do not need garageband and
19:09 - you do not need logic to access this
19:12 - this comes with the operating system
19:15 - this time we're going to use the audio
19:16 - file player plugin that i created this
19:19 - plugin is a port of the juice audio
19:21 - playback demo app to work as an audio
19:23 - plugin the demo app if you're curious
19:25 - you can go to file
19:27 - open example audio audio playback demo
19:30 - and this is an actual audio application
19:32 - so what i have done is i have ported
19:34 - this into an actual plugin that you can
19:36 - use in your daw in audio plug and host
19:40 - on mac and windows to handle all of
19:42 - these playback duties so we need to go
19:44 - grab this let's close our project for
19:45 - now it's close we're not going to close
19:48 - that
19:49 - we need to go grab it so let's open up
19:51 - our browser we're going to navigate to
19:53 - github.com
19:55 - mathcat music slash audio file player
19:59 - this is what we need to clone so click
20:01 - on the code button copy it and then
20:04 - clone it in fork file clone
20:08 - paste that url and let's clone it all
20:11 - right successfully cloned
20:12 - now we need to compile it open in finder
20:15 - let's go to our audio file player
20:18 - audio file player.juicer save and open
20:20 - in ide it's going to launch xcode we
20:23 - just need to build it and it's going to
20:24 - build um all of these it's going to be
20:26 - able to the standalone version the vsd3
20:28 - and the audio unit build
20:35 - all right cool once it's built um we
20:36 - should be able to launch audio plug and
20:38 - host and uh
20:40 - be good to go so close this project we
20:43 - can close audio let's not close it yet
20:45 - because we may need to um
20:46 - do it again let's open up our simple mb
20:48 - comp
20:49 - all right let's run it and now we are
20:51 - going to scan
20:53 - for audio file player
20:55 - all right options menu edit the list of
20:57 - available plugins
20:59 - options scan for new or updated vst3
21:03 - scan
21:05 - there it is audio file player perfect
21:09 - close this window
21:10 - right click mat cat music my company
21:13 - name audio file player
21:15 - here's the audio file player
21:17 - double click it to view the gui
21:20 - now we just need to wire up the outputs
21:22 - of this
21:23 - uh to the inputs of our simple multiband
21:25 - compressor
21:27 - now let's just add an audio file we can
21:29 - either drag one in or
21:32 - select something from here
21:34 - and if it prompts you to grant
21:36 - permission uh to the desktop and the
21:38 - documents folder in the music folder
21:39 - just click accept
21:41 - that's all it's you know mac security
21:43 - stuff let's press play to hear the audio
21:46 - file
21:50 - awesome there we go let's push stop
21:53 - all right save the filter graph
21:56 - now audio plug and host is configured
22:00 - every time we run the vst 3 version of
22:02 - the project audio plugin host will
22:04 - launch and it will load our plugin and
22:06 - it will load this audio player let's go
22:08 - ahead and quit this
22:10 - and show what i mean
22:13 - we run this
22:14 - it's gonna launch there's our audio file
22:16 - player plug-in and we can just stream
22:18 - audio right into the plug-in
22:21 - all right perfect
22:22 - we are ready to start coding up this
22:24 - plug-in mac users you can jump to the
22:27 - time stamp shown below
22:29 - to start
22:30 - the tutorial that actually codes up the
22:32 - plugin windows users we are going to
22:34 - cover setting up your system next
22:41 - all right windows users
22:43 - as a reminder i am using windows 10
22:46 - inside of a virtual machine on my mac i
22:49 - am doing this to show
22:50 - uh how to get started using a relatively
22:53 - fresh and clean operating system
22:54 - installation and also because i love the
22:57 - pain of using windows 10 in a virtual
22:58 - machine
23:00 - sad face okay ah let's dive in the first
23:03 - thing we need to do is grab visual
23:05 - studio community from the website
23:07 - not visual studio code but visual studio
23:10 - we can get the community edition just go
23:12 - up here
23:13 - and just google for it
23:15 - visual studio community
23:18 - all right we want the 2019 community
23:20 - edition go ahead and download it
23:23 - once you have that then resume this
23:25 - video okay once you have the installer
23:28 - downloaded go here
23:30 - and run the installer
23:32 - and we need to configure it to build c
23:34 - plus plus apps if you already have
23:36 - visual studio installed
23:38 - but you're using it for javascript or c
23:41 - sharp or something else but you don't
23:43 - have c plus plus installed
23:45 - run the installer and
23:47 - set it up the way i'm about to show you
23:48 - once this thing launches in
23:50 - 10 minutes so we have this here uh
23:53 - visual studio community 2019 click the
23:56 - modify button and what we want to do is
23:59 - set it up for c plus development so go
24:01 - to here desktop development with c plus
24:04 - make sure that's enabled and what you
24:05 - want to configure um you're going to
24:07 - want clang tools
24:09 - you're going to want the address
24:10 - sanitizer you're going to want
24:11 - intellicode you uh we don't need live
24:13 - share we don't need test adapter for
24:15 - google tests we do not need boost.test
24:18 - we need a latest
24:21 - we need the latest v142 build tools we
24:24 - need we don't need cmake we need the
24:26 - profiling tools we need the just in time
24:28 - debugger
24:29 - we need this guy and we need this guy
24:33 - all right so set your thing up so that
24:35 - way it's got these
24:36 - and then
24:37 - um just click install while downloading
24:40 - all right once everything is installed
24:41 - you can quit visual studio the next step
24:44 - is to download the juice framework or
24:47 - sorry not download but clone the juice
24:49 - framework okay we always want to clone
24:51 - it so we have access to the repository
24:53 - history so the first thing we're going
24:55 - to do is we're going to use fork which
24:57 - is the get gui to interact with this
25:00 - repository so you can get that if you
25:02 - open your browser you can grab that from
25:05 - fork.dev it's available for mac and for
25:08 - windows okay
25:09 - so you can go ahead and grab it here
25:12 - download fork for windows okay once
25:14 - you've got fork installed we need to
25:17 - configure it to store everything
25:20 - um
25:21 - in our preferred location any
25:22 - repositories that it clones all that
25:24 - sort of thing
25:25 - launch fork go to the file menu
25:28 - go to preferences and we need to specify
25:31 - the default clone folder
25:33 - i like to keep things in a folder called
25:35 - programming i have it right here on my
25:37 - desktop you know i could move it
25:38 - somewhere else but for the sake of this
25:40 - tutorial it's right here on the desktop
25:42 - so i just navigate to that you know
25:43 - click this folder button
25:46 - find where i'm going to put it basically
25:48 - anything that i'm going to clone is
25:49 - going to go there so i'm going to put it
25:50 - on the desktop programming like that
25:54 - select folder okay now anything that i
25:56 - clone is going to go into that folder in
25:58 - its own repository now we need to
26:00 - navigate to the juice framework and get
26:03 - the url for that so open up your browser
26:05 - open up a new tab then visit
26:09 - com github.com
26:10 - juice dash framework
26:12 - w-o-r-k
26:14 - j-u-c-e in all caps
26:17 - here's the juice framework now we need
26:19 - to click this code button right here
26:21 - click the copy button and go back to
26:24 - fork and now we can do file
26:26 - clone
26:28 - it's going to auto populate this
26:29 - repository url and it's going to save it
26:32 - into the programming folder that we
26:33 - requested click the clone button and you
26:35 - will be downloading a copy of the juice
26:38 - repository to your computer
26:41 - okay cloned alright perfect
26:44 - now we have a copy of juice on our
26:46 - computer the next thing to do is to
26:48 - build the producer which creates juice
26:49 - projects for us but before we do that
26:52 - juice is a pretty old framework by
26:54 - default the master branch or main branch
26:56 - is checked out
26:58 - however there have been several commits
27:02 - since the
27:03 - most recent branch oh spinning wheel a
27:07 - lot of things have been fixed in the
27:08 - juice framework since the master branch
27:10 - was last updated so we want to check out
27:12 - the develop branch okay so just double
27:14 - click right on origin slash develop and
27:16 - then it will prompt to create a branch
27:19 - and track the remote branch click the
27:21 - track button now we can open up producer
27:24 - and build it okay so click on this open
27:27 - in
27:28 - button right here and choose open in
27:29 - file explorer
27:31 - now we need to navigate to the extras
27:34 - pro juicer
27:36 - navigate to builds
27:38 - visual studio 2019
27:40 - and then we're going to open up this
27:42 - solution file
27:43 - we can just go to the build menu and
27:45 - choose build solution
27:47 - this is going to build producer for us
27:49 - now we just need to wait for it to
27:50 - finish compiling all right build
27:53 - succeeded fantastic
27:55 - we can close the visual studio project
27:57 - now now we can create a plug-in project
27:59 - next
28:00 - navigate to the x64 folder
28:04 - click on debug click on app and now
28:06 - we're looking for producer.exe
28:13 - there it is
28:14 - all right double click it to launch
28:17 - now if this is the first time you are
28:19 - using producer it's going to ask you to
28:21 - sign in we want to turn on gpl mode if
28:24 - this is not the first time you've
28:25 - probably already set it up but normally
28:27 - what you will see you'll go to the file
28:29 - menu you will choose sign in it'll show
28:31 - this thing you can if you have a juice
28:33 - account you can set that up or you can
28:36 - enable gpl mode now gpl mode has the
28:38 - requirement that we make our projects
28:40 - open source so
28:43 - uh yeah make your project open source
28:45 - okay
28:46 - in the simple eq project a lot of people
28:48 - left comments that they created an audio
28:51 - application or they were missing
28:53 - um they were missing the plug-in
28:55 - processor file
28:57 - and that's because they created an audio
28:58 - application instead of a plug-in
29:01 - instead of a basic plug-in so for this
29:03 - you definitely want to make sure you are
29:05 - definitely going to want to make sure
29:07 - that you choose plug-in category and
29:09 - that you choose basic
29:11 - all right first thing that we need to do
29:14 - we need to give it the name
29:16 - simple mbcomp
29:18 - and then create project oh i'm sorry
29:20 - before you do that
29:22 - if producer says you need to set your
29:25 - paths because you had downloaded juice
29:28 - to a directory that's not the standard
29:31 - directory it's expecting
29:32 - go here under the file menu go to global
29:35 - paths and then customize these paths
29:37 - here this is what i'm talking about
29:39 - when you
29:41 - install it to the default location it's
29:42 - expecting juice to go
29:44 - in a folder on the root level of your
29:46 - hard drive
29:47 - so obviously i put mine in this
29:49 - programming folder on the desktop so
29:51 - that is not where my juice folder is and
29:53 - that is not where the modules folder is
29:56 - so i'm going to click these three dots
29:57 - i'm going to choose the juice folder
30:00 - and then select folder and i'm going to
30:02 - do the same thing for the modules
30:05 - the modules folder
30:06 - select folder
30:08 - and i can close this window now all
30:10 - right now i can create this
30:13 - all right i want to put this in my
30:14 - programming folder with juice and the
30:17 - other stuff i've made
30:19 - this is going to create the project the
30:21 - next thing that we need to do is enable
30:23 - the plugin copy step this is going to
30:26 - copy the plugin when we compile it to
30:29 - the
30:30 - folder that
30:32 - most
30:33 - hosts you know reaper cubase ableton
30:36 - they're all looking for plugins in this
30:38 - one folder so this is going to enable
30:40 - copying it there automatically
30:42 - in this view click on exporters click on
30:45 - debug scroll down to the scroll down a
30:47 - little bit and you'll see where it says
30:49 - enable plug-in copy step
30:52 - make sure this is set to enabled all
30:54 - right we'll figure out where this
30:56 - actually gets copied to in a little bit
30:58 - next we need to um
31:01 - change the c plus version so go up here
31:04 - go to
31:06 - let's see this is down at the bottom of
31:07 - this list okay scroll all the way to the
31:09 - end then scroll up a little bit and
31:11 - change the c plus plus language standard
31:14 - to c plus plus 17.
31:17 - all right next we want to
31:20 - supply our company name
31:22 - so let's do that first i'm going to type
31:24 - mine matcat music llc
31:27 - when we scan for the plugin in audio
31:30 - plug-in host
31:32 - whatever we put here is the
31:34 - name that it's going to appear as it's
31:36 - going to show up as a sub menu under
31:38 - this name right here
31:40 - okay
31:41 - we may or may not need to set this using
31:44 - namespace juice so we'll come back to
31:46 - that first thing we're going to do is
31:49 - we're going to save and launch this
31:52 - save and open in ide this is going to
31:55 - launch visual studio
31:57 - we're going to find out whether or not
31:58 - we need to turn on that
32:00 - using namespace juice so go to the build
32:02 - menu
32:03 - and we're just going to try to build
32:04 - this real quick rebuild solution
32:07 - and if we get any errors about namespace
32:09 - stuff then we will turn that on
32:11 - let's see what happens
32:13 - okay cool all right so the copy step
32:15 - failed but we don't have any error
32:17 - messages relating to the namespace juice
32:20 - let's do the next thing which is to
32:22 - create a repository for our project
32:24 - first and then we will deal with this
32:25 - copy step all right we can close this
32:27 - for now
32:29 - okay to create a repository open fork
32:32 - and then do file
32:34 - init new repository and choose the
32:36 - simple mbcomp folder for the project
32:40 - now you'll notice that there are a ton
32:42 - of files here
32:44 - um listed under under local changes so
32:47 - we need to customize the get ignore file
32:49 - for this project and ignore all of this
32:51 - stuff the reason we are doing that is
32:53 - because all of this stuff gets created
32:56 - automatically by producer whenever we
32:58 - save
32:59 - and
33:00 - whenever we save and open in ide or when
33:03 - we compile like you'll see there's all
33:04 - these object files and stuff so we want
33:07 - to right click
33:08 - choose ignore custom pattern
33:12 - star star and for this we're going to
33:14 - type star star slash
33:17 - builds
33:19 - then
33:20 - and what this is going to do is it's
33:21 - going to ignore all of the files that
33:23 - are in the builds directory
33:25 - we want to do the same thing for juice
33:27 - library code so star star slash
33:29 - juice
33:30 - library code
33:33 - like that now if for some reason we want
33:35 - to migrate this project over to mac
33:38 - it's very handy to add star star slash
33:41 - dot ds store that's going to ignore any
33:45 - ds store files on mac
33:47 - these files control how the
33:51 - finders view
33:52 - looks basically if it's showing icons or
33:54 - if it's showing a list or if it's
33:56 - showing um
33:58 - if it's arranged by name or if it's
33:59 - arranged by day created that sort of
34:01 - stuff that information is stored in
34:03 - these ds store files okay add to git
34:05 - ignore
34:06 - you can see we only have the four source
34:08 - files our git ignore file and the juicer
34:11 - file
34:12 - now we can make our initial commit let's
34:13 - stage these by clicking the stage all
34:15 - button
34:16 - and now
34:17 - committing them initial
34:20 - commit
34:24 - now we can save and open in ide go ahead
34:27 - and go back to visual studio
34:29 - save and open in ide this will launch
34:31 - visual studio one more time
34:34 - okay on the right side is the solution
34:36 - explorer we want to right click on the
34:39 - standalone plugin
34:42 - and choose
34:43 - set as startup project
34:45 - okay now we can build and run it by
34:48 - clicking on this local windows debugger
34:51 - let's see if this throws an error with
34:53 - regard to the
34:54 - copy step or not it shouldn't because
34:56 - we're not spawning the copy stop version
34:59 - we're not spawning the vst3
35:01 - this is the default audio plugin from
35:04 - producer okay it is running inside of a
35:08 - standalone app
35:10 - that is part of the juice framework that
35:12 - hosts this okay it is our job to
35:15 - customize the dsp that runs on our
35:16 - plug-in as well as the graphics let's
35:18 - not get ahead of ourselves though we
35:20 - need to come up with a test bed so that
35:22 - we can actually run audio through our
35:25 - plug-in that's what we're going to set
35:26 - up next all right close that
35:29 - close this
35:31 - let's go set up audio plugin host
35:34 - navigate to your juice directory
35:38 - navigate to extras navigate to audio
35:41 - plugin host
35:42 - navigate to the juicer file and open it
35:45 - up in producer
35:48 - save and open in ide
35:52 - build it build the solution
35:56 - okay
35:57 - build one succeeded zero failed awesome
36:00 - all right we're done with audio plug and
36:01 - host
36:02 - okay
36:03 - we can close the juicer file as well
36:06 - all right let's configure audio plugin
36:08 - host to launch whenever we have the vst3
36:10 - as to startup project
36:12 - right click on the vst3 target
36:15 - go down to properties
36:17 - navigate to where it says debugging
36:20 - we're going to change this command so
36:22 - click on this arrow
36:24 - go to browse and we're going to look for
36:27 - audio plug and host
36:30 - all right got that
36:32 - build simple me comp navigate to the
36:35 - juice folder
36:37 - navigate to the extras folder audio
36:39 - plugin host
36:40 - builds
36:42 - visual studio 2019
36:44 - x64
36:46 - debug
36:48 - app
36:49 - and now audiopluginhost.exe
36:52 - click apply and okay
36:56 - now we need to change the target from
36:58 - standalone to vst3
37:00 - change that to the startup project
37:03 - and now if we build and run it's going
37:05 - to fail on that copy step like we saw
37:07 - earlier let's do it anyway all right
37:10 - copy step failed it's trying to copy to
37:13 - common programs
37:14 - wherever this thing is okay so we what
37:17 - we need to do is change the permissions
37:20 - of this folder
37:23 - to allow
37:24 - the current user
37:26 - which is you know whoever we are logged
37:28 - in as we need to give them write
37:29 - permission to this folder so open up
37:32 - explorer
37:34 - this is located in the c drive program
37:38 - files common files this is where
37:40 - um
37:42 - x this is where visual studio is trying
37:44 - to copy this file to so
37:46 - right click create new create a folder
37:50 - call it vst3
37:52 - and then the second part of this is to
37:54 - change the permissions so that the
37:56 - logged-in user
37:57 - can write to this folder because visual
38:00 - studio is being
38:01 - run under that user's settings okay so
38:05 - right click on this
38:06 - go to properties
38:08 - go to security
38:09 - click on edit to change the permissions
38:12 - and then we need to change the
38:14 - permissions for the user
38:17 - to be able to modify
38:19 - all right apply
38:20 - okay
38:21 - okay
38:22 - all right let's try this one more time
38:24 - let's see if it throws an error or not
38:29 - okay cool copy step completed if we go
38:32 - back over here
38:34 - let's see where was that let's just
38:35 - press stop real quick if we go to the
38:37 - build
38:39 - and scroll to the top we can see that
38:40 - one file was copied correctly
38:43 - all right let's go ahead and launch this
38:46 - now we need to scan for our plugin
38:49 - so choose options edit the list of
38:51 - available plugins
38:54 - and now this is where we need to scan
38:56 - all right so i've already done this scan
38:58 - before but i'm going to clear this list
38:59 - and now i'm going to scan for new or
39:02 - updated vst3 plugins
39:05 - right like i said it's looking for
39:07 - program files common files vst3 scan
39:11 - all right here's our plugin
39:14 - okay now we can load it into the filter
39:16 - graph
39:18 - right click
39:19 - go to your company name
39:21 - and here's your plugin if we double
39:23 - click on it it looks identical to the
39:25 - standalone version we saw earlier okay
39:28 - let's wire it up to the outputs
39:31 - just click and drag
39:34 - and we're not going to hear anything
39:35 - because there's nothing feeding audio
39:37 - into our plug-in and thus going to the
39:39 - speakers let's fix that next
39:42 - go ahead and
39:43 - we can save this and add it to our
39:44 - repository choose file save
39:47 - and let's see
39:49 - let's add this to our repository desktop
39:52 - programming simple mbq
39:55 - and then we can say this is the um
39:58 - oh it's called simple mb comp
40:02 - filter graph
40:04 - now we'll get the extension
40:08 - save all right we can close that let's
40:12 - make a commit that we added this
40:14 - added filter graph
40:19 - go ahead and stage that
40:21 - commit that all right
40:23 - we are going to set up audio file player
40:25 - so that we can run audio files through
40:27 - our plugin
40:30 - go ahead and close this project
40:32 - okay
40:33 - in the previous tutorial video that i
40:35 - created i used apple's au audio file
40:39 - player to run audio files through the
40:41 - simple eq
40:42 - windows users did not have a plug-in
40:44 - like that at their disposal and i saw a
40:46 - lot of comments in
40:49 - in the comments section of that video
40:52 - about that like people were just like
40:53 - hey what's the windows equivalent to
40:55 - this so this time we're going to use the
40:57 - audio file player plug-in that i created
41:01 - this plug-in is a port of the juice
41:02 - audio playback demo app
41:05 - it has been ported to work as a
41:07 - audio plugin so you can see that project
41:10 - if you want if you go to open example
41:12 - audio audio playback demo
41:14 - this is what this guy well we're not
41:16 - going to look at that right now but if
41:18 - you want to check it out just load that
41:20 - up um save it build it you know what to
41:23 - do because you know you've already done
41:25 - it a few times with producer and
41:28 - uh this project and with audio plugin
41:29 - host okay let's go get this thing all
41:32 - right open up your browser
41:35 - navigate to github
41:38 - dot com slash mat cat music
41:41 - slash
41:42 - audio
41:44 - let me spell that right audio file
41:47 - player
41:49 - okay now we want to grab the code from
41:51 - this
41:52 - copy
41:53 - we're done here
41:54 - in fork we want to clone
41:59 - all right it's already populated for us
42:01 - clone it
42:03 - all right let's open it in finder or in
42:06 - file explorer
42:07 - okay open up the juicer file
42:10 - save and open in ide
42:15 - now we just need to build it
42:17 - build solution
42:19 - this should also copy the vst3 to that
42:22 - folder
42:23 - let's see what it does
42:25 - may need to change the build target
42:28 - creating library one file copied
42:31 - okay that should be okay
42:33 - all right let's close this
42:36 - now we can go back to our project let's
42:38 - close audio file
42:39 - player the juicer file close that guy
42:42 - and we can also close this repository we
42:44 - don't need that anymore
42:46 - all right go back to our simple
42:47 - multiband comp
42:49 - let's load up xcode let's launch it and
42:51 - then we will configure audio plugin host
42:54 - to use it
42:56 - go ahead and run it
42:58 - now we need to scan for our plugins one
43:00 - more time because we just compiled the
43:03 - new one so go to the options menu edit
43:05 - the list of available plugins
43:08 - options scan for new or updated threes
43:13 - scan
43:14 - there is our audio file player so
43:17 - we can right click here
43:19 - mat cat music llc that's the name it's
43:21 - going to be under and then choose audio
43:23 - file player
43:26 - and here's our plugin
43:28 - all right this is what's going to play
43:29 - the files
43:30 - we just need to wire it up
43:33 - we've got our instance
43:35 - in the filter graph
43:37 - okay let's add an audio file um i've got
43:40 - one on the desktop
43:42 - it's this guy right here
43:44 - let's start that over
43:52 - all right perfect
43:53 - let's save the filter graph
43:56 - save
43:57 - all right we can close this
43:59 - what's great about this is that every
44:01 - time we launch this project
44:04 - it's going to load that audio file
44:06 - automatically for us we're not gonna
44:08 - have to you know go find the audio file
44:11 - every time
44:12 - we relaunch audio plug-in host that's
44:14 - the problem that existed in the earlier
44:16 - version of this plug-in that i had which
44:18 - i
44:19 - that plug-in was just a band-aid fix
44:21 - when i first created this simple eq
44:23 - tutorial for the windows users because i
44:25 - didn't realize that they would have this
44:26 - problem i have since fixed that so that
44:29 - it now
44:32 - it now shows you
44:34 - it now remembers what file you had
44:36 - loaded so if we go ahead and launch this
44:38 - again
44:40 - there's our file and if we press play
44:45 - gonna work as expected
44:47 - so that's fantastic all right we'll put
44:49 - this guy over here
44:51 - audio plugin host is configured and um
44:53 - we have set up our project so that way
44:55 - every time we have the vst3 version set
44:58 - as the startup project it's going to
45:00 - launch audio plug-in host and we'll have
45:02 - a
45:03 - real easy time of you know debugging our
45:05 - plug-in and adding features to it and
45:08 - being able to run audio through it using
45:09 - audio plug-in host
45:11 - now we are ready to start coding our
45:13 - plug-in
45:16 - now we will be reusing and modifying
45:18 - some elements from the simple eq
45:20 - tutorial that i made for free code camp
45:22 - if you haven't completed that tutorial i
45:26 - recommend that you pause this video and
45:28 - start watching that one i'm not going to
45:31 - explain how the things we are reusing
45:33 - were created if you want that
45:35 - information you can watch that video
45:37 - where all that stuff is explained okay i
45:39 - will be explaining the modifications
45:41 - that we will be making to those classes
45:43 - though so with that said let's begin
45:46 - building this simple multiband
45:48 - compressor
45:51 - let's survey the lay of the land before
45:54 - we start writing any code
45:56 - also thanks to everybody who watched
45:58 - simple eq and said i looked like
46:00 - guilfoyle i had never heard of that show
46:02 - silicon valley before i started checking
46:04 - the comments for that video and
46:08 - that's good times okay number one there
46:10 - are several important parts to any audio
46:13 - plugin the first one is the dsp code
46:16 - itself
46:17 - this code is responsible for the actual
46:19 - audio that we hear we are responsible
46:22 - for making it fast and efficient
46:25 - number two is the audio parameters these
46:28 - control the various parts of the dsp
46:31 - code
46:32 - examples include the filter frequency or
46:34 - the pitch of a node being played by a
46:36 - synthesizer for example
46:38 - if we were writing a reverb plugin
46:41 - we might have a parameter that controls
46:42 - the reverb time
46:45 - in dsp programming it's all state-based
46:48 - programming we are constantly updating
46:50 - the state of our dsp based on math that
46:53 - modifies the audio signal in some way
46:56 - for example when we filter audio
46:59 - we keep track of the previously filtered
47:01 - samples these samples which are known as
47:04 - the previous filter output
47:06 - get added to the incoming samples after
47:08 - being scaled with some coefficient
47:11 - the newly filtered samples become the
47:13 - previous filter output for the next time
47:16 - that we process incoming samples
47:19 - number three preparing our dsp before we
47:22 - start processing anything with it
47:25 - before we can run audio through our dsp
47:27 - we need to configure some basic
47:29 - information about it the number of
47:31 - samples we're going to be processing the
47:33 - sample rate we will be processing those
47:35 - samples at and the number of channels we
47:38 - will be processing for example we might
47:40 - have a stereo feed which is two channels
47:43 - we might have a mono feed which is one
47:45 - channel or we might even have a dolby
47:48 - 5.1 which is six channels
47:50 - now if you are unfamiliar with the
47:52 - concept of sample rate
47:54 - there are numerous videos on youtube
47:57 - that explain how digital audio works
47:59 - let me grab my whiteboard
48:02 - so i'm reading my script over on this
48:03 - side so bear with me as a brief overview
48:08 - the audio we hear with our ears is an
48:10 - analog signal like this graph that i've
48:12 - got drawn here
48:14 - our eardrums detect changes in air
48:16 - pressure and they convert that change
48:18 - into an electrical signal which gets
48:20 - turned into
48:22 - sound
48:23 - by our brain
48:24 - this signal this graph that i've got
48:27 - right here this is a graph of the
48:29 - changes of the air pressure it is
48:30 - continuous
48:32 - if we uh take this signal right here if
48:34 - we were to continually zoom in on it
48:37 - like i've got down here on the bottom
48:38 - part if we continually zoom in on it
48:41 - it's always going to appear smooth
48:43 - okay now on computers
48:46 - that's not the case computers on the
48:48 - other hand
48:49 - operate using ones and zeros
48:51 - like i was saying computers operate on
48:54 - ones and zeros what this means is that
48:56 - the computer has to sample this smooth
48:58 - audio signal at a specific rate
49:01 - and produce an approximation of this
49:04 - smooth audio signal the more frequently
49:06 - that the signal is sampled the smoother
49:08 - the approximation becomes
49:10 - as an example let me use this blue color
49:12 - here
49:13 - if we sample at every tick
49:17 - like this blip
49:19 - blip
49:20 - blip and blip we are left with and also
49:23 - right there we are left with a wave form
49:25 - that looks like this
49:27 - if we sample at these tick marks
49:31 - we and we remove the continuous line we
49:33 - are left with this lollipop graph like
49:35 - this which has these little dots
49:37 - the more frequently that we sample the
49:39 - signal the smoother this approximation
49:42 - becomes as you can see right now it's
49:43 - not
49:44 - it's not a very good approximation of
49:46 - the original so let's sample it twice as
49:48 - often all right we'll sample here
49:51 - and here
49:53 - here and here that's going to give us a
49:55 - circle there
49:56 - circle there circle there
49:59 - circle there
50:02 - okay
50:03 - let's see the more frequently that the
50:04 - signal is sampled the smoother the
50:07 - approximation becomes this is the sample
50:09 - rate you know we can keep going we can
50:10 - keep bumping this up blip blip
50:13 - blip
50:14 - like that like that like that like that
50:18 - this is starting to look like the
50:19 - original
50:20 - waveform
50:22 - which is great
50:24 - which means like our approximation this
50:26 - digital approximation
50:28 - is much more accurate
50:31 - it's much more true to the original
50:34 - waveform okay
50:36 - this is the concept of sample rate the
50:38 - higher the sample rate the more
50:40 - frequently the signal is sampled
50:42 - now our ears
50:44 - they can hear up to around 20 000 hertz
50:47 - there's a theory called the nyquist
50:49 - theory that basically says that digital
50:51 - audio needs to be sampled at a rate of
50:54 - twice the highest frequency that you
50:56 - want to reproduce
50:58 - so this comes back to
51:00 - the way the waveform is shaped across
51:02 - the grid
51:04 - if i want to reproduce this pink line i
51:06 - can't sample it here and only there i
51:09 - need to have an intermediate point so
51:11 - that way
51:12 - um the full
51:14 - shape of the waveform is captured
51:17 - that's what the nyquist is talking about
51:19 - if i only capture here and here i'm
51:20 - gonna miss the fact that this
51:23 - actually goes up and goes back down
51:25 - that's the whole point behind the whole
51:26 - nyquist theory and whatnot so since we
51:28 - want to hear things up to about 20
51:30 - kilohertz
51:32 - we need to sample that audio that 20
51:35 - kilohertz um signal we need to sample
51:37 - that at 20 kilohertz times roughly 2.
51:40 - then this is where that sample rate of
51:42 - 44.1 kilohertz or 48 kilohertz comes in
51:46 - the sound card in the computer is
51:48 - converting 44
51:50 - 100 or 48 000 audio samples into an
51:54 - analog waveform literally an electric
51:56 - signal
51:56 - and it's sending that to the analog
51:58 - outputs every second
52:00 - you might have speakers or you might
52:02 - have headphones plugged into that analog
52:04 - output
52:05 - and this is where that analog signal
52:07 - goes and then the speakers themselves or
52:09 - the headphones might have an amplifier
52:12 - built into them that actually boosts
52:14 - this electrical signal that comes out of
52:16 - the analog output and then this boosted
52:19 - signal from the amplifier
52:21 - it is sent through some wires that wrap
52:23 - around a magnet that is attached to the
52:26 - speaker cone
52:27 - then the speaker cone vibrates when it
52:28 - gets that electrical signal goes like
52:30 - this
52:31 - which moves the air which our eardrums
52:34 - detect that change in pressure and then
52:36 - our brain
52:37 - translates that into sound that we hear
52:40 - okay now there is a ton of math and
52:43 - science behind these numbers of 44.1
52:46 - kilohertz and 48 and like the way the
52:48 - ears work and the electrical signals and
52:50 - all that stuff
52:51 - we don't need to know any of that we
52:52 - just need to know that what sample rate
52:54 - means is it's like we have this
52:56 - we have this curved line which is
52:58 - continuous that's air pressure moving
53:00 - back and forth and we need to convert it
53:01 - into a digital signal that represents it
53:04 - and the more often we sample it
53:07 - the closer our representation will be
53:11 - now in the juice project there are two
53:13 - important functions that are always
53:14 - called the first one is called prepare
53:16 - to play let's go find the declaration of
53:18 - that that's right here
53:20 - i hope this font is big enough for those
53:23 - of you watching this on a tablet
53:25 - let's go look for the actual
53:26 - implementation of it
53:28 - also if you're using xcode or visual
53:30 - studio there are navigator
53:32 - things in the bars at the top which lets
53:34 - you
53:35 - jump directly to a function so you know
53:37 - learn to use those tools they're very
53:38 - handy the first one is called prepare to
53:40 - play and this is where we configure that
53:42 - basic information
53:44 - of our dsp code the sample rate the
53:46 - number of channels
53:48 - the size of the blocks and stuff
53:50 - the next one is called process block
53:53 - that's right here that's declared right
53:55 - here let's go to where that is over here
53:58 - okay this function process block brings
54:00 - us to our fourth important piece of the
54:02 - audio plugin
54:04 - processing audio samples at a regularly
54:06 - recurring interval using our dsp code
54:10 - this is what happens in the process
54:12 - block function
54:13 - now if you recall
54:15 - let's see let me hide that ring light
54:16 - that's in the back if you recall our
54:19 - sound card has to send 44 or 48 000
54:22 - samples of audio to our speakers every
54:24 - second now internally
54:26 - let's pretend that this chunk right here
54:29 - on the bottom let's pretend this is 48
54:31 - 000 samples
54:32 - okay internally the sound card splits
54:35 - this into small chunks of samples called
54:38 - blocks or buffers so let me just
54:41 - draw what i mean by that okay so instead
54:43 - of sending let's just say this is zero
54:45 - and then this is 48
54:49 - 000. okay imagine there are 48 000
54:52 - samples right here
54:53 - now internal as i said internally the
54:56 - sound card is going to split this into
54:58 - smaller chunks they're going to be
54:59 - called blocks and buffers now by doing
55:01 - this the sound card can lessen its
55:03 - burden of having to send this huge chunk
55:05 - of data to the speakers
55:08 - and to the amplifier and the digital
55:10 - audio converter all at once every second
55:12 - so instead of sending one big chunk of
55:15 - audio
55:16 - it can send lots of little ones such
55:18 - that the total number of samples per
55:20 - second ends up equaling
55:22 - the sample rate so for example it might
55:24 - say here's a chunk right here
55:27 - all right then here's the next chunk
55:29 - and then here's the next chunk
55:31 - and it's going to keep chunkifying this
55:32 - up into just these little blocks well
55:35 - that was terrible
55:37 - these little blocks like this until it
55:38 - gets the total number it needs to send
55:41 - per second
55:42 - if the buffer size was 512 samples let's
55:45 - pretend each of these is you know 512
55:47 - samples
55:48 - and the sample rate is 48 000 then the
55:50 - sound card is going to send 48 000
55:53 - divided by 512 buffers to the sound card
55:55 - every second or
55:57 - 93.75 buffers okay so
56:00 - obviously my picture is not totally
56:03 - accurate there should be 93 orange uh
56:06 - chunks right there okay now it's much
56:08 - easier to send 512 samples 93 times a
56:12 - second than it is to send
56:15 - samples one time per second and it's
56:18 - also easier to design hardware that can
56:21 - deal with 512 samples versus hardware
56:24 - that can handle 48 000 samples at a time
56:26 - okay so that's one of the things that
56:28 - goes into why we have these smaller
56:30 - chunks called blocks or buffers that are
56:32 - like 64 samples or whatever
56:34 - now this is how that idea affects our
56:37 - plug-in and how we design our dsp code
56:39 - the process block function receives a
56:42 - buffer of samples whenever the sound
56:44 - card is ready for more audio to send to
56:47 - the speakers
56:48 - using a sample rate of 48 000 and a
56:50 - buffer size of 512 we know that the
56:53 - sound card is going to send audio to the
56:55 - speakers
56:56 - 93-ish times per second or
56:59 - once every 10 milliseconds
57:01 - one 10-ish milliseconds so that means
57:04 - that all the stuff that happens in our
57:06 - process block
57:07 - it needs to do whatever it's going to do
57:09 - in within those 10-ish milliseconds the
57:12 - faster it does it the better
57:14 - however if the buffer size is even
57:16 - smaller maybe it's only 64 samples
57:19 - then our dsp code must be that much more
57:22 - efficient the sound card needs to send
57:25 - 48 000 samples
57:27 - to the speaker in blocks of 64 samples
57:30 - that means it needs to send 750 of these
57:33 - little blocks
57:36 - per second to the speaker that means it
57:38 - needs to send one block of 64 samples
57:41 - every 1.3333
57:44 - milliseconds that's pretty fast
57:47 - we need to make sure that our dsp code
57:49 - runs as fast as possible as a result the
57:52 - sound card is not going to wait for us
57:54 - if we don't have that block that we were
57:55 - working on ready to go
57:57 - and this is what causes audio dropouts
57:59 - to happen the sound card will just send
58:01 - a block of silence to the speakers if
58:03 - the buffer it sent to our plugin wasn't
58:06 - processed in time so now you know what
58:09 - the process block function does and the
58:11 - constraints that exist for it
58:13 - audio dsp is a serial process there's a
58:16 - loop that is always sending a buffer of
58:18 - samples to our code and then our code in
58:21 - our process block runs from top to
58:23 - bottom
58:24 - and then the loop sends another buffer
58:26 - and there is no asynchronous coding
58:28 - happening here on the dsp side of things
58:31 - it's all happening in series which
58:33 - simplifies thinking about the code a bit
58:36 - this is also why i said earlier that dsp
58:38 - programming is all state-based
58:39 - programming
58:40 - we update the state every time the loop
58:43 - sends us a new buffer of samples to
58:45 - process
58:46 - and finally we have the gui which is the
58:49 - last piece of any audio plugin
58:52 - the gui is where we have all of the
58:54 - sliders all of the knobs all of the
58:56 - buttons that control the audio
58:58 - parameters which in turn control the dsp
59:00 - state
59:01 - it's important to design a gui that is
59:03 - very intuitive to use
59:08 - in terms of
59:09 - how this shows up in the code the plugin
59:12 - processor is where we handle the audio
59:14 - sides of things the
59:17 - dot plugin
59:17 - and cpp source files is where our gui is
59:20 - programmed
59:21 - while we are designing the audio
59:23 - parameters and the dsp for our plugin we
59:25 - will be using the generic audio
59:27 - processor editor instead of our own
59:29 - custom editor this class is really cool
59:31 - because it will automatically create all
59:33 - of the sliders knobs and buttons and
59:36 - combo boxes for every audio parameter
59:38 - that we declare this will allow us to
59:40 - dial in the dsp first and then add a
59:43 - pretty paint job later in the form of
59:44 - the gui now this is important because
59:47 - there are often times where we can't see
59:49 - the gui but the dsp code still runs for
59:52 - example the user might be using
59:54 - automation in their daw to control the
59:56 - audio parameters instead of the gui our
59:59 - gui always reflects the state of these
60:02 - parameters it's never the other way
60:04 - around the gui always shows the state of
60:07 - the audio parameters
60:09 - with this understanding let's switch to
60:11 - the generic audio processor editor so
60:14 - navigate to the create editor function
60:16 - in
60:18 - pluginprocessor.cpp
60:20 - create editor
60:22 - comment out this line
60:24 - that
60:25 - currently returns the custom editor we
60:27 - will develop later
60:28 - and change this to return
60:30 - the generic audio processor editor
60:32 - instead return new juice
60:36 - generic
60:38 - audio processor editor
60:42 - oh that's deprecated all right
60:43 - add the star
60:45 - all right let's run this and take a look
60:46 - at our gui
60:48 - don't forget our plugin will
60:49 - automatically show up because we already
60:51 - configured audio plug-in host which is
60:52 - awesome
60:54 - it's this guy right here simple mb comp
60:57 - okay we don't have any audio parameters
60:59 - yet so the gui is not going to show
61:01 - anything we will add some audio
61:03 - parameters next
61:08 - let's talk about compressors and what
61:10 - they do
61:11 - now audio signals have different levels
61:14 - they can be loud they can be soft it
61:17 - could be a medium level there can be
61:19 - signals that can be too loud for a given
61:21 - system now when i say system i'm
61:24 - referring to the circuitry and the code
61:26 - that is either converting an analog
61:28 - signal into a digital one or converting
61:31 - a digital signal into an analog
61:33 - what this means is that the signal's
61:36 - amplitude can be greater than what the
61:39 - system can support let's use an example
61:42 - let's say that we have a sine wave that
61:44 - is represented digitally
61:46 - if we plot this wave on a graph that
61:48 - shows time on the x-axis and amplitude
61:51 - on the y-axis
61:53 - uh let's let's give it an amplitude with
61:55 - a range of negative 0.5 to positive 0.5
61:58 - so we'll start here
62:01 - and we'll just go that high
62:03 - that high
62:05 - like that okay
62:06 - so let's just pretend this lines up with
62:08 - 0.5 and this lines up with negative 0.5
62:12 - let's add some gain to this signal right
62:15 - we're going to
62:16 - boost it and by doing that we're going
62:17 - to double the signal
62:20 - okay so
62:21 - i'm going to turn up my volume knob
62:23 - crank it up it's going to double it
62:26 - add some more gain
62:32 - all right cool so now the wave has an
62:35 - amplitude of positive one to negative
62:37 - one that's the range of the signal so
62:40 - that's the range of the signal's
62:41 - amplitude okay let's add some more again
62:43 - some more we're going to double it again
62:45 - so now it goes from
62:46 - zero goes up to plus two let's see i'll
62:49 - use this red color
62:51 - hopefully this shows up
62:55 - i'm gonna add this guy right here
62:57 - we're gonna double it we go up to two
63:03 - our waveform has an amplitude of minus
63:06 - two
63:07 - to plus two what happens if we try to
63:10 - send this signal to our speakers through
63:12 - our sound card now the sound card can
63:14 - only handle
63:15 - signals between negative one and plus
63:17 - one let me use this green color i really
63:20 - hope this shows up
63:21 - now the sound card can only handle
63:23 - signals between negative one and plus
63:25 - one so the sound card is going to clamp
63:28 - any value that is outside of this range
63:30 - to this range so it's going to take this
63:32 - red signal
63:33 - and instead of it doing this
63:37 - instead of it doing that
63:40 - it's going to clamp it right across like
63:42 - that
63:43 - same for the top one it's just gonna go
63:44 - blip
63:46 - and right here it's gonna go blip
63:47 - just like that
63:49 - all right this is gonna turn it into a
63:51 - quasi square wave this doesn't sound
63:53 - good when that happens this form of
63:55 - signal clamping is a form of brick wall
63:58 - limiting this signal is hard limited to
64:01 - a specific range of values with no
64:02 - regard for what sort of distortion this
64:04 - will cause to the original signal
64:07 - by distortion i mean the fact that we
64:09 - had a nice smooth curve and now it's got
64:11 - like a square top and a square bottom
64:13 - it is no longer
64:15 - accurate to the original
64:18 - a compressor allows us to control the
64:20 - signal's amplitude in a musical way and
64:23 - in an automated way there are four parts
64:26 - to every compressor the two main parts
64:28 - are the threshold and the ratio
64:31 - so we're going to talk about our
64:32 - hypothetical signal for a little bit our
64:34 - signal is currently being clamped by the
64:36 - sound card whenever the absolute value
64:38 - of the signal is greater than one that's
64:40 - happening right here and then right here
64:43 - this plus one
64:45 - this absolute value plus one that is the
64:47 - threshold
64:49 - the threshold control tells the
64:51 - compressor whenever the absolute value
64:53 - of the incoming signal is greater than
64:56 - this threshold whenever it's greater
64:57 - than this
64:58 - apply gain to the signal it can be
65:00 - negative gain apply it to the signal so
65:03 - that the signal stays near or below this
65:06 - threshold
65:07 - now the next part is the ratio control
65:10 - the ratio control affects how much gain
65:13 - is actually applied to the signal is it
65:15 - is written as x colon y like this you've
65:19 - got
65:19 - x
65:21 - y so you could have three to one you
65:24 - could have ten to one
65:27 - you could have two point five
65:30 - to one
65:31 - like that okay
65:33 - these are the different ratios
65:36 - what they mean is that for every x
65:38 - decibels of input signal above the
65:40 - threshold
65:41 - the output signal will actually show y
65:44 - decibels of signal above the threshold
65:47 - so let's do an example to understand how
65:49 - this works because it's easier to think
65:51 - of this stuff in terms of decibels
65:53 - versus negative one and plus one
65:55 - normalized samples
65:58 - let's say that we have a signal
66:01 - that has a value
66:03 - of plus six decibels we can see that it
66:06 - goes over this threshold right here i've
66:07 - changed the scale on the side
66:09 - we still have zero plus one and minus
66:12 - one but you can think of zero as
66:14 - negative infinity because it means
66:16 - silence like the signal level in terms
66:18 - of decibels is
66:20 - infinitely small
66:22 - and then the plus one
66:24 - is the same as zero decibels below full
66:27 - scale and then any signal above that is
66:30 - reflected as a positive value
66:32 - okay let's say that our ratio is
66:36 - two
66:37 - to one
66:41 - and we're going to have a threshold of
66:42 - zero db
66:44 - okay now let's say that our signal is
66:47 - plus 6 db
66:49 - that means that our signal is 6 decibels
66:52 - above the threshold
66:54 - so let's plug the ratio into this line
66:57 - for every x db of input signal above the
66:59 - threshold the output will show y db of
67:02 - signal above the threshold
67:05 - so that means for every two decibels of
67:08 - input signal above the threshold
67:11 - the output will show one decibel of
67:14 - signal above the threshold so our signal
67:16 - is six decibels of the threshold so the
67:18 - output will actually only show
67:21 - three
67:22 - decibels of signal above the threshold
67:25 - that's going to look like this
67:30 - okay i should have probably used a
67:32 - different color but you get the idea
67:33 - this is plus six here
67:37 - this is plus three
67:39 - now let's try a different ratio like 10
67:42 - to 1.
67:43 - what that means is that for every 10
67:45 - decibels of input signal that is above
67:47 - the threshold the output will show only
67:50 - 1 db of signal above the threshold our
67:53 - output is 6 over the threshold so the
67:56 - output will only be 0.6 above the
67:58 - threshold
68:00 - which means our signal let me use a
68:02 - different color
68:03 - means our signal
68:05 - is actually going to look like this
68:07 - i think that math is right if it's 6
68:09 - above the
68:10 - yeah 10 decibel 10 to 1 ratio so we're
68:13 - going to get a 0.6 out of it now we can
68:16 - continue to increase this ratio and get
68:18 - more and more reduction
68:20 - of the input signal however we can never
68:23 - make the output not produce a signal
68:26 - over the threshold unless we use an
68:28 - infinite ratio and that's what that
68:29 - brick wall limiting was that we saw
68:31 - before where the signal was just
68:34 - just chopped off that's where it just
68:35 - went
68:36 - like that and like that that's that
68:38 - brick wall limiter thing that i
68:40 - mentioned earlier that's using that same
68:42 - ratio of infinity to one
68:44 - okay so that covers threshold and ratio
68:47 - these are the two of the four parameters
68:49 - you can see them here we got threshold
68:51 - and ratio
68:53 - now clamping the audio like this doesn't
68:55 - sound musically pleasing
68:57 - furthermore
68:59 - going from clamping the signal to
69:00 - suddenly not clamping it doesn't sound
69:02 - good either and this brings us to the
69:04 - other two parameters the attack and the
69:07 - release the attack parameter controls
69:09 - how long to wait after the signal
69:11 - exceeds the threshold before gain
69:13 - reduction is applied
69:15 - the release parameter controls how long
69:18 - to wait once the signal stops exceeding
69:20 - the threshold before the gain reduction
69:23 - is no longer applied
69:25 - let me show you what that looks like on
69:26 - this graph
69:28 - all right we're back with our signal it
69:30 - goes from it's got a plus 6 db range on
69:34 - it
69:35 - uh the threshold is zero is still zero
69:37 - let's give it an attack time of
69:40 - one of these ticks right here so what
69:42 - that means if we draw a vertical line
69:45 - where this intersection
69:46 - happens let's just let's just pretend it
69:49 - happens right on this line right here
69:51 - that means that we're gonna wait until
69:53 - this tick
69:54 - to actually start compressing this
69:56 - signal okay
69:58 - so now i've got this orange line right
70:00 - here
70:01 - what this means is that it's not going
70:03 - to start applying compression until this
70:06 - point in time so this chunk of signal
70:09 - right here is not compressed it's going
70:11 - to go over the threshold
70:13 - and what is actually going to happen is
70:14 - we're going to apply the same rule right
70:16 - here of you know let's do two to one
70:19 - so this is you know let's say this is
70:22 - this looks like four
70:23 - so we're at four db
70:25 - so this is going to produce an output of
70:27 - two
70:28 - which means we're going to get something
70:30 - like this here
70:33 - we're going to see that
70:34 - okay so like i was saying we have this
70:36 - one intersection point
70:39 - what's going to happen is the signal is
70:40 - going to come to here
70:41 - it's going to rise the way it was
70:43 - normally going and then when it's going
70:44 - to hit that attack time
70:46 - let's say this is attack right there
70:48 - and this is going to go down like this
70:52 - and go like that
70:54 - so it's going to wait before
70:56 - gain
70:57 - reduction is applied based on however
71:00 - long this time is set to
71:02 - okay
71:04 - that's the attack time
71:06 - again the release parameter is going to
71:07 - control how long to wait once the signal
71:10 - stops exceeding the threshold before
71:13 - gain reduction is no longer applied
71:16 - so what that means on this side is that
71:18 - let's say the release time if we draw
71:20 - this line down here let's say this is
71:22 - our release right here
71:24 - just it's just one chunk of this right
71:25 - here
71:26 - so what that means is it's going to
71:27 - continue to apply
71:30 - gain reduction to this
71:32 - until we get to about there and then
71:34 - it'll drop across
71:36 - and how much gain reduction is applied
71:38 - depends on the ratio these two
71:40 - parameters the attack and release time
71:42 - allow us to smooth the transition
71:45 - between compressing the input signal and
71:47 - not compressing the input signal
71:49 - and then finally the threshold is always
71:51 - expressed in decibels and the attack and
71:53 - release times are expressed in
71:55 - milliseconds
71:56 - so the ratio is not expressed in any
71:58 - units even though conceptually we like
72:00 - to think of it as input decibels versus
72:03 - output decibels
72:04 - so with this knowledge in hand let's
72:07 - begin coding up some audio parameters to
72:09 - control our
72:11 - soon to be functional compressor
72:15 - one of the things we need to think about
72:17 - is synchronizing these audio parameters
72:19 - with our gui
72:21 - thankfully juice solves that for us with
72:24 - the audio processor value tree state
72:26 - class
72:27 - this class synchronizes our audio
72:29 - parameters with the host application
72:31 - that is loading our plugin and with our
72:34 - plugins gui we're going to need one of
72:36 - these in our audio processor
72:38 - it's going to need to be public so that
72:40 - the gui can attach all of its knobs and
72:42 - sliders and buttons etc to it now
72:45 - parameters must be declared when the
72:47 - plugin is created they cannot be
72:49 - dynamically created as such the apvts
72:52 - expects us to provide the list of
72:54 - parameters when it is constructed so
72:57 - we're going to need a function that will
72:59 - provide that list for us in the form of
73:02 - an audio processor value tree state
73:04 - parameter layout object let's head on
73:06 - over to
73:08 - our pluginprocessor.h
73:10 - let's go to the end of the public
73:12 - section right here
73:14 - and i'm going to use an alias using
73:16 - apbts equals juice audio processor value
73:20 - tree state
73:22 - now i'm going to declare this function
73:23 - first static ap oops
73:30 - um parameter layout
73:34 - create parameter layout
73:36 - all right now we can declare our ap vts
73:40 - give me the argument list
73:42 - all right we want this one all right we
73:44 - want to connect to this
73:46 - we're not going to use an undo manager
73:49 - we're just going to call it parameters
73:50 - and then the parameter layout will be
73:52 - provided by our create parameter
73:55 - layout
73:57 - function
73:58 - all right let's declare
74:00 - let's see i'm going to use my alias now
74:04 - a b v t s
74:06 - and then i got to use curly braces here
74:08 - instead of parentheses because it's
74:10 - initialization
74:11 - now we can go implement our uh the
74:14 - function that will provide the param the
74:16 - parameter layout let's go to the cpp
74:17 - file i'm going to put this all on one
74:19 - screen let me hide this uh
74:22 - hide this assistant guy all right i'm
74:24 - going to put this down in
74:26 - put this past the set state information
74:28 - put this right here
74:30 - first things first return type
74:33 - parameter layout
74:35 - and then the name of our class and the
74:37 - function
74:38 - [Music]
74:40 - all right first thing we need is uh the
74:42 - thing we're going to return
74:44 - lay out and we're going to return that
74:48 - all right we're going to be using the
74:50 - juice name space a lot i don't want to
74:51 - have to type it so we're going to use
74:53 - the using alias
74:55 - okay the first parameter we will create
74:57 - is the threshold parameter i'm going to
74:59 - set the range for the threshold to be
75:01 - between negative 60 and plus 12. i'm
75:03 - going to set the step size to one
75:06 - decibel meaning we can adjust the
75:08 - threshold in one decibel increments
75:11 - the skew parameter will be one
75:13 - now the skew parameter affects how this
75:15 - range of values from negative 60 to plus
75:17 - 12 is distributed across the slider
75:20 - that for the slider that's going to be
75:21 - attached to this parameter if you want
75:23 - to learn about this stuff i covered all
75:24 - of this in detail in the simple eq
75:27 - tutorial okay here we go layout.add we
75:30 - need to make a unique pointer
75:33 - all right we want to make a
75:34 - audio parameter
75:36 - float this one right here that guy off
75:40 - we're not going to use this
75:43 - my first parameter is going to be
75:44 - threshold parameter name is also
75:46 - threshold normalizable range we'll
75:49 - figure that out in a second all right we
75:51 - want to have a default value of zero
75:53 - decibels for our threshold let's define
75:55 - a normalizable range next
75:57 - normalizable range let's see which one
75:59 - do we want
76:01 - uh this one has start
76:03 - and interval and skew we'll use that one
76:05 - all right it's going to be a float type
76:08 - our range start is going to be negative
76:10 - 60 range end is positive 12. our
76:13 - interval value is 1
76:15 - and our skew is 1.
76:18 - all right awesome next i'm going to dial
76:20 - in the attack and release i want to have
76:22 - a minimum attack and release time of 5
76:26 - milliseconds so that means our
76:27 - compressor will always take at least 5
76:30 - milliseconds to start compressing once
76:32 - the input signal goes over the threshold
76:35 - i'm going to set the max time to 500
76:37 - milliseconds and i'm going to set the
76:39 - step size and the skew to 1.
76:41 - the slider controlling the attack and
76:44 - release will be linear just like the
76:45 - threshold slider let's do that next
76:47 - first let's define the range
76:49 - auto attack release range equals
76:53 - normalizable range
76:55 - this guy right here floats our range
76:57 - start is going to be five milliseconds
76:59 - like we said
77:00 - um then we're gonna have 500 as the end
77:04 - and then one and one for the skew and
77:06 - for the step size let's add an attack
77:09 - param and a release param
77:11 - layout.add
77:14 - make
77:15 - unique
77:17 - uh this is audio parameter float
77:21 - and
77:22 - oops i forgot
77:24 - this we want this one right here okay
77:26 - this is attack
77:28 - attack our normalizable range will be
77:31 - this thing
77:33 - our default value will be 50
77:35 - milliseconds
77:38 - all right we can do the exact same thing
77:40 - for the release
77:43 - just need to change the name
77:47 - paste that there
77:48 - i'm going to change this release time to
77:50 - be 250
77:53 - and we need to add the closing carrot to
77:56 - the template type
77:58 - and then let's change this to say
78:00 - release
78:03 - and let's line these guys up now finally
78:06 - we need to give ourselves some ratios
78:09 - a one-to-one ratio results in no
78:12 - compression and a 100 to 1 ratio is
78:15 - basically brick wall limiting i'm going
78:17 - to use those values as like my start and
78:19 - end range and i'm going to add some
78:20 - values in between and since i don't want
78:22 - to use linear steps between 1 and 100
78:24 - because that would just provide a huge
78:26 - list of ratios i'm going to use audio
78:28 - parameter choice and hard code
78:31 - the choices that i'm going to use okay
78:34 - the audio parameter choice constructor
78:36 - requires a string array of choices so
78:39 - i'm going to declare my choices first
78:41 - i'm going to convert them into strings
78:43 - and then i'm going to add them to the
78:44 - string array
78:45 - then i will create the parameter
78:47 - so here's my choices
78:49 - so i'm going to do i'm going to start at
78:51 - 1
78:52 - 1 2 3 4 5 with a 1.5 this is a pretty
78:55 - common
78:56 - um just you know very very light
78:57 - compression basically one two three four
78:59 - five six seven eight you know linear
79:01 - steps and then once we hit 10 i do 10 15
79:03 - 20 then 50 then 100. okay this 20 50 and
79:07 - 100 are all basically gonna sound the
79:09 - same they're just
79:10 - variously more aggressive forms of brick
79:12 - wall limiting
79:13 - now i can declare my string array
79:16 - and now i can use i can convert my
79:18 - choices into juice string
79:20 - objects now there's a string
79:24 - constructor
79:25 - that takes a um takes a double and we
79:28 - can specify how many decimal places get
79:30 - used so that's the one i want here
79:32 - double double value into number of
79:35 - decimal places i only want to display
79:36 - one decimal place so we're going to do
79:38 - that first
79:39 - and we're going to pass the choice to it
79:42 - that takes care of that
79:43 - now
79:44 - we can create the parameter and i do not
79:47 - want one to one to be the default ratio
79:50 - so i think three to one would be better
79:52 - so i'm going to use the index of this
79:54 - guy right here as the default value and
79:56 - remember that indexing starts with zero
79:59 - in c plus so we go like this layout dot
80:02 - add
80:03 - std make unique
80:05 - audio parameter choice
80:08 - all right this is going to be called
80:09 - ratio
80:10 - this is also ratio and my choices are
80:13 - the string array my default index is
80:16 - let's see this is zero one two three
80:20 - that guy right there all right
80:24 - like that and then we need our
80:26 - carrot
80:27 - all right there we go let's run it and
80:30 - we will see our sliders let's see what
80:31 - we got
80:32 - this should show us some sliders okay
80:36 - look at this we got our threshold guy
80:37 - right here we've got our attack time
80:40 - we have our release time and here we
80:42 - have our ratio
80:44 - awesome
80:45 - let's add saving and loading of the
80:47 - parameters next
80:49 - let's implement saving and loading of
80:51 - our plug-in parameters state
80:54 - it's very easy to do because the plug-in
80:57 - state is stored in the audio processor
80:59 - value tree states
81:01 - state member i'll show you what i'm
81:02 - talking about
81:04 - go over here let's go to where it's
81:05 - actually
81:06 - defined jump to definition
81:09 - way down here in the at the end of the
81:11 - public section
81:13 - there is a state member let's just look
81:16 - for that state
81:17 - right here yes it was at the
81:19 - bottom of this okay this is the public
81:21 - member the state okay this is the state
81:23 - of the whole processor all right let's
81:25 - go back to where we were plugin
81:27 - processor.cpp
81:29 - let's move to the get state information
81:32 - function
81:33 - it's very easy to implement saving and
81:36 - loading of our plugins parameter state
81:38 - and that's because the
81:40 - plug-in state is stored in that state
81:43 - value tree okay now the value tree
81:46 - serializes to memory very easily we can
81:48 - use a memory output stream to handle the
81:50 - busy work which is needed to write the
81:53 - ap vts state to the memory block that
81:55 - this function has been given by the host
81:57 - it's this thing right here so all we
81:59 - have to do is create a memory stream
82:01 - juice memory output stream
82:04 - uh here's the block we're going to write
82:05 - to
82:06 - okay we're going to write to destination
82:08 - data
82:09 - um yes we can append because who knows
82:11 - if we're getting an empty one or a full
82:13 - one
82:14 - one that's empty or one that's already
82:15 - got a bunch of stuff in it let's give
82:17 - ourselves a member name a variable name
82:19 - and then we can just do apvcs dot state
82:23 - dot write to stream and then write it to
82:25 - our memory output stream
82:27 - all right wasn't that easy now we can do
82:30 - the reverse and restore our plug-in
82:32 - state from memory using a value tree
82:34 - helper function
82:36 - the only thing we need to check for is
82:38 - whether or not the tree that was pulled
82:39 - from
82:40 - the uh chunk of memory we were given
82:42 - this stuff right here we just need to
82:44 - check if it's valid um before we copy it
82:46 - into our plug-in state once we know that
82:49 - it's valid we can replace the plug-in
82:51 - state appropriately
82:53 - here's the free function to use juice
82:55 - value tree
82:58 - read from data this is the one we want
83:00 - so we're going to pass the data we're
83:02 - going to pass its size in bytes
83:04 - this is going to give us back a value
83:06 - tree auto tree equals we just need to
83:09 - make sure it's valid if tree dot is
83:12 - valid
83:13 - if it's valid then we can replace it ap
83:16 - vts.replace
83:18 - state with our tree
83:20 - awesome let's test it out
83:24 - where did that go
83:25 - oh you're hiding okay we'll put you here
83:27 - all right i'm going to change the ratio
83:29 - from 3 to 10
83:31 - then i'm going to save and quit
83:34 - and i'm going to re-run it
83:36 - the ratio should appear as 10.
83:38 - and there it is perfect all right cool
83:40 - let's add a compressor next and get it
83:42 - to modify some audio next
83:47 - if you get stuck or run into trouble
83:49 - while coding this or simple eq just grab
83:52 - one of my free products from programming
83:54 - for musicians.com and you can message me
83:56 - directly in the slack workspace and i
83:58 - will help you directly
84:00 - juice has a generic compressor that we
84:03 - will be using for this project in order
84:05 - to access it we need to include the dsp
84:08 - module first before we can use it so
84:10 - let's go to our juicer file
84:13 - okay go to the modules section click on
84:16 - this plus icon right here
84:18 - add a module global juice modules path
84:22 - and choose the juice dsp class
84:25 - dsp module save and reopen
84:28 - all right now
84:30 - there it is now we can use the juice dsp
84:33 - classes let's go to the private section
84:35 - of our header file
84:36 - plugin processor let's declare an
84:38 - instance and then next we will prepare
84:40 - it in prepare to play
84:42 - so juice dsp
84:45 - compressor
84:47 - float
84:49 - compressor
84:51 - that was easy
84:52 - all right let's head over to the cpp
84:54 - file and prepare it go to plug-in
84:56 - processor
84:57 - and go to prepare to play now we need to
85:00 - prepare our compressor we do this by
85:02 - passing a process spec object to the
85:05 - compressor we must first set up this
85:08 - spec object let's declare one juice
85:11 - dsp process spec give it the name spec
85:15 - first it needs to know the maximum
85:17 - number of samples that will be processed
85:19 - at any time so spec dot maximum block
85:22 - size equals this parameter here
85:25 - samples per block next it needs to know
85:27 - the number of channels this compressor
85:29 - can handle multiple channels we will use
85:32 - the number of output channels that our
85:34 - plug-in can support as the number of
85:36 - channels to configure our compressor
85:38 - with spec dot num channels equals get
85:41 - total num output channels
85:44 - okay and now it finally it needs to know
85:46 - the sample rate which is this parameter
85:48 - here
85:49 - spec dot sample rate equals sample rate
85:52 - now we can pass it to our compressor
85:54 - which will prepare it
85:56 - compressor
85:57 - dot prepare
85:58 - spec
85:59 - next go to process block
86:02 - all right now we can start using our
86:04 - compressor to squish our audio the
86:07 - compressor wants a context to process
86:10 - and this context requires an audio block
86:12 - in order to be constructed so let's
86:14 - create an audio block out of the buffer
86:17 - that was provided to us
86:20 - let's get rid of this stuff right here
86:24 - and we're going to leave this code which
86:25 - clears channels that are not in the
86:27 - input okay so first let's declare an
86:30 - audio block juice dsp audio block
86:35 - and we want to use the one that takes a
86:37 - buffer as the constructor
86:40 - float
86:41 - pass it the buffer
86:43 - pass it this thing right here all right
86:45 - let's give it a name auto block equals
86:47 - whoops let's spell that right
86:50 - all right now that we've got our block
86:51 - we can create a context
86:53 - auto context equals juice dsp and here's
86:57 - where we want our context we're going to
86:59 - use a replacing context
87:01 - which means we're going to replace the
87:02 - audio in the buffer with our processed
87:05 - audio
87:06 - and we want the one that takes a block
87:08 - as its constructor argument
87:10 - float
87:11 - block
87:13 - now that we have our context we can
87:15 - process audio with our compressor
87:18 - compressor.process
87:20 - context
87:22 - let's run it
87:23 - everything should sound the same
87:25 - let's try it out
87:28 - and just to be sure that i've got some
87:30 - signal
87:31 - that stuff is actually happening i'm
87:32 - going to instantiate
87:34 - project 12. i'm going to feed
87:36 - project 12 with our output
87:40 - and this is just going to be over here
87:42 - so we can see what's going on
87:44 - okay let's play it we're going to run
87:46 - some sound through it
87:51 - all right
87:52 - now
87:53 - not doing anything to the sound and if
87:54 - we bypass this
87:59 - sound is the same
88:01 - all right so this is because we have not
88:03 - wired up any parameters to our
88:05 - compressor to adjust
88:07 - the threshold attack release and whatnot
88:09 - we've got our parameters here but they
88:10 - are not connected to the compressor
88:12 - that's actually doing signal processing
88:14 - let's do that next
88:17 - head on over to the header file plug-in
88:19 - processor dot h
88:21 - okay now the apvts has a member function
88:24 - that returns pointers to the parameters
88:26 - that we created in the create parameter
88:28 - layout function it does not make sense
88:30 - to call this member function for every
88:33 - single parameter every time process
88:35 - block is called remember process block
88:38 - if our buffer size is small it could be
88:39 - being called 750 times a second
88:42 - so the cost of looking up those
88:44 - parameters could get expensive very
88:46 - quickly and this is one of those
88:47 - optimizations that we can do i know the
88:49 - rule don't prematurely optimize but this
88:51 - is one of the ones where it's okay to do
88:53 - it alright so let's create some member
88:55 - variables that will act as cached
88:57 - versions of our audio parameters for
88:59 - this compressor instance we're going to
89:01 - use the same types that we used when we
89:03 - created our parameters if we go over
89:05 - here go to our create parameter layout
89:08 - we used audio parameter float float
89:11 - float and audio parameter choice so we
89:13 - will create pointers to those okay so go
89:17 - to pluginprocessor.h
89:19 - and start declaring them here juice
89:21 - audio parameter oops let's spell that
89:23 - right parameter float make pointer
89:26 - attack
89:27 - initialize it
89:29 - okay we're going to do the same thing
89:30 - for the release
89:33 - and the threshold release
89:37 - threshold and then
89:39 - the ratio is a choice parameter juice
89:42 - audio parameter choice
89:47 - let's move over to the process block
89:49 - next and use these guys first before we
89:51 - set them up okay go to process block
89:56 - all right now here is how we use these
89:58 - guys first of all we need to use them we
90:00 - need to configure all this stuff before
90:01 - we start processing audio i'm going to
90:03 - do that before i create the block and
90:05 - the context
90:06 - okay here is how we use these parameters
90:08 - the float parameters have a get function
90:11 - that we can use and we just need to call
90:13 - the appropriate compressor function
90:16 - with this parameter value so we do
90:18 - compressor
90:19 - dot set
90:20 - and you can see we've got choices here
90:22 - attack release threshold ratio so let's
90:24 - start with the attack set attack
90:27 - and then we call attack param
90:29 - and just get the value
90:31 - let's do the same thing for the release
90:33 - and the threshold compressor dot set
90:36 - release
90:37 - release
90:39 - get
90:40 - compressor dot set threshold
90:43 - threshold
90:45 - get
90:46 - now for the ratio setting we need to
90:49 - extract the float value from the current
90:51 - ratio choice if you recall let's scroll
90:54 - down here
90:56 - if you recall uh the choices are stored
90:58 - in a string array
91:00 - all right so we need to get the float
91:01 - value of the current choice from the
91:03 - string and thankfully there is a helper
91:06 - function
91:07 - in the string class which does this for
91:09 - us and all we need to do is get the name
91:11 - of the current choice and then call that
91:12 - helper function so let's do that next we
91:15 - can do compressor
91:16 - dot set ratio
91:18 - and do the ratio parameter and we need
91:20 - to get the current choice name this guy
91:22 - right here returns a string and then we
91:24 - just need to call that string helper
91:26 - function get float value
91:29 - now before we actually test this we need
91:31 - to initialize our member variables so
91:33 - they aren't null
91:35 - let's go to the constructor to do that
91:37 - because if you remember when we declared
91:38 - these guys
91:40 - they're all currently null if we were to
91:42 - run this now we would get a big old
91:43 - crash all right so let's go on up to the
91:45 - constructor
91:49 - all right now as i said earlier there is
91:50 - a member function in the ap vts that
91:53 - allows us to retrieve pointers to
91:55 - parameters that we have added
91:57 - and all of these parameters are stored
91:59 - internally as ranged audio parameter
92:02 - this is the base class that all
92:03 - parameter types come from so we need to
92:05 - cast these parameters these ranged audio
92:08 - parameters to their correct type before
92:10 - we can assign them to the cached
92:12 - instances that we declared
92:14 - so let's do that we need let's do the
92:16 - attack parameter first let's do attack
92:18 - equals
92:19 - like i said we need to cast it to a
92:21 - juice audio parameter float
92:24 - and this is where we call
92:25 - apvts.getparameter
92:28 - and our name was attack okay now the
92:31 - getparameter function will return a
92:33 - nullpointer if the parameter name that
92:35 - we provided is not found in the
92:38 - list of parameters in case we type the
92:40 - parameter name incorrectly it's very
92:42 - useful if we assert when the parameter
92:44 - is null so this is going to help us
92:46 - catch any misspelled parameter names so
92:49 - we can do jsert
92:51 - attack
92:52 - is not a null pointer
92:54 - remember this function returns null
92:57 - if it doesn't find this parameter and if
92:59 - it does find this parameter
93:01 - then
93:02 - if this cast succeeds then the attack
93:05 - will not be null pointer if this cast
93:07 - fails like for instance let's say the
93:09 - attack was actually an integer audio
93:10 - parameter in
93:12 - or this cast would fail and we would
93:13 - have a null pointer here and we would
93:14 - hit a j assert so this is really handy
93:17 - so let's do that same thing for the
93:19 - uh two other float parameters just copy
93:22 - this
93:23 - we'll make this the release
93:25 - release
93:27 - and change this to release and then we
93:29 - can do threshold
93:31 - threshold
93:33 - threshold
93:34 - and threshold for the ratio we need to
93:37 - cast to audio parameter choice is this
93:40 - ratio
93:41 - ratio ratio
93:44 - choice
93:45 - audio parameter choice
93:48 - and ratio all right perfect let's
93:51 - compile it and run it and tweak some
93:52 - sliders
93:53 - we should hear some audible effects
93:55 - here's how we're gonna test this out
93:58 - okay change the ratio to like 50 to one
94:02 - and then we're going to set the
94:03 - threshold pretty low and then we're
94:05 - gonna start messing with the attack time
94:07 - so
94:08 - highly recommend get yourself some
94:10 - headphones to hear this
94:12 - all right let's run some audio through
94:13 - it though
94:16 - all right change that ratio to 50
94:19 - drop that threshold down
94:21 - and we can really hear it clamping on
94:23 - that signal let's adjust this attack
94:25 - time
94:27 - so you can hear how the signal goes
94:30 - you can hear how the signal peeks
94:31 - through and then gets clamped down real
94:33 - quick that's that attack time the weight
94:35 - once the signal is past the threshold
94:37 - before it actually starts getting
94:38 - clamped
94:39 - we can hear if we change the change the
94:41 - ratio to something
94:43 - more subtle
94:44 - uh to a lower ratio we can hear that
94:46 - it's going to
94:47 - um
94:48 - it's not going to be as drastic of an
94:50 - effect
94:52 - so if we go back to 50 we can really
94:54 - hear it doing something major
94:57 - and then
94:58 - if we set that attack time as fast as
95:00 - possible we're not going to hear any
95:01 - attack at all because our ears just
95:02 - don't hear
95:04 - we just hear the audio getting really
95:05 - slammed
95:07 - [Music]
95:09 - okay
95:11 - if we set that release time really fast
95:13 - we're not going to hear so much
95:16 - oh we can start to hear a lot of
95:17 - distortion happening it's really
95:19 - smashing the signal
95:22 - all right let's bypass it
95:24 - see what's going on
95:30 - [Music]
95:35 - all right let's increase that release
95:36 - time
95:37 - all right cool
95:40 - so there we go our compressor is
95:42 - currently compressing
95:44 - all right let's find something else to
95:46 - do to make this turn this into a
95:47 - multi-band compressor next
95:49 - all right cool
95:52 - let's add a bypass parameter it's much
95:55 - easier to click on this parameter than
95:57 - it is to right-click on the plug-in in
95:58 - the audio plug-in hosts filter graph and
96:00 - toggle that menu option so let's head on
96:03 - over to the create parameter layout and
96:06 - add a bypass parameter stick this at the
96:09 - end
96:10 - layout
96:12 - dot add
96:13 - std make
96:15 - unique we want to add an audio parameter
96:18 - bool audio parameter
96:21 - bool this one right here all right this
96:24 - is called bypassed
96:28 - same name by passed and the default
96:31 - value is false meaning it is not
96:34 - bypassed
96:35 - that means it's active
96:37 - next let's declare a cached version of
96:39 - this plugin processor.h down to the
96:41 - bottom stick this guy right here
96:44 - juice audio parameter bool pointer
96:47 - bypassed
96:49 - nullpointer
96:50 - we can toggle whether or not our
96:52 - compressor processes the audio by
96:54 - setting the is bypassed flag on the
96:57 - context let's head on over to the plugin
96:59 - processor dot cpp go to process block
97:04 - and we can modify this context okay this
97:06 - is the simplest way to do this
97:08 - we can toggle whether or not our
97:10 - compressor processes the audio let's
97:12 - just actually go look at this okay if
97:14 - context is bypassed then just copy from
97:16 - the input to the output and get out of
97:18 - here okay otherwise
97:21 - do all this stuff which actually
97:22 - processes the code processes the audio
97:24 - samples all right this is the simplest
97:27 - way to
97:28 - toggle bypassing all we have to do is go
97:31 - context dot is bypassed equals our
97:34 - bypass parameter
97:36 - and get that value
97:37 - okay another option would be to write an
97:39 - if statement and wrap all of this stuff
97:41 - that creates
97:43 - um that creates the block and the
97:45 - context and does the processing in that
97:48 - but this is much much simpler to just do
97:50 - this okay so let's finally move to the
97:53 - constructor and initialize this param we
97:55 - will follow the same pattern as before
97:58 - initialize and then
98:00 - check it out all right we copied it
98:02 - let's change this to be bypassed
98:05 - and we want audio parameter bool
98:07 - and this is
98:08 - bypassed
98:10 - and then we just check it if it's null
98:13 - or not all right let's run and test it
98:15 - let's see what happens
98:17 - grab these headphones one more time
98:19 - all right there's our bypass parameter
98:22 - go ahead and start the music
98:25 - wow it's really slammed
98:27 - there we go
98:29 - bypass parameter is
98:31 - working as uh expected
98:33 - so this makes it much easier to compare
98:36 - the unprocessed and the processed audio
98:38 - so we can hear what our compressor is
98:39 - doing
98:46 - all right cool
98:47 - that was easy
98:49 - super easy
98:53 - we are trying to build a three band
98:55 - compressor
98:56 - what we have done so far is implemented
98:59 - the functionality of a single band
99:02 - so it makes sense for us to wrap this
99:04 - functionality into a class so it can be
99:07 - reused easily
99:08 - let's do that next
99:10 - let's declare a compressor band struct
99:13 - let's go to our plugin processor dot h
99:16 - and turn on the assistant editor
99:19 - actually before we do this let's make a
99:21 - commit let's go over here
99:23 - stage all this stuff
99:25 - i'll say implemented basic compressor
99:28 - functionality
99:31 - all right there's our juicer file
99:33 - filter graph yes we want that right we
99:35 - added our params
99:38 - and then here's where we initialized our
99:39 - params
99:41 - here's where we initialized our
99:42 - compressor here's where we processed our
99:45 - audio
99:46 - here's where we saved the uh here's
99:48 - where we're using the generic audio
99:50 - processor editor
99:52 - here's where we are saving and loading
99:54 - the state
99:55 - and then here's where we are creating
99:57 - our parameter layout
100:00 - all right as i was saying let's go to
100:02 - our header file go up to the top
100:05 - let's declare a compressor band struct
100:10 - let's add an instance of the compressor
100:13 - class to this and make it private
100:18 - now for the ease of initialization i'm
100:20 - going to make the audio parameters
100:22 - public in this class let's just go copy
100:24 - them from our audio processor
100:28 - copy these guys
100:32 - let's make them public
100:35 - next we are going to need some member
100:36 - functions that update the compressor
100:38 - settings that prepare the compressor and
100:41 - that also process audio through the
100:42 - compressor
100:44 - let's declare the prepare function first
100:47 - put that down here
100:48 - it's going to take a process spec object
100:54 - let's prepare our compressor with it
100:58 - now we can update our compressor
101:00 - settings by copying the code from the
101:02 - process block function that we had
101:03 - written earlier so let's do that
101:06 - let's just write this function right
101:07 - here void update compressor settings
101:12 - and then let's go to our process block
101:15 - that's right here
101:18 - and we're going to grab these things
101:21 - and just copy that right over like that
101:25 - okay the same goes for processing audio
101:29 - we are going to copy the code that we
101:30 - used here it's these guys
101:33 - and we just have to remember to pass in
101:35 - a buffer by reference since we will be
101:37 - modifying that buffer
101:39 - so let's declare that here void process
101:43 - juice audio buffer float
101:46 - reference buffer
101:50 - and now we need our block and our
101:51 - context we need to set the bypass state
101:55 - and then process
101:57 - boom
101:58 - now we can replace our compressor and
102:00 - the parameters in our audio processor
102:02 - with one instance of this compressor
102:04 - band class let's do that go way down to
102:06 - the bottom
102:10 - let's comment all of this out
102:13 - and change it to compressor
102:15 - band
102:16 - compressor
102:18 - like that
102:19 - now we need to do a bit of revision in
102:21 - the process block it's right here so
102:23 - let's take care of that
102:25 - it's coming out the old way of using the
102:28 - compressor
102:30 - to come with that stuff out now we just
102:32 - need to call the update function that
102:35 - updates the compressor compressor dot
102:37 - update
102:38 - settings
102:40 - and then pass our buffer directly to the
102:42 - compressor compressor dot
102:44 - process
102:46 - buffer
102:47 - okay the last thing we need to do is
102:49 - configure these parameters
102:51 - like we were doing but um we need to
102:53 - configure these in the constructor but
102:55 - for this object instead of these
102:57 - directly
102:58 - all right we just need to go up to here
103:00 - now we need to make these all say
103:02 - compressor dot attack that sort of thing
103:05 - so these cached parameters now live in
103:07 - the
103:08 - compressor band class so we just need to
103:09 - update these variable names here
103:11 - compressor dot attack like that
103:16 - ratio
103:18 - and bypassed
103:22 - okay let's test it everything should
103:24 - function exactly as it did a moment ago
103:26 - let's try it out
103:29 - all right
103:33 - i got my headphones
103:43 - all right um let's do a quick clean and
103:45 - rebuild just to make sure
103:49 - clean
103:49 - rebuild
103:56 - all right one more time
103:58 - [Music]
104:03 - [Applause]
104:08 - all right that works as expected we can
104:10 - now start to think about
104:12 - how to ride a multi-band compressor now
104:14 - that we have this building block of the
104:16 - compressor band
104:22 - all right let's make a commit now that
104:24 - we have our compressor banned
104:26 - um let's clean up this code
104:28 - let's get rid of this dead stuff too
104:30 - let's see
104:31 - it's gonna be in process block
104:35 - that's down here let's get rid of this
104:40 - okay let's make a commit
104:45 - added compressor band wrapper
104:51 - that's that that's that
104:53 - that's that guy that's that all right
104:56 - and our filter graph stage
104:59 - okay great
105:00 - let's figure out the roadmap for
105:02 - implementing the rest of the dsp in our
105:05 - plug-in
105:06 - let's go to the top we'll put this at
105:07 - the top of the header file there's that
105:09 - file here we go at the very top but this
105:11 - below the fragment once
105:14 - okay
105:15 - road map
105:16 - number one is figure out how to split
105:19 - the audio into three bands figure out
105:22 - how to split the audio into three bands
105:26 - number two is going to be create
105:29 - parameters
105:30 - to control where this split
105:33 - happens
105:35 - number three we need to prove that
105:38 - splitting into three bands produces no
105:41 - audible
105:43 - audible artifacts
105:46 - okay number four we need to create audio
105:50 - parameters for the three compressor
105:51 - bands
105:53 - create audio parameters for
105:56 - the three compressor bands
105:59 - and these need to live on each band
106:03 - instance
106:05 - just like we currently have one
106:06 - compressor band which has
106:08 - the parameters as cached members okay
106:11 - number five we need to create the two
106:14 - remaining compressors
106:16 - create the two remaining not create we
106:19 - need to add the two add two
106:22 - remaining compressors
106:24 - because we already have one
106:26 - all right number six
106:29 - we need to add the ability to mute solo
106:31 - and bypass individual compressors add
106:34 - ability
106:36 - to mute solo bypass individual
106:41 - compressors
106:43 - number seven
106:44 - we need to add input and output gain
106:46 - because compression lowers the output
106:48 - level
106:49 - add input and output gain
106:52 - to offset
106:54 - uh
106:55 - changes in output level
106:59 - number eight we need to clean up
107:01 - anything that needs cleaning up clean up
107:04 - any
107:05 - um
107:07 - anything that needs cleaning up
107:10 - all right that will conclude the dsp
107:12 - side of the plug-in dsp road map
107:16 - okay let's get started on the first one
107:18 - uh figuring out how to split the audio
107:20 - into three bands
107:23 - all right it's time to break out the
107:25 - white board
107:25 - [Music]
107:28 - okay
107:29 - let me erase this graph of how the sound
107:32 - card talks to the process block and the
107:35 - speakers
107:37 - okay
107:38 - sorry for the ring light
107:41 - okay here we go all right we learned in
107:43 - the simple eq project about low pass and
107:46 - high pass filters
107:48 - let's just draw what those are so say
107:50 - we've got
107:50 - um say we've got a
107:53 - filter spectrum like this
107:57 - um here's like
107:59 - here are the different frequency ranges
108:00 - this is like 20 hertz this is
108:04 - 20k
108:06 - all right
108:07 - low pass is
108:09 - eliminating all the frequencies above
108:12 - whatever the crop the threshold is let's
108:14 - say we got something like this so if i
108:15 - go let's say i want to eliminate all the
108:18 - frequencies below
108:20 - let's just call this 1k right here
108:22 - if i want to eliminate all the
108:23 - frequencies i would use a
108:25 - high cut filter which is going to cut
108:27 - out the high stuff and our frequency
108:29 - response will look like this
108:33 - likewise we can have a
108:35 - a low cut which is going to
108:38 - eliminate all of the frequencies below
108:41 - whatever our cutoff is set to let's set
108:43 - it to the same frequency
108:45 - so i will have a filter response like
108:48 - this
108:53 - all right so that's what we learned in
108:54 - simple eq the
108:57 - low pass and high pass or low cut and
108:59 - high cut however you want to think of it
109:01 - okay now if we duplicate our audio
109:04 - buffer
109:05 - we can filter the copies separately and
109:08 - if we set the cutoff of these two
109:10 - filters to the same frequency then we
109:12 - will get a frequency response like this
109:16 - where we have roughly flat except for
109:18 - right here
109:20 - now there's a special type of filter
109:22 - that we can use for the low pass and
109:24 - high pass filters that will actually
109:26 - produce a flat magnitude response when
109:28 - we sum the output of both
109:30 - of both of these filters
109:33 - this is the linquitz reilly filter let
109:35 - me write that here
109:40 - l-i-n-k-w-i-t-z riley
109:44 - filter
109:46 - oh geez that's like a terrible r there
109:49 - we go that looks like an r
109:51 - okay now these are known as audio
109:53 - crossover filters if you have a speaker
109:56 - that has multiple drivers in it it is
109:58 - using some kind of audio crossover to
110:00 - send part of the signal to each of the
110:02 - drivers separately
110:04 - for instance you might have a 10 inch
110:06 - woofer you might have a 5 inch mid-range
110:09 - driver and you might have a two inch
110:10 - tweeter
110:12 - so let me show you um let me move this
110:14 - stuff over here and just draw a quick
110:17 - diagram of the speaker
110:19 - the speaker's crossovers might be set up
110:22 - so that the 10 inch woofer
110:24 - only covers
110:26 - frequencies below
110:28 - 100 hertz let me draw that on here
110:32 - so the uh speakers crossover filters may
110:35 - be set up such that the 10-inch woofer
110:38 - only outputs uh
110:40 - audio that is below 100 hertz
110:43 - so that might be that's this guy right
110:44 - here this might only cover 100 hertz
110:49 - and below which means it's only covering
110:51 - this range
110:54 - like that
110:57 - the 5 inch driver
110:59 - might be set up to only output
111:01 - 100 to 5000
111:07 - that might look like this
111:09 - let's see here's here's 5k right about
111:11 - there
111:17 - and that means the tweeter can only
111:20 - output stuff above well not can the
111:22 - tweeter may be set up so that it only
111:24 - outputs audio above 5000 hertz
111:27 - so this is 5
111:28 - k
111:30 - plus
111:31 - that looks like this
111:35 - let me clean up this line right here
111:37 - because this one's bad
111:48 - okay now on a frequency plot we can see
111:51 - that this is a pretty even distribution
111:53 - the mid-range is doing a decent amount
111:56 - the um
111:58 - little range is kind of handling there
112:02 - now why do we do this
112:04 - the reason is because it's pretty
112:06 - difficult to make a big heavy 10-inch
112:09 - speaker move fast enough
112:12 - to produce frequencies above 5000 hertz
112:16 - right you got all that mass you're
112:17 - trying to move it
112:19 - at a really really fast frequency and
112:21 - it's really difficult it takes a lot of
112:23 - energy to do that
112:24 - likewise it's really difficult to make a
112:26 - small two inch speaker like this tweeter
112:29 - produce any kind of frequency below 100
112:31 - hertz you know all of us are very
112:33 - familiar with listening to
112:35 - audio on our cell phones
112:37 - on the speakers that are built in and
112:38 - there's no bass whatsoever coming out of
112:40 - that tiny little speaker so
112:43 - some really smart people figured out
112:45 - that if we split the signal using these
112:46 - special filters these link with reilly
112:48 - filters
112:50 - we can have much better sounding music
112:52 - come out of our speakers when we
112:53 - dedicate each speaker to a specific
112:56 - frequency range all right now in the
112:59 - juice module there are link with reilly
113:01 - objects that we can use to split our
113:03 - audio into separate bands before we
113:06 - start using those however we need to
113:08 - start creating parameters that can
113:09 - control our filters and compressors
113:12 - so we're going to have a lot of
113:13 - parameters for these compressor bands so
113:15 - it makes sense now to refactor how our
113:18 - audio parameters are being created
113:20 - we don't want to have to type so much
113:22 - code since there will be a lot of
113:23 - repetitive code in the next few sections
113:25 - of this course
113:30 - okay
113:31 - let's get started creating a new
113:33 - approach to declaring our parameters
113:36 - the system we are going to create will
113:37 - let us easily look up the names of our
113:39 - parameters and not have to worry about
113:40 - misspelling anything either which is
113:42 - cool all right let's go to our header
113:44 - file
113:45 - first let's declare a namespace
113:48 - called params let's put this above
113:50 - compressor brand
113:51 - namespace
113:52 - params
113:54 - i am going to add an enumeration and
113:57 - this enumeration will represent all of
113:59 - the parameters that we are going to have
114:01 - in this project
114:03 - we are going to add to it as we add more
114:05 - dsp functionality and add more gui
114:08 - functionality as well for now here is
114:10 - the basic enum
114:11 - i'm going to call it names
114:14 - i'm going to add two entries for the
114:16 - crossover frequency parameter first
114:19 - low
114:21 - mid
114:24 - mid crossover
114:26 - freak
114:28 - and then mid high
114:31 - crossover freak
114:34 - and then i'm going to add entries for
114:36 - the threshold attack release and ratio
114:38 - for each of the three bands
114:41 - finally i am going to add an entry for
114:44 - the ability to bypass each of these
114:46 - bands
114:47 - bypassed
114:50 - band
114:52 - we'll do low mid and high
114:55 - all right now i'm going to create a map
114:57 - that will act as a lookup table for the
115:00 - string name of the parameters if you
115:02 - remember when we create our parameters
115:04 - let's go way down here
115:07 - when we create our parameters we pass a
115:09 - string in
115:10 - okay
115:13 - so we're going to pass in the name's
115:14 - enumeration value and that will give us
115:16 - back our string name that's how this map
115:18 - is going to work so this is going to
115:20 - eliminate the chance of misspelling
115:22 - anything
115:23 - and we'll be able to use autocomplete to
115:25 - choose items from the enumeration when
115:27 - we look up our parameter names
115:29 - as well which is cool so here we go
115:31 - inline const std map
115:35 - we're going to use our names enumeration
115:38 - paired with juice string
115:41 - and this function is going to return
115:42 - this
115:43 - map as a const reference i'm going to
115:46 - call it get params
115:48 - all right now this is what is known as a
115:49 - myers singleton pattern well it's kind
115:51 - of like meyer singleton it's more like a
115:54 - local function
115:55 - singleton pattern first we're going to
115:57 - declare a static map
115:59 - and we're just going to return that map
116:03 - map
116:04 - we'll call it params
116:06 - and we'll declare what it is in just a
116:08 - second
116:08 - and then we will return params
116:11 - okay so now we just need to um supply
116:15 - um
116:16 - pairs for the map so we just need to
116:19 - start declaring them so let's do the
116:20 - first one
116:22 - we're going to use this guy
116:25 - low mid high crossover
116:27 - and then i'm going to provide the name
116:30 - for what i want this parameter to
116:31 - actually be called
116:32 - low
116:33 - mid
116:34 - crossover freak
116:37 - when see
116:38 - i'll just do free so it's all within one
116:40 - line
116:41 - okay we just need to do this
116:43 - for
116:45 - all of these guys here
116:47 - so i'm going to copy this
116:57 - all right last is to add a
117:00 - oops we need to add commas at the end of
117:02 - all these
117:06 - there's our map now what is interesting
117:08 - about this pattern is that this static
117:10 - map that we've got right here it does
117:12 - not get created until we actually call
117:14 - this function so that's pretty handy
117:17 - okay let's update our existing
117:19 - parameters to use this map now
117:22 - so we need to change where the
117:23 - parameters are created and also where
117:25 - they are assigned to the current
117:27 - compressor band so let's do that first
117:30 - all right head on over to the create
117:32 - parameter layout function i'm going to
117:33 - switch from using um
117:36 - i'm going to get rid of the assistant
117:37 - editor all right head over to
117:38 - pluginprocessor.cpp
117:41 - and go to create parameter layout
117:43 - i'm gonna save myself a lot of time by
117:46 - adding the namespace alias right here
117:49 - not alias by using the using keyword
117:54 - and i'm going to get a local reference
117:56 - copy of the parameters map
117:59 - const auto params equals get params
118:03 - now i just need to replace all of these
118:05 - strings with
118:08 - the correct entry in the map and i'm
118:09 - going to set all these as though they
118:11 - were being assigned to the low
118:13 - compressor band so the first one becomes
118:16 - params.at
118:18 - names
118:20 - threshold low band
118:24 - let's do the same thing for the attack
118:26 - and the release
118:28 - and change this to attack low band
118:31 - attack low band
118:33 - and then for the release
118:35 - let's fix this indentation as well
118:39 - this is release low band
118:42 - next we need to do our ratio
118:45 - let's put these on separate lines
118:47 - copy these guys right here
118:53 - ratio low band
118:56 - and then finally the bypassed
118:58 - bypass low band
119:00 - bypass low band
119:02 - all right that was easy enough let's
119:04 - revise our um constructor where we
119:07 - initialize the cached parameters next
119:09 - head on up to the constructor
119:12 - we're going to do the same trick i used
119:14 - before of using
119:16 - the namespace and caching the
119:19 - sorry not caching but getting a local
119:21 - reference copy of the params map using
119:24 - namespace
119:26 - params const auto params equals get
119:30 - params
119:31 - if we look at our enumeration in the
119:33 - params class
119:34 - we have a lot of float parameters and
119:37 - the plan is to add solo and bypass
119:39 - functionality as well as mute which are
119:42 - boolean parameters and i don't want to
119:44 - have to keep typing this casting code
119:45 - more than i need to so let's write a
119:47 - helper function
119:49 - to do that let's go back to our
119:50 - constructor you can see what i'm talking
119:51 - about i don't want to have to write this
119:53 - line more than i need to
119:56 - okay so let's write a helper function
119:58 - we're going to use an in place lambda
120:00 - and i'm going to capture all the stuff
120:01 - that i use in the lambda by reference
120:04 - call this float helper
120:07 - auto float helper
120:09 - equals lambda lambda lambda
120:12 - all right we're going to need to capture
120:14 - the ap vts because we're using that to
120:16 - look up the parameters
120:18 - so actually let's do this let's um
120:20 - let's copy these lines into here and
120:23 - we'll adjust what we've got so we're
120:25 - going to change this to say param equals
120:28 - that
120:28 - and then we'll just say param is not an
120:30 - alternator no pointer param
120:33 - and then for this we wanted to say uh
120:35 - params at
120:38 - name like that
120:40 - or we can do program name
120:43 - okay so what do we need to capture let's
120:45 - capture apbts
120:47 - apvts equals this abvts
120:51 - we need to capture the params
120:53 - capture those guys capture these guys by
120:55 - reference
120:56 - now we need to pass in the parameter
121:00 - this thing right here
121:02 - so we'll just use auto
121:04 - and then we also need to pass in the
121:05 - param
121:06 - name autopram name
121:13 - all right cool unused variable let's use
121:16 - it now
121:17 - i'm using auto here because i want the
121:19 - compiler to figure it out and you can do
121:20 - that with lambdas which is pretty cool
121:22 - again all of these are being treated as
121:24 - though they are
121:26 - being attached to the low filter band
121:29 - the first one we're going to do is the
121:30 - attack param so do float helper
121:33 - and our
121:34 - parameter is compressor dot attack
121:37 - and then our parameter name is the
121:39 - names low band
121:42 - attack
121:44 - okay
121:45 - that takes care of this
121:49 - now we need to do the release param
121:52 - that takes care of this
121:55 - and now threshold
121:57 - that takes care of this
122:00 - now i just need one for the choice
122:02 - parameter and the boolean parameter
122:04 - and remember we're going to have three
122:06 - different choice parameters because
122:07 - we're going to have three different
122:08 - compressors with ratios and a boolean
122:11 - one for the bypassed mute and solo so it
122:14 - makes sense to just create it now so i'm
122:16 - just going to copy this and we're just
122:18 - changing with the cast
122:20 - we're just changing the cast that gets
122:21 - used really so this is going to be audio
122:24 - parameter
122:25 - bool
122:26 - uh not but we're doing choice first
122:29 - choice
122:30 - so this is the choice helper
122:34 - we can call it
122:36 - choice helper
122:37 - we got compressor dot ratio
122:41 - and our param name is names
122:44 - uh ratio low band
122:46 - all right that takes care of this guy
122:48 - and now let's add our
122:50 - uh boolean helper
122:52 - duplicate paste
122:55 - bool helper
122:57 - change the cast type
123:02 - and now we just call it bullhelper
123:05 - compressor.bypassed and we got names
123:08 - bypassed low band
123:12 - all right let's run it just to make sure
123:14 - everything works as expected
123:18 - all right my headphones
123:20 - we're going to adjust all the parameters
123:21 - and see if they work the way they should
123:24 - or if we get a js or false
123:27 - all right node.jser that's cool
123:29 - when you make big changes like this
123:30 - sometimes you need to recompile the code
123:32 - so let's do a you need to clean it out
123:34 - and recompile it from scratch so let's
123:36 - do that
123:44 - all right here we go
123:49 - change that to 50
123:52 - drop that down
123:56 - [Music]
124:03 - all right that works for me
124:05 - save quit
124:07 - all right awesome all the controls are
124:09 - doing what they're supposed to be doing
124:10 - all right if you were curious as to why
124:12 - when we loaded this up our previous
124:14 - parameter settings were no longer found
124:17 - it's because we changed parameter names
124:19 - so they
124:20 - fell back to their default values
124:22 - okay
124:23 - onward
124:27 - let's make a commit of our changes let's
124:30 - see what we've done
124:31 - added
124:33 - road
124:34 - added road map and params
124:37 - namespace
124:39 - all right that's that
124:41 - and then we added where we use our
124:43 - params and all that good stuff
124:46 - okay
124:47 - now let's uh go to our roadmap
124:50 - let's tackle this guy right here figure
124:53 - out how to split the audio into three
124:55 - bands
124:57 - i had mentioned link with riley filters
125:00 - earlier now we're going to use them
125:03 - let's go look at the documentation for
125:04 - this class okay it says that um these
125:09 - are used in audio crossovers that have
125:11 - two outputs a low pass and a high pass
125:13 - such that there's some
125:15 - is equivalent to an all pass filter with
125:17 - a flat magnitude frequency response
125:21 - remember this it's they're talking about
125:23 - this like the response of the filter
125:25 - when you sum them together gives you a
125:27 - flat response
125:29 - okay they are saying that summing the
125:32 - output of two filters is identical to
125:35 - the same result you would get if you ran
125:37 - your audio through an all pass filter
125:39 - we are going to use that information
125:41 - later when we prove that the filters do
125:43 - not add any audible artifacts to the
125:46 - signal for now here is what we need to
125:48 - know we can split the audio into two
125:51 - bands using the
125:52 - juice linquit's reilly filters
125:55 - low band and high band once we do that
125:58 - we need to split one of these bands into
126:00 - two other bands
126:02 - that comes with its own set of problems
126:04 - that we need to deal with so for now
126:06 - let's just get a high band and a low
126:08 - band working first before we add a mid
126:11 - band okay so let's go down to our plugin
126:14 - processor dot h so we're going to go to
126:16 - our private section
126:18 - of plug-in processor
126:20 - way down at the bottom
126:22 - we're going to do this after our
126:23 - compressor band
126:25 - let's declare two instances of this
126:27 - linquist reilly filter i'm going to use
126:29 - an alias to make typing it easier using
126:31 - filter equals juice dsp
126:35 - link widths
126:36 - riley
126:38 - come on auto complete
126:41 - filter
126:42 - float
126:44 - all right give me two instances filter
126:46 - low pass high pass
126:49 - all right we are also going to need a
126:50 - cached audio parameter for the crossover
126:53 - frequency
126:54 - juice audio parameter float
126:58 - low crossover
127:01 - little pointer
127:02 - all right each of these filters modifies
127:05 - the audio
127:07 - if we low pass our process block buffer
127:11 - then high pass filtering it will not
127:13 - give us the expected results here's my
127:15 - audio band
127:19 - okay we're doing low pass and high pass
127:21 - so if we low pass a bunch of signal like
127:24 - this
127:25 - this is what's left in the buffer
127:27 - okay this stuff right here this is
127:29 - what's left in the audio buffer right we
127:32 - originally had
127:33 - you know this was full spectrum
127:36 - and then
127:38 - you know we chopped out all of the high
127:40 - pass we did a low pass which kept all of
127:42 - the low frequency and everything above
127:44 - it got cut now if we try to high pass
127:45 - this
127:46 - at the same frequency
127:49 - you know we're trying to
127:50 - cut out everything below
127:53 - you know let's say this is our high pass
127:55 - that means we're trying to cut out
127:57 - everything below this point but there's
127:59 - nothing here this is all gone so the
128:01 - only thing we're gonna get left with
128:04 - is this chunk right here
128:06 - that's not what we want
128:09 - that is not the result that we want to
128:10 - have okay so what we need to do is use
128:13 - separate buffers and these are what
128:15 - we're going to sum later as the
128:17 - documentation said if you sum the
128:19 - results together you'll get a flat
128:21 - magnitude response
128:23 - all right let's declare an array of
128:26 - buffers std array
128:29 - juice audio whoops let's spell that
128:31 - right audio buffer float two of them
128:35 - filter buffers
128:36 - let's spell that right
128:39 - okay let's create a filter parameter
128:42 - next and then initialize it and then
128:44 - prepare our filters and buffers
128:46 - head over to
128:48 - pluginprocessor.cpp create parameter
128:51 - layout let's do this at the bottom after
128:53 - we make our bypass param
128:59 - layout.add
129:00 - here we want std make unique
129:03 - we want an audio parameter float
129:08 - all right we are going to set the
129:10 - crossover's range to be the auditory
129:12 - range of human here of human hearing 20
129:15 - hertz to 20 000 hertz and we're going to
129:18 - set the default frequency to 500
129:21 - okay so first things first let's provide
129:23 - our um
129:24 - our names so params.at
129:27 - names
129:28 - crossover low mid
129:32 - right copy that
129:34 - duplicate it
129:37 - let's give our default value of 500
129:41 - and then we need a normalizable range
129:44 - normalizable range
129:46 - our range start
129:49 - will be 20 our range end will be 20 000.
129:54 - our interval value will be 1
129:56 - meaning our
129:58 - value can change in increments of one
130:00 - hertz so 20 21 22 23 all the way to 20
130:04 - 000 and our skew will be one
130:08 - next let's initialize our parameter
130:11 - go on up to the constructor
130:14 - can use our helper for that float helper
130:16 - let's put this at the bottom
130:18 - float helper we are initializing our low
130:21 - crossover
130:23 - with the names low crossover
130:26 - awesome
130:28 - now we need to prepare our filters so go
130:30 - to prepare to play
130:34 - let's do this here lp dot prepare
130:37 - spec
130:39 - high pass dot prepare spec
130:43 - and now we need to prepare our buffers
130:46 - so that they don't allocate whenever we
130:48 - copy the input buffer into them let's do
130:50 - that next for
130:52 - auto buffer filter buffers
130:55 - buffer dot set size
130:57 - the number of channels is spec.num
131:00 - channels number of samples is samples
131:02 - per block
131:05 - all right let's go to process block now
131:08 - let's disable the uh compressor while we
131:11 - mess with these um while we mess with
131:13 - these filters for a little bit
131:14 - comment those guys out
131:17 - first
131:18 - let's copy our incoming buffer into
131:20 - these dedicated filter buffers for auto
131:23 - filter buffer
131:25 - filter buffers
131:28 - fb equals buffer
131:31 - each buffer in our filter buffers array
131:33 - now contains a copy
131:35 - of the
131:36 - input of the buffer that we were given
131:39 - from the sound card
131:41 - all right next we will update our
131:43 - filters cut offs both of the filters are
131:45 - going to share the same cut off so auto
131:47 - cut off
131:49 - equals low crossover get
131:53 - now we can do lp dot set cutoff
131:56 - cut off
131:58 - then hp dot set cutoff
132:01 - cut off
132:04 - now we must create blocks and contexts
132:07 - for the filters all right so we do auto
132:10 - fb0
132:11 - block filter buffer zero block equals
132:15 - okay so we've got one
132:17 - audio block pointing to the first filter
132:19 - buffer and then another audio block
132:21 - pointing to the second filter buffer now
132:23 - we can create our context
132:25 - all right just initialize each context
132:28 - from the appropriate filter block
132:31 - and now we can process our audio lp dot
132:34 - process lp gets the first filter buffer
132:36 - of the two
132:38 - fb0 context
132:40 - hp
132:41 - dot process
132:43 - fb1 dot context oops
132:46 - no dot
132:47 - okay
132:49 - now that our input buffer has been
132:51 - turned into
132:52 - two separate buffers each of which has
132:54 - been filtered separately we need to sum
132:56 - them back into a single buffer
132:59 - now in order to ease some of this
133:01 - struggle with copying let's cache some
133:03 - of the details of the
133:06 - input buffer so auto num samples equals
133:09 - buffer dot get num samples
133:12 - auto num
133:13 - channels
133:15 - equals
133:16 - buffer.get whoops let's spell that right
133:19 - getting them channels
133:22 - and we need to clear our input before we
133:25 - start um adding our filter buffers to it
133:29 - so buffer dot clear
133:34 - okay each channel of our filter buffer
133:36 - needs to be copied back to the input
133:38 - buffer so i'm going to write a helper
133:40 - function to do that i'm going to use a
133:43 - use a lambda in here to do it
133:45 - auto add filter band
133:47 - equals
133:49 - lambda lambda lambda
133:52 - first thing
133:53 - let's see first thing we're going to do
133:54 - is create a parameter for our input and
133:57 - then
133:58 - a parameter for the source that we're
134:00 - going to copy from so here's our input
134:03 - buffer
134:04 - input buffer
134:06 - and then where we're going to copy from
134:08 - so const auto source
134:11 - all right now we just need to simply
134:13 - loop through all of the channels that
134:14 - were in the input buffer and copy
134:17 - from a source buffer into that so we can
134:19 - do 4
134:20 - auto i equals 0. i is less than
134:24 - num channels is what we want so let's
134:26 - capture that by copy
134:28 - num channels
134:30 - eyes let's numb channels
134:34 - plus plus i
134:36 - now we can do input buffer dot
134:38 - add from
134:41 - and let's see what are our parameters
134:43 - let's see buffer
134:44 - dot add from
134:47 - let's do this okay our destination
134:48 - channel is going to be i our destination
134:51 - start sample is going to be 0.
134:54 - so let's just do this we're going to do
134:56 - i
134:57 - we're going to do 0 our source is going
134:59 - to be the source
135:01 - source channel is going to be i
135:03 - star source start sample is going to be
135:06 - 0 and then our num samples is going to
135:08 - be
135:09 - um this because buffer and the source
135:13 - have the same number of channels so
135:15 - we'll just call that ns
135:18 - all right
135:18 - this is what we add here
135:21 - like that
135:24 - all right and we need to capture n
135:26 - s
135:27 - n s equals num samples
135:30 - okay
135:32 - and just to go over that so we are
135:33 - capturing our num channels and num
135:35 - samples we are passing in
135:38 - this guy we're going to pass it in as a
135:40 - parameter and we're going to copy every
135:42 - single channel from the source one at a
135:44 - time
135:45 - and add it to our input buffer
135:48 - now we just need to call this helper
135:49 - function with our filter buffers
135:51 - add filter band our input buffer is
135:55 - buffer and our source is filter buffers
136:00 - zero
136:02 - add filter band buffer
136:05 - filter buffers
136:07 - second one
136:09 - all right perfect
136:10 - let's run this and see what happens
136:14 - grab my headphones
136:18 - all right
136:19 - [Music]
136:22 - okay all the top end is gone
136:25 - let's go figure out why that happened
136:28 - let's go look at how this class gets uh
136:30 - created
136:31 - all right
136:32 - we have a type parameter sets the filter
136:34 - type well we didn't do that let's see
136:36 - what type this thing defaults to
136:41 - all right default filter type low pass
136:44 - so that makes sense we're basically
136:46 - running our audio
136:48 - uh this is low passing it and then this
136:50 - is also low passing it at the same
136:52 - frequency let's solve that we need to
136:54 - call that set um set type function let's
136:57 - do that in the constructor
136:59 - going up to the constructor
137:01 - all right go down to the bottom let's
137:03 - configure our filters lp dot set type
137:08 - here we go juice dsp
137:10 - link what's riley filter
137:13 - all right now our lp is low pass and
137:16 - then let's do it again for the high pass
137:21 - this is hp
137:23 - and this is high pass
137:26 - all right let's test this again now
137:28 - remember we don't have our compressors
137:29 - turned on so we're literally just going
137:31 - to hear this filtering
137:33 - the result of our audio going through
137:35 - the lp and the hp filters
137:37 - here we
137:40 - go all right no audible um no audible
137:44 - effects to me
137:46 - if we adjust the slider which is
137:48 - adjusting the crossover
137:51 - nothing no audible effects so that's
137:53 - fantastic
137:56 - all right perfect we are halfway through
137:58 - splitting the audio into three bands
138:01 - before we go further let's prove that
138:03 - our filters are producing no audible
138:05 - artifacts
138:06 - we will also demo that the filters are
138:09 - actually doing something by soloing each
138:11 - one we'll do all that stuff next
138:15 - let's make a commit of our progress it's
138:18 - always a good idea to do that what did
138:20 - we do
138:21 - we added
138:23 - link with
138:24 - riley
138:26 - filtering
138:27 - here's what we did all the processing
138:29 - here's where we set up our filters
138:30 - that's where we prepared them
138:32 - here's what we processed with them
138:34 - here's where we created the parameter
138:36 - let's go back here let's save and quit
138:39 - this
138:40 - okay we can bypass the filtering by
138:43 - exiting the process block
138:45 - before we clear our input buffer and
138:47 - copy our filter buffers to it it's just
138:50 - temporary but we can use our single
138:52 - compressor's bypass parameter to control
138:54 - this
138:55 - alright the purpose is just to show that
138:57 - the filters don't introduce any audible
138:59 - effects
139:00 - when the buffer copy step is bypassed we
139:03 - are listening to the input buffer still
139:05 - and when it's not bypassed we are
139:08 - listening to the sum of the filter
139:09 - buffers being copied into the input
139:11 - buffer so this is very easy to write
139:15 - we just need to do it after this num
139:16 - channel so we can just say if compressor
139:19 - dot bypassed
139:21 - if it's bypassed um don't clear just
139:24 - leave the function
139:26 - right we've done our filtering but we're
139:28 - not clearing our buffer and we're not
139:30 - copying stuff into it okay
139:32 - okay here is how we can prove that this
139:34 - is actually what is happening let's run
139:36 - this
139:38 - okay first things first make sure this
139:39 - bypass low band is toggled on
139:43 - next let's add a breakpoint right on
139:45 - buffer.clear now if we press play
139:49 - notice that the breakpoint does not get
139:51 - hit and it's not until we
139:53 - uncheck the toggle button that it
139:54 - actually gets hit and this is going to
139:56 - cause like some weird audio stuff but
139:59 - you know just bear with me
140:04 - okay here we go gonna unbypass this
140:07 - all right hit the breakpoint
140:10 - so let's remove the breakpoint
140:15 - all right now we can stop our audio
140:17 - okay
140:18 - but that proves uh the point i try i was
140:21 - trying to make that our audio is
140:23 - actually running through our filters and
140:25 - we can hear the difference between if
140:27 - it's um
140:28 - between if we're hearing just like the
140:30 - raw buffer input or if we're hearing our
140:32 - filtered input okay
140:35 - all right let's talk about this
140:35 - crossover filter and one of the special
140:37 - properties of it when you have a pair of
140:40 - these filters like we have here
140:42 - and you sum their output like we are
140:44 - doing here
140:46 - the result is the same as though you had
140:49 - run your signal through an all pass
140:51 - filter with the same cutoff frequency
140:54 - i want to show you what i mean by that
140:56 - so let's add an all pass filter and then
140:59 - demonstrate toggling it with our lp and
141:02 - hp filters so we can see how they sound
141:04 - the same okay let's go to our header
141:06 - file
141:07 - let's go down here to our filter
141:10 - let's add another filter filter ap like
141:13 - that for all pass filter and now it
141:15 - needs its own buffer so let's give it
141:17 - one of those
141:18 - juice
141:19 - audio buffer
141:21 - float
141:22 - ap buffer
141:24 - all right we will prepare it and set the
141:26 - type next
141:27 - let's go to the prepare to play function
141:30 - prepare to play
141:32 - let's do
141:33 - ap dot prepare
141:35 - spec
141:36 - all right let's uh set the buffer size
141:39 - ap buffer dot set size
141:42 - spec.num channels
141:44 - samples per block
141:46 - all right let's go set the type in our
141:47 - constructor we learned our lesson from
141:50 - the first time we messed with these
141:51 - filters and
141:52 - we're going to make sure we're going to
141:53 - set that type now
141:55 - ap dot set type whoops
141:58 - set type
142:00 - juice
142:01 - dsp let me just copy this
142:04 - all pass
142:06 - next we will make our process block
142:08 - toggle between our low pass and high
142:10 - pass doing the filtering versus our
142:13 - all pass doing the filtering and we're
142:15 - going to use that bypass parameter
142:17 - like we used earlier because it's you
142:19 - know it gives us a toggle button that we
142:21 - can just easily click on and off
142:23 - okay let's go do that next alright let's
142:25 - go to our
142:27 - process block let's get rid of this
142:29 - bypass code let's just comment it out
142:31 - for now
142:34 - now we can copy our input buffer to our
142:37 - all pass buffer ap buffer equals in uh
142:41 - buffer
142:43 - okay we got to make sure we do that
142:44 - before we clear
142:46 - all right let's do the same processing
142:48 - you know we're going to create a block
142:49 - and a context and then process with the
142:51 - filter
142:53 - so i'll just grab these two lines right
142:54 - here and i will just rename them
142:57 - this is ap block
143:00 - and then this will be ap block
143:03 - this is going to be ap buffer
143:06 - and then this will just call this a
143:09 - all pass context
143:12 - and let's do our processing ap dot
143:14 - process ap
143:16 - context all right now we can revise our
143:19 - logic that does the copying
143:22 - if the bypass toggle is unchecked use
143:25 - the low pass and high pass buffers
143:28 - otherwise use the all pass buffer
143:31 - so if
143:33 - compressor
143:35 - bypassed
143:37 - get
143:38 - if that toggle button is
143:41 - unchecked
143:42 - use these guys
143:45 - otherwise
143:46 - add filter band buffer
143:48 - from the ap buffer
143:52 - this logic will let us hear the lp and
143:55 - hp buffers by default we already know
143:58 - that they don't add audible artifacts
144:00 - and toggling this checkbox will show
144:02 - that the ap buffer produces the same
144:04 - result so let's test this out we're
144:06 - going to just run this we're going to
144:08 - toggle the thing on and on
144:10 - on and off
144:12 - let's grab our headphones
144:16 - all right so let's play it
144:18 - turn this down
144:23 - so if i toggle this
144:31 - all right let's push stop real quick
144:33 - now we can confirm that it's working by
144:35 - making sure bypass is unchecked and then
144:38 - setting a breakpoint in the else block
144:42 - let's press start once we click that
144:44 - check box the break point will be hit
144:50 - perfect
144:51 - this is expected
144:54 - show all the dewey
144:57 - okay so that works as expected
145:01 - so let's investigate soloing the low and
145:04 - the high bands next okay our compressors
145:06 - will be able to compress either band so
145:08 - it's important to know what these bans
145:11 - sound like
145:13 - let's check that out next
145:14 - all right soloing one of these bands is
145:16 - really easy
145:18 - we just need to comment out which buffer
145:19 - gets added to the input so let's solo
145:22 - the low pass output by commenting out
145:25 - the second line
145:28 - all right we can toggle between hearing
145:29 - the all pass filter and the low pass
145:31 - filter using our check box let's run
145:33 - this
145:46 - oh you know what we can adjust this
145:51 - there it goes
145:53 - i was wondering why i wasn't doing
145:55 - anything because i had this this cutoff
145:57 - way up high
145:57 - [Music]
145:59 - all right so right now we're listening
146:00 - to the low filter uh the low pass band
146:03 - now we're listening to the all pass
146:06 - all right
146:07 - cool
146:08 - save that quit
146:10 - all right let's do it again and switch
146:12 - to the high pass okay so uncomment this
146:15 - one
146:16 - all right sorry comment the first one
146:18 - out and then uncomment the second one
146:21 - let's run and test
146:23 - all right we'll drag the same crossover
146:24 - slider again so we can change how much
146:26 - bottom end is actually cut out of the
146:28 - signal
146:31 - [Music]
146:38 - [Music]
146:47 - all right
146:49 - all right so there you go so that is how
146:52 - soloing and the muting of the bands
146:54 - works okay it's all about figuring out
146:55 - which buffer you want to copy to the
146:58 - input
146:59 - all right so we're going to do one more
147:00 - little test with these audio filters
147:02 - next
147:03 - okay the final test that we will do is
147:05 - to sum the inverse of the all pass
147:07 - filter with the
147:09 - output of the low pass and high pass
147:11 - filter the purpose of this is to show
147:14 - how the two outputs sum to zero or
147:17 - silence
147:18 - again we will be using the bypass switch
147:20 - to toggle
147:21 - between this behavior versus hearing the
147:23 - output of the low pass and high pass
147:25 - filters so let's comment out
147:28 - this code actually let's copy this first
147:30 - because we're gonna need this let's copy
147:31 - this now we can comment this out
147:35 - all right now paste this here okay we
147:37 - are going to always copy the output of
147:39 - the filters into our m into those buffer
147:43 - that we were given by the audio
147:45 - audio
147:46 - system
147:47 - okay now if the bypass switch is turned
147:49 - on we will invert the all pass filter
147:52 - buffer and add that to the output
147:55 - we can do that by going if compressor
147:58 - dot bypassed
148:00 - get
148:01 - if the switch is toggled on
148:04 - then we need to invert every channel in
148:06 - our all pass buffer
148:09 - and then add that to the filter band so
148:11 - let's let's set up the add band first
148:13 - add filter band
148:15 - buffer we're copying from the all pass
148:18 - buffer
148:19 - okay
148:20 - and now we just need to invert so let's
148:22 - do this for every channel and we can do
148:24 - this using float vector operations so
148:26 - four auto ch equals zero ch is less than
148:30 - num channels
148:32 - plus plus ch
148:33 - now we can do juice
148:35 - float vector operations and there's a
148:38 - there's a way that we can multiply a
148:39 - fixed value against every sample in a
148:42 - particular channel so we're going to use
148:43 - that multiply and we want the one that
148:46 - takes a multiplier
148:49 - okay our destination is going to be
148:52 - a right pointer to one of the channels
148:54 - in the ap buffer so ap buffer dot get
148:57 - right pointer because we want to be able
148:58 - to modify this buffer that's why
149:01 - um our channel number is ch our
149:03 - multiplier will be negative one
149:05 - to flip it upside down and we're going
149:07 - to do this for every sample so num
149:09 - samples
149:11 - all right now that they are inverted um
149:14 - we already we're already adding them
149:16 - over okay so now the next thing to do
149:19 - and this is actually something we forgot
149:20 - to do earlier um is to go up to where we
149:23 - are setting our cutoffs and we need to
149:25 - set the all pass filter to that have the
149:27 - same cutoff
149:30 - as the other filters
149:32 - we forgot to do this earlier so when we
149:34 - were dragging the slider back and forth
149:36 - yeah just a fluke that um
149:38 - it didn't sound audibly different to me
149:41 - let's go to the last step we can test
149:43 - this out now and if it works as expected
149:46 - we will hear silence when we toggle the
149:48 - bypass switch let's check it out
149:52 - all right
149:53 - [Music]
149:57 - silence there we go and if we adjust the
149:59 - frequency
150:01 - [Music]
150:04 - silence
150:06 - all right awesome
150:08 - so that is doing what it is supposed to
150:09 - do
150:11 - okay let's learn a little bit more
150:13 - theory about this whole lp plus hp
150:16 - versus the all pass filtering and how we
150:18 - can use this to make three separate
150:20 - audio bands that some to produce a
150:23 - signal with no audible artifacts
150:26 - once we have this knowledge we will
150:28 - implement it and check off item one in
150:30 - the dsp roadmap
150:35 - let's make a commit of our progress from
150:38 - uh working on this filter stuff before
150:40 - we start diving into
150:41 - filter band theory
150:43 - all right what did we do oh we have to
150:45 - fill the graph okay we um
150:48 - uh tested
150:50 - using
150:52 - all paths filter that's basically what
150:54 - we did we got our filter here and our
150:56 - filter buffer here's where we set up the
150:59 - filter type here's where we prepared it
151:01 - here's where we set the cut off here's
151:03 - where we did our processing
151:05 - and then here's where we did the
151:07 - inversion to
151:10 - basically cancel out the regular
151:12 - filtering
151:14 - that's what's going on there all right
151:16 - all right let's talk about filter band
151:18 - theory
151:19 - all right let's discuss some theory
151:20 - behind these filters before we create
151:22 - the three band splitter
151:24 - filters work by delaying part of the
151:28 - signal let me get this more on camera
151:30 - we've got a pair of filters here a pair
151:32 - of linguists riley filters we got low
151:34 - pass one and high pass one
151:36 - okay every time we filter the signal we
151:38 - introduce a delay now i don't know how
151:41 - the math of this delay actually works
151:43 - and that's beyond the scope of this
151:44 - video
151:45 - that's what they end up doing in the
151:46 - math is they apply delays to certain
151:49 - frequencies in the spectrum and that's
151:51 - how you end up getting that stuff to be
151:53 - muted
151:54 - so when we split the signal into low
151:56 - pass and high pass bands we are
151:57 - introducing the same delay
152:00 - so to speak to both parts and then when
152:02 - we run the signal through an all passed
152:04 - filter the same delay is produced of
152:07 - course that's assuming the all pass
152:08 - filter the low pass and the high pass
152:10 - all have the same cutoff frequency
152:13 - so that means that we can use an
152:15 - all-pass filter to equate this same
152:18 - delay okay
152:19 - so whenever we have a pair of these we
152:21 - can replicate that same delay by using
152:23 - an all-pass filter okay now we can use
152:25 - this to our benefit we can split our
152:27 - signal into two bands like we're
152:29 - currently doing
152:30 - and this split will just add one delay
152:32 - to the signal you know delay so to speak
152:35 - okay
152:36 - if we then split one of these bands into
152:40 - another delay
152:42 - we will end up with three bands let me
152:44 - show you what i mean all right so check
152:46 - it out we've got our three bands here
152:48 - this band this band and this band
152:50 - okay that's what we're trying to
152:51 - accomplish three bands however the
152:53 - problem is that
152:55 - lp1's output the signal that runs
152:58 - through this chain only has one delay
153:02 - whereas the signal that is split from
153:05 - high pass one this guy and this guy
153:08 - there are two delays and that means that
153:09 - our signals will not sum
153:11 - correctly okay
153:13 - now as we learned earlier the all pass
153:15 - filter introduces the same delay as this
153:18 - so all we need to do is replace this
153:20 - line
153:22 - you just we just need to add an all pass
153:24 - filter here
153:26 - set to the same cutoff frequency
153:28 - as these two filters
153:30 - and we will have
153:31 - a um
153:33 - we'll have our solution
153:35 - so this is the solution that we need to
153:37 - use okay we just run lp1 through an all
153:39 - pass filter and that gives us
153:41 - an output that has the same number of
153:43 - delays as the other
153:46 - uh signals over here okay
153:48 - so the low pass one to
153:50 - all pass two
153:52 - contains all of the audio be low filter
153:54 - cut off zero
153:55 - and then the uh high pass one to low
153:59 - pass two contains all of the audio
154:01 - between filter cutoff 1 and filter
154:03 - cutoff
154:04 - 0
154:05 - this range right here
154:07 - and then
154:08 - high pass 1 into high pass 2 contains
154:10 - all of the audio at filter cut off 1.
154:12 - all right so there we go three bands
154:15 - that sum to a flat filter response okay
154:17 - and we can prove that this null's out by
154:19 - creating two more all pass filters set
154:21 - to filter cut off zero and filter cut
154:23 - off one
154:24 - and inverting their output and then
154:26 - summing it with the output of these
154:28 - three bands okay all right in project 12
154:31 - you will learn how to dynamically create
154:34 - uh n number of bands you'll learn how to
154:36 - figure out okay if i have seven bands
154:38 - how many all-pass filters do i need how
154:40 - many low-pass filters do i need how many
154:42 - high-pass filters do i need and um how
154:45 - do i structure them so that way it can
154:47 - all sum together and can all
154:49 - do everything that it's supposed to do
154:51 - my computer can handle about eight
154:53 - filter bands when i'm in debug mode
154:55 - maybe yours can handle more than that
154:57 - but it's a really really interesting
154:59 - problem to solve and is very cool
155:02 - so let's code that up next and
155:05 - begin filtering
155:09 - let's restructure our filtering i find
155:12 - that it helps to declare them visually
155:13 - in the same way that they will be
155:15 - structured i'm also going to write the
155:17 - name of the cutoff parameter that will
155:19 - control that particular
155:21 - group of filters
155:22 - above that filter itself
155:24 - so let's get rid of our old filters and
155:26 - the buffers and stuff and start writing
155:28 - this first all right here we go so
155:30 - filter
155:31 - uh we've got an lp1
155:35 - and an ap2
155:37 - all right that's part one we've got hp1
155:40 - and that feeds into lp2 and then we've
155:44 - got our hp2 on the bottom
155:46 - so that guy let's add these cutoffs next
155:51 - here we've got our fc0 filter cutoff 0
155:54 - and filter cutoff 1.
155:56 - let's rename this crossover
155:58 - and add another one for the mid high
156:02 - right click refactor rename
156:06 - i'm going to call this the low mid
156:09 - crossover
156:10 - all right let's duplicate this
156:13 - this is going to be the mid-high
156:14 - crossover
156:16 - mid
156:17 - high crossover
156:19 - finally we can give ourselves a third
156:22 - filter buffer because we have three
156:23 - bands
156:24 - let's add another parameter for the
156:26 - mid-high crossover then we will set our
156:28 - filter types and then prepare our
156:30 - filters and then use our filters
156:34 - head over to
156:35 - pluginprocessor.cpp go down to create
156:38 - parameter layout go all the way to the
156:40 - end where we create the low mid
156:42 - crossover
156:43 - copy and paste it
156:46 - and change this to the mid high
156:48 - crossover frequency
156:51 - all right now while we are here i'm
156:53 - going to change the range of the
156:55 - crossovers so they do not overlap
156:58 - so this first one is going to go from 20
157:00 - hertz to 999 hertz
157:03 - i'm going to change the default to
157:05 - 400
157:07 - and then for the second one it's going
157:08 - to have a range of 1000 to 20 000 hertz
157:12 - and the default value will be
157:14 - 2 000 hertz
157:17 - all right let us set our filter types
157:19 - next and then initialize our cached
157:22 - crossover variables
157:24 - head up to the constructor
157:27 - all right let's go to
157:29 - let's do our cached value first
157:32 - so float helper we're doing the mid high
157:35 - crossover names
157:38 - mid high
157:40 - now let's tackle these errors we just
157:42 - need to rename these types so it's lp1
157:45 - now and hp1 and then it's ap2
157:48 - and then this just needs to be
157:50 - duplicated
157:52 - for lp2 and hp2
157:56 - alright cool let us go prepare these
157:58 - next head over to prepare to play
158:02 - again renaming the old filters this is
158:04 - lp1 this is hp1 and this is ap2
158:10 - and just copy these and rename
158:13 - we've got lp2 and hp2
158:18 - all right we don't have an all pass
158:19 - buffer anymore so this line gets removed
158:22 - all right let's configure some 3-band
158:25 - filtering
158:26 - next over to process block
158:31 - the first thing to do is to configure
158:33 - the filter cutoffs so the low mid cutoff
158:36 - is applied to lp1
158:39 - and hp1 all right let's rename this
158:42 - parameter as well refactor rename
158:46 - and this is low
158:47 - mid
158:49 - cutoff
158:51 - the mid high cutoff is applied to lp2
158:55 - hp2 and ap2 so let's get that value next
158:59 - auto mid
159:01 - high cutoff freq equals
159:04 - mid high crossover get
159:07 - and then this is ap2 ap2 gets the mid
159:11 - high cutoff
159:13 - and then let's copy these guys
159:16 - and this is lp2 hp2 and they also get
159:20 - the mid-high cutoff
159:23 - the next thing to do is to create audio
159:25 - blocks and contexts for each filter
159:28 - buffer now there is a dry way to do this
159:31 - but if you want to know how to do that
159:33 - you need to take project 12 because
159:34 - project 12 covers
159:36 - all that in this video we are going to
159:38 - hard code it
159:39 - so the first thing we need to do is
159:42 - let's add a block for our third
159:45 - filter buffer
159:46 - so copy and paste this
159:50 - fb2 block goes to filter buffers2
159:54 - let's add a context for it
159:56 - copy this line
159:59 - fb2 context
160:02 - goes to fb2 block
160:05 - and now we need to run the appropriate
160:07 - context through the appropriate filters
160:10 - lp1 and ap2 get the first filter buffer
160:14 - ap2.process
160:15 - fb0 context
160:19 - next
160:20 - hp1 and lp2 get the second buffer but
160:25 - here's the thing we need to know
160:27 - let's come back to my chart here
160:30 - okay the thing to know and i've written
160:31 - the names of like which filters go with
160:34 - which brands the thing to know about
160:36 - this is that
160:38 - hp2 needs the result of hp1 so we have
160:42 - to filter this first
160:44 - we have to filter hp1 first
160:47 - and then copy it to the second filter
160:49 - buffer before we can run it through hp2
160:52 - okay that's the only gotcha that's going
160:54 - on here all right
160:56 - it's okay so currently in our code we've
160:58 - got lp1 and ap2 processing the first
161:00 - filter buffer that's this line right
161:02 - here
161:03 - okay now what we need to do is
161:05 - process hp1
161:07 - into filter buffer one
161:09 - and then
161:10 - we can copy it to filter buffer two and
161:13 - run it through here
161:14 - and then run lp 2 through filter buffer
161:16 - one so we've got filter buffer 0 filter
161:19 - buffer 1 filter buffer 2. alright let's
161:21 - do that let's turn that concept into
161:24 - code
161:25 - all right let's see hp1 processes filter
161:28 - buffer context 1.
161:31 - then
161:32 - we copy the output of filter buffer 1
161:35 - into filter buffer 2.
161:36 - filter buffers
161:38 - 2 equals filter buffers
161:41 - 1.
161:43 - all right now we can process lp2
161:47 - that gets fb1 context
161:50 - and then
161:51 - hp2
161:53 - can process filter buffer 2.
161:56 - filter buffer two
161:59 - okay this is very important now our
162:02 - audio has been filtered into three bands
162:04 - and now we need to sum it back let's get
162:06 - rid of this um code right here the ap
162:09 - buffer stuff because we don't have that
162:10 - anymore
162:12 - and let's get rid of this stuff here as
162:13 - well let's just clean this up
162:18 - now i want to make the bypass act as a
162:20 - toggle like we did earlier so we will
162:22 - just exit
162:24 - before we clear
162:28 - we'll go like that
162:29 - okay i am going to comment out all of
162:31 - this all pass invert code
162:34 - because i do want to come back to it in
162:35 - a little bit
162:37 - but for now
162:38 - we just need to add the third band
162:41 - and i am not going to use a loop for
162:43 - this even though this is pretty
162:44 - repetitive
162:45 - and that is because i eventually want to
162:47 - have the ability to mute and solo and
162:49 - bypass individual bands and that is
162:52 - accomplished by not adding a filter
162:54 - buffer
162:55 - to the input buffer
162:57 - and writing a loop right now would make
162:59 - that you know we'd have to revise it
163:01 - later which is annoying so for now we'll
163:03 - just leave it
163:04 - uh we'll just manually add each one like
163:07 - that okay
163:09 - let us go test this out
163:11 - we're gonna toggle the bypass we're
163:12 - gonna drag the sliders all that good
163:14 - stuff
163:16 - all right let's test this out
163:23 - adjust the sliders
163:24 - toggle the bypass
163:27 - that sounds good to me i'm not hearing
163:28 - any of that phasing
163:30 - that's fantastic
163:32 - all right now we can confirm that this
163:33 - is working by toggling the bypass
163:35 - checkbox
163:37 - and then adding a breakpoint anywhere
163:39 - after that bypass param check so i'm
163:40 - going to add it on buffer.clear
163:43 - and let's push play and then once we
163:46 - unbypass our breakpoint will be hit
163:49 - [Music]
163:52 - yep
163:56 - all right so it works as expected
163:59 - okay the last test i want to do is the
164:01 - null test with the inverted all pass
164:03 - filters we will do that next
164:08 - all right
164:09 - let's close this guy
164:11 - save quit
164:12 - go to pluginprocessor.h
164:15 - okay i showed earlier how a single
164:18 - inverted all-pass filter will know the
164:20 - output of a pair of low-pass high-pass
164:23 - filters when they are all tuned to the
164:25 - same cutoff frequency and you multiply
164:28 - the output of the all pass filter by
164:30 - negative one
164:31 - i'm going to show that the same thing is
164:33 - true here with these three bands each
164:36 - stage in the filtering acts as a delay
164:39 - that's this stuff right here the lp1 and
164:41 - the hp1 that's stage one
164:44 - and each delay can be nulled out with an
164:47 - all-pass filter set to the same cutoff
164:50 - of that stage
164:51 - so we've got two stages so we need two
164:54 - all-pass filters let's add them here
164:57 - filter inv ap1 i inv ap2
165:01 - all right now we are going to need one
165:03 - buffer for the all pass filtering since
165:05 - they are processed in series
165:08 - juice
165:09 - audio buffer
165:11 - float
165:13 - in ap buffer
165:15 - next we need to set their types then we
165:17 - need to prepare them and then we need to
165:19 - process audio with them
165:22 - head to the constructor in
165:23 - pluginprocessor.cpp
165:27 - let's go down here let's do this at the
165:29 - bottom
165:31 - all right let's just copy uh copy this
165:33 - all past two dot set type
165:35 - let's put this at the bottom
165:38 - all right we're gonna call this
165:40 - inv ab2
165:42 - and invap1
165:46 - go to prepare to play
165:49 - and prepare them as well as the buffer
165:51 - let's just copy this
165:54 - paste paste
165:57 - inv
166:01 - all right and let's prepare the buffer
166:03 - in ap buffer
166:05 - dot set size
166:07 - spec.num channels samples per block
166:12 - let's filter and invert some audio next
166:15 - go to process block
166:17 - all right we're going to do this after
166:19 - we do our initial set of copying first
166:22 - we will copy the input buffer into the
166:24 - buffer that we will be processing in ap
166:27 - buffer equals buffer
166:30 - next we'll set the first inverted all
166:32 - pass filter to have the same cutoff as
166:35 - lp1 and hp1
166:37 - then we will set the second all pass
166:40 - filter to have the same cutoff as the
166:42 - second stage
166:44 - now we need to make our block and
166:46 - context to filter our all pass buffer
166:49 - with our filters
166:50 - i'm just going to
166:52 - copy this
166:54 - and duplicate that let me do that
166:57 - after we process this guy i'll put that
166:59 - right here
167:01 - this is in ap block
167:04 - and we will use
167:06 - in ap buffer
167:09 - and then here's
167:12 - in ap context
167:15 - ctx
167:16 - and this is fed by end ap block
167:21 - all right now we just need to process it
167:23 - in ap
167:25 - one dot process
167:27 - apctx
167:29 - and then in ap2 dot process
167:32 - abctx
167:35 - let's get rid of this bypass
167:36 - functionality for just a moment
167:39 - if the bypass button is not ticked let's
167:41 - see let's comment this out let's talk
167:43 - about what we're going to do
167:44 - if the bypass button is not ticked we
167:47 - will be hearing the audio running
167:49 - through our three filters
167:51 - if the bypass button is ticked we will
167:53 - be hearing the sum of the three filter
167:55 - bands added with the inverted all pass
167:58 - filters that's what we're going to
168:00 - implement next all right let's re-enable
168:02 - this chunk right here
168:06 - and then let's change the names so it
168:09 - compiles this is
168:11 - in ap buffer
168:15 - and then that's it that's all we need to
168:17 - do all right so we're always adding
168:19 - these guys
168:20 - um and if our bypass button is turned on
168:23 - then we're adding the output of the
168:27 - inverted all pass buffer after it's been
168:29 - multiplied by negative one
168:31 - okay
168:32 - so clicking the bypass button should
168:35 - produce silence when we test this out
168:38 - here we go
168:40 - all right let's press play
168:42 - again if we click this button we should
168:44 - get silence
168:46 - all right and drag in the sliders
168:49 - perfect
168:53 - all right awesome so this wraps up the
168:55 - theory side of things we can start
168:57 - compressing our separate bands once we
168:59 - remove this inverted all pass filter
169:01 - stuff
169:02 - all right let's remove the all pass
169:05 - filter stuff the inverted all pass
169:07 - filter stuff we're not going to be using
169:08 - it anymore in this project we are done
169:10 - with all of that so
169:12 - let's head on over to pluginprocessor.h
169:15 - and we can get rid of this inverted all
169:17 - pass filter we can get rid of the buffer
169:20 - we can
169:20 - get rid of
169:23 - the stuff in the
169:24 - constructor stuff down here get rid of
169:27 - these two guys
169:29 - go to prepare to play basically
169:31 - everywhere if we were to build this now
169:32 - everywhere that we have errors is where
169:34 - we need to comment this stuff out
169:36 - okay we don't have these three anymore
169:38 - so i'll get rid of those and then in a
169:41 - process block
169:43 - that's going to be right here
169:45 - that's going to be here and right there
169:49 - that's going to be all of this code
169:51 - right here
169:53 - actual block context and filtering
169:57 - we don't need that let's turn this
169:58 - bypassing back on
170:02 - and then we can get rid of all of this
170:04 - code that inverted the samples
170:08 - you can get rid of this stuff right here
170:11 - let's build and test
170:13 - bypassing should not produce any audible
170:16 - differences that's what we're aiming for
170:18 - when we use the bypass button
170:21 - versus if we
170:22 - drag the sliders and whatnot all right
170:24 - let's try it out
170:28 - no phasing
170:34 - no audible difference here either
170:36 - awesome
170:37 - all right
170:38 - we can check off the first item in our
170:40 - dsp roadmap
170:43 - figure out how to split audio into three
170:46 - bands
170:47 - done
170:49 - cool
170:51 - let's make a commit of that
170:53 - figured out how to split audio into
170:56 - three bands
171:00 - here's our buffers and whatnot
171:04 - fill the graph yes all right here's
171:06 - where we set our types
171:08 - here's where we prepared our filtering
171:10 - here's where we set our cutoffs here's
171:12 - where we did our processing
171:17 - um and then this is just here's our
171:19 - parameter and then this is just where we
171:21 - are adding our third filter band
171:24 - all right
171:27 - awesome
171:29 - let's create audio parameters for the
171:32 - compressors that we will be adding we
171:33 - can also remove two other items from the
171:36 - roadmap since we completed them as well
171:39 - goodbye number two
171:40 - and goodbye number three all right so we
171:43 - are on number four now all right let's
171:46 - head over to create parameter layout in
171:48 - pluginprocessor.cpp
171:52 - all right we already created param names
171:54 - for these extra compressors so we just
171:56 - need to create the parameters for it
171:58 - since they all are going to have the
171:59 - same settings and range of settings we
172:03 - can literally just duplicate most of
172:05 - this code that creates the current set
172:07 - and just change the names
172:10 - so let's copy let's do the threshold
172:12 - first copy this paste it twice
172:16 - and then hold down
172:18 - option shift
172:20 - to select multiple lines and then change
172:23 - this to mid
172:24 - same thing for this one here change that
172:26 - to high done
172:29 - couldn't be easier
172:31 - let's do the attack param
172:33 - select this
172:35 - paste paste
172:38 - option
172:39 - drag
172:40 - mid option drag
172:43 - high
172:45 - boom
172:46 - okay let's do the release param
172:50 - copy this
172:55 - and option drag mid
172:58 - option drag
173:00 - hi
173:01 - perfect
173:03 - all right let's do the ratio parameter
173:04 - next
173:07 - copy paste paste
173:11 - option drag
173:13 - mid
173:14 - option drag
173:16 - hi
173:18 - and then the bypass parameter is next
173:26 - option drag
173:27 - mid
173:29 - option drag hi
173:32 - all right cool let's run it
173:36 - all right look at all the parameters
173:38 - that we have
173:39 - access to now
173:42 - all right that was super easy all right
173:44 - let's close this
173:45 - now in project 12 i teach a much more
173:48 - optimized solution for creating the
173:50 - parameters and looking them up versus
173:51 - using this params get paramed
173:55 - dot at thing that we're using here all
173:57 - right let's go on to the next item in
173:59 - the road map
174:01 - since we are up here let's see
174:04 - we're done with this done
174:07 - so now we need to reinstate our
174:09 - compressors and add two new ones let's
174:11 - do that next
174:12 - let's go to pluginprocessor.h
174:15 - we'll go down to where we are declaring
174:16 - everything go to our private member
174:19 - variable section the first thing i'm
174:21 - going to do is create an array of
174:23 - compressor band instances and then i'm
174:25 - going to create aliases to each one
174:29 - now the reason is so that i want to have
174:30 - the option to be able to loop through
174:32 - and i also want to have the option of
174:34 - being able to target each one
174:35 - individually without having to use array
174:37 - indexing so check that out let's do std
174:40 - array
174:41 - compressor band
174:44 - three
174:45 - there's my compressors we're going to
174:46 - change this to be plural and now we're
174:49 - going to do compressor
174:52 - let's see i'm going to do this on three
174:53 - lines so
174:54 - let me write this three times
174:57 - compressor band
175:00 - band comp uh let's see capital b
175:04 - band comp
175:07 - equals compressors
175:10 - like that all right let's just fill it
175:12 - in
175:13 - all right first this is going to be
175:15 - the low band this is going to be the
175:18 - mid band and this is going to be the
175:19 - high band
175:20 - this will be the first one this will be
175:22 - the second one and this will be the
175:24 - third one
175:26 - boom that was easy
175:29 - all right now we need to initialize all
175:30 - of the parameters
175:32 - for all of our compressors so go to
175:35 - pluginprocessor.cpp go to the
175:37 - constructor
175:39 - all right i'm going to rename the very
175:41 - first one
175:42 - and then i can just copy and paste the
175:45 - three lines
175:46 - to initialize the other two compressors
175:49 - all right so let's rename this right
175:51 - here
175:52 - this is gonna be low band comp
175:56 - like that now i can copy and paste it
175:59 - and rename accordingly
176:03 - all right i'll change this
176:06 - mid band
176:07 - and then this one is
176:09 - high
176:10 - band all right do the same thing for the
176:13 - bypass
176:14 - and the ratio
176:17 - so first rename this
176:19 - low band comp ratio
176:21 - and then copy and
176:23 - paste this two times
176:25 - and this is the mid band
176:29 - and the high band
176:32 - um oh you know what i forgot to do all
176:34 - of these need to be um let's see this is
176:36 - low so these need to be
176:38 - let's get let's line these up
176:41 - that could have been problematic
176:44 - let's see
176:46 - um all right go to the end
176:48 - arrow over one two three
176:51 - mid
176:52 - same thing here
176:56 - high like that awesome okay do the same
176:59 - thing here this needs to be mid with a
177:01 - capital m
177:03 - and then
177:04 - high with a capital h
177:07 - it could have been a disaster all right
177:09 - let's do this let's see this is low band
177:12 - comp bypassed
177:14 - copy and paste this
177:17 - and let's see this needs to be low
177:20 - this is mid
177:22 - this is
177:25 - high
177:27 - all right and then this is going to be
177:28 - the mid band
177:30 - and this will be the
177:32 - high band
177:34 - perfect all right the compressor
177:36 - parameters are initialized now we can
177:39 - prepare our compressors all right so
177:42 - when you're doing this step be very
177:44 - careful to make sure you're initializing
177:45 - the low band compressor with the low
177:49 - band parameters
177:51 - all right
177:52 - you know mid band with mid params high
177:54 - band with high params okay just be
177:57 - careful be very careful when you're
177:58 - doing this on your side
178:00 - go to prepare to play
178:02 - all right remember what i had said about
178:04 - the ability to loop through these we can
178:07 - just do four
178:09 - auto comp
178:11 - compressors
178:14 - comp
178:16 - boom done onward to process block
178:20 - first we need to update
178:22 - all of the compressors settings again
178:24 - looping for the win for auto compressor
178:28 - compressors
178:31 - let's turn that on
178:34 - now we can't actually compress any audio
178:37 - until after it has been filtered so we
178:39 - need to move this line this compressor
178:41 - dot process
178:43 - until after all of the filtering has
178:45 - been completed
178:47 - so let's go do that
178:50 - all right that happens down here
178:52 - okay now one of the important things to
178:54 - note was that filter buffers zero
178:57 - this guy right here
179:00 - this holds the low pass audio and that
179:03 - same index zero
179:06 - is the same index of the compressor that
179:08 - is set up for low band processing
179:12 - so isn't that convenient
179:14 - that means that it makes it really easy
179:17 - for us to run the correct buffer through
179:19 - the correct compressor so it would be a
179:21 - problem if it wasn't done this way
179:23 - imagine if we had to remember that
179:24 - filter buffers2 was
179:26 - the
179:27 - buffer to use for compressor zero all
179:29 - right anyway it's very easy to do this
179:32 - we just need to use an index based loop
179:34 - instead of a range based loop
179:36 - for size t
179:39 - i zero i is less than filter buffers dot
179:42 - size
179:43 - plus plus i
179:45 - now we can do compressors
179:47 - i dot process
179:49 - filter buffers
179:51 - i
179:54 - wasn't that easy
179:56 - how simple is that
179:58 - all right
179:59 - let's get rid of this uh bypass stuff
180:01 - let's clean this stuff up too we don't
180:03 - need that
180:05 - all right
180:06 - let's get rid of this bypass stuff we
180:07 - can delete it for good
180:10 - and
180:12 - uh that's it all right we can get rid of
180:14 - this stuff as well
180:17 - all right let's test it out
180:19 - our compressors should be able to be
180:23 - tested separately so grab your
180:24 - headphones and
180:26 - mess around with it
180:29 - here we go
180:31 - let's put this on screen so we can see
180:32 - more of the parameters and let's um
180:36 - let's see let's make the output of our
180:38 - compressor feed project 12 so we can
180:41 - actually see
180:43 - the result
180:48 - let's just turn off all processing first
180:50 - okay if uh we're gonna run some audio
180:53 - and then we're going to um
180:56 - you know adjust and
180:57 - adjust each individual band and just
181:00 - kind of mess with them all right so we
181:01 - got our low band we're going to hear the
181:03 - way this is set up now we're not going
181:04 - to hear a lot of low band
181:09 - you can really see this as we clamp it
181:11 - down we can see that a lot of the low
181:13 - band is gone
181:14 - let's go down here let's
181:18 - see that that low end is
181:20 - really chopped
181:23 - [Music]
181:25 - and then we turn it back we bypass it we
181:27 - can see that
181:29 - uh that happened all right let's let's
181:31 - uh chomp down the mid band
181:36 - [Music]
181:38 - wow it's really getting chopped
181:41 - all right let's adjust our mid band so
181:42 - it's tighter
181:46 - and let's change that ratio
181:48 - [Music]
181:54 - you can see this dip that's happening
181:56 - right here
181:57 - uh between 1k between as we show here
182:00 - 761 and 2300
182:02 - it's kind of a dip right here between
182:05 - 1k and 2k let's change this to be
182:08 - closer to
182:09 - 300s that's right around where this line
182:12 - is you can see this dip right here so if
182:13 - i bypass the mid band
182:16 - see a little bit of a boost here
182:18 - change this ratio to be like really
182:20 - dramatic
182:22 - and really slam it
182:27 - all right we can see a big dip right
182:29 - there okay all right so that's a pretty
182:31 - good test
182:33 - next let's add the ability to solo and
182:36 - mute the individual compressors because
182:38 - that's a very cool feature
182:40 - let's save this
182:42 - and quit this
182:44 - let's um make a commit
182:47 - let's see what did we do we um
182:49 - reinstated
182:51 - all three compressors
182:54 - all right here's where we did that
182:57 - and fill the graph
182:59 - and here's where we set up our
183:00 - parameters
183:01 - here's where we set up our ratio param
183:04 - our bypass param here's where we
183:06 - prepared them here's where we did our
183:08 - settings updating here's where we
183:10 - actually processed audio
183:12 - and we got rid of some code there here's
183:14 - where we created our params params
183:17 - params params params
183:20 - good times commit all right solo bypass
183:24 - mute next
183:29 - let's check off road map item number
183:31 - five
183:33 - add two remaining compressors done
183:36 - number six add the ability to mute solo
183:38 - bypass individual compressors
183:42 - all right we can already bypass an
183:43 - individual band
183:45 - we just need to be able to solo and mute
183:47 - them so let's duplicate
183:49 - the bypass enum entries and rename them
183:53 - go to the params
183:56 - copy this
183:58 - paste paste
184:00 - and we just need to rename so
184:03 - option shift
184:05 - mute
184:06 - and sorry not shift just option drag to
184:09 - select and then
184:10 - solo
184:11 - i don't know if that's a thing on
184:13 - windows but on mac it is in xcode it's
184:16 - very handy
184:17 - all right we just need to add them to
184:19 - our map
184:20 - below let's go down here again copy
184:24 - paste rename
184:26 - one two
184:28 - let's get that back on screen
184:30 - all right first things first this is um
184:33 - let's see we'll do mute first
184:36 - copy paste copy paste copy paste all
184:38 - right and then solo will be the second
184:40 - set
184:41 - solo
184:43 - solo
184:44 - copy paste paste
184:47 - alright awesome
184:49 - now we need to add solo and mute
184:51 - parameters to our compressor
184:55 - let's go to the compressor band and
184:57 - declare two more boolean audio
184:59 - parameters named mute and solo so
185:02 - duplicate this copy paste paste
185:07 - it says mute
185:08 - and this is solo
185:11 - now these aren't going to be used in the
185:12 - compressor class at all they will be
185:14 - used in process block
185:17 - we still need to create the parameters
185:19 - in parameter layout before we can
185:20 - initialize them in the constructor so
185:23 - let's do that next head over to
185:25 - pluginprocessor.cpp
185:27 - and create parameter layout
185:30 - all right go to the bypass parameter
185:33 - where is that that's down here at the
185:35 - end
185:36 - all right
185:36 - copy paste rename do this for mute and
185:40 - solo
185:44 - all right
185:45 - change this to be
185:46 - the mute
185:49 - and mute
185:51 - again option drag
185:54 - mute and then we'll do solo here at the
185:56 - end
185:57 - solo
185:58 - whoops
186:01 - solo
186:04 - solo
186:05 - all right awesome let's go initialize
186:08 - the parameters and our compressors next
186:10 - go to the constructor
186:12 - all right copy and paste the boolean
186:15 - helper code for the bypassed param
186:19 - and then rename accordingly
186:22 - whoops let me add extra line okay this
186:25 - should be
186:26 - mute let's do all three of these
186:29 - and let's see
186:31 - i can't because their line lengths are
186:33 - different
186:34 - i can copy and paste
186:36 - this is solo
186:39 - copy and paste all right now for these i
186:41 - can do it
186:42 - at the end so this is
186:45 - all right no because high is too long
186:47 - all right gotta do them individually all
186:48 - right this is mute
186:50 - and then
186:53 - uh solo
186:54 - and solo okay excellent all right let's
186:57 - go solo or mute our separate bands next
187:01 - in
187:02 - process block
187:04 - all right this happens after buffer dot
187:06 - clear
187:09 - right here okay the logic is
187:11 - surprisingly simple if any of the bands
187:14 - are soloed we copy only the solo band's
187:18 - buffer to the output
187:20 - otherwise if a band is not muted we copy
187:24 - that band's buffer to the output so
187:26 - first we need to figure out if any band
187:28 - is soloed this is pretty easy to do
187:31 - we start with a boolean flag
187:33 - and then we loop through the compressors
187:35 - and just check their solo param if it's
187:38 - true then we have at least one band that
187:40 - is soloed and we stop checking once we
187:43 - have at least one
187:45 - that looks like this
187:48 - again we start with a flag we loop
187:50 - through every compressor if the solo
187:52 - parameter is true
187:53 - then we have at least one that is soloed
187:55 - so we don't need to check anymore
187:58 - let's comment out the old way of looping
188:01 - of adding the filters
188:03 - all right now we just need to check if
188:05 - bands are soloed or not all right if
188:08 - bands are soloed
188:11 - else
188:13 - if any of the bands are soloed copy only
188:16 - the solo band's buffer to the output now
188:19 - we cannot use a range-based loop here
188:22 - because our filter buffers don't live
188:24 - with compressors so we have to use an
188:26 - indexed loop instead but that's okay
188:29 - that's easy to use for
188:31 - size t
188:33 - i equals
188:34 - zero i is less than compressors dot size
188:39 - plus plus i
188:40 - again uh let's get a compressor auto
188:44 - comp equals compressors
188:47 - if
188:48 - comp dot solo
188:51 - if it's soloed
188:53 - then add filter band
188:56 - add the buffer and this one we want
188:58 - filter bands
188:59 - uh filter buffers we want if index i
189:03 - apostrophe th all right cool that's very
189:06 - simple to understand
189:07 - all right again if a band is soloed loop
189:10 - through all of the bands and if a band's
189:12 - solo parameter is on
189:14 - then we add the associated
189:17 - filter buffer that that particular band
189:20 - is using
189:21 - all right let's implement
189:23 - what happens when nothing is soloed next
189:27 - go to the else block if nothing is
189:29 - soloed then copy only the buffers that
189:32 - are not muted
189:34 - let's use the same loop again
189:37 - and we need this uh compressor part as
189:39 - well
189:42 - oops
189:43 - all right
189:44 - if comp dot mute
189:46 - get
189:47 - all right
189:48 - if it is not muted it's very important
189:50 - to include that exclamation part
189:52 - if it is not muted
189:55 - then we can add
189:57 - that filter band
189:59 - okay that's it that is solo mute and
190:01 - bypass let's test it out let's mess with
190:03 - the solo buttons and the mute buttons
190:06 - grab your headphones
190:08 - all right here we go
190:12 - all right this is bypass
190:14 - let's mute let's solo the mid band
190:20 - all right we can adjust this
190:23 - just this range
190:25 - we can see how we we can make this mid
190:27 - band really narrow
190:30 - like that
190:31 - all right and we can bypass it as well
190:35 - so we can see what our mid band actually
190:36 - is like and what it actually sounds like
190:40 - what that means is that we can go up
190:42 - here and dial in
190:44 - all this stuff like say i want
190:46 - real slow attack time
190:48 - i want to let all of that you know snare
190:51 - information through
190:53 - i don't want that to get clamped down
190:55 - so i can adjust all that stuff
191:00 - it's just ratio
191:01 - all right let me stop
191:03 - you stop soloing it
191:05 - you know it's funny about that i was
191:07 - adjusting all those parameters
191:09 - and it was bypassed so i wasn't even
191:11 - hearing it
191:13 - so that's a whole that's a whole thing
191:15 - like you shouldn't be able to adjust
191:16 - these sliders
191:18 - um if it's bypassed
191:20 - but that's something we implement later
191:23 - all right so we can mess with this mid
191:24 - band
191:25 - see what it actually sounds like and use
191:27 - the bypass to um
191:28 - [Music]
191:29 - uh you know adjust this stuff let's
191:31 - change this ratio so it's real dramatic
191:34 - [Music]
191:43 - here there's a lot of information that's
191:45 - being uh
191:47 - is it in the high band
191:49 - well the high band is real wide
191:53 - all right so we can dial in a lot of the
191:55 - snare stuff that's going on here anyway
191:57 - that's solo mute and bypass
192:00 - actually
192:01 - mute the mid band we can see it gets
192:03 - dipped out there let's mute the high
192:04 - band
192:06 - stuff gets kind of dull if you need the
192:07 - low band it'll sound like a telephone
192:11 - and we can like you know tweak all this
192:13 - stuff early
192:14 - okay
192:16 - all right
192:17 - that is solo and mute and bypass
192:20 - of three separate bands with our
192:22 - filtering so we can check another item
192:24 - off of our roadmap let's solo this i'm
192:27 - not solo let's save this quit
192:30 - go to our roadmap turn off the ability
192:33 - to
192:34 - uh let's mark it as done that's awesome
192:37 - and then uh let's see we're gonna add
192:39 - input and output gain to compensate for
192:41 - level changes and then we're gonna clean
192:43 - it up and that will be the dsp side of
192:45 - things
192:46 - let's make a commit
192:48 - all right
192:50 - added
192:51 - mute solo
192:53 - functionality
192:55 - and bypass
192:58 - bypass functionality
193:01 - all right here's where we set up the uh
193:03 - mute and solo params here's where we
193:06 - implemented the actual dsp
193:08 - here's where we created the params
193:11 - uh marked it off list here's our enum
193:13 - here's our param names
193:15 - and here's our parameters
193:18 - on the compressor band
193:21 - excellent done all right
193:24 - input and output gain next and then
193:26 - clean up and that will conclude the dsp
193:29 - side of this plug-in
193:31 - awesome
193:34 - all right now it is time to add input
193:36 - and output gain because compressors
193:39 - lower the output level of the signal the
193:42 - input gain is mainly if the incoming
193:44 - signal is not high enough or if it's too
193:47 - high and we need to turn it down
193:49 - first we need to add some entries in our
193:52 - enumeration that will point to the
193:54 - parameter names let's put these at the
193:55 - bottom
193:57 - next we need to add two entries so copy
193:59 - these
194:01 - stick these at the bottom
194:03 - number four all right we need to declare
194:05 - some gain processors and cached
194:07 - parameters go to plugin
194:08 - pluginprocessor.h
194:10 - way down at the bottom
194:12 - where we are declaring all of our stuff
194:14 - let's put this after our filter buffers
194:16 - uh let's see juice
194:18 - dsp
194:19 - gain float we got input gain output gain
194:24 - all right then we need two parameters
194:26 - these are going to be audio parameter
194:27 - float as well
194:29 - okay
194:31 - we need to create some actual parameters
194:33 - that represent our input and output gain
194:35 - so let's go to plug-in
194:37 - pluginprocessor.cpp create parameter
194:39 - layout so we're going to put these at
194:41 - the top
194:42 - so i'm going to define a range of
194:44 - negative 24 to plus 24 with a step size
194:47 - of 0.5 this means we can boost or cut
194:50 - our incoming signal with a range of
194:53 - uh not in with a range but with steps of
194:55 - like 0.5 such as you know 1.5 db of gain
194:59 - 2 db again 2.5 db of gain same will go
195:02 - for the output gain levels all right so
195:05 - let's define that first auto gain range
195:08 - equals
195:09 - juice
195:10 - normalizable range actually i didn't
195:12 - need to type juice just type
195:14 - normalizable range
195:16 - range start is negative 24.f whoops
195:19 - that's float in the wrong place holder
195:21 - here we go range start negative 24.f
195:24 - range end positive 24
195:27 - interval value 0.5 f and our skew will
195:29 - be one
195:31 - okay that's our gain range now we can
195:33 - define our parameter
195:35 - all right let's just copy this
195:39 - paste paste
195:41 - let's change this name to be gain in
195:44 - and we'll change this to use our gain
195:47 - range
195:49 - all right
195:50 - and let's just duplicate this
195:53 - copy paste replace that right now this
195:55 - can be gained out
195:58 - all right now that we have created the
195:59 - parameters we need to initialize our
196:01 - cached parameters in the constructor
196:04 - all right let's uh
196:06 - let's do this after our
196:09 - crossovers where's that that's right
196:11 - here
196:12 - okay float helper
196:14 - input gain param
196:17 - as with every other dsp processor we
196:19 - need to prepare our gain processors
196:22 - before we can use them let's go to
196:24 - prepare to play
196:25 - all right we also need to specify the
196:27 - ramp duration for these processors now
196:30 - this function
196:32 - the ramp duration it controls how long
196:34 - it takes to transition from one gain
196:36 - level to another
196:38 - whenever the gain level is changed so
196:40 - anything quicker than 5 or 10
196:41 - milliseconds is pretty audible and it
196:43 - sounds it produces like clicks and pops
196:46 - so i'm gonna go with 50 milliseconds
196:48 - we'll go input gain
196:53 - gain dot prepare
196:55 - what do you want srb come say hi to
196:57 - everybody oh
196:59 - yes everybody say hi
197:01 - to srabby she's very whiny can you whine
197:05 - you gonna wind everybody all right down
197:07 - you go
197:08 - spec
197:10 - all right output gain dot prepare spec
197:14 - let's set those ramp times input gain
197:17 - dot
197:18 - set ramp duration in seconds 0.05
197:22 - because there's a thousand
197:24 - milliseconds in one second so 0.5
197:28 - seconds is 50 milliseconds all right do
197:31 - the same thing for the output
197:33 - copy paste
197:34 - copy paste okay now that this is all set
197:37 - up let us start processing our audio
197:40 - with our gain processors
197:43 - all right um let's see go to process
197:45 - block
197:46 - and before we start applying gain to our
197:48 - input buffer we need to update our
197:51 - processors with the most recent gain
197:53 - parameter values so input gain
197:56 - dot set gain in decibels because we're
197:59 - storing our parameter in decimals input
198:01 - gain program
198:02 - get
198:03 - do the same for the output all right we
198:05 - must apply input gain b4 processing
198:09 - audio through the bands so i'm going to
198:10 - call an imaginary function that i
198:12 - haven't written yet that applies the
198:14 - gain
198:14 - and then we'll implement that imaginary
198:16 - function next
198:17 - but first we'll do that here
198:20 - and call apply gain
198:23 - buffer and our input gain
198:26 - i'm doing this because i'm going to be
198:27 - applying gain
198:29 - i just don't want to have to write the
198:30 - code that actually applies the gain
198:32 - twice let's implement this imaginary
198:34 - function next head over to the header
198:36 - file plug in processor.h down at the
198:38 - bottom
198:40 - all right i'm going to declare a helper
198:41 - function that will apply the gain
198:44 - we are very familiar with creating the
198:45 - context for a particular buffer so i'm
198:48 - trying to type in that code so i'm going
198:50 - to write this helper function and i'm
198:52 - going to use templates because i'm too
198:54 - lazy to figure out the type that each of
198:56 - the arguments should have
198:58 - so you know why should i have to think
199:00 - about that stuff when the compiler can
199:01 - figure it out for me you know all right
199:03 - so here we go template type name t
199:06 - type name u
199:09 - void apply
199:11 - gain
199:12 - passing in
199:14 - a buffer
199:17 - and passing in
199:19 - again
199:20 - all right let's make our block auto
199:22 - block equals juice dsp
199:26 - audio block
199:27 - float
199:28 - out of the buffer make it out of the
199:29 - buffer let's make our context auto ct x
199:32 - equals juice dsp
199:35 - process context replacing float this is
199:39 - out of the block and then we can do gain
199:41 - dot process ctx
199:44 - all right head back over to process
199:45 - block so we can apply output gain next
199:48 - all right now finally we apply output
199:50 - gain after processing all of the audio
199:54 - that way at the end
199:57 - after all of this stuff
199:59 - apply
200:00 - gain
200:02 - buffer
200:03 - output gain
200:05 - all right cool let's test this out the
200:07 - gain sliders should change the volume
200:10 - headphones
200:11 - all right cool gaining at the top gain
200:14 - out at the top as well let's mess with
200:16 - this we'll adjust our levels let's just
200:17 - bypass um
200:19 - let's bypass our compression for right
200:21 - now
200:26 - turn down the input
200:32 - that works as expected
200:36 - all right cool that is awesome that
200:38 - works as expected all right so here's an
200:41 - interesting test
200:42 - um let's turn down the input gain to
200:44 - like negative 12
200:46 - negative 12 and then let's turn up the
200:47 - output
200:49 - to positive 12.
200:51 - all right let's run some audio through
200:52 - it
200:53 - [Music]
200:55 - all right now if we toggle the bypass of
200:58 - plug-in
200:59 - oh wait hold on i need to un-bypass this
201:01 - stuff
201:01 - [Music]
201:06 - okay
201:07 - oh let's see
201:09 - [Music]
201:13 - all right if we bypass this
201:17 - the audio will sound the same okay so
201:20 - you would think that we would hear some
201:21 - type of compression especially if the
201:23 - compressors have a pretty low threshold
201:25 - prior to modifying the input and up
201:27 - again
201:28 - but
201:29 - when we do this we don't actually hear
201:31 - any compression
201:36 - all right so the reason is because we
201:40 - turned down the input gain level which
201:42 - means the low threshold that we had and
201:44 - the compressors is no longer low
201:47 - relative to the signal level
201:49 - so we need to lower these thresholds by
201:51 - 12 db in order for them to actually do
201:53 - anything
201:54 - right so for example if let's see um
201:59 - i'm gonna do it to just the low band for
202:02 - now
202:03 - turn the mid band back up
202:05 - okay i'm going to set this to negative
202:07 - 20.
202:12 - all right all right let me just solo
202:14 - this real quick
202:19 - oh look at me tweaking stuff all right
202:22 - here's our solo low band
202:24 - all right now because this is applying
202:26 - negative 12 to the input
202:29 - um
202:30 - our signal may not be hot enough to
202:33 - actually trick to actually trip the
202:35 - compressor so what we need to do is
202:37 - lower this by 12.
202:39 - so put this to 32.
202:42 - there we go now we now we're starting to
202:44 - hear it smash
202:47 - you can hear it on the base boom boom
202:49 - boom boom boom
202:51 - [Music]
202:57 - [Music]
203:01 - open that up a bit
203:05 - if we bypass
203:07 - [Music]
203:11 - okay
203:12 - all right
203:13 - so that's the interesting test do that
203:17 - now it'll really be it'll be really big
203:19 - it will really compress it and if we put
203:21 - this back 20 negative 20
203:24 - we'll hear the same results that we
203:25 - heard a moment ago
203:27 - okay
203:28 - okay so that marks another item on our
203:30 - dsp roadmap let's save and quit this
203:33 - let's go up to our roadmap uh where's
203:36 - that plugin processor.h way at the top
203:38 - add input and output gain
203:40 - done
203:41 - okay so now the next thing to do is to
203:44 - clean this up let's do that next
203:47 - okay uh head on over to create pro
203:50 - create parameter layout all of these
203:52 - thresholds use the same um normalizable
203:55 - range so let's dri that dry that auto
203:58 - threshold range equals this thing
204:03 - cut
204:04 - paste semicolon
204:06 - replace
204:07 - the next thing to do is to move all of
204:10 - the code that updates the dsp processors
204:12 - into a function
204:13 - process block always operates in this
204:16 - order let's go to processblock see let's
204:18 - actually just see what i'm talking about
204:20 - processblock always operates in this
204:22 - order first thing we do is update dsp
204:25 - processors with the latest parameter
204:27 - values and then we process the audio so
204:29 - again dsp processing is entirely
204:32 - state-based
204:33 - and the parameters represent the state
204:36 - so we update the stuff that does all the
204:38 - math with the latest dsp state before
204:41 - any math
204:42 - computations are actually performed so
204:44 - i'm going to call an imaginary function
204:46 - first i'm going to call that right here
204:48 - update state
204:50 - and then we just need to move all of
204:51 - this code that happens here all of this
204:54 - stuff
204:55 - she need to move that to that function
204:58 - okay so let's do that next
205:00 - first we go declare it plug in
205:02 - processor.h way down at the bottom
205:05 - void update state
205:08 - now we can go implement it i'm going to
205:10 - put this right above a plug-in i'm going
205:13 - to put it right above process block put
205:16 - that right here
205:17 - simple mb comp audio processor
205:20 - update state
205:23 - let's update our compressor settings
205:25 - all right we need to update the uh
205:27 - filters let's grab all this stuff
205:30 - and then we need to update the gain
205:32 - processors let's grab these as well
205:38 - let's clean this up as well
205:40 - get rid of that stuff
205:42 - and get rid of that
205:43 - and get rid of that
205:45 - all right cool and now process block is
205:48 - much simpler
205:50 - okay we update our state then we apply
205:52 - our gain
205:53 - the next thing that happens is we split
205:55 - the audio into separate bands so let's
205:57 - do the same thing we will
205:59 - call another imaginary function
206:02 - we'll call that right here split bands
206:05 - and we'll pass our buffer to it let's go
206:07 - declare it go to plug-in processor down
206:09 - to the end
206:12 - okay go back to plug-in processor
206:14 - and let's just move the relevant code
206:16 - again um above process block void simple
206:22 - i mean comp audio processor
206:25 - split bands
206:28 - okay so this is where we make this copy
206:31 - first
206:33 - and we do our contexts and this needs to
206:36 - say input buffer
206:39 - we do our contexts and our processing
206:46 - right cool so again we are making
206:48 - process block just that much simpler and
206:50 - easier to understand right we update our
206:52 - state we apply our gain then we split
206:54 - our bands and then we're doing
206:56 - compression
206:57 - all right now i'm just thinking out loud
206:58 - here but because the apply gain function
207:01 - is set up for a generic processor we
207:04 - technically we could use it
207:07 - i mean we could use it here for all of
207:10 - these
207:10 - but
207:12 - there are five processors being used
207:13 - which means that
207:16 - we would be creating five blocks and
207:18 - five contexts
207:21 - and right now we're only creating three
207:22 - blocks and three contacts so
207:25 - i'm gonna stick with what we have
207:27 - because it's um even though it would
207:29 - simplify this function a lot
207:31 - what we have now is um a light it is
207:34 - less cpu intensive because it has less
207:36 - objects being created
207:38 - okay everything else that happens is
207:40 - already pretty simple we do our
207:42 - compression
207:44 - um we do our
207:46 - solo check then we do our
207:49 - um
207:51 - if it's soloed here's which buffers get
207:53 - added otherwise these are the buffers
207:54 - that get added
207:56 - um let's clean that up so we could
207:59 - refactor it but we're not going to
208:00 - really gain anything here instead
208:02 - single line comments can be used to
208:04 - explain what is happening
208:06 - in case it isn't readable what's going
208:09 - on but in my opinion this is very
208:12 - readable right we're clearing the buffer
208:14 - we're figuring out if a band is soloed
208:16 - and then we're
208:17 - using whether or not a band is soloed to
208:20 - add stuff to um our input buffer okay so
208:24 - let's just run and test this to make
208:26 - sure
208:27 - and it should be all good but let's just
208:29 - make sure
208:31 - okay
208:32 - [Music]
208:36 - that still works
208:39 - it still works
208:44 - it still works
208:46 - all right cool and
208:48 - solo still works
208:51 - [Music]
208:56 - [Applause]
208:59 - all right
209:00 - sounds good to me
209:01 - this concludes the
209:04 - dsp portion of
209:06 - this uh simple multi-band compressor um
209:09 - in project 12 we tackle how to
209:11 - dynamically change the number of bands
209:13 - so you can have six bands two brands
209:16 - three bands up to eight bands if you're
209:18 - if you need that much
209:20 - along with uh how to do a bunch of other
209:22 - stuff like a draggable gui for adjusting
209:24 - the crossovers and adjusting the
209:25 - thresholds and whatnot
209:28 - okay so we can move on to developing the
209:30 - gui and making it as simple and as
209:32 - intuitive to use because this
209:35 - will never fly in front of the customers
209:38 - customers will look at this and say
209:40 - i don't know what i don't know how to
209:42 - use this i don't know
209:44 - yeah this is
209:45 - i will not give you my hard-earned cash
209:48 - if this is the gui that i'm working with
209:50 - all right let's work on that next
209:52 - good times save
209:54 - quit
209:55 - let's make a commit
209:57 - added io gain cleaned up dsp
210:02 - here's where we um let's see
210:04 - checked out these things here's where we
210:06 - added our input gain
210:08 - uh strings
210:10 - here's where we added helper functions
210:12 - and parameters
210:13 - here's where we set up our parameters
210:15 - here's where we prepared our dsp
210:17 - processors here's where we did some
210:19 - cleanup
210:20 - here's more cleanup here
210:22 - more cleanup there
210:24 - and more cleanup here
210:26 - and here's where we added those
210:28 - parameters let's see that goes there
210:31 - here's where we added the parameters and
210:33 - here's where we refactored um
210:36 - the threshold parameter
210:38 - okay
210:40 - excellent onward to the gui
210:45 - all right the dsp is done let's get rid
210:47 - of the old road map
210:50 - let's sketch out the road map for the
210:52 - gui
210:54 - all right first thing that we're going
210:55 - to do is the global so let's add this in
210:58 - here globe gui road map
211:02 - all right number one
211:03 - global controls
211:05 - these are the x over
211:07 - x over sliders and the gain sliders okay
211:12 - these are going to go in the middle of
211:13 - the display
211:15 - input gain on the left output gain on
211:16 - the right crossover controls in the
211:18 - middle
211:19 - okay next
211:20 - we're going to have the main band
211:22 - controls
211:23 - these are going to be the attack release
211:26 - threshold ratio sliders
211:29 - all right these are going to go below
211:31 - the global controls
211:33 - and these controls will be assigned to
211:35 - the mid band first
211:37 - all right
211:38 - next
211:39 - we're going to add solo mute
211:42 - bypass buttons
211:45 - again these are going to be assigned to
211:46 - the mid band first and these are going
211:48 - to be on the right side of the main band
211:50 - controls component
211:52 - okay number four
211:54 - band select functionality this is also
211:58 - known as resettable parameter
211:59 - attachments
212:01 - this band selects functionality will
212:03 - allow us to have one set of controls for
212:06 - all of the bands
212:07 - and it will also give us some buttons to
212:10 - switch which band is currently being
212:12 - controlled by the sliders and the solo
212:16 - mute bypass buttons okay we will be
212:18 - using the band controls so we will need
212:21 - to have a mechanism to change which
212:22 - parameter a control is assigned to
212:25 - it's a pretty cool system to implement
212:27 - um it's not not the simplest thing but
212:29 - it's it's a very it's a very interesting
212:31 - problem to solve
212:33 - okay next five band select buttons
212:37 - reflect the solo mute bypass state when
212:42 - we switch the bands now this is to give
212:44 - us some visual feedback when we click
212:47 - any of these
212:48 - you know low band mid band high band
212:50 - buttons okay we also need to implement
212:52 - the logic that
212:54 - prevents you from having both uh the
212:57 - mute button and the solo button set at
212:59 - the same time for example because it
213:00 - doesn't make sense to be able to
213:02 - be muted and soloed at the same time all
213:05 - right so we're going to deal with that
213:07 - all right next number six
213:10 - custom look and feel for the rotary
213:12 - sliders and the toggle buttons all right
213:15 - so custom
213:16 - look
213:17 - and feel
213:19 - for sliders and toggle buttons we will
213:22 - be modifying the look and feel that we
213:24 - developed from the simple eq tutorial so
213:26 - if you don't have
213:28 - um if you did if you didn't do simple eq
213:30 - um you know pause right now and go
213:32 - through that and then come back here so
213:34 - that way you have those files i will
213:36 - also be including links to
213:38 - the simple eq repository so if you don't
213:41 - want to go through it you can just
213:42 - copy that code and um
213:44 - you know paste what you need you know
213:46 - copy the parts you need and paste it
213:48 - into this project let's see number seven
213:52 - spectrum analyzer overview
213:54 - spectrum
213:57 - analyzer overview
213:59 - okay the spectrum analyzer in this
214:01 - project is slightly different than the
214:03 - one in simple eq so i'm going to go into
214:06 - detail about what is actually different
214:09 - number eight
214:10 - data
214:11 - structures
214:13 - for spectrum
214:15 - analyzer all right we're going to grab
214:18 - these from the simple eq tutorial
214:20 - and then we're going to you know modify
214:22 - them at some point number nine
214:24 - we're going to
214:26 - let's see what are we doing here we are
214:27 - going to do fifo usage in
214:30 - uh plugin processor
214:33 - process block
214:35 - oh i got weird capitalization going on
214:37 - number ten
214:39 - uh well sorry before we do that okay so
214:41 - for the fifo usage
214:43 - in process block um we need to do a
214:45 - little bit of dsp modification to make
214:48 - this happen correctly
214:50 - all right and then let's see number 10
214:52 - is okay implementation of the analyzer
214:55 - rendering pre-computed paths again this
214:57 - is going to be taken from simple eq the
214:59 - simple eq analyzer took a decent chunk
215:02 - of time to develop in that course so
215:04 - there's nothing gained if i duplicate
215:06 - that same chunk of video
215:08 - in this video other than to make this
215:10 - video an hour and a half longer so
215:12 - i'm not going to do that i'm going to
215:14 - include links to the relevant code and
215:16 - we will be copying what we need and
215:17 - reusing it
215:19 - okay number 11
215:21 - drawing crossovers on top of the
215:24 - analyzer plot okay this is where we're
215:27 - going to customize the spectrum analyzer
215:30 - number 12 okay drawing gain reduction on
215:33 - top of the analyzer drawing gain
215:35 - reduction
215:37 - on top of the analyzer
215:40 - again this is the final customization
215:43 - and we will need to write a little bit
215:44 - of dsp code to make this happen so we
215:47 - will be doing a little bit of work in
215:48 - plug-in processor
215:50 - and then let's see the last one uh let's
215:53 - see analyze or bypass analyze the bypass
215:56 - um we're going to use the same code that
215:57 - we used from simple eq
216:00 - and then number 14.
216:02 - let's see we have a global bypass button
216:06 - global bypass
216:08 - button all right and this is just
216:09 - something that every plug-in should have
216:11 - because
216:12 - um it's it just makes it really easy to
216:15 - compare
216:16 - what your plug-in is doing with um if
216:19 - it's not processing anything
216:21 - okay that is wrapping up the gui we have
216:23 - our roadmap so let's start coding up the
216:26 - very first item
216:28 - global controls
216:31 - if you get stuck or run into trouble
216:33 - while coding this or simple eq just grab
216:36 - one of my free products from
216:37 - programming4musicians.com
216:39 - and you can message me directly in the
216:41 - slack workspace and i will help you
216:43 - directly now that we are tackling the
216:46 - editor we can disable the generic editor
216:48 - and use our customized editor plugin
216:51 - processor.cpp
216:53 - create editor
216:54 - comment out this line
216:56 - and
216:58 - there we go
216:59 - all right we want to return our
217:00 - customized editor
217:02 - go to plugineditor.h
217:06 - alright the first thing we are going to
217:07 - do in the roadmap is tackle the global
217:10 - controls
217:12 - i'm not sure what size i want
217:14 - my different gui components to have
217:16 - right now so i'm going to use
217:18 - placeholder components that will show me
217:20 - the sizes i've set
217:22 - these are going to be empty components
217:24 - that only draw a single color so the
217:26 - good thing about this approach is that
217:27 - once i've dialed in the placeholder
217:30 - positioning
217:31 - when i finish developing the real
217:33 - component the screen position is already
217:35 - locked in and i won't have to mess
217:36 - around with the positioning
217:38 - of the component itself
217:41 - let's declare a placeholder component
217:43 - we'll put this here at the top
217:46 - this component is going to draw a single
217:47 - color
217:48 - and that single color is going to be
217:50 - defined when the component is
217:52 - constructed
217:53 - and this compo this color is going to be
217:55 - randomly generated but it will never
217:57 - change once it's configured so here we
217:59 - go struct
218:01 - placeholder
218:02 - let's define our paint function first
218:05 - and we're going to fill the whole thing
218:06 - with this custom color
218:08 - and then the next thing we will do after
218:10 - this is to declare our custom color now
218:12 - that we have used it
218:15 - okay let's declare our custom color next
218:19 - and we will initialize it in the
218:21 - constructor next
218:23 - first we need to declare a constructor
218:25 - and because the autocomplete is not
218:27 - responding as quickly as i would like in
218:29 - this header file
218:31 - i'm going to define this constructor in
218:33 - the cpp file so let's go over to plugin
218:35 - editor dot cpp next all right let's put
218:38 - this at the top
218:40 - all right let's start
218:41 - place holder
218:43 - i'm going to use the juice random class
218:45 - to generate some integers that will
218:47 - populate the rgb values of our custom
218:50 - color
218:55 - okay cool
218:56 - let's give ourselves some placeholder
218:58 - components and position them on the
219:00 - screen next
219:01 - head over to the editor class
219:03 - declaration and add some placeholders
219:06 - plug in editor.h
219:08 - down here at the bottom
219:09 - the editor will be split into four
219:11 - sections
219:12 - at the very top will feature the
219:14 - analyzer bypass buttons and the global
219:16 - band bypass button
219:18 - below that will be the spectrum analyzer
219:20 - with the part that shows the threshold
219:22 - as well as the gain reduction then below
219:25 - that are the global controls and then
219:27 - finally we will have the actual
219:28 - compressor band controls at the bottom
219:31 - so let's declare four instances of the
219:33 - placeholder and give them appropriate
219:35 - names
219:36 - all right let's add these to our display
219:38 - in our editor's constructor so head on
219:41 - over to plugin editor.cpp next
219:43 - we need to add and make our child
219:45 - components visible if we want to be able
219:47 - to see them
219:49 - let's give ourselves a little bit more
219:51 - room and make our editor a little bit
219:53 - wider and a fair bit taller i'm going to
219:56 - go with 600 by 500.
220:00 - all right let's go to resized
220:03 - for the control bar at the top i want to
220:05 - have the analyzer power button on the
220:07 - left and the compressor
220:09 - global bypass button on the right so i'm
220:11 - going to make these sit within a
220:13 - bounding box that is
220:15 - 32 units tall so first let me get the
220:18 - local bounce
220:20 - and now i can get a 32 pixel tall
220:24 - rectangle that will form the bounds of
220:25 - our control bar by calling the rectangle
220:28 - remove from top function
220:32 - this member function will remove a chunk
220:33 - from the top of the rectangle and give
220:35 - us that chunk that was removed as a
220:37 - separate rectangle so i'm going to use
220:39 - that here to give the control bar a
220:41 - bounds that is 32 pixels tall
220:44 - and the same width as our editor and is
220:46 - positioned at the top of the screen
220:51 - next let's position the actual
220:53 - compressor band controls at the bottom
220:55 - of the screen and i think i need
220:57 - something between 130 and 140
221:01 - units in terms of height so let me try
221:03 - 135 first and just like remove from top
221:06 - i am going to use the
221:08 - rectangle remove from bottom function
221:10 - here which behaves just like the remove
221:13 - from top except the chunk is taken from
221:15 - the bottom of the rectangle
221:20 - let's dial in the analyzer bounds next i
221:23 - know i want this to be taller than the
221:24 - band controls and the global controls in
221:27 - the center
221:28 - so let me choose something between 200
221:30 - and 250 all right let's go right down
221:32 - the middle and use 225 and remove that
221:35 - from the top of the bounding box again
221:37 - we're just removing chunks from the get
221:39 - local bounce rectangle and using those
221:41 - chunks as the bounding boxes for our
221:43 - child components
221:47 - okay we removed a small sliver from the
221:49 - top which was for the control bar then
221:52 - we removed the chunk from the bottom
221:54 - for the actual compressor band controls
221:56 - and then we removed a large chunk from
221:58 - the analyzer and that leaves us with a
222:00 - rectangle that will be used for the
222:01 - actual global controls
222:04 - let's run and test this i'm going to
222:05 - switch to the standalone editor
222:09 - and we can find we can fine tune these
222:11 - values
222:12 - after we see what it looks like this
222:14 - very first time
222:16 - all right this looks okay to me this is
222:18 - um this rectangle right here is going to
222:20 - be the control bar at the top
222:22 - uh this is going to be the band controls
222:25 - here's our global controls in the middle
222:28 - and then this rectangle right here
222:31 - this is the analyzer okay i'm happy with
222:33 - these placements we have created
222:35 - placeholders
222:36 - for the main parts of this gui so now we
222:38 - can dial in custom components for the
222:40 - global controls
222:44 - let's make a quick commit
222:47 - added placeholder components
222:51 - also added gui road map
222:53 - all right here's our road map
222:55 - the graph here's where we change to the
222:57 - custom editor
222:58 - here's our placeholder and the usage
223:01 - and here's our placeholder constructor
223:04 - adding all of our child components and
223:06 - positioning them
223:08 - all right let's declare a global control
223:10 - component plugin editor.h let's put this
223:13 - after the placeholder i'm going to start
223:15 - dialing in the graphics before i add
223:17 - sliders to it and the reason is because
223:20 - i want to reuse the sliders that were
223:21 - used in simple eq and migrating those
223:25 - files over to this project
223:27 - will require a bit of code surgery and i
223:29 - want to do this simple task first so
223:32 - let's declare the class first
223:36 - and we just need to add a paint function
223:38 - for now
223:39 - okay now we can replace our placeholder
223:42 - with an instance of this global controls
223:45 - let's flush out the paint function this
223:47 - one that we've got right here head to
223:49 - the cpp file let's put this after our
223:51 - placeholder paint function
223:53 - let's put this after our placeholder
223:56 - constructor
223:58 - okay let's flush this out i want to draw
224:01 - a border around the component but i also
224:03 - want to have a gap between this
224:05 - component and the others so i'm going to
224:06 - use the draw order to handle this since
224:09 - i don't want to have to mess with the
224:10 - component bounds again in the editor's
224:12 - resize function so the first things
224:14 - first let's fill the component with our
224:16 - border color
224:18 - i'm going to be using the juice
224:19 - namespace in here a lot so let me just
224:21 - do the using namespace trick
224:24 - we're going to fill our component bounds
224:26 - let's get them first all right and i'm
224:29 - going to use a blue violet color for
224:31 - right now
224:34 - next let's reduce our bounding box a
224:36 - little bit and fill a rounded rectangle
224:38 - with all black
224:42 - there we go we reduced we set the color
224:45 - to black and then we filled a rounded
224:46 - rectangle let's take a look at this just
224:49 - run it
224:50 - quick let's see what this looks like
224:51 - it's kind of hard to tell because this
224:52 - is
224:53 - a similar color
224:55 - okay to make this easier let's hide some
224:57 - of our placeholders go to plugin
224:59 - editor.cpp go to the
225:02 - editor constructor and let's just see
225:05 - the
225:06 - global controls comment out the control
225:09 - bar the analyzer and the band controls
225:11 - all right let's run it again all right
225:13 - let's get rid of this and we'll fill it
225:15 - with all black
225:16 - go down to this paint function
225:18 - so we will comment all of this out and
225:21 - do g dot fill all fill it with all black
225:24 - now let's run it again
225:26 - okay great let's add this little gap
225:28 - that i was talking about next i wanted
225:30 - to have a little bit of a gap between
225:31 - each of these widgets and go back to
225:33 - global controls paint
225:35 - okay so i want to draw a black border
225:37 - around the entire bounds of this
225:38 - component and since i'm reducing bounds
225:41 - here i need to make a copy of this
225:43 - before i reduce it
225:46 - i need to do this before i do the
225:48 - reduction right now i can reduce like
225:51 - i'm doing here
225:52 - now i can draw this black border so i
225:55 - will give myself a small gap between
225:57 - this component and the surrounding ones
225:59 - without messing with the resized
226:00 - function now for what it's worth i could
226:03 - have accomplished a similar result if i
226:05 - do g dot draw rect
226:08 - i could have achieved a similar result
226:09 - by using the juice path and adding a
226:11 - rounded rectangle to it and then calling
226:13 - g dot stroke path but that would have
226:15 - given me rounded corners on the outside
226:17 - in addition to the inside so this way i
226:19 - end up with a square
226:21 - i end up with square outer corners and
226:23 - rounded inner corners and i like the way
226:25 - this looks a little bit better
226:26 - personally speaking
226:27 - let's take a look
226:29 - all right so you can see there's a
226:31 - little bit of a gap between this and the
226:34 - right edge of the component and
226:36 - between the purple line and the left
226:38 - edge i think this looks really clean you
226:40 - know this nice little gap and there's
226:42 - going to be a little bit of a gap
226:43 - between each of the components
226:44 - i want to use this border effect in the
226:46 - compressor band controls and with the
226:48 - spectrum analyzer but i'm going to wait
226:50 - to refactor this paint stuff until it's
226:52 - actually time for that the next step is
226:54 - to grab the look and feel and rotary
226:56 - sliders from simple eq and get our
226:58 - global controls functioning so let's
227:01 - just we'll close this for now and we'll
227:04 - figure out how to do that stuff next
227:05 - let's make a commit
227:07 - added global control
227:10 - graphics
227:12 - okay
227:12 - i want to reuse the rotary sliders from
227:15 - simple eq in this project these sliders
227:19 - depend on the custom look and feel class
227:21 - that we developed in the simple eq
227:23 - project and the easiest thing to do is
227:25 - to copy the classes from that project
227:27 - and just add them here now if you did
227:30 - not complete simple eq
227:32 - visit the repository linked below the
227:34 - classes will be in the plugin editor dot
227:37 - h and cpp
227:39 - so we're going to copy the declarations
227:40 - for the look and feel class and the
227:42 - rotary slider
227:44 - with labels class let's paste them above
227:48 - our placeholder components so let's go
227:50 - grab simple eq
227:51 - we can grab it from here matcap music
227:54 - simple eq we can go to our source plugin
227:57 - editor.h
227:59 - and we are looking for
228:01 - look and feel
228:03 - all right here's our look and feel so we
228:06 - need the look and feel as well as the
228:09 - rotary slider with labels class
228:11 - this guy right here
228:13 - and this guy right here copy these guys
228:16 - and you can clone it if you want and
228:18 - grab it that way um go to your plugin
228:20 - editor and put it below no put it above
228:23 - our placeholder components
228:26 - okay now we need to grab the relevant
228:28 - implementations draw rotary slider draw
228:31 - toggle button all of this stuff
228:33 - so go back to
228:35 - the um
228:36 - source on github
228:38 - go to the cpp file plugin editor and we
228:40 - are looking for the
228:43 - look and feel draw rotary slider
228:46 - the next look and feel class
228:48 - and then rotary slider with labels paint
228:51 - and any other rotary slider with label
228:54 - functions all right there's a few of
228:57 - them
228:57 - plug-in editor.cpp let's put these at
228:59 - the top
229:01 - put those right there
229:07 - i'm going to put this line between
229:10 - myself and between these classes and the
229:12 - placeholder just so i can tell them
229:13 - apart
229:14 - all right once it is pasted we have a
229:16 - few error messages to deal with let's
229:19 - find out where those are do a quick
229:21 - build and it should show them to us
229:24 - unknown type name power button
229:27 - all right let's deal with these two type
229:28 - errors
229:30 - i want to have a global bypass button in
229:31 - this project and i want to use the power
229:33 - button graphics from simple eq for it
229:36 - so the easy thing to do is to grab the
229:39 - power button class from simple eq and
229:41 - that is found in the
229:43 - editor.h
229:45 - so go back to the source code on github
229:48 - or if you have the project grab it from
229:49 - there plugin
229:51 - h and look for power button
229:54 - all right paste that grab the power
229:56 - button
229:57 - and paste that before the placeholder
230:01 - before the placeholder after the rotary
230:02 - slider with labels class plugin editor.h
230:06 - after rotary slider with labels
230:08 - before placeholder
230:10 - what's the next error
230:12 - analyzer button and i want to use that
230:15 - same button that we used in simple eq to
230:17 - toggle the spectrum analyzer on and off
230:20 - so again just copy the code for this
230:22 - class from the simple eq project and
230:26 - we'll paste it after the power button
230:27 - class so go over here
230:30 - here it is right here right below power
230:31 - button analyzer button
230:34 - copy that and put this in plugin editor
230:37 - after power button and before
230:39 - placeholder
230:40 - all right now try to build it
230:43 - alright build succeeded so with these
230:45 - errors out of the way we can now add our
230:47 - global controls to the gui now
230:50 - all right here is the plan for the
230:52 - global controls
230:54 - number one add generic juice sliders
230:57 - and then
230:58 - do some refactoring because i'm pretty
231:00 - sure we're to reuse some code between
231:02 - the paint function and the resize
231:03 - function for determining the bounding
231:05 - box our sliders will sit inside
231:07 - then we will add parameter attachments
231:10 - then we will replace the sliders with
231:11 - our rotary slider with labels classes on
231:14 - the heap and start using look and feel
231:17 - then we're going to dial in the colors
231:18 - for the sliders and the borders a bit
231:20 - then we're going to add the range labels
231:21 - to the sliders we're going to add a
231:23 - title that's the plan okay so let's dive
231:26 - in and add some generic sliders we're
231:28 - going to need a constructor for adding
231:30 - them as child component where's our
231:33 - global controls class where is that
231:37 - global controls okay down here all right
231:39 - constructor first
231:40 - we're going to need a resized function
231:43 - for positioning them and then we will
231:45 - need some private slider instances
231:49 - we have our input gain slider our low
231:50 - mid crossover slider our mid to high
231:53 - crossover slider and then our output
231:55 - gain slider all right let's head to the
231:57 - cpp file next and then add them as child
232:00 - components plugin editor.cpp let's go
232:03 - after our
232:04 - placeholder constructor
232:07 - let's add some child components
232:11 - all right let's position them
232:13 - add a resized function after paint
232:18 - i'm going to use flexbox for this so
232:20 - first let's get our
232:22 - bounding box then let's make a setup for
232:25 - row positioning because we're arranging
232:27 - these in a row i don't want to write
232:29 - juice all over the place so i'm going to
232:31 - use my using namespace juice let's move
232:34 - this up
232:36 - all right here we go flexbox all right
232:38 - i've declared my flexbox it's going to
232:40 - be a row flexbox and i don't want
232:42 - anything to wrap around
232:44 - now we just need to add every slider
232:45 - with the same amount of flex
232:48 - and then finally we just perform the
232:50 - layout
232:52 - all right let's see what we get let's
232:53 - run this
232:55 - okay those are not rotary sliders we
232:57 - need to customize the type to be rotary
233:00 - all right instead of doing this for
233:02 - every single
233:04 - slider
233:05 - let's declare a rotary slider class and
233:08 - make it inherit from slider and then
233:10 - we'll just set it up so that way it is
233:13 - it has the rotary style with no text box
233:16 - all right let's do this after let's do
233:18 - this right up here app right before our
233:20 - global controls all right let's
233:22 - initialize the base class
233:25 - rotary slider inherits from juice slider
233:27 - and it uses the rotary horizontal
233:29 - vertical drag slider with no text box
233:32 - let's change the type from juice slider
233:36 - here to rotary slider
233:39 - all right and let's test it out go ahead
233:41 - and run it see what we get
233:43 - all right much better okay let's add
233:45 - attachments next and then we will
233:48 - replace these with our
233:50 - rotary slider with labels that we
233:53 - created from simple eq
233:55 - all right let's declare one attachment
233:58 - per slider let's see where am i right
234:00 - now global controls we're down here all
234:03 - right i'm going to allocate these on the
234:06 - heap so that way i can optimize a bit in
234:08 - the constructor i will explain when we
234:10 - get to that stage for now let's just
234:12 - declare a unique pointer to the
234:14 - attachment and create one attachment per
234:17 - slider
234:20 - okay one attachment per slider
234:23 - now if we are using attachments
234:25 - we need the ap vts to look up the
234:28 - parameters so let's modify this
234:29 - constructor
234:31 - and let's change now how we initialize
234:34 - our global controls
234:36 - we need the audio processor
234:38 - dot apbts
234:40 - that's why we made that thing public
234:43 - that's why it's a public member variable
234:46 - way down here
234:50 - all right
234:51 - let's change our constructor plugin
234:53 - editor.cpp go to the global controls go
234:56 - up to this constructor choose ap
234:59 - processor valley true state apv ts
235:02 - okay now all of these attachments are
235:04 - unique pointer which means we have to
235:05 - call std make unique to create them now
235:08 - the slider attachment constructor wants
235:11 - three different parameters number one
235:13 - the ap vts number two the parameter name
235:16 - and number three
235:17 - the slider to attach to the first thing
235:19 - that we need is our parameter map so we
235:21 - can look up the names
235:23 - so let's do that before we start adding
235:25 - these things as child components the
235:26 - next thing that we will be writing a lot
235:29 - is attachment equals make unique
235:31 - attachment and then the three things and
235:33 - that sure seems like an opportunity for
235:36 - not repeating myself
235:38 - by writing a free function now i'm too
235:40 - lazy to look up the type names so i'm
235:42 - going to use the templated function
235:44 - instead and let the compiler figure out
235:45 - the type names so let's head over to the
235:47 - header file
235:48 - we're going to write a function called
235:50 - make attachment we're going to put this
235:52 - after our rotary slider
235:57 - it's going to go right here
235:59 - okay let's start by writing a function
236:01 - with no parameters now in the body we
236:04 - will call the actual make unique call
236:06 - using generic names in our parameter map
236:08 - so let's do void make attachment
236:12 - and here we're going to do attachment
236:14 - equals std make unique it's going to be
236:17 - an attachment
236:19 - and let's see what do we say the first
236:21 - argument that is needed is the apbts
236:26 - second argument is the parameter name
236:28 - which we get from our map
236:32 - and then the third argument is the
236:33 - slider itself
236:35 - okay
236:36 - now that we've got this we can dial in
236:38 - the um parameter list and then we can
236:40 - use template parameters for the five
236:42 - variables that are used in this function
236:44 - this is variable one two three four and
236:48 - five and then there's this thing right
236:50 - here
236:51 - so the first argument is
236:54 - the unique pointer itself std unique
236:57 - pointer
236:58 - of type attachment
237:00 - all right next we have the parameter
237:02 - name
237:03 - let's see well i guess next is actually
237:05 - the ap vts but
237:07 - um we'll just do these in this order
237:09 - yeah we'll do ap vts next ap vts
237:13 - all right then we've got our parameters
237:15 - map that's this thing here
237:17 - so params
237:21 - then we've got the name param name name
237:25 - let's make those guys const and then
237:27 - finally we've got our slider
237:28 - slider type
237:30 - slider
237:31 - okay now we can just add um template
237:34 - parameters for each of these templates
237:38 - like that and now we can do type name
237:42 - and attachment
237:44 - type name apbts type name params
237:49 - type
237:50 - name
237:51 - param name
237:53 - and then type name slider type
237:56 - okay great
237:58 - so again what we did here to figure this
238:00 - out was we just made an empty function
238:02 - with no arguments we implemented what we
238:04 - were going to call and then we said all
238:06 - right what gets used let's add
238:08 - parameters for all of that stuff that
238:10 - gets used and then
238:12 - let's just you know use template
238:14 - parameters for that and then we can use
238:16 - um the compiler
238:18 - feature
238:20 - template type name deduction
238:23 - when we call this function we'll just
238:24 - you know pass in all the stuff it needs
238:26 - and the compiler will figure out all the
238:27 - types and
238:28 - it should all just work just like magic
238:31 - with this helper function in place let's
238:33 - go back to our cpp file
238:36 - and now we can write a lambda that lets
238:38 - us dry calling that make attachment
238:41 - stuff with five parameters instead we
238:43 - can just call it with three parameters
238:46 - so that's dry for the win
238:50 - all right here we go
238:51 - auto make attachment helper equals
238:55 - lambda lambda lambda
238:57 - i always need to call make attachments
239:00 - all right so we just need to pass in our
239:02 - attachment
239:04 - we need to pass in the uh let's see
239:07 - we're going to be using the params so we
239:09 - need to capture those let's capture
239:11 - those by reference
239:13 - we're going to capture the ap vts
239:15 - and then everything else is
239:18 - passed by
239:19 - passed as constructor arguments okay so
239:21 - here's our mpvts
239:22 - here's our params
239:24 - our program name is something we can
239:27 - pass in here and we also need to pass in
239:28 - our slido so let's do
239:30 - auto attachment
239:33 - this should be lower case
239:35 - and then let's do um
239:37 - const auto name and
239:41 - let's see auto slider
239:45 - alright so we can just do name
239:47 - then slider
239:49 - so this is a very similar idea to what
239:51 - we did in
239:53 - the constructor for the audio processor
239:55 - or we made a lambda to
239:58 - basically dry a bunch of
240:01 - code that initialized parameters
240:03 - okay next step is to call our attachment
240:06 - helper for each of those three um each
240:08 - of the attachments for the sliders so
240:10 - make attachment
240:11 - helper our first attachment is the in
240:14 - gain slider attachment and for this we
240:16 - want names gain in
240:19 - and we're attaching this to the in gain
240:21 - slider
240:23 - all right let's do it again for the low
240:24 - mid crossover
240:26 - low mid attachment
240:29 - names low mid crossover and then the low
240:33 - mid
240:34 - slider make attachment we're doing mid
240:37 - high now mid high attachment
240:41 - whoops not make attachment
240:43 - attachment helper that's what we want
240:45 - all right so mid high attachment
240:48 - names mid high
240:51 - and then the mid high slider
240:56 - last one is the output slider make
240:58 - attachment helper
241:00 - this is the out gain attachment
241:03 - names out gain and then name um let's
241:07 - see this is the out gain slider
241:10 - all right cool let's build and test
241:13 - now if we run
241:15 - and tweak some knobs then quit and
241:16 - re-run the sliders should return
241:20 - to the same position that we left them
241:22 - in
241:22 - all right so
241:24 - this is input gain so i'm going to turn
241:26 - this all the way down
241:28 - and we will quit
241:29 - and rerun
241:32 - perfect all right
241:34 - double click to reset
241:36 - okay our compressors are not connected
241:38 - to any gui controls but the input gain
241:40 - and output gain parameters are so let's
241:43 - switch to testing with the aph to make
241:45 - sure the gain controls actually adjust
241:47 - audio levels
241:48 - which they should since you know we just
241:50 - saw it be attached to the parameters but
241:53 - there's nothing wrong with testing okay
241:54 - switch to the vst audio plug-in host
241:58 - and let's run this all right let's run
242:00 - some audio
242:01 - grab your headphones
242:06 - turn down that input
242:09 - [Music]
242:14 - all right
242:18 - perfect
242:20 - okay we can switch these sliders out
242:22 - with our rotary slider with labels next
242:25 - so let's go over here let's make a quick
242:27 - commit as well save quit
242:29 - commit and we want to say that we added
242:32 - not simply q we want to say that we
242:33 - connected up
242:35 - what do we do we have connected let's
242:37 - see let's do two commits here so first
242:38 - number one is added
242:40 - lnf and
242:43 - rotary slider with labels from simple eq
242:47 - that's this stuff here
242:49 - stage this stage this
242:54 - and that's these guys
242:57 - and then that's also this stuff here
242:59 - here's our look and feel
243:05 - that's the look and feel stuff
243:08 - this is all rotary slider with labels
243:10 - stage u okay cool so that's adding the
243:12 - look and feel and rotary slider with
243:14 - labels from simple eq
243:17 - now what did we do next next we did
243:20 - let's see we
243:21 - added um
243:24 - sliders to
243:26 - global controls
243:30 - and then we also wired up the
243:32 - attachments
243:35 - there's our global control
243:37 - there's where we laid them all out with
243:39 - flexbox
243:40 - okay great
243:42 - next let's connect them to the rotary
243:44 - slider with labels
243:48 - all right go to plugin editor.h
243:50 - let's switch these sliders out the
243:52 - rotary sliders
243:54 - with our rotary slider with labels class
243:56 - now this rswl class has constructor
243:59 - parameters specifically and wants an
244:01 - audio parameter first now we have this
244:04 - parameter names map right here
244:07 - in our constructor with the attachments
244:09 - so i'm going to put these sliders on the
244:11 - heap
244:11 - and this is going to let this will allow
244:13 - me to initialize them
244:16 - inside this constructor so i can reuse
244:18 - this map okay if i didn't do that then i
244:20 - would have to use
244:22 - this params
244:24 - dot get params at
244:27 - for each of these
244:30 - sliders and that would be super annoying
244:31 - it would also be really verbose okay so
244:34 - that's why i'm not gonna do that so
244:35 - let's put these on the heap
244:38 - let's get rid of these guys right here
244:39 - let's change this to be std unique
244:42 - pointer
244:43 - rswl
244:45 - and do using r swl equals rotary slider
244:49 - with labels
244:51 - all right even though we're not using
244:53 - this anymore i'm just going to leave it
244:55 - leave it as is
244:56 - okay let's build this real quick and
244:58 - tackle some of these errors that are
245:00 - going to appear
245:01 - all right number one
245:03 - these need to be dereferenced because
245:04 - they are all a pointer so hold down
245:07 - option drag to select all the lines and
245:10 - add the star 2d reference let's do the
245:12 - same thing in resized okay now we can
245:16 - initialize these so let's do in gain
245:19 - slider equals
245:21 - std make unique
245:24 - rs oh that's not going to show us the
245:26 - full name so show me the full name
245:29 - rotary slider with labels
245:33 - all right
245:34 - okay we can fill in our suffix before we
245:36 - start dealing with our the thing that
245:38 - gets the ranged audio parameter so let's
245:40 - see for the uh in gain we want to use
245:43 - decibels so we need to look up a
245:45 - parameter from the ap vts so let's write
245:48 - another helper function that's templated
245:50 - that'll do that for us let's do the same
245:52 - thing go over to the header file we'll
245:54 - do the same thing that we did like we
245:56 - did with make attachment we'll just do
245:58 - it with um you know get the parameter so
246:01 - we'll start by calling functions on the
246:04 - objects that we haven't declared so
246:05 - let's first get a function we'll just do
246:08 - void
246:09 - get param
246:11 - like this and then what we need to do is
246:14 - get our parameter from the apvcs using
246:17 - our map autopram equals
246:20 - apvts.getparameter
246:23 - params.at
246:25 - name or position we'll do name
246:28 - this function returns a pointer so let's
246:30 - make sure it's not null j assert param
246:33 - is not null pointer
246:35 - okay now the let's see what what does
246:37 - this want here this wants a reference
246:40 - let's dereference the parameter that we
246:41 - looked up
246:42 - so let's go return
246:45 - param
246:46 - okay this jsert right here will fire if
246:49 - our parameter is not found but that
246:51 - should never happen because we are using
246:53 - our map
246:54 - to provide the names and also to create
246:56 - the parameters all right now we can
246:58 - start filling in function parameters
247:00 - we need our map we need our ap vts and
247:03 - we need our name okay so let's do um
247:06 - let's see
247:07 - apv ts ap vts
247:11 - we need our params so params params and
247:14 - then our name so
247:16 - name
247:17 - name and this should be const reference
247:20 - and this should also be cost reference
247:22 - now we just need to template it template
247:25 - type name apbts type name params type
247:29 - name
247:30 - name all right
247:32 - now we can call it
247:34 - plugineditor.cpp
247:36 - all right and let's add a helper
247:38 - function just like we did here
247:40 - our make
247:41 - our getparams function needs three
247:44 - parameters and three of those parameters
247:46 - are sorry two of those parameters
247:49 - are the params map and our ap vts yeah
247:51 - we can use a helper lambda to
247:53 - make it so we only need to pass in the
247:55 - name
247:56 - so let's do that
247:57 - auto get param helper equals lambda
248:01 - lambda lambda
248:03 - and let's grab our params and our ap vts
248:06 - by reference and now we just need our
248:08 - name const auto name we need to
248:10 - explicitly specify that this thing is
248:12 - going to return by reference so let's do
248:14 - that
248:15 - and now we can call our function
248:18 - super simple all right cool now we can
248:20 - fill in this placeholder with our lambda
248:23 - get param helper
248:25 - and here we want names
248:27 - in gain
248:29 - gain in and then finally we can replace
248:32 - our alias
248:34 - our rotary slider with labels with our
248:36 - alias r s w l
248:39 - cool that's clean
248:41 - all right now we just need to initialize
248:42 - these let's do the rest of them
248:45 - in-game slider let's see there's the
248:47 - in-game slider
248:49 - all right this is going to be the low
248:52 - mid crossover slider
248:55 - this is the mid-high crossover slider
248:58 - and this is the out gain slider
249:02 - all right this was low mid
249:05 - this was mid high
249:07 - and this was
249:08 - uh gain out and let's see this is in
249:11 - hertz
249:13 - and in hertz
249:15 - let's build that
249:17 - figure out if it's going to continue to
249:18 - give us errors or not
249:20 - oh you know what of course i forgot to
249:23 - change this return type here void return
249:25 - void
249:26 - function get param should not return
249:27 - value but it is returning a juice
249:30 - ranged audio parameter reference
249:34 - all right that's important i could have
249:37 - bogged this up for a while all right
249:38 - let's try it again
249:40 - build that should solve all the errors
249:42 - all right what's wrong with this one
249:43 - here
249:45 - oh you know what it's because these need
249:47 - to be dereferenced because this is a
249:49 - unique pointer now so to reference that
249:52 - because it wants the actual object
249:55 - like that all right
249:56 - let's try building it again
249:58 - voila magic all right let's run this
250:03 - and see what we get all right awesome
250:06 - those look nice and clean
250:08 - they display the value good times
250:12 - i'm very happy with that
250:14 - okay the problem is that they are
250:15 - smashed up to the top of this component
250:18 - so let's dial in this positioning next
250:21 - and we can also switch to using the
250:23 - standalone
250:25 - okay go to the resized function
250:29 - now let's shrink our bounding box a
250:31 - little bit just just enough i'm gonna go
250:33 - with five dot reduced five
250:36 - all right i want to add some spacers
250:38 - between the sliders and also at either
250:40 - end of the row so let's make some
250:42 - instances of the
250:44 - flex item class that will do that for us
250:46 - all right spacers are going to go in
250:48 - between the sliders and then end caps
250:50 - will go on the very ends this is just to
250:52 - kind of nudge everything in towards the
250:54 - center of it
250:55 - let's make the end cap a little bit
250:56 - bigger
250:58 - okay we need an end cap at the beginning
251:00 - and the end of the items array and then
251:02 - spacers in between each item
251:05 - all right here's my end cap
251:07 - and then a spacer between each item
251:10 - let's test it out
251:11 - all right cool so there's a bit more of
251:13 - a gap here a bit more of a gap here and
251:15 - then the gap in between is also a bit
251:18 - it has made these a little bit smaller
251:20 - and notice there's a little bit of a gap
251:21 - at the top too which is great all right
251:24 - let's tweak these colors next
251:26 - all right actually i want to add labels
251:28 - to the sliders next and i want to revise
251:31 - how this was accomplished in simple eq
251:33 - so let's take a quick look at what was
251:35 - done in that project
251:38 - so if i go to the simple eq constructor
251:42 - um let's see
251:43 - which class
251:46 - i can go to any of these classes i'll
251:48 - just look for dot labels okay
251:50 - here we go in simple eq i was hard
251:53 - coding these ranges
251:55 - okay now what i would like to do is
251:56 - actually extract them from the audio
251:58 - parameter for this project
252:00 - in this one i only care about the
252:02 - minimum and the maximum value of the
252:04 - parameter so let's write a helper
252:06 - function that can populate the labels
252:09 - array of our sliders and all we need to
252:12 - do is just give it the parameter
252:14 - for the range and the suffix so it's
252:16 - time for some more template magic
252:19 - let's declare a function and pass in our
252:21 - labels the parameter and the suffix
252:24 - and
252:25 - um we'll get it's just it's going to
252:27 - populate this labels array with the good
252:30 - stuff from the parameter
252:32 - let's go to our header file plugin
252:33 - editor.h let's go after get param
252:37 - now let's see we're going to modify the
252:39 - labels object and
252:41 - we're going to modify labels but
252:43 - everything else can be const to
252:44 - reference
252:45 - all right the first thing we want to do
252:46 - is
252:47 - first declare this function void add
252:49 - label pairs
252:51 - labels this is what our labels are
252:54 - all right everything else is constantly
252:55 - we've got our
252:57 - program
252:59 - type param and then we have our suffix
253:01 - type
253:02 - okay so the first thing we want to do is
253:04 - clear whatever labels are in the array
253:06 - so labels.clear
253:09 - all right so let's just add the first
253:10 - thing labels dot add
253:14 - um let's take a quick look at what was
253:16 - done here all right it was a we used
253:17 - curly brace because it's this position
253:19 - object
253:23 - we can take a look over here let's see
253:25 - it's in the middle of this class
253:28 - all right first object is position
253:30 - second object is a string all right
253:31 - labels.add
253:33 - curly brace first object is a string no
253:36 - first object is the percentage 0.f
253:38 - the second object is
253:40 - um the string okay
253:43 - um and actually let's add some template
253:45 - parameters for now
253:46 - we just need three
253:49 - let's just copy and paste this
253:51 - and do labels
253:53 - param type
253:56 - suffix type
253:57 - perfect
253:59 - all right we know that we need to return
254:00 - a string right here
254:02 - so let's create a function called getval
254:05 - string
254:06 - and it's going to return juice string
254:08 - get val string
254:11 - okay we know we need to pull our value
254:13 - to display from the parameter so let's
254:15 - make that a function argument
254:16 - one of these things
254:19 - next we're going to only display the
254:21 - minimum and maximum values so let's add
254:24 - a boolean flag to the parameter list and
254:26 - this flag will indicate if we should use
254:29 - the low end of the parameter range or
254:31 - the high end of the parameter range
254:33 - bool
254:34 - gets low
254:37 - the thought behind this comes from where
254:39 - we declared all of our parameters create
254:41 - parameter layout
254:43 - we always declared you know minimum the
254:45 - range start and the range end and then
254:47 - it was always
254:48 - step size and skew
254:50 - but
254:51 - you know this is like the low end of the
254:52 - range and this is the high end of the
254:54 - range and that applied for every
254:56 - normalizable range that we created
254:57 - negative 60 positive 12
255:00 - 5 and 500
255:03 - um was there any others no there's not
255:05 - okay so that's where that comes from
255:07 - all right plugin editor dot h that's
255:09 - where this get low flag is coming from
255:11 - the idea behind that okay
255:13 - finally we need to append our suffix
255:17 - so let's make that be the last function
255:19 - parameter
255:20 - now if this was a templated function we
255:23 - could define it here but we know all the
255:24 - types so let's
255:26 - just declare it here and define it in
255:28 - the cpv file
255:30 - top
255:31 - uh well we'll define it in just a second
255:33 - let's use it first though
255:35 - all right go down here and then replace
255:37 - this quoted stuff with a call to it
255:39 - getval string
255:41 - all right now we can pass an hour param
255:43 - we can pass in our suffix yes we want to
255:46 - do true because we want the low
255:48 - parameter at the zero percent
255:49 - and then we can repeat for the 100
255:52 - position
255:56 - one dot f
255:57 - and this should be
255:59 - false we do not want the low
256:02 - we do not want the low param
256:04 - we want the um
256:07 - yeah we want the end per value
256:10 - okay
256:11 - let's go implement this get val string
256:13 - next go to plugin editor.cpp
256:16 - way up at the top let's put this up here
256:19 - all right
256:20 - juice string
256:21 - get val string
256:24 - are you going to auto complete for me no
256:26 - all right let's copy it over from the
256:27 - header file
256:29 - copy
256:31 - paste remove that semicolon add curly
256:34 - braces all right we need our string
256:37 - juice string str
256:39 - let's return it next return str
256:44 - all right let's get our parameters
256:47 - minimum and maximum value
256:49 - from the parameters range autoval equals
256:52 - get low
256:54 - param dot get normalizable range
256:57 - dot start
256:59 - or param dot get normalizable range
257:02 - end
257:10 - okay that's part of the puzzle let's add
257:12 - our suffix str
257:15 - suffix now something that i really liked
257:18 - from the
257:19 - rotary slider with labels class was that
257:21 - um the k the gods appended to
257:24 - the little the letter k that is appended
257:27 - um to the suffix whenever a parameters
257:30 - value was 1000 or higher so let's
257:32 - refactor that into a function that we
257:34 - can use here and in rotary slider with
257:36 - labels and in look and feel
257:39 - all right so i'm gonna let's see where
257:41 - does that happen
257:43 - let's take a look at that logic real
257:44 - quick
257:45 - that's right here if the value is over
257:48 - 999
257:50 - divided by a thousand and then we're
257:52 - going to add the k
257:54 - and then it's like
257:55 - if we have to add k then um
257:58 - we just stick a key on there before we
258:00 - add this suffix
258:01 - very simple all right so i'm going to
258:04 - just add a function at the top i'm going
258:06 - to call it
258:07 - truncate kilo value
258:10 - let's see um let's do void for right now
258:13 - truncate
258:15 - kilo
258:17 - kilo jeez louise
258:18 - value
258:20 - and let's i'm not sure what type i'm
258:22 - going to use so i'm going to do that
258:23 - let's template this
258:25 - i'm declaring it here in the cpp file
258:27 - because this is the only place that will
258:28 - get used currently
258:31 - all right here's the logic if the value
258:32 - is over 9.99
258:34 - divided by 1 000. okay we're passing in
258:38 - by reference because we're going to
258:39 - actually modify this thing
258:41 - and then let's see if we did perform a
258:44 - truncation let's return true
258:46 - and if we didn't let's return false so
258:49 - if value is greater than
258:52 - 999 let's cast this 999 to whatever type
258:56 - t is all right if it's over 9.99
258:59 - value
259:01 - equals static cast
259:03 - t
259:05 - 1 000
259:07 - return true
259:09 - return false
259:11 - all right so if it's over
259:13 - 9.99
259:15 - divided by a thousand
259:17 - and return true meaning yes we did
259:19 - perform a truncation
259:21 - all right let's go use it
259:23 - all right so we can do bool use
259:26 - k equals truncate
259:29 - truncate
259:30 - kilo value kilo value
259:33 - value
259:35 - all right
259:36 - and then um
259:38 - let's see don't forget this function is
259:40 - going to modify this if we used if it
259:44 - performs truncation
259:45 - so we can add our string now str
259:48 - val
259:50 - if we should use kilos append it as well
259:54 - if
259:56 - use k
259:57 - str
259:59 - the letter k
260:00 - we can make use of this in that get
260:02 - display string function
260:04 - over here get display string it's a
260:06 - float param
260:08 - now just looking at the rest of this
260:10 - function here
260:11 - we could probably revise it to use our
260:13 - get valve string function too but that's
260:15 - not something that i want to do i just
260:16 - want to replace
260:18 - this
260:19 - with our code so i'm just going to
260:21 - comment this out
260:23 - and do
260:24 - add k equals truncate
260:28 - kilo value all right a little bit of a
260:31 - code surgery
260:32 - all right um let's see let's go back to
260:35 - where we are creating our
260:38 - sliders because once we once we've made
260:40 - our let's go back to where we are making
260:42 - our attachments
260:44 - it's under global controls constructor
260:46 - because after we make our attachments
260:47 - we're going to
260:48 - add our labels but let's do a quick
260:50 - build to make sure we don't have any
260:51 - template errors first make sure our
260:53 - truncate function works
260:55 - all right cool
260:57 - all right let's use our helper function
261:00 - let's do this right here
261:01 - add label pairs so the first label is
261:04 - going to be the
261:05 - let's see i'm going to do the in gain
261:07 - slider
261:08 - labels
261:09 - and the param is going to be get param
261:12 - helper
261:13 - let's see names
261:15 - in
261:16 - and the suffix type is going to be
261:19 - decibels
261:21 - right let's do it for the next one
261:23 - let's put these on there online
261:26 - add label pairs let's see we got the low
261:29 - mid
261:30 - crossover slider labels
261:32 - pram is get param helper
261:35 - names low mid
261:38 - this is hertz
261:41 - again
261:42 - add label pairs
261:43 - mid high
261:46 - get program helper
261:48 - names
261:49 - mid high
261:51 - also hurts
261:53 - all right last one is the output gain
261:54 - slider add label pairs
261:57 - out gain slider labels
262:00 - get program helper
262:03 - names output gain
262:07 - whoops
262:08 - put that on the next line and decibels
262:11 - okay let's run this
262:14 - and we should see some labels next to
262:16 - our sliders
262:19 - let's see what we got oh build failed
262:21 - what happened no matching call forget
262:23 - val string
262:25 - what did i do wrong oh
262:28 - my get param helper let's see
262:31 - what's the problem candidate function
262:34 - you want a reference parameter what is
262:36 - being passed
262:38 - i'm passing a const reference oh that's
262:40 - why this should be const
262:43 - and that's because
262:45 - that's because it's const right here
262:47 - okay
262:48 - am i going to run into a bunch of const
262:50 - issues
262:51 - let's see undefined symbol yes because i
262:54 - made one const and the other not
262:56 - constant okay this needs to be const up
262:58 - here
262:59 - get val string this should be const
263:02 - build completed build succeeded boom all
263:04 - right we've got our labels negative 24
263:07 - positive 24 20 hertz to 989 one
263:10 - kilohertz to 20 kilohertz perfect
263:13 - and this shows 1k
263:17 - awesome that's fantastic all right cool
263:19 - let's commit that
263:22 - very happy with that
263:23 - make our commit
263:25 - let's see added
263:26 - label pairs two sliders is that what we
263:29 - did
263:30 - um oh no we did uh switched to
263:34 - rswl
263:36 - and added label pairs to sliders perfect
263:40 - all right that was a lot
263:42 - it's not a lot of code here in this
263:44 - commit
263:46 - but in terms of like what we actually
263:48 - implemented that's a lot of
263:49 - functionality
263:50 - okay
263:52 - okay let's look at this constructor real
263:54 - quick we are calling get pram helper
263:59 - twice we're doing it right here when we
264:01 - make our slider
264:02 - and then we're doing it here again when
264:04 - we make our label pairs so let's fix
264:07 - that let's cache our parameters here and
264:09 - then replace accordingly that right here
264:12 - so auto gain in param
264:16 - equals
264:17 - okay
264:19 - let's replace accordingly
264:27 - all right and these ones down here
264:30 - all right cool let's build and test to
264:32 - make sure everything is cool
264:34 - all right i'm gonna change that to
264:36 - negative six brings you to negative six
264:39 - quit rerun
264:42 - all right awesome
264:43 - that works as expected
264:46 - all right let's add titles to our
264:48 - sliders so we're gonna add a third
264:50 - constructor parameter and give it a
264:52 - value of no title
264:54 - so let's go up to our
264:57 - rotary slider with labels class plug an
264:59 - editor get rid of this build target
265:01 - thing
265:02 - plugin editor go to the
265:04 - ranged no not range rotary slider with
265:07 - labels
265:08 - um we're going to add a third
265:10 - constructor parameter to this
265:13 - let's see where is that that's right
265:14 - here
265:16 - we're going to put this on its own line
265:19 - and we're going to give it a default
265:20 - value so everything still constructs um
265:22 - still builds without any errors const
265:25 - juice string
265:27 - title equals no title
265:30 - all right
265:31 - that's the first part we will display
265:33 - the component's name
265:35 - in the paint function so we'll call set
265:38 - name
265:39 - title
265:40 - now let's go to the paint function plug
265:43 - in editor
265:45 - rotor slider with labels paint
265:48 - wait why does this say just oh that's
265:50 - this should that should say juice
265:52 - all right
265:54 - uh paint function right below where we
265:56 - get the slider bounds let's see i want
265:59 - to draw this title at the top of the
266:01 - slider so we need to modify the get
266:04 - slider bounds function to account for
266:06 - this so let's draw our title first and
266:09 - then
266:10 - adjust the slider bounds next
266:12 - first let's get the local bounds auto
266:14 - bounds equals get local bounce
266:18 - next let's set a color and draw some
266:22 - fitted text i'm going to go with blue
266:24 - violet
266:25 - and let's draw some fitted text g draw
266:28 - fitted text
266:30 - all right i'm going to use the rectangle
266:32 - remove from top function to create the
266:35 - bounding box that the title text will be
266:37 - placed in
266:38 - and i'm going to use the get text height
266:40 - function plus a little bit more for this
266:42 - bounding box first things first the text
266:45 - we will display is the name
266:48 - get name
266:49 - the area let's see we're going to be
266:51 - centered
266:53 - justification
266:55 - centered
266:56 - do centered bottom and we're on one line
267:00 - all right
267:01 - let me put these on separate lines
267:04 - uh let's see we're gonna do bounds dot
267:06 - remove from top
267:08 - and the amount to remove is our text
267:10 - type plus a little bit all right let's
267:12 - see
267:14 - how that looks
267:15 - let's comment out this draw rotary
267:17 - slider stuff to begin with
267:20 - all right cool no title excellent
267:23 - all right let's uncomment to this
267:27 - okay so we need to dial in these slider
267:30 - bounds next
267:32 - all right go down to get slider bounds
267:34 - now we need to remove some space from
267:37 - the top of the local bounds so let's do
267:40 - text height
267:42 - minus 1.5 and see how that looks
267:45 - let's see what are we doing right now
267:47 - auto bounds is get local downs and let's
267:49 - trim off the top bounds dot remove from
267:53 - top let's do get text height
267:56 - times 1.5
268:00 - let's see how that looks
268:02 - all right that's very small and it's
268:03 - still colliding with the title
268:06 - so
268:07 - shrinking
268:08 - let's see
268:10 - so let's change the y position of this
268:12 - rectangle to be the y position of our
268:15 - bounds
268:16 - let's do let's comment this out and do r
268:18 - dot set y
268:20 - bounds dot get y instead
268:24 - okay cool so
268:26 - it's not covering up the title now
268:27 - that's good that's progress all right
268:28 - let's adjust the s the slider size by
268:32 - adjusting the size of this rectangle
268:34 - here this thing right here
268:37 - now shrinking the size by
268:39 - twice the text height is too much so
268:41 - let's change this to be 1.5
268:45 - and see what it looks like
268:47 - now that's much better okay this is a
268:49 - much more reasonable size
268:51 - let's remove the default parameter next
268:54 - go back to plugineditor.h
268:57 - let's get rid of this default parameter
268:59 - and
269:00 - let's
269:02 - build and add our titles where the error
269:05 - messages appear
269:07 - okay
269:08 - in-game slider
269:10 - you are going to say
269:13 - input trim
269:15 - in all caps
269:18 - low mid is going to be
269:20 - let's see low
269:22 - mid
269:23 - x
269:25 - over
269:26 - like that
269:27 - let's do this one this will be
269:29 - mid
269:30 - hi
269:32 - no gh x
269:34 - over
269:36 - and then this will be output trim
269:39 - output trim
269:42 - all right let's take a look at this now
269:44 - that we've got our titles in here
269:46 - okay that's fantastic now i don't like
269:48 - this black square in the middle that's
269:50 - surrounding the numbers
269:52 - but we'll fix all of these colors later
269:56 - alright for now
269:58 - that wraps up the global control so
270:00 - that's fantastic let's take a look at
270:01 - that one more time
270:03 - all right awesome very cool
270:05 - let's make a commit of that
270:08 - added titles
270:10 - to
270:11 - our swl
270:17 - bang boom all right
270:19 - so we adjusted that
270:20 - just that part is just that part here's
270:21 - where we actually added the titles
270:25 - we can start working on the actual
270:27 - compressor band controls next
270:32 - let's create the compressor band
270:34 - controls next here's the road map for
270:37 - this component
270:38 - this guy way down here compressor band
270:41 - controls
270:42 - number one we're going to add sliders
270:44 - for the main compressor controls once
270:46 - that's done we will add the solo mute
270:47 - and bypass buttons then we will add band
270:50 - selection functionality meaning we're
270:52 - going to change the parameters that the
270:54 - sliders are connected to uh whenever we
270:56 - click those buttons then we will dial in
270:58 - the colors before we add in the spectrum
271:00 - analyzer and drawing the thresholds and
271:03 - gain reduction all right let's dive in
271:06 - all right we are going to reuse our uh
271:10 - where is that class we're gonna reuse
271:12 - this rotary slider class for right now
271:14 - okay let's put this um
271:17 - yeah we're gonna put this after rotary
271:18 - slider oh let's put it after these
271:21 - functions let's put it above global
271:23 - controls okay here we go
271:27 - all right we need four instances of um
271:31 - the rotary slider class for our four
271:34 - compressor controls
271:38 - okay attack slider release slider
271:40 - threshold slider and ratio slider
271:43 - you know what comes next a constructor
271:46 - and a resized function
271:48 - let's implement those next head to the
271:51 - cpp file
271:52 - let's do this above our global controls
271:55 - uh constructor
271:57 - compressor band controls
271:59 - compressor band controls
272:01 - let's add all of these sliders as
272:04 - children
272:05 - is there anything in here that i can
272:06 - copy
272:07 - yeah i'm gonna copy this
272:09 - we have four sliders
272:11 - those are four sliders being added
272:13 - all right let's just delete this
272:17 - all right now we can add our sliders and
272:20 - let's see they all end in the word
272:22 - slider so i'm going to add that and now
272:24 - i can fill them in tack slider
272:26 - release slider
272:28 - threshold slider
272:30 - ratio slider
272:32 - now i am going to copy the global
272:34 - controls
272:35 - resized code to position these i'm going
272:37 - to move them later when we add the
272:39 - buttons but this is just to get them on
272:41 - screen so go to the compressor brand
272:44 - sorry go to the global controls resize
272:46 - function and we're just going to copy
272:48 - the whole thing
272:52 - and then we're going to paste it
272:56 - now we just need to change these names
272:58 - here
273:00 - attack slider
273:02 - oh sorry we need to change this name
273:04 - first to be uh compressor band controls
273:07 - all right now we can do attack slider
273:10 - release slider
273:12 - threshold slider
273:14 - and ratio slide it's very convenient
273:16 - all right let's change our band controls
273:18 - in the editor to use our compressor band
273:20 - controls class next select this and copy
273:23 - it let's go back to the header file
273:25 - let's get rid of our placeholder in our
273:28 - editor get rid of band controls here
273:31 - oops that's the wrong key command
273:33 - get rid of band controls and get rid of
273:35 - this comma
273:37 - and now add an instance here
273:39 - band controls
273:41 - all right now we just need to make it
273:42 - visible again so go to plugineditor.cpp
273:45 - go to the plugin
273:47 - uh go to the editor constructor
273:50 - and we're going to make our band
273:51 - controls visible let's test it out make
273:53 - sure you're doing the standalone version
273:56 - let's see what we get all right awesome
273:59 - our four sliders very cool so we'll turn
274:01 - them into these um sliders with the
274:03 - labels and stuff in a little bit
274:06 - all right i want to add the same border
274:09 - that the global controls has to this
274:12 - compressor
274:13 - band controls components so let's add a
274:15 - paint function i'm just going to copy
274:17 - this declaration put it right below
274:20 - resized
274:21 - now we can literally just copy the
274:23 - global controls paint function and just
274:25 - rename the class and we'll get that so
274:28 - go to plugin editor go to global
274:30 - controls paint literally copy this
274:33 - paste it after the compressor band
274:35 - controls resize function and just click
274:37 - change the class name compressor band
274:39 - controls change it to
274:41 - like that all right
274:43 - let's run it
274:44 - and see what we get
274:46 - all right i'm very happy with that
274:48 - remember i had said i wanted to have a
274:50 - border with a bit of a gap between
274:52 - the um between these modules
274:54 - all right so that's very clean let's
274:56 - refactor it next because we are
274:58 - literally repeating the exact same code
275:00 - in those two paint functions
275:03 - let's refactor this module background
275:06 - paint code so we aren't repeating
275:08 - ourselves i would like to declare a free
275:11 - function and it's going to be identical
275:14 - to what we are doing in paint except for
275:16 - the call to get local bounds that's this
275:18 - thing right here instead this rectangle
275:21 - bounds will be one of our parameters so
275:24 - i'm going to just put that um where
275:26 - should i put that
275:28 - i'm going to put that um i'm going to
275:30 - put that right above this paint function
275:32 - for right now we'll move it later void
275:35 - draw module background add an empty
275:38 - argument list
275:40 - now we're going to copy these guts over
275:42 - grab this copy copy and paste this and
275:45 - let's see all right first things first
275:46 - we need a graphics context to draw into
275:50 - then we need that rectangle
275:52 - bounce all right now that can let us
275:54 - remove this line there we go okay that
275:57 - takes care of that
275:58 - now we just need to comment out this old
276:00 - code here in our let's see let's do
276:03 - global controls first let's comment it
276:05 - out down here let's get rid of this
276:07 - and let's see i am going to need
276:10 - uh the bounding box so we'll do
276:13 - uncomment that line and now do draw
276:15 - module background bounds
276:18 - oh we also need your graphics context
276:20 - okay
276:21 - let's just uh verify that this works
276:23 - let's run this real quick
276:25 - all right global controls is still cool
276:27 - awesome let's do the exact same thing in
276:30 - global
276:31 - in compressor band controls copy that
276:33 - line scroll on up here comment all of
276:36 - this out and replace it like that
276:40 - all right perfect looks good to me let's
276:42 - get our sliders connected to the
276:44 - parameters next we will create
276:46 - attachments first and then we will
276:47 - change to rotary slider with labels all
276:51 - right let's clean this up we don't need
276:53 - that
276:54 - and we don't need this stuff let's get
276:56 - rid of this code okay fantastic all
276:59 - right head over to your plugin editor
277:01 - dot h go to the global controls
277:05 - and now copy these attachments from
277:07 - global controls we're going to copy them
277:10 - we are going to paste them in our
277:11 - compressor band controls and rename them
277:14 - put them right below our sliders
277:16 - now we're going to do attack slider
277:17 - attachments
277:19 - release slider attachment threshold
277:21 - slider attachment
277:22 - ratio slider attachment let me line
277:25 - these back up
277:28 - let's update this constructor next all
277:30 - right go to plugineditor.cpp
277:33 - go to compressor band controls the
277:36 - constructor
277:38 - and let's see what can we borrow all
277:40 - right we're going to do the same
277:42 - parameter initialization stuff that we
277:44 - did in
277:45 - uh compressor band in global band
277:47 - control so we can grab these things
277:50 - copy this stuff and we'll fix these
277:52 - incorrect names in just a moment all
277:54 - right go up here to the constructor and
277:57 - paste all this stuff let's copy all of
277:59 - that code that initialized those
278:01 - attachments from uh global controls so
278:04 - go down to global controls grab all of
278:06 - this stuff the make attachment helper
278:08 - we're going to need that stuff too
278:10 - grab this code paste it here all right
278:13 - now we need to change all of these names
278:15 - but we'll fix that in just a moment
278:18 - we need to copy the params declaration
278:21 - and update the constructor to receive an
278:24 - ap bts so let's copy that stuff from the
278:27 - global controls constructor as well
278:30 - grab this thing right here
278:32 - all right and paste that here as a
278:34 - constructor argument
278:36 - now let's update the declaration next
278:38 - copy this stuff right here
278:41 - go to plugineditor.h
278:43 - and modify this constructor
278:45 - oops uh this has an extra set of
278:47 - parentheses
278:48 - there we go
278:50 - now we need to revise how our class gets
278:53 - constructed in our editor so go down
278:55 - here
278:56 - and just copy these um copy how the
278:59 - global controls are initialized and just
279:02 - paste it here
279:04 - now we can fix all of these errors in
279:06 - our um
279:07 - constructor here all right so first
279:09 - things first we are doing the um attack
279:12 - attachment slider attachment and this is
279:15 - the attack slider and this name needs to
279:18 - be the attack let's do the um i think we
279:22 - said we were doing the mid band let's
279:24 - see what we did uh yeah we'll do we'll
279:26 - do the middle band first okay so we'll
279:28 - change that all right so there's the
279:29 - attack all right now we need to do
279:31 - release release slider release slider
279:35 - attachment and then this is the release
279:38 - mid band all right now we've got the uh
279:40 - threshold threshold attachment
279:43 - threshold slider
279:45 - and then threshold mid band then finally
279:48 - we have our ratio so this is ratio
279:51 - attachment
279:52 - ratio slider and then ratio mid band all
279:56 - right when we add band switching
279:58 - functionality we will be able to
280:00 - dynamically
280:02 - switch these attachments which will be a
280:04 - very cool thing all right let's test it
280:07 - out we are going to drag a slider quit
280:10 - and rerun and the slider should display
280:13 - this updated position let's see what we
280:14 - get
280:17 - okay
280:18 - i'm gonna do the uh i'm gonna do the
280:20 - attack time i'm gonna
280:21 - yeah i'll do the attack time i'm just
280:23 - gonna put it at 12 o'clock quit
280:26 - rerun the attack slider should be at 12
280:28 - o'clock all right perfect it is double
280:30 - click to reset to the default value
280:32 - awesome
280:35 - our next task is to change rotary
280:38 - sliders with labels so that it accepts a
280:41 - pointer to a parameter instead of a
280:43 - reference the reason is because we will
280:45 - be dynamically changing the parameter in
280:48 - the compressor band controls class
280:50 - whenever we change which band is
280:52 - currently being displayed
280:54 - so the other thing we will do is to move
280:56 - the look and feel to our editor this way
280:59 - every child component inherits the look
281:01 - and feel of the parent class
281:03 - let's go to rotary slider with labels
281:06 - in the header file
281:07 - let's modify this constructor
281:09 - to take a pointer let's change this
281:12 - member initialization
281:14 - let's remove the look and feel member
281:16 - variable
281:17 - copy this and comment it out now
281:20 - by removing the look and feel we no
281:22 - longer
281:23 - need
281:25 - to set it here and we also don't need
281:26 - this destructor so that's cool now let's
281:29 - see before we add a look and feel to the
281:32 - editor let's add a member function which
281:34 - will allow us to change the parameter
281:36 - whenever we want let's go put this here
281:40 - right below get display string
281:42 - void change param
281:44 - and we'll go to juice
281:47 - ranged audio parameter pointer
281:50 - like that
281:51 - all right now we can go all the way down
281:52 - to our editor and add a look and feel
281:55 - member make sure this is the first
281:57 - member variable that gets constructed
282:01 - let's go to our editor's constructor we
282:03 - want to set our look and feel right here
282:06 - set look oh let's do it before
282:09 - uh before we
282:10 - make these guys visible set look and
282:12 - feel
282:13 - lnf
282:14 - make sure you're taking the address of
282:16 - it
282:16 - and now we must remember to set it to
282:19 - null pointer when our component is
282:21 - destroyed we go set look and feel
282:24 - null pointer oops
282:26 - null pointer
282:27 - okay now we can adjust where every rswl
282:30 - is created since the constructor wants a
282:32 - pointer
282:33 - not a reference so let's build it and
282:36 - start fixing all of those errors
282:38 - command b to build
282:40 - all right
282:41 - where does this happen
282:43 - okay so the only spot where we created
282:45 - these sliders is in the global controls
282:48 - function so we just need to pass
282:49 - pointers instead of references so we
282:51 - just need to
282:52 - add our ampersand in front of all these
282:56 - and let's test it out that should clear
282:58 - all of the errors all right build
282:59 - succeeded let's test it out let's adjust
283:02 - the in gain slider and see if it sticks
283:05 - well look at these guys all right turn
283:07 - that down and turn that down to 10
283:09 - quit re-run it should be at 10
283:12 - 10.5 interesting let me do that one more
283:14 - time
283:16 - 10.
283:22 - okay there goes all right cool that
283:24 - looks good to me now
283:26 - let's see i just want to look at that
283:27 - one more time now changing the look and
283:29 - feel um and making the editor
283:32 - own the instance that all child
283:34 - components inherit from really messed up
283:36 - how these compressor band controls
283:38 - uh end up looking so let's fix that next
283:42 - all right go to compressor band controls
283:44 - in the header file
283:46 - all right this class is going to need
283:48 - access to the ap vts in order to look up
283:51 - parameters as needed so let's add a
283:53 - reference to that we can
283:55 - just copy this one
283:57 - right here from our global controls
283:58 - constructor all right next let's change
284:01 - all of these sliders here the attack
284:04 - release threshold and ratio sliders into
284:06 - rotary slider with labels so grab this
284:08 - class right here
284:10 - and paste it there alright we will need
284:12 - to use the member initializer list to
284:14 - initialize all of these
284:16 - next
284:17 - go to plugin editor dot cpp go to the
284:20 - compressor brand control constructor
284:22 - let's initialize all of these members
284:24 - first things first
284:27 - let's do the ap vts ap vts
284:30 - and i'm going to rename this to be apv
284:33 - now let's do all of our sliders attack
284:35 - slider alright we're going to start with
284:37 - nullpointer
284:38 - and our suffix is milliseconds and our
284:41 - title is attack let's do the others
284:44 - release slider same thing null pointer
284:47 - ms
284:48 - and
284:49 - release oops
284:50 - don't forget the quotes so the other two
284:57 - all right let's fix this error in the
284:59 - capture list now we need to do
285:01 - abbvts
285:03 - let's see ap bts equals this apbts like
285:07 - that
285:08 - all right now we are capturing this
285:09 - class's instance of the ap ap vts by
285:12 - reference okay
285:16 - all right let's test this out oh we need
285:18 - to um adjust this make params helper
285:23 - oh you know what i don't know if we
285:24 - actually need this get param helper yet
285:26 - so i'm going to comment that out i might
285:28 - need that in a little bit sure okay
285:30 - let's test this out we'll see what
285:31 - happens maybe we will have sliders with
285:33 - titles
285:34 - who knows
285:40 - uh what's going on here
285:42 - oh this is because it doesn't have a
285:43 - parameter
285:45 - all right let's fix that
285:46 - it's going back here
285:48 - so it turns out we did need this
285:50 - we need to get our parameters
285:53 - and now we can call
285:55 - change param on all of our sliders let's
285:57 - do that right here attack slider dot
286:00 - change param
286:02 - get pram
286:03 - helper
286:04 - let's see this thing returns
286:06 - a reference so we need to get the
286:09 - address of it and the name we want is
286:12 - names
286:13 - attack mid band all right let's do the
286:15 - others we got our release slider so i'm
286:18 - going to just copy this line whoops copy
286:20 - this line paste
286:22 - face paste
286:23 - release slider
286:25 - threshold slider
286:26 - ratio slider all right now this is
286:29 - release mid band
286:31 - threshold mid band
286:32 - ratio mid band let's test this out
286:36 - see what we get
286:37 - an error
286:38 - undefined symbol yes we did not
286:41 - implement this we declared it but did
286:42 - not implement it so let's do that next
286:46 - let's go up to where our rotary slider
286:48 - with labels get display string is we're
286:51 - going to put this at after it
286:53 - void
286:55 - rotary slider with labels
286:57 - and change param is the one we want
287:00 - so whatever parameter we pass into this
287:02 - is
287:03 - um what we need to give it
287:05 - um let's see so this becomes param
287:07 - equals p
287:08 - and then once we get a new param repaint
287:11 - let's try this out all right awesome so
287:13 - these are almost fully functional we
287:15 - just need to add labels next
287:18 - all right go back to the constructor we
287:21 - can use the add label pairs function
287:23 - that we wrote for
287:25 - all of our sliders except the ratio
287:27 - slider and the reason is because the
287:29 - ratio slider labels need to have a colon
287:32 - 1 at the end so we need to define those
287:35 - manually so let's start here
287:38 - add label pairs
287:40 - our first labels are the attack slider
287:43 - dot labels
287:44 - parameter is the get param helper
287:48 - attack mid band we'll refactor this in a
287:50 - little bit those need to be cached does
287:52 - that want to reference it does want a
287:54 - reference we're giving it that all right
287:55 - and our suffix is going to be
287:56 - milliseconds okay do the same thing for
287:59 - the release paste release slider
288:02 - release mid band and then threshold
288:06 - copy
288:07 - paste threshold slider threshold
288:10 - mid band and this needs to be decibels
288:12 - db
288:14 - so the first label for the ratio slider
288:16 - the first ratio
288:18 - is one to one so let's make a label
288:21 - position element let's add a curly brace
288:23 - for this for
288:24 - default initialization all right so at
288:26 - the zero percent position we want to see
288:29 - one colon one
288:31 - all right now the second one should be
288:32 - the highest ratio
288:34 - uh defined in the list of choices so
288:36 - let's get our ratio param
288:39 - let's see this is a
288:41 - juice audio parameter
288:43 - choice
288:45 - and we want to call get param helper
288:48 - we want our names ratio mid band
288:51 - all right now we just need to get the
288:53 - last entry
288:54 - from this let's add our line first
288:57 - um why can't we not why can we not use
289:00 - cannot convert from this to that um oh
289:03 - this returns a reference that's right we
289:05 - should take the address of the reference
289:07 - return okay so now let's see we want
289:10 - ratioslider.labels.add
289:14 - and this is for the 100
289:18 - position
289:20 - and now we are going to add um let's see
289:22 - ratio param
289:24 - choices and we want the last one how can
289:27 - we do that we can do get reference
289:29 - and then ratio param
289:32 - choices
289:33 - size
289:34 - minus one
289:35 - okay let's see how that looks
289:38 - so this is displaying 100.0 and we
289:41 - wanted to say 100 colon 1.
289:44 - so we need to get the integer value of
289:47 - this string
289:48 - and then turn that into a string and
289:50 - then append the colon one to the end
289:53 - all right we can do that
289:55 - we need to change this to be uh choices
289:58 - get reference i'm gonna put this
290:00 - down here
290:01 - all right choices get reference give me
290:03 - the last one
290:04 - all right now you're going to give me
290:06 - the int value
290:07 - and then
290:09 - um let's see i need to turn this into a
290:12 - string
290:13 - first
290:14 - put that in parenthesis juice string and
290:18 - now i can append
290:20 - colon 1 to it let's see how that looks
290:23 - there we go 100 to 1. perfect now let's
290:26 - make the center of the sliders display
290:29 - the current ratio
290:31 - next so for this we will need to derive
290:33 - from the rotary slider with labels and
290:36 - customize the get display string
290:39 - function
290:40 - all right
290:41 - head over to your header file plugin
290:43 - editor.h
290:45 - go to
290:46 - the
290:47 - what's the name of this class go to the
290:49 - rotary slider with labels class all
290:51 - right we are going to override
290:54 - this get display string function so we
290:56 - need to make it virtual first
290:58 - ritual
290:59 - and then we need to make these member
291:00 - variables protected instead of private
291:03 - so the derived class can access them
291:05 - let's clean this up too while we are
291:07 - here
291:08 - all right let's declare a ratio slider
291:10 - class below this
291:12 - now this is a ratio slider which means
291:14 - we can hard code the title whenever we
291:16 - are initializing the base class we still
291:18 - need everything else though
291:20 - so let's just copy all of this paste it
291:23 - here change this class name
291:25 - and fix this indentation
291:28 - all right so all we need is the suffix
291:32 - and the rest is for the base class
291:34 - rotary slider with labels
291:37 - and put this on its own line
291:39 - all right we're passing in
291:40 - our ranged audio parameter our unit
291:43 - suffix and then
291:45 - ratio
291:46 - perfect
291:47 - curly braces
291:49 - all right now we can implement the
291:51 - function that we care about
291:52 - this guy right here get display string
291:56 - override
291:58 - let's implement it next let's go to the
292:00 - plugin editor.cpp
292:02 - go to the
292:04 - uh change param function we're gonna put
292:06 - it right below that
292:08 - all right so let's start the
292:09 - implementation this function returns a
292:12 - string
292:13 - okay
292:14 - what we need to do here is get the name
292:16 - of the current choice to do that we need
292:18 - to convert the program into a choice
292:21 - parameter so that's uh step number one
292:24 - auto
292:25 - choice param equals dynamic cast
292:29 - juice audio parameter choice
292:31 - param
292:32 - let's make sure that we can cast it
292:34 - once we have our choice param we can
292:36 - just get the current choice name
292:41 - now if you remember it displayed 100.0
292:44 - when we used the choice name directly
292:47 - this is because we declared our choices
292:49 - as doubles because i wanted 1.5 to be
292:51 - one of the choices
292:53 - and everything else is an integer value
292:55 - basically which means it's gonna end up
292:56 - with that point zero at the end so if
292:59 - the choice ends with point zero just
293:01 - remove that from the string
293:04 - if current choice dot contains
293:07 - point zero
293:08 - get rid of it current choice
293:11 - equals
293:12 - currentchoice.substring
293:14 - our starting index is zero
293:16 - and our endpoint is the index of that
293:18 - period because the
293:20 - end index is not included in the
293:22 - substring we go from our starting point
293:24 - up to but not including the end
293:27 - currentchoice.index of
293:30 - okay once we've done that just stick the
293:33 - colon at the end current choice
293:36 - colon one
293:37 - all right
293:38 - there's our display string let's test it
293:40 - out let's return it return current
293:42 - choice
293:44 - see what happens
293:46 - nothing and that is because we forgot to
293:49 - change our ratio sliders type
293:51 - copy this ratio slider go to the header
293:53 - file
293:54 - go to the
293:56 - uh where's this class
293:58 - go to the constructor go to the
294:00 - compressor band controls class and
294:02 - change
294:02 - the ratio slider
294:05 - to be that ratio slider
294:08 - all right let's run this we should see
294:10 - the ratio in the center nope we uh
294:12 - what's wrong oh we don't need this third
294:15 - parameter that's why all right let's fix
294:17 - that all right third time's the charm
294:20 - okay cool there we go we're seeing our
294:22 - ratio in the middle let's cycle through
294:24 - them see what we get four five six seven
294:26 - eight nine ten fifteen twenty
294:29 - 100 perfect and what happens when we get
294:31 - to 1.5 is that a thing
294:34 - perfect
294:35 - all right
294:37 - let's make a commit of that
294:42 - so implemented
294:44 - basic
294:46 - comp band controls
294:48 - perfect stage stage
294:55 - let's add the solo mute and bypass
294:58 - buttons next we will position them and
295:00 - then connect them to parameters
295:03 - go to the header file go to our
295:05 - compressor band controls and let's add
295:08 - these after our attachments
295:11 - juice toggle button is the weapon of
295:13 - choice here
295:14 - okay bypass button solo button mute
295:17 - button
295:18 - let's set the name next go to the plugin
295:21 - uh go to the constructor compressor band
295:23 - controls
295:24 - let's do this after we add our sliders
295:27 - bypass button
295:28 - dot set name we're going to draw the
295:30 - name the name is what will be drawn when
295:32 - we configure the look and feel
295:34 - bypass we'll give it an x
295:36 - solo will have a big
295:38 - s in it
295:40 - and mute will have an m
295:44 - okay let's add them next i'm just going
295:46 - to copy three of these
295:48 - paste and now copy paste copy paste copy
295:53 - paste let's go to our resized function
295:57 - okay
295:58 - this component will have band control
296:00 - buttons on the right and band select
296:02 - buttons on the left so let's write a
296:04 - helper function to wrap this vertical
296:06 - arrangement
296:07 - of these buttons in a flex box somewhere
296:10 - since we are using flexbox already for
296:12 - the sliders so first we will pass in a
296:14 - vector of
296:16 - pointers to components that'll look like
296:18 - this
296:22 - std vector
296:25 - component pointer
296:27 - comps
296:29 - then we will declare a flexbox
296:32 - that we will be adding the buttons to
296:34 - but the column direction we can just
296:36 - copy this
296:38 - the column direction
296:39 - or the direction will be column instead
296:42 - of row
296:43 - that's the only change we're going to
296:44 - make there number six i want a small
296:47 - spacer between them so i'm going to copy
296:49 - this
296:50 - again this is vertical
296:52 - so we're going to do with height
296:55 - and
296:56 - i want it smaller than 4 2 pixels is
296:58 - fine
296:59 - all right now we just need to loop
297:00 - through our components add a spacer
297:02 - before and then add the component to the
297:05 - flexbox for autocomp
297:09 - comps
297:10 - flexbox.items.add
297:14 - add the spacer first
297:15 - then add the
297:17 - add to the component
297:20 - add a flex item
297:22 - with a flex of one
297:26 - now our item list currently goes spacer
297:29 - component spacer component spacer
297:31 - component so we need to add one more
297:33 - spacer
297:35 - at the end
297:37 - now we can return our flexbox
297:41 - all right so this is going to be used
297:43 - for the buttons on the right the bypass
297:46 - mute solo buttons and then the band
297:48 - select buttons on the left
297:50 - all right now we can call it
297:53 - we can call our lambda
297:54 - like this with our band control buttons
297:56 - with our uh not banned control buttons
297:58 - with our um
298:00 - uh yeah band control buttons that's
298:02 - right um the bypass mute solo buttons
298:04 - auto band
298:06 - button control
298:08 - correct capitalization auto band button
298:10 - control box equals create band
298:14 - band button control box and we need to
298:16 - provide a vector
298:18 - of our
298:20 - a vector with our components we want the
298:22 - address of the bypass button
298:24 - address of the solo button
298:26 - and the address of the mute button
298:29 - okay next
298:32 - let's get rid of this end cap for now
298:34 - and we're going to replace it with a
298:35 - spacer
298:38 - and now let's add the band control
298:41 - button box on the right
298:43 - flexbox.items.add
298:46 - band control
298:48 - button box band button control box and
298:50 - let's give it a width
298:52 - uh this needs to be wrapped in flex item
298:54 - declare a flex item
298:56 - and let's give it a width
298:58 - uh let's see 30. i you know i usually
299:01 - enjoy buttons
299:02 - and i like gooeys that have buttons
299:04 - around like the 20 to 30 size so we'll
299:06 - start with 30.
299:08 - see what we get
299:11 - okay we're not seeing them
299:14 - let's check the look and feel class next
299:17 - all right let's see go up to the look
299:18 - and feel draw toggle button
299:24 - all right if it's power button it's
299:25 - going to draw something
299:27 - if it's an analyzer button it's going to
299:29 - do something else
299:30 - okay it doesn't do anything if it's
299:32 - neither of those so let's add an else
299:34 - clause
299:35 - it's a pretty silly error okay let's
299:38 - draw a rounded rectangle with the
299:40 - component name in the middle all right
299:42 - if the button is on
299:43 - we're going to draw a black text on a
299:45 - white background otherwise draw a white
299:47 - text on a black background we'll dial in
299:49 - these colors later first let's get our
299:52 - bounding box
299:53 - auto bounds equals toggle button dot
299:57 - get local bounds
299:59 - and i'll shrink it a little bit
300:03 - alright if the button is on
300:05 - it would be nice to know
300:07 - all right let's give ourselves a
300:08 - corner size
300:10 - because remember we're doing rounded
300:11 - rectangle
300:13 - all right let's fill a rounded rectangle
300:15 - with the background color first g.set
300:17 - color
300:19 - if the button is on
300:21 - we're gonna do white otherwise we're
300:23 - doing black
300:24 - and now let's fill our rectangle
300:27 - and then invert the colors and draw a
300:30 - rounded rect followed by the text so g
300:33 - dot let's just copy this line
300:35 - invert the colors so if it's we're gonna
300:37 - do black first
300:39 - and then white depending on if the
300:40 - button is on or off now let's draw a
300:42 - rounded rectangle g dot draw rounded
300:46 - rectangle our corner size is going to be
300:49 - corner size our line thickness will be 1
300:51 - and our rectangle will be bounds dot 2
300:53 - float
300:54 - all right now let's draw our text g.draw
300:58 - fitted text
300:59 - we're going to draw the
301:01 - button get name
301:03 - we're gonna draw it inbounds
301:05 - we're gonna be centered and we're gonna
301:07 - occupy one line of text
301:14 - all right let's test it out
301:17 - boom
301:18 - all right got some toggle buttons
301:22 - fantastic
301:24 - all right let's connect them to
301:25 - parameters next
301:27 - okay go to plugin editor.h go to the
301:30 - bottom of compressor band controls and
301:33 - let's add some attachment i'm just going
301:35 - to copy this code we only need three of
301:37 - these we're using a different attachment
301:39 - we're using
301:40 - button attachment
301:42 - and we cannot use an alias
301:45 - without redeclaring one so let's do btn
301:48 - attachment like that and an indent
301:51 - indent indent we don't need uh we only
301:54 - need three of these
301:55 - so we'll do bypass button attachment
301:57 - solo button attachment
302:00 - mute button attachment
302:02 - and let's indent these so they all line
302:04 - up nicely
302:06 - okay
302:07 - and now
302:08 - head over to the constructor we want
302:11 - compressor band controls
302:13 - and let's use our attachment helper to
302:15 - initialize them make attachment helper
302:19 - our attachment is going to be let's see
302:20 - we'll start with bypass button oops
302:22 - bypass button attachment our name is
302:25 - names um
302:27 - we're doing mid band right bypass mid
302:30 - band and our slider is the bypass button
302:34 - i'm glad we templated that class because
302:36 - it means we can use it with any
302:37 - component not just
302:39 - um
302:40 - not just sliders all right let's do this
302:42 - again
302:43 - i'm just going to copy and paste this
302:44 - and rename stuff
302:46 - all right we've got bypass we got solo
302:48 - attach
302:49 - um we've got mute attach
302:52 - let's see the solo button
302:54 - this was the mute button
302:57 - solo mid
302:59 - and
303:00 - mute mid
303:01 - okay let's test it out
303:04 - that was very quick
303:06 - all right let's let's see um
303:10 - let's um
303:11 - let's close this this will be bypassed
303:14 - close that rerun
303:16 - all right bypass is still working all
303:18 - right let's go
303:19 - test this out in audio plug and host
303:23 - and we adjust the sliders and the solo
303:26 - bypass buttons and see if we hear any
303:28 - differences
303:29 - all right
303:30 - here we go
303:32 - oh headphones
303:36 - [Music]
303:39 - all right we're soloing the mid band
303:42 - and we can adjust all this stuff
303:48 - that is definitely working mute that
303:50 - band seeing it dipped out very cool
303:53 - [Music]
303:57 - [Applause]
304:01 - let's give it a real quick release time
304:06 - [Applause]
304:11 - [Music]
304:16 - that is definitely working
304:18 - all right
304:20 - right past that turn that off
304:22 - stop
304:23 - save quit
304:25 - all right we're getting there okay
304:27 - all of these are working the next step
304:28 - is to add buttons that let us select
304:30 - which band the sliders are actually
304:32 - controlling let's do that next
304:35 - all right let's add three buttons to
304:37 - allow switching of the bands go to the
304:39 - header file
304:41 - and just put them at the end of the list
304:43 - low band mid band high band
304:48 - let's go to the uh constructor and set
304:50 - their name
304:52 - there's a brand
304:54 - i'm just gonna duplicate this
304:56 - i'm gonna put this after the attachment
304:58 - stuff this is low band
305:01 - mid band high band
305:04 - low
305:06 - mid
305:07 - high
305:08 - okay these buttons need to be grouped
305:10 - together so that when you click on one
305:12 - the others toggle off
305:14 - that's what the radio group id is for so
305:17 - low band dot set radio group id
305:21 - set them all to one
305:23 - all right we'll do low band
305:24 - mid band
305:26 - high band these are all part of the same
305:27 - radio group let's make them visible we
305:29 - will position them next
305:32 - paste and now copy paste
305:35 - copy paste
305:37 - copy paste
305:39 - okay let's add another flex box
305:42 - go to the resize function
305:44 - we've got our band button control box
305:46 - let's add another one for the select
305:48 - buttons auto band
305:51 - select
305:52 - control box
305:54 - equals create band button
305:57 - all right let's add our vector
306:00 - with our three buttons
306:02 - low band first
306:04 - mid band next
306:06 - high band last
306:08 - all right let's get rid of the end cap
306:10 - let's replace it with a spacer
306:14 - and now add the band
306:17 - select box on the left
306:19 - flexbox items
306:22 - add flex item
306:26 - here you are going to control the band
306:28 - select control box
306:30 - with flex of one
306:32 - and we're gonna need one spacer after
306:34 - this let's see i'm not gonna do it with
306:36 - with with this flex actually i'm gonna
306:38 - do it with a fixed width um let's see
306:41 - okay so the band control box had a width
306:43 - of 30
306:45 - um and that was displaying a single
306:46 - character of text so i know that this
306:48 - needs to be wider because
306:50 - it's displaying you know three or four
306:52 - characters so let's try 50
306:55 - and we need a spacer after it as well
306:58 - all right let's take a look
307:02 - all right those look nice like that that
307:04 - looks good it's nice um
307:07 - nice positioning of everything so i'm
307:09 - happy with that so let's save this quit
307:12 - this
307:13 - those buttons don't do anything but we
307:15 - will fix that in a bit
307:17 - for now let's make a commit
307:19 - of what we've done
307:21 - what did we do we added um
307:24 - added control buttons
307:27 - to
307:29 - band control what is this thing called
307:31 - compressor band control class
307:33 - presser band controls
307:35 - that's what we did
307:37 - stage
307:38 - stage that
307:40 - um let's see here's where we customize
307:42 - the look and feel here's where we added
307:43 - all of our buttons
307:45 - here's where we
307:46 - added them to the flexbox stage stage
307:48 - stage commit all right awesome
307:53 - if you get stuck or run into trouble
307:55 - while coding this or simple eq just grab
307:58 - one of my free products from
307:59 - programming4musicians.com
308:01 - and you can message me directly in the
308:03 - slack workspace and i will help you
308:05 - directly
308:06 - let's make these band switcher buttons
308:08 - work whenever we click on one of these
308:10 - buttons we will simply reset the slider
308:13 - and the button attachments and recreate
308:15 - the attachments okay the tricky part is
308:17 - figuring out
308:19 - which button was clicked now we're going
308:21 - to be doing all of this stuff before we
308:23 - make our buttons visible so first let's
308:26 - define a lambda that will be called
308:28 - whenever each button is clicked
308:31 - let's capture a safe pointer
308:33 - that is alive for as long as this class
308:35 - exists
308:36 - all right we're going to just speak some
308:38 - stuff into existence
308:40 - all right we're going to do this after
308:41 - we
308:42 - set our radio group and before we set
308:43 - everything visible all right here we go
308:45 - let's make a let's make this lambda
308:50 - all right we have
308:52 - uh declared that a safe point or member
308:54 - variable exists so let's um let's go
308:57 - make one
308:59 - okay go to the
309:00 - plugin editor dot h at the bottom of the
309:03 - compressor band control
309:05 - let's add one here
309:07 - juice
309:08 - component
309:10 - safe
309:11 - pointer come on auto complete
309:14 - there it is
309:15 - all right and it is a compressor band
309:18 - controls and it is an instance created
309:21 - from this
309:22 - and it's called safe pointer
309:24 - and initialization requires curly braces
309:28 - okay
309:29 - all right go back to that constructor
309:31 - okay
309:33 - let's do a quick build to clear that
309:34 - error
309:35 - okay if our save pointers component is
309:38 - valid let's call a function that updates
309:40 - the attachments
309:41 - if
309:42 - auto
309:46 - all right if the safe pointer component
309:49 - exists let's call a function on it
309:51 - alright i'm going to just call a
309:53 - function that doesn't exist yet but it
309:54 - will
309:55 - update attachments
309:57 - okay it doesn't exist yet but it will
310:00 - let's go declare it next
310:02 - plug in editor go to the bottom of this
310:04 - put it right here void update
310:06 - attachments
310:08 - all right we've got our declaration in
310:09 - place let's go implement this after we
310:12 - finish doing what we need to do in the
310:14 - constructor
310:15 - so go back to the constructor because
310:16 - we're not done there we can
310:18 - do a quick build to clear that error
310:21 - all right we've got this lambda so let's
310:23 - assign it to the on click member
310:25 - function
310:26 - why is that still giving oh there it
310:28 - goes error is gone because it says bill
310:30 - succeeded so that's just
310:31 - xcode is just taking a while to catch up
310:33 - all right here we go
310:34 - band dot on click equals button switcher
310:38 - do the same thing for the other three
310:40 - bands low band mid band high band oh
310:42 - sorry don't no parentheses
310:44 - all right we want low band mid band
310:47 - high band okay whenever one of those
310:49 - buttons is clicked it is going to call
310:51 - this function now before we implement
310:54 - update attachments let's make the low
310:56 - band the default band choice by setting
310:59 - the toggle state to true
311:01 - and then we can call our attachment
311:04 - updater function
311:05 - which will connect all the attachments
311:07 - to the appropriate sliders so first set
311:09 - the toggle state to true
311:12 - low band dot
311:14 - set toggle state
311:16 - true
311:17 - and we do not want to send a
311:19 - notification the reason is because
311:22 - sending a notification will trigger this
311:25 - lambda and we don't want that to happen
311:28 - don't
311:29 - choose notification type
311:31 - don't send notification all right let's
311:33 - call update attachments update
311:35 - attachments
311:37 - now we can go implement the update
311:39 - attachments function
311:41 - all right let's start this after the
311:43 - paint function
311:44 - right here void compressor band controls
311:48 - update attachments okay there are a few
311:52 - problems we need to solve in this
311:53 - function
311:54 - number one we have to figure out which
311:56 - button was clicked now we can do this by
311:58 - checking the toggle state of all of our
312:00 - buttons
312:01 - they are part of a radio group which
312:02 - means only one button can be toggled on
312:05 - at a time
312:06 - problem number two we have to figure out
312:08 - which parameters go with which buttons
312:11 - and number three we have to create the
312:12 - parameters like we did in the
312:14 - constructor so first things first let's
312:16 - figure out which button is clicked i
312:19 - don't want to use integers for this so
312:20 - i'm going to declare an enumeration and
312:23 - declare a variable that uses that
312:24 - enumeration as the type then i'm going
312:27 - to immediately invoke a
312:30 - lambda that will determine that
312:32 - variable's value first things first here
312:34 - is the enumeration
312:36 - scroll a little bit
312:40 - and here is the immediately invoked
312:42 - lambda
312:46 - all right this logic is very simple if
312:47 - it's the low band we're going to return
312:49 - low band type if it's the mid band we
312:51 - return the mid band type if it's high
312:53 - band well then the only thing that's
312:54 - left if it's not lower mid is high
312:56 - okay very simple
312:58 - all right next the plan here is to use a
313:00 - switch statement that works off of
313:02 - whichever button was clicked to populate
313:04 - a vector
313:05 - that contains the names from our param
313:08 - names enum that we can use
313:10 - to look up
313:11 - the parameters once we have that vector
313:14 - we can easily figure out which parameter
313:16 - to use with each attachment we have our
313:19 - band type from this lambda now we simply
313:22 - switch based on this band type
313:24 - let's let the autocomplete fill out all
313:26 - of the cases for us switch
313:29 - band type
313:31 - let's get rid of these
313:36 - and press build and wait for auto
313:38 - complete to tell us that we are missing
313:40 - enumeration values
313:42 - there it is
313:43 - all right add missing switch cases thank
313:45 - you
313:47 - let's reindent
313:48 - those correctly
313:50 - all right let's get rid of this get rid
313:52 - of these placeholders
313:53 - okay we have all of our cases now in our
313:56 - switch statement we can declare our
313:57 - vector next and then fill it with values
314:00 - from the param
314:02 - names enumeration next i'm talking about
314:05 - this enumeration right here this thing
314:09 - from
314:10 - a long time ago in this project
314:12 - all right let's create our vector next
314:15 - we're going to need our params namespace
314:17 - using
314:18 - namespace params
314:21 - std vector
314:23 - names
314:24 - names
314:25 - okay
314:26 - we can fill in the switch cases next
314:28 - with the param names for the selected
314:30 - bands
314:31 - so for the let's do the low band first
314:33 - names equals
314:35 - let's see um
314:38 - we need to do this and it's going to
314:39 - complain if i don't define the type
314:41 - because it doesn't know
314:43 - what i'm doing
314:45 - let's see this is going to be names if
314:47 - it's the low band then we're using the
314:49 - attack low band we're using the
314:51 - release
314:53 - release low band and we're doing the
314:54 - threshold
314:56 - let's see attack release threshold
314:59 - ratio
315:01 - and the bypass mutant solo
315:06 - all right this is what to do when it's
315:08 - the low band
315:09 - all right i'm gonna put this in curly
315:10 - braces
315:13 - okay we need to do the exact same thing
315:15 - for the mid band
315:17 - and the high band so grab this stuff
315:20 - paste it and just start replacing the
315:22 - values
315:26 - 1 2 3 h i g h
315:29 - okay great
315:33 - all right
315:34 - fix any errors that come up while you're
315:35 - typing it make sure that for the high if
315:38 - the high button is switched you're using
315:39 - high params if the mid button is
315:41 - switched make sure you're using mid
315:43 - params
315:45 - all right so here's the thing to notice
315:47 - from this we are always doing the same
315:50 - order attack release threshold ratio
315:52 - mute solo bypass
315:54 - attack release threshold ratio mute solo
315:57 - bypass same for here attack release
315:59 - threshold ratio mute solo bypass
316:02 - let's define another enumeration for the
316:04 - possible positions in this name vector
316:06 - and we will index into the names array
316:09 - using this position
316:11 - vector so enum position
316:15 - attack
316:16 - release threshold
316:18 - ratio
316:20 - mute solo
316:22 - bypass
316:25 - let's get our param name map
316:29 - that's auto
316:31 - params
316:32 - whoops that begins with the p params
316:34 - equals get params now the next thing to
316:37 - do is to update the parameter that the
316:39 - slider is connected to let's grab that
316:42 - param helper lambda from the constructor
316:44 - and we need to modify it to use the
316:46 - names vector
316:48 - to provide the parameter name so let's
316:50 - go up here go to our constructor we want
316:52 - the param helper
316:54 - copy this thing here copy go back to our
316:57 - attachment function
316:59 - we're going down here after our position
317:02 - enumeration
317:03 - and we need to capture
317:05 - our names vector and we're going to be
317:08 - using our position
317:10 - thing to index and do so let's just
317:12 - change that pos just so we know what
317:14 - we're doing
317:15 - and now we're going to use let's see
317:19 - let me call get param return get param
317:22 - okay we're passing the ap vts yes we are
317:25 - passing our params map and our name is
317:29 - taken from our names
317:31 - vector
317:32 - at
317:33 - the position this thing right here
317:36 - okay so we're looking up um let's see
317:40 - we have our names array
317:42 - and we're pulling out a position from it
317:45 - so if we pass attack into names and it
317:48 - happens to be the high band we're going
317:50 - to get back this enumeration value and
317:53 - then we're going to pass that into get
317:55 - params as the name of which position to
317:58 - get for the map
318:00 - okay it's a little bit of in direction
318:02 - there to figure out all that stuff
318:05 - all right now we need to reset the
318:07 - attachments before we create new
318:09 - attachment i'm not sure exactly why this
318:11 - is necessary as make attachment ends up
318:13 - calling the same destructor of the
318:15 - slider attachment class
318:16 - however if this is omitted then the
318:19 - sliders don't display the correct value
318:21 - when they are refreshed so if i figure
318:23 - out the answer i will let you know but
318:24 - for now just
318:26 - you know trust me on this attack slider
318:28 - attachment dot reset we have to do this
318:31 - for all of the sliders all the sliders
318:33 - and all the for all of the attachment
318:35 - all right let me work on that now
318:39 - now we can change our parameters and add
318:41 - label pairs to our sliders so let's
318:43 - cache the parameters so we are not
318:45 - calling the helper function twice for
318:48 - each parameter
318:49 - now remember that
318:51 - changing the parameter repaints so we
318:53 - need to add the labels before we
318:55 - actually change the parameter so let's
318:57 - get our attack parameter first auto
319:00 - attack param equals get param helper
319:04 - and our position is going to be
319:06 - the position
319:07 - attack
319:08 - okay remember we are
319:10 - using our names
319:12 - thing
319:13 - to look this up
319:14 - all right and our name
319:16 - our names vector is
319:18 - one of these three choices it could be
319:21 - could contain all mid-band param lookups
319:23 - it could be low band param lookups could
319:25 - be high band param lookups
319:27 - all right
319:28 - that's how all that stuff works okay
319:30 - let's get um let's add our label pairs
319:33 - add label pairs
319:35 - attack slider
319:37 - labels our param is going to be the
319:40 - attack parameter
319:42 - and our suffix is milliseconds
319:45 - all right and now we can change the
319:46 - param
319:48 - attack param
319:50 - excellent
319:52 - now do the same thing for the release
319:53 - param and the threshold param
319:59 - now for the ratio
320:02 - in the constructor if you recall we
320:04 - could not use
320:06 - add label pairs instead we had to
320:09 - manually code them up
320:11 - so
320:12 - let's grab this code because we're going
320:14 - to reuse it
320:15 - actually all this stuff is going to end
320:16 - up getting commented out
320:18 - but let's copy this and actually we need
320:20 - to clear our ratio slider labels ratio
320:23 - slider dot labels
320:26 - dot clear
320:28 - okay
320:29 - all right copy this stuff
320:32 - actually we don't need any of this now
320:34 - because none of this this is all getting
320:36 - set in that attachment um update
320:38 - attachments class
320:40 - we can come with that out now
320:41 - oh we don't need our end cap
320:43 - i'm a big fan of not having any warnings
320:45 - all right way down here at the bottom
320:47 - all right let's get our um our ratio
320:50 - param
320:51 - auto ratio param
320:54 - as a
320:55 - um let's see
320:57 - it's a ranged audio
320:59 - right now we can replace this
321:01 - all right our ratio param is going to be
321:04 - ratio param wrap
321:10 - all right and then now we can change our
321:12 - parameter ratio
321:14 - uh ratio slider dot change param
321:19 - ratio param
321:21 - okay great now we are ready to start
321:23 - updating our attachments
321:25 - so let's use our make attachment class
321:28 - directly ins uh our make attachment
321:31 - function instead of that make attachment
321:32 - helper well we could use that actually
321:36 - let's see where is that helper there's
321:38 - button switcher there's make attachment
321:39 - helper
321:40 - okay here we go grab this guy let's see
321:43 - let's see if we can use this
321:45 - make attachment helper
321:46 - all right make attachment helper first
321:49 - one is the attack slider attachment
321:52 - our name is going to be the names array
321:56 - and we want the position
321:58 - attack
322:00 - our slider is the attack slider
322:02 - okay let's do that for the release
322:06 - slider next
322:09 - now for the threshold slider
322:14 - and now the ratio slider
322:18 - next to the button attachments let's do
322:20 - bypass button first then we'll do solo
322:24 - and finally the mute button
322:27 - all right now we can go to the
322:28 - constructor and delete the code that
322:31 - configures the attachments and the
322:32 - sliders because this function does all
322:35 - of that for us this is a bit of a
322:36 - monster function all right let's go up
322:38 - to the constructor
322:40 - all right we don't need any of this um
322:42 - attachment stuff all right cool we don't
322:44 - need any of this grit get uh get param
322:46 - helper
322:47 - which means we don't need these either
322:49 - is that right can i get rid of that too
322:52 - i can get rid of that
322:54 - excellent
322:55 - all right let's run this switch to the
322:57 - standalone editor
322:59 - that was a big
323:00 - big chunk of surgery we did there on the
323:02 - code
323:03 - out of range
323:05 - why is that happening
323:07 - named that position what is being called
323:09 - here
323:10 - what position did i choose
323:12 - ratio mid band
323:15 - oh uh this is the wrong one
323:18 - okay
323:20 - for this
323:21 - yeah this should not be the names ratio
323:23 - this should be position
323:25 - ratio
323:27 - there we go okay
323:29 - all right there we go okay we're
323:31 - defaulting to the low band that's good
323:34 - all right so to test this out
323:37 - let's
323:38 - uh let's see we're on the low band now
323:40 - let's switch the threshold to like
323:43 - whatever like negative 24. cool let's
323:45 - switch to the mid band
323:46 - that goes back to zero let's switch back
323:48 - to the low band
323:49 - negative 24. perfect all right cool
323:52 - all right the sliders are currently
323:54 - reflecting let's chest the low band i'm
323:56 - going to change this from 50 to
323:58 - 150 whatever
324:00 - go to the mid band
324:02 - go back all right cool that works as
324:04 - expected if i go to the high band and
324:06 - change i'm going to change the release
324:07 - super short so this was five
324:11 - now it's 250 now it's five all right
324:14 - perfect so the next thing to do
324:16 - is to make the solo mute and bypass
324:19 - buttons have custom fill colors to
324:21 - reflect their state
324:23 - then we will make the band selection
324:25 - buttons reflect that state as well so
324:27 - that way if you're on the high band
324:30 - and the low band is bypassed this button
324:32 - will reflect that it's bypassed even
324:34 - though these buttons are currently
324:35 - showing the high band state
324:38 - we'll do that next
324:40 - let's close this let's make a commit of
324:43 - what we did
324:44 - what did we do we added
324:46 - let's see wired up band selection
324:50 - buttons that's a good way to describe it
324:53 - all right let's clean up that
324:54 - constructor
324:56 - um where is that that's here
324:59 - we have a lot of code that does not need
325:00 - to exist
325:02 - let's get rid of this stuff
325:04 - and this stuff
325:07 - all right great
325:09 - let's clean that up stage commence there
325:11 - we go commit awesome all right
325:14 - next we will um
325:16 - next we will adjust the colors that get
325:19 - used whenever you click on a button
325:23 - okay the next thing to do is to make the
325:26 - bypass solo and mute buttons change the
325:29 - slider enablements as well as change the
325:32 - color of the band select buttons also
325:35 - because these buttons are not part of a
325:37 - radio group that means we need to
325:38 - manually make sure that only one button
325:40 - is toggled on at a time
325:43 - that means we need to modify the audio
325:44 - parameters so that only one parameter
325:46 - can be true at a time remember clicking
325:49 - the button changes the audio parameter
325:51 - and the gui then updates itself to
325:54 - reflect the latest value of this audio
325:56 - parameter so we need to accomplish a lot
325:58 - of stuff whenever we click one of these
326:00 - banned control buttons so let's use
326:02 - button listener instead of the button on
326:05 - click lambda to coordinate all of this
326:08 - first things first
326:10 - let's go to our header file
326:12 - and let's inherit
326:14 - from button listener
326:16 - juice button
326:18 - listener let's add a destructor and the
326:21 - appropriate callback
326:23 - all right there we go got my destructor
326:25 - and the appropriate
326:26 - callback for the listener class
326:29 - let's add our band controls as a
326:32 - listener to all of our
326:34 - to our three buttons where are those
326:37 - guys those guys are right here let's do
326:38 - this before we set our name let's do
326:41 - this yeah right here it's fine
326:43 - bypass button add listener
326:46 - this class all right do the same for the
326:48 - solo and mute
326:52 - paste that copy this
326:54 - paste paste
326:56 - let's add the destructor and stop
326:59 - listening to these three buttons
327:01 - put that right here pressure band
327:03 - controls
327:08 - just copy these guys copy these three
327:10 - lines
327:12 - paste it and change this to say remove
327:14 - listener copy paste copy paste copy
327:16 - paste
327:17 - okay the next thing to do is to
327:20 - implement the button clicked function
327:23 - all right let's put this after paint
327:26 - go to the paint function
327:28 - and put it before update attachments
327:31 - void compressor band controls
327:34 - button clicked
327:36 - step number one is to update the slider
327:38 - enablements if you mute or bypass a band
327:42 - if um
327:44 - if a band is muted or the band is
327:46 - bypassed the sliders should be disabled
327:49 - it's extremely common for audio
327:51 - engineers to be adjusting a parameter
327:54 - you know tweaking a knob and they think
327:56 - that the sound is totally changing like
327:58 - totally different wow this sounds so
328:00 - much better when i tweak this knob only
328:02 - to find out that the plug-in was
328:03 - bypassed the entire time when they're
328:05 - done it's this placebo effect but it's
328:08 - with audio so implementing this will
328:10 - prevent this from happening so let's
328:12 - call an imaginary function
328:14 - that does this first and we'll implement
328:16 - it next so here we go update slider
328:19 - enablements
328:20 - that's the first thing we will do
328:22 - let's go declare the imaginary function
328:24 - that we just called
328:26 - copy this
328:27 - header file go to the bottom of it put
328:30 - it after update attachments and let's
328:32 - put this right after oh let's give it a
328:35 - return type void
328:37 - let's put this right after our button
328:39 - clicked class for right now
328:41 - void compressor band controls
328:43 - implementation real quick
328:45 - okay here is the logic to implement
328:48 - if the band is muted or bypassed disable
328:51 - the sliders a simple or statement will
328:54 - give us our disabled status auto
328:56 - disabled equals
328:58 - mute button
329:00 - dot get toggle state
329:03 - or
329:04 - bypass button
329:05 - get toggle state
329:07 - if a button is mute if the band is muted
329:09 - or bypassed it should be disabled
329:12 - once we have our disabled state we just
329:14 - set each slider to that state
329:17 - attack slider
329:19 - dot set enabled
329:21 - if the mute button is on
329:24 - then that means disabled is true and it
329:26 - should be disabled if disabled it should
329:29 - not be enabled so we want opposite of
329:31 - that disabled
329:33 - okay
329:33 - if disabled is true then enabled should
329:35 - be false so if so we want to pass the
329:38 - opposite of disabled all right do this
329:41 - for all
329:42 - four sliders
329:44 - attack slider release slider
329:47 - threshold slider
329:49 - ratio slider
329:50 - let's try this out
329:52 - run this
329:53 - and now let's bypass
329:55 - and cool we can't we cannot interact
329:58 - with these
329:59 - and now we can
330:01 - perfect all right the next thing to
330:03 - implement is replicating the radio group
330:06 - functionality now we cannot use the
330:08 - radio group functionality that comes
330:10 - with the juice button clasp because
330:12 - those require one button in the group to
330:14 - always be on
330:15 - we don't want that we want to be able to
330:18 - solo and unsolo we want to be able to
330:20 - mute and unmute bypass and bun and
330:22 - bypass and also prevent being soloed and
330:25 - muted at the same time so that's way
330:27 - different okay
330:29 - we need to be able to have
330:31 - i'll show you what i'm talking about we
330:32 - need to be able to have these buttons in
330:34 - toggled off state and radio group will
330:36 - not allow that at least one button needs
330:39 - to be on in the radio group well not at
330:41 - least one button needs to always be
330:44 - having a toggle state of true in the um
330:47 - in the radio group okay so that's why we
330:50 - cannot use radio group
330:51 - let's write a function that is called
330:54 - after this guy that updates the solo
330:56 - mute and bypass toggle states so we need
330:59 - to pass in the button that was clicked
331:00 - so we can update the non-clicked buttons
331:03 - accordingly let's call our imaginary
331:05 - function and then implement what it does
331:07 - next
331:08 - update solo mute bypass toggle states
331:13 - and update it with the button we passed
331:15 - in and we're going to pass it as a
331:16 - reference because
331:18 - yeah
331:20 - because it's yeah let's let's just do
331:21 - that
331:22 - all right let's go declare it
331:25 - copy this function name go to the editor
331:28 - put it at the bottom
331:29 - void
331:30 - and pass in a juice
331:32 - a regular juice button as a reference
331:35 - clicked button excellent all right let's
331:38 - implement it next go back to plugin
331:40 - editor.cpp let's put this after slider
331:43 - enablements before update attachments
331:46 - void compressor band controls
331:48 - update solo
331:50 - whatever that huge name was that we came
331:52 - up with
331:53 - all right the logic here is pretty
331:54 - simple if you click the solo button on
331:58 - toggle the mute button and the bypass
332:00 - button off
332:01 - if you click the mute button on toggle
332:03 - the solo and bypass buttons off
332:07 - if you click bypass on toggle the mute
332:10 - and solo buttons off and if you click a
332:13 - but if you click a button off
332:15 - don't do anything and we need to
332:18 - remember to send the notification as
332:20 - that is what alerts the parameter
332:22 - attachment to update the audio parameter
332:26 - all right so here is what this code ends
332:29 - up looking like i'll show you the first
332:31 - one if the clicked button is the solo
332:34 - button and the solo button was clicked
332:37 - on
332:38 - set the bypass
332:40 - to false and send that notification to
332:42 - update the parameter
332:44 - do the same for the mute button set the
332:46 - mute button to off and send the
332:48 - notification
332:49 - all right now we need to do the same
332:51 - thing for the mute button
332:53 - as well as the bypass button okay there
332:56 - we go
332:57 - if the clicked button is the mute button
332:59 - and the mute button was toggled on
333:02 - turn off the bypass button and turn off
333:04 - the solo button
333:06 - if the clicked button is the bypass
333:08 - button
333:08 - turn off the mute button and turn off
333:12 - the solo button let's try this out we
333:14 - should be able to click on the buttons
333:16 - and only one should be toggled at a time
333:20 - all right solo
333:22 - mute
333:23 - mute bypass bypass off solo on soul off
333:27 - mute on mute off
333:31 - all right cool
333:33 - that works as expected so the next thing
333:35 - is to make these
333:36 - solo mute and bypass buttons use a
333:39 - custom color whenever they are toggled
333:42 - let's make a commit before we go any
333:44 - further
333:45 - what did we do we added um
333:48 - let's see we uh added
333:50 - solo mute
333:52 - bypass
333:55 - click functionality that's a i don't
333:58 - know any other way to describe it and
333:59 - that's a pretty good description of what
334:01 - it's doing
334:02 - um added
334:04 - extended click functionality
334:06 - all right commit that stuff okay
334:09 - all right like i said the next thing
334:11 - that we have to do on our to-do list is
334:13 - to make the band buttons for um first we
334:17 - have to make the solo mute and bypass
334:19 - buttons show a custom color whenever we
334:21 - click on them and then we need to make
334:22 - the band select buttons reflect that
334:24 - state of the band but before we do that
334:28 - we're going to do something else
334:31 - before we tackle the next item in the
334:34 - band controls to do list
334:36 - let's create separate files for
334:39 - all of the classes we currently have in
334:41 - editor
334:42 - um
334:43 - editor.h and editor.cpp
334:45 - so these
334:46 - this these two source files are getting
334:48 - pretty cluttered so what we're going to
334:50 - do is one class or namespace
334:53 - per source file so here is the process
334:55 - we're going to use producer to create a
334:57 - new set of source files we're going to
334:59 - migrate the class over and we're going
335:00 - to repeat this until all non-original
335:03 - classes and namespaces have been moved
335:05 - into their own source files once that is
335:08 - done we're going to correct all of the
335:10 - include directives and keep trying to
335:12 - build until it builds successfully
335:15 - so let's go over to producer let's sorry
335:17 - let's go to our header file first let's
335:19 - go all the way to the top alright first
335:21 - thing we're going to do is look and feel
335:23 - okay
335:24 - first thing we're going to do is look
335:26 - and feel
335:27 - new cpp and header file
335:29 - look and feel
335:34 - all right that went in the wrong place
335:36 - let's get rid of that
335:42 - put it here look and feel
335:46 - all right save and open
335:49 - now go to plugin editor
335:51 - and just start migrating stuff over
335:56 - okay let's do the cpp file next
336:01 - this is an instance where it's very
336:03 - helpful to use the assistant editor
336:07 - all right that's one class
336:11 - oh we don't need this anymore let's get
336:12 - rid of that
336:15 - okay let's do rotary slider with labels
336:17 - and we will put the ratio slider in that
336:20 - class as well
336:21 - because it's you know it has like
336:23 - minimal there's no reason for it to be
336:25 - its own
336:26 - to be in its own separate source file so
336:28 - we'll grab all of this and put it there
336:29 - okay let's do ratio let's do a rotary
336:33 - slider with labels
336:36 - rotary slider with labels
336:42 - grab these guys
336:45 - cut
336:48 - paste
336:49 - and we need our juice header
336:52 - we need to copy these functions
336:54 - collapse collapse
336:58 - and ratio slider
337:01 - okay
337:04 - cut and paste
337:09 - all right next we can do our buttons the
337:11 - analyzer and the power buttons
337:14 - these guys are implemented in class so
337:16 - we just need a header file for that
337:19 - well you know let's do header and source
337:23 - custom buttons
337:27 - cut
337:29 - custom buttons
337:32 - include
337:34 - juice header
337:35 - all right let's move this analyzer
337:37 - toggle button
337:40 - copy
337:42 - paste
337:44 - add the fully qualified name
337:47 - and get rid of this there we go
337:51 - and we don't need the override
337:52 - keyword okay uh placeholder component
337:56 - and we can leave that
337:58 - we do need to
337:59 - yeah we'll just add those as like um
338:02 - we'll just do like utility utility
338:05 - components
338:06 - utility comps
338:08 - utility components
338:14 - okay copy these guys
338:18 - paste them here
338:20 - juice header
338:23 - plug-in editor all right
338:25 - our placeholder constructor
338:29 - might as well put the paint function
338:31 - there
338:35 - and now our rotary slider
338:40 - there we go okay
338:42 - next
338:44 - all right we need some utility classes
338:46 - for all of these templated guys
338:55 - utilities i'm just going to call it
338:57 - utilities
339:01 - all right let's see we need to move make
339:04 - attachment
339:06 - that goes here
339:11 - what else goes here
339:12 - um get param that should go there
339:17 - get vowel string declaration of it that
339:19 - should go there
339:22 - let's grab um get val string
339:26 - that goes here
339:28 - let's see um we can do this truncate
339:30 - kilo value that's templated so that can
339:32 - go here as well
339:35 - and then add label pairs
339:38 - all right let's see what else should go
339:40 - there i think we can use our
339:43 - draw background function where did that
339:45 - go
339:47 - that here that's in this class
339:49 - draw module background let's do that one
339:51 - too that should move as well
339:53 - cut this
339:54 - put that at the end of this cpp file and
339:57 - grab the
339:59 - declaration
340:01 - okay
340:03 - all right now we need a compressor band
340:05 - controls
340:11 - compressor band controls
340:18 - all right you know let me let's organize
340:20 - these
340:22 - let's see sort
340:24 - alphabetically
340:25 - there we go
340:29 - okay plugin editor dot h let's grab
340:31 - compressor band controls
340:36 - paste it here
340:38 - and don't forget the juice header
340:41 - all right let's collapse all of these
340:44 - so they're easy to copy
340:46 - sized
340:48 - paint
340:49 - button clicked
340:51 - update enablements
340:53 - update solo mute update attachments okay
340:57 - copy all of these over
341:01 - all right what do we have left
341:03 - global controls okay
341:05 - last one
341:08 - global
341:11 - controls
341:17 - all right plugin editor we need our
341:19 - global controls
341:21 - paste them
341:22 - here include the juice header
341:26 - and now let's grab our global controls
341:28 - from the cpp file collapse all these
341:31 - down
341:32 - okay cool it's just three functions very
341:34 - cool
341:36 - all right
341:37 - and is there anything in plug-in
341:39 - processor yes we have our params
341:42 - let's do that next
341:47 - params
341:54 - let's add the juice header
342:00 - and we can probably move this to the cpp
342:03 - file um it's not necessary though
342:07 - all right next one is compressor band
342:09 - let's do that next
342:14 - compressor band
342:22 - all right let's copy this guy over
342:24 - okay
342:26 - include
342:28 - juice header
342:29 - awesome
342:31 - and let's see we can do all of this
342:35 - cpp file
342:38 - very simple all right
342:40 - just turn all these into declarations
342:44 - oh you know we're here we can check off
342:46 - some things we did our global controls
342:48 - those are done
342:50 - we have added our main band controls
342:51 - that's done
342:53 - we added solo mute bypass and we did
342:56 - band select functionality
342:58 - very cool
342:59 - so we have split all this stuff up and
343:01 - if we build it we're going to have a ton
343:03 - of include errors
343:05 - let's fix that stuff next
343:07 - the way that you do this is just start
343:10 - building it and tackling the errors
343:12 - expected namespace so we need to include
343:14 - that
343:17 - include
343:18 - params.h
343:20 - just start building it until stuff
343:22 - disappears
343:23 - all right compressor brand control
343:24 - unknown type name rotary slider with
343:26 - labels let's include that include
343:29 - rotary slider with labels
343:33 - go to the next one ratio slider
343:35 - that's part of that class that's fine
343:37 - um okay
343:39 - button listener let's just see what it
343:40 - does let's just start clearing stuff out
343:42 - look and feel needs to know about the
343:45 - rotary slider with labels class in the
343:47 - cpp file
343:48 - include
343:50 - rotary slider labels
343:53 - you need to know about our utility
343:55 - function kilo value
343:57 - include utilities i believe is what i
344:00 - called it yes
344:02 - uh plug-in processor you need to know
344:04 - about the compressor band
344:08 - all right plug an editor you need to
344:09 - know about look and feel
344:11 - include
344:12 - look and feel
344:14 - what else do you need to know about you
344:16 - need to know about global controls and
344:17 - compressor band controls
344:20 - include
344:21 - global
344:24 - holes include compressor band
344:28 - controls
344:30 - global controls you need to know about
344:32 - rotary slider with labels
344:35 - global controls constructor you need to
344:37 - know about params
344:40 - all right placeholder where is
344:42 - placeholder located
344:44 - include utility
344:47 - utility components that's where that was
344:50 - all right global controls needs to know
344:52 - about get param that's in utilities
344:56 - all right cool power button
344:58 - you are located in those custom buttons
345:00 - is that what it's called
345:02 - that will be called that file yes
345:08 - all right draw module background that is
345:10 - found in the utilities
345:15 - i need to know about the params
345:20 - oh build succeeded all right let's run
345:22 - it let's see if it looks the same
345:24 - fantastic all right cool let's make a
345:26 - commit of that
345:28 - all right
345:29 - refactored into separate
345:33 - files
345:34 - that's huge there's our compressor band
345:38 - custom buttons global controls
345:44 - and actually what i want to do
345:47 - uh before i commit that i actually want
345:49 - to put these into
345:50 - dsp and source folders so here is let's
345:54 - see programming simple mbcomp
345:57 - uh not build source i'm going to add a
345:59 - new folder
346:00 - i should have done this when i created
346:01 - the files
346:03 - all right click
346:04 - um how do i make a new folder in here
346:08 - new folder
346:09 - dsp
346:10 - and then
346:12 - i'm gonna make another new folder
346:15 - gui
346:16 - all right dsp stuff goes in here
346:20 - compressor band goes in here that's in
346:22 - dsp
346:23 - params is part of dsp
346:26 - um everything else seems to be gooey
346:28 - gooey look and feel is definitely gooey
346:31 - custom buttons
346:33 - compressor band controls is definitely
346:35 - gooey
346:37 - rotary slider with labels
346:39 - is definitely gooey
346:41 - and utility components is definitely
346:44 - gooey
346:46 - utilities
346:48 - this is all gooey stuff so we'll just
346:51 - leave it in there
346:53 - all right now let's fix
346:55 - this
346:57 - by deleting this
346:59 - so we'll just delete the entire chunk
347:03 - just remove the references and just drag
347:05 - the whole source file in
347:07 - perfect
347:08 - save and reopen
347:10 - okay now we need to fix all of these
347:12 - includes now that they are organized
347:14 - correctly
347:18 - so let's do a build
347:21 - and start fixing errors
347:23 - look and feel not found because it is
347:24 - found in gui
347:27 - like that all right global controls
347:29 - all those are in the gui
347:32 - we can really just look through this
347:33 - okay this is um
347:35 - params is fine let's see compressor
347:38 - that's all going to be in there so it's
347:39 - really just plugin editor that needs
347:41 - this stuff and then plug-in processor
347:44 - needs that stuff that way
347:47 - all right params you are going to be
347:49 - located in dot dot slash dsp
347:53 - like that
347:55 - right include dot dot slash dsp
347:59 - params yeah that was right okay
348:07 - all right any of these files that need
348:10 - it are going to be the same this is dsp
348:13 - slash
348:14 - same for global controls
348:18 - all right build succeeded let's run it
348:20 - just to make sure
348:22 - cool
348:23 - all right now we can make our commit
348:26 - let's just stage all of this
348:30 - okay
348:31 - here's our compressor band
348:36 - let's look at this all right compressor
348:38 - band that's cool that's cool
348:40 - also cool
348:41 - [Music]
348:42 - all right because we didn't we opted to
348:44 - not move this to the cvp file
348:47 - okay compressor band controls
348:50 - all this stuff
348:52 - all right
348:53 - this is fine let's commit these 23 files
348:56 - okay great that was an epic refactor
348:59 - but now our plugin editor
349:02 - is much simpler
349:07 - let's customize these button colors
349:10 - let's enable the ability to customize
349:12 - the color per button by using the find
349:15 - color member function of the component
349:17 - class
349:18 - these are toggle buttons that we're
349:19 - currently doing
349:21 - uh but we will use the text button color
349:23 - ids to figure out which color we want
349:26 - let's i just want to show you which ones
349:28 - i'm talking about if we go to draw if we
349:30 - go to the toggle button class and then
349:32 - actually go to the text button class
349:34 - there are several color ids that we can
349:36 - use we can use
349:38 - color id when the button is off when
349:39 - it's on and then the text color for when
349:41 - it's off and when it's on
349:43 - okay so we'll be working with that stuff
349:47 - all right let's work through this
349:49 - revision let me show the code first
349:52 - all right we are calling set color twice
349:54 - right here and right here
349:57 - one for the background that's what the
349:58 - first one does when we fill our
350:00 - rectangle and then the second one for
350:02 - the border that's what this one does and
350:04 - then the text that's what this line does
350:06 - okay for the background we want to use
350:08 - the button on color id and the button
350:12 - off color id
350:13 - okay
350:14 - the trick is to remember to call find
350:16 - color on the toggle button itself that
350:19 - means we need to remember to set both of
350:21 - these colors the button on color and
350:24 - button off color
350:25 - we need to set both of these on the
350:27 - button itself in order for this find
350:29 - color lookup to actually work we're
350:32 - going to customize the border color
350:33 - later when we work on the color scheme
350:35 - for the entire plugin so for now let's
350:38 - head back to the compressor band
350:40 - controls class and assign some default
350:42 - colors for these guys
350:45 - head over to compressorbandcontrols.cpp
350:47 - [Music]
350:49 - all right we're going to do this after
350:51 - we add our
350:52 - uh
350:53 - after we set our low bands name
350:56 - we're going to
350:57 - um we're gonna do low band and we're
351:00 - gonna set the color and we need to do
351:01 - the on color and the off color
351:04 - so
351:05 - low band dot set color
351:08 - and then we need to provide the name
351:10 - we're doing juice text
351:12 - text button
351:14 - color ids
351:15 - and we're doing the
351:16 - button on color
351:18 - for this i'm going to do gray
351:21 - all right for the off color let me copy
351:23 - this
351:24 - for the off color i'm going to do
351:29 - black
351:30 - now don't forget the on button and the
351:32 - off button color need to be set for this
351:35 - to work
351:36 - all right let's do the same
351:38 - do the same thing for the other two
351:40 - bands
351:43 - all right we just need to change the
351:44 - names here
351:47 - high band
351:48 - high band
351:50 - all right next let's set the colors for
351:52 - the bypass solo and mute buttons when
351:55 - these buttons are toggled on they should
351:57 - each have a different fill color i'm
352:00 - gonna go with yellow for bypass greenish
352:02 - for the solo and then red for the mute
352:05 - because usually when a button when a
352:07 - track is muted
352:09 - on a like an actual console it's got a
352:11 - red led
352:12 - all right and then if you solo it it's i
352:15 - don't know maybe it's yellow or whatever
352:16 - i don't know i haven't looked at a
352:18 - console in a while regardless let's add
352:21 - these colors next
352:23 - all right here's the bypass we'll do the
352:24 - bypass button first
352:25 - set name
352:27 - okay first color i'm going to do for
352:29 - bypass i'm going to do yellow and black
352:31 - yellow when it's on and black when it's
352:34 - off for this is the fill color not the
352:36 - border color
352:37 - the solo button next
352:40 - i'm gonna do lime green and black
352:43 - and the mute button is gonna be red and
352:45 - black
352:47 - red when it's on black when it's off
352:50 - okay let's test this out
352:52 - let's do a quick run
352:55 - all right cool so we get gray when it's
352:57 - selected that's cool
353:00 - and this is yellow this is greenish and
353:03 - red
353:05 - all right fantastic
353:08 - the next thing to do is to make the band
353:10 - select buttons these guys right here we
353:12 - need to make their fill color reflect
353:14 - the state of the band if the band is
353:16 - soloed then we want this button to be
353:18 - green if the band is bypass we want this
353:20 - to be yellow if this is muted we want it
353:22 - to be red every time we click a button
353:25 - we need to refresh these colors for the
353:27 - active band so let's head down to the
353:29 - button clicked function
353:31 - next all right head to the header file
353:34 - and we're going to add a pointer right
353:36 - here that is going to keep track of
353:39 - which band is the active band this is
353:41 - based off of which band select button is
353:44 - currently toggled on juice toggle button
353:47 - pointer active band and it's going to
353:50 - default to the low band right now we
353:52 - need to update which band is the active
353:54 - band whenever we make new attachments go
353:56 - to the cpp file go to update attachments
353:59 - and we can do this in the switch
354:00 - statement if we click on the low low
354:02 - button then we need to say that the
354:04 - active band is the low band if we click
354:07 - on the mid band
354:09 - and it's the mid band click on the mid
354:11 - band button the active band is the mid
354:12 - band and then finally if we click on hi
354:16 - active band is the high band what's cool
354:19 - about this is we don't have to check
354:21 - toggle state to figure it out all right
354:22 - let's go back to button clicked alright
354:24 - let's call another imaginary function
354:27 - update the active band fill colors let's
354:30 - call it first then we will declare it
354:32 - and then implement it
354:33 - update
354:34 - active band fill colors and we'll pass
354:38 - it the button
354:39 - that's currently being used all right
354:41 - let's go declare it next go to the
354:43 - header file let's put it down here void
354:46 - update active band fill colors juice
354:49 - button clicked button now this function
354:52 - is basically going to call active band
354:55 - arrow set colors with specific colors
354:58 - let's go implement it now copy this
355:00 - thing go back here and let's put this
355:03 - above update slider enablements
355:06 - put it right here compressor controls
355:09 - update band fill colors
355:11 - um what's it called
355:13 - yeah that's right
355:14 - oops let me just use autocomplete
355:18 - there it is
355:19 - okay first things first let's make sure
355:21 - our active band is valid i don't see why
355:24 - it would ever be but just you know just
355:27 - make sure
355:28 - all right and let's print out the name
355:30 - just so we know what's going on
355:32 - active band
355:34 - active band
355:35 - get name
355:36 - next if the button's toggle state is off
355:39 - we need to reset the active band's
355:42 - colors back to the default colors so
355:44 - let's call an imaginary function for
355:46 - that if clicked button
355:48 - dot get toggle state is false if the
355:51 - button is off then reset active band
355:55 - colors we'll fill that in we'll
355:56 - implement that in just a moment
355:58 - otherwise
355:59 - we need to refresh the active bands
356:01 - colors and we need to pull the colors
356:04 - from the button that was clicked so
356:06 - let's call another imaginary function
356:09 - refresh band button
356:12 - colors active band
356:14 - and the clicked button okay let's
356:17 - implement reset active colors next
356:20 - first let's declare it header file void
356:23 - reset active band colors
356:27 - and let's put this above slider
356:30 - enablements void compressor band
356:32 - controls
356:33 - reset active band colors so first the
356:36 - button was clicked off let's restore the
356:38 - active band to the default fill slash
356:41 - off colors active band
356:44 - set color and we're going to do the
356:46 - button on color text button color ids
356:49 - on color
356:51 - and we want to do that gray color juice
356:53 - colors
356:55 - now we're currently using gray for the
356:56 - default color but we will eventually
356:58 - build a system that lets us look up
357:00 - colors from the global color scheme it's
357:02 - going to be similar to that
357:04 - params names system that we built
357:06 - earlier but it's going to be for colors
357:09 - okay let's implement the other function
357:11 - after we do the rest of this all right
357:13 - so we've got our active color for on is
357:15 - this and then we need to do the off
357:17 - color and we're using black here
357:20 - now changing the color doesn't cause it
357:21 - to repaint so let's do that next
357:24 - let's implement the other function
357:26 - refresh band
357:28 - button colors let's declare this guy
357:30 - right here
357:31 - this one right here
357:33 - copy it go to the header file void let's
357:36 - make it static so we can use it with any
357:37 - button pair that we need static
357:40 - and the first thing is going to be juice
357:42 - button
357:43 - and then juice button color source we're
357:46 - going to pull colors from the color
357:47 - source and apply them to the to the
357:49 - first param
357:51 - let's go to the implementation cpp file
357:54 - uh put it above reset
357:56 - void compressor band controls refresh
358:00 - okay we're going to do band dot set
358:03 - color and now we need to copy copy the
358:06 - button on color id from the source to
358:09 - the band button on and we're copying um
358:12 - we are copying color source color source
358:16 - dot find color this thing
358:18 - since we want this color to persist when
358:20 - we change the selected band we need to
358:23 - also set the off color to the color
358:26 - sources on color and what i mean by this
358:28 - is if i click the solo button on the low
358:31 - band
358:32 - and then switch to the mid band i still
358:34 - want the low band to
358:36 - show i still want the low band select
358:38 - button to show me that it is soloed
358:40 - and when you switch bands it uses the
358:43 - off color when it's no longer toggled on
358:45 - so that's why we have to do it this way
358:48 - so we go
358:49 - band dot set color
358:51 - i can just copy this line okay we are
358:53 - setting the off color button color id
358:56 - to the on color of the color source and
358:59 - then once we set the colors we need to
359:01 - repaint the buttons
359:03 - and dot repaint
359:05 - all right let's test that out all right
359:08 - let's bypass and switch to the mid band
359:11 - and it still shows up as yellow so
359:14 - that's awesome the only issue is the
359:15 - text is white instead of black
359:17 - and then if we switch back
359:19 - this is cool all right solo let's bypass
359:22 - you
359:24 - very cool solo
359:26 - and bypass very cool all right that's
359:28 - awesome that works as expected so that
359:30 - is fantastic
359:32 - all right here is a test what happens if
359:34 - we mute a band other than the low band
359:39 - let's see uh let's just me let's mute
359:41 - the mid band
359:43 - let's quit and relaunch what do you
359:45 - think is going to happen
359:50 - okay the button the mid band button does
359:53 - not reflect the state of the band when
359:54 - the gui opens once we click on the band
359:57 - it happens so we need to update the band
359:59 - select button colors when the gui is
360:01 - loaded
360:02 - disable that guy now we'll leave that on
360:05 - actually it's a good way to test
360:07 - okay so let's write a function that does
360:09 - that and it's only going to be called
360:10 - from the constructor as the band select
360:13 - buttons reflect the band state correctly
360:16 - after the gui has finished loading and
360:18 - one of the buttons is clicked okay so
360:19 - this is just like
360:21 - we only have to do this in the
360:22 - constructor all right let's declare it
360:24 - first we're going to call it update band
360:26 - select button states
360:28 - go to the header file let's put this
360:30 - down here void update band select button
360:35 - states all right here is what it is
360:37 - going to do number one it is going to
360:39 - query the audio parameters for all three
360:42 - bands
360:43 - um for their solo mute and bypass states
360:45 - it is going to update the band's select
360:48 - buttons fill color
360:49 - appropriately back again huh you want
360:52 - some more time on camera is that what
360:54 - this is
360:56 - just going to make all the noise now
361:00 - all right here is what this function
361:02 - will do it is going to query the audio
361:04 - parameters for all three bands um it's
361:07 - going to look for their solo mute and
361:08 - bypass parameters and it's going to
361:10 - update the band select buttons fill
361:13 - colors accordingly this function again
361:15 - is only going to be used during
361:16 - construction to ensure that the band
361:18 - select buttons
361:20 - show the correct colors when the gui is
361:22 - initially loaded
361:24 - let's go call it in our constructor
361:26 - where is our constructor it's here at
361:28 - the top and we can do this after we um
361:30 - after we update our attachments and
361:32 - before
361:33 - before we make the low mid and high
361:36 - bands visible and we also need to enable
361:39 - we need to configure enablements as well
361:40 - so let's do that to update slider
361:42 - enablements and then we can do update
361:44 - band select button states let's add this
361:47 - before update slider enablement just a
361:50 - good place to put it void compressor
361:52 - band controls
361:54 - update ban select button states
361:57 - all right here's the algorithm for this
361:59 - function
362:00 - number one query the following params in
362:02 - the following order solo mute bypass if
362:06 - a parameter is on
362:07 - set the band select colors accordingly
362:11 - do this for the low mid and high bands i
362:14 - want to do this in a loop so let's make
362:16 - a vector that holds all of the program
362:17 - name enum entries that we need to use go
362:20 - check this out
362:22 - first we need our params namespace
362:24 - then we need our array of param names to
362:28 - check
362:29 - next we need to get to the parameter in
362:31 - question as an audio parameter bool so
362:34 - this will let us check if the parameter
362:36 - is true or false easily let's get our
362:39 - params const auto params equals get
362:42 - params and then let's make a helper auto
362:45 - param helper equals lambda lambda lambda
362:49 - let's back up on screen we need our
362:51 - params
362:53 - and we need our apv do we need ap vts
362:56 - yes we do but um
362:59 - i'm lazy we're just going to capture
363:00 - this and we also need a name to pass in
363:03 - let's see let's implement this first
363:05 - return
363:06 - dynamic cast
363:08 - juice audio param i never hold down
363:11 - shift long enough
363:12 - audio parameter bool and we want our get
363:15 - param
363:17 - this function which returns a point or
363:18 - returns a reference we need to point to
363:20 - that okay we need our params we need our
363:23 - name
363:24 - let's pass that in
363:26 - const auto name and then we need our ap
363:29 - vts all right great
363:32 - now we just need to loop through our
363:34 - vector of params to check
363:36 - and
363:37 - do some magic inside this loop all right
363:40 - so four
363:41 - size t zero is less than params to check
363:46 - size right let's get a list so this is
363:48 - the name of the params we're going to
363:50 - check so auto list equals params to
363:53 - check
363:54 - whichever entry we're on so we might be
363:56 - iterating either iterating through this
363:58 - list we might be iterating through this
364:00 - list might be iterating through this
364:02 - list let's figure out which band is
364:04 - currently being updated based on
364:08 - our index auto band button
364:11 - equals
364:12 - if i is zero then we're working on the
364:15 - low band otherwise if i equals 1 then
364:19 - we're working on the mid band otherwise
364:22 - we're working on the high band all right
364:24 - now we simply check the solo parameter
364:27 - the mute parameter and the bypass
364:29 - parameter if any of these are true we
364:31 - can use the static function we wrote to
364:33 - change the colors of the band button
364:35 - declared here
364:37 - if auto solo equals param helper first
364:41 - entry in our list
364:44 - right here we could use an enum
364:46 - but this is fine all right if it's this
364:49 - and solo get this is going to return
364:52 - true or false then we can do refresh
364:55 - band button colors and our band is going
364:57 - to be the band button and our color
364:59 - source is going to be the solo button
365:01 - okay let's check for the mute parameter
365:03 - else if auto mute
365:05 - equals param helper list one
365:09 - mute get refresh the band button with
365:12 - the mute button colors finally else if
365:16 - auto bypass equals param helpers list
365:20 - two
365:21 - last one oops that's not where that
365:23 - semicolon goes all right if it's the
365:25 - bypass button that's currently on then
365:28 - update our appropriate band button with
365:31 - the bypass button all right let's test
365:33 - it out all right cool the mid band is
365:35 - currently on
365:36 - so that test worked as expected i'm
365:38 - going to change this to solo i'm going
365:41 - to bypass you and i'm going to change
365:43 - you to
365:44 - muted all right let's save and quit
365:47 - and rerun we should see
365:51 - them as expected all right cool and the
365:52 - low band is muted which it means
365:54 - uh these are bypassed mute band is
365:57 - soloed and the high band is also muted
365:59 - so those are disabled so that's perfect
366:02 - all right and solo and bypass all right
366:05 - cool that is some excellent gui
366:07 - functionality helpful for the user let's
366:10 - make a commit of that
366:12 - dialed in
366:14 - custom
366:16 - band control
366:18 - colors
366:23 - all right good times good times
366:26 - let's look at our road map we have our
366:28 - bands reflecting this
366:30 - we're done with that all right and we
366:32 - have we got custom look and feel going
366:34 - so we can um we can mark that one off as
366:37 - well we are up to the spectrum analyzer
366:40 - next
366:41 - uh okay we're gonna do an overview we're
366:43 - gonna migrate it over from simple eq
366:45 - we're gonna get it working and then
366:47 - we're going to um we're going to get it
366:50 - drawing and then we're going to
366:52 - customize how it draws then we're going
366:54 - to add bypass functionality to the
366:56 - analyzer and to all bands at the same
366:58 - time so we still got a decent chunk of
367:01 - stuff to do
367:03 - i'd say we're about maybe 60 of the way
367:06 - done so the next thing we will tackle is
367:08 - getting the spectrum analyzer from
367:10 - simple eq
367:12 - into here
367:15 - if you get stuck or run into trouble
367:17 - while coding this or simple eq just grab
367:20 - one of my free products from programming
367:22 - for musicians.com and you can message me
367:24 - directly in the slack workspace and i
367:26 - will help you directly
367:28 - all right spectrum analyzer okay a lot
367:31 - of code surgery in this one
367:33 - if you have not completed the simple eq
367:36 - project we will be reusing the spectrum
367:38 - analyzer and related classes from that
367:41 - project so you might take this
367:44 - opportunity to pause this video
367:46 - and start watching the simple eq videos
367:48 - so you can learn how to build that
367:50 - spectrum analyzer before you copy the
367:52 - code over to this project
367:55 - either way we are going to visit the
367:57 - simple eq repository and copy over the
368:00 - appropriate classes and get our spectrum
368:02 - analyzer functional before we start
368:05 - modifying it let's do that now
368:08 - go to your browser go to the spectrum
368:11 - go to simple eq
368:12 - and we're going to go to the
368:14 - um the plugineditor.h
368:18 - okay we need to copy over what is this
368:20 - thing called this is called the response
368:24 - curve component if we go down here
368:26 - we've got our let's see where is this
368:29 - thing
368:30 - yeah it's just called the response curve
368:32 - component okay for whatever reason
368:33 - that's what i decided to call it um i
368:35 - don't remember why but
368:37 - that's what i called it instead of
368:38 - spectrum analyzer but we will be
368:40 - renaming it here because it will not be
368:43 - displaying the response of a filter
368:46 - one of the first things we will do is
368:48 - remove the
368:50 - um the response curve display from this
368:52 - all right let's go grab this class
368:55 - response curve component
368:57 - copy this
369:02 - okay copy all of the response curve
369:04 - component copied it
369:06 - and now let's paste it in our plugin
369:08 - editor dot h
369:10 - paste it above the editor
369:14 - and let's
369:16 - um let's see we're going to replace the
369:18 - placeholder
369:20 - we're going to replace this placeholder
369:21 - here for analyzer with an instance of
369:23 - that
369:24 - response curve component
369:27 - analyzer
369:29 - okay
369:31 - now let's figure out what else we need
369:33 - to copy over
369:34 - by trying to build it and obviously we
369:36 - need to copy over the cpp files so let's
369:38 - grab those as well go to
369:42 - source go to plugin editor and now we're
369:44 - looking for a response curve
369:46 - rotary slider here we go response curve
369:49 - components
369:53 - all right paint function
369:55 - get frequencies get gains get x's draw
369:58 - background grid draw text labels
370:02 - uh resized parameter value change
370:05 - process
370:07 - timer callback update chain get render
370:11 - area get analysis area grab all of these
370:13 - functions copy them
370:15 - go to plugin editor dot cpp paste these
370:19 - all at the top
370:20 - okay let's try to build it
370:23 - okay first thing to do is to change this
370:25 - constructor parameter
370:27 - to
370:28 - be the audio processor for this project
370:30 - so go to plugineditor.h let's grab a
370:32 - copy of this
370:35 - simple mb comp audio processor
370:37 - and let's change that here
370:40 - simple audio
370:41 - right and same for right here
370:43 - okay we took care of this member
370:44 - variable
370:46 - and we took care of this constructor
370:49 - all right let's try building it again
370:50 - that should take care of those errors
370:52 - all right cool
370:53 - let's get rid of this mono chain
370:56 - we don't need this we don't need the
370:58 - response curve
371:00 - uh we don't need the response curve
371:01 - member variable and we don't need the
371:04 - update chain function
371:06 - next let's see okay we need path
371:08 - producer so let's go grab that from
371:11 - our repository
371:13 - let's see that's going to be in the
371:16 - header file first plugin editor dot h
371:20 - we want path producer
371:23 - where are you path producer there you
371:24 - are okay path producer
371:28 - copy all right put this at
371:31 - the top above our response curve
371:33 - component paste that
371:35 - okay
371:37 - next we need to copy over the single
371:40 - channel sample fifo
371:42 - now the explanation for how this thing
371:44 - is built the single channel sample fifo
371:46 - can be found in project 11. so if you're
371:48 - interested in learning how this thing
371:50 - gets built
371:51 - you can uh sign up for that course this
371:53 - is going to be found in
371:55 - pluginprocessor.h from simple eq so
371:57 - let's go grab that
372:00 - source plugin processor dot h
372:04 - all right single channel sample fifo
372:11 - copy that
372:12 - and let's paste it above our path
372:15 - producer
372:17 - actually uh this needs to live in
372:19 - pluginprocessor.h so let's put it there
372:21 - let's put it above
372:23 - our class declaration for our processor
372:26 - we need to copy over the channel
372:28 - enumeration from simple eq let's do that
372:30 - next go back to the repository and grab
372:34 - this channel enumeration
372:36 - i really don't know why i chose to do
372:38 - the right channel first and the left
372:39 - channel second because left is always
372:42 - channel zero
372:43 - right is always channel one but
372:46 - i'm stuck with it now changing it would
372:48 - be a huge um
372:50 - huge code revision so we'll just leave
372:52 - it as it is all right
372:54 - put this above single channel sample
372:56 - fifo in plugin processor dot h
372:59 - all right let's build this and see what
373:01 - happens
373:03 - okay next thing is it wants a fifo so
373:06 - let's grab that as well from simple eq
373:10 - where's that that's right here
373:14 - here's our fifo make sure you include
373:16 - the array class that's part of the fifo
373:19 - fifo needs that
373:21 - i put that above
373:22 - the channel enumeration
373:25 - again if you want to learn how to build
373:27 - this fifo from scratch and all the
373:29 - design decisions that come with it you
373:31 - can check out any of my advanced
373:33 - plug-in courses because they all use it
373:35 - project 10 uses it project 11 uses it
373:37 - and project 12 uses uses it
373:40 - all right let's build this again let's
373:42 - see if we have any more errors in the
373:46 - single channel sample fifo
373:49 - none okay cool all right let's go back
373:52 - to the editor
373:53 - editor.h and uh cp and editor.cpp and
373:57 - get the rest of these classes working
374:00 - okay let's change these references right
374:02 - here to the simple eq change it from
374:06 - simple eq audio processor and change
374:08 - them to
374:09 - our simple mb comp audio processor
374:13 - that goes there that goes there
374:16 - build that all right it says no member
374:20 - named block type in simplemb comp audio
374:23 - processor all right let's see what this
374:25 - block type is
374:26 - go back to the repository
374:29 - um let's just look for block type
374:32 - let's see what our options are
374:35 - okay there it is using block type equals
374:37 - audio buffer so it's just an alias so
374:40 - let's
374:41 - um it's public let's just copy this line
374:44 - and put it in our plugin processor dot h
374:46 - and let's also copy over these two
374:49 - channel instances
374:50 - these two single channel sample fifo
374:52 - instances as well
374:54 - that are declared right below it let's
374:56 - copy those
374:58 - all right plugin processor
375:00 - go down to the end of the public section
375:02 - after ap vts is declared and put them
375:05 - right there
375:07 - all right let's do a little build and
375:08 - see what errors are left
375:11 - okay build failed
375:14 - all right block type disappeared so
375:15 - that's cool
375:16 - all right what do we got next
375:18 - okay we need this fft order type we need
375:21 - that so that is found at the top of
375:25 - where is that found
375:26 - it's in here somewhere let's see let's
375:28 - check plugin editor
375:30 - there it is fft order all right let's
375:32 - copy that
375:34 - let's put that at the top of our class
375:37 - at the top of our editor header file
375:40 - all right let's try to build it
375:42 - and what do we have here
375:44 - oh that's cpp file stuff let's fix that
375:47 - while we are here
375:48 - um go back to the plugin editor copy
375:51 - this simple mb comp audio processor
375:55 - go back over here
375:56 - run away
375:57 - all right this needs to be changed
375:59 - okay let's try that one more time okay
376:02 - so now we've got an error with fft data
376:04 - generator all right let's copy these
376:06 - over next we're going to grab the fft
376:09 - data generator and the analyzer path
376:10 - generator these are both found in
376:14 - let's see here's fft data generator
376:18 - and here's the analyzer path generator
376:23 - let's copy both of these classes
376:25 - they both go in plug-in editor.h
376:29 - above
376:29 - path producer let's try that again
376:35 - again if you want to learn how to build
376:37 - any of these classes from scratch and
376:39 - learn the design decisions that went
376:41 - into them
376:43 - check out my advanced courses project 10
376:45 - project 11 and project 12.
376:47 - they all use this spectrum analyzer so
376:50 - you'll be able to understand how these
376:51 - are put together
376:53 - all right let's fix the cpp file stuff
376:56 - okay we're getting rid of update chain
376:59 - all right let's see what's next
377:01 - update response curve let's get rid of
377:03 - this function
377:07 - actually we don't need it at all
377:09 - same for update chain that's gone
377:10 - entirely let's just keep building it
377:12 - there's stuff that needs to be removed
377:14 - all right remove this code that uh draws
377:16 - the response curve
377:18 - this line right here
377:20 - and get rid of that entirely
377:22 - all right let's next
377:24 - um okay update chain that can disappear
377:29 - response curve okay this stuff in resize
377:31 - we don't need any of this that can all
377:33 - disappear
377:36 - all right um we don't need any of this
377:38 - update chain update response curve
377:41 - all right let's see what happens next
377:43 - constructor must explicitly
377:47 - initialize okay we need to do that
377:49 - that's down in our header file
377:52 - plug in editor all the way down to the
377:54 - bottom
377:56 - this needs an instance of its audio
377:58 - processor
378:01 - yeah it is the audio processor okay
378:03 - let's try building it one more time
378:06 - all right let's see what we get
378:08 - uh we forgot to make it a visible child
378:11 - go to plugin editor and let's add our
378:13 - analyzer make it visible
378:16 - all right here we go let's see what we
378:18 - get
378:20 - there it is we have our spectrum
378:21 - analyzer in place that we can start
378:23 - modifying it
378:24 - uh let's rename it next and then modify
378:26 - it to display what we need it to display
378:29 - okay let's rename this class to spectrum
378:32 - analyzer right click refactor rename
378:37 - spectrum analyzer
378:41 - okay cool let's clean it up next all
378:44 - right let's delete these
378:46 - all right let's see if there's anything
378:48 - left in here that needs to be deleted
378:51 - i think we removed a lot of stuff
378:52 - earlier instead of just commenting it
378:53 - out
378:55 - yep that's it okay all right let's make
378:58 - a commit now that we have a spectrum
379:00 - analyzer
379:02 - added spectrum analyzer and
379:05 - associated
379:07 - source associated classes
379:11 - all right it's not wired up but that's
379:13 - okay
379:15 - we'll do that next
379:16 - well first let's refactor into separate
379:18 - files
379:20 - all right so we'll do what we did before
379:23 - we've got all of these classes so one
379:26 - source file
379:28 - one class one source file
379:30 - go over to producer
379:32 - and let's see first thing we're gonna do
379:34 - is add
379:35 - fft data generator
379:38 - fft
379:40 - data generator
379:47 - all right just paste that here
379:50 - include
379:51 - juice
379:52 - header dot h
379:54 - all right next let's do the analyzer
379:56 - path generator
379:59 - uh collapse it
380:02 - uh sorry
380:03 - yeah let's collapse these first this
380:06 - will make it easier to see what we have
380:07 - to do all right three classes analyzer
380:09 - path generator path producer and
380:11 - spectrum analyzer
380:13 - okay so let's see these are all in the
380:16 - gui
380:18 - spectrum
380:20 - analyzer and let's see
380:23 - path producer
380:26 - path producer
380:28 - and then analyzer path generator is just
380:30 - a header file
380:31 - analyzer path generator
380:35 - all right let's take care of these
380:38 - all right let's do spectrum analyzer
380:40 - first
380:41 - cut
380:43 - paste this here
380:45 - and don't forget the juice header
380:48 - alright next is path producer
380:51 - and don't forget the juice header
380:53 - include
380:55 - oops not that one
380:57 - choose header
380:59 - and then analyzer path generator
381:04 - include
381:06 - juice
381:07 - header.h
381:10 - what else do we got there's something in
381:12 - uh that's it for this guy so let's
381:13 - migrate over
381:15 - stuff from cpp let's collapse the
381:17 - spectrum analyzer
381:19 - collapse all of these
381:20 - let's grab all of them
381:26 - it goes in spectrumanalyzer.cpp
381:31 - all right next um let's see fft order
381:35 - let's put this in
381:37 - utilities
381:38 - put this at the top
381:41 - all right and then plug-in processor dot
381:43 - h
381:44 - has single channel sample fifo
381:48 - and
381:49 - the
381:50 - fifo class so let's add these to the dsp
381:54 - dsp folder
381:55 - add new header file fifo
381:59 - make sure that's dsp folder fifo.h
382:03 - and then single channel sample fifo
382:10 - all right
382:13 - all right channel can go with the single
382:15 - channel
382:16 - sample fifo class
382:18 - put this here
382:20 - include
382:21 - juice
382:23 - header.h
382:24 - let's migrate over the fifo
382:29 - and include the juice header
382:32 - okay
382:34 - all right now we can fix all of the
382:36 - includes try to build
382:38 - let's go through the errors
382:41 - plug and processor needs single channel
382:42 - sample fifo
382:44 - include
382:46 - dsp
382:48 - single channel sample fifo
382:50 - we got no
382:52 - let's see where was that name
382:53 - no template named fifo so let's include
382:56 - the fifo here
382:59 - what is wrong with this
383:01 - oh yes okay
383:03 - unknown type name spectrum analyzer
383:04 - let's include that
383:06 - include
383:07 - gui spectrum analyzer
383:11 - spectrum analyzer does not know about
383:12 - the path producer let's inform it
383:14 - include
383:16 - path producer
383:19 - path producer does not know about the
383:22 - fft data generator include fft data
383:25 - generator
383:26 - include what's the other thing analyzer
383:29 - path generator
383:31 - all right fft order
383:33 - that was in utilities
383:36 - uh that wasn't gui utilities
383:40 - no template named fifo
383:43 - include dot dot slash
383:46 - dsp
383:48 - fifo
383:50 - all right path producer we can um we
383:53 - need to include the audio processor
383:56 - include
383:57 - um let's see dot slash
383:59 - plugin processor dot h
384:02 - all right build succeeded let's run it
384:03 - just to make sure
384:05 - all right cool let's commit that
384:06 - refactor
384:10 - all right
384:12 - refactored
384:14 - separate files
384:16 - set bar 8
384:17 - file 3 vector
384:20 - all right we will run audio through the
384:22 - spectrum analyzer next and get it to
384:24 - display what it displays
384:26 - let's remove some stuff from our road
384:29 - map we have not looked at that for a
384:31 - while
384:32 - go to the
384:33 - pluginprocessor.h
384:35 - wait at the top let's see what do we got
384:37 - left all right we've done our spectrum
384:39 - analyzer
384:40 - uh we have our data structures for it
384:43 - we need to do
384:45 - let's see
384:47 - this needs testing
384:48 - and then we need to get this working
384:50 - this is what we're gonna do in this
384:51 - issue
384:52 - all right let's tackle this one number
384:54 - nine fifo usage in process block
384:57 - this is where we will feed audio into
385:00 - our single channel sample fifo
385:04 - head on over to pluginprocessor.cpp
385:08 - go to processblock
385:11 - before we apply our gain let's send our
385:14 - incoming audio into the fifos for the
385:16 - spectrum analyzer so the spectrum
385:17 - analyzer is going to show
385:20 - um it's going to show the incoming audio
385:23 - before any gain reduction
385:26 - left channel fifo dot
385:28 - update buffer
385:31 - right channel 5.0 update buffer
385:35 - all right let's switch to testing out
385:37 - the vst version and run some audio
385:40 - through the plugin
385:41 - pst3
385:42 - run let's see what happens
385:46 - j sertion aha we forgot to prepare
385:49 - i'm glad this guy was here this was
385:51 - smart
385:52 - if uh
385:54 - yeah if i hadn't done this uh who knows
385:56 - what this thing would do
385:57 - all right let's go fix that
386:00 - go to uh plugin processor dot cpp go to
386:03 - prepare to play and we need to prepare
386:07 - our fifos
386:08 - put this down at the bottom
386:11 - left channel
386:13 - fifo dot prepare
386:15 - samples per block
386:18 - right channel fifo prepare
386:20 - samples per block
386:22 - all right now let's try it
386:25 - all right
386:26 - let's play some music through it
386:29 - headphones if needed
386:34 - excellent
386:36 - all right let's test the accuracy next
386:39 - just to be sure
386:41 - and save this quit
386:42 - let's make a commit
386:45 - wired up um spectrum analyzer to
386:50 - incoming audio
386:53 - stage u
386:55 - that's that
386:56 - yeah
386:57 - it's funny these two lines of code are
387:00 - these four lines of code are what make
387:02 - the spectrum analyzer actually work
387:03 - that's good times
387:05 - all right we're going to verify the
387:07 - spectrum analyzer accuracy next
387:12 - to verify the accuracy of the spectrum
387:14 - analyzer we're going to need an
387:16 - oscillator to generate a test signal
387:18 - now we could use a daw for this um but
387:22 - i'd rather use
387:24 - internal code to do that
387:26 - so let's go down to the bottom of our
387:28 - header file
387:29 - and after our split bands class let's
387:32 - give ourselves an oscillator
387:35 - the juice framework has one it's part of
387:38 - the dsp module we will use that
387:41 - let's go to prepare to play next
387:44 - we need to configure it
387:46 - let's do this after our
387:48 - fifos let's initialize to prepare it and
387:51 - then set the frequency
387:53 - we need to provide a lambda that takes
387:56 - in a
387:58 - position
388:00 - within the circle of pi and returns a
388:03 - sample
388:04 - float x this is our position within the
388:07 - circle of pi
388:08 - oops um and we can just do return st
388:12 - sine
388:12 - of x
388:13 - this is going to generate a sine wave
388:16 - all right let's prepare it all right
388:18 - let's go down to where we are updating
388:21 - our state
388:22 - plugin processor.cpp process block
388:25 - okay let's do this after update state
388:28 - the move here is to clear our buffer and
388:32 - fill it with samples from the oscillator
388:35 - so let's give ourselves an if block
388:37 - let's just say if true if it's true
388:39 - you're going to do this thing you're
388:40 - going to do buffer
388:41 - clear
388:43 - then you're going to
388:44 - you're gonna fill it with oscillator
388:46 - samples
388:48 - do an audio block from the buffer
388:51 - do a context
388:57 - and now we can do ask.process
389:00 - right this is going to fill up the
389:02 - buffer with samples from the oscillator
389:05 - all right this is going to be super
389:07 - annoying to listen to because it's going
389:09 - to be a full scale sine wave at 440
389:12 - hertz so i suggest
389:14 - muting your speakers i'm not going to
389:16 - use headphones for this what we are
389:18 - looking for is a single peak in the
389:21 - spectrum analyzer at 440 hertz where did
389:24 - 440 hertz come from
389:26 - it came from right here if we go to the
389:28 - oscillator class way down at the bottom
389:30 - the default frequency
389:33 - is 440. that's where that comes from
389:36 - because you'll notice we did not set a
389:37 - frequency with that said turn down your
389:40 - headphones
389:41 - possibly turning them off or unplugging
389:43 - them or turning your speakers off
389:45 - and switch to the standalone version
389:48 - and now let's run it we can test other
389:50 - frequencies that line up with grid lines
389:52 - later for now we want to see this peak
389:55 - hit
389:56 - the zero db line
389:58 - oh let's change
390:03 - all right let's try that one more time
390:06 - okay
390:07 - so it's pretty accurate in terms of uh
390:10 - the
390:11 - the pitch
390:13 - let's try 500 and then 2 000 okay those
390:16 - frequencies are actual lines on the grid
390:18 - so we can go up to our prepare to play
390:22 - and this is where we will set our
390:24 - frequency
390:26 - ask dot set frequency is that what it's
390:29 - called yes it is all right let's do 500
390:32 - let's test this out
390:34 - all right that's pretty accurate
390:37 - let's do
390:38 - uh 2000 hertz
390:41 - all right that's basically right on the
390:43 - money all right let's add a gain
390:45 - processor and test negative 12 db since
390:48 - that is a grid line on the scale on the
390:51 - left i'll show you what i'm talking
390:52 - about real quick
390:53 - that's over here this line right here
390:55 - this is negative 12.
390:57 - let's go declare it go to the
391:01 - plug-in processor.h after the oscillator
391:05 - go back to um
391:07 - plugin processor.cpp we need to prepare
391:09 - it let's do that after our oscillator
391:12 - gain dot prepare
391:14 - spec
391:16 - gain dot set gain decibels negative 12.f
391:20 - all right now let's just process the
391:23 - context with it
391:24 - process block
391:27 - gain.process
391:29 - ctx
391:31 - okay let's test it out okay what i am
391:35 - seeing is that the peak is not at
391:38 - negative 12
391:39 - it should be lining up with this grid
391:40 - line and it's not
391:42 - it's a bit lower than that and if we
391:44 - turn the gain off let's comment this out
391:49 - it's below the zero db line which is
391:51 - this line right here
391:53 - so there is an issue with the spectrum
391:55 - analyzer mapping
391:57 - that we need to solve and i want to test
391:59 - a few more frequencies though just to
392:01 - see if it's an issue with the amount of
392:02 - energy in that particular frequency band
392:04 - so let's try 50 hertz next go to
392:08 - um prepare to play
392:10 - let's try 50 hertz
392:13 - all right let's try 50.
392:18 - okay this is definitely below zero db
392:21 - and we're not applying any gain
392:24 - let's try 1 000
392:28 - okay all right so we definitely have a
392:30 - mapping issue with the spectrum analyzer
392:33 - let's investigate that next
392:37 - let's go back to process block let's
392:38 - turn on our gain processing real quick
392:41 - all right as you can see the fft is not
392:45 - correctly displaying our test signal it
392:47 - should be displaying at negative 12 but
392:49 - it is not it is much lower than that i
392:52 - want to make the gain adjustable while
392:53 - we figure this out so let's use juice
392:56 - live constant to give ourselves this
392:59 - option
393:00 - this will give us a slider to drag in a
393:02 - pop-up window and we can use that to
393:04 - adjust the test signal level let's close
393:07 - this
393:08 - let's right here we will go gain dot set
393:12 - gain decibels
393:13 - juice live constant
393:15 - negative 12. notice i'm using negative
393:18 - 12 not negative 12 dot f that's because
393:20 - if i do dot f
393:22 - this will give us a float and i want to
393:23 - do integers so that way i can have um
393:26 - steps of like 12 11 10 9.
393:29 - okay let's try this off oops cancel
393:32 - let's try this one more time building
393:34 - all right here's our live constant
393:35 - editor
393:38 - all right so now we can drag this slider
393:42 - let's see how far up do i need to go to
393:44 - make it zero
393:46 - i have to go about 5 db maybe 4 db up to
393:50 - get it to line up with 0. so there's
393:52 - something going on with how the test
393:53 - signal is being mapped vertically to the
393:55 - screen coordinates
393:57 - let's solve that
393:59 - let's head on over to
394:01 - spectrumanalyzer.cpp
394:04 - and we're going to go to the paint
394:06 - function
394:07 - all right let's get rid of this y
394:09 - transform
394:10 - and see what happens
394:12 - we're going to put 0 here
394:14 - and we're going to put that on a new
394:15 - line comment it out
394:17 - and put that like that let's do the same
394:19 - thing for the right channel oh i need uh
394:22 - both of these there we go
394:24 - all right do the same thing here put a
394:25 - zero
394:27 - put this on its own line
394:28 - and then put the curly braces on there
394:30 - uh put the parentheses on there online
394:32 - all right let's test and see what
394:34 - happens
394:36 - okay so our setting is negative 12 and
394:38 - now it's showing at right on negative
394:40 - 12. the problem is that we can now see
394:43 - where negative infinity
394:45 - is currently mapped to
394:47 - so there's an issue with where negative
394:49 - infinity is
394:51 - in the rectangle that we are using to
394:53 - convert our fft bin values remember with
394:56 - the rectangle we are using to map these
394:58 - values the top represents 0 db and the
395:01 - bottom represents negative infinity so
395:03 - let's look at the rectangle that we are
395:05 - passing to the path producer
395:07 - all right go to the timer callback
395:10 - we are passing the analysis
395:13 - area rectangle so let's take a look at
395:15 - how this gets computed i go to get
395:18 - analysis area
395:20 - okay so we start with our local bounds
395:22 - here and get render area that's what's
395:24 - going on here
395:25 - and in this function we remove a chunk
395:27 - from the top then we remove a chunk from
395:29 - the bottom
395:30 - then we remove a little bit more from
395:32 - the top
395:33 - and a little bit more from the bottom
395:36 - okay so let me get the whiteboard so i
395:38 - can explain
395:40 - um how we are mapping this stuff
395:43 - okay we are mapping our signal
395:46 - let's see let me let me first step back
395:48 - all right this big rectangle on the
395:50 - outside
395:52 - that is our local bounds let me go this
395:54 - way
395:55 - that's our local bounce and then in our
395:57 - get uh render area this is where we
395:59 - remove a little bit from the top and a
396:01 - little bit from the bottom
396:02 - and that gives us this purple rectangle
396:04 - on the inside
396:06 - then we do get analysis area which
396:09 - shrinks it even further
396:11 - now we are mapping our signal between
396:13 - this area here and here
396:16 - the top line is 0 db
396:19 - let me draw that here
396:21 - this is 0 db
396:24 - and this bottom line
396:26 - is negative 48.
396:28 - however
396:29 - negative 48 is not negative infinity we
396:32 - need down here to be negative infinity
396:35 - so we need to update two things number
396:38 - one the rectangle being passed to the
396:40 - path producer
396:41 - needs to have a proper bottom edge that
396:43 - actually lines up with negative infinity
396:46 - right now it lines up with this it's
396:47 - this green greenish blue one so we
396:50 - actually need to make a rectangle
396:52 - that goes from here
396:56 - like that
396:59 - okay number two
397:01 - we need to tell the path producer that
397:02 - the decibel value
397:04 - number two we need to tell the path
397:06 - producer the decimal value that is
397:08 - negative infinity for that we need to
397:11 - figure out what is the db value of this
397:14 - bottom edge if this is 0 and this is 48
397:17 - or this is negative 48
397:19 - what is this
397:21 - this is
397:23 - uh like negative 50 or 52 or something
397:25 - and that's what negative and that is
397:27 - what is
397:28 - negative infinity in terms of uh this
397:31 - mapping of values
397:34 - okay so let's take care of number one
397:36 - first the rectangle being passed to the
397:38 - path producer needs to have a proper
397:40 - bottom edge
397:42 - that lines up with negative infinity
397:43 - let's do that first
397:45 - all right let's go to our timer callback
397:48 - let's set the bottom of this fft bounds
397:51 - right here to our component's bottom
397:54 - fft bounds dot set bottom
397:58 - get local bounds
398:00 - get bottom
398:02 - next we need to adjust the top and
398:04 - bottom values in the function that maps
398:06 - decibels to screen coordinates
398:09 - that is over in the analyzer path
398:11 - generator
398:12 - analyzerpathgenerator.h
398:15 - okay that's right here
398:17 - all right we are mapping the bottom to
398:19 - get height but we need to map it to fft
398:22 - bounce get bottom so comment this line
398:25 - out
398:26 - and do auto
398:28 - bottom equals fft bounds dot get bottom
398:33 - next we are currently adding 10 to
398:36 - whatever the bottom is that's right here
398:38 - in this lambda this magic number is also
398:41 - a source of inaccuracy so let's remove
398:43 - that
398:44 - all right let's get rid of this line
398:46 - we also don't need that cast anymore
398:49 - bottom
398:51 - top
398:52 - all right let's take a look at this and
398:54 - see if we have an improvement
398:56 - okay
398:57 - better
398:58 - now it's mapping negative infinity to
399:01 - the bottom of the screen
399:03 - but this is slightly off right here and
399:05 - if we adjust this if i put this at
399:07 - negative 24
399:09 - it's still off that way if i go up to
399:11 - zero
399:13 - zero is lined up
399:15 - negative 36
399:18 - and this is because
399:20 - it is not it's mapping
399:23 - the negative infinity negative 48 to the
399:25 - bottom of the screen instead of this
399:27 - line right here so we need to define
399:29 - what negative infinity actually is in
399:32 - decibels relative to this 0 db line and
399:36 - this negative 48 db line on screen range
399:40 - let's do that next
399:42 - all right let's head over to the path
399:44 - producer
399:46 - and way at the bottom
399:47 - let's add
399:49 - a negative infinity member variable
399:52 - float
399:53 - negative infinity
399:56 - let's initialize it to negative 48
399:59 - just as a starting point
400:01 - all right let's add a setter function so
400:03 - we can update this in our spectrum
400:05 - analyzer after the component has actual
400:08 - screen bounds
400:09 - void update negative infinity
400:13 - float nf
400:15 - negative
400:17 - infinity equals nf
400:21 - now go to the cpp file
400:23 - all right we need to
400:25 - where's my path producer did i not
400:27 - migrate this stuff over
400:28 - i don't think i migrated this stuff over
400:31 - oh you know why because it's here in
400:33 - spectrum analyzer
400:35 - right there path producer process
400:39 - oops
400:40 - let's collapse that
400:42 - that belongs over here
400:47 - okay
400:48 - okay we need to look for
400:51 - any negative 48s and replace them with
400:55 - negative infinity
400:57 - there's one
400:58 - and here's the other
401:02 - okay this shouldn't make any visual
401:04 - difference but let's just test to make
401:06 - sure
401:07 - all right that's still off if i put it
401:09 - at negative 36
401:12 - what do we get
401:14 - are we gonna get that same weird uh
401:17 - difference yep that's fine okay and zero
401:20 - zero lines up the top okay cool all
401:22 - right no difference all right let's set
401:25 - negative infinity for the path producer
401:28 - let's head over to the resized function
401:30 - in the spectrum analyzer spectrum
401:33 - analyzer.cpp
401:35 - go to the resized function
401:38 - all right as i said earlier
401:40 - the top line i'll show this
401:43 - make sure your speakers are muted
401:45 - uh make sure you're um
401:47 - yeah well i'll mute this in post okay
401:49 - the top line right here is 0 db
401:52 - this gray line
401:53 - and then the bottom line is negative 48.
401:56 - however negative 48 is not negative
401:58 - infinity we want the bottom of this
402:00 - component to represent negative infinity
402:02 - so first we need to get this analysis
402:04 - area
402:05 - since that area represents 0 to negative
402:08 - 48.
402:09 - let's do that first auto fft bounds
402:12 - equals get analysis area dot to float
402:19 - then we need to j map the bottom of our
402:21 - local bounds from the analysis area
402:24 - range to the decibel range
402:26 - auto neg inf
402:29 - equals jmap
402:31 - all right our source value is going to
402:33 - be local bounds
402:36 - as a float rectangle
402:38 - and we want the bottom of it
402:41 - all right our source range minimum is
402:44 - going to be our fft bounds get bottom
402:47 - and our source range max is going to be
402:50 - f of t bounds get y
402:53 - and our target range minimum
402:55 - is going to be negative 48
402:58 - our target range max is zero d is zero
403:01 - uh float
403:03 - so this negative 48 corresponds to the
403:05 - bottom of our fft bounds and the zero
403:08 - corresponds to the top or the y the y
403:11 - value
403:13 - and then we are mapping
403:15 - our local bounds the bottom of it
403:18 - based on this set of
403:20 - top and bottom values
403:22 - now we can update our path producers
403:25 - let's print out what the bottom of the
403:26 - window actually maps to in decibels
403:30 - and update accordingly
403:33 - okay let's test this out
403:36 - all right that is almost perfect
403:38 - still not 100 it seems
403:43 - all right it seems like it's a tiny bit
403:45 - off but
403:46 - maybe it's not actually off let's look
403:49 - at the maximum value being produced
403:51 - where the fft bins are converted into
403:53 - decibels
403:54 - and i'd like to think that it should be
403:56 - whatever gain level our gain processor
403:58 - is set to since a full-scale sine wave
404:01 - is being used
404:03 - as the test signal but
404:06 - let's find out
404:07 - head to the fft data generator
404:11 - all right fft data generator
404:13 - go down to the bottom
404:15 - we want to see the maximum decibel level
404:17 - that the fft data has so let's use juice
404:20 - jmax
404:22 - to find out first declare a local max
404:25 - variable
404:26 - set it to negative infinity
404:28 - this is where we convert everything into
404:30 - decibels so we want to find the maximum
404:31 - decibel level
404:33 - all right now declare a local variable
404:36 - that will hold our converted bin value
404:39 - then use jmax to store the max value
404:42 - between the current max and the
404:44 - converted fft bins value that looks like
404:47 - this auto data equals
404:50 - this thing
404:53 - f of t
404:55 - data at index i equals data and then
404:58 - max equals juice
405:01 - j max
405:03 - uh our data value and our max value
405:06 - let's add a j assert false so we can
405:08 - look at what that max value has
405:11 - j assert false
405:12 - i do not want to flood the console with
405:14 - this max value which is why i am not
405:17 - using
405:18 - a debug macro here all right oh and
405:20 - here's what our negative infinity turns
405:21 - out to be it's negative 49.41
405:24 - whatever
405:25 - okay let's test this out we need to
405:27 - press the continue button several times
405:29 - until the fft buffers are filled with
405:30 - data but let's see what we get we'll be
405:34 - able to inspect and see what max is set
405:36 - to
405:37 - all right max is negative 41 continue 19
405:41 - negative 16 negative 16 negative 16
405:44 - negative 16 negative 13 negative 12.
405:48 - all right
405:51 - 13 12.
405:53 - okay negative 12 3 6 5 whatever whatever
405:58 - okay
405:59 - i'm happy with that
406:01 - yeah negative three six five whatever
406:04 - okay now why is this not exactly 12
406:08 - it's because our oscillator's frequency
406:11 - is not the same as that of one of the
406:13 - frequency bins so let's change our
406:16 - oscillator's frequency to match one
406:19 - let's comment out this j assert false
406:22 - and head over to plugin processor dot
406:25 - cpp go to prepare to play
406:28 - all right now we're gonna fix this
406:30 - frequency here
406:31 - we need to test with a frequency that
406:33 - lines up with the center of an fft bin
406:37 - the bins are spaced evenly between zero
406:40 - hertz and the sample rate
406:42 - so
406:43 - we just need to divide the sample rate
406:45 - by the number of bins minus one and that
406:48 - will give us the bin width then from
406:50 - there we just multiply this bin width by
406:53 - any number n to find the center
406:55 - frequency of the nth bin
406:58 - i'm going to go with 50 because it's
407:01 - kind of close to a thousand hertz
407:03 - the fft order is a bit shift value so we
407:06 - need to shift 2 to the left by our fft
407:09 - order to get the number of bins then
407:12 - just subtract one
407:14 - since we don't count the bin with a
407:16 - center frequency of zero hertz
407:19 - that's what this looks like
407:22 - comment this out we're going to do
407:23 - oscillator dot set frequency we start
407:27 - with our sample rate
407:29 - get sample rate
407:31 - and then we divide that by
407:34 - uh
407:35 - our bin
407:36 - order which is fft order
407:39 - um let's see what are we setting that to
407:41 - i think we're doing it at like a low
407:42 - value let's see um
407:44 - the spectrum analyzer
407:46 - where are we doing that is that in the
407:47 - path producer class
407:49 - there it is
407:51 - right there
407:52 - fft order order two zero four eight
407:56 - all right let's copy that go back to
407:58 - plugin processor
408:00 - this is the fft order that we want
408:03 - okay we take this value we shift it
408:06 - we do bit shifting and then we subtract
408:09 - one
408:10 - from that and this gives us
408:13 - the bin width
408:17 - and then we just multiply this whole
408:19 - thing
408:20 - let's see this all needs to be in uh
408:24 - um let's see that needs to go this needs
408:26 - to be in parentheses
408:30 - and this gets multiplied by whatever bin
408:32 - i want so i'll do 50.
408:34 - all right this is going to produce a
408:36 - frequency that lines up with the center
408:40 - of one of the fft bins
408:43 - let's check it out
408:46 - all right look at that boom right on the
408:48 - money negative 12 and if we adjust this
408:51 - let's do negative 24
408:53 - right on the money and negative 36
408:59 - right on the money all right
409:02 - bug solved the fft analyzer is accurate
409:05 - again
409:07 - i hope you enjoyed um this whole process
409:10 - because this was a really fun bug to
409:12 - solve for me and i'm excited to share
409:15 - how it gets solved because it's a really
409:17 - interesting problem
409:19 - that was good times let's make a commit
409:22 - of that
409:24 - and we've got some extra stuff in here
409:26 - but that's okay we have these guys we'll
409:28 - just leave them in there for now we can
409:30 - turn this off in a minute
409:35 - okay let's see what do we do in the
409:36 - spectrum analyzer
409:38 - um this is mapped to zero this is mapped
409:41 - to zero
409:45 - uh we moved that function
409:47 - all right that's what that is okay path
409:49 - producer um we gave ourselves a means of
409:52 - supplying negative infinity based on the
409:53 - window position
409:56 - um in path producer this is where we
409:58 - just migrated that function over
410:01 - okay and then fft data generator this is
410:03 - where we figured out the max value
410:05 - um i don't know if we need to commit
410:07 - this
410:08 - we can just remove it later
410:11 - an analyzer path generator this is where
410:13 - we corrected a mapping issue
410:15 - stage that all right
410:18 - all right this is going to say corrected
410:20 - fft
410:23 - mapping inaccuracies
410:27 - i hope i spelled that right
410:29 - inaccuracies
410:33 - don't judge me if that's spelled wrong
410:37 - we need to fix a bug in the path
410:40 - producer
410:42 - the float vector operations copy
410:44 - function is not meant to be used where
410:46 - the destination buffer is the same as
410:49 - the source that's exactly what we are
410:50 - doing here
410:52 - this causes undefined behavior and
410:55 - causes address or thread sanitizer
410:57 - issues if that stuff is turned on i
410:59 - can't remember which one it triggers i
411:01 - just remember that it triggered it at
411:02 - one point and yeah either way we need to
411:05 - fix it so we can use std copy instead we
411:09 - also need to make sure that the temp
411:11 - buffer has the same or fewer number of
411:14 - samples as the mono buffer so let's do
411:17 - this first
411:18 - let's add a js search j assert
411:21 - size
411:22 - is less than or equal to monobuffer dot
411:25 - get num samples
411:27 - and now
411:28 - um we can just force it
411:30 - size equals juice j min
411:33 - size
411:35 - monobuffer get numb samples all right so
411:38 - this makes sure
411:40 - that
411:41 - size is set to
411:44 - monobuffer.getnumsamples or size
411:46 - whichever one is smaller
411:49 - all right for this we will need the read
411:51 - and write pointers
411:53 - in the monobuffer auto right pointer
411:56 - equals monobuffer
411:58 - get right pointer
412:00 - channel num is uh we need
412:03 - channel number is zero and our sample
412:06 - index is zero
412:08 - we need our read pointer
412:10 - auto read pointer
412:12 - equals monobuffer get read pointer
412:16 - this one we're reading
412:18 - channel zero
412:20 - and we're starting at index size
412:23 - basically these two lines right here
412:26 - all right now for std copy the first
412:28 - parameter
412:29 - the first parameter is the location of
412:32 - the first sample in the source buffer
412:34 - that we want to copy
412:36 - so that's going to be our read pointer
412:38 - the second parameter is the location of
412:42 - the last sample that we want to copy
412:46 - plus one so wherever we want to copy to
412:49 - the end of that
412:51 - all right read pointer
412:53 - plus
412:55 - here we have our
412:57 - monobuffer dot get num samples
413:03 - minus size
413:06 - all right and then the third parameter
413:08 - is the destination right pointer
413:13 - second parameter is kind of confusing so
413:16 - let's break out the whiteboard just to
413:18 - explain
413:19 - uh before we do that let's comment out
413:21 - the old code
413:24 - okay
413:26 - std copy is annoying because of how it
413:28 - works but it's the right tool for the
413:30 - job in this situation so i'm going to
413:32 - explain
413:33 - what is happening i've got rp
413:35 - representing read pointer i've got um wp
413:39 - representing the right pointer this is
413:41 - the same block of memory okay it's just
413:44 - i'm just showing eight
413:46 - eight bytes for right now
413:47 - okay
413:49 - our goal is to add three samples to the
413:52 - end of our array the way we're going to
413:55 - do that with std copy
413:57 - is to provide the right the read pointer
414:00 - which is at the third index and then our
414:04 - read pointer plus num samples minus the
414:07 - size is the end of the chunk we want to
414:11 - we want to read from
414:13 - and then we say hey where do we want to
414:15 - put this the destination
414:17 - that's the very beginning
414:20 - so again one more time we the first
414:22 - argument is the read pointer
414:25 - this is where we're gonna start reading
414:26 - from then we say all right where's the
414:29 - end
414:30 - and that's the read pointer plus the
414:32 - number of samples minus our size
414:35 - our size is three our number of samples
414:37 - is eight so we get three minus three
414:40 - plus eight is eleven minus three gives
414:42 - us
414:43 - one past um it's basically gives us the
414:47 - index after
414:48 - um
414:49 - the range we wanna copy it's that same
414:51 - thing with like um string uh substring
414:55 - where you say here's the first index and
414:57 - then go up to but not including this
415:00 - other index they're doing the exact same
415:02 - thing here we start at this index we go
415:04 - to this we copy from here up until this
415:07 - index but don't include this index and
415:09 - then we say all right we want to copy
415:11 - all that stuff to the right pointer
415:12 - which is at the beginning and this is
415:14 - going to shift this whole chunk over
415:16 - here which is going to give us
415:18 - our three samples it's going to give us
415:20 - room for our three samples at the end
415:22 - that's how std copy works like i said
415:25 - it's not the most intuitive thing to use
415:28 - but it does not trigger the
415:31 - thread sanitizer or
415:32 - address sanitizer errors that
415:36 - float vector operations do
415:39 - okay so that's
415:41 - um
415:42 - that's how the std copy operation works
415:44 - okay
415:46 - all right we commented out the old float
415:48 - vector operations so we can go ahead and
415:51 - test this out
415:53 - all right no visual difference this is
415:55 - still at zero uh still negative 12 still
415:58 - accurate
415:59 - negative 24 all right cool so that's
416:01 - fine okay cool so we can get back to our
416:03 - roadmap now that the spectrum analyzer
416:05 - has been dialed in and it is now ready
416:08 - for modifying let's go take a look and
416:09 - see what we have
416:11 - left to do
416:13 - all right this is done
416:15 - and this is done
416:17 - all right so we need to do this next
416:20 - all right let's make a commit because
416:22 - that was um
416:23 - that was a pretty decent um
416:26 - pretty decent bug that we fixed
416:29 - fixed um
416:30 - i think it's a sand i think it's address
416:32 - center
416:33 - issue in um
416:36 - path producer
416:38 - stage and stage
416:41 - okay
416:43 - all right let's disable our test
416:45 - oscillator this is extremely simple go
416:47 - to process block
416:50 - and change this to if false
416:54 - we can remove this stuff later if we
416:56 - want to
416:57 - i'm going to leave it in in case i need
416:59 - to do more testing
417:02 - this is more convenient than just com
417:04 - commenting it all out we're just left
417:06 - with a simple warning
417:08 - um let's see
417:10 - all right the next thing to do is
417:12 - we're going to tweak some of these
417:14 - graphics a little bit
417:15 - and then once we do that
417:18 - we're going to do a little bit of
417:19 - refactoring and then we're going to
417:20 - tweak the labels and then that's going
417:23 - to wrap up the spectrum analyzer
417:26 - so let's adjust these background
417:28 - graphics
417:30 - first
417:31 - all right go to spectrum analyzer dot
417:33 - cpp go to the paint function
417:36 - now i want to reorganize this a little
417:38 - bit i want to use the draw module
417:40 - background first that i've been using in
417:42 - other classes
417:44 - so that's the main motivation is i want
417:46 - this to have that same cool border that
417:48 - our other modules have the global
417:51 - controls and the compressor band
417:52 - controls
417:53 - draw module background is in the
417:55 - utilities file so we need to include
417:57 - that that's up here at the top include
418:01 - let's go find it
418:03 - setting is that in the guise yes it is
418:05 - in the gui so it's just right there in
418:07 - utilities
418:08 - i go back to the paint function
418:11 - okay right here
418:13 - let's call draw module background
418:16 - okay this function does not return
418:18 - anything but i wanted to return the area
418:21 - inside the module bounce
418:23 - this area will be where we draw
418:25 - everything and it is smaller than the
418:26 - local bounce so let's change the
418:29 - drawable
418:30 - so let's change the draw module function
418:32 - to give us this autobounds equals that
418:36 - all right we're just kind of saying hey
418:37 - this is going to give us something back
418:40 - all right let's go fix that next
418:42 - let's go to our utilities
418:44 - utilities.cpp
418:47 - all right bounds is what it is going to
418:49 - return
418:51 - bounds is the inner reduced rectangle so
418:53 - let's return that
418:55 - let's uh say that it's going to return a
418:57 - rectangle here
418:59 - and now let's change the return type in
419:02 - the declaration
419:03 - there is that function down here at the
419:05 - bottom rectangle
419:07 - okay cool
419:09 - back to the spectrum analyzer
419:11 - all right the next step is to revise how
419:14 - the background grid is drawn it is
419:16 - currently drawn relative to the local
419:19 - bounds and we need to make it relative
419:21 - to this bounding box that was returned
419:23 - from draw module background so let's
419:26 - revise the declaration first and then
419:29 - pass these bounds
419:31 - to it where we are calling it right here
419:35 - all right go to the header file
419:37 - all right comment out the old one and
419:40 - add a juice rectangle as the second
419:42 - parameter
419:44 - let's copy and paste
419:46 - juice rectangle
419:50 - int
419:52 - bounce
419:53 - all right go back to the cpp file
419:56 - cpp file
419:58 - now we can pass our bounds to this
420:00 - function
420:01 - let's update the implementation next go
420:04 - to the implementation draw background
420:06 - grid
420:08 - let's update this to take a rectangle as
420:10 - the second parameter
420:12 - all right next we need to make this
420:15 - analysis area function take a rectangle
420:17 - as its parameter
420:19 - let's change the declaration first and
420:21 - then the call site and then the
420:23 - implementation
420:25 - go to the header file
420:26 - get analysis area
420:29 - add a juice rectangle as the parameter
420:33 - all right that updates
420:35 - the declaration
420:36 - go back to the cpp file
420:39 - all right let's pass in the bounds now
420:42 - and let's update the implementation next
420:44 - this is way down here get an
420:47 - get analysis area
420:49 - change this
420:51 - juice rectangle
420:53 - int
420:55 - okay we need to make get render area
420:58 - compute its result based on this bounce
421:01 - that we're passing in
421:03 - so let's revise that function as well
421:06 - and then after we finish that revision
421:08 - we will update the implementation
421:10 - let's go to the declaration
421:13 - and add
421:15 - a rectangle as the parameter
421:17 - back to the cpp file
421:20 - and now let's
421:21 - update the call site
421:23 - here we can say bounds equals that and
421:26 - this is no longer an auto
421:28 - now we can update this implementation
421:30 - here
421:31 - pass inbounds
421:33 - all right we are providing a bounding
421:34 - box now so we do not need to get the
421:37 - local bounce
421:38 - okay let's go back to where we were in
421:41 - the paint function because we have a few
421:44 - errors now since revising get render
421:46 - area and get analysis area
421:49 - we're going to get to those though let's
421:51 - go back to the paint function
421:52 - okay let's get this compiling before we
421:55 - continue first of all we need to pass
421:57 - our bounds to this
421:59 - uh to these functions that want a
422:01 - parameter so response area
422:03 - um
422:04 - is provided by get analysis area and
422:06 - that requires bounds
422:09 - in draw text labels let's
422:12 - draw text labels let's see what error is
422:15 - our first
422:16 - spectrum analyzer okay this one um let's
422:19 - see
422:20 - just looking at my notes here
422:22 - draw text labels is what it says to do
422:25 - next
422:26 - all right draw text labels
422:29 - needs a rectangle
422:31 - because get analysis needs a rectangle
422:34 - so let's make draw text labels receive a
422:37 - rectangle as the second parameter
422:40 - and let's
422:42 - call that here
422:43 - bounce
422:44 - and let's update that declaration real
422:46 - quick
422:47 - go to the header file draw text labels
422:51 - okay go back to our
422:54 - cpp file go to that paint function one
422:56 - more time
422:58 - okay we're down here and draw text
422:59 - labels
423:00 - let's pass our bounding box here um
423:04 - let's add our bounds here into this get
423:07 - render area
423:08 - and in this one as well bounds
423:11 - are there any others in here
423:14 - okay let's do a quick build
423:17 - okay we need to pass our local bounds
423:19 - here
423:20 - in our get analysis area so let's get
423:22 - that auto bounds equals get local bounds
423:27 - bounce
423:29 - and we can dri dry this one right here
423:32 - this should just be bounce
423:34 - all right let's see what do we have next
423:37 - okay the last place is
423:41 - um right here
423:42 - let's get analysis area so let's dry
423:45 - this
423:46 - getting the local bounds auto bounds
423:49 - equals get local bounds
423:51 - and now we can pass bounce here
423:54 - and we can use our bounce here
423:57 - all right let's test it out it should
423:59 - all look the same except for having the
424:01 - module border around it
424:03 - all right no module border
424:07 - all right let's investigate paint and
424:08 - see if we missed something
424:11 - aha this fill path is covering up the
424:13 - background let's comment it out
424:15 - see what we get
424:17 - all right excellent we have a module
424:19 - border
424:20 - and we've got this uh line right there
424:23 - we'll deal with that in a little bit
424:25 - um and then we can also tweak these
424:27 - positions for the text labels next
424:29 - that was a lot that was very surgical
424:32 - let's make commit of that
424:36 - added
424:37 - uh what do we do we added module border
424:40 - to
424:41 - spectrum analyzer
424:44 - also disabled
424:46 - disabled test
424:48 - oscillator
424:49 - okay
424:50 - here's where we modify draw
424:52 - draw module background to return the
424:54 - rectangle that it
424:57 - ends up
424:58 - yeah
424:59 - it returns the rectangle that is
425:02 - being reduced
425:04 - right here's where we updated our
425:06 - declarations to work with bounding boxes
425:09 - and then here's all the code surgery
425:11 - that we did
425:15 - all right let's move all of this code
425:17 - into its own function
425:20 - let's declare a private member function
425:23 - spectrum analyzer dot h down at the
425:25 - bottom
425:26 - void draw fft
425:29 - analysis we need a graphics and a
425:31 - bounding box
425:33 - we can take that from here
425:34 - all right we're going to pass the
425:36 - bounding box because we're going to draw
425:38 - the paths
425:39 - within
425:40 - this bounding box
425:42 - all right let's go call it
425:45 - spectrum analyzer.cpp
425:48 - draw fft analysis g bounce
425:53 - all right let's implement it we just
425:55 - need to copy this code
425:56 - and then remove it
425:58 - i'm going to put that right up here
426:00 - void spectrum analyzer
426:02 - draw fft analysis
426:07 - and uh wants the juice namespace using
426:10 - namespace juice
426:14 - all right let's get rid of this code
426:15 - here
426:18 - all right let's go to our function
426:19 - because it's got it we have a few errors
426:22 - all right first error is it wants the
426:24 - response area so let's take that from
426:27 - here
426:29 - got that since it's not used anymore
426:32 - that can go here
426:36 - all right let's run this
426:40 - all right everything seems to look okay
426:43 - uh let's do the um
426:45 - we still have that white line
426:47 - but let's run this let's actually run
426:48 - some signal through this now just to
426:50 - make sure
426:52 - you can grab your headphones if you want
426:56 - all right that's still working
426:58 - cool
426:59 - all right let's take care of that white
427:00 - line that's being drawn
427:02 - we can use the graphics reduce clip
427:06 - region function to shrink the area that
427:08 - we are allowed to draw within
427:10 - if we combine this with graphics scoped
427:13 - save state
427:15 - this reduced clip region will stop being
427:17 - reduced once we leave this function
427:20 - so this lets us draw only within this
427:22 - response area which is pretty handy so
427:24 - first create a graphics save state
427:28 - juice uh we don't need to write that
427:30 - graphics
427:32 - scoped stave save state
427:35 - triple s
427:37 - passing in our graphics instance and
427:38 - then let's do g dot reduce clip region
427:42 - response area
427:44 - all right let's take a look at it
427:47 - all right i don't see that white line
427:49 - anymore
427:50 - that's fantastic
427:54 - all right and it's only drawing it
427:56 - within the negative 48 0. that's awesome
428:00 - okay the next thing is to fix these text
428:02 - labels and the grid itself because
428:05 - uh we don't care about you know plus 24
428:08 - to negative 24. we carry about um plus
428:11 - 12
428:12 - to negative 60 because that's what our
428:14 - threshold range is that's what we want
428:16 - to see on here
428:17 - okay
428:18 - let's commit this since that was a
428:21 - decent bug to fix
428:23 - fixed um
428:27 - negative infinity
428:29 - line being visible in spectrum
428:34 - analyzer
428:40 - also refactored
428:43 - how fft paths are drawn
428:50 - all right cool
428:52 - all right let's continue cleaning up the
428:54 - spectrum analyzer go to the paint
428:56 - function
428:57 - all right let's get rid of this border
428:59 - we already have a border
429:01 - that's the uh draw module background
429:05 - so let's comment out everything except
429:07 - the draw text labels
429:10 - get rid of that
429:12 - and get rid of this
429:14 - all right let's test it out standalone
429:17 - editor
429:18 - all right cool it looks good all right
429:21 - let's dial in the text labels next
429:24 - all right let's take a look at this all
429:26 - right first things first notice that
429:27 - this text along the top is colliding
429:31 - with uh this border so let's fix that
429:34 - that's in the text labels function let's
429:37 - go to that
429:39 - all right this is where we draw our
429:41 - frequencies
429:42 - right in this chunk right here
429:45 - all right this is where we draw it okay
429:48 - the y position should be the y position
429:50 - of the bounds that we're passing in not
429:53 - one so that's the first fix right there
429:55 - r dot set y
429:58 - bounds dot get y
429:59 - remember we're passing in a bounding box
430:01 - that is inside of our uh module
430:05 - background all right
430:07 - let's look at that
430:09 - all right cool they are no longer
430:10 - colliding that's great
430:12 - see
430:13 - next the text on the right
430:17 - okay this text is colliding with the
430:19 - edge let's fix that
430:21 - again it needs to be relative to the
430:23 - bounding box that we are passing in not
430:25 - the components bounding box let's go
430:27 - where that is that's in the gains
430:29 - that's gonna be this uh set x it's
430:32 - currently
430:33 - based off the components
430:36 - right edge and we need it to be based
430:38 - off of our bounding box right edge r dot
430:40 - set x
430:42 - bounds dot get right
430:45 - minus text width
430:47 - all right the text on the left let's see
430:49 - how that is i'm pretty sure that's
430:51 - colliding too and i can see where right
430:53 - there
430:54 - where did this go all right yep that
430:55 - text is colliding all right so this is
430:57 - good this is no longer colliding that's
430:59 - great
431:00 - this is colliding
431:02 - this needs to be not
431:04 - one to the right of the component left
431:07 - edge it needs to be one to the right of
431:08 - the
431:10 - bounds dot
431:12 - the bounding box left edge
431:14 - oops
431:15 - plus let's look at that
431:17 - okay great our text labels no longer
431:20 - collide let's do a quick commit of that
431:23 - surgical edit
431:25 - corrected uh no fixed
431:29 - text collisions
431:31 - with component edge
431:35 - also uh removed old border
431:39 - all right it is now time to introduce
431:41 - the concept of negative infinity and max
431:44 - decibels
431:45 - as well as min frequency and max
431:48 - frequency
431:49 - these values are constants that we are
431:51 - going to use in this project to ensure
431:53 - we aren't typing
431:55 - magic numbers whenever we need to supply
431:57 - a frequency range we will use min
431:59 - frequency and max frequency let's go
432:02 - define those now
432:03 - head over to utility.h
432:06 - utilities.h plural
432:09 - all right define these up at the top
432:12 - put these right here
432:13 - define
432:15 - min frequency
432:17 - 20 hertz
432:19 - and define max frequency
432:23 - 20 000 hertz
432:26 - next let's define our decibel ranges
432:29 - define
432:31 - negative infinity
432:34 - this is going to be negative 72
432:36 - and then max decibels will be plus 12.
432:39 - define
432:40 - max decibels
432:42 - 12 dot f
432:44 - finally we need to define our minimum
432:47 - threshold for our compressor bands
432:49 - define
432:50 - min threshold whoops all caps
432:54 - negative 60.
432:56 - our next job is to replace all instances
432:59 - of these values with our macros we will
433:01 - start with the plug-in processor
433:05 - there i go to
433:06 - uh what's the name of this function this
433:08 - is create parameter layout let's change
433:10 - this threshold range
433:12 - right here
433:13 - this needs to be min threshold
433:16 - and max decibels
433:19 - whoops
433:20 - max decibels
433:22 - all right let's do a quick build am i
433:24 - including utilities here
433:27 - apparently i am all right cool
433:30 - i did not think i was but i guess one of
433:32 - these classes is including it
433:34 - all right back to the spectrum analyzer
433:38 - all right
433:39 - let's change our mapping first
433:42 - all right we're not going to do negative
433:43 - 24 to positive 24. we are going to do
433:45 - negative infinity to max decibels so
433:48 - comment this out replace it auto y
433:50 - equals
433:51 - jmap
433:52 - our source value is gdp
433:55 - we got negative infinity
433:57 - max decibels
433:59 - and then this is
434:01 - let's see this is going to be
434:03 - um
434:04 - bottom but
434:06 - cast doesn't float
434:08 - and then top cast as a float
434:11 - all right good times
434:13 - all right we need to do this again where
434:16 - else do we need to do that
434:18 - um right here
434:20 - in
434:21 - draw background grid so we're doing it
434:23 - in draw text labels
434:25 - and then we're doing it in draw
434:27 - background grid
434:28 - so we can just copy this first just copy
434:31 - this stuff
434:32 - and let's fix this indentation
434:35 - and you should be all the way to the
434:36 - left
434:38 - all right let's go to the resized
434:39 - function because there's a negative 48
434:42 - over there
434:43 - all right comment out this line
434:45 - and add negative infinity
434:48 - and max decibels
434:51 - that's the choices
434:52 - all right let's test this out
434:54 - and see how it looks with our test
434:56 - signal we're going to re-enable our test
435:00 - signal so be sure to take off your
435:01 - headphones or turn down your speakers
435:05 - when you press the go button put this on
435:08 - true
435:10 - all right let's test it out
435:14 - all right we're missing grid lines it
435:16 - still lines up with the grid line
435:18 - uh but our labels are wrong it says plus
435:20 - 12 to minus 24 and then 12 to the
435:22 - negative 48.
435:24 - so let's fix that next
435:27 - back to spectrum analyzer
435:30 - all right we need to go to the get gains
435:32 - function
435:33 - all right let's change what we are
435:35 - returning here first of all
435:37 - uh let's dynamically create
435:40 - the vector instead all right if we
435:42 - change what negative
435:44 - infinity and max decibels mean it can be
435:46 - automatically reflected here so let's
435:48 - start at negative infinity and increment
435:50 - to max decibels using an increment size
435:52 - of 12. start with a vector of values
435:56 - let's return this return values
436:00 - now we can do auto increment equals max
436:04 - decibels we can change this if we want
436:06 - for now this is 12 db steps
436:10 - now we do 4 auto db equals negative
436:13 - infinity
436:14 - db is less than or equal to
436:16 - max decibels
436:18 - and we are incrementing
436:21 - by our increment db plus equals
436:23 - increment
436:25 - all right let's do values.pushback
436:28 - db
436:29 - all right let's test this out
436:32 - see if that solves our issue with the
436:34 - gains
436:37 - all right that looks good to me 12 to
436:39 - 96.
436:40 - uh why does that say negative okay this
436:42 - one says the right range it says plus 12
436:44 - to negative 72 which is what we want
436:47 - and
436:48 - all right this is off
436:50 - it's showing negative 12 and it should
436:53 - be showing that should be showing here
436:55 - we'll deal with that
436:57 - all right let's make both sides show the
436:59 - same range first
437:01 - all right let's get rid of the code go
437:03 - to the draw text labels function
437:07 - um there's code in here that shifts the
437:10 - value yes this code right here okay
437:11 - let's get rid of that
437:14 - don't clear it don't shift it
437:17 - all right the only thing that we need to
437:18 - actually change here is the x position
437:20 - because we're drawing the same string
437:23 - uh that we set here
437:25 - this string right here this is the only
437:26 - thing we need to change or sorry this is
437:28 - the only thing we're drawing so we don't
437:30 - need to change the text width we don't
437:33 - need to change the size
437:35 - we don't need to change the color we're
437:36 - just drawing the same string in a
437:38 - different position
437:40 - all right
437:42 - let's test this out
437:44 - we should see the same range same scale
437:47 - range on both sides of the fft now
437:50 - there we go plus 12 negative 72 plus 12
437:53 - negative 72. all right great
437:56 - all right now
437:59 - uh our fft is not mapping correctly this
438:02 - is negative 12 and it's showing up as
438:04 - zero so let's fix that next
438:08 - go to the analyzer path generator this
438:12 - is the source of the problem the problem
438:14 - here is that we are mapping our y
438:16 - position to the screen coordinates and
438:19 - notice that the upper range is zero
438:22 - and not max decibels so let's change
438:25 - that
438:27 - we want to make this
438:28 - max decibels instead
438:31 - negative
438:32 - infinity
438:34 - max decibels there we go
438:38 - um let's see if
438:40 - do we need to include the utility header
438:42 - for that let's do a build and see
438:44 - see what it does maybe it'll complain
438:47 - maybe it won't all right no complaints
438:49 - that's cool
438:50 - let's run this now
438:52 - all right
438:54 - all right this is pretty good
438:56 - all right let's change this to negative
438:58 - 24.
439:00 - also pretty accurate
439:02 - let's change it to zero
439:04 - all right it might be off by like you
439:05 - know one db or half a db
439:07 - uh but for the sake of this tutorial
439:09 - which is free i'm going to call this
439:11 - good if you really want to know how to
439:13 - make this stuff absolutely perfect you
439:15 - can check out project 11 or project 12
439:18 - where we
439:19 - create a perfect
439:21 - spectrum analyzer that is perfectly
439:23 - accurate
439:24 - all right let's turn off the test
439:26 - oscillator we no longer need that
439:28 - discard change
439:30 - all right
439:32 - one last test um let's do it with um
439:35 - let's see why did i run the standalone
439:38 - that looks clean now let's let's run
439:40 - some actual audio through it make sure
439:42 - it looks okay
439:43 - run it grab your headphones
439:45 - turn the volume back up
439:47 - so you can hear what it's doing
439:54 - all right
439:56 - fantastic
439:59 - okay cool all right next we're going to
440:01 - draw the crossovers then we're going to
440:03 - draw thresholds then we are going to
440:05 - draw gain reduction
440:07 - and that will conclude the spectrum
440:09 - analyzer
440:12 - let's make a commit of the work that we
440:14 - did
440:15 - what did we do
440:17 - um let's see um standardized
440:22 - how
440:23 - ranges are defined
440:26 - that's that that's what that is
440:28 - um
440:30 - fixed spectrum
440:32 - analyzer labels these should be reversed
440:35 - let's switch that
440:36 - all right fix spectrum analyzer labels
440:39 - and then we standardized
440:41 - how the ranges are defined
440:46 - all right sounds good
440:49 - all right before we go and implement
440:53 - crossovers and thresholds and gain
440:55 - reduction let's go through the code and
440:56 - replace any 20 hertz and 20 000 hertz
441:00 - with min frequency and max frequency
441:02 - where does that happen first
441:04 - all right here's one in analyzer paths
441:08 - generator
441:09 - right here
441:11 - okay this needs to be
441:13 - min frequency
441:15 - and max frequency
441:17 - okay there is another in spectrum
441:19 - analyzer
441:20 - um we just need to search for twenty
441:22 - thousand twenty one two three dot
441:25 - all right spectrum analyzer
441:27 - all right right here
441:28 - in uh the get x's function
441:32 - we're doing min
441:34 - freak
441:35 - and max
441:38 - all right
441:39 - and there should be two more let's just
441:41 - look for 20 000.
441:43 - only look in the actual project source
441:45 - code
441:46 - okay um
441:48 - spectrum analyzer
441:50 - um we're going to keep these hard coded
441:53 - all right plugin processor
441:57 - okay here's one right here this should
441:59 - be min
442:00 - min
442:01 - frequency and then this should be
442:04 - max frequency
442:07 - all right i believe those are the only
442:09 - two that remain
442:12 - all right yes okay cool
442:14 - all right those are the only two
442:16 - let's make sure
442:18 - all right
442:19 - our gain sliders still works
442:23 - our threshold slider
442:25 - still cool
442:27 - our frequency still goes 20 hertz to 20k
442:30 - all right cool good enough for me let's
442:33 - draw some crossovers next
442:37 - if you get stuck or run into trouble
442:39 - while coding this or simple eq just grab
442:42 - one of my free products from
442:43 - programmingformusions.com
442:45 - and you can message me directly in the
442:47 - slack workspace and i will help you
442:49 - directly
442:50 - we are going to draw our crossovers next
442:53 - to accomplish this all we need to do is
442:56 - get the frequency value from the
442:57 - crossover parameter
442:59 - map it to an x position and then draw a
443:01 - vertical line the timer callback is
443:04 - taking care of repainting the screen at
443:06 - a regular rate let's go look at um our
443:09 - spectrum analyzer.cpp so you can see
443:11 - what i'm talking about go to the timer
443:13 - callback okay this is
443:15 - repainting at a regular rate so that's
443:17 - good times okay so we don't need to do
443:19 - anything special to refresh whenever the
443:21 - crossover slider is dragged we just need
443:23 - to declare some stuff and
443:26 - add some functions and whatnot that can
443:28 - get the parameter and pull the
443:30 - crossovers and produce x values for us
443:32 - to draw from top to bottom okay let's
443:35 - declare a function for drawing the
443:37 - crossovers and call it
443:39 - first
443:40 - go to the header file
443:42 - spectrum analyzer.h let's do this at the
443:44 - bottom
443:45 - i'm just going to copy this draw fft
443:47 - analysis
443:48 - and
443:49 - rename it to be draw crossovers
443:53 - okay
443:54 - super simple
443:56 - let's go call it go back to that paint
443:58 - function
443:59 - and we're going to do this before we
444:01 - draw our text labels draw crossovers
444:06 - g
444:08 - bounds
444:09 - all right let's go implement it next
444:11 - i'm just going to
444:13 - put this right below the
444:16 - paint function because i'm lazy
444:19 - void
444:20 - spectrum analyzer draw crossovers
444:23 - all right i don't feel like scrolling to
444:25 - put it in the order that it was declared
444:27 - in
444:28 - which would mean it's after that draw
444:30 - fft analysis function okay
444:32 - we are going to be using a lot of juice
444:35 - functions in here so let's set up the
444:36 - namespace alias as always
444:39 - using names
444:42 - namespace juice
444:44 - okay then let's get our bounding box
444:47 - bounds equals get analysis area
444:50 - from our input argument
444:53 - all right next we need to give ourselves
444:56 - access to the two crossover parameters
445:00 - let's go back to the header file let's
445:03 - declare two member variables to do that
445:07 - one for the low mid and one for the mid
445:09 - high
445:10 - all right let's initialize these up to
445:12 - the constructor
445:14 - where is the constructor way at the top
445:17 - all right let's do this before we start
445:18 - our timer using namespace params whoops
445:22 - let's spell space correctly
445:24 - let's get our params map
445:27 - auto
445:28 - param
445:30 - equals get params
445:33 - all right um let's see it doesn't know
445:34 - where params come from so let's include
445:36 - where those come from
445:39 - include dot dot slash
445:42 - dsp
445:44 - params
445:46 - oh uh conflict so let's make this param
445:48 - names
445:49 - all right let's copy the float helper
445:52 - lambda from the plugin processor
445:54 - constructor plug-in processor all the
445:56 - way to the top where's that lambda float
445:59 - helper this thing right here
446:01 - copy that
446:02 - go back to spectrum analyzer let's put
446:04 - that here
446:06 - and we need to change the capture stuff
446:08 - a little bit
446:09 - differently we're not using that let's
446:11 - go like that and then this needs to be
446:13 - param names
446:15 - and this is going to be
446:17 - apvts equals audioprocessor.apbts
446:22 - and this we're capturing param names not
446:24 - params
446:25 - there we go
446:27 - okay
446:28 - now we can use it to initialize our
446:30 - members float helper
446:33 - low mid crossover
446:35 - and we want our names low mid crossover
446:38 - freak float helper
446:41 - mid high
446:42 - names
446:44 - mid high
446:45 - crossover freak
446:47 - cool
446:48 - all right we are going to draw a
446:50 - vertical line from the top of our bounds
446:52 - to the bottom of our bounds
446:54 - so let's go to that uh function we were
446:56 - working on
446:58 - draw crossovers
447:00 - and we need to cache the top and bottom
447:03 - let's do that next const auto top equals
447:06 - bounce dot get y
447:09 - and then const auto bottom equals
447:11 - balance dot get bottom
447:13 - all right first we need to map the
447:15 - frequency to a screen position so let's
447:17 - copy the mapping code from our get x's
447:20 - function wherever that is
447:23 - get x's all right here's the mapping
447:25 - code
447:26 - and we can turn we can uh dry this later
447:30 - use a free function if we want
447:32 - let's change this push back into a
447:33 - return statement we're going to stuff
447:35 - this into a lambda
447:36 - go back to our draw crossovers all right
447:40 - auto map x equals
447:42 - lambda lambda lambda
447:44 - all right and here's where we're going
447:46 - to
447:47 - take our norm x
447:48 - and we're going to return
447:51 - left plus width times norm x all right
447:54 - what do we need we need left
447:56 - left equals bounds dot get x
447:59 - we need the width width equals
448:03 - bounce.get width
448:05 - we need our frequency
448:08 - indent that please all right float
448:12 - frequency
448:14 - um let's make this say
448:16 - all right that's nice and
448:18 - readable
448:19 - all right now we can draw our crossovers
448:22 - use the map x function to convert the
448:25 - low mid into an x coordinate
448:27 - auto low mid
448:29 - x equals
448:30 - map x
448:31 - frequency is going to be low mid x over
448:34 - pram
448:35 - get
448:36 - all right uh let's draw a vertical line
448:37 - from top to bottom g dot set color
448:41 - colors let's do orange because that'll
448:44 - stick out and we can do g dot draw
448:47 - vertical line our x is going to be low
448:50 - mid x and our top is top and our float
448:53 - our bottom is
448:54 - all right let's do the same for the mid
448:56 - high
448:57 - auto mid high
448:59 - x equals map x
449:02 - mid high pram
449:04 - get the value
449:07 - drop
449:08 - g dot draw vertical
449:10 - mid high from the top to the bottom
449:14 - let's test it out
449:16 - all right we see some crossovers
449:19 - let's put this right at 200
449:21 - perfect
449:23 - works like a charm but a 2k
449:27 - default value default value
449:29 - all right awesome
449:30 - let's do thresholds next let's do the
449:32 - same thing for the thresholds that we
449:34 - did for the crossovers
449:37 - go to the um header file
449:41 - we have three compressor bands so we
449:43 - need three threshold parameters let's go
449:46 - um
449:47 - yeah just copy these rename them and we
449:49 - will initialize them in the constructor
449:51 - next let's do one more
449:53 - all right low threshold
449:55 - param
449:56 - let's just copy the word threshold and
449:59 - change this to say
450:01 - hi whoops
450:02 - hi h i g h
450:05 - mid threshold
450:07 - all right cool
450:08 - that takes care of the declarations
450:10 - let's go construct these again
450:12 - go to the uh constructor
450:16 - let's use our float helper to make our
450:17 - life very simple
450:19 - i'm just gonna copy this three times and
450:21 - rename it two three
450:23 - low threshold
450:25 - mid threshold
450:27 - high thresh
450:29 - low threshold
450:31 - threshold low
450:33 - thresh mid
450:35 - and thresh
450:36 - hi
450:38 - perfect okay let's go draw
450:41 - let's go to the draw crossover function
450:43 - and update it to also draw thresholds
450:46 - all right draw crossovers
450:48 - okay here is how we are going to draw
450:50 - these thresholds number one we draw a
450:52 - horizontal line from the left edge to
450:54 - the low mid crossover let me pull the
450:56 - plugin up
450:58 - so you can see what i'm talking about
450:59 - all right we are going to draw a
451:01 - horizontal line from the left edge
451:04 - to this crossover right here
451:07 - all right we're going to use uh the y
451:09 - value is going to be the
451:11 - low threshold param mapped to this
451:13 - decibel range okay then we're going to
451:15 - draw
451:16 - a horizontal line from the low mid
451:19 - crossover to the mid high crossover
451:22 - again using the same y value is
451:24 - mapped onto these screen coordinates
451:27 - then we're going to draw a horizontal
451:28 - line from the mid high to the right edge
451:31 - of our
451:32 - analysis area
451:34 - so we're going to need the left x and
451:36 - we're going to need the right x too
451:38 - all right let's get those guys
451:40 - const auto left
451:43 - equals bounds dot get x const auto right
451:47 - equals bounds dot get right now we can
451:50 - map our thresholds to their y position
451:52 - and then draw horizontal lines let's
451:54 - grab the y mapping code from draw
451:57 - background grid
451:58 - that's this stuff right here
452:00 - and turn it into a lambda
452:02 - copy this
452:03 - go back up to draw crossovers let's make
452:06 - a lambda real quick
452:08 - auto map y equals lambda lambda lambda
452:12 - guts of it is this mapping function we
452:14 - need to capture the top and bottom
452:17 - bottom
452:18 - top
452:19 - and we need to pass in our decibels so
452:21 - change that name db
452:24 - float db
452:26 - and now we just need to return it okay
452:28 - great
452:29 - now we can use it
452:30 - i want to use a different color
452:33 - than the color that i used for the
452:34 - crossover so i'm going to go with yellow
452:37 - colors
452:38 - yellow
452:40 - now we're going to draw the low band
452:41 - threshold from the left edge to the low
452:43 - mid crossover so g dot draw horizontal
452:46 - line our y is going to be map y
452:50 - and we are mapping our low
452:52 - threshold parameter
452:54 - and our left side is going to be the
452:56 - left edge and our right is going to be
452:58 - low mid x
453:00 - okay
453:01 - pretty simple
453:02 - let's test it out just to make sure it
453:04 - works
453:05 - we should see a yellow horizontal line
453:08 - for the low band depending on what it is
453:10 - set to
453:11 - all right cool it is set to negative 23
453:14 - and i see that
453:15 - this line is right above the gray
453:18 - so that's cool let's put this on 12.
453:20 - all right nice and accurate
453:22 - awesome that is working as expected
453:24 - that means we can do the other ones uh
453:26 - this line is a little bit hard to see
453:29 - i might change this later to draw a
453:31 - rectangle that is you know taller
453:33 - with a center y
453:35 - of
453:36 - this thing whatever this y value is
453:39 - uh but for now i'm just going to leave
453:41 - this as is and we're going to draw the
453:44 - other lines
453:46 - draw horizontal
453:47 - draw horizontal okay we are mapping the
453:50 - mid
453:51 - threshold param and we're mapping the
453:53 - high threshold param
453:55 - our left side is going to be the low mid
453:58 - x and our right side is going to be the
453:59 - mid high x
454:02 - for the mid threshold for the high
454:04 - threshold our left side is the mid high
454:06 - x and our right side is
454:08 - the right
454:10 - all right let's test it out
454:12 - all right let's adjust the mid threshold
454:15 - cool and let's adjust our crossovers
454:19 - fantastic
454:21 - now if you want to make these draggable
454:23 - or if you want to learn how to make
454:24 - these draggable when you click and drag
454:25 - on them
454:26 - you can learn how to do that in project
454:28 - 12. we cover how to make this a very
454:30 - interactive gui so you can adjust all
454:32 - this stuff all right the last thing to
454:35 - do is to draw gain reduction
454:38 - all right we are nearing the end of our
454:40 - road map let's go mark off a few items
454:43 - ah let's make a commit first actually
454:46 - what did we do we um added a
454:50 - spectrum
454:52 - let's see spectrum
454:54 - analyzer
454:56 - shows crossovers and thresholds
455:00 - that's what we did stage
455:03 - um we also adjusted um
455:06 - used
455:07 - macros for min max frequencies
455:11 - all right here's our spectrum analyzer
455:12 - with our draw crossover fanciness
455:18 - we're nearing the end of our road map so
455:19 - let's mark off a few more items
455:23 - plugin processor.h we are drawing the
455:25 - crossovers that's done
455:27 - um and we need to
455:29 - draw the gain reduction so let's do that
455:32 - next
455:33 - let's go to the compressor band class
455:36 - all right first of all we're going to
455:37 - need some atomic members that will store
455:39 - the rms levels
455:41 - one for the input and one for the output
455:44 - all right these should be initialized to
455:45 - negative infinity uh we're going to need
455:47 - to include our header file to make use
455:50 - of negative infinity um
455:52 - these are going to get the rms level of
455:55 - the buffer
455:56 - before and after processing all right
455:58 - let's put these here
456:00 - in the private section
456:02 - std uh let's see i'm doing two of them
456:04 - so i don't want to type twice so let's
456:06 - do the old option
456:08 - drag and do std atomic
456:11 - float
456:12 - um let's see rms
456:15 - level
456:16 - db
456:17 - curly brace
456:19 - negative infinity
456:21 - closing curly brace semicolon
456:24 - all right let's change this to be
456:26 - input and this is output cool
456:30 - let's include
456:32 - um utilities for that
456:35 - include
456:36 - uh let's see yeah utility so dot dot
456:39 - slash
456:41 - dot dot slash
456:43 - all right gui utilities dot h
456:47 - let's just make sure that that's cool
456:49 - all right all right build succeeded
456:51 - all right next we need some getter
456:53 - functions
456:55 - so let's write a pair
456:57 - again
456:58 - i'm going to type it twice
457:00 - float
457:01 - get
457:02 - rms
457:04 - level db
457:06 - these are const functions
457:08 - and they return
457:10 - rms level db
457:13 - colon all right let's fix these names
457:15 - get rms output level
457:17 - and get rms input level
457:20 - and this is going to return
457:22 - the input returns input output returns
457:25 - output cool
457:27 - all right let's go to the compressor
457:29 - band uh cpp file
457:31 - we just need to sample the rms level
457:34 - before we compress and then after we
457:36 - compress our buffer has multiple
457:38 - channels so we want to compute the
457:40 - average rms level over all of these
457:42 - channels we're going to need to write a
457:44 - function to do that i am lazy and do not
457:46 - want to figure out the types that we are
457:47 - passing in so i'm going to template this
457:49 - function
457:50 - because templates are awesome
457:53 - okay go back to the compressor band
457:55 - header file put this after
457:58 - these guys
457:59 - all right this is fairly simple to write
458:02 - first of all we need the number of
458:03 - channels let's uh write a template
458:06 - function now
458:07 - template type name
458:09 - t
458:11 - float compute rms
458:14 - rms level
458:16 - const t buffer
458:19 - okay
458:20 - first we need to compute
458:22 - the rms level of each channel
458:24 - um let me start over first of all we
458:26 - need the number of channels in the
458:27 - number of samples
458:30 - then we are going to need to compute the
458:32 - rms of each channel and add them all
458:34 - together
458:35 - then we just divide this summed value by
458:37 - the number of channels and that gives us
458:39 - our averaged rms level for the buffer
458:42 - let's do that
458:43 - all right so first we get the number of
458:45 - channels and the number of samples
458:48 - then we get a we set an rms level to
458:50 - zero and now we walk through every
458:53 - channel and get the rms level for that
458:55 - particular channel for all samples
458:58 - then after summing them all together we
459:00 - just divided by the number of channels
459:02 - and that is our averaged rms level for
459:05 - the buffer
459:06 - nice and simple all right let's go use
459:08 - this function next compressorband.cpp
459:12 - go to the process function
459:15 - all right
459:16 - let's get the pre-rms level of the
459:19 - buffer and remember this is not
459:21 - expressed in decibels so auto pre-rms
459:25 - equals compute rms level buffer
459:29 - okay and then let's get the post rms
459:32 - level
459:33 - compute rms level buffer
459:36 - and i don't want to write juice
459:39 - decibels gain to decibels twice so i'm
459:41 - going to do a
459:43 - helper lambda
459:45 - return
459:47 - juice decibels
459:49 - gain two decibels
459:51 - and now we can use it to store our pre
459:53 - and post rms levels as decibels in the
459:56 - atomic members so rms
459:59 - input level dot store
460:02 - convert to decibels the pre-rms
460:06 - then rms output dot store convert to db
460:11 - post rms
460:13 - all right the next thing to do is to get
460:15 - these values into our spectrum analyzer
460:18 - head on over to the editor
460:20 - for that
460:21 - plugin editor dot h we need to pull
460:24 - these compressor rms levels p-o-l-l we
460:28 - need to pull these compressor rms levels
460:30 - at a regular interval so let's inherit
460:33 - from timer next
460:36 - juice timer
460:38 - let's add the appropriate callback
460:41 - void
460:42 - timer callback
460:45 - let's go start the timer in our
460:48 - constructor let's do this after set size
460:51 - i'm going to do a 60 hertz timer so it's
460:53 - refreshing 60 times a second
460:56 - and now let's go implement it let's do
460:58 - this after resized
461:00 - void simple mbcomp editor
461:04 - timer callback all right
461:07 - the compressor bands are not public
461:10 - so let's make them public first before
461:12 - we start polling them here
461:15 - go to uh pluginprocessor.h
461:19 - way down to the bottom
461:21 - move these to the public section all
461:24 - right go back to plugin editor timer
461:26 - callback
461:27 - now that those compressors are public we
461:29 - can create a vector and get these rms
461:32 - levels so i'm going to create a vector
461:34 - so i only have to pass one object to the
461:36 - spectrum analyzer instead of six
461:39 - this means that the function that i
461:40 - write i only have to type one parameter
461:43 - uh declaration instead of six so you
461:46 - know simplify my life a little bit
461:49 - here we go declare a vector and grab the
461:51 - input and output rms levels from each
461:54 - band
461:56 - let's go write a function in our
461:58 - spectrum analyzer to receive this vector
462:02 - spectrum analyzer dot h
462:04 - let's make an update function in the
462:06 - public section
462:08 - void
462:09 - update
462:10 - now we're going to need to compute the
462:12 - gain reduction from the values that we
462:14 - are getting so let's let's see i'm
462:16 - getting ahead of myself
462:18 - all right first let's declare this it's
462:19 - going to take an std vector
462:21 - of float values
462:24 - all right we're going to need to compute
462:26 - the gain reduction from the values that
462:28 - were passed to us
462:29 - let's declare three variables that can
462:31 - hold those values
462:34 - all right
462:35 - three floats let's put these at the
462:37 - bottom
462:38 - way down here with our params
462:40 - float low band gr
462:43 - initialize them all to zero since no
462:45 - gain reduction is happening
462:47 - to begin with float mid band gr
462:52 - okay
462:53 - cool back to the editor let's pass that
462:55 - vector
462:57 - to the um spectrum analyzer
463:00 - uh analyzer is that what i'm calling it
463:03 - updates values all right our analyzer
463:06 - has been updated with fresh rms levels
463:10 - of uh input and output
463:12 - uh gain buffer levels whatever we're
463:14 - calling it rms input levels let's go
463:16 - implement this update function next
463:19 - all right let's go to spectrum
463:20 - analyzer.cpp i'm going to put these
463:22 - below the
463:23 - uh draw crossovers function
463:26 - all right void spectrum analyzer update
463:31 - first let's make sure we have six values
463:34 - j asserts values dot size equals six
463:39 - um i don't know why it wouldn't be that
463:41 - but
463:42 - you know
463:43 - just to make sure
463:44 - all right next i am going to help myself
463:47 - out and give myself an enumeration that
463:49 - i can use to index into this vector and
463:51 - keep track of which indexes point to
463:54 - which rms
463:55 - levels that looks like this
463:58 - all right now i can simply update my
464:00 - gain reduction
464:02 - my gain reduction member variables and
464:04 - then repaint the gain reduction is a
464:07 - negative value usually so we want to
464:09 - subtract the input
464:11 - from the output as the output is almost
464:14 - always lower than the input level so
464:16 - that looks like this
464:18 - low band gr equals values
464:22 - low band out
464:23 - minus values
464:25 - low band in
464:27 - all right very simple
464:29 - all right let's do the rest and then
464:30 - repaint
464:32 - all right in order to draw the gain
464:34 - reduction correctly we need to know the
464:36 - following coordinates per band
464:38 - this is going to happen in where are we
464:40 - doing this we're doing this in our draw
464:42 - crossovers draw crossovers is where we
464:45 - need to go
464:46 - in order to draw the gain reduction
464:48 - correctly we need to know the following
464:49 - coordinates per band the left x the
464:52 - right x where 0 db is as a screen
464:55 - coordinate and whereas the gain
464:57 - reduction is
464:58 - expressed as decibels again as a screen
465:01 - coordinate so let's
465:03 - um compute zero db
465:05 - auto zero db equals map y
465:09 - zero dot f all right we've got the left
465:11 - x and the right x that's what this stuff
465:13 - is and this stuff here
465:16 - so we just need to map the gain
465:17 - reduction before we can draw our gain
465:19 - reduction
465:20 - that's pretty easy to get
465:22 - so let's get our color first i'm just
465:24 - going to give it some alpha so it
465:26 - doesn't cover up the grid lines
465:27 - g dot set color
465:30 - i'm going to use hot pink because i want
465:32 - something that sticks out colors hot
465:34 - pink
465:35 - with alpha
465:36 - give me an alpha of 0.3 f
465:40 - all right
465:41 - now i am going to use the rectangle
465:44 - static function left top right bottom to
465:47 - create the rectangles that will
465:49 - represent the gain reduction and then
465:50 - i'm going to fill them up
465:52 - so here we go
465:53 - and i'm going to draw these behind
465:56 - i'm going to draw these behind the
465:59 - actual
466:01 - threshold levels
466:03 - all right g dot phil rect
466:05 - and we're gonna do rectangle
466:07 - um
466:09 - we're gonna do float and we want the
466:10 - left top
466:12 - right bottom okay our left is going to
466:14 - be left our top is 0 db
466:17 - our right side is going to be the low
466:20 - mid x
466:21 - and our bottom is going to be the low
466:24 - band
466:25 - gain reduction mapped
466:27 - map y
466:28 - low band gain reduction
466:30 - all right let's put that all
466:32 - separate lines
466:33 - okay let's do this again for the next um
466:37 - for the mid band
466:39 - all right so this is mid band
466:40 - it mid-band gain reduction this one is
466:42 - high band gain reduction
466:45 - okay our left side for this one is the
466:46 - low mid x and our right side is the mid
466:50 - high x
466:51 - for this one it's mid high x
466:54 - and then the right edge
466:56 - all right let's feed some audio through
466:58 - the plug-in we're going to test this out
467:00 - we should see some gain reduction
467:02 - uh not standalone
467:04 - we're going to use um
467:07 - audio plug-and-host we're going to feed
467:08 - some actual audio through this and we
467:10 - should see some gain reduction
467:12 - rectangles light up
467:14 - let's see what happens do we have any
467:15 - errors nope just the warning about that
467:17 - stuff that's marked false the test
467:19 - signal
467:20 - all right here we go
467:28 - there we go look at that rectangle
467:29 - that's awesome let's adjust the mid-band
467:32 - get that squishing
467:43 - all right
467:47 - [Music]
467:53 - all right very cool
467:54 - [Music]
467:57 - awesome okay there are only three things
468:00 - left to do in this project let's save
468:03 - and quit this
468:04 - let's make a commit and then we'll talk
468:06 - about those three things that remain
468:08 - uh this was added added gain reduction
468:13 - display
468:14 - is that all we did
468:16 - yeah that's right game reduction uh
468:18 - timer is part of that here's the gain
468:20 - reduction
468:22 - that's where we passed it to the
468:23 - spectrum analyzer those are our members
468:25 - that display the gain reduction
468:28 - and here's how we actually made it
468:29 - happen
468:30 - and then here's where we compute the
468:32 - gain reduction so this was cool bit of
468:34 - code surgery on this one pretty involved
468:36 - but good times
468:38 - all right let's talk about the major
468:40 - three things we have left to do let's
468:42 - look at our road map plugin processor.h
468:45 - at the top all right we are currently
468:47 - drawing our gain reduction done
468:50 - all right analyze your bypass button
468:52 - that's not going to be difficult
468:54 - um global bypass button that's got a few
468:56 - tricks to it and then the color scheme
468:59 - and the color helper stuff i want to
469:00 - talk about that at the very end
469:02 - so we are nearing the completion of this
469:04 - project i hope you are enjoying the
469:06 - journey
469:10 - let's tackle the control bar next
469:12 - uh the first thing we will do is add the
469:15 - analyzer button
469:16 - just like in the simple eq project this
469:19 - button will toggle the analyzer on and
469:21 - off let's go to the plugin editor.h
469:25 - let's just put this right here
469:28 - all right first things first let's
469:29 - define a class for it
469:32 - okay we already copied the code for this
469:34 - button over earlier
469:36 - that's right here here's our analyzer
469:38 - button
469:39 - so we just need to include that file
469:43 - include
469:44 - gui custom buttons
469:47 - and then we can give ourselves an
469:48 - instance let's put this in the uh
469:52 - just toss it right here
469:53 - analyzer button
469:56 - analyzer button all right
469:59 - next we need a constructor to make it
470:00 - visible and a resized function to give
470:03 - it some bounds
470:05 - plugin editor dot cpp go to the top
470:08 - stick that right here
470:10 - add and make visible analyze button
470:14 - uh let's make it
470:15 - uh toggled on by default analyzer button
470:18 - dot set toggle state
470:20 - should be on true
470:22 - uh don't send a notification
470:26 - all right
470:27 - let's make it sit on the left and be
470:29 - about 50 pixels wide i'm gonna want a
470:32 - small gap between the top of the
470:33 - component let's start our resized
470:35 - function void control bar
470:38 - resized um as i was saying let's make it
470:41 - sit on the left side of the gui be about
470:43 - 50 maybe 60 pixels wide i'm gonna want a
470:46 - small gap between the top of the
470:47 - component and the bottom
470:49 - um and also between the component and
470:51 - the spectrum analyzer
470:53 - so i'm going to trim a little bit off of
470:55 - the top and the bottom of our local
470:56 - bounce
470:58 - auto bounds equals get local bounds
471:01 - an analyzer button dot set bounds
471:05 - and we're going to do bounds dot remove
471:07 - from left
471:09 - 50 and then we need to take some off the
471:11 - top dot remove from top
471:14 - just a little bit
471:16 - with
471:16 - trimmed
471:18 - uh not remove from top we want with
471:20 - trimmed top with trimmed top
471:22 - all right this returns a version of this
471:24 - rectangle with the given amount removed
471:26 - from its top edge so that's what we want
471:28 - with trim to top
471:30 - four
471:31 - and with trimmed bottom
471:33 - all right because we're removing four
471:35 - from the top of
471:37 - this rectangle the rectangle that's 50
471:40 - pixels that was removed from the left
471:41 - edge we're trimming four off of the top
471:43 - of that thing
471:45 - all right
471:46 - that's the width trimmed stuff versus
471:48 - the remove stuff can be kind of tricky
471:51 - the first few times you use it all right
471:53 - let's get rid of our placeholder once
471:55 - and for all
471:56 - go to the plugin editor get rid of the
471:59 - placeholder control bar and make it a
472:01 - control bar
472:03 - awesome
472:04 - get rid of all this stuff
472:06 - all right plugin editor.cpp
472:09 - let's connect the control bar analyzer
472:11 - button
472:12 - uh to the actual analyzer and toggle
472:15 - enablement accordingly let's do this
472:17 - before we make it visible
472:19 - control bar
472:20 - dot analyzer button dot on click equals
472:23 - lambda lambda lambda semicolon you go on
472:26 - a new line oops and we're going to
472:28 - capture this
472:30 - and we're going to do analyzer dot
472:33 - toggle
472:35 - analyzer
472:36 - analysis enablement and it should be on
472:39 - if the analyzer control button
472:42 - if the control bar analyzer button
472:44 - toggle state says so
472:46 - so let's just get that state
472:48 - bool should
472:50 - i'll use auto auto should
472:53 - be on
472:55 - equals control bar
472:57 - analyzer button get toggle state
473:00 - all right now we just need to make it
473:02 - visible let's uncomment this line let's
473:04 - test her out run some audio see if the
473:06 - spectrum analyzer turns on and off
473:09 - all right let's test her out
473:12 - all right we're going to run some audio
473:13 - we're going to click that button
473:15 - [Music]
473:19 - all right perfect
473:21 - save
473:22 - stop
473:23 - quit
473:24 - perfect all right um
473:27 - global bypass is next all right
473:30 - we have included
473:32 - uh let's see where's our header editor
473:35 - file all right
473:36 - all right we already included our custom
473:37 - buttons so let's add our power button
473:40 - next super easy um declare an instance
473:44 - power button
473:45 - global
473:47 - bypass button all right great let's add
473:50 - it as a child go to the plugin editor
473:52 - dot cpp
473:54 - up here
473:55 - add and
473:57 - make
473:58 - visible
474:00 - global bypass button
474:02 - all right let's give it some bounds and
474:04 - um see what we got
474:06 - all right i'm going to make it 60 wide
474:09 - maybe that'll look cool let's see i'm
474:11 - going to stick it on the right side
474:12 - globalbypassbutton.setbounds
474:15 - bounds.remove from right
474:18 - 60 and i'm going to trim off the top and
474:21 - trim off the bottom
474:22 - with trimmed top i'm gonna do a little
474:24 - less than four so i'll do two
474:26 - with
474:28 - that width with trimmed bottom see i
474:30 - might change that later
474:32 - let's see how we see how it looks
474:35 - should see a little power button in the
474:36 - upper right hand corner
474:38 - alright perfect
474:40 - it doesn't do anything let's make it do
474:42 - something
474:43 - alright
474:44 - clicking the bypass button should toggle
474:47 - the bypass parameter of each band before
474:49 - we set up the bypass buttons on click
474:52 - lambda let's declare a function that
474:53 - will toggle the global bypass state
474:57 - all right let's go declare this as
474:59 - private plugin editor.h go down to the
475:01 - bottom
475:02 - put this here void toggle global
475:06 - bypass state
475:08 - all right let's go set up the lambda
475:11 - plug in editor.cpp
475:13 - and do the lambda right after our
475:16 - control bar
475:17 - control bar
475:19 - dot um whoops let me spell that right
475:22 - dot global bypass button dot on click
475:25 - equals lambda oops
475:27 - equals lambda lambda lambda
475:30 - we're going to capture this one more
475:32 - time
475:33 - all right we're going to call our toggle
475:35 - global bypass function
475:37 - all right
475:38 - let's go implement that let's put this
475:41 - after timer callback void simple editor
475:45 - toggle global bypass
475:47 - okay first we need to get the toggle
475:49 - state of the button if the button is off
475:52 - meaning it's green
475:54 - everything should be enabled so auto
475:56 - should enable
475:58 - everything
475:59 - equals
476:01 - control bar
476:02 - global bypass button
476:04 - get toggle state all right again if this
476:07 - is on
476:09 - sorry if this button is off meaning it
476:11 - is currently drawing as green everything
476:14 - should be enabled so if it's off then
476:16 - this should be true if this is off that
476:18 - means it's false which means this should
476:20 - be true so we want the opposite of that
476:23 - all right next we need to get all of the
476:25 - bypass parameters let's write a function
476:28 - to give us that
476:29 - plugin editor.h put it after this uh
476:32 - let's return an array
476:34 - std
476:35 - array all right we are returning three
476:38 - instances of audio parameter bull
476:40 - it's called get bypass params nice and
476:42 - convenient
476:44 - all right let's get to the params
476:46 - auto params equals get bypass per amps
476:50 - let's write this function next
476:53 - all right put this down here
476:55 - std array
476:57 - juice audio parameter bool
477:00 - three of them
477:02 - simple
477:03 - editor
477:04 - get bypass params
477:06 - we need to query the audio processor
477:09 - value tree state for these parameters so
477:11 - we will need the usual namespace aliases
477:14 - and references when looking up the
477:16 - parameters let's do that now
477:19 - all right let's copy the bool helper
477:22 - uh first i need to include the right
477:24 - params file include
477:27 - dot dot slash dsp
477:30 - is that where dsp is no dsp is
477:32 - right there params
477:34 - all right
477:35 - let's copy the bool helper from plugin
477:37 - processors constructor and modify it for
477:40 - our needs plug-in processor
477:43 - scroll down for the bool helper copy and
477:46 - put it right here
477:47 - all right so specifically we needed to
477:50 - return a pointer instead of a reference
477:54 - right now this is returning a reference
477:56 - and this is also modifying
477:58 - um it's modifying the input parameter we
478:00 - don't care about that so we're not doing
478:02 - that we're going to return whatever it
478:04 - figures out return param
478:07 - and then ap vts um we can just capture
478:10 - that that should be that um then we need
478:12 - auto declaration here auto param equals
478:15 - whatever param we get from the ap vts
478:17 - casted to a
478:20 - audio parameter bool if the cast is cool
478:22 - this will not fire and hopefully we will
478:25 - return a pointer okay great
478:28 - now we can use the helper to get three
478:30 - boolean parameters
478:32 - auto low
478:34 - bypass param equals bool helper
478:38 - names bypassed low band
478:41 - all right let's do that for the other
478:43 - two bands
478:44 - there we go mid band high band bypass
478:47 - all right now we can just package them
478:49 - into an array
478:50 - return
478:52 - low bypass
478:54 - mid bypass
478:55 - high bypass
478:57 - all right cool
478:58 - all right we have our parameters now
479:00 - whenever we change audio parameters we
479:02 - need to tell the host that it is part of
479:04 - a guester this is so that the host can
479:07 - store these changes in automation
479:09 - let's write a helper lambda to do this
479:12 - we are going to be updating three
479:13 - parameters so the first lambda argument
479:16 - will be the parameter second will be
479:18 - whether or not the parameter should be
479:20 - bypass auto bypass param helper equals
479:24 - lambda lambda lambda first param is the
479:26 - parameter auto param second is whether
479:29 - or not it should be bypassed bool should
479:31 - be bypassed
479:33 - all right now we can begin our change
479:35 - guester param
479:37 - begin
479:38 - change gesture
479:40 - then we can set the params value based
479:42 - on if it should be bypassed or not
479:44 - param set value notifying host
479:49 - should be bypassed
479:51 - then it should be one otherwise should
479:53 - be zero
479:54 - um it's important to remember that set
479:56 - notifying set value notifying hosts
479:58 - wants a normalized value between zero
480:01 - and one all right and then we can end
480:03 - our change guesser param and
480:06 - change guess
480:07 - now we can loop through our parameters
480:10 - for auto param
480:12 - params if everything should be enabled
480:15 - then should be bypassed should be false
480:18 - that means we want the opposite of
480:20 - should enable everything passed in as
480:22 - the parameter so bypass program helper
480:26 - passing the param and should be bypassed
480:28 - is the opposite of should enable
480:30 - everything
480:31 - all right
480:33 - let's test that out
480:35 - all right let's do this okay so the
480:38 - active compressor bands band select
480:41 - button changes
480:46 - the other band select buttons do not for
480:48 - instance this is showing as bypassed but
480:50 - this state is not updated
480:52 - and if we click on those bands like same
480:54 - for the high one it's bypassed but this
480:56 - button is not reflecting that state
480:58 - so we need to fix that
481:01 - we need to update the colors of the band
481:04 - select buttons that are not the active
481:06 - band whenever we toggle the global
481:08 - bypass button
481:09 - let's do that next we need to add a
481:11 - member function in compressor band
481:13 - controls that will update these bands
481:16 - colors so head on over to compressor
481:18 - band controls
481:20 - all right let's declare a public
481:21 - function
481:23 - void toggle all bands
481:26 - bool should be bypassed
481:29 - all right let's put this below button
481:31 - clicked in the implementation
481:34 - button clicked
481:36 - void
481:37 - compressor band
481:38 - controls
481:40 - toggle all bands
481:42 - here is how this function is going to
481:44 - work we're going to use an array of
481:45 - pointers to all three band select
481:47 - buttons and we're going to loop through
481:49 - that array
481:50 - here's the logic we are going to
481:52 - implement
481:54 - if the global bypass button is clicked
481:56 - off meaning that everything
481:59 - is bypassed we need to set every band
482:02 - buttons on color to the bypass fill
482:05 - color and then we need to set every
482:07 - band's off color to the bypass color as
482:09 - well
482:11 - if the global bypass button is clicked
482:13 - on meaning nothing is bypassed we need
482:16 - to set every band buttons on color to
482:19 - the default fill color
482:21 - and we need to set every band's off
482:23 - color to black as this is the default
482:26 - off color
482:27 - when the band select button is bypassed
482:30 - and not the active band it will still
482:32 - display the correct fill color
482:35 - and finally we need to manually repaint
482:37 - after we change a button's color
482:40 - let's implement that now
482:42 - here's my
482:44 - here's my vector of buttons
482:47 - we're going to loop through each button
482:49 - we're going to set the color based on if
482:51 - we should be bypassed
482:53 - we're going to
482:54 - pull it from the bypass button if it
482:56 - should be bypassed
482:58 - and if not we're going to use our
482:59 - default gray color
483:00 - and then we are also going to set the
483:02 - off color
483:03 - if it should be bypassed we're going to
483:04 - use that on color again
483:06 - otherwise we're going to use black and
483:08 - then we're going to manually repaint
483:11 - okay
483:12 - very simple
483:13 - all right head back over to plugin
483:14 - plugineditor.cpp
483:17 - let's call our function now below this
483:20 - band controls dot
483:23 - toggle all bands and if it's if it's if
483:26 - everything should be enabled then it
483:28 - should not be bypassed so we're doing
483:30 - this again
483:32 - all right let's
483:33 - test it out
483:34 - all right
483:36 - all right awesome
483:40 - toggle them on and off okay very cool
483:42 - the next thing to do is to update the
483:45 - global bypass button if we manually
483:47 - bypass each button separately for
483:49 - example if i go
483:51 - low as bypassed mid button is bypassed
483:54 - high band is bypassed this should turn
483:56 - off
483:57 - and then likewise if we have all bands
484:00 - bypassed when the plug-in loads
484:02 - then the global bypass should also
484:04 - reflect this let's tackle that
484:07 - next
484:09 - all right the final task is to make the
484:12 - global bypass button reflect the bypass
484:14 - state of the bands if we toggle them
484:16 - manually we are going to use our timer
484:19 - callback to do this let's go look at
484:20 - that real quick
484:22 - all right
484:23 - we are going to declare a function to
484:25 - update the global bypass
484:27 - and then we're going to call it here and
484:28 - implement it next let's go to the header
484:30 - file plugin editor.h declare a private
484:33 - function void update global bypass
484:36 - button
484:38 - go to timer callback
484:40 - and we will call it after we update our
484:44 - analyzer
484:45 - all right
484:46 - it's gonna
484:48 - i'm gonna put it right below timer
484:50 - callback
484:51 - void
484:52 - simple editor
484:54 - update global bypass all right the logic
484:57 - here is pretty simple we need to get all
484:58 - the params all of the bypass parameters
485:01 - we need to figure out if all of them are
485:03 - set to true
485:04 - and then we set the global bypass
485:06 - buttons toggle state accordingly and we
485:09 - need to make sure that we don't send a
485:11 - notification when setting the toggle
485:13 - state
485:14 - if we were to send a notification it
485:16 - would trigger that on click lambda which
485:19 - is something we don't need to have
485:20 - happen because that's gonna fire all
485:23 - this stuff
485:24 - let's get all of our params
485:26 - auto params equals get bypass params
485:30 - we can use std all of
485:33 - to check if all of the params are true
485:35 - bool all bands
485:37 - are
485:38 - bypassed equals std
485:41 - all of
485:43 - params.begin
485:45 - params oops
485:47 - params.end
485:48 - and our predicate is a lambda i am the
485:51 - lambda lambda
485:52 - const auto param we want to see if the
485:55 - param is true or not so return param get
485:59 - finally now that we know whether or not
486:01 - all of the bands are bypassed we just
486:03 - need to set the toggle state so control
486:06 - bar
486:06 - dot
486:08 - global bypass button set toggle state
486:13 - and remember do not send that
486:14 - notification
486:15 - juice
486:17 - notification type don't send
486:19 - okay so remember
486:21 - if all of the bands are bypassed then
486:23 - the button should not appear as green
486:26 - if it only appears as green when the
486:29 - toggle state is off
486:31 - so this is most likely false which means
486:34 - all bands are bypassed which means our
486:36 - toggle stage should be false all right
486:38 - let's test this out here's what we're
486:40 - going to do we're going to enable all
486:41 - the bands
486:43 - we're going to manually bypass them one
486:45 - by one and see if that button switches
486:48 - all right
486:49 - let's turn this on
486:52 - turn this on
486:53 - and if we bypass this is this one going
486:55 - to change
486:57 - it does all right great and clicking it
486:59 - turns them all back off
487:01 - okay so the next test is if we do this
487:04 - if they're all on
487:06 - and then i turn off a band is this going
487:08 - to turn on
487:10 - yes it does
487:11 - awesome that works as expected
487:14 - now what happens if we close the gui
487:16 - when all bands are bypassed
487:20 - is this button going to be set correct
487:23 - let's save and quit
487:25 - and rerun
487:27 - and see what it does
487:30 - all right perfect
487:32 - that works as expected okay that wraps
487:34 - up the functionality for the plug-in for
487:37 - this tutorial the last thing that i want
487:40 - to do is customize some of these colors
487:42 - and show a few tricks that i use to do
487:45 - that
487:46 - let's make a commit of our work
487:49 - uh implemented global controls
487:51 - implemented
487:53 - global
487:54 - controls um let's go to our plug-in
487:57 - processor let's mark these guys off
488:00 - done and global bypass done our roadmap
488:04 - is now complete
488:06 - that is fantastic all right plug an
488:08 - editor here's our control bar here's
488:10 - where we did all this bypass stuff
488:12 - there's our editor
488:14 - here's all the
488:16 - bypass code that we
488:18 - implemented control band this is how we
488:20 - update the colors of the control band
488:23 - based on whether or not it should or
488:25 - should not be bypassed
488:27 - all right commit six files
488:30 - all right
488:31 - do color stuff next
488:35 - all right head over to look and feel i'm
488:37 - going to show you a trick that is going
488:39 - to help you dial in your colors the
488:41 - first thing is to declare a macro that
488:43 - toggles whether we use juice live
488:45 - constant or not
488:48 - put this
488:49 - right here
488:51 - define
488:53 - use live constant
488:56 - all right next i'm going to write a
488:57 - helper macro
488:59 - that will make use of this macro right
489:02 - here
489:03 - this macro doesn't do anything except
489:05 - return what was passed to it if the
489:07 - macro is true
489:09 - then the juice live constant editor is
489:11 - true otherwise this function just
489:13 - returns what was given to it the only
489:16 - downside here is that the juice live
489:18 - constant editor doesn't show the
489:20 - relevant code
489:21 - in the code snippet viewer and it
489:23 - triggers a jsert but
489:26 - who cares you know it's for what we
489:28 - needed to do
489:29 - it's awesome
489:31 - if use live constant
489:34 - we're gonna define a color helper
489:36 - function
489:38 - where we pass in c and
489:40 - we use juice live constant
489:43 - c like that
489:45 - else
489:47 - define
489:48 - color helper
489:52 - and if
489:53 - okay the next piece of the puzzle is to
489:56 - declare a namespace that holds all of
489:58 - the colors i plan on using
490:00 - and it wraps these colors and getter
490:02 - functions so i'm going to demonstrate
490:03 - one first
490:06 - all right in this function all i do
490:09 - is call the color helper function with
490:11 - whatever color i want
490:14 - so return color helper
490:16 - i'm going to go with blue for right now
490:20 - okay now i just need to replace whatever
490:21 - color i'm using when setting the
490:23 - slider's border with a call to this
490:26 - function instead
490:29 - let's go to lookingfield.cpp
490:33 - let's go find where that is drawn
490:36 - that's going to be drawn in the draw
490:38 - rotary slider
490:40 - at the top
490:42 - all right this is where i draw the
490:44 - border
490:46 - so i'm going to replace this line
490:49 - uh with a call to the um get slider
490:51 - border color g dot set color
490:54 - enabled
490:56 - if it's enabled use color scheme
490:59 - get slider border color
491:00 - otherwise do uh
491:02 - colors
491:04 - gray
491:05 - otherwise do this thing
491:09 - all right let's test it out and it will
491:12 - trigger a j assert but we can just
491:13 - continue past that it'll still work as
491:15 - expected
491:16 - oh um sorry let's do this in the
491:19 - standalone version
491:21 - and why is this showing an error
491:23 - redefinition
491:26 - i don't know why it's saying that
491:29 - all right here's that j assert i was
491:30 - talking about
491:32 - okay
491:32 - let's pull up our
491:35 - plugin here
491:38 - all right so you can click on this color
491:40 - right here and adjust all of the colors
491:43 - directly which is a great way
491:46 - to dial in
491:48 - um you know your colors in your gui
491:52 - once you find a color that you like
491:54 - oh that's a cool color
491:56 - um yeah copy the hexadecimal value
492:00 - and paste it where you were passing the
492:02 - default color to color helper that was
492:04 - over here in
492:06 - not look and feel
492:07 - that was over here in lookandfeel.h this
492:10 - color right here so i would just paste
492:12 - this instead and then wrap it in a juice
492:14 - color constructor
492:16 - juice color
492:17 - like that because there's a juice color
492:19 - constructor that takes a hexadecimal
492:22 - value
492:23 - all right let's do another let's do the
492:25 - module border
492:26 - all right let's go declare this function
492:30 - inline juice color
492:33 - get module
492:36 - color
492:38 - return color helper
492:41 - juice
492:42 - colors
492:43 - blue violet
492:46 - all right we're returning the color we
492:47 - want
492:49 - now let's use the function as needed in
492:52 - uh look and feel
492:54 - that'll go right here
492:57 - g dot set color
492:59 - if it's enabled use color scheme
493:04 - get slide uh get module border
493:08 - otherwise use dark gray
493:12 - and then let's
493:13 - head over to
493:15 - the draw module border color
493:18 - find that in utilities dot cpp
493:22 - there you go all right we need to
493:24 - include our look and feel so we can use
493:25 - the color scheme
493:28 - um look and feel
493:31 - all right
493:33 - and now we can set the color to the
493:35 - module border instead of that blue
493:37 - violet we can do
493:39 - color scheme
493:41 - get module border color
493:45 - all right let's run this it's going to j
493:46 - assert
493:49 - all right that's one
493:52 - there's the other
493:54 - all right let's find our plug-in window
493:57 - here we go so what's cool about this is
493:59 - we get two colors now
494:01 - so we can adjust all of these
494:04 - like that you can see how it's adjusting
494:05 - the fill color of the knobs as well as
494:07 - the um
494:08 - border color
494:10 - and then we can dial in this thing
494:17 - and again once we find a color that we
494:19 - like
494:21 - that's kind of cool
494:22 - once we find a color that we like we
494:24 - just copy the hexadecimal over to our um
494:30 - copy it over here and replace the colors
494:33 - all right so there you go that's a nice
494:35 - helpful tip for how to dial in the
494:36 - colors you know once you get this
494:38 - color set to what you want if you want
494:41 - this like red color or not so much this
494:42 - uh
494:43 - maybe you want this to be like an alpha
494:45 - color and you can do that too
494:47 - that looks kind of cool
494:50 - this pop out more
494:53 - once you get this color dialed in to
494:55 - what you want um just copy the
494:57 - hexadecimal and replace it in your color
494:59 - scheme helper
495:00 - and you'll have your colors dialed in
495:02 - so it's you know a pretty handy way if
495:04 - you don't have a graphic designer to
495:06 - provide you colors
495:07 - and like give you like a real fancy gui
495:10 - it's just one of those things that we
495:11 - can use to tweak our gui and make it um
495:14 - a bit easier to make changes in a
495:16 - dynamic way that are easy to update
495:19 - okay so i hope you found that tip useful
495:21 - um i've used it a few times and i think
495:23 - it's a pretty it's a pretty efficient
495:24 - way to dial in gooey colors all right
495:30 - all right so there you go that wraps up
495:32 - the tutorial
495:33 - i am going to dial in some more of these
495:35 - colors and tweak the gui a bit to my
495:37 - liking i'm going to encourage you to do
495:39 - the same you can check out the completed
495:41 - project at the link in the description
495:43 - and if you want to learn how to build
495:45 - the big brother of this plugin check out
495:47 - my course project 12 which is available
495:49 - at www.programming4
495:53 - you will be building it from
495:54 - instructions written in a jira board i
495:57 - will be reviewing your code every step
495:58 - of the way it is not a follow-along
496:01 - course like this video was you're going
496:03 - to be getting your hands dirty and
496:04 - figuring it all out for yourself alright
496:06 - thank you so much for watching and
496:08 - supporting this be sure to check out my
496:10 - youtube channel my instagram and my
496:12 - twitter accounts check the links in the
496:14 - description including me starting from
496:16 - scratch videos as well as simple eq and
496:18 - my other courses and as always if you
496:20 - get stuck or run into trouble while
496:23 - coding this or simple eq just grab one
496:25 - of my free products from
496:26 - programming4musicians.com
496:28 - and you can message me directly in the
496:30 - slack workspace and i will help you
496:32 - directly thank you for tuning in i hope
496:35 - you appreciated this tutorial and i hope
496:37 - you learned a lot from it i will see you
496:38 - in the next one

Cleaned transcript:

hey folks we are back again with another c plus plus audio tutorial today we are going to build this plugin from scratch using modern c plus and the juice framework check the description for links to the repository and to download the final build okay what is this thing this is the little brother of my new audio plugin and course for programming for musicians where you can learn to build these other plugins also where you can learn modern c plus and the juice framework taught from the context of writing audio software in a mentored environment in programming for musicians you are not following videos you are not watching someone else code and you are not copying them either you are coding it yourself from a design spec and i'm reviewing your work every step of the way alright enough about those let's learn about what we are going to build today this is a 3band compressor audio signal is split into three discrete bands and compression is applied to each band separately the bottom of the gui contains the controls for the selected band you'll find standard compressor controls here attack release threshold and ratio on the right side you'll find buttons to mute solo or bypass an individual audio band these buttons are helpful for dialing in an individual compressor or hearing how it is affecting the overall audio signal the band select buttons are on the left these control which compressor is being controlled remember we have three of them in the middle of the gui are the global controls you'll find input trim on the left crossover controls in the middle and output trim on the right crossover sliders control where the audio is split into the 3band the top portion of the gui features a spectrum analyzer which shows us what we are hearing where the crossovers are in the frequency spectrum and what our thresholds are set to as well as the current gain reduction per band at the very top of the gui you'll find the analyzer bypass button on the left this button turns off the fft analysis in the spectrum analyzer finally we have the global bypass button on the right which disables or enables all three compressors simultaneously we are going to learn to build all of the dsp that's going on in the background we are going to learn how to build this gui okay that's the feature set for this plugin and for this course my name is chuck i go by the name matcat music on youtube instagram and twitter once again check the description for links to the repository and where to download the final builds let's get started and write a multiband compressor using modern c plus plus and the juice framework from scratch welcome to this tutorial teaching the simple multiband compressor if you happen to get stuck during uh any part of the setup or in the actual tutorial itself grab any free product from programming for musicians you will be sent an invite link to a slack workspace where you can send me a message directly i will help you get unstuck we can work on error messages if you have setup issues that sort of thing all right on with the show hey folks welcome to this tutorial documenting how to build this threeband compressor before we start building anything we need to have a working development environment that is what we're going to do first i'm going to show how to do this for mac and then how to do this for windows here is what we are going to accomplish in this first part of the course we're going to install the ide which could be xcode or visual studio we're going to clone the juice framework we're going to build producer create a project and then create a repository for the project then we're going to build and run the standalone app version of the project then we're going to set up audio plug and host we're going to configure the ide to launch audio plug and host whenever we build and run the project then we're going to configure audio plugin host so it can load our plugin and set up a filter graph so audio will run through our plugin then we are going to set up an audio file player so that we can actually play audio files through our plugin then we are going to configure audio plugin host to use the audio file player plugin to send audio into our plugin and out to our sound card if you are a windows user you can skip ahead to the time stamp shown below for your steps all right let's begin the first thing we need is xcode now i have already downloaded and installed xcode but if you haven't there are two ways you can get it number one is to get it from the app store just go here and search xcode oops search here xcode this is going to get the version that is the most recent version that is available for most people to get if you have an older computer the other way you can do it is to grab a apple developer account these are free you only need to pay for the account if you are code signing okay so if you don't um if you're not planning on signing any of your binaries you can just go to developer.apple.com developer.apple.com uh sign up for a free account and then uh sign on in all right once you are signed on in go to downloads click on more and then search for xcode all right you will see all of the versions of xcode that have ever been released xcode 11 12 13 keep scrolling on down there's 11.7 there's 11.4 xcode 4.6.2 xcode 10 11. all that stuff so if you're running an older version of mac os and you cannot get um you cannot run xcode 12 or xcode13 this is what you can do we have successfully grabbed xcode and our next thing to do is to clone the juice repository navigate to juce github.comuce framework slash juc we are going to clone using fork which is a get gui you can grab that from https colon slash fork dot dev once you've got fork go ahead and launch it now we need to configure where fork looks for all of its repositories so go to the fork menu go to preferences and you're going to specify the default source folder in my case i am putting all of my code here in my users folder in a folder called programming okay once you've got that configured you can go back to we can close this we can go back to github we can copy this url right here click the green button for code um copy this url and then go to fork file clone it's going to automatically populate this url if it doesn't that's fine you can just paste it click clone now if fork if you're running an older version of mac os and it throws some kind of errors at you you need to install the swift runtime so again you can grab that you can grab that either you can grab that from the developer your developer account go to your account go to downloads search for more and swift somewhere in here is it here there it is swift's uh runtime support for command line tools this is what you need to install that will make fork run again this is only if you have an older version of mac juice has been around for like a decade or so i'm not quite sure how long um by default it checks out the master branch but the master branch there's quite a few commits that have happened between when the master branch was released and when the developer branch which contains the most recent fixes had its most recent commit push to it so we want to check out the develop branch so go ahead and double click on origin developer that'll check out a branch and now we've got the latest set of changes in producer all right our next step is to build producer which will create juice projects for us okay so just click open in finder your little button right there navigate to the juice extras folder the producer folder and the builds folder and then mac os x double click on the juicer file this is going to open up xcode if this is the first time launching xcode it may ask you to install it may ask you to install additional command line tools just click yes and then get it to this point all right i've already built this a few times because i was doing test runs in this video what we want to do is go to the product menu and choose build now we can watch what it's doing uh during the compilation process by clicking on this button right here of these buttons right here it's the rightmost one and just click on this and it will take us to this report showing us what is being compiled while it is being compiled we just need to wait for it to finish all right currently compiling gui basics linking signing there we go build succeeded all right we are done with xcode for right now go ahead and close the project all right navigate to the builds folder in the debug folder is where you will find the produced binary double click on this to launch producer producer is here now the first thing we need to do is turn on gpl mode if we go to file by default it might be on it may not be on choose sign in and select gpl mode now the next thing to do is to customize where the juice paths are because this was cloned to the to a location other than the users folder pro juicer is not going to be able to find the modules so go to the globalpaths menu choice under producer and we need to set our path to juice okay so that's over here and all we need to do is find our juice folder which in my case is in this programming directory matcap music programming there's the juice folder whoops mad cat music programming juice open all right now we need to do the same thing for the juice modules modules are found inside of the juice folder so we just need to navigate to that and then choose open again this is like programming juice modules okay once we've done that we're good to go here now we can create an audio plugin in the simple eq video there were a lot of comments of people who created an audio application we do not want an audio application we want to create a basic plugin okay the first thing to do is set the name we're going to do simple mb comp short for simple multiband compressor and click create project we just need to choose a valid place to save the project so i'm going to save it into my programming folder okay next we need to make sure that the plugin copy step is enabled so click on exporters click on debug and scroll down for the plugin copy step make sure it is enabled all right the next thing to do is to set the c plus plus version to c plus 17. click this little gear icon for project settings and scroll down to the bottom and then up a little bit we can change the c plus plus language standard here change it to c plus plus 17. finally let's set the company name that's up at the top i'm going to put matcat music llc when we scan for plugins in audio plug and host this is our plug this is how our plugin will show up it will show up under the name of whatever we put here all right now we can click save and open in ide let's create a repository next let's go over to fork in fork we're going to choose file create new local repository and then we just need to pick this directory notice that there are a ton of files that are unstaged okay we need to customize the git ignore file for this project and we're doing this because we don't want any of these files that producer automatically generates every time we save the project to be stored in the repository again they're autogenerated so there's no reason for us to keep track of how they changed okay so right click on one of these files i'm going to right click on this builds directory and choose ignore custom pattern now i'm going to type some stuff here the first thing i'm going to type is star star slash builds that's going to ignore everything in the builds directory next i'm going to just type star star whoops star star juice library code that's going to ignore everything in the juice library code folder and then because this is mac i'm going to type star star dot ds store that's going to ignore the ds store files which are generated by mac os every time you customize the view of a folder all right add to git ignore now we only have six files awesome we've got our four source folders and our ignore file and then the juicer file for the project now we can stage these by clicking this button right here to stage all and now we can make our initial commit initial commit all right every time we click save and open in ide it's not going to produce new changes it's only when we change source code that it will do that all right we can go back to producer and we can choose save and open in ide let's build and run the standalone app version first of all change the scheme right here to the standalone plugin and then click the play button to build and run all right we can watch the build happen again go to the report navigator click on the entry with the spinning wheel all right build succeeded we're waiting for it to run this is the default audio plugin that comes from producer running within a standalone plugin app it is our job to customize the dsp and the graphics but let's not get ahead of ourselves we need to set up a test bed that we can use to run audio through our plugin so let's set that up next go ahead and close this all right we can close this project as well close project if you uh were not aware i am doing this in a virtual machine that has nothing set up in it um that's just to show you if you've never done this before here's how you can get set up real quickly show me later never okay all right the first thing to do is to set up audio plug and host we need to navigate to that folder okay so users folder programming it's inside the juice folder it's under extras it's audio plugin host open up the juicer file save and open in ide and build it product build linking build succeeded okay close the project once building is complete we are going to configure our plugin project to launch audio plugandhost every time we use the vst3 scheme all right we can close this juicer file let's go back to our simple multiband compressor and open this up all right we can make this full screen now go to the xcode project we're going to edit the vst3 scheme okay click on this guy to select it and now edit the scheme all right we're going to change the executable from none to audio plugin host so choose other and we're going to search for audio plugin host there it is click choose now let's see close this now we just need to run this and that's going to launch audio plugin host well first it has to build the vst3 version linking build succeeded okay launching audio plugin host there's audio plugandhost yes you can use my microphone okay the first thing we need to do is configure audio plugin host to load our plugin go to the options menu and click edit the list of available plugins we're going to scan all right so choose options and scan for new or updated vst3 plugins that's fine there's our compressor right there simple mb comp okay we can close this window now that our plugin has been found we can load it into the filter graph so rightclick select it from the popup again this is where you set your company name and there's your compressor now if we double click this it looks the same as the standalone version cool let's wire it up to the output go like this click right there click right there and drag that okay right now any audio that our plugin produces will go to the sound card all right now we're not going to hear anything because there's nothing feeding audio into our plugin so let's do that next and then the other thing is if we go to options we can change our audio device settings again i'm running this in parallels so it's using a virtual machine and the virtual machine devices okay let's set up audio file player next we can save this and we want to save this into our we want to save this with our project so let's see where's my documents full not documents we want to save this with our programming programming simple multiband comp this is like um simple mb comp test testbed cool that'll work we can quit audio plugin host for now in the previous tutorial video that i created the simple eq tutorial i used apple's au audio file player let me show you what that looks like let me see if that's even on here hey i just wanted to interject i'm editing this video the next day the au audio file player does show up on a default installation of mac you just need to scan for audio units and it will be there so if i do that then i can scan and it'll show up under apple au audio file player there it is okay this is what i used in simple eq all right i just wanted to let you know that this stuff does come on here if you do have um a fresh install of the operating system you do not need garageband and you do not need logic to access this this comes with the operating system this time we're going to use the audio file player plugin that i created this plugin is a port of the juice audio playback demo app to work as an audio plugin the demo app if you're curious you can go to file open example audio audio playback demo and this is an actual audio application so what i have done is i have ported this into an actual plugin that you can use in your daw in audio plug and host on mac and windows to handle all of these playback duties so we need to go grab this let's close our project for now it's close we're not going to close that we need to go grab it so let's open up our browser we're going to navigate to github.com mathcat music slash audio file player this is what we need to clone so click on the code button copy it and then clone it in fork file clone paste that url and let's clone it all right successfully cloned now we need to compile it open in finder let's go to our audio file player audio file player.juicer save and open in ide it's going to launch xcode we just need to build it and it's going to build um all of these it's going to be able to the standalone version the vsd3 and the audio unit build all right cool once it's built um we should be able to launch audio plug and host and uh be good to go so close this project we can close audio let's not close it yet because we may need to um do it again let's open up our simple mb comp all right let's run it and now we are going to scan for audio file player all right options menu edit the list of available plugins options scan for new or updated vst3 scan there it is audio file player perfect close this window right click mat cat music my company name audio file player here's the audio file player double click it to view the gui now we just need to wire up the outputs of this uh to the inputs of our simple multiband compressor now let's just add an audio file we can either drag one in or select something from here and if it prompts you to grant permission uh to the desktop and the documents folder in the music folder just click accept that's all it's you know mac security stuff let's press play to hear the audio file awesome there we go let's push stop all right save the filter graph now audio plug and host is configured every time we run the vst 3 version of the project audio plugin host will launch and it will load our plugin and it will load this audio player let's go ahead and quit this and show what i mean we run this it's gonna launch there's our audio file player plugin and we can just stream audio right into the plugin all right perfect we are ready to start coding up this plugin mac users you can jump to the time stamp shown below to start the tutorial that actually codes up the plugin windows users we are going to cover setting up your system next all right windows users as a reminder i am using windows 10 inside of a virtual machine on my mac i am doing this to show uh how to get started using a relatively fresh and clean operating system installation and also because i love the pain of using windows 10 in a virtual machine sad face okay ah let's dive in the first thing we need to do is grab visual studio community from the website not visual studio code but visual studio we can get the community edition just go up here and just google for it visual studio community all right we want the 2019 community edition go ahead and download it once you have that then resume this video okay once you have the installer downloaded go here and run the installer and we need to configure it to build c plus plus apps if you already have visual studio installed but you're using it for javascript or c sharp or something else but you don't have c plus plus installed run the installer and set it up the way i'm about to show you once this thing launches in 10 minutes so we have this here uh visual studio community 2019 click the modify button and what we want to do is set it up for c plus development so go to here desktop development with c plus make sure that's enabled and what you want to configure um you're going to want clang tools you're going to want the address sanitizer you're going to want intellicode you uh we don't need live share we don't need test adapter for google tests we do not need boost.test we need a latest we need the latest v142 build tools we need we don't need cmake we need the profiling tools we need the just in time debugger we need this guy and we need this guy all right so set your thing up so that way it's got these and then um just click install while downloading all right once everything is installed you can quit visual studio the next step is to download the juice framework or sorry not download but clone the juice framework okay we always want to clone it so we have access to the repository history so the first thing we're going to do is we're going to use fork which is the get gui to interact with this repository so you can get that if you open your browser you can grab that from fork.dev it's available for mac and for windows okay so you can go ahead and grab it here download fork for windows okay once you've got fork installed we need to configure it to store everything um in our preferred location any repositories that it clones all that sort of thing launch fork go to the file menu go to preferences and we need to specify the default clone folder i like to keep things in a folder called programming i have it right here on my desktop you know i could move it somewhere else but for the sake of this tutorial it's right here on the desktop so i just navigate to that you know click this folder button find where i'm going to put it basically anything that i'm going to clone is going to go there so i'm going to put it on the desktop programming like that select folder okay now anything that i clone is going to go into that folder in its own repository now we need to navigate to the juice framework and get the url for that so open up your browser open up a new tab then visit com github.com juice dash framework work juce in all caps here's the juice framework now we need to click this code button right here click the copy button and go back to fork and now we can do file clone it's going to auto populate this repository url and it's going to save it into the programming folder that we requested click the clone button and you will be downloading a copy of the juice repository to your computer okay cloned alright perfect now we have a copy of juice on our computer the next thing to do is to build the producer which creates juice projects for us but before we do that juice is a pretty old framework by default the master branch or main branch is checked out however there have been several commits since the most recent branch oh spinning wheel a lot of things have been fixed in the juice framework since the master branch was last updated so we want to check out the develop branch okay so just double click right on origin slash develop and then it will prompt to create a branch and track the remote branch click the track button now we can open up producer and build it okay so click on this open in button right here and choose open in file explorer now we need to navigate to the extras pro juicer navigate to builds visual studio 2019 and then we're going to open up this solution file we can just go to the build menu and choose build solution this is going to build producer for us now we just need to wait for it to finish compiling all right build succeeded fantastic we can close the visual studio project now now we can create a plugin project next navigate to the x64 folder click on debug click on app and now we're looking for producer.exe there it is all right double click it to launch now if this is the first time you are using producer it's going to ask you to sign in we want to turn on gpl mode if this is not the first time you've probably already set it up but normally what you will see you'll go to the file menu you will choose sign in it'll show this thing you can if you have a juice account you can set that up or you can enable gpl mode now gpl mode has the requirement that we make our projects open source so uh yeah make your project open source okay in the simple eq project a lot of people left comments that they created an audio application or they were missing um they were missing the plugin processor file and that's because they created an audio application instead of a plugin instead of a basic plugin so for this you definitely want to make sure you are definitely going to want to make sure that you choose plugin category and that you choose basic all right first thing that we need to do we need to give it the name simple mbcomp and then create project oh i'm sorry before you do that if producer says you need to set your paths because you had downloaded juice to a directory that's not the standard directory it's expecting go here under the file menu go to global paths and then customize these paths here this is what i'm talking about when you install it to the default location it's expecting juice to go in a folder on the root level of your hard drive so obviously i put mine in this programming folder on the desktop so that is not where my juice folder is and that is not where the modules folder is so i'm going to click these three dots i'm going to choose the juice folder and then select folder and i'm going to do the same thing for the modules the modules folder select folder and i can close this window now all right now i can create this all right i want to put this in my programming folder with juice and the other stuff i've made this is going to create the project the next thing that we need to do is enable the plugin copy step this is going to copy the plugin when we compile it to the folder that most hosts you know reaper cubase ableton they're all looking for plugins in this one folder so this is going to enable copying it there automatically in this view click on exporters click on debug scroll down to the scroll down a little bit and you'll see where it says enable plugin copy step make sure this is set to enabled all right we'll figure out where this actually gets copied to in a little bit next we need to um change the c plus version so go up here go to let's see this is down at the bottom of this list okay scroll all the way to the end then scroll up a little bit and change the c plus plus language standard to c plus plus 17. all right next we want to supply our company name so let's do that first i'm going to type mine matcat music llc when we scan for the plugin in audio plugin host whatever we put here is the name that it's going to appear as it's going to show up as a sub menu under this name right here okay we may or may not need to set this using namespace juice so we'll come back to that first thing we're going to do is we're going to save and launch this save and open in ide this is going to launch visual studio we're going to find out whether or not we need to turn on that using namespace juice so go to the build menu and we're just going to try to build this real quick rebuild solution and if we get any errors about namespace stuff then we will turn that on let's see what happens okay cool all right so the copy step failed but we don't have any error messages relating to the namespace juice let's do the next thing which is to create a repository for our project first and then we will deal with this copy step all right we can close this for now okay to create a repository open fork and then do file init new repository and choose the simple mbcomp folder for the project now you'll notice that there are a ton of files here um listed under under local changes so we need to customize the get ignore file for this project and ignore all of this stuff the reason we are doing that is because all of this stuff gets created automatically by producer whenever we save and whenever we save and open in ide or when we compile like you'll see there's all these object files and stuff so we want to right click choose ignore custom pattern star star and for this we're going to type star star slash builds then and what this is going to do is it's going to ignore all of the files that are in the builds directory we want to do the same thing for juice library code so star star slash juice library code like that now if for some reason we want to migrate this project over to mac it's very handy to add star star slash dot ds store that's going to ignore any ds store files on mac these files control how the finders view looks basically if it's showing icons or if it's showing a list or if it's showing um if it's arranged by name or if it's arranged by day created that sort of stuff that information is stored in these ds store files okay add to git ignore you can see we only have the four source files our git ignore file and the juicer file now we can make our initial commit let's stage these by clicking the stage all button and now committing them initial commit now we can save and open in ide go ahead and go back to visual studio save and open in ide this will launch visual studio one more time okay on the right side is the solution explorer we want to right click on the standalone plugin and choose set as startup project okay now we can build and run it by clicking on this local windows debugger let's see if this throws an error with regard to the copy step or not it shouldn't because we're not spawning the copy stop version we're not spawning the vst3 this is the default audio plugin from producer okay it is running inside of a standalone app that is part of the juice framework that hosts this okay it is our job to customize the dsp that runs on our plugin as well as the graphics let's not get ahead of ourselves though we need to come up with a test bed so that we can actually run audio through our plugin that's what we're going to set up next all right close that close this let's go set up audio plugin host navigate to your juice directory navigate to extras navigate to audio plugin host navigate to the juicer file and open it up in producer save and open in ide build it build the solution okay build one succeeded zero failed awesome all right we're done with audio plug and host okay we can close the juicer file as well all right let's configure audio plugin host to launch whenever we have the vst3 as to startup project right click on the vst3 target go down to properties navigate to where it says debugging we're going to change this command so click on this arrow go to browse and we're going to look for audio plug and host all right got that build simple me comp navigate to the juice folder navigate to the extras folder audio plugin host builds visual studio 2019 x64 debug app and now audiopluginhost.exe click apply and okay now we need to change the target from standalone to vst3 change that to the startup project and now if we build and run it's going to fail on that copy step like we saw earlier let's do it anyway all right copy step failed it's trying to copy to common programs wherever this thing is okay so we what we need to do is change the permissions of this folder to allow the current user which is you know whoever we are logged in as we need to give them write permission to this folder so open up explorer this is located in the c drive program files common files this is where um x this is where visual studio is trying to copy this file to so right click create new create a folder call it vst3 and then the second part of this is to change the permissions so that the loggedin user can write to this folder because visual studio is being run under that user's settings okay so right click on this go to properties go to security click on edit to change the permissions and then we need to change the permissions for the user to be able to modify all right apply okay okay all right let's try this one more time let's see if it throws an error or not okay cool copy step completed if we go back over here let's see where was that let's just press stop real quick if we go to the build and scroll to the top we can see that one file was copied correctly all right let's go ahead and launch this now we need to scan for our plugin so choose options edit the list of available plugins and now this is where we need to scan all right so i've already done this scan before but i'm going to clear this list and now i'm going to scan for new or updated vst3 plugins right like i said it's looking for program files common files vst3 scan all right here's our plugin okay now we can load it into the filter graph right click go to your company name and here's your plugin if we double click on it it looks identical to the standalone version we saw earlier okay let's wire it up to the outputs just click and drag and we're not going to hear anything because there's nothing feeding audio into our plugin and thus going to the speakers let's fix that next go ahead and we can save this and add it to our repository choose file save and let's see let's add this to our repository desktop programming simple mbq and then we can say this is the um oh it's called simple mb comp filter graph now we'll get the extension save all right we can close that let's make a commit that we added this added filter graph go ahead and stage that commit that all right we are going to set up audio file player so that we can run audio files through our plugin go ahead and close this project okay in the previous tutorial video that i created i used apple's au audio file player to run audio files through the simple eq windows users did not have a plugin like that at their disposal and i saw a lot of comments in in the comments section of that video about that like people were just like hey what's the windows equivalent to this so this time we're going to use the audio file player plugin that i created this plugin is a port of the juice audio playback demo app it has been ported to work as a audio plugin so you can see that project if you want if you go to open example audio audio playback demo this is what this guy well we're not going to look at that right now but if you want to check it out just load that up um save it build it you know what to do because you know you've already done it a few times with producer and uh this project and with audio plugin host okay let's go get this thing all right open up your browser navigate to github dot com slash mat cat music slash audio let me spell that right audio file player okay now we want to grab the code from this copy we're done here in fork we want to clone all right it's already populated for us clone it all right let's open it in finder or in file explorer okay open up the juicer file save and open in ide now we just need to build it build solution this should also copy the vst3 to that folder let's see what it does may need to change the build target creating library one file copied okay that should be okay all right let's close this now we can go back to our project let's close audio file player the juicer file close that guy and we can also close this repository we don't need that anymore all right go back to our simple multiband comp let's load up xcode let's launch it and then we will configure audio plugin host to use it go ahead and run it now we need to scan for our plugins one more time because we just compiled the new one so go to the options menu edit the list of available plugins options scan for new or updated threes scan there is our audio file player so we can right click here mat cat music llc that's the name it's going to be under and then choose audio file player and here's our plugin all right this is what's going to play the files we just need to wire it up we've got our instance in the filter graph okay let's add an audio file um i've got one on the desktop it's this guy right here let's start that over all right perfect let's save the filter graph save all right we can close this what's great about this is that every time we launch this project it's going to load that audio file automatically for us we're not gonna have to you know go find the audio file every time we relaunch audio plugin host that's the problem that existed in the earlier version of this plugin that i had which i that plugin was just a bandaid fix when i first created this simple eq tutorial for the windows users because i didn't realize that they would have this problem i have since fixed that so that it now it now shows you it now remembers what file you had loaded so if we go ahead and launch this again there's our file and if we press play gonna work as expected so that's fantastic all right we'll put this guy over here audio plugin host is configured and um we have set up our project so that way every time we have the vst3 version set as the startup project it's going to launch audio plugin host and we'll have a real easy time of you know debugging our plugin and adding features to it and being able to run audio through it using audio plugin host now we are ready to start coding our plugin now we will be reusing and modifying some elements from the simple eq tutorial that i made for free code camp if you haven't completed that tutorial i recommend that you pause this video and start watching that one i'm not going to explain how the things we are reusing were created if you want that information you can watch that video where all that stuff is explained okay i will be explaining the modifications that we will be making to those classes though so with that said let's begin building this simple multiband compressor let's survey the lay of the land before we start writing any code also thanks to everybody who watched simple eq and said i looked like guilfoyle i had never heard of that show silicon valley before i started checking the comments for that video and that's good times okay number one there are several important parts to any audio plugin the first one is the dsp code itself this code is responsible for the actual audio that we hear we are responsible for making it fast and efficient number two is the audio parameters these control the various parts of the dsp code examples include the filter frequency or the pitch of a node being played by a synthesizer for example if we were writing a reverb plugin we might have a parameter that controls the reverb time in dsp programming it's all statebased programming we are constantly updating the state of our dsp based on math that modifies the audio signal in some way for example when we filter audio we keep track of the previously filtered samples these samples which are known as the previous filter output get added to the incoming samples after being scaled with some coefficient the newly filtered samples become the previous filter output for the next time that we process incoming samples number three preparing our dsp before we start processing anything with it before we can run audio through our dsp we need to configure some basic information about it the number of samples we're going to be processing the sample rate we will be processing those samples at and the number of channels we will be processing for example we might have a stereo feed which is two channels we might have a mono feed which is one channel or we might even have a dolby 5.1 which is six channels now if you are unfamiliar with the concept of sample rate there are numerous videos on youtube that explain how digital audio works let me grab my whiteboard so i'm reading my script over on this side so bear with me as a brief overview the audio we hear with our ears is an analog signal like this graph that i've got drawn here our eardrums detect changes in air pressure and they convert that change into an electrical signal which gets turned into sound by our brain this signal this graph that i've got right here this is a graph of the changes of the air pressure it is continuous if we uh take this signal right here if we were to continually zoom in on it like i've got down here on the bottom part if we continually zoom in on it it's always going to appear smooth okay now on computers that's not the case computers on the other hand operate using ones and zeros like i was saying computers operate on ones and zeros what this means is that the computer has to sample this smooth audio signal at a specific rate and produce an approximation of this smooth audio signal the more frequently that the signal is sampled the smoother the approximation becomes as an example let me use this blue color here if we sample at every tick like this blip blip blip and blip we are left with and also right there we are left with a wave form that looks like this if we sample at these tick marks we and we remove the continuous line we are left with this lollipop graph like this which has these little dots the more frequently that we sample the signal the smoother this approximation becomes as you can see right now it's not it's not a very good approximation of the original so let's sample it twice as often all right we'll sample here and here here and here that's going to give us a circle there circle there circle there circle there okay let's see the more frequently that the signal is sampled the smoother the approximation becomes this is the sample rate you know we can keep going we can keep bumping this up blip blip blip like that like that like that like that this is starting to look like the original waveform which is great which means like our approximation this digital approximation is much more accurate it's much more true to the original waveform okay this is the concept of sample rate the higher the sample rate the more frequently the signal is sampled now our ears they can hear up to around 20 000 hertz there's a theory called the nyquist theory that basically says that digital audio needs to be sampled at a rate of twice the highest frequency that you want to reproduce so this comes back to the way the waveform is shaped across the grid if i want to reproduce this pink line i can't sample it here and only there i need to have an intermediate point so that way um the full shape of the waveform is captured that's what the nyquist is talking about if i only capture here and here i'm gonna miss the fact that this actually goes up and goes back down that's the whole point behind the whole nyquist theory and whatnot so since we want to hear things up to about 20 kilohertz we need to sample that audio that 20 kilohertz um signal we need to sample that at 20 kilohertz times roughly 2. then this is where that sample rate of 44.1 kilohertz or 48 kilohertz comes in the sound card in the computer is converting 44 100 or 48 000 audio samples into an analog waveform literally an electric signal and it's sending that to the analog outputs every second you might have speakers or you might have headphones plugged into that analog output and this is where that analog signal goes and then the speakers themselves or the headphones might have an amplifier built into them that actually boosts this electrical signal that comes out of the analog output and then this boosted signal from the amplifier it is sent through some wires that wrap around a magnet that is attached to the speaker cone then the speaker cone vibrates when it gets that electrical signal goes like this which moves the air which our eardrums detect that change in pressure and then our brain translates that into sound that we hear okay now there is a ton of math and science behind these numbers of 44.1 kilohertz and 48 and like the way the ears work and the electrical signals and all that stuff we don't need to know any of that we just need to know that what sample rate means is it's like we have this we have this curved line which is continuous that's air pressure moving back and forth and we need to convert it into a digital signal that represents it and the more often we sample it the closer our representation will be now in the juice project there are two important functions that are always called the first one is called prepare to play let's go find the declaration of that that's right here i hope this font is big enough for those of you watching this on a tablet let's go look for the actual implementation of it also if you're using xcode or visual studio there are navigator things in the bars at the top which lets you jump directly to a function so you know learn to use those tools they're very handy the first one is called prepare to play and this is where we configure that basic information of our dsp code the sample rate the number of channels the size of the blocks and stuff the next one is called process block that's right here that's declared right here let's go to where that is over here okay this function process block brings us to our fourth important piece of the audio plugin processing audio samples at a regularly recurring interval using our dsp code this is what happens in the process block function now if you recall let's see let me hide that ring light that's in the back if you recall our sound card has to send 44 or 48 000 samples of audio to our speakers every second now internally let's pretend that this chunk right here on the bottom let's pretend this is 48 000 samples okay internally the sound card splits this into small chunks of samples called blocks or buffers so let me just draw what i mean by that okay so instead of sending let's just say this is zero and then this is 48 000. okay imagine there are 48 000 samples right here now internal as i said internally the sound card is going to split this into smaller chunks they're going to be called blocks and buffers now by doing this the sound card can lessen its burden of having to send this huge chunk of data to the speakers and to the amplifier and the digital audio converter all at once every second so instead of sending one big chunk of audio it can send lots of little ones such that the total number of samples per second ends up equaling the sample rate so for example it might say here's a chunk right here all right then here's the next chunk and then here's the next chunk and it's going to keep chunkifying this up into just these little blocks well that was terrible these little blocks like this until it gets the total number it needs to send per second if the buffer size was 512 samples let's pretend each of these is you know 512 samples and the sample rate is 48 000 then the sound card is going to send 48 000 divided by 512 buffers to the sound card every second or 93.75 buffers okay so obviously my picture is not totally accurate there should be 93 orange uh chunks right there okay now it's much easier to send 512 samples 93 times a second than it is to send samples one time per second and it's also easier to design hardware that can deal with 512 samples versus hardware that can handle 48 000 samples at a time okay so that's one of the things that goes into why we have these smaller chunks called blocks or buffers that are like 64 samples or whatever now this is how that idea affects our plugin and how we design our dsp code the process block function receives a buffer of samples whenever the sound card is ready for more audio to send to the speakers using a sample rate of 48 000 and a buffer size of 512 we know that the sound card is going to send audio to the speakers 93ish times per second or once every 10 milliseconds one 10ish milliseconds so that means that all the stuff that happens in our process block it needs to do whatever it's going to do in within those 10ish milliseconds the faster it does it the better however if the buffer size is even smaller maybe it's only 64 samples then our dsp code must be that much more efficient the sound card needs to send 48 000 samples to the speaker in blocks of 64 samples that means it needs to send 750 of these little blocks per second to the speaker that means it needs to send one block of 64 samples every 1.3333 milliseconds that's pretty fast we need to make sure that our dsp code runs as fast as possible as a result the sound card is not going to wait for us if we don't have that block that we were working on ready to go and this is what causes audio dropouts to happen the sound card will just send a block of silence to the speakers if the buffer it sent to our plugin wasn't processed in time so now you know what the process block function does and the constraints that exist for it audio dsp is a serial process there's a loop that is always sending a buffer of samples to our code and then our code in our process block runs from top to bottom and then the loop sends another buffer and there is no asynchronous coding happening here on the dsp side of things it's all happening in series which simplifies thinking about the code a bit this is also why i said earlier that dsp programming is all statebased programming we update the state every time the loop sends us a new buffer of samples to process and finally we have the gui which is the last piece of any audio plugin the gui is where we have all of the sliders all of the knobs all of the buttons that control the audio parameters which in turn control the dsp state it's important to design a gui that is very intuitive to use in terms of how this shows up in the code the plugin processor is where we handle the audio sides of things the dot plugin and cpp source files is where our gui is programmed while we are designing the audio parameters and the dsp for our plugin we will be using the generic audio processor editor instead of our own custom editor this class is really cool because it will automatically create all of the sliders knobs and buttons and combo boxes for every audio parameter that we declare this will allow us to dial in the dsp first and then add a pretty paint job later in the form of the gui now this is important because there are often times where we can't see the gui but the dsp code still runs for example the user might be using automation in their daw to control the audio parameters instead of the gui our gui always reflects the state of these parameters it's never the other way around the gui always shows the state of the audio parameters with this understanding let's switch to the generic audio processor editor so navigate to the create editor function in pluginprocessor.cpp create editor comment out this line that currently returns the custom editor we will develop later and change this to return the generic audio processor editor instead return new juice generic audio processor editor oh that's deprecated all right add the star all right let's run this and take a look at our gui don't forget our plugin will automatically show up because we already configured audio plugin host which is awesome it's this guy right here simple mb comp okay we don't have any audio parameters yet so the gui is not going to show anything we will add some audio parameters next let's talk about compressors and what they do now audio signals have different levels they can be loud they can be soft it could be a medium level there can be signals that can be too loud for a given system now when i say system i'm referring to the circuitry and the code that is either converting an analog signal into a digital one or converting a digital signal into an analog what this means is that the signal's amplitude can be greater than what the system can support let's use an example let's say that we have a sine wave that is represented digitally if we plot this wave on a graph that shows time on the xaxis and amplitude on the yaxis uh let's let's give it an amplitude with a range of negative 0.5 to positive 0.5 so we'll start here and we'll just go that high that high like that okay so let's just pretend this lines up with 0.5 and this lines up with negative 0.5 let's add some gain to this signal right we're going to boost it and by doing that we're going to double the signal okay so i'm going to turn up my volume knob crank it up it's going to double it add some more gain all right cool so now the wave has an amplitude of positive one to negative one that's the range of the signal so that's the range of the signal's amplitude okay let's add some more again some more we're going to double it again so now it goes from zero goes up to plus two let's see i'll use this red color hopefully this shows up i'm gonna add this guy right here we're gonna double it we go up to two our waveform has an amplitude of minus two to plus two what happens if we try to send this signal to our speakers through our sound card now the sound card can only handle signals between negative one and plus one let me use this green color i really hope this shows up now the sound card can only handle signals between negative one and plus one so the sound card is going to clamp any value that is outside of this range to this range so it's going to take this red signal and instead of it doing this instead of it doing that it's going to clamp it right across like that same for the top one it's just gonna go blip and right here it's gonna go blip just like that all right this is gonna turn it into a quasi square wave this doesn't sound good when that happens this form of signal clamping is a form of brick wall limiting this signal is hard limited to a specific range of values with no regard for what sort of distortion this will cause to the original signal by distortion i mean the fact that we had a nice smooth curve and now it's got like a square top and a square bottom it is no longer accurate to the original a compressor allows us to control the signal's amplitude in a musical way and in an automated way there are four parts to every compressor the two main parts are the threshold and the ratio so we're going to talk about our hypothetical signal for a little bit our signal is currently being clamped by the sound card whenever the absolute value of the signal is greater than one that's happening right here and then right here this plus one this absolute value plus one that is the threshold the threshold control tells the compressor whenever the absolute value of the incoming signal is greater than this threshold whenever it's greater than this apply gain to the signal it can be negative gain apply it to the signal so that the signal stays near or below this threshold now the next part is the ratio control the ratio control affects how much gain is actually applied to the signal is it is written as x colon y like this you've got x y so you could have three to one you could have ten to one you could have two point five to one like that okay these are the different ratios what they mean is that for every x decibels of input signal above the threshold the output signal will actually show y decibels of signal above the threshold so let's do an example to understand how this works because it's easier to think of this stuff in terms of decibels versus negative one and plus one normalized samples let's say that we have a signal that has a value of plus six decibels we can see that it goes over this threshold right here i've changed the scale on the side we still have zero plus one and minus one but you can think of zero as negative infinity because it means silence like the signal level in terms of decibels is infinitely small and then the plus one is the same as zero decibels below full scale and then any signal above that is reflected as a positive value okay let's say that our ratio is two to one and we're going to have a threshold of zero db okay now let's say that our signal is plus 6 db that means that our signal is 6 decibels above the threshold so let's plug the ratio into this line for every x db of input signal above the threshold the output will show y db of signal above the threshold so that means for every two decibels of input signal above the threshold the output will show one decibel of signal above the threshold so our signal is six decibels of the threshold so the output will actually only show three decibels of signal above the threshold that's going to look like this okay i should have probably used a different color but you get the idea this is plus six here this is plus three now let's try a different ratio like 10 to 1. what that means is that for every 10 decibels of input signal that is above the threshold the output will show only 1 db of signal above the threshold our output is 6 over the threshold so the output will only be 0.6 above the threshold which means our signal let me use a different color means our signal is actually going to look like this i think that math is right if it's 6 above the yeah 10 decibel 10 to 1 ratio so we're going to get a 0.6 out of it now we can continue to increase this ratio and get more and more reduction of the input signal however we can never make the output not produce a signal over the threshold unless we use an infinite ratio and that's what that brick wall limiting was that we saw before where the signal was just just chopped off that's where it just went like that and like that that's that brick wall limiter thing that i mentioned earlier that's using that same ratio of infinity to one okay so that covers threshold and ratio these are the two of the four parameters you can see them here we got threshold and ratio now clamping the audio like this doesn't sound musically pleasing furthermore going from clamping the signal to suddenly not clamping it doesn't sound good either and this brings us to the other two parameters the attack and the release the attack parameter controls how long to wait after the signal exceeds the threshold before gain reduction is applied the release parameter controls how long to wait once the signal stops exceeding the threshold before the gain reduction is no longer applied let me show you what that looks like on this graph all right we're back with our signal it goes from it's got a plus 6 db range on it uh the threshold is zero is still zero let's give it an attack time of one of these ticks right here so what that means if we draw a vertical line where this intersection happens let's just let's just pretend it happens right on this line right here that means that we're gonna wait until this tick to actually start compressing this signal okay so now i've got this orange line right here what this means is that it's not going to start applying compression until this point in time so this chunk of signal right here is not compressed it's going to go over the threshold and what is actually going to happen is we're going to apply the same rule right here of you know let's do two to one so this is you know let's say this is this looks like four so we're at four db so this is going to produce an output of two which means we're going to get something like this here we're going to see that okay so like i was saying we have this one intersection point what's going to happen is the signal is going to come to here it's going to rise the way it was normally going and then when it's going to hit that attack time let's say this is attack right there and this is going to go down like this and go like that so it's going to wait before gain reduction is applied based on however long this time is set to okay that's the attack time again the release parameter is going to control how long to wait once the signal stops exceeding the threshold before gain reduction is no longer applied so what that means on this side is that let's say the release time if we draw this line down here let's say this is our release right here just it's just one chunk of this right here so what that means is it's going to continue to apply gain reduction to this until we get to about there and then it'll drop across and how much gain reduction is applied depends on the ratio these two parameters the attack and release time allow us to smooth the transition between compressing the input signal and not compressing the input signal and then finally the threshold is always expressed in decibels and the attack and release times are expressed in milliseconds so the ratio is not expressed in any units even though conceptually we like to think of it as input decibels versus output decibels so with this knowledge in hand let's begin coding up some audio parameters to control our soon to be functional compressor one of the things we need to think about is synchronizing these audio parameters with our gui thankfully juice solves that for us with the audio processor value tree state class this class synchronizes our audio parameters with the host application that is loading our plugin and with our plugins gui we're going to need one of these in our audio processor it's going to need to be public so that the gui can attach all of its knobs and sliders and buttons etc to it now parameters must be declared when the plugin is created they cannot be dynamically created as such the apvts expects us to provide the list of parameters when it is constructed so we're going to need a function that will provide that list for us in the form of an audio processor value tree state parameter layout object let's head on over to our pluginprocessor.h let's go to the end of the public section right here and i'm going to use an alias using apbts equals juice audio processor value tree state now i'm going to declare this function first static ap oops um parameter layout create parameter layout all right now we can declare our ap vts give me the argument list all right we want this one all right we want to connect to this we're not going to use an undo manager we're just going to call it parameters and then the parameter layout will be provided by our create parameter layout function all right let's declare let's see i'm going to use my alias now a b v t s and then i got to use curly braces here instead of parentheses because it's initialization now we can go implement our uh the function that will provide the param the parameter layout let's go to the cpp file i'm going to put this all on one screen let me hide this uh hide this assistant guy all right i'm going to put this down in put this past the set state information put this right here first things first return type parameter layout and then the name of our class and the function all right first thing we need is uh the thing we're going to return lay out and we're going to return that all right we're going to be using the juice name space a lot i don't want to have to type it so we're going to use the using alias okay the first parameter we will create is the threshold parameter i'm going to set the range for the threshold to be between negative 60 and plus 12. i'm going to set the step size to one decibel meaning we can adjust the threshold in one decibel increments the skew parameter will be one now the skew parameter affects how this range of values from negative 60 to plus 12 is distributed across the slider that for the slider that's going to be attached to this parameter if you want to learn about this stuff i covered all of this in detail in the simple eq tutorial okay here we go layout.add we need to make a unique pointer all right we want to make a audio parameter float this one right here that guy off we're not going to use this my first parameter is going to be threshold parameter name is also threshold normalizable range we'll figure that out in a second all right we want to have a default value of zero decibels for our threshold let's define a normalizable range next normalizable range let's see which one do we want uh this one has start and interval and skew we'll use that one all right it's going to be a float type our range start is going to be negative 60 range end is positive 12. our interval value is 1 and our skew is 1. all right awesome next i'm going to dial in the attack and release i want to have a minimum attack and release time of 5 milliseconds so that means our compressor will always take at least 5 milliseconds to start compressing once the input signal goes over the threshold i'm going to set the max time to 500 milliseconds and i'm going to set the step size and the skew to 1. the slider controlling the attack and release will be linear just like the threshold slider let's do that next first let's define the range auto attack release range equals normalizable range this guy right here floats our range start is going to be five milliseconds like we said um then we're gonna have 500 as the end and then one and one for the skew and for the step size let's add an attack param and a release param layout.add make unique uh this is audio parameter float and oops i forgot this we want this one right here okay this is attack attack our normalizable range will be this thing our default value will be 50 milliseconds all right we can do the exact same thing for the release just need to change the name paste that there i'm going to change this release time to be 250 and we need to add the closing carrot to the template type and then let's change this to say release and let's line these guys up now finally we need to give ourselves some ratios a onetoone ratio results in no compression and a 100 to 1 ratio is basically brick wall limiting i'm going to use those values as like my start and end range and i'm going to add some values in between and since i don't want to use linear steps between 1 and 100 because that would just provide a huge list of ratios i'm going to use audio parameter choice and hard code the choices that i'm going to use okay the audio parameter choice constructor requires a string array of choices so i'm going to declare my choices first i'm going to convert them into strings and then i'm going to add them to the string array then i will create the parameter so here's my choices so i'm going to do i'm going to start at 1 1 2 3 4 5 with a 1.5 this is a pretty common um just you know very very light compression basically one two three four five six seven eight you know linear steps and then once we hit 10 i do 10 15 20 then 50 then 100. okay this 20 50 and 100 are all basically gonna sound the same they're just variously more aggressive forms of brick wall limiting now i can declare my string array and now i can use i can convert my choices into juice string objects now there's a string constructor that takes a um takes a double and we can specify how many decimal places get used so that's the one i want here double double value into number of decimal places i only want to display one decimal place so we're going to do that first and we're going to pass the choice to it that takes care of that now we can create the parameter and i do not want one to one to be the default ratio so i think three to one would be better so i'm going to use the index of this guy right here as the default value and remember that indexing starts with zero in c plus so we go like this layout dot add std make unique audio parameter choice all right this is going to be called ratio this is also ratio and my choices are the string array my default index is let's see this is zero one two three that guy right there all right like that and then we need our carrot all right there we go let's run it and we will see our sliders let's see what we got this should show us some sliders okay look at this we got our threshold guy right here we've got our attack time we have our release time and here we have our ratio awesome let's add saving and loading of the parameters next let's implement saving and loading of our plugin parameters state it's very easy to do because the plugin state is stored in the audio processor value tree states state member i'll show you what i'm talking about go over here let's go to where it's actually defined jump to definition way down here in the at the end of the public section there is a state member let's just look for that state right here yes it was at the bottom of this okay this is the public member the state okay this is the state of the whole processor all right let's go back to where we were plugin processor.cpp let's move to the get state information function it's very easy to implement saving and loading of our plugins parameter state and that's because the plugin state is stored in that state value tree okay now the value tree serializes to memory very easily we can use a memory output stream to handle the busy work which is needed to write the ap vts state to the memory block that this function has been given by the host it's this thing right here so all we have to do is create a memory stream juice memory output stream uh here's the block we're going to write to okay we're going to write to destination data um yes we can append because who knows if we're getting an empty one or a full one one that's empty or one that's already got a bunch of stuff in it let's give ourselves a member name a variable name and then we can just do apvcs dot state dot write to stream and then write it to our memory output stream all right wasn't that easy now we can do the reverse and restore our plugin state from memory using a value tree helper function the only thing we need to check for is whether or not the tree that was pulled from the uh chunk of memory we were given this stuff right here we just need to check if it's valid um before we copy it into our plugin state once we know that it's valid we can replace the plugin state appropriately here's the free function to use juice value tree read from data this is the one we want so we're going to pass the data we're going to pass its size in bytes this is going to give us back a value tree auto tree equals we just need to make sure it's valid if tree dot is valid if it's valid then we can replace it ap vts.replace state with our tree awesome let's test it out where did that go oh you're hiding okay we'll put you here all right i'm going to change the ratio from 3 to 10 then i'm going to save and quit and i'm going to rerun it the ratio should appear as 10. and there it is perfect all right cool let's add a compressor next and get it to modify some audio next if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming for musicians.com and you can message me directly in the slack workspace and i will help you directly juice has a generic compressor that we will be using for this project in order to access it we need to include the dsp module first before we can use it so let's go to our juicer file okay go to the modules section click on this plus icon right here add a module global juice modules path and choose the juice dsp class dsp module save and reopen all right now there it is now we can use the juice dsp classes let's go to the private section of our header file plugin processor let's declare an instance and then next we will prepare it in prepare to play so juice dsp compressor float compressor that was easy all right let's head over to the cpp file and prepare it go to plugin processor and go to prepare to play now we need to prepare our compressor we do this by passing a process spec object to the compressor we must first set up this spec object let's declare one juice dsp process spec give it the name spec first it needs to know the maximum number of samples that will be processed at any time so spec dot maximum block size equals this parameter here samples per block next it needs to know the number of channels this compressor can handle multiple channels we will use the number of output channels that our plugin can support as the number of channels to configure our compressor with spec dot num channels equals get total num output channels okay and now it finally it needs to know the sample rate which is this parameter here spec dot sample rate equals sample rate now we can pass it to our compressor which will prepare it compressor dot prepare spec next go to process block all right now we can start using our compressor to squish our audio the compressor wants a context to process and this context requires an audio block in order to be constructed so let's create an audio block out of the buffer that was provided to us let's get rid of this stuff right here and we're going to leave this code which clears channels that are not in the input okay so first let's declare an audio block juice dsp audio block and we want to use the one that takes a buffer as the constructor float pass it the buffer pass it this thing right here all right let's give it a name auto block equals whoops let's spell that right all right now that we've got our block we can create a context auto context equals juice dsp and here's where we want our context we're going to use a replacing context which means we're going to replace the audio in the buffer with our processed audio and we want the one that takes a block as its constructor argument float block now that we have our context we can process audio with our compressor compressor.process context let's run it everything should sound the same let's try it out and just to be sure that i've got some signal that stuff is actually happening i'm going to instantiate project 12. i'm going to feed project 12 with our output and this is just going to be over here so we can see what's going on okay let's play it we're going to run some sound through it all right now not doing anything to the sound and if we bypass this sound is the same all right so this is because we have not wired up any parameters to our compressor to adjust the threshold attack release and whatnot we've got our parameters here but they are not connected to the compressor that's actually doing signal processing let's do that next head on over to the header file plugin processor dot h okay now the apvts has a member function that returns pointers to the parameters that we created in the create parameter layout function it does not make sense to call this member function for every single parameter every time process block is called remember process block if our buffer size is small it could be being called 750 times a second so the cost of looking up those parameters could get expensive very quickly and this is one of those optimizations that we can do i know the rule don't prematurely optimize but this is one of the ones where it's okay to do it alright so let's create some member variables that will act as cached versions of our audio parameters for this compressor instance we're going to use the same types that we used when we created our parameters if we go over here go to our create parameter layout we used audio parameter float float float and audio parameter choice so we will create pointers to those okay so go to pluginprocessor.h and start declaring them here juice audio parameter oops let's spell that right parameter float make pointer attack initialize it okay we're going to do the same thing for the release and the threshold release threshold and then the ratio is a choice parameter juice audio parameter choice let's move over to the process block next and use these guys first before we set them up okay go to process block all right now here is how we use these guys first of all we need to use them we need to configure all this stuff before we start processing audio i'm going to do that before i create the block and the context okay here is how we use these parameters the float parameters have a get function that we can use and we just need to call the appropriate compressor function with this parameter value so we do compressor dot set and you can see we've got choices here attack release threshold ratio so let's start with the attack set attack and then we call attack param and just get the value let's do the same thing for the release and the threshold compressor dot set release release get compressor dot set threshold threshold get now for the ratio setting we need to extract the float value from the current ratio choice if you recall let's scroll down here if you recall uh the choices are stored in a string array all right so we need to get the float value of the current choice from the string and thankfully there is a helper function in the string class which does this for us and all we need to do is get the name of the current choice and then call that helper function so let's do that next we can do compressor dot set ratio and do the ratio parameter and we need to get the current choice name this guy right here returns a string and then we just need to call that string helper function get float value now before we actually test this we need to initialize our member variables so they aren't null let's go to the constructor to do that because if you remember when we declared these guys they're all currently null if we were to run this now we would get a big old crash all right so let's go on up to the constructor all right now as i said earlier there is a member function in the ap vts that allows us to retrieve pointers to parameters that we have added and all of these parameters are stored internally as ranged audio parameter this is the base class that all parameter types come from so we need to cast these parameters these ranged audio parameters to their correct type before we can assign them to the cached instances that we declared so let's do that we need let's do the attack parameter first let's do attack equals like i said we need to cast it to a juice audio parameter float and this is where we call apvts.getparameter and our name was attack okay now the getparameter function will return a nullpointer if the parameter name that we provided is not found in the list of parameters in case we type the parameter name incorrectly it's very useful if we assert when the parameter is null so this is going to help us catch any misspelled parameter names so we can do jsert attack is not a null pointer remember this function returns null if it doesn't find this parameter and if it does find this parameter then if this cast succeeds then the attack will not be null pointer if this cast fails like for instance let's say the attack was actually an integer audio parameter in or this cast would fail and we would have a null pointer here and we would hit a j assert so this is really handy so let's do that same thing for the uh two other float parameters just copy this we'll make this the release release and change this to release and then we can do threshold threshold threshold and threshold for the ratio we need to cast to audio parameter choice is this ratio ratio ratio choice audio parameter choice and ratio all right perfect let's compile it and run it and tweak some sliders we should hear some audible effects here's how we're gonna test this out okay change the ratio to like 50 to one and then we're going to set the threshold pretty low and then we're gonna start messing with the attack time so highly recommend get yourself some headphones to hear this all right let's run some audio through it though all right change that ratio to 50 drop that threshold down and we can really hear it clamping on that signal let's adjust this attack time so you can hear how the signal goes you can hear how the signal peeks through and then gets clamped down real quick that's that attack time the weight once the signal is past the threshold before it actually starts getting clamped we can hear if we change the change the ratio to something more subtle uh to a lower ratio we can hear that it's going to um it's not going to be as drastic of an effect so if we go back to 50 we can really hear it doing something major and then if we set that attack time as fast as possible we're not going to hear any attack at all because our ears just don't hear we just hear the audio getting really slammed okay if we set that release time really fast we're not going to hear so much oh we can start to hear a lot of distortion happening it's really smashing the signal all right let's bypass it see what's going on all right let's increase that release time all right cool so there we go our compressor is currently compressing all right let's find something else to do to make this turn this into a multiband compressor next all right cool let's add a bypass parameter it's much easier to click on this parameter than it is to rightclick on the plugin in the audio plugin hosts filter graph and toggle that menu option so let's head on over to the create parameter layout and add a bypass parameter stick this at the end layout dot add std make unique we want to add an audio parameter bool audio parameter bool this one right here all right this is called bypassed same name by passed and the default value is false meaning it is not bypassed that means it's active next let's declare a cached version of this plugin processor.h down to the bottom stick this guy right here juice audio parameter bool pointer bypassed nullpointer we can toggle whether or not our compressor processes the audio by setting the is bypassed flag on the context let's head on over to the plugin processor dot cpp go to process block and we can modify this context okay this is the simplest way to do this we can toggle whether or not our compressor processes the audio let's just actually go look at this okay if context is bypassed then just copy from the input to the output and get out of here okay otherwise do all this stuff which actually processes the code processes the audio samples all right this is the simplest way to toggle bypassing all we have to do is go context dot is bypassed equals our bypass parameter and get that value okay another option would be to write an if statement and wrap all of this stuff that creates um that creates the block and the context and does the processing in that but this is much much simpler to just do this okay so let's finally move to the constructor and initialize this param we will follow the same pattern as before initialize and then check it out all right we copied it let's change this to be bypassed and we want audio parameter bool and this is bypassed and then we just check it if it's null or not all right let's run and test it let's see what happens grab these headphones one more time all right there's our bypass parameter go ahead and start the music wow it's really slammed there we go bypass parameter is working as uh expected so this makes it much easier to compare the unprocessed and the processed audio so we can hear what our compressor is doing all right cool that was easy super easy we are trying to build a three band compressor what we have done so far is implemented the functionality of a single band so it makes sense for us to wrap this functionality into a class so it can be reused easily let's do that next let's declare a compressor band struct let's go to our plugin processor dot h and turn on the assistant editor actually before we do this let's make a commit let's go over here stage all this stuff i'll say implemented basic compressor functionality all right there's our juicer file filter graph yes we want that right we added our params and then here's where we initialized our params here's where we initialized our compressor here's where we processed our audio here's where we saved the uh here's where we're using the generic audio processor editor here's where we are saving and loading the state and then here's where we are creating our parameter layout all right as i was saying let's go to our header file go up to the top let's declare a compressor band struct let's add an instance of the compressor class to this and make it private now for the ease of initialization i'm going to make the audio parameters public in this class let's just go copy them from our audio processor copy these guys let's make them public next we are going to need some member functions that update the compressor settings that prepare the compressor and that also process audio through the compressor let's declare the prepare function first put that down here it's going to take a process spec object let's prepare our compressor with it now we can update our compressor settings by copying the code from the process block function that we had written earlier so let's do that let's just write this function right here void update compressor settings and then let's go to our process block that's right here and we're going to grab these things and just copy that right over like that okay the same goes for processing audio we are going to copy the code that we used here it's these guys and we just have to remember to pass in a buffer by reference since we will be modifying that buffer so let's declare that here void process juice audio buffer float reference buffer and now we need our block and our context we need to set the bypass state and then process boom now we can replace our compressor and the parameters in our audio processor with one instance of this compressor band class let's do that go way down to the bottom let's comment all of this out and change it to compressor band compressor like that now we need to do a bit of revision in the process block it's right here so let's take care of that it's coming out the old way of using the compressor to come with that stuff out now we just need to call the update function that updates the compressor compressor dot update settings and then pass our buffer directly to the compressor compressor dot process buffer okay the last thing we need to do is configure these parameters like we were doing but um we need to configure these in the constructor but for this object instead of these directly all right we just need to go up to here now we need to make these all say compressor dot attack that sort of thing so these cached parameters now live in the compressor band class so we just need to update these variable names here compressor dot attack like that ratio and bypassed okay let's test it everything should function exactly as it did a moment ago let's try it out all right i got my headphones all right um let's do a quick clean and rebuild just to make sure clean rebuild all right one more time all right that works as expected we can now start to think about how to ride a multiband compressor now that we have this building block of the compressor band all right let's make a commit now that we have our compressor banned um let's clean up this code let's get rid of this dead stuff too let's see it's gonna be in process block that's down here let's get rid of this okay let's make a commit added compressor band wrapper that's that that's that that's that guy that's that all right and our filter graph stage okay great let's figure out the roadmap for implementing the rest of the dsp in our plugin let's go to the top we'll put this at the top of the header file there's that file here we go at the very top but this below the fragment once okay road map number one is figure out how to split the audio into three bands figure out how to split the audio into three bands number two is going to be create parameters to control where this split happens number three we need to prove that splitting into three bands produces no audible audible artifacts okay number four we need to create audio parameters for the three compressor bands create audio parameters for the three compressor bands and these need to live on each band instance just like we currently have one compressor band which has the parameters as cached members okay number five we need to create the two remaining compressors create the two remaining not create we need to add the two add two remaining compressors because we already have one all right number six we need to add the ability to mute solo and bypass individual compressors add ability to mute solo bypass individual compressors number seven we need to add input and output gain because compression lowers the output level add input and output gain to offset uh changes in output level number eight we need to clean up anything that needs cleaning up clean up any um anything that needs cleaning up all right that will conclude the dsp side of the plugin dsp road map okay let's get started on the first one uh figuring out how to split the audio into three bands all right it's time to break out the white board okay let me erase this graph of how the sound card talks to the process block and the speakers okay sorry for the ring light okay here we go all right we learned in the simple eq project about low pass and high pass filters let's just draw what those are so say we've got um say we've got a filter spectrum like this um here's like here are the different frequency ranges this is like 20 hertz this is 20k all right low pass is eliminating all the frequencies above whatever the crop the threshold is let's say we got something like this so if i go let's say i want to eliminate all the frequencies below let's just call this 1k right here if i want to eliminate all the frequencies i would use a high cut filter which is going to cut out the high stuff and our frequency response will look like this likewise we can have a a low cut which is going to eliminate all of the frequencies below whatever our cutoff is set to let's set it to the same frequency so i will have a filter response like this all right so that's what we learned in simple eq the low pass and high pass or low cut and high cut however you want to think of it okay now if we duplicate our audio buffer we can filter the copies separately and if we set the cutoff of these two filters to the same frequency then we will get a frequency response like this where we have roughly flat except for right here now there's a special type of filter that we can use for the low pass and high pass filters that will actually produce a flat magnitude response when we sum the output of both of both of these filters this is the linquitz reilly filter let me write that here linkwitz riley filter oh geez that's like a terrible r there we go that looks like an r okay now these are known as audio crossover filters if you have a speaker that has multiple drivers in it it is using some kind of audio crossover to send part of the signal to each of the drivers separately for instance you might have a 10 inch woofer you might have a 5 inch midrange driver and you might have a two inch tweeter so let me show you um let me move this stuff over here and just draw a quick diagram of the speaker the speaker's crossovers might be set up so that the 10 inch woofer only covers frequencies below 100 hertz let me draw that on here so the uh speakers crossover filters may be set up such that the 10inch woofer only outputs uh audio that is below 100 hertz so that might be that's this guy right here this might only cover 100 hertz and below which means it's only covering this range like that the 5 inch driver might be set up to only output 100 to 5000 that might look like this let's see here's here's 5k right about there and that means the tweeter can only output stuff above well not can the tweeter may be set up so that it only outputs audio above 5000 hertz so this is 5 k plus that looks like this let me clean up this line right here because this one's bad okay now on a frequency plot we can see that this is a pretty even distribution the midrange is doing a decent amount the um little range is kind of handling there now why do we do this the reason is because it's pretty difficult to make a big heavy 10inch speaker move fast enough to produce frequencies above 5000 hertz right you got all that mass you're trying to move it at a really really fast frequency and it's really difficult it takes a lot of energy to do that likewise it's really difficult to make a small two inch speaker like this tweeter produce any kind of frequency below 100 hertz you know all of us are very familiar with listening to audio on our cell phones on the speakers that are built in and there's no bass whatsoever coming out of that tiny little speaker so some really smart people figured out that if we split the signal using these special filters these link with reilly filters we can have much better sounding music come out of our speakers when we dedicate each speaker to a specific frequency range all right now in the juice module there are link with reilly objects that we can use to split our audio into separate bands before we start using those however we need to start creating parameters that can control our filters and compressors so we're going to have a lot of parameters for these compressor bands so it makes sense now to refactor how our audio parameters are being created we don't want to have to type so much code since there will be a lot of repetitive code in the next few sections of this course okay let's get started creating a new approach to declaring our parameters the system we are going to create will let us easily look up the names of our parameters and not have to worry about misspelling anything either which is cool all right let's go to our header file first let's declare a namespace called params let's put this above compressor brand namespace params i am going to add an enumeration and this enumeration will represent all of the parameters that we are going to have in this project we are going to add to it as we add more dsp functionality and add more gui functionality as well for now here is the basic enum i'm going to call it names i'm going to add two entries for the crossover frequency parameter first low mid mid crossover freak and then mid high crossover freak and then i'm going to add entries for the threshold attack release and ratio for each of the three bands finally i am going to add an entry for the ability to bypass each of these bands bypassed band we'll do low mid and high all right now i'm going to create a map that will act as a lookup table for the string name of the parameters if you remember when we create our parameters let's go way down here when we create our parameters we pass a string in okay so we're going to pass in the name's enumeration value and that will give us back our string name that's how this map is going to work so this is going to eliminate the chance of misspelling anything and we'll be able to use autocomplete to choose items from the enumeration when we look up our parameter names as well which is cool so here we go inline const std map we're going to use our names enumeration paired with juice string and this function is going to return this map as a const reference i'm going to call it get params all right now this is what is known as a myers singleton pattern well it's kind of like meyer singleton it's more like a local function singleton pattern first we're going to declare a static map and we're just going to return that map map we'll call it params and we'll declare what it is in just a second and then we will return params okay so now we just need to um supply um pairs for the map so we just need to start declaring them so let's do the first one we're going to use this guy low mid high crossover and then i'm going to provide the name for what i want this parameter to actually be called low mid crossover freak when see i'll just do free so it's all within one line okay we just need to do this for all of these guys here so i'm going to copy this all right last is to add a oops we need to add commas at the end of all these there's our map now what is interesting about this pattern is that this static map that we've got right here it does not get created until we actually call this function so that's pretty handy okay let's update our existing parameters to use this map now so we need to change where the parameters are created and also where they are assigned to the current compressor band so let's do that first all right head on over to the create parameter layout function i'm going to switch from using um i'm going to get rid of the assistant editor all right head over to pluginprocessor.cpp and go to create parameter layout i'm gonna save myself a lot of time by adding the namespace alias right here not alias by using the using keyword and i'm going to get a local reference copy of the parameters map const auto params equals get params now i just need to replace all of these strings with the correct entry in the map and i'm going to set all these as though they were being assigned to the low compressor band so the first one becomes params.at names threshold low band let's do the same thing for the attack and the release and change this to attack low band attack low band and then for the release let's fix this indentation as well this is release low band next we need to do our ratio let's put these on separate lines copy these guys right here ratio low band and then finally the bypassed bypass low band bypass low band all right that was easy enough let's revise our um constructor where we initialize the cached parameters next head on up to the constructor we're going to do the same trick i used before of using the namespace and caching the sorry not caching but getting a local reference copy of the params map using namespace params const auto params equals get params if we look at our enumeration in the params class we have a lot of float parameters and the plan is to add solo and bypass functionality as well as mute which are boolean parameters and i don't want to have to keep typing this casting code more than i need to so let's write a helper function to do that let's go back to our constructor you can see what i'm talking about i don't want to have to write this line more than i need to okay so let's write a helper function we're going to use an in place lambda and i'm going to capture all the stuff that i use in the lambda by reference call this float helper auto float helper equals lambda lambda lambda all right we're going to need to capture the ap vts because we're using that to look up the parameters so actually let's do this let's um let's copy these lines into here and we'll adjust what we've got so we're going to change this to say param equals that and then we'll just say param is not an alternator no pointer param and then for this we wanted to say uh params at name like that or we can do program name okay so what do we need to capture let's capture apbts apvts equals this abvts we need to capture the params capture those guys capture these guys by reference now we need to pass in the parameter this thing right here so we'll just use auto and then we also need to pass in the param name autopram name all right cool unused variable let's use it now i'm using auto here because i want the compiler to figure it out and you can do that with lambdas which is pretty cool again all of these are being treated as though they are being attached to the low filter band the first one we're going to do is the attack param so do float helper and our parameter is compressor dot attack and then our parameter name is the names low band attack okay that takes care of this now we need to do the release param that takes care of this and now threshold that takes care of this now i just need one for the choice parameter and the boolean parameter and remember we're going to have three different choice parameters because we're going to have three different compressors with ratios and a boolean one for the bypassed mute and solo so it makes sense to just create it now so i'm just going to copy this and we're just changing with the cast we're just changing the cast that gets used really so this is going to be audio parameter bool uh not but we're doing choice first choice so this is the choice helper we can call it choice helper we got compressor dot ratio and our param name is names uh ratio low band all right that takes care of this guy and now let's add our uh boolean helper duplicate paste bool helper change the cast type and now we just call it bullhelper compressor.bypassed and we got names bypassed low band all right let's run it just to make sure everything works as expected all right my headphones we're going to adjust all the parameters and see if they work the way they should or if we get a js or false all right node.jser that's cool when you make big changes like this sometimes you need to recompile the code so let's do a you need to clean it out and recompile it from scratch so let's do that all right here we go change that to 50 drop that down all right that works for me save quit all right awesome all the controls are doing what they're supposed to be doing all right if you were curious as to why when we loaded this up our previous parameter settings were no longer found it's because we changed parameter names so they fell back to their default values okay onward let's make a commit of our changes let's see what we've done added road added road map and params namespace all right that's that and then we added where we use our params and all that good stuff okay now let's uh go to our roadmap let's tackle this guy right here figure out how to split the audio into three bands i had mentioned link with riley filters earlier now we're going to use them let's go look at the documentation for this class okay it says that um these are used in audio crossovers that have two outputs a low pass and a high pass such that there's some is equivalent to an all pass filter with a flat magnitude frequency response remember this it's they're talking about this like the response of the filter when you sum them together gives you a flat response okay they are saying that summing the output of two filters is identical to the same result you would get if you ran your audio through an all pass filter we are going to use that information later when we prove that the filters do not add any audible artifacts to the signal for now here is what we need to know we can split the audio into two bands using the juice linquit's reilly filters low band and high band once we do that we need to split one of these bands into two other bands that comes with its own set of problems that we need to deal with so for now let's just get a high band and a low band working first before we add a mid band okay so let's go down to our plugin processor dot h so we're going to go to our private section of plugin processor way down at the bottom we're going to do this after our compressor band let's declare two instances of this linquist reilly filter i'm going to use an alias to make typing it easier using filter equals juice dsp link widths riley come on auto complete filter float all right give me two instances filter low pass high pass all right we are also going to need a cached audio parameter for the crossover frequency juice audio parameter float low crossover little pointer all right each of these filters modifies the audio if we low pass our process block buffer then high pass filtering it will not give us the expected results here's my audio band okay we're doing low pass and high pass so if we low pass a bunch of signal like this this is what's left in the buffer okay this stuff right here this is what's left in the audio buffer right we originally had you know this was full spectrum and then you know we chopped out all of the high pass we did a low pass which kept all of the low frequency and everything above it got cut now if we try to high pass this at the same frequency you know we're trying to cut out everything below you know let's say this is our high pass that means we're trying to cut out everything below this point but there's nothing here this is all gone so the only thing we're gonna get left with is this chunk right here that's not what we want that is not the result that we want to have okay so what we need to do is use separate buffers and these are what we're going to sum later as the documentation said if you sum the results together you'll get a flat magnitude response all right let's declare an array of buffers std array juice audio whoops let's spell that right audio buffer float two of them filter buffers let's spell that right okay let's create a filter parameter next and then initialize it and then prepare our filters and buffers head over to pluginprocessor.cpp create parameter layout let's do this at the bottom after we make our bypass param layout.add here we want std make unique we want an audio parameter float all right we are going to set the crossover's range to be the auditory range of human here of human hearing 20 hertz to 20 000 hertz and we're going to set the default frequency to 500 okay so first things first let's provide our um our names so params.at names crossover low mid right copy that duplicate it let's give our default value of 500 and then we need a normalizable range normalizable range our range start will be 20 our range end will be 20 000. our interval value will be 1 meaning our value can change in increments of one hertz so 20 21 22 23 all the way to 20 000 and our skew will be one next let's initialize our parameter go on up to the constructor can use our helper for that float helper let's put this at the bottom float helper we are initializing our low crossover with the names low crossover awesome now we need to prepare our filters so go to prepare to play let's do this here lp dot prepare spec high pass dot prepare spec and now we need to prepare our buffers so that they don't allocate whenever we copy the input buffer into them let's do that next for auto buffer filter buffers buffer dot set size the number of channels is spec.num channels number of samples is samples per block all right let's go to process block now let's disable the uh compressor while we mess with these um while we mess with these filters for a little bit comment those guys out first let's copy our incoming buffer into these dedicated filter buffers for auto filter buffer filter buffers fb equals buffer each buffer in our filter buffers array now contains a copy of the input of the buffer that we were given from the sound card all right next we will update our filters cut offs both of the filters are going to share the same cut off so auto cut off equals low crossover get now we can do lp dot set cutoff cut off then hp dot set cutoff cut off now we must create blocks and contexts for the filters all right so we do auto fb0 block filter buffer zero block equals okay so we've got one audio block pointing to the first filter buffer and then another audio block pointing to the second filter buffer now we can create our context all right just initialize each context from the appropriate filter block and now we can process our audio lp dot process lp gets the first filter buffer of the two fb0 context hp dot process fb1 dot context oops no dot okay now that our input buffer has been turned into two separate buffers each of which has been filtered separately we need to sum them back into a single buffer now in order to ease some of this struggle with copying let's cache some of the details of the input buffer so auto num samples equals buffer dot get num samples auto num channels equals buffer.get whoops let's spell that right getting them channels and we need to clear our input before we start um adding our filter buffers to it so buffer dot clear okay each channel of our filter buffer needs to be copied back to the input buffer so i'm going to write a helper function to do that i'm going to use a use a lambda in here to do it auto add filter band equals lambda lambda lambda first thing let's see first thing we're going to do is create a parameter for our input and then a parameter for the source that we're going to copy from so here's our input buffer input buffer and then where we're going to copy from so const auto source all right now we just need to simply loop through all of the channels that were in the input buffer and copy from a source buffer into that so we can do 4 auto i equals 0. i is less than num channels is what we want so let's capture that by copy num channels eyes let's numb channels plus plus i now we can do input buffer dot add from and let's see what are our parameters let's see buffer dot add from let's do this okay our destination channel is going to be i our destination start sample is going to be 0. so let's just do this we're going to do i we're going to do 0 our source is going to be the source source channel is going to be i star source start sample is going to be 0 and then our num samples is going to be um this because buffer and the source have the same number of channels so we'll just call that ns all right this is what we add here like that all right and we need to capture n s n s equals num samples okay and just to go over that so we are capturing our num channels and num samples we are passing in this guy we're going to pass it in as a parameter and we're going to copy every single channel from the source one at a time and add it to our input buffer now we just need to call this helper function with our filter buffers add filter band our input buffer is buffer and our source is filter buffers zero add filter band buffer filter buffers second one all right perfect let's run this and see what happens grab my headphones all right okay all the top end is gone let's go figure out why that happened let's go look at how this class gets uh created all right we have a type parameter sets the filter type well we didn't do that let's see what type this thing defaults to all right default filter type low pass so that makes sense we're basically running our audio uh this is low passing it and then this is also low passing it at the same frequency let's solve that we need to call that set um set type function let's do that in the constructor going up to the constructor all right go down to the bottom let's configure our filters lp dot set type here we go juice dsp link what's riley filter all right now our lp is low pass and then let's do it again for the high pass this is hp and this is high pass all right let's test this again now remember we don't have our compressors turned on so we're literally just going to hear this filtering the result of our audio going through the lp and the hp filters here we go all right no audible um no audible effects to me if we adjust the slider which is adjusting the crossover nothing no audible effects so that's fantastic all right perfect we are halfway through splitting the audio into three bands before we go further let's prove that our filters are producing no audible artifacts we will also demo that the filters are actually doing something by soloing each one we'll do all that stuff next let's make a commit of our progress it's always a good idea to do that what did we do we added link with riley filtering here's what we did all the processing here's where we set up our filters that's where we prepared them here's what we processed with them here's where we created the parameter let's go back here let's save and quit this okay we can bypass the filtering by exiting the process block before we clear our input buffer and copy our filter buffers to it it's just temporary but we can use our single compressor's bypass parameter to control this alright the purpose is just to show that the filters don't introduce any audible effects when the buffer copy step is bypassed we are listening to the input buffer still and when it's not bypassed we are listening to the sum of the filter buffers being copied into the input buffer so this is very easy to write we just need to do it after this num channel so we can just say if compressor dot bypassed if it's bypassed um don't clear just leave the function right we've done our filtering but we're not clearing our buffer and we're not copying stuff into it okay okay here is how we can prove that this is actually what is happening let's run this okay first things first make sure this bypass low band is toggled on next let's add a breakpoint right on buffer.clear now if we press play notice that the breakpoint does not get hit and it's not until we uncheck the toggle button that it actually gets hit and this is going to cause like some weird audio stuff but you know just bear with me okay here we go gonna unbypass this all right hit the breakpoint so let's remove the breakpoint all right now we can stop our audio okay but that proves uh the point i try i was trying to make that our audio is actually running through our filters and we can hear the difference between if it's um between if we're hearing just like the raw buffer input or if we're hearing our filtered input okay all right let's talk about this crossover filter and one of the special properties of it when you have a pair of these filters like we have here and you sum their output like we are doing here the result is the same as though you had run your signal through an all pass filter with the same cutoff frequency i want to show you what i mean by that so let's add an all pass filter and then demonstrate toggling it with our lp and hp filters so we can see how they sound the same okay let's go to our header file let's go down here to our filter let's add another filter filter ap like that for all pass filter and now it needs its own buffer so let's give it one of those juice audio buffer float ap buffer all right we will prepare it and set the type next let's go to the prepare to play function prepare to play let's do ap dot prepare spec all right let's uh set the buffer size ap buffer dot set size spec.num channels samples per block all right let's go set the type in our constructor we learned our lesson from the first time we messed with these filters and we're going to make sure we're going to set that type now ap dot set type whoops set type juice dsp let me just copy this all pass next we will make our process block toggle between our low pass and high pass doing the filtering versus our all pass doing the filtering and we're going to use that bypass parameter like we used earlier because it's you know it gives us a toggle button that we can just easily click on and off okay let's go do that next alright let's go to our process block let's get rid of this bypass code let's just comment it out for now now we can copy our input buffer to our all pass buffer ap buffer equals in uh buffer okay we got to make sure we do that before we clear all right let's do the same processing you know we're going to create a block and a context and then process with the filter so i'll just grab these two lines right here and i will just rename them this is ap block and then this will be ap block this is going to be ap buffer and then this will just call this a all pass context and let's do our processing ap dot process ap context all right now we can revise our logic that does the copying if the bypass toggle is unchecked use the low pass and high pass buffers otherwise use the all pass buffer so if compressor bypassed get if that toggle button is unchecked use these guys otherwise add filter band buffer from the ap buffer this logic will let us hear the lp and hp buffers by default we already know that they don't add audible artifacts and toggling this checkbox will show that the ap buffer produces the same result so let's test this out we're going to just run this we're going to toggle the thing on and on on and off let's grab our headphones all right so let's play it turn this down so if i toggle this all right let's push stop real quick now we can confirm that it's working by making sure bypass is unchecked and then setting a breakpoint in the else block let's press start once we click that check box the break point will be hit perfect this is expected show all the dewey okay so that works as expected so let's investigate soloing the low and the high bands next okay our compressors will be able to compress either band so it's important to know what these bans sound like let's check that out next all right soloing one of these bands is really easy we just need to comment out which buffer gets added to the input so let's solo the low pass output by commenting out the second line all right we can toggle between hearing the all pass filter and the low pass filter using our check box let's run this oh you know what we can adjust this there it goes i was wondering why i wasn't doing anything because i had this this cutoff way up high all right so right now we're listening to the low filter uh the low pass band now we're listening to the all pass all right cool save that quit all right let's do it again and switch to the high pass okay so uncomment this one all right sorry comment the first one out and then uncomment the second one let's run and test all right we'll drag the same crossover slider again so we can change how much bottom end is actually cut out of the signal all right all right so there you go so that is how soloing and the muting of the bands works okay it's all about figuring out which buffer you want to copy to the input all right so we're going to do one more little test with these audio filters next okay the final test that we will do is to sum the inverse of the all pass filter with the output of the low pass and high pass filter the purpose of this is to show how the two outputs sum to zero or silence again we will be using the bypass switch to toggle between this behavior versus hearing the output of the low pass and high pass filters so let's comment out this code actually let's copy this first because we're gonna need this let's copy this now we can comment this out all right now paste this here okay we are going to always copy the output of the filters into our m into those buffer that we were given by the audio audio system okay now if the bypass switch is turned on we will invert the all pass filter buffer and add that to the output we can do that by going if compressor dot bypassed get if the switch is toggled on then we need to invert every channel in our all pass buffer and then add that to the filter band so let's let's set up the add band first add filter band buffer we're copying from the all pass buffer okay and now we just need to invert so let's do this for every channel and we can do this using float vector operations so four auto ch equals zero ch is less than num channels plus plus ch now we can do juice float vector operations and there's a there's a way that we can multiply a fixed value against every sample in a particular channel so we're going to use that multiply and we want the one that takes a multiplier okay our destination is going to be a right pointer to one of the channels in the ap buffer so ap buffer dot get right pointer because we want to be able to modify this buffer that's why um our channel number is ch our multiplier will be negative one to flip it upside down and we're going to do this for every sample so num samples all right now that they are inverted um we already we're already adding them over okay so now the next thing to do and this is actually something we forgot to do earlier um is to go up to where we are setting our cutoffs and we need to set the all pass filter to that have the same cutoff as the other filters we forgot to do this earlier so when we were dragging the slider back and forth yeah just a fluke that um it didn't sound audibly different to me let's go to the last step we can test this out now and if it works as expected we will hear silence when we toggle the bypass switch let's check it out all right silence there we go and if we adjust the frequency silence all right awesome so that is doing what it is supposed to do okay let's learn a little bit more theory about this whole lp plus hp versus the all pass filtering and how we can use this to make three separate audio bands that some to produce a signal with no audible artifacts once we have this knowledge we will implement it and check off item one in the dsp roadmap let's make a commit of our progress from uh working on this filter stuff before we start diving into filter band theory all right what did we do oh we have to fill the graph okay we um uh tested using all paths filter that's basically what we did we got our filter here and our filter buffer here's where we set up the filter type here's where we prepared it here's where we set the cut off here's where we did our processing and then here's where we did the inversion to basically cancel out the regular filtering that's what's going on there all right all right let's talk about filter band theory all right let's discuss some theory behind these filters before we create the three band splitter filters work by delaying part of the signal let me get this more on camera we've got a pair of filters here a pair of linguists riley filters we got low pass one and high pass one okay every time we filter the signal we introduce a delay now i don't know how the math of this delay actually works and that's beyond the scope of this video that's what they end up doing in the math is they apply delays to certain frequencies in the spectrum and that's how you end up getting that stuff to be muted so when we split the signal into low pass and high pass bands we are introducing the same delay so to speak to both parts and then when we run the signal through an all passed filter the same delay is produced of course that's assuming the all pass filter the low pass and the high pass all have the same cutoff frequency so that means that we can use an allpass filter to equate this same delay okay so whenever we have a pair of these we can replicate that same delay by using an allpass filter okay now we can use this to our benefit we can split our signal into two bands like we're currently doing and this split will just add one delay to the signal you know delay so to speak okay if we then split one of these bands into another delay we will end up with three bands let me show you what i mean all right so check it out we've got our three bands here this band this band and this band okay that's what we're trying to accomplish three bands however the problem is that lp1's output the signal that runs through this chain only has one delay whereas the signal that is split from high pass one this guy and this guy there are two delays and that means that our signals will not sum correctly okay now as we learned earlier the all pass filter introduces the same delay as this so all we need to do is replace this line you just we just need to add an all pass filter here set to the same cutoff frequency as these two filters and we will have a um we'll have our solution so this is the solution that we need to use okay we just run lp1 through an all pass filter and that gives us an output that has the same number of delays as the other uh signals over here okay so the low pass one to all pass two contains all of the audio be low filter cut off zero and then the uh high pass one to low pass two contains all of the audio between filter cutoff 1 and filter cutoff 0 this range right here and then high pass 1 into high pass 2 contains all of the audio at filter cut off 1. all right so there we go three bands that sum to a flat filter response okay and we can prove that this null's out by creating two more all pass filters set to filter cut off zero and filter cut off one and inverting their output and then summing it with the output of these three bands okay all right in project 12 you will learn how to dynamically create uh n number of bands you'll learn how to figure out okay if i have seven bands how many allpass filters do i need how many lowpass filters do i need how many highpass filters do i need and um how do i structure them so that way it can all sum together and can all do everything that it's supposed to do my computer can handle about eight filter bands when i'm in debug mode maybe yours can handle more than that but it's a really really interesting problem to solve and is very cool so let's code that up next and begin filtering let's restructure our filtering i find that it helps to declare them visually in the same way that they will be structured i'm also going to write the name of the cutoff parameter that will control that particular group of filters above that filter itself so let's get rid of our old filters and the buffers and stuff and start writing this first all right here we go so filter uh we've got an lp1 and an ap2 all right that's part one we've got hp1 and that feeds into lp2 and then we've got our hp2 on the bottom so that guy let's add these cutoffs next here we've got our fc0 filter cutoff 0 and filter cutoff 1. let's rename this crossover and add another one for the mid high right click refactor rename i'm going to call this the low mid crossover all right let's duplicate this this is going to be the midhigh crossover mid high crossover finally we can give ourselves a third filter buffer because we have three bands let's add another parameter for the midhigh crossover then we will set our filter types and then prepare our filters and then use our filters head over to pluginprocessor.cpp go down to create parameter layout go all the way to the end where we create the low mid crossover copy and paste it and change this to the mid high crossover frequency all right now while we are here i'm going to change the range of the crossovers so they do not overlap so this first one is going to go from 20 hertz to 999 hertz i'm going to change the default to 400 and then for the second one it's going to have a range of 1000 to 20 000 hertz and the default value will be 2 000 hertz all right let us set our filter types next and then initialize our cached crossover variables head up to the constructor all right let's go to let's do our cached value first so float helper we're doing the mid high crossover names mid high now let's tackle these errors we just need to rename these types so it's lp1 now and hp1 and then it's ap2 and then this just needs to be duplicated for lp2 and hp2 alright cool let us go prepare these next head over to prepare to play again renaming the old filters this is lp1 this is hp1 and this is ap2 and just copy these and rename we've got lp2 and hp2 all right we don't have an all pass buffer anymore so this line gets removed all right let's configure some 3band filtering next over to process block the first thing to do is to configure the filter cutoffs so the low mid cutoff is applied to lp1 and hp1 all right let's rename this parameter as well refactor rename and this is low mid cutoff the mid high cutoff is applied to lp2 hp2 and ap2 so let's get that value next auto mid high cutoff freq equals mid high crossover get and then this is ap2 ap2 gets the mid high cutoff and then let's copy these guys and this is lp2 hp2 and they also get the midhigh cutoff the next thing to do is to create audio blocks and contexts for each filter buffer now there is a dry way to do this but if you want to know how to do that you need to take project 12 because project 12 covers all that in this video we are going to hard code it so the first thing we need to do is let's add a block for our third filter buffer so copy and paste this fb2 block goes to filter buffers2 let's add a context for it copy this line fb2 context goes to fb2 block and now we need to run the appropriate context through the appropriate filters lp1 and ap2 get the first filter buffer ap2.process fb0 context next hp1 and lp2 get the second buffer but here's the thing we need to know let's come back to my chart here okay the thing to know and i've written the names of like which filters go with which brands the thing to know about this is that hp2 needs the result of hp1 so we have to filter this first we have to filter hp1 first and then copy it to the second filter buffer before we can run it through hp2 okay that's the only gotcha that's going on here all right it's okay so currently in our code we've got lp1 and ap2 processing the first filter buffer that's this line right here okay now what we need to do is process hp1 into filter buffer one and then we can copy it to filter buffer two and run it through here and then run lp 2 through filter buffer one so we've got filter buffer 0 filter buffer 1 filter buffer 2. alright let's do that let's turn that concept into code all right let's see hp1 processes filter buffer context 1. then we copy the output of filter buffer 1 into filter buffer 2. filter buffers 2 equals filter buffers 1. all right now we can process lp2 that gets fb1 context and then hp2 can process filter buffer 2. filter buffer two okay this is very important now our audio has been filtered into three bands and now we need to sum it back let's get rid of this um code right here the ap buffer stuff because we don't have that anymore and let's get rid of this stuff here as well let's just clean this up now i want to make the bypass act as a toggle like we did earlier so we will just exit before we clear we'll go like that okay i am going to comment out all of this all pass invert code because i do want to come back to it in a little bit but for now we just need to add the third band and i am not going to use a loop for this even though this is pretty repetitive and that is because i eventually want to have the ability to mute and solo and bypass individual bands and that is accomplished by not adding a filter buffer to the input buffer and writing a loop right now would make that you know we'd have to revise it later which is annoying so for now we'll just leave it uh we'll just manually add each one like that okay let us go test this out we're gonna toggle the bypass we're gonna drag the sliders all that good stuff all right let's test this out adjust the sliders toggle the bypass that sounds good to me i'm not hearing any of that phasing that's fantastic all right now we can confirm that this is working by toggling the bypass checkbox and then adding a breakpoint anywhere after that bypass param check so i'm going to add it on buffer.clear and let's push play and then once we unbypass our breakpoint will be hit yep all right so it works as expected okay the last test i want to do is the null test with the inverted all pass filters we will do that next all right let's close this guy save quit go to pluginprocessor.h okay i showed earlier how a single inverted allpass filter will know the output of a pair of lowpass highpass filters when they are all tuned to the same cutoff frequency and you multiply the output of the all pass filter by negative one i'm going to show that the same thing is true here with these three bands each stage in the filtering acts as a delay that's this stuff right here the lp1 and the hp1 that's stage one and each delay can be nulled out with an allpass filter set to the same cutoff of that stage so we've got two stages so we need two allpass filters let's add them here filter inv ap1 i inv ap2 all right now we are going to need one buffer for the all pass filtering since they are processed in series juice audio buffer float in ap buffer next we need to set their types then we need to prepare them and then we need to process audio with them head to the constructor in pluginprocessor.cpp let's go down here let's do this at the bottom all right let's just copy uh copy this all past two dot set type let's put this at the bottom all right we're gonna call this inv ab2 and invap1 go to prepare to play and prepare them as well as the buffer let's just copy this paste paste inv all right and let's prepare the buffer in ap buffer dot set size spec.num channels samples per block let's filter and invert some audio next go to process block all right we're going to do this after we do our initial set of copying first we will copy the input buffer into the buffer that we will be processing in ap buffer equals buffer next we'll set the first inverted all pass filter to have the same cutoff as lp1 and hp1 then we will set the second all pass filter to have the same cutoff as the second stage now we need to make our block and context to filter our all pass buffer with our filters i'm just going to copy this and duplicate that let me do that after we process this guy i'll put that right here this is in ap block and we will use in ap buffer and then here's in ap context ctx and this is fed by end ap block all right now we just need to process it in ap one dot process apctx and then in ap2 dot process abctx let's get rid of this bypass functionality for just a moment if the bypass button is not ticked let's see let's comment this out let's talk about what we're going to do if the bypass button is not ticked we will be hearing the audio running through our three filters if the bypass button is ticked we will be hearing the sum of the three filter bands added with the inverted all pass filters that's what we're going to implement next all right let's reenable this chunk right here and then let's change the names so it compiles this is in ap buffer and then that's it that's all we need to do all right so we're always adding these guys um and if our bypass button is turned on then we're adding the output of the inverted all pass buffer after it's been multiplied by negative one okay so clicking the bypass button should produce silence when we test this out here we go all right let's press play again if we click this button we should get silence all right and drag in the sliders perfect all right awesome so this wraps up the theory side of things we can start compressing our separate bands once we remove this inverted all pass filter stuff all right let's remove the all pass filter stuff the inverted all pass filter stuff we're not going to be using it anymore in this project we are done with all of that so let's head on over to pluginprocessor.h and we can get rid of this inverted all pass filter we can get rid of the buffer we can get rid of the stuff in the constructor stuff down here get rid of these two guys go to prepare to play basically everywhere if we were to build this now everywhere that we have errors is where we need to comment this stuff out okay we don't have these three anymore so i'll get rid of those and then in a process block that's going to be right here that's going to be here and right there that's going to be all of this code right here actual block context and filtering we don't need that let's turn this bypassing back on and then we can get rid of all of this code that inverted the samples you can get rid of this stuff right here let's build and test bypassing should not produce any audible differences that's what we're aiming for when we use the bypass button versus if we drag the sliders and whatnot all right let's try it out no phasing no audible difference here either awesome all right we can check off the first item in our dsp roadmap figure out how to split audio into three bands done cool let's make a commit of that figured out how to split audio into three bands here's our buffers and whatnot fill the graph yes all right here's where we set our types here's where we prepared our filtering here's where we set our cutoffs here's where we did our processing um and then this is just here's our parameter and then this is just where we are adding our third filter band all right awesome let's create audio parameters for the compressors that we will be adding we can also remove two other items from the roadmap since we completed them as well goodbye number two and goodbye number three all right so we are on number four now all right let's head over to create parameter layout in pluginprocessor.cpp all right we already created param names for these extra compressors so we just need to create the parameters for it since they all are going to have the same settings and range of settings we can literally just duplicate most of this code that creates the current set and just change the names so let's copy let's do the threshold first copy this paste it twice and then hold down option shift to select multiple lines and then change this to mid same thing for this one here change that to high done couldn't be easier let's do the attack param select this paste paste option drag mid option drag high boom okay let's do the release param copy this and option drag mid option drag hi perfect all right let's do the ratio parameter next copy paste paste option drag mid option drag hi and then the bypass parameter is next option drag mid option drag hi all right cool let's run it all right look at all the parameters that we have access to now all right that was super easy all right let's close this now in project 12 i teach a much more optimized solution for creating the parameters and looking them up versus using this params get paramed dot at thing that we're using here all right let's go on to the next item in the road map since we are up here let's see we're done with this done so now we need to reinstate our compressors and add two new ones let's do that next let's go to pluginprocessor.h we'll go down to where we are declaring everything go to our private member variable section the first thing i'm going to do is create an array of compressor band instances and then i'm going to create aliases to each one now the reason is so that i want to have the option to be able to loop through and i also want to have the option of being able to target each one individually without having to use array indexing so check that out let's do std array compressor band three there's my compressors we're going to change this to be plural and now we're going to do compressor let's see i'm going to do this on three lines so let me write this three times compressor band band comp uh let's see capital b band comp equals compressors like that all right let's just fill it in all right first this is going to be the low band this is going to be the mid band and this is going to be the high band this will be the first one this will be the second one and this will be the third one boom that was easy all right now we need to initialize all of the parameters for all of our compressors so go to pluginprocessor.cpp go to the constructor all right i'm going to rename the very first one and then i can just copy and paste the three lines to initialize the other two compressors all right so let's rename this right here this is gonna be low band comp like that now i can copy and paste it and rename accordingly all right i'll change this mid band and then this one is high band all right do the same thing for the bypass and the ratio so first rename this low band comp ratio and then copy and paste this two times and this is the mid band and the high band um oh you know what i forgot to do all of these need to be um let's see this is low so these need to be let's get let's line these up that could have been problematic let's see um all right go to the end arrow over one two three mid same thing here high like that awesome okay do the same thing here this needs to be mid with a capital m and then high with a capital h it could have been a disaster all right let's do this let's see this is low band comp bypassed copy and paste this and let's see this needs to be low this is mid this is high all right and then this is going to be the mid band and this will be the high band perfect all right the compressor parameters are initialized now we can prepare our compressors all right so when you're doing this step be very careful to make sure you're initializing the low band compressor with the low band parameters all right you know mid band with mid params high band with high params okay just be careful be very careful when you're doing this on your side go to prepare to play all right remember what i had said about the ability to loop through these we can just do four auto comp compressors comp boom done onward to process block first we need to update all of the compressors settings again looping for the win for auto compressor compressors let's turn that on now we can't actually compress any audio until after it has been filtered so we need to move this line this compressor dot process until after all of the filtering has been completed so let's go do that all right that happens down here okay now one of the important things to note was that filter buffers zero this guy right here this holds the low pass audio and that same index zero is the same index of the compressor that is set up for low band processing so isn't that convenient that means that it makes it really easy for us to run the correct buffer through the correct compressor so it would be a problem if it wasn't done this way imagine if we had to remember that filter buffers2 was the buffer to use for compressor zero all right anyway it's very easy to do this we just need to use an index based loop instead of a range based loop for size t i zero i is less than filter buffers dot size plus plus i now we can do compressors i dot process filter buffers i wasn't that easy how simple is that all right let's get rid of this uh bypass stuff let's clean this stuff up too we don't need that all right let's get rid of this bypass stuff we can delete it for good and uh that's it all right we can get rid of this stuff as well all right let's test it out our compressors should be able to be tested separately so grab your headphones and mess around with it here we go let's put this on screen so we can see more of the parameters and let's um let's see let's make the output of our compressor feed project 12 so we can actually see the result let's just turn off all processing first okay if uh we're gonna run some audio and then we're going to um you know adjust and adjust each individual band and just kind of mess with them all right so we got our low band we're going to hear the way this is set up now we're not going to hear a lot of low band you can really see this as we clamp it down we can see that a lot of the low band is gone let's go down here let's see that that low end is really chopped and then we turn it back we bypass it we can see that uh that happened all right let's let's uh chomp down the mid band wow it's really getting chopped all right let's adjust our mid band so it's tighter and let's change that ratio you can see this dip that's happening right here uh between 1k between as we show here 761 and 2300 it's kind of a dip right here between 1k and 2k let's change this to be closer to 300s that's right around where this line is you can see this dip right here so if i bypass the mid band see a little bit of a boost here change this ratio to be like really dramatic and really slam it all right we can see a big dip right there okay all right so that's a pretty good test next let's add the ability to solo and mute the individual compressors because that's a very cool feature let's save this and quit this let's um make a commit let's see what did we do we um reinstated all three compressors all right here's where we did that and fill the graph and here's where we set up our parameters here's where we set up our ratio param our bypass param here's where we prepared them here's where we did our settings updating here's where we actually processed audio and we got rid of some code there here's where we created our params params params params params good times commit all right solo bypass mute next let's check off road map item number five add two remaining compressors done number six add the ability to mute solo bypass individual compressors all right we can already bypass an individual band we just need to be able to solo and mute them so let's duplicate the bypass enum entries and rename them go to the params copy this paste paste and we just need to rename so option shift mute and sorry not shift just option drag to select and then solo i don't know if that's a thing on windows but on mac it is in xcode it's very handy all right we just need to add them to our map below let's go down here again copy paste rename one two let's get that back on screen all right first things first this is um let's see we'll do mute first copy paste copy paste copy paste all right and then solo will be the second set solo solo copy paste paste alright awesome now we need to add solo and mute parameters to our compressor let's go to the compressor band and declare two more boolean audio parameters named mute and solo so duplicate this copy paste paste it says mute and this is solo now these aren't going to be used in the compressor class at all they will be used in process block we still need to create the parameters in parameter layout before we can initialize them in the constructor so let's do that next head over to pluginprocessor.cpp and create parameter layout all right go to the bypass parameter where is that that's down here at the end all right copy paste rename do this for mute and solo all right change this to be the mute and mute again option drag mute and then we'll do solo here at the end solo whoops solo solo all right awesome let's go initialize the parameters and our compressors next go to the constructor all right copy and paste the boolean helper code for the bypassed param and then rename accordingly whoops let me add extra line okay this should be mute let's do all three of these and let's see i can't because their line lengths are different i can copy and paste this is solo copy and paste all right now for these i can do it at the end so this is all right no because high is too long all right gotta do them individually all right this is mute and then uh solo and solo okay excellent all right let's go solo or mute our separate bands next in process block all right this happens after buffer dot clear right here okay the logic is surprisingly simple if any of the bands are soloed we copy only the solo band's buffer to the output otherwise if a band is not muted we copy that band's buffer to the output so first we need to figure out if any band is soloed this is pretty easy to do we start with a boolean flag and then we loop through the compressors and just check their solo param if it's true then we have at least one band that is soloed and we stop checking once we have at least one that looks like this again we start with a flag we loop through every compressor if the solo parameter is true then we have at least one that is soloed so we don't need to check anymore let's comment out the old way of looping of adding the filters all right now we just need to check if bands are soloed or not all right if bands are soloed else if any of the bands are soloed copy only the solo band's buffer to the output now we cannot use a rangebased loop here because our filter buffers don't live with compressors so we have to use an indexed loop instead but that's okay that's easy to use for size t i equals zero i is less than compressors dot size plus plus i again uh let's get a compressor auto comp equals compressors if comp dot solo if it's soloed then add filter band add the buffer and this one we want filter bands uh filter buffers we want if index i apostrophe th all right cool that's very simple to understand all right again if a band is soloed loop through all of the bands and if a band's solo parameter is on then we add the associated filter buffer that that particular band is using all right let's implement what happens when nothing is soloed next go to the else block if nothing is soloed then copy only the buffers that are not muted let's use the same loop again and we need this uh compressor part as well oops all right if comp dot mute get all right if it is not muted it's very important to include that exclamation part if it is not muted then we can add that filter band okay that's it that is solo mute and bypass let's test it out let's mess with the solo buttons and the mute buttons grab your headphones all right here we go all right this is bypass let's mute let's solo the mid band all right we can adjust this just this range we can see how we we can make this mid band really narrow like that all right and we can bypass it as well so we can see what our mid band actually is like and what it actually sounds like what that means is that we can go up here and dial in all this stuff like say i want real slow attack time i want to let all of that you know snare information through i don't want that to get clamped down so i can adjust all that stuff it's just ratio all right let me stop you stop soloing it you know it's funny about that i was adjusting all those parameters and it was bypassed so i wasn't even hearing it so that's a whole that's a whole thing like you shouldn't be able to adjust these sliders um if it's bypassed but that's something we implement later all right so we can mess with this mid band see what it actually sounds like and use the bypass to um uh you know adjust this stuff let's change this ratio so it's real dramatic here there's a lot of information that's being uh is it in the high band well the high band is real wide all right so we can dial in a lot of the snare stuff that's going on here anyway that's solo mute and bypass actually mute the mid band we can see it gets dipped out there let's mute the high band stuff gets kind of dull if you need the low band it'll sound like a telephone and we can like you know tweak all this stuff early okay all right that is solo and mute and bypass of three separate bands with our filtering so we can check another item off of our roadmap let's solo this i'm not solo let's save this quit go to our roadmap turn off the ability to uh let's mark it as done that's awesome and then uh let's see we're gonna add input and output gain to compensate for level changes and then we're gonna clean it up and that will be the dsp side of things let's make a commit all right added mute solo functionality and bypass bypass functionality all right here's where we set up the uh mute and solo params here's where we implemented the actual dsp here's where we created the params uh marked it off list here's our enum here's our param names and here's our parameters on the compressor band excellent done all right input and output gain next and then clean up and that will conclude the dsp side of this plugin awesome all right now it is time to add input and output gain because compressors lower the output level of the signal the input gain is mainly if the incoming signal is not high enough or if it's too high and we need to turn it down first we need to add some entries in our enumeration that will point to the parameter names let's put these at the bottom next we need to add two entries so copy these stick these at the bottom number four all right we need to declare some gain processors and cached parameters go to plugin pluginprocessor.h way down at the bottom where we are declaring all of our stuff let's put this after our filter buffers uh let's see juice dsp gain float we got input gain output gain all right then we need two parameters these are going to be audio parameter float as well okay we need to create some actual parameters that represent our input and output gain so let's go to plugin pluginprocessor.cpp create parameter layout so we're going to put these at the top so i'm going to define a range of negative 24 to plus 24 with a step size of 0.5 this means we can boost or cut our incoming signal with a range of uh not in with a range but with steps of like 0.5 such as you know 1.5 db of gain 2 db again 2.5 db of gain same will go for the output gain levels all right so let's define that first auto gain range equals juice normalizable range actually i didn't need to type juice just type normalizable range range start is negative 24.f whoops that's float in the wrong place holder here we go range start negative 24.f range end positive 24 interval value 0.5 f and our skew will be one okay that's our gain range now we can define our parameter all right let's just copy this paste paste let's change this name to be gain in and we'll change this to use our gain range all right and let's just duplicate this copy paste replace that right now this can be gained out all right now that we have created the parameters we need to initialize our cached parameters in the constructor all right let's uh let's do this after our crossovers where's that that's right here okay float helper input gain param as with every other dsp processor we need to prepare our gain processors before we can use them let's go to prepare to play all right we also need to specify the ramp duration for these processors now this function the ramp duration it controls how long it takes to transition from one gain level to another whenever the gain level is changed so anything quicker than 5 or 10 milliseconds is pretty audible and it sounds it produces like clicks and pops so i'm gonna go with 50 milliseconds we'll go input gain gain dot prepare what do you want srb come say hi to everybody oh yes everybody say hi to srabby she's very whiny can you whine you gonna wind everybody all right down you go spec all right output gain dot prepare spec let's set those ramp times input gain dot set ramp duration in seconds 0.05 because there's a thousand milliseconds in one second so 0.5 seconds is 50 milliseconds all right do the same thing for the output copy paste copy paste okay now that this is all set up let us start processing our audio with our gain processors all right um let's see go to process block and before we start applying gain to our input buffer we need to update our processors with the most recent gain parameter values so input gain dot set gain in decibels because we're storing our parameter in decimals input gain program get do the same for the output all right we must apply input gain b4 processing audio through the bands so i'm going to call an imaginary function that i haven't written yet that applies the gain and then we'll implement that imaginary function next but first we'll do that here and call apply gain buffer and our input gain i'm doing this because i'm going to be applying gain i just don't want to have to write the code that actually applies the gain twice let's implement this imaginary function next head over to the header file plug in processor.h down at the bottom all right i'm going to declare a helper function that will apply the gain we are very familiar with creating the context for a particular buffer so i'm trying to type in that code so i'm going to write this helper function and i'm going to use templates because i'm too lazy to figure out the type that each of the arguments should have so you know why should i have to think about that stuff when the compiler can figure it out for me you know all right so here we go template type name t type name u void apply gain passing in a buffer and passing in again all right let's make our block auto block equals juice dsp audio block float out of the buffer make it out of the buffer let's make our context auto ct x equals juice dsp process context replacing float this is out of the block and then we can do gain dot process ctx all right head back over to process block so we can apply output gain next all right now finally we apply output gain after processing all of the audio that way at the end after all of this stuff apply gain buffer output gain all right cool let's test this out the gain sliders should change the volume headphones all right cool gaining at the top gain out at the top as well let's mess with this we'll adjust our levels let's just bypass um let's bypass our compression for right now turn down the input that works as expected all right cool that is awesome that works as expected all right so here's an interesting test um let's turn down the input gain to like negative 12 negative 12 and then let's turn up the output to positive 12. all right let's run some audio through it all right now if we toggle the bypass of plugin oh wait hold on i need to unbypass this stuff okay oh let's see all right if we bypass this the audio will sound the same okay so you would think that we would hear some type of compression especially if the compressors have a pretty low threshold prior to modifying the input and up again but when we do this we don't actually hear any compression all right so the reason is because we turned down the input gain level which means the low threshold that we had and the compressors is no longer low relative to the signal level so we need to lower these thresholds by 12 db in order for them to actually do anything right so for example if let's see um i'm gonna do it to just the low band for now turn the mid band back up okay i'm going to set this to negative 20. all right all right let me just solo this real quick oh look at me tweaking stuff all right here's our solo low band all right now because this is applying negative 12 to the input um our signal may not be hot enough to actually trick to actually trip the compressor so what we need to do is lower this by 12. so put this to 32. there we go now we now we're starting to hear it smash you can hear it on the base boom boom boom boom boom open that up a bit if we bypass okay all right so that's the interesting test do that now it'll really be it'll be really big it will really compress it and if we put this back 20 negative 20 we'll hear the same results that we heard a moment ago okay okay so that marks another item on our dsp roadmap let's save and quit this let's go up to our roadmap uh where's that plugin processor.h way at the top add input and output gain done okay so now the next thing to do is to clean this up let's do that next okay uh head on over to create pro create parameter layout all of these thresholds use the same um normalizable range so let's dri that dry that auto threshold range equals this thing cut paste semicolon replace the next thing to do is to move all of the code that updates the dsp processors into a function process block always operates in this order let's go to processblock see let's actually just see what i'm talking about processblock always operates in this order first thing we do is update dsp processors with the latest parameter values and then we process the audio so again dsp processing is entirely statebased and the parameters represent the state so we update the stuff that does all the math with the latest dsp state before any math computations are actually performed so i'm going to call an imaginary function first i'm going to call that right here update state and then we just need to move all of this code that happens here all of this stuff she need to move that to that function okay so let's do that next first we go declare it plug in processor.h way down at the bottom void update state now we can go implement it i'm going to put this right above a plugin i'm going to put it right above process block put that right here simple mb comp audio processor update state let's update our compressor settings all right we need to update the uh filters let's grab all this stuff and then we need to update the gain processors let's grab these as well let's clean this up as well get rid of that stuff and get rid of that and get rid of that all right cool and now process block is much simpler okay we update our state then we apply our gain the next thing that happens is we split the audio into separate bands so let's do the same thing we will call another imaginary function we'll call that right here split bands and we'll pass our buffer to it let's go declare it go to plugin processor down to the end okay go back to plugin processor and let's just move the relevant code again um above process block void simple i mean comp audio processor split bands okay so this is where we make this copy first and we do our contexts and this needs to say input buffer we do our contexts and our processing right cool so again we are making process block just that much simpler and easier to understand right we update our state we apply our gain then we split our bands and then we're doing compression all right now i'm just thinking out loud here but because the apply gain function is set up for a generic processor we technically we could use it i mean we could use it here for all of these but there are five processors being used which means that we would be creating five blocks and five contexts and right now we're only creating three blocks and three contacts so i'm gonna stick with what we have because it's um even though it would simplify this function a lot what we have now is um a light it is less cpu intensive because it has less objects being created okay everything else that happens is already pretty simple we do our compression um we do our solo check then we do our um if it's soloed here's which buffers get added otherwise these are the buffers that get added um let's clean that up so we could refactor it but we're not going to really gain anything here instead single line comments can be used to explain what is happening in case it isn't readable what's going on but in my opinion this is very readable right we're clearing the buffer we're figuring out if a band is soloed and then we're using whether or not a band is soloed to add stuff to um our input buffer okay so let's just run and test this to make sure and it should be all good but let's just make sure okay that still works it still works it still works all right cool and solo still works all right sounds good to me this concludes the dsp portion of this uh simple multiband compressor um in project 12 we tackle how to dynamically change the number of bands so you can have six bands two brands three bands up to eight bands if you're if you need that much along with uh how to do a bunch of other stuff like a draggable gui for adjusting the crossovers and adjusting the thresholds and whatnot okay so we can move on to developing the gui and making it as simple and as intuitive to use because this will never fly in front of the customers customers will look at this and say i don't know what i don't know how to use this i don't know yeah this is i will not give you my hardearned cash if this is the gui that i'm working with all right let's work on that next good times save quit let's make a commit added io gain cleaned up dsp here's where we um let's see checked out these things here's where we added our input gain uh strings here's where we added helper functions and parameters here's where we set up our parameters here's where we prepared our dsp processors here's where we did some cleanup here's more cleanup here more cleanup there and more cleanup here and here's where we added those parameters let's see that goes there here's where we added the parameters and here's where we refactored um the threshold parameter okay excellent onward to the gui all right the dsp is done let's get rid of the old road map let's sketch out the road map for the gui all right first thing that we're going to do is the global so let's add this in here globe gui road map all right number one global controls these are the x over x over sliders and the gain sliders okay these are going to go in the middle of the display input gain on the left output gain on the right crossover controls in the middle okay next we're going to have the main band controls these are going to be the attack release threshold ratio sliders all right these are going to go below the global controls and these controls will be assigned to the mid band first all right next we're going to add solo mute bypass buttons again these are going to be assigned to the mid band first and these are going to be on the right side of the main band controls component okay number four band select functionality this is also known as resettable parameter attachments this band selects functionality will allow us to have one set of controls for all of the bands and it will also give us some buttons to switch which band is currently being controlled by the sliders and the solo mute bypass buttons okay we will be using the band controls so we will need to have a mechanism to change which parameter a control is assigned to it's a pretty cool system to implement um it's not not the simplest thing but it's it's a very it's a very interesting problem to solve okay next five band select buttons reflect the solo mute bypass state when we switch the bands now this is to give us some visual feedback when we click any of these you know low band mid band high band buttons okay we also need to implement the logic that prevents you from having both uh the mute button and the solo button set at the same time for example because it doesn't make sense to be able to be muted and soloed at the same time all right so we're going to deal with that all right next number six custom look and feel for the rotary sliders and the toggle buttons all right so custom look and feel for sliders and toggle buttons we will be modifying the look and feel that we developed from the simple eq tutorial so if you don't have um if you did if you didn't do simple eq um you know pause right now and go through that and then come back here so that way you have those files i will also be including links to the simple eq repository so if you don't want to go through it you can just copy that code and um you know paste what you need you know copy the parts you need and paste it into this project let's see number seven spectrum analyzer overview spectrum analyzer overview okay the spectrum analyzer in this project is slightly different than the one in simple eq so i'm going to go into detail about what is actually different number eight data structures for spectrum analyzer all right we're going to grab these from the simple eq tutorial and then we're going to you know modify them at some point number nine we're going to let's see what are we doing here we are going to do fifo usage in uh plugin processor process block oh i got weird capitalization going on number ten uh well sorry before we do that okay so for the fifo usage in process block um we need to do a little bit of dsp modification to make this happen correctly all right and then let's see number 10 is okay implementation of the analyzer rendering precomputed paths again this is going to be taken from simple eq the simple eq analyzer took a decent chunk of time to develop in that course so there's nothing gained if i duplicate that same chunk of video in this video other than to make this video an hour and a half longer so i'm not going to do that i'm going to include links to the relevant code and we will be copying what we need and reusing it okay number 11 drawing crossovers on top of the analyzer plot okay this is where we're going to customize the spectrum analyzer number 12 okay drawing gain reduction on top of the analyzer drawing gain reduction on top of the analyzer again this is the final customization and we will need to write a little bit of dsp code to make this happen so we will be doing a little bit of work in plugin processor and then let's see the last one uh let's see analyze or bypass analyze the bypass um we're going to use the same code that we used from simple eq and then number 14. let's see we have a global bypass button global bypass button all right and this is just something that every plugin should have because um it's it just makes it really easy to compare what your plugin is doing with um if it's not processing anything okay that is wrapping up the gui we have our roadmap so let's start coding up the very first item global controls if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming4musicians.com and you can message me directly in the slack workspace and i will help you directly now that we are tackling the editor we can disable the generic editor and use our customized editor plugin processor.cpp create editor comment out this line and there we go all right we want to return our customized editor go to plugineditor.h alright the first thing we are going to do in the roadmap is tackle the global controls i'm not sure what size i want my different gui components to have right now so i'm going to use placeholder components that will show me the sizes i've set these are going to be empty components that only draw a single color so the good thing about this approach is that once i've dialed in the placeholder positioning when i finish developing the real component the screen position is already locked in and i won't have to mess around with the positioning of the component itself let's declare a placeholder component we'll put this here at the top this component is going to draw a single color and that single color is going to be defined when the component is constructed and this compo this color is going to be randomly generated but it will never change once it's configured so here we go struct placeholder let's define our paint function first and we're going to fill the whole thing with this custom color and then the next thing we will do after this is to declare our custom color now that we have used it okay let's declare our custom color next and we will initialize it in the constructor next first we need to declare a constructor and because the autocomplete is not responding as quickly as i would like in this header file i'm going to define this constructor in the cpp file so let's go over to plugin editor dot cpp next all right let's put this at the top all right let's start place holder i'm going to use the juice random class to generate some integers that will populate the rgb values of our custom color okay cool let's give ourselves some placeholder components and position them on the screen next head over to the editor class declaration and add some placeholders plug in editor.h down here at the bottom the editor will be split into four sections at the very top will feature the analyzer bypass buttons and the global band bypass button below that will be the spectrum analyzer with the part that shows the threshold as well as the gain reduction then below that are the global controls and then finally we will have the actual compressor band controls at the bottom so let's declare four instances of the placeholder and give them appropriate names all right let's add these to our display in our editor's constructor so head on over to plugin editor.cpp next we need to add and make our child components visible if we want to be able to see them let's give ourselves a little bit more room and make our editor a little bit wider and a fair bit taller i'm going to go with 600 by 500. all right let's go to resized for the control bar at the top i want to have the analyzer power button on the left and the compressor global bypass button on the right so i'm going to make these sit within a bounding box that is 32 units tall so first let me get the local bounce and now i can get a 32 pixel tall rectangle that will form the bounds of our control bar by calling the rectangle remove from top function this member function will remove a chunk from the top of the rectangle and give us that chunk that was removed as a separate rectangle so i'm going to use that here to give the control bar a bounds that is 32 pixels tall and the same width as our editor and is positioned at the top of the screen next let's position the actual compressor band controls at the bottom of the screen and i think i need something between 130 and 140 units in terms of height so let me try 135 first and just like remove from top i am going to use the rectangle remove from bottom function here which behaves just like the remove from top except the chunk is taken from the bottom of the rectangle let's dial in the analyzer bounds next i know i want this to be taller than the band controls and the global controls in the center so let me choose something between 200 and 250 all right let's go right down the middle and use 225 and remove that from the top of the bounding box again we're just removing chunks from the get local bounce rectangle and using those chunks as the bounding boxes for our child components okay we removed a small sliver from the top which was for the control bar then we removed the chunk from the bottom for the actual compressor band controls and then we removed a large chunk from the analyzer and that leaves us with a rectangle that will be used for the actual global controls let's run and test this i'm going to switch to the standalone editor and we can find we can fine tune these values after we see what it looks like this very first time all right this looks okay to me this is um this rectangle right here is going to be the control bar at the top uh this is going to be the band controls here's our global controls in the middle and then this rectangle right here this is the analyzer okay i'm happy with these placements we have created placeholders for the main parts of this gui so now we can dial in custom components for the global controls let's make a quick commit added placeholder components also added gui road map all right here's our road map the graph here's where we change to the custom editor here's our placeholder and the usage and here's our placeholder constructor adding all of our child components and positioning them all right let's declare a global control component plugin editor.h let's put this after the placeholder i'm going to start dialing in the graphics before i add sliders to it and the reason is because i want to reuse the sliders that were used in simple eq and migrating those files over to this project will require a bit of code surgery and i want to do this simple task first so let's declare the class first and we just need to add a paint function for now okay now we can replace our placeholder with an instance of this global controls let's flush out the paint function this one that we've got right here head to the cpp file let's put this after our placeholder paint function let's put this after our placeholder constructor okay let's flush this out i want to draw a border around the component but i also want to have a gap between this component and the others so i'm going to use the draw order to handle this since i don't want to have to mess with the component bounds again in the editor's resize function so the first things first let's fill the component with our border color i'm going to be using the juice namespace in here a lot so let me just do the using namespace trick we're going to fill our component bounds let's get them first all right and i'm going to use a blue violet color for right now next let's reduce our bounding box a little bit and fill a rounded rectangle with all black there we go we reduced we set the color to black and then we filled a rounded rectangle let's take a look at this just run it quick let's see what this looks like it's kind of hard to tell because this is a similar color okay to make this easier let's hide some of our placeholders go to plugin editor.cpp go to the editor constructor and let's just see the global controls comment out the control bar the analyzer and the band controls all right let's run it again all right let's get rid of this and we'll fill it with all black go down to this paint function so we will comment all of this out and do g dot fill all fill it with all black now let's run it again okay great let's add this little gap that i was talking about next i wanted to have a little bit of a gap between each of these widgets and go back to global controls paint okay so i want to draw a black border around the entire bounds of this component and since i'm reducing bounds here i need to make a copy of this before i reduce it i need to do this before i do the reduction right now i can reduce like i'm doing here now i can draw this black border so i will give myself a small gap between this component and the surrounding ones without messing with the resized function now for what it's worth i could have accomplished a similar result if i do g dot draw rect i could have achieved a similar result by using the juice path and adding a rounded rectangle to it and then calling g dot stroke path but that would have given me rounded corners on the outside in addition to the inside so this way i end up with a square i end up with square outer corners and rounded inner corners and i like the way this looks a little bit better personally speaking let's take a look all right so you can see there's a little bit of a gap between this and the right edge of the component and between the purple line and the left edge i think this looks really clean you know this nice little gap and there's going to be a little bit of a gap between each of the components i want to use this border effect in the compressor band controls and with the spectrum analyzer but i'm going to wait to refactor this paint stuff until it's actually time for that the next step is to grab the look and feel and rotary sliders from simple eq and get our global controls functioning so let's just we'll close this for now and we'll figure out how to do that stuff next let's make a commit added global control graphics okay i want to reuse the rotary sliders from simple eq in this project these sliders depend on the custom look and feel class that we developed in the simple eq project and the easiest thing to do is to copy the classes from that project and just add them here now if you did not complete simple eq visit the repository linked below the classes will be in the plugin editor dot h and cpp so we're going to copy the declarations for the look and feel class and the rotary slider with labels class let's paste them above our placeholder components so let's go grab simple eq we can grab it from here matcap music simple eq we can go to our source plugin editor.h and we are looking for look and feel all right here's our look and feel so we need the look and feel as well as the rotary slider with labels class this guy right here and this guy right here copy these guys and you can clone it if you want and grab it that way um go to your plugin editor and put it below no put it above our placeholder components okay now we need to grab the relevant implementations draw rotary slider draw toggle button all of this stuff so go back to the um source on github go to the cpp file plugin editor and we are looking for the look and feel draw rotary slider the next look and feel class and then rotary slider with labels paint and any other rotary slider with label functions all right there's a few of them plugin editor.cpp let's put these at the top put those right there i'm going to put this line between myself and between these classes and the placeholder just so i can tell them apart all right once it is pasted we have a few error messages to deal with let's find out where those are do a quick build and it should show them to us unknown type name power button all right let's deal with these two type errors i want to have a global bypass button in this project and i want to use the power button graphics from simple eq for it so the easy thing to do is to grab the power button class from simple eq and that is found in the editor.h so go back to the source code on github or if you have the project grab it from there plugin h and look for power button all right paste that grab the power button and paste that before the placeholder before the placeholder after the rotary slider with labels class plugin editor.h after rotary slider with labels before placeholder what's the next error analyzer button and i want to use that same button that we used in simple eq to toggle the spectrum analyzer on and off so again just copy the code for this class from the simple eq project and we'll paste it after the power button class so go over here here it is right here right below power button analyzer button copy that and put this in plugin editor after power button and before placeholder all right now try to build it alright build succeeded so with these errors out of the way we can now add our global controls to the gui now all right here is the plan for the global controls number one add generic juice sliders and then do some refactoring because i'm pretty sure we're to reuse some code between the paint function and the resize function for determining the bounding box our sliders will sit inside then we will add parameter attachments then we will replace the sliders with our rotary slider with labels classes on the heap and start using look and feel then we're going to dial in the colors for the sliders and the borders a bit then we're going to add the range labels to the sliders we're going to add a title that's the plan okay so let's dive in and add some generic sliders we're going to need a constructor for adding them as child component where's our global controls class where is that global controls okay down here all right constructor first we're going to need a resized function for positioning them and then we will need some private slider instances we have our input gain slider our low mid crossover slider our mid to high crossover slider and then our output gain slider all right let's head to the cpp file next and then add them as child components plugin editor.cpp let's go after our placeholder constructor let's add some child components all right let's position them add a resized function after paint i'm going to use flexbox for this so first let's get our bounding box then let's make a setup for row positioning because we're arranging these in a row i don't want to write juice all over the place so i'm going to use my using namespace juice let's move this up all right here we go flexbox all right i've declared my flexbox it's going to be a row flexbox and i don't want anything to wrap around now we just need to add every slider with the same amount of flex and then finally we just perform the layout all right let's see what we get let's run this okay those are not rotary sliders we need to customize the type to be rotary all right instead of doing this for every single slider let's declare a rotary slider class and make it inherit from slider and then we'll just set it up so that way it is it has the rotary style with no text box all right let's do this after let's do this right up here app right before our global controls all right let's initialize the base class rotary slider inherits from juice slider and it uses the rotary horizontal vertical drag slider with no text box let's change the type from juice slider here to rotary slider all right and let's test it out go ahead and run it see what we get all right much better okay let's add attachments next and then we will replace these with our rotary slider with labels that we created from simple eq all right let's declare one attachment per slider let's see where am i right now global controls we're down here all right i'm going to allocate these on the heap so that way i can optimize a bit in the constructor i will explain when we get to that stage for now let's just declare a unique pointer to the attachment and create one attachment per slider okay one attachment per slider now if we are using attachments we need the ap vts to look up the parameters so let's modify this constructor and let's change now how we initialize our global controls we need the audio processor dot apbts that's why we made that thing public that's why it's a public member variable way down here all right let's change our constructor plugin editor.cpp go to the global controls go up to this constructor choose ap processor valley true state apv ts okay now all of these attachments are unique pointer which means we have to call std make unique to create them now the slider attachment constructor wants three different parameters number one the ap vts number two the parameter name and number three the slider to attach to the first thing that we need is our parameter map so we can look up the names so let's do that before we start adding these things as child components the next thing that we will be writing a lot is attachment equals make unique attachment and then the three things and that sure seems like an opportunity for not repeating myself by writing a free function now i'm too lazy to look up the type names so i'm going to use the templated function instead and let the compiler figure out the type names so let's head over to the header file we're going to write a function called make attachment we're going to put this after our rotary slider it's going to go right here okay let's start by writing a function with no parameters now in the body we will call the actual make unique call using generic names in our parameter map so let's do void make attachment and here we're going to do attachment equals std make unique it's going to be an attachment and let's see what do we say the first argument that is needed is the apbts second argument is the parameter name which we get from our map and then the third argument is the slider itself okay now that we've got this we can dial in the um parameter list and then we can use template parameters for the five variables that are used in this function this is variable one two three four and five and then there's this thing right here so the first argument is the unique pointer itself std unique pointer of type attachment all right next we have the parameter name let's see well i guess next is actually the ap vts but um we'll just do these in this order yeah we'll do ap vts next ap vts all right then we've got our parameters map that's this thing here so params then we've got the name param name name let's make those guys const and then finally we've got our slider slider type slider okay now we can just add um template parameters for each of these templates like that and now we can do type name and attachment type name apbts type name params type name param name and then type name slider type okay great so again what we did here to figure this out was we just made an empty function with no arguments we implemented what we were going to call and then we said all right what gets used let's add parameters for all of that stuff that gets used and then let's just you know use template parameters for that and then we can use um the compiler feature template type name deduction when we call this function we'll just you know pass in all the stuff it needs and the compiler will figure out all the types and it should all just work just like magic with this helper function in place let's go back to our cpp file and now we can write a lambda that lets us dry calling that make attachment stuff with five parameters instead we can just call it with three parameters so that's dry for the win all right here we go auto make attachment helper equals lambda lambda lambda i always need to call make attachments all right so we just need to pass in our attachment we need to pass in the uh let's see we're going to be using the params so we need to capture those let's capture those by reference we're going to capture the ap vts and then everything else is passed by passed as constructor arguments okay so here's our mpvts here's our params our program name is something we can pass in here and we also need to pass in our slido so let's do auto attachment this should be lower case and then let's do um const auto name and let's see auto slider alright so we can just do name then slider so this is a very similar idea to what we did in the constructor for the audio processor or we made a lambda to basically dry a bunch of code that initialized parameters okay next step is to call our attachment helper for each of those three um each of the attachments for the sliders so make attachment helper our first attachment is the in gain slider attachment and for this we want names gain in and we're attaching this to the in gain slider all right let's do it again for the low mid crossover low mid attachment names low mid crossover and then the low mid slider make attachment we're doing mid high now mid high attachment whoops not make attachment attachment helper that's what we want all right so mid high attachment names mid high and then the mid high slider last one is the output slider make attachment helper this is the out gain attachment names out gain and then name um let's see this is the out gain slider all right cool let's build and test now if we run and tweak some knobs then quit and rerun the sliders should return to the same position that we left them in all right so this is input gain so i'm going to turn this all the way down and we will quit and rerun perfect all right double click to reset okay our compressors are not connected to any gui controls but the input gain and output gain parameters are so let's switch to testing with the aph to make sure the gain controls actually adjust audio levels which they should since you know we just saw it be attached to the parameters but there's nothing wrong with testing okay switch to the vst audio plugin host and let's run this all right let's run some audio grab your headphones turn down that input all right perfect okay we can switch these sliders out with our rotary slider with labels next so let's go over here let's make a quick commit as well save quit commit and we want to say that we added not simply q we want to say that we connected up what do we do we have connected let's see let's do two commits here so first number one is added lnf and rotary slider with labels from simple eq that's this stuff here stage this stage this and that's these guys and then that's also this stuff here here's our look and feel that's the look and feel stuff this is all rotary slider with labels stage u okay cool so that's adding the look and feel and rotary slider with labels from simple eq now what did we do next next we did let's see we added um sliders to global controls and then we also wired up the attachments there's our global control there's where we laid them all out with flexbox okay great next let's connect them to the rotary slider with labels all right go to plugin editor.h let's switch these sliders out the rotary sliders with our rotary slider with labels class now this rswl class has constructor parameters specifically and wants an audio parameter first now we have this parameter names map right here in our constructor with the attachments so i'm going to put these sliders on the heap and this is going to let this will allow me to initialize them inside this constructor so i can reuse this map okay if i didn't do that then i would have to use this params dot get params at for each of these sliders and that would be super annoying it would also be really verbose okay so that's why i'm not gonna do that so let's put these on the heap let's get rid of these guys right here let's change this to be std unique pointer rswl and do using r swl equals rotary slider with labels all right even though we're not using this anymore i'm just going to leave it leave it as is okay let's build this real quick and tackle some of these errors that are going to appear all right number one these need to be dereferenced because they are all a pointer so hold down option drag to select all the lines and add the star 2d reference let's do the same thing in resized okay now we can initialize these so let's do in gain slider equals std make unique rs oh that's not going to show us the full name so show me the full name rotary slider with labels all right okay we can fill in our suffix before we start dealing with our the thing that gets the ranged audio parameter so let's see for the uh in gain we want to use decibels so we need to look up a parameter from the ap vts so let's write another helper function that's templated that'll do that for us let's do the same thing go over to the header file we'll do the same thing that we did like we did with make attachment we'll just do it with um you know get the parameter so we'll start by calling functions on the objects that we haven't declared so let's first get a function we'll just do void get param like this and then what we need to do is get our parameter from the apvcs using our map autopram equals apvts.getparameter params.at name or position we'll do name this function returns a pointer so let's make sure it's not null j assert param is not null pointer okay now the let's see what what does this want here this wants a reference let's dereference the parameter that we looked up so let's go return param okay this jsert right here will fire if our parameter is not found but that should never happen because we are using our map to provide the names and also to create the parameters all right now we can start filling in function parameters we need our map we need our ap vts and we need our name okay so let's do um let's see apv ts ap vts we need our params so params params and then our name so name name and this should be const reference and this should also be cost reference now we just need to template it template type name apbts type name params type name name all right now we can call it plugineditor.cpp all right and let's add a helper function just like we did here our make our getparams function needs three parameters and three of those parameters are sorry two of those parameters are the params map and our ap vts yeah we can use a helper lambda to make it so we only need to pass in the name so let's do that auto get param helper equals lambda lambda lambda and let's grab our params and our ap vts by reference and now we just need our name const auto name we need to explicitly specify that this thing is going to return by reference so let's do that and now we can call our function super simple all right cool now we can fill in this placeholder with our lambda get param helper and here we want names in gain gain in and then finally we can replace our alias our rotary slider with labels with our alias r s w l cool that's clean all right now we just need to initialize these let's do the rest of them ingame slider let's see there's the ingame slider all right this is going to be the low mid crossover slider this is the midhigh crossover slider and this is the out gain slider all right this was low mid this was mid high and this was uh gain out and let's see this is in hertz and in hertz let's build that figure out if it's going to continue to give us errors or not oh you know what of course i forgot to change this return type here void return void function get param should not return value but it is returning a juice ranged audio parameter reference all right that's important i could have bogged this up for a while all right let's try it again build that should solve all the errors all right what's wrong with this one here oh you know what it's because these need to be dereferenced because this is a unique pointer now so to reference that because it wants the actual object like that all right let's try building it again voila magic all right let's run this and see what we get all right awesome those look nice and clean they display the value good times i'm very happy with that okay the problem is that they are smashed up to the top of this component so let's dial in this positioning next and we can also switch to using the standalone okay go to the resized function now let's shrink our bounding box a little bit just just enough i'm gonna go with five dot reduced five all right i want to add some spacers between the sliders and also at either end of the row so let's make some instances of the flex item class that will do that for us all right spacers are going to go in between the sliders and then end caps will go on the very ends this is just to kind of nudge everything in towards the center of it let's make the end cap a little bit bigger okay we need an end cap at the beginning and the end of the items array and then spacers in between each item all right here's my end cap and then a spacer between each item let's test it out all right cool so there's a bit more of a gap here a bit more of a gap here and then the gap in between is also a bit it has made these a little bit smaller and notice there's a little bit of a gap at the top too which is great all right let's tweak these colors next all right actually i want to add labels to the sliders next and i want to revise how this was accomplished in simple eq so let's take a quick look at what was done in that project so if i go to the simple eq constructor um let's see which class i can go to any of these classes i'll just look for dot labels okay here we go in simple eq i was hard coding these ranges okay now what i would like to do is actually extract them from the audio parameter for this project in this one i only care about the minimum and the maximum value of the parameter so let's write a helper function that can populate the labels array of our sliders and all we need to do is just give it the parameter for the range and the suffix so it's time for some more template magic let's declare a function and pass in our labels the parameter and the suffix and um we'll get it's just it's going to populate this labels array with the good stuff from the parameter let's go to our header file plugin editor.h let's go after get param now let's see we're going to modify the labels object and we're going to modify labels but everything else can be const to reference all right the first thing we want to do is first declare this function void add label pairs labels this is what our labels are all right everything else is constantly we've got our program type param and then we have our suffix type okay so the first thing we want to do is clear whatever labels are in the array so labels.clear all right so let's just add the first thing labels dot add um let's take a quick look at what was done here all right it was a we used curly brace because it's this position object we can take a look over here let's see it's in the middle of this class all right first object is position second object is a string all right labels.add curly brace first object is a string no first object is the percentage 0.f the second object is um the string okay um and actually let's add some template parameters for now we just need three let's just copy and paste this and do labels param type suffix type perfect all right we know that we need to return a string right here so let's create a function called getval string and it's going to return juice string get val string okay we know we need to pull our value to display from the parameter so let's make that a function argument one of these things next we're going to only display the minimum and maximum values so let's add a boolean flag to the parameter list and this flag will indicate if we should use the low end of the parameter range or the high end of the parameter range bool gets low the thought behind this comes from where we declared all of our parameters create parameter layout we always declared you know minimum the range start and the range end and then it was always step size and skew but you know this is like the low end of the range and this is the high end of the range and that applied for every normalizable range that we created negative 60 positive 12 5 and 500 um was there any others no there's not okay so that's where that comes from all right plugin editor dot h that's where this get low flag is coming from the idea behind that okay finally we need to append our suffix so let's make that be the last function parameter now if this was a templated function we could define it here but we know all the types so let's just declare it here and define it in the cpv file top uh well we'll define it in just a second let's use it first though all right go down here and then replace this quoted stuff with a call to it getval string all right now we can pass an hour param we can pass in our suffix yes we want to do true because we want the low parameter at the zero percent and then we can repeat for the 100 position one dot f and this should be false we do not want the low we do not want the low param we want the um yeah we want the end per value okay let's go implement this get val string next go to plugin editor.cpp way up at the top let's put this up here all right juice string get val string are you going to auto complete for me no all right let's copy it over from the header file copy paste remove that semicolon add curly braces all right we need our string juice string str let's return it next return str all right let's get our parameters minimum and maximum value from the parameters range autoval equals get low param dot get normalizable range dot start or param dot get normalizable range end okay that's part of the puzzle let's add our suffix str suffix now something that i really liked from the rotary slider with labels class was that um the k the gods appended to the little the letter k that is appended um to the suffix whenever a parameters value was 1000 or higher so let's refactor that into a function that we can use here and in rotary slider with labels and in look and feel all right so i'm gonna let's see where does that happen let's take a look at that logic real quick that's right here if the value is over 999 divided by a thousand and then we're going to add the k and then it's like if we have to add k then um we just stick a key on there before we add this suffix very simple all right so i'm going to just add a function at the top i'm going to call it truncate kilo value let's see um let's do void for right now truncate kilo kilo jeez louise value and let's i'm not sure what type i'm going to use so i'm going to do that let's template this i'm declaring it here in the cpp file because this is the only place that will get used currently all right here's the logic if the value is over 9.99 divided by 1 000. okay we're passing in by reference because we're going to actually modify this thing and then let's see if we did perform a truncation let's return true and if we didn't let's return false so if value is greater than 999 let's cast this 999 to whatever type t is all right if it's over 9.99 value equals static cast t 1 000 return true return false all right so if it's over 9.99 divided by a thousand and return true meaning yes we did perform a truncation all right let's go use it all right so we can do bool use k equals truncate truncate kilo value kilo value value all right and then um let's see don't forget this function is going to modify this if we used if it performs truncation so we can add our string now str val if we should use kilos append it as well if use k str the letter k we can make use of this in that get display string function over here get display string it's a float param now just looking at the rest of this function here we could probably revise it to use our get valve string function too but that's not something that i want to do i just want to replace this with our code so i'm just going to comment this out and do add k equals truncate kilo value all right a little bit of a code surgery all right um let's see let's go back to where we are creating our sliders because once we once we've made our let's go back to where we are making our attachments it's under global controls constructor because after we make our attachments we're going to add our labels but let's do a quick build to make sure we don't have any template errors first make sure our truncate function works all right cool all right let's use our helper function let's do this right here add label pairs so the first label is going to be the let's see i'm going to do the in gain slider labels and the param is going to be get param helper let's see names in and the suffix type is going to be decibels right let's do it for the next one let's put these on there online add label pairs let's see we got the low mid crossover slider labels pram is get param helper names low mid this is hertz again add label pairs mid high get program helper names mid high also hurts all right last one is the output gain slider add label pairs out gain slider labels get program helper names output gain whoops put that on the next line and decibels okay let's run this and we should see some labels next to our sliders let's see what we got oh build failed what happened no matching call forget val string what did i do wrong oh my get param helper let's see what's the problem candidate function you want a reference parameter what is being passed i'm passing a const reference oh that's why this should be const and that's because that's because it's const right here okay am i going to run into a bunch of const issues let's see undefined symbol yes because i made one const and the other not constant okay this needs to be const up here get val string this should be const build completed build succeeded boom all right we've got our labels negative 24 positive 24 20 hertz to 989 one kilohertz to 20 kilohertz perfect and this shows 1k awesome that's fantastic all right cool let's commit that very happy with that make our commit let's see added label pairs two sliders is that what we did um oh no we did uh switched to rswl and added label pairs to sliders perfect all right that was a lot it's not a lot of code here in this commit but in terms of like what we actually implemented that's a lot of functionality okay okay let's look at this constructor real quick we are calling get pram helper twice we're doing it right here when we make our slider and then we're doing it here again when we make our label pairs so let's fix that let's cache our parameters here and then replace accordingly that right here so auto gain in param equals okay let's replace accordingly all right and these ones down here all right cool let's build and test to make sure everything is cool all right i'm gonna change that to negative six brings you to negative six quit rerun all right awesome that works as expected all right let's add titles to our sliders so we're gonna add a third constructor parameter and give it a value of no title so let's go up to our rotary slider with labels class plug an editor get rid of this build target thing plugin editor go to the ranged no not range rotary slider with labels um we're going to add a third constructor parameter to this let's see where is that that's right here we're going to put this on its own line and we're going to give it a default value so everything still constructs um still builds without any errors const juice string title equals no title all right that's the first part we will display the component's name in the paint function so we'll call set name title now let's go to the paint function plug in editor rotor slider with labels paint wait why does this say just oh that's this should that should say juice all right uh paint function right below where we get the slider bounds let's see i want to draw this title at the top of the slider so we need to modify the get slider bounds function to account for this so let's draw our title first and then adjust the slider bounds next first let's get the local bounds auto bounds equals get local bounce next let's set a color and draw some fitted text i'm going to go with blue violet and let's draw some fitted text g draw fitted text all right i'm going to use the rectangle remove from top function to create the bounding box that the title text will be placed in and i'm going to use the get text height function plus a little bit more for this bounding box first things first the text we will display is the name get name the area let's see we're going to be centered justification centered do centered bottom and we're on one line all right let me put these on separate lines uh let's see we're gonna do bounds dot remove from top and the amount to remove is our text type plus a little bit all right let's see how that looks let's comment out this draw rotary slider stuff to begin with all right cool no title excellent all right let's uncomment to this okay so we need to dial in these slider bounds next all right go down to get slider bounds now we need to remove some space from the top of the local bounds so let's do text height minus 1.5 and see how that looks let's see what are we doing right now auto bounds is get local downs and let's trim off the top bounds dot remove from top let's do get text height times 1.5 let's see how that looks all right that's very small and it's still colliding with the title so shrinking let's see so let's change the y position of this rectangle to be the y position of our bounds let's do let's comment this out and do r dot set y bounds dot get y instead okay cool so it's not covering up the title now that's good that's progress all right let's adjust the s the slider size by adjusting the size of this rectangle here this thing right here now shrinking the size by twice the text height is too much so let's change this to be 1.5 and see what it looks like now that's much better okay this is a much more reasonable size let's remove the default parameter next go back to plugineditor.h let's get rid of this default parameter and let's build and add our titles where the error messages appear okay ingame slider you are going to say input trim in all caps low mid is going to be let's see low mid x over like that let's do this one this will be mid hi no gh x over and then this will be output trim output trim all right let's take a look at this now that we've got our titles in here okay that's fantastic now i don't like this black square in the middle that's surrounding the numbers but we'll fix all of these colors later alright for now that wraps up the global control so that's fantastic let's take a look at that one more time all right awesome very cool let's make a commit of that added titles to our swl bang boom all right so we adjusted that just that part is just that part here's where we actually added the titles we can start working on the actual compressor band controls next let's create the compressor band controls next here's the road map for this component this guy way down here compressor band controls number one we're going to add sliders for the main compressor controls once that's done we will add the solo mute and bypass buttons then we will add band selection functionality meaning we're going to change the parameters that the sliders are connected to uh whenever we click those buttons then we will dial in the colors before we add in the spectrum analyzer and drawing the thresholds and gain reduction all right let's dive in all right we are going to reuse our uh where is that class we're gonna reuse this rotary slider class for right now okay let's put this um yeah we're gonna put this after rotary slider oh let's put it after these functions let's put it above global controls okay here we go all right we need four instances of um the rotary slider class for our four compressor controls okay attack slider release slider threshold slider and ratio slider you know what comes next a constructor and a resized function let's implement those next head to the cpp file let's do this above our global controls uh constructor compressor band controls compressor band controls let's add all of these sliders as children is there anything in here that i can copy yeah i'm gonna copy this we have four sliders those are four sliders being added all right let's just delete this all right now we can add our sliders and let's see they all end in the word slider so i'm going to add that and now i can fill them in tack slider release slider threshold slider ratio slider now i am going to copy the global controls resized code to position these i'm going to move them later when we add the buttons but this is just to get them on screen so go to the compressor brand sorry go to the global controls resize function and we're just going to copy the whole thing and then we're going to paste it now we just need to change these names here attack slider oh sorry we need to change this name first to be uh compressor band controls all right now we can do attack slider release slider threshold slider and ratio slide it's very convenient all right let's change our band controls in the editor to use our compressor band controls class next select this and copy it let's go back to the header file let's get rid of our placeholder in our editor get rid of band controls here oops that's the wrong key command get rid of band controls and get rid of this comma and now add an instance here band controls all right now we just need to make it visible again so go to plugineditor.cpp go to the plugin uh go to the editor constructor and we're going to make our band controls visible let's test it out make sure you're doing the standalone version let's see what we get all right awesome our four sliders very cool so we'll turn them into these um sliders with the labels and stuff in a little bit all right i want to add the same border that the global controls has to this compressor band controls components so let's add a paint function i'm just going to copy this declaration put it right below resized now we can literally just copy the global controls paint function and just rename the class and we'll get that so go to plugin editor go to global controls paint literally copy this paste it after the compressor band controls resize function and just click change the class name compressor band controls change it to like that all right let's run it and see what we get all right i'm very happy with that remember i had said i wanted to have a border with a bit of a gap between the um between these modules all right so that's very clean let's refactor it next because we are literally repeating the exact same code in those two paint functions let's refactor this module background paint code so we aren't repeating ourselves i would like to declare a free function and it's going to be identical to what we are doing in paint except for the call to get local bounds that's this thing right here instead this rectangle bounds will be one of our parameters so i'm going to just put that um where should i put that i'm going to put that um i'm going to put that right above this paint function for right now we'll move it later void draw module background add an empty argument list now we're going to copy these guts over grab this copy copy and paste this and let's see all right first things first we need a graphics context to draw into then we need that rectangle bounce all right now that can let us remove this line there we go okay that takes care of that now we just need to comment out this old code here in our let's see let's do global controls first let's comment it out down here let's get rid of this and let's see i am going to need uh the bounding box so we'll do uncomment that line and now do draw module background bounds oh we also need your graphics context okay let's just uh verify that this works let's run this real quick all right global controls is still cool awesome let's do the exact same thing in global in compressor band controls copy that line scroll on up here comment all of this out and replace it like that all right perfect looks good to me let's get our sliders connected to the parameters next we will create attachments first and then we will change to rotary slider with labels all right let's clean this up we don't need that and we don't need this stuff let's get rid of this code okay fantastic all right head over to your plugin editor dot h go to the global controls and now copy these attachments from global controls we're going to copy them we are going to paste them in our compressor band controls and rename them put them right below our sliders now we're going to do attack slider attachments release slider attachment threshold slider attachment ratio slider attachment let me line these back up let's update this constructor next all right go to plugineditor.cpp go to compressor band controls the constructor and let's see what can we borrow all right we're going to do the same parameter initialization stuff that we did in uh compressor band in global band control so we can grab these things copy this stuff and we'll fix these incorrect names in just a moment all right go up here to the constructor and paste all this stuff let's copy all of that code that initialized those attachments from uh global controls so go down to global controls grab all of this stuff the make attachment helper we're going to need that stuff too grab this code paste it here all right now we need to change all of these names but we'll fix that in just a moment we need to copy the params declaration and update the constructor to receive an ap bts so let's copy that stuff from the global controls constructor as well grab this thing right here all right and paste that here as a constructor argument now let's update the declaration next copy this stuff right here go to plugineditor.h and modify this constructor oops uh this has an extra set of parentheses there we go now we need to revise how our class gets constructed in our editor so go down here and just copy these um copy how the global controls are initialized and just paste it here now we can fix all of these errors in our um constructor here all right so first things first we are doing the um attack attachment slider attachment and this is the attack slider and this name needs to be the attack let's do the um i think we said we were doing the mid band let's see what we did uh yeah we'll do we'll do the middle band first okay so we'll change that all right so there's the attack all right now we need to do release release slider release slider attachment and then this is the release mid band all right now we've got the uh threshold threshold attachment threshold slider and then threshold mid band then finally we have our ratio so this is ratio attachment ratio slider and then ratio mid band all right when we add band switching functionality we will be able to dynamically switch these attachments which will be a very cool thing all right let's test it out we are going to drag a slider quit and rerun and the slider should display this updated position let's see what we get okay i'm gonna do the uh i'm gonna do the attack time i'm gonna yeah i'll do the attack time i'm just gonna put it at 12 o'clock quit rerun the attack slider should be at 12 o'clock all right perfect it is double click to reset to the default value awesome our next task is to change rotary sliders with labels so that it accepts a pointer to a parameter instead of a reference the reason is because we will be dynamically changing the parameter in the compressor band controls class whenever we change which band is currently being displayed so the other thing we will do is to move the look and feel to our editor this way every child component inherits the look and feel of the parent class let's go to rotary slider with labels in the header file let's modify this constructor to take a pointer let's change this member initialization let's remove the look and feel member variable copy this and comment it out now by removing the look and feel we no longer need to set it here and we also don't need this destructor so that's cool now let's see before we add a look and feel to the editor let's add a member function which will allow us to change the parameter whenever we want let's go put this here right below get display string void change param and we'll go to juice ranged audio parameter pointer like that all right now we can go all the way down to our editor and add a look and feel member make sure this is the first member variable that gets constructed let's go to our editor's constructor we want to set our look and feel right here set look oh let's do it before uh before we make these guys visible set look and feel lnf make sure you're taking the address of it and now we must remember to set it to null pointer when our component is destroyed we go set look and feel null pointer oops null pointer okay now we can adjust where every rswl is created since the constructor wants a pointer not a reference so let's build it and start fixing all of those errors command b to build all right where does this happen okay so the only spot where we created these sliders is in the global controls function so we just need to pass pointers instead of references so we just need to add our ampersand in front of all these and let's test it out that should clear all of the errors all right build succeeded let's test it out let's adjust the in gain slider and see if it sticks well look at these guys all right turn that down and turn that down to 10 quit rerun it should be at 10 10.5 interesting let me do that one more time 10. okay there goes all right cool that looks good to me now let's see i just want to look at that one more time now changing the look and feel um and making the editor own the instance that all child components inherit from really messed up how these compressor band controls uh end up looking so let's fix that next all right go to compressor band controls in the header file all right this class is going to need access to the ap vts in order to look up parameters as needed so let's add a reference to that we can just copy this one right here from our global controls constructor all right next let's change all of these sliders here the attack release threshold and ratio sliders into rotary slider with labels so grab this class right here and paste it there alright we will need to use the member initializer list to initialize all of these next go to plugin editor dot cpp go to the compressor brand control constructor let's initialize all of these members first things first let's do the ap vts ap vts and i'm going to rename this to be apv now let's do all of our sliders attack slider alright we're going to start with nullpointer and our suffix is milliseconds and our title is attack let's do the others release slider same thing null pointer ms and release oops don't forget the quotes so the other two all right let's fix this error in the capture list now we need to do abbvts let's see ap bts equals this apbts like that all right now we are capturing this class's instance of the ap ap vts by reference okay all right let's test this out oh we need to um adjust this make params helper oh you know what i don't know if we actually need this get param helper yet so i'm going to comment that out i might need that in a little bit sure okay let's test this out we'll see what happens maybe we will have sliders with titles who knows uh what's going on here oh this is because it doesn't have a parameter all right let's fix that it's going back here so it turns out we did need this we need to get our parameters and now we can call change param on all of our sliders let's do that right here attack slider dot change param get pram helper let's see this thing returns a reference so we need to get the address of it and the name we want is names attack mid band all right let's do the others we got our release slider so i'm going to just copy this line whoops copy this line paste face paste release slider threshold slider ratio slider all right now this is release mid band threshold mid band ratio mid band let's test this out see what we get an error undefined symbol yes we did not implement this we declared it but did not implement it so let's do that next let's go up to where our rotary slider with labels get display string is we're going to put this at after it void rotary slider with labels and change param is the one we want so whatever parameter we pass into this is um what we need to give it um let's see so this becomes param equals p and then once we get a new param repaint let's try this out all right awesome so these are almost fully functional we just need to add labels next all right go back to the constructor we can use the add label pairs function that we wrote for all of our sliders except the ratio slider and the reason is because the ratio slider labels need to have a colon 1 at the end so we need to define those manually so let's start here add label pairs our first labels are the attack slider dot labels parameter is the get param helper attack mid band we'll refactor this in a little bit those need to be cached does that want to reference it does want a reference we're giving it that all right and our suffix is going to be milliseconds okay do the same thing for the release paste release slider release mid band and then threshold copy paste threshold slider threshold mid band and this needs to be decibels db so the first label for the ratio slider the first ratio is one to one so let's make a label position element let's add a curly brace for this for default initialization all right so at the zero percent position we want to see one colon one all right now the second one should be the highest ratio uh defined in the list of choices so let's get our ratio param let's see this is a juice audio parameter choice and we want to call get param helper we want our names ratio mid band all right now we just need to get the last entry from this let's add our line first um why can't we not why can we not use cannot convert from this to that um oh this returns a reference that's right we should take the address of the reference return okay so now let's see we want ratioslider.labels.add and this is for the 100 position and now we are going to add um let's see ratio param choices and we want the last one how can we do that we can do get reference and then ratio param choices size minus one okay let's see how that looks so this is displaying 100.0 and we wanted to say 100 colon 1. so we need to get the integer value of this string and then turn that into a string and then append the colon one to the end all right we can do that we need to change this to be uh choices get reference i'm gonna put this down here all right choices get reference give me the last one all right now you're going to give me the int value and then um let's see i need to turn this into a string first put that in parenthesis juice string and now i can append colon 1 to it let's see how that looks there we go 100 to 1. perfect now let's make the center of the sliders display the current ratio next so for this we will need to derive from the rotary slider with labels and customize the get display string function all right head over to your header file plugin editor.h go to the what's the name of this class go to the rotary slider with labels class all right we are going to override this get display string function so we need to make it virtual first ritual and then we need to make these member variables protected instead of private so the derived class can access them let's clean this up too while we are here all right let's declare a ratio slider class below this now this is a ratio slider which means we can hard code the title whenever we are initializing the base class we still need everything else though so let's just copy all of this paste it here change this class name and fix this indentation all right so all we need is the suffix and the rest is for the base class rotary slider with labels and put this on its own line all right we're passing in our ranged audio parameter our unit suffix and then ratio perfect curly braces all right now we can implement the function that we care about this guy right here get display string override let's implement it next let's go to the plugin editor.cpp go to the uh change param function we're gonna put it right below that all right so let's start the implementation this function returns a string okay what we need to do here is get the name of the current choice to do that we need to convert the program into a choice parameter so that's uh step number one auto choice param equals dynamic cast juice audio parameter choice param let's make sure that we can cast it once we have our choice param we can just get the current choice name now if you remember it displayed 100.0 when we used the choice name directly this is because we declared our choices as doubles because i wanted 1.5 to be one of the choices and everything else is an integer value basically which means it's gonna end up with that point zero at the end so if the choice ends with point zero just remove that from the string if current choice dot contains point zero get rid of it current choice equals currentchoice.substring our starting index is zero and our endpoint is the index of that period because the end index is not included in the substring we go from our starting point up to but not including the end currentchoice.index of okay once we've done that just stick the colon at the end current choice colon one all right there's our display string let's test it out let's return it return current choice see what happens nothing and that is because we forgot to change our ratio sliders type copy this ratio slider go to the header file go to the uh where's this class go to the constructor go to the compressor band controls class and change the ratio slider to be that ratio slider all right let's run this we should see the ratio in the center nope we uh what's wrong oh we don't need this third parameter that's why all right let's fix that all right third time's the charm okay cool there we go we're seeing our ratio in the middle let's cycle through them see what we get four five six seven eight nine ten fifteen twenty 100 perfect and what happens when we get to 1.5 is that a thing perfect all right let's make a commit of that so implemented basic comp band controls perfect stage stage let's add the solo mute and bypass buttons next we will position them and then connect them to parameters go to the header file go to our compressor band controls and let's add these after our attachments juice toggle button is the weapon of choice here okay bypass button solo button mute button let's set the name next go to the plugin uh go to the constructor compressor band controls let's do this after we add our sliders bypass button dot set name we're going to draw the name the name is what will be drawn when we configure the look and feel bypass we'll give it an x solo will have a big s in it and mute will have an m okay let's add them next i'm just going to copy three of these paste and now copy paste copy paste copy paste let's go to our resized function okay this component will have band control buttons on the right and band select buttons on the left so let's write a helper function to wrap this vertical arrangement of these buttons in a flex box somewhere since we are using flexbox already for the sliders so first we will pass in a vector of pointers to components that'll look like this std vector component pointer comps then we will declare a flexbox that we will be adding the buttons to but the column direction we can just copy this the column direction or the direction will be column instead of row that's the only change we're going to make there number six i want a small spacer between them so i'm going to copy this again this is vertical so we're going to do with height and i want it smaller than 4 2 pixels is fine all right now we just need to loop through our components add a spacer before and then add the component to the flexbox for autocomp comps flexbox.items.add add the spacer first then add the add to the component add a flex item with a flex of one now our item list currently goes spacer component spacer component spacer component so we need to add one more spacer at the end now we can return our flexbox all right so this is going to be used for the buttons on the right the bypass mute solo buttons and then the band select buttons on the left all right now we can call it we can call our lambda like this with our band control buttons with our uh not banned control buttons with our um uh yeah band control buttons that's right um the bypass mute solo buttons auto band button control correct capitalization auto band button control box equals create band band button control box and we need to provide a vector of our a vector with our components we want the address of the bypass button address of the solo button and the address of the mute button okay next let's get rid of this end cap for now and we're going to replace it with a spacer and now let's add the band control button box on the right flexbox.items.add band control button box band button control box and let's give it a width uh this needs to be wrapped in flex item declare a flex item and let's give it a width uh let's see 30. i you know i usually enjoy buttons and i like gooeys that have buttons around like the 20 to 30 size so we'll start with 30. see what we get okay we're not seeing them let's check the look and feel class next all right let's see go up to the look and feel draw toggle button all right if it's power button it's going to draw something if it's an analyzer button it's going to do something else okay it doesn't do anything if it's neither of those so let's add an else clause it's a pretty silly error okay let's draw a rounded rectangle with the component name in the middle all right if the button is on we're going to draw a black text on a white background otherwise draw a white text on a black background we'll dial in these colors later first let's get our bounding box auto bounds equals toggle button dot get local bounds and i'll shrink it a little bit alright if the button is on it would be nice to know all right let's give ourselves a corner size because remember we're doing rounded rectangle all right let's fill a rounded rectangle with the background color first g.set color if the button is on we're gonna do white otherwise we're doing black and now let's fill our rectangle and then invert the colors and draw a rounded rect followed by the text so g dot let's just copy this line invert the colors so if it's we're gonna do black first and then white depending on if the button is on or off now let's draw a rounded rectangle g dot draw rounded rectangle our corner size is going to be corner size our line thickness will be 1 and our rectangle will be bounds dot 2 float all right now let's draw our text g.draw fitted text we're going to draw the button get name we're gonna draw it inbounds we're gonna be centered and we're gonna occupy one line of text all right let's test it out boom all right got some toggle buttons fantastic all right let's connect them to parameters next okay go to plugin editor.h go to the bottom of compressor band controls and let's add some attachment i'm just going to copy this code we only need three of these we're using a different attachment we're using button attachment and we cannot use an alias without redeclaring one so let's do btn attachment like that and an indent indent indent we don't need uh we only need three of these so we'll do bypass button attachment solo button attachment mute button attachment and let's indent these so they all line up nicely okay and now head over to the constructor we want compressor band controls and let's use our attachment helper to initialize them make attachment helper our attachment is going to be let's see we'll start with bypass button oops bypass button attachment our name is names um we're doing mid band right bypass mid band and our slider is the bypass button i'm glad we templated that class because it means we can use it with any component not just um not just sliders all right let's do this again i'm just going to copy and paste this and rename stuff all right we've got bypass we got solo attach um we've got mute attach let's see the solo button this was the mute button solo mid and mute mid okay let's test it out that was very quick all right let's let's see um let's um let's close this this will be bypassed close that rerun all right bypass is still working all right let's go test this out in audio plug and host and we adjust the sliders and the solo bypass buttons and see if we hear any differences all right here we go oh headphones all right we're soloing the mid band and we can adjust all this stuff that is definitely working mute that band seeing it dipped out very cool let's give it a real quick release time that is definitely working all right right past that turn that off stop save quit all right we're getting there okay all of these are working the next step is to add buttons that let us select which band the sliders are actually controlling let's do that next all right let's add three buttons to allow switching of the bands go to the header file and just put them at the end of the list low band mid band high band let's go to the uh constructor and set their name there's a brand i'm just gonna duplicate this i'm gonna put this after the attachment stuff this is low band mid band high band low mid high okay these buttons need to be grouped together so that when you click on one the others toggle off that's what the radio group id is for so low band dot set radio group id set them all to one all right we'll do low band mid band high band these are all part of the same radio group let's make them visible we will position them next paste and now copy paste copy paste copy paste okay let's add another flex box go to the resize function we've got our band button control box let's add another one for the select buttons auto band select control box equals create band button all right let's add our vector with our three buttons low band first mid band next high band last all right let's get rid of the end cap let's replace it with a spacer and now add the band select box on the left flexbox items add flex item here you are going to control the band select control box with flex of one and we're gonna need one spacer after this let's see i'm not gonna do it with with with this flex actually i'm gonna do it with a fixed width um let's see okay so the band control box had a width of 30 um and that was displaying a single character of text so i know that this needs to be wider because it's displaying you know three or four characters so let's try 50 and we need a spacer after it as well all right let's take a look all right those look nice like that that looks good it's nice um nice positioning of everything so i'm happy with that so let's save this quit this those buttons don't do anything but we will fix that in a bit for now let's make a commit of what we've done what did we do we added um added control buttons to band control what is this thing called compressor band control class presser band controls that's what we did stage stage that um let's see here's where we customize the look and feel here's where we added all of our buttons here's where we added them to the flexbox stage stage stage commit all right awesome if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming4musicians.com and you can message me directly in the slack workspace and i will help you directly let's make these band switcher buttons work whenever we click on one of these buttons we will simply reset the slider and the button attachments and recreate the attachments okay the tricky part is figuring out which button was clicked now we're going to be doing all of this stuff before we make our buttons visible so first let's define a lambda that will be called whenever each button is clicked let's capture a safe pointer that is alive for as long as this class exists all right we're going to just speak some stuff into existence all right we're going to do this after we set our radio group and before we set everything visible all right here we go let's make a let's make this lambda all right we have uh declared that a safe point or member variable exists so let's um let's go make one okay go to the plugin editor dot h at the bottom of the compressor band control let's add one here juice component safe pointer come on auto complete there it is all right and it is a compressor band controls and it is an instance created from this and it's called safe pointer and initialization requires curly braces okay all right go back to that constructor okay let's do a quick build to clear that error okay if our save pointers component is valid let's call a function that updates the attachments if auto all right if the safe pointer component exists let's call a function on it alright i'm going to just call a function that doesn't exist yet but it will update attachments okay it doesn't exist yet but it will let's go declare it next plug in editor go to the bottom of this put it right here void update attachments all right we've got our declaration in place let's go implement this after we finish doing what we need to do in the constructor so go back to the constructor because we're not done there we can do a quick build to clear that error all right we've got this lambda so let's assign it to the on click member function why is that still giving oh there it goes error is gone because it says bill succeeded so that's just xcode is just taking a while to catch up all right here we go band dot on click equals button switcher do the same thing for the other three bands low band mid band high band oh sorry don't no parentheses all right we want low band mid band high band okay whenever one of those buttons is clicked it is going to call this function now before we implement update attachments let's make the low band the default band choice by setting the toggle state to true and then we can call our attachment updater function which will connect all the attachments to the appropriate sliders so first set the toggle state to true low band dot set toggle state true and we do not want to send a notification the reason is because sending a notification will trigger this lambda and we don't want that to happen don't choose notification type don't send notification all right let's call update attachments update attachments now we can go implement the update attachments function all right let's start this after the paint function right here void compressor band controls update attachments okay there are a few problems we need to solve in this function number one we have to figure out which button was clicked now we can do this by checking the toggle state of all of our buttons they are part of a radio group which means only one button can be toggled on at a time problem number two we have to figure out which parameters go with which buttons and number three we have to create the parameters like we did in the constructor so first things first let's figure out which button is clicked i don't want to use integers for this so i'm going to declare an enumeration and declare a variable that uses that enumeration as the type then i'm going to immediately invoke a lambda that will determine that variable's value first things first here is the enumeration scroll a little bit and here is the immediately invoked lambda all right this logic is very simple if it's the low band we're going to return low band type if it's the mid band we return the mid band type if it's high band well then the only thing that's left if it's not lower mid is high okay very simple all right next the plan here is to use a switch statement that works off of whichever button was clicked to populate a vector that contains the names from our param names enum that we can use to look up the parameters once we have that vector we can easily figure out which parameter to use with each attachment we have our band type from this lambda now we simply switch based on this band type let's let the autocomplete fill out all of the cases for us switch band type let's get rid of these and press build and wait for auto complete to tell us that we are missing enumeration values there it is all right add missing switch cases thank you let's reindent those correctly all right let's get rid of this get rid of these placeholders okay we have all of our cases now in our switch statement we can declare our vector next and then fill it with values from the param names enumeration next i'm talking about this enumeration right here this thing from a long time ago in this project all right let's create our vector next we're going to need our params namespace using namespace params std vector names names okay we can fill in the switch cases next with the param names for the selected bands so for the let's do the low band first names equals let's see um we need to do this and it's going to complain if i don't define the type because it doesn't know what i'm doing let's see this is going to be names if it's the low band then we're using the attack low band we're using the release release low band and we're doing the threshold let's see attack release threshold ratio and the bypass mutant solo all right this is what to do when it's the low band all right i'm gonna put this in curly braces okay we need to do the exact same thing for the mid band and the high band so grab this stuff paste it and just start replacing the values 1 2 3 h i g h okay great all right fix any errors that come up while you're typing it make sure that for the high if the high button is switched you're using high params if the mid button is switched make sure you're using mid params all right so here's the thing to notice from this we are always doing the same order attack release threshold ratio mute solo bypass attack release threshold ratio mute solo bypass same for here attack release threshold ratio mute solo bypass let's define another enumeration for the possible positions in this name vector and we will index into the names array using this position vector so enum position attack release threshold ratio mute solo bypass let's get our param name map that's auto params whoops that begins with the p params equals get params now the next thing to do is to update the parameter that the slider is connected to let's grab that param helper lambda from the constructor and we need to modify it to use the names vector to provide the parameter name so let's go up here go to our constructor we want the param helper copy this thing here copy go back to our attachment function we're going down here after our position enumeration and we need to capture our names vector and we're going to be using our position thing to index and do so let's just change that pos just so we know what we're doing and now we're going to use let's see let me call get param return get param okay we're passing the ap vts yes we are passing our params map and our name is taken from our names vector at the position this thing right here okay so we're looking up um let's see we have our names array and we're pulling out a position from it so if we pass attack into names and it happens to be the high band we're going to get back this enumeration value and then we're going to pass that into get params as the name of which position to get for the map okay it's a little bit of in direction there to figure out all that stuff all right now we need to reset the attachments before we create new attachment i'm not sure exactly why this is necessary as make attachment ends up calling the same destructor of the slider attachment class however if this is omitted then the sliders don't display the correct value when they are refreshed so if i figure out the answer i will let you know but for now just you know trust me on this attack slider attachment dot reset we have to do this for all of the sliders all the sliders and all the for all of the attachment all right let me work on that now now we can change our parameters and add label pairs to our sliders so let's cache the parameters so we are not calling the helper function twice for each parameter now remember that changing the parameter repaints so we need to add the labels before we actually change the parameter so let's get our attack parameter first auto attack param equals get param helper and our position is going to be the position attack okay remember we are using our names thing to look this up all right and our name our names vector is one of these three choices it could be could contain all midband param lookups it could be low band param lookups could be high band param lookups all right that's how all that stuff works okay let's get um let's add our label pairs add label pairs attack slider labels our param is going to be the attack parameter and our suffix is milliseconds all right and now we can change the param attack param excellent now do the same thing for the release param and the threshold param now for the ratio in the constructor if you recall we could not use add label pairs instead we had to manually code them up so let's grab this code because we're going to reuse it actually all this stuff is going to end up getting commented out but let's copy this and actually we need to clear our ratio slider labels ratio slider dot labels dot clear okay all right copy this stuff actually we don't need any of this now because none of this this is all getting set in that attachment um update attachments class we can come with that out now oh we don't need our end cap i'm a big fan of not having any warnings all right way down here at the bottom all right let's get our um our ratio param auto ratio param as a um let's see it's a ranged audio right now we can replace this all right our ratio param is going to be ratio param wrap all right and then now we can change our parameter ratio uh ratio slider dot change param ratio param okay great now we are ready to start updating our attachments so let's use our make attachment class directly ins uh our make attachment function instead of that make attachment helper well we could use that actually let's see where is that helper there's button switcher there's make attachment helper okay here we go grab this guy let's see let's see if we can use this make attachment helper all right make attachment helper first one is the attack slider attachment our name is going to be the names array and we want the position attack our slider is the attack slider okay let's do that for the release slider next now for the threshold slider and now the ratio slider next to the button attachments let's do bypass button first then we'll do solo and finally the mute button all right now we can go to the constructor and delete the code that configures the attachments and the sliders because this function does all of that for us this is a bit of a monster function all right let's go up to the constructor all right we don't need any of this um attachment stuff all right cool we don't need any of this grit get uh get param helper which means we don't need these either is that right can i get rid of that too i can get rid of that excellent all right let's run this switch to the standalone editor that was a big big chunk of surgery we did there on the code out of range why is that happening named that position what is being called here what position did i choose ratio mid band oh uh this is the wrong one okay for this yeah this should not be the names ratio this should be position ratio there we go okay all right there we go okay we're defaulting to the low band that's good all right so to test this out let's uh let's see we're on the low band now let's switch the threshold to like whatever like negative 24. cool let's switch to the mid band that goes back to zero let's switch back to the low band negative 24. perfect all right cool all right the sliders are currently reflecting let's chest the low band i'm going to change this from 50 to 150 whatever go to the mid band go back all right cool that works as expected if i go to the high band and change i'm going to change the release super short so this was five now it's 250 now it's five all right perfect so the next thing to do is to make the solo mute and bypass buttons have custom fill colors to reflect their state then we will make the band selection buttons reflect that state as well so that way if you're on the high band and the low band is bypassed this button will reflect that it's bypassed even though these buttons are currently showing the high band state we'll do that next let's close this let's make a commit of what we did what did we do we added let's see wired up band selection buttons that's a good way to describe it all right let's clean up that constructor um where is that that's here we have a lot of code that does not need to exist let's get rid of this stuff and this stuff all right great let's clean that up stage commence there we go commit awesome all right next we will um next we will adjust the colors that get used whenever you click on a button okay the next thing to do is to make the bypass solo and mute buttons change the slider enablements as well as change the color of the band select buttons also because these buttons are not part of a radio group that means we need to manually make sure that only one button is toggled on at a time that means we need to modify the audio parameters so that only one parameter can be true at a time remember clicking the button changes the audio parameter and the gui then updates itself to reflect the latest value of this audio parameter so we need to accomplish a lot of stuff whenever we click one of these banned control buttons so let's use button listener instead of the button on click lambda to coordinate all of this first things first let's go to our header file and let's inherit from button listener juice button listener let's add a destructor and the appropriate callback all right there we go got my destructor and the appropriate callback for the listener class let's add our band controls as a listener to all of our to our three buttons where are those guys those guys are right here let's do this before we set our name let's do this yeah right here it's fine bypass button add listener this class all right do the same for the solo and mute paste that copy this paste paste let's add the destructor and stop listening to these three buttons put that right here pressure band controls just copy these guys copy these three lines paste it and change this to say remove listener copy paste copy paste copy paste okay the next thing to do is to implement the button clicked function all right let's put this after paint go to the paint function and put it before update attachments void compressor band controls button clicked step number one is to update the slider enablements if you mute or bypass a band if um if a band is muted or the band is bypassed the sliders should be disabled it's extremely common for audio engineers to be adjusting a parameter you know tweaking a knob and they think that the sound is totally changing like totally different wow this sounds so much better when i tweak this knob only to find out that the plugin was bypassed the entire time when they're done it's this placebo effect but it's with audio so implementing this will prevent this from happening so let's call an imaginary function that does this first and we'll implement it next so here we go update slider enablements that's the first thing we will do let's go declare the imaginary function that we just called copy this header file go to the bottom of it put it after update attachments and let's put this right after oh let's give it a return type void let's put this right after our button clicked class for right now void compressor band controls implementation real quick okay here is the logic to implement if the band is muted or bypassed disable the sliders a simple or statement will give us our disabled status auto disabled equals mute button dot get toggle state or bypass button get toggle state if a button is mute if the band is muted or bypassed it should be disabled once we have our disabled state we just set each slider to that state attack slider dot set enabled if the mute button is on then that means disabled is true and it should be disabled if disabled it should not be enabled so we want opposite of that disabled okay if disabled is true then enabled should be false so if so we want to pass the opposite of disabled all right do this for all four sliders attack slider release slider threshold slider ratio slider let's try this out run this and now let's bypass and cool we can't we cannot interact with these and now we can perfect all right the next thing to implement is replicating the radio group functionality now we cannot use the radio group functionality that comes with the juice button clasp because those require one button in the group to always be on we don't want that we want to be able to solo and unsolo we want to be able to mute and unmute bypass and bun and bypass and also prevent being soloed and muted at the same time so that's way different okay we need to be able to have i'll show you what i'm talking about we need to be able to have these buttons in toggled off state and radio group will not allow that at least one button needs to be on in the radio group well not at least one button needs to always be having a toggle state of true in the um in the radio group okay so that's why we cannot use radio group let's write a function that is called after this guy that updates the solo mute and bypass toggle states so we need to pass in the button that was clicked so we can update the nonclicked buttons accordingly let's call our imaginary function and then implement what it does next update solo mute bypass toggle states and update it with the button we passed in and we're going to pass it as a reference because yeah because it's yeah let's let's just do that all right let's go declare it copy this function name go to the editor put it at the bottom void and pass in a juice a regular juice button as a reference clicked button excellent all right let's implement it next go back to plugin editor.cpp let's put this after slider enablements before update attachments void compressor band controls update solo whatever that huge name was that we came up with all right the logic here is pretty simple if you click the solo button on toggle the mute button and the bypass button off if you click the mute button on toggle the solo and bypass buttons off if you click bypass on toggle the mute and solo buttons off and if you click a but if you click a button off don't do anything and we need to remember to send the notification as that is what alerts the parameter attachment to update the audio parameter all right so here is what this code ends up looking like i'll show you the first one if the clicked button is the solo button and the solo button was clicked on set the bypass to false and send that notification to update the parameter do the same for the mute button set the mute button to off and send the notification all right now we need to do the same thing for the mute button as well as the bypass button okay there we go if the clicked button is the mute button and the mute button was toggled on turn off the bypass button and turn off the solo button if the clicked button is the bypass button turn off the mute button and turn off the solo button let's try this out we should be able to click on the buttons and only one should be toggled at a time all right solo mute mute bypass bypass off solo on soul off mute on mute off all right cool that works as expected so the next thing is to make these solo mute and bypass buttons use a custom color whenever they are toggled let's make a commit before we go any further what did we do we added um let's see we uh added solo mute bypass click functionality that's a i don't know any other way to describe it and that's a pretty good description of what it's doing um added extended click functionality all right commit that stuff okay all right like i said the next thing that we have to do on our todo list is to make the band buttons for um first we have to make the solo mute and bypass buttons show a custom color whenever we click on them and then we need to make the band select buttons reflect that state of the band but before we do that we're going to do something else before we tackle the next item in the band controls to do list let's create separate files for all of the classes we currently have in editor um editor.h and editor.cpp so these this these two source files are getting pretty cluttered so what we're going to do is one class or namespace per source file so here is the process we're going to use producer to create a new set of source files we're going to migrate the class over and we're going to repeat this until all nonoriginal classes and namespaces have been moved into their own source files once that is done we're going to correct all of the include directives and keep trying to build until it builds successfully so let's go over to producer let's sorry let's go to our header file first let's go all the way to the top alright first thing we're going to do is look and feel okay first thing we're going to do is look and feel new cpp and header file look and feel all right that went in the wrong place let's get rid of that put it here look and feel all right save and open now go to plugin editor and just start migrating stuff over okay let's do the cpp file next this is an instance where it's very helpful to use the assistant editor all right that's one class oh we don't need this anymore let's get rid of that okay let's do rotary slider with labels and we will put the ratio slider in that class as well because it's you know it has like minimal there's no reason for it to be its own to be in its own separate source file so we'll grab all of this and put it there okay let's do ratio let's do a rotary slider with labels rotary slider with labels grab these guys cut paste and we need our juice header we need to copy these functions collapse collapse and ratio slider okay cut and paste all right next we can do our buttons the analyzer and the power buttons these guys are implemented in class so we just need a header file for that well you know let's do header and source custom buttons cut custom buttons include juice header all right let's move this analyzer toggle button copy paste add the fully qualified name and get rid of this there we go and we don't need the override keyword okay uh placeholder component and we can leave that we do need to yeah we'll just add those as like um we'll just do like utility utility components utility comps utility components okay copy these guys paste them here juice header plugin editor all right our placeholder constructor might as well put the paint function there and now our rotary slider there we go okay next all right we need some utility classes for all of these templated guys utilities i'm just going to call it utilities all right let's see we need to move make attachment that goes here what else goes here um get param that should go there get vowel string declaration of it that should go there let's grab um get val string that goes here let's see um we can do this truncate kilo value that's templated so that can go here as well and then add label pairs all right let's see what else should go there i think we can use our draw background function where did that go that here that's in this class draw module background let's do that one too that should move as well cut this put that at the end of this cpp file and grab the declaration okay all right now we need a compressor band controls compressor band controls all right you know let me let's organize these let's see sort alphabetically there we go okay plugin editor dot h let's grab compressor band controls paste it here and don't forget the juice header all right let's collapse all of these so they're easy to copy sized paint button clicked update enablements update solo mute update attachments okay copy all of these over all right what do we have left global controls okay last one global controls all right plugin editor we need our global controls paste them here include the juice header and now let's grab our global controls from the cpp file collapse all these down okay cool it's just three functions very cool all right and is there anything in plugin processor yes we have our params let's do that next params let's add the juice header and we can probably move this to the cpp file um it's not necessary though all right next one is compressor band let's do that next compressor band all right let's copy this guy over okay include juice header awesome and let's see we can do all of this cpp file very simple all right just turn all these into declarations oh you know we're here we can check off some things we did our global controls those are done we have added our main band controls that's done we added solo mute bypass and we did band select functionality very cool so we have split all this stuff up and if we build it we're going to have a ton of include errors let's fix that stuff next the way that you do this is just start building it and tackling the errors expected namespace so we need to include that include params.h just start building it until stuff disappears all right compressor brand control unknown type name rotary slider with labels let's include that include rotary slider with labels go to the next one ratio slider that's part of that class that's fine um okay button listener let's just see what it does let's just start clearing stuff out look and feel needs to know about the rotary slider with labels class in the cpp file include rotary slider labels you need to know about our utility function kilo value include utilities i believe is what i called it yes uh plugin processor you need to know about the compressor band all right plug an editor you need to know about look and feel include look and feel what else do you need to know about you need to know about global controls and compressor band controls include global holes include compressor band controls global controls you need to know about rotary slider with labels global controls constructor you need to know about params all right placeholder where is placeholder located include utility utility components that's where that was all right global controls needs to know about get param that's in utilities all right cool power button you are located in those custom buttons is that what it's called that will be called that file yes all right draw module background that is found in the utilities i need to know about the params oh build succeeded all right let's run it let's see if it looks the same fantastic all right cool let's make a commit of that all right refactored into separate files that's huge there's our compressor band custom buttons global controls and actually what i want to do uh before i commit that i actually want to put these into dsp and source folders so here is let's see programming simple mbcomp uh not build source i'm going to add a new folder i should have done this when i created the files all right click um how do i make a new folder in here new folder dsp and then i'm gonna make another new folder gui all right dsp stuff goes in here compressor band goes in here that's in dsp params is part of dsp um everything else seems to be gooey gooey look and feel is definitely gooey custom buttons compressor band controls is definitely gooey rotary slider with labels is definitely gooey and utility components is definitely gooey utilities this is all gooey stuff so we'll just leave it in there all right now let's fix this by deleting this so we'll just delete the entire chunk just remove the references and just drag the whole source file in perfect save and reopen okay now we need to fix all of these includes now that they are organized correctly so let's do a build and start fixing errors look and feel not found because it is found in gui like that all right global controls all those are in the gui we can really just look through this okay this is um params is fine let's see compressor that's all going to be in there so it's really just plugin editor that needs this stuff and then plugin processor needs that stuff that way all right params you are going to be located in dot dot slash dsp like that right include dot dot slash dsp params yeah that was right okay all right any of these files that need it are going to be the same this is dsp slash same for global controls all right build succeeded let's run it just to make sure cool all right now we can make our commit let's just stage all of this okay here's our compressor band let's look at this all right compressor band that's cool that's cool also cool all right because we didn't we opted to not move this to the cvp file okay compressor band controls all this stuff all right this is fine let's commit these 23 files okay great that was an epic refactor but now our plugin editor is much simpler let's customize these button colors let's enable the ability to customize the color per button by using the find color member function of the component class these are toggle buttons that we're currently doing uh but we will use the text button color ids to figure out which color we want let's i just want to show you which ones i'm talking about if we go to draw if we go to the toggle button class and then actually go to the text button class there are several color ids that we can use we can use color id when the button is off when it's on and then the text color for when it's off and when it's on okay so we'll be working with that stuff all right let's work through this revision let me show the code first all right we are calling set color twice right here and right here one for the background that's what the first one does when we fill our rectangle and then the second one for the border that's what this one does and then the text that's what this line does okay for the background we want to use the button on color id and the button off color id okay the trick is to remember to call find color on the toggle button itself that means we need to remember to set both of these colors the button on color and button off color we need to set both of these on the button itself in order for this find color lookup to actually work we're going to customize the border color later when we work on the color scheme for the entire plugin so for now let's head back to the compressor band controls class and assign some default colors for these guys head over to compressorbandcontrols.cpp all right we're going to do this after we add our uh after we set our low bands name we're going to um we're gonna do low band and we're gonna set the color and we need to do the on color and the off color so low band dot set color and then we need to provide the name we're doing juice text text button color ids and we're doing the button on color for this i'm going to do gray all right for the off color let me copy this for the off color i'm going to do black now don't forget the on button and the off button color need to be set for this to work all right let's do the same do the same thing for the other two bands all right we just need to change the names here high band high band all right next let's set the colors for the bypass solo and mute buttons when these buttons are toggled on they should each have a different fill color i'm gonna go with yellow for bypass greenish for the solo and then red for the mute because usually when a button when a track is muted on a like an actual console it's got a red led all right and then if you solo it it's i don't know maybe it's yellow or whatever i don't know i haven't looked at a console in a while regardless let's add these colors next all right here's the bypass we'll do the bypass button first set name okay first color i'm going to do for bypass i'm going to do yellow and black yellow when it's on and black when it's off for this is the fill color not the border color the solo button next i'm gonna do lime green and black and the mute button is gonna be red and black red when it's on black when it's off okay let's test this out let's do a quick run all right cool so we get gray when it's selected that's cool and this is yellow this is greenish and red all right fantastic the next thing to do is to make the band select buttons these guys right here we need to make their fill color reflect the state of the band if the band is soloed then we want this button to be green if the band is bypass we want this to be yellow if this is muted we want it to be red every time we click a button we need to refresh these colors for the active band so let's head down to the button clicked function next all right head to the header file and we're going to add a pointer right here that is going to keep track of which band is the active band this is based off of which band select button is currently toggled on juice toggle button pointer active band and it's going to default to the low band right now we need to update which band is the active band whenever we make new attachments go to the cpp file go to update attachments and we can do this in the switch statement if we click on the low low button then we need to say that the active band is the low band if we click on the mid band and it's the mid band click on the mid band button the active band is the mid band and then finally if we click on hi active band is the high band what's cool about this is we don't have to check toggle state to figure it out all right let's go back to button clicked alright let's call another imaginary function update the active band fill colors let's call it first then we will declare it and then implement it update active band fill colors and we'll pass it the button that's currently being used all right let's go declare it next go to the header file let's put it down here void update active band fill colors juice button clicked button now this function is basically going to call active band arrow set colors with specific colors let's go implement it now copy this thing go back here and let's put this above update slider enablements put it right here compressor controls update band fill colors um what's it called yeah that's right oops let me just use autocomplete there it is okay first things first let's make sure our active band is valid i don't see why it would ever be but just you know just make sure all right and let's print out the name just so we know what's going on active band active band get name next if the button's toggle state is off we need to reset the active band's colors back to the default colors so let's call an imaginary function for that if clicked button dot get toggle state is false if the button is off then reset active band colors we'll fill that in we'll implement that in just a moment otherwise we need to refresh the active bands colors and we need to pull the colors from the button that was clicked so let's call another imaginary function refresh band button colors active band and the clicked button okay let's implement reset active colors next first let's declare it header file void reset active band colors and let's put this above slider enablements void compressor band controls reset active band colors so first the button was clicked off let's restore the active band to the default fill slash off colors active band set color and we're going to do the button on color text button color ids on color and we want to do that gray color juice colors now we're currently using gray for the default color but we will eventually build a system that lets us look up colors from the global color scheme it's going to be similar to that params names system that we built earlier but it's going to be for colors okay let's implement the other function after we do the rest of this all right so we've got our active color for on is this and then we need to do the off color and we're using black here now changing the color doesn't cause it to repaint so let's do that next let's implement the other function refresh band button colors let's declare this guy right here this one right here copy it go to the header file void let's make it static so we can use it with any button pair that we need static and the first thing is going to be juice button and then juice button color source we're going to pull colors from the color source and apply them to the to the first param let's go to the implementation cpp file uh put it above reset void compressor band controls refresh okay we're going to do band dot set color and now we need to copy copy the button on color id from the source to the band button on and we're copying um we are copying color source color source dot find color this thing since we want this color to persist when we change the selected band we need to also set the off color to the color sources on color and what i mean by this is if i click the solo button on the low band and then switch to the mid band i still want the low band to show i still want the low band select button to show me that it is soloed and when you switch bands it uses the off color when it's no longer toggled on so that's why we have to do it this way so we go band dot set color i can just copy this line okay we are setting the off color button color id to the on color of the color source and then once we set the colors we need to repaint the buttons and dot repaint all right let's test that out all right let's bypass and switch to the mid band and it still shows up as yellow so that's awesome the only issue is the text is white instead of black and then if we switch back this is cool all right solo let's bypass you very cool solo and bypass very cool all right that's awesome that works as expected so that is fantastic all right here is a test what happens if we mute a band other than the low band let's see uh let's just me let's mute the mid band let's quit and relaunch what do you think is going to happen okay the button the mid band button does not reflect the state of the band when the gui opens once we click on the band it happens so we need to update the band select button colors when the gui is loaded disable that guy now we'll leave that on actually it's a good way to test okay so let's write a function that does that and it's only going to be called from the constructor as the band select buttons reflect the band state correctly after the gui has finished loading and one of the buttons is clicked okay so this is just like we only have to do this in the constructor all right let's declare it first we're going to call it update band select button states go to the header file let's put this down here void update band select button states all right here is what it is going to do number one it is going to query the audio parameters for all three bands um for their solo mute and bypass states it is going to update the band's select buttons fill color appropriately back again huh you want some more time on camera is that what this is just going to make all the noise now all right here is what this function will do it is going to query the audio parameters for all three bands um it's going to look for their solo mute and bypass parameters and it's going to update the band select buttons fill colors accordingly this function again is only going to be used during construction to ensure that the band select buttons show the correct colors when the gui is initially loaded let's go call it in our constructor where is our constructor it's here at the top and we can do this after we um after we update our attachments and before before we make the low mid and high bands visible and we also need to enable we need to configure enablements as well so let's do that to update slider enablements and then we can do update band select button states let's add this before update slider enablement just a good place to put it void compressor band controls update ban select button states all right here's the algorithm for this function number one query the following params in the following order solo mute bypass if a parameter is on set the band select colors accordingly do this for the low mid and high bands i want to do this in a loop so let's make a vector that holds all of the program name enum entries that we need to use go check this out first we need our params namespace then we need our array of param names to check next we need to get to the parameter in question as an audio parameter bool so this will let us check if the parameter is true or false easily let's get our params const auto params equals get params and then let's make a helper auto param helper equals lambda lambda lambda let's back up on screen we need our params and we need our apv do we need ap vts yes we do but um i'm lazy we're just going to capture this and we also need a name to pass in let's see let's implement this first return dynamic cast juice audio param i never hold down shift long enough audio parameter bool and we want our get param this function which returns a point or returns a reference we need to point to that okay we need our params we need our name let's pass that in const auto name and then we need our ap vts all right great now we just need to loop through our vector of params to check and do some magic inside this loop all right so four size t zero is less than params to check size right let's get a list so this is the name of the params we're going to check so auto list equals params to check whichever entry we're on so we might be iterating either iterating through this list we might be iterating through this list might be iterating through this list let's figure out which band is currently being updated based on our index auto band button equals if i is zero then we're working on the low band otherwise if i equals 1 then we're working on the mid band otherwise we're working on the high band all right now we simply check the solo parameter the mute parameter and the bypass parameter if any of these are true we can use the static function we wrote to change the colors of the band button declared here if auto solo equals param helper first entry in our list right here we could use an enum but this is fine all right if it's this and solo get this is going to return true or false then we can do refresh band button colors and our band is going to be the band button and our color source is going to be the solo button okay let's check for the mute parameter else if auto mute equals param helper list one mute get refresh the band button with the mute button colors finally else if auto bypass equals param helpers list two last one oops that's not where that semicolon goes all right if it's the bypass button that's currently on then update our appropriate band button with the bypass button all right let's test it out all right cool the mid band is currently on so that test worked as expected i'm going to change this to solo i'm going to bypass you and i'm going to change you to muted all right let's save and quit and rerun we should see them as expected all right cool and the low band is muted which it means uh these are bypassed mute band is soloed and the high band is also muted so those are disabled so that's perfect all right and solo and bypass all right cool that is some excellent gui functionality helpful for the user let's make a commit of that dialed in custom band control colors all right good times good times let's look at our road map we have our bands reflecting this we're done with that all right and we have we got custom look and feel going so we can um we can mark that one off as well we are up to the spectrum analyzer next uh okay we're gonna do an overview we're gonna migrate it over from simple eq we're gonna get it working and then we're going to um we're going to get it drawing and then we're going to customize how it draws then we're going to add bypass functionality to the analyzer and to all bands at the same time so we still got a decent chunk of stuff to do i'd say we're about maybe 60 of the way done so the next thing we will tackle is getting the spectrum analyzer from simple eq into here if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming for musicians.com and you can message me directly in the slack workspace and i will help you directly all right spectrum analyzer okay a lot of code surgery in this one if you have not completed the simple eq project we will be reusing the spectrum analyzer and related classes from that project so you might take this opportunity to pause this video and start watching the simple eq videos so you can learn how to build that spectrum analyzer before you copy the code over to this project either way we are going to visit the simple eq repository and copy over the appropriate classes and get our spectrum analyzer functional before we start modifying it let's do that now go to your browser go to the spectrum go to simple eq and we're going to go to the um the plugineditor.h okay we need to copy over what is this thing called this is called the response curve component if we go down here we've got our let's see where is this thing yeah it's just called the response curve component okay for whatever reason that's what i decided to call it um i don't remember why but that's what i called it instead of spectrum analyzer but we will be renaming it here because it will not be displaying the response of a filter one of the first things we will do is remove the um the response curve display from this all right let's go grab this class response curve component copy this okay copy all of the response curve component copied it and now let's paste it in our plugin editor dot h paste it above the editor and let's um let's see we're going to replace the placeholder we're going to replace this placeholder here for analyzer with an instance of that response curve component analyzer okay now let's figure out what else we need to copy over by trying to build it and obviously we need to copy over the cpp files so let's grab those as well go to source go to plugin editor and now we're looking for a response curve rotary slider here we go response curve components all right paint function get frequencies get gains get x's draw background grid draw text labels uh resized parameter value change process timer callback update chain get render area get analysis area grab all of these functions copy them go to plugin editor dot cpp paste these all at the top okay let's try to build it okay first thing to do is to change this constructor parameter to be the audio processor for this project so go to plugineditor.h let's grab a copy of this simple mb comp audio processor and let's change that here simple audio right and same for right here okay we took care of this member variable and we took care of this constructor all right let's try building it again that should take care of those errors all right cool let's get rid of this mono chain we don't need this we don't need the response curve uh we don't need the response curve member variable and we don't need the update chain function next let's see okay we need path producer so let's go grab that from our repository let's see that's going to be in the header file first plugin editor dot h we want path producer where are you path producer there you are okay path producer copy all right put this at the top above our response curve component paste that okay next we need to copy over the single channel sample fifo now the explanation for how this thing is built the single channel sample fifo can be found in project 11. so if you're interested in learning how this thing gets built you can uh sign up for that course this is going to be found in pluginprocessor.h from simple eq so let's go grab that source plugin processor dot h all right single channel sample fifo copy that and let's paste it above our path producer actually uh this needs to live in pluginprocessor.h so let's put it there let's put it above our class declaration for our processor we need to copy over the channel enumeration from simple eq let's do that next go back to the repository and grab this channel enumeration i really don't know why i chose to do the right channel first and the left channel second because left is always channel zero right is always channel one but i'm stuck with it now changing it would be a huge um huge code revision so we'll just leave it as it is all right put this above single channel sample fifo in plugin processor dot h all right let's build this and see what happens okay next thing is it wants a fifo so let's grab that as well from simple eq where's that that's right here here's our fifo make sure you include the array class that's part of the fifo fifo needs that i put that above the channel enumeration again if you want to learn how to build this fifo from scratch and all the design decisions that come with it you can check out any of my advanced plugin courses because they all use it project 10 uses it project 11 uses it and project 12 uses uses it all right let's build this again let's see if we have any more errors in the single channel sample fifo none okay cool all right let's go back to the editor editor.h and uh cp and editor.cpp and get the rest of these classes working okay let's change these references right here to the simple eq change it from simple eq audio processor and change them to our simple mb comp audio processor that goes there that goes there build that all right it says no member named block type in simplemb comp audio processor all right let's see what this block type is go back to the repository um let's just look for block type let's see what our options are okay there it is using block type equals audio buffer so it's just an alias so let's um it's public let's just copy this line and put it in our plugin processor dot h and let's also copy over these two channel instances these two single channel sample fifo instances as well that are declared right below it let's copy those all right plugin processor go down to the end of the public section after ap vts is declared and put them right there all right let's do a little build and see what errors are left okay build failed all right block type disappeared so that's cool all right what do we got next okay we need this fft order type we need that so that is found at the top of where is that found it's in here somewhere let's see let's check plugin editor there it is fft order all right let's copy that let's put that at the top of our class at the top of our editor header file all right let's try to build it and what do we have here oh that's cpp file stuff let's fix that while we are here um go back to the plugin editor copy this simple mb comp audio processor go back over here run away all right this needs to be changed okay let's try that one more time okay so now we've got an error with fft data generator all right let's copy these over next we're going to grab the fft data generator and the analyzer path generator these are both found in let's see here's fft data generator and here's the analyzer path generator let's copy both of these classes they both go in plugin editor.h above path producer let's try that again again if you want to learn how to build any of these classes from scratch and learn the design decisions that went into them check out my advanced courses project 10 project 11 and project 12. they all use this spectrum analyzer so you'll be able to understand how these are put together all right let's fix the cpp file stuff okay we're getting rid of update chain all right let's see what's next update response curve let's get rid of this function actually we don't need it at all same for update chain that's gone entirely let's just keep building it there's stuff that needs to be removed all right remove this code that uh draws the response curve this line right here and get rid of that entirely all right let's next um okay update chain that can disappear response curve okay this stuff in resize we don't need any of this that can all disappear all right um we don't need any of this update chain update response curve all right let's see what happens next constructor must explicitly initialize okay we need to do that that's down in our header file plug in editor all the way down to the bottom this needs an instance of its audio processor yeah it is the audio processor okay let's try building it one more time all right let's see what we get uh we forgot to make it a visible child go to plugin editor and let's add our analyzer make it visible all right here we go let's see what we get there it is we have our spectrum analyzer in place that we can start modifying it uh let's rename it next and then modify it to display what we need it to display okay let's rename this class to spectrum analyzer right click refactor rename spectrum analyzer okay cool let's clean it up next all right let's delete these all right let's see if there's anything left in here that needs to be deleted i think we removed a lot of stuff earlier instead of just commenting it out yep that's it okay all right let's make a commit now that we have a spectrum analyzer added spectrum analyzer and associated source associated classes all right it's not wired up but that's okay we'll do that next well first let's refactor into separate files all right so we'll do what we did before we've got all of these classes so one source file one class one source file go over to producer and let's see first thing we're gonna do is add fft data generator fft data generator all right just paste that here include juice header dot h all right next let's do the analyzer path generator uh collapse it uh sorry yeah let's collapse these first this will make it easier to see what we have to do all right three classes analyzer path generator path producer and spectrum analyzer okay so let's see these are all in the gui spectrum analyzer and let's see path producer path producer and then analyzer path generator is just a header file analyzer path generator all right let's take care of these all right let's do spectrum analyzer first cut paste this here and don't forget the juice header alright next is path producer and don't forget the juice header include oops not that one choose header and then analyzer path generator include juice header.h what else do we got there's something in uh that's it for this guy so let's migrate over stuff from cpp let's collapse the spectrum analyzer collapse all of these let's grab all of them it goes in spectrumanalyzer.cpp all right next um let's see fft order let's put this in utilities put this at the top all right and then plugin processor dot h has single channel sample fifo and the fifo class so let's add these to the dsp dsp folder add new header file fifo make sure that's dsp folder fifo.h and then single channel sample fifo all right all right channel can go with the single channel sample fifo class put this here include juice header.h let's migrate over the fifo and include the juice header okay all right now we can fix all of the includes try to build let's go through the errors plug and processor needs single channel sample fifo include dsp single channel sample fifo we got no let's see where was that name no template named fifo so let's include the fifo here what is wrong with this oh yes okay unknown type name spectrum analyzer let's include that include gui spectrum analyzer spectrum analyzer does not know about the path producer let's inform it include path producer path producer does not know about the fft data generator include fft data generator include what's the other thing analyzer path generator all right fft order that was in utilities uh that wasn't gui utilities no template named fifo include dot dot slash dsp fifo all right path producer we can um we need to include the audio processor include um let's see dot slash plugin processor dot h all right build succeeded let's run it just to make sure all right cool let's commit that refactor all right refactored separate files set bar 8 file 3 vector all right we will run audio through the spectrum analyzer next and get it to display what it displays let's remove some stuff from our road map we have not looked at that for a while go to the pluginprocessor.h wait at the top let's see what do we got left all right we've done our spectrum analyzer uh we have our data structures for it we need to do let's see this needs testing and then we need to get this working this is what we're gonna do in this issue all right let's tackle this one number nine fifo usage in process block this is where we will feed audio into our single channel sample fifo head on over to pluginprocessor.cpp go to processblock before we apply our gain let's send our incoming audio into the fifos for the spectrum analyzer so the spectrum analyzer is going to show um it's going to show the incoming audio before any gain reduction left channel fifo dot update buffer right channel 5.0 update buffer all right let's switch to testing out the vst version and run some audio through the plugin pst3 run let's see what happens j sertion aha we forgot to prepare i'm glad this guy was here this was smart if uh yeah if i hadn't done this uh who knows what this thing would do all right let's go fix that go to uh plugin processor dot cpp go to prepare to play and we need to prepare our fifos put this down at the bottom left channel fifo dot prepare samples per block right channel fifo prepare samples per block all right now let's try it all right let's play some music through it headphones if needed excellent all right let's test the accuracy next just to be sure and save this quit let's make a commit wired up um spectrum analyzer to incoming audio stage u that's that yeah it's funny these two lines of code are these four lines of code are what make the spectrum analyzer actually work that's good times all right we're going to verify the spectrum analyzer accuracy next to verify the accuracy of the spectrum analyzer we're going to need an oscillator to generate a test signal now we could use a daw for this um but i'd rather use internal code to do that so let's go down to the bottom of our header file and after our split bands class let's give ourselves an oscillator the juice framework has one it's part of the dsp module we will use that let's go to prepare to play next we need to configure it let's do this after our fifos let's initialize to prepare it and then set the frequency we need to provide a lambda that takes in a position within the circle of pi and returns a sample float x this is our position within the circle of pi oops um and we can just do return st sine of x this is going to generate a sine wave all right let's prepare it all right let's go down to where we are updating our state plugin processor.cpp process block okay let's do this after update state the move here is to clear our buffer and fill it with samples from the oscillator so let's give ourselves an if block let's just say if true if it's true you're going to do this thing you're going to do buffer clear then you're going to you're gonna fill it with oscillator samples do an audio block from the buffer do a context and now we can do ask.process right this is going to fill up the buffer with samples from the oscillator all right this is going to be super annoying to listen to because it's going to be a full scale sine wave at 440 hertz so i suggest muting your speakers i'm not going to use headphones for this what we are looking for is a single peak in the spectrum analyzer at 440 hertz where did 440 hertz come from it came from right here if we go to the oscillator class way down at the bottom the default frequency is 440. that's where that comes from because you'll notice we did not set a frequency with that said turn down your headphones possibly turning them off or unplugging them or turning your speakers off and switch to the standalone version and now let's run it we can test other frequencies that line up with grid lines later for now we want to see this peak hit the zero db line oh let's change all right let's try that one more time okay so it's pretty accurate in terms of uh the the pitch let's try 500 and then 2 000 okay those frequencies are actual lines on the grid so we can go up to our prepare to play and this is where we will set our frequency ask dot set frequency is that what it's called yes it is all right let's do 500 let's test this out all right that's pretty accurate let's do uh 2000 hertz all right that's basically right on the money all right let's add a gain processor and test negative 12 db since that is a grid line on the scale on the left i'll show you what i'm talking about real quick that's over here this line right here this is negative 12. let's go declare it go to the plugin processor.h after the oscillator go back to um plugin processor.cpp we need to prepare it let's do that after our oscillator gain dot prepare spec gain dot set gain decibels negative 12.f all right now let's just process the context with it process block gain.process ctx okay let's test it out okay what i am seeing is that the peak is not at negative 12 it should be lining up with this grid line and it's not it's a bit lower than that and if we turn the gain off let's comment this out it's below the zero db line which is this line right here so there is an issue with the spectrum analyzer mapping that we need to solve and i want to test a few more frequencies though just to see if it's an issue with the amount of energy in that particular frequency band so let's try 50 hertz next go to um prepare to play let's try 50 hertz all right let's try 50. okay this is definitely below zero db and we're not applying any gain let's try 1 000 okay all right so we definitely have a mapping issue with the spectrum analyzer let's investigate that next let's go back to process block let's turn on our gain processing real quick all right as you can see the fft is not correctly displaying our test signal it should be displaying at negative 12 but it is not it is much lower than that i want to make the gain adjustable while we figure this out so let's use juice live constant to give ourselves this option this will give us a slider to drag in a popup window and we can use that to adjust the test signal level let's close this let's right here we will go gain dot set gain decibels juice live constant negative 12. notice i'm using negative 12 not negative 12 dot f that's because if i do dot f this will give us a float and i want to do integers so that way i can have um steps of like 12 11 10 9. okay let's try this off oops cancel let's try this one more time building all right here's our live constant editor all right so now we can drag this slider let's see how far up do i need to go to make it zero i have to go about 5 db maybe 4 db up to get it to line up with 0. so there's something going on with how the test signal is being mapped vertically to the screen coordinates let's solve that let's head on over to spectrumanalyzer.cpp and we're going to go to the paint function all right let's get rid of this y transform and see what happens we're going to put 0 here and we're going to put that on a new line comment it out and put that like that let's do the same thing for the right channel oh i need uh both of these there we go all right do the same thing here put a zero put this on its own line and then put the curly braces on there uh put the parentheses on there online all right let's test and see what happens okay so our setting is negative 12 and now it's showing at right on negative 12. the problem is that we can now see where negative infinity is currently mapped to so there's an issue with where negative infinity is in the rectangle that we are using to convert our fft bin values remember with the rectangle we are using to map these values the top represents 0 db and the bottom represents negative infinity so let's look at the rectangle that we are passing to the path producer all right go to the timer callback we are passing the analysis area rectangle so let's take a look at how this gets computed i go to get analysis area okay so we start with our local bounds here and get render area that's what's going on here and in this function we remove a chunk from the top then we remove a chunk from the bottom then we remove a little bit more from the top and a little bit more from the bottom okay so let me get the whiteboard so i can explain um how we are mapping this stuff okay we are mapping our signal let's see let me let me first step back all right this big rectangle on the outside that is our local bounds let me go this way that's our local bounce and then in our get uh render area this is where we remove a little bit from the top and a little bit from the bottom and that gives us this purple rectangle on the inside then we do get analysis area which shrinks it even further now we are mapping our signal between this area here and here the top line is 0 db let me draw that here this is 0 db and this bottom line is negative 48. however negative 48 is not negative infinity we need down here to be negative infinity so we need to update two things number one the rectangle being passed to the path producer needs to have a proper bottom edge that actually lines up with negative infinity right now it lines up with this it's this green greenish blue one so we actually need to make a rectangle that goes from here like that okay number two we need to tell the path producer that the decibel value number two we need to tell the path producer the decimal value that is negative infinity for that we need to figure out what is the db value of this bottom edge if this is 0 and this is 48 or this is negative 48 what is this this is uh like negative 50 or 52 or something and that's what negative and that is what is negative infinity in terms of uh this mapping of values okay so let's take care of number one first the rectangle being passed to the path producer needs to have a proper bottom edge that lines up with negative infinity let's do that first all right let's go to our timer callback let's set the bottom of this fft bounds right here to our component's bottom fft bounds dot set bottom get local bounds get bottom next we need to adjust the top and bottom values in the function that maps decibels to screen coordinates that is over in the analyzer path generator analyzerpathgenerator.h okay that's right here all right we are mapping the bottom to get height but we need to map it to fft bounce get bottom so comment this line out and do auto bottom equals fft bounds dot get bottom next we are currently adding 10 to whatever the bottom is that's right here in this lambda this magic number is also a source of inaccuracy so let's remove that all right let's get rid of this line we also don't need that cast anymore bottom top all right let's take a look at this and see if we have an improvement okay better now it's mapping negative infinity to the bottom of the screen but this is slightly off right here and if we adjust this if i put this at negative 24 it's still off that way if i go up to zero zero is lined up negative 36 and this is because it is not it's mapping the negative infinity negative 48 to the bottom of the screen instead of this line right here so we need to define what negative infinity actually is in decibels relative to this 0 db line and this negative 48 db line on screen range let's do that next all right let's head over to the path producer and way at the bottom let's add a negative infinity member variable float negative infinity let's initialize it to negative 48 just as a starting point all right let's add a setter function so we can update this in our spectrum analyzer after the component has actual screen bounds void update negative infinity float nf negative infinity equals nf now go to the cpp file all right we need to where's my path producer did i not migrate this stuff over i don't think i migrated this stuff over oh you know why because it's here in spectrum analyzer right there path producer process oops let's collapse that that belongs over here okay okay we need to look for any negative 48s and replace them with negative infinity there's one and here's the other okay this shouldn't make any visual difference but let's just test to make sure all right that's still off if i put it at negative 36 what do we get are we gonna get that same weird uh difference yep that's fine okay and zero zero lines up the top okay cool all right no difference all right let's set negative infinity for the path producer let's head over to the resized function in the spectrum analyzer spectrum analyzer.cpp go to the resized function all right as i said earlier the top line i'll show this make sure your speakers are muted uh make sure you're um yeah well i'll mute this in post okay the top line right here is 0 db this gray line and then the bottom line is negative 48. however negative 48 is not negative infinity we want the bottom of this component to represent negative infinity so first we need to get this analysis area since that area represents 0 to negative 48. let's do that first auto fft bounds equals get analysis area dot to float then we need to j map the bottom of our local bounds from the analysis area range to the decibel range auto neg inf equals jmap all right our source value is going to be local bounds as a float rectangle and we want the bottom of it all right our source range minimum is going to be our fft bounds get bottom and our source range max is going to be f of t bounds get y and our target range minimum is going to be negative 48 our target range max is zero d is zero uh float so this negative 48 corresponds to the bottom of our fft bounds and the zero corresponds to the top or the y the y value and then we are mapping our local bounds the bottom of it based on this set of top and bottom values now we can update our path producers let's print out what the bottom of the window actually maps to in decibels and update accordingly okay let's test this out all right that is almost perfect still not 100 it seems all right it seems like it's a tiny bit off but maybe it's not actually off let's look at the maximum value being produced where the fft bins are converted into decibels and i'd like to think that it should be whatever gain level our gain processor is set to since a fullscale sine wave is being used as the test signal but let's find out head to the fft data generator all right fft data generator go down to the bottom we want to see the maximum decibel level that the fft data has so let's use juice jmax to find out first declare a local max variable set it to negative infinity this is where we convert everything into decibels so we want to find the maximum decibel level all right now declare a local variable that will hold our converted bin value then use jmax to store the max value between the current max and the converted fft bins value that looks like this auto data equals this thing f of t data at index i equals data and then max equals juice j max uh our data value and our max value let's add a j assert false so we can look at what that max value has j assert false i do not want to flood the console with this max value which is why i am not using a debug macro here all right oh and here's what our negative infinity turns out to be it's negative 49.41 whatever okay let's test this out we need to press the continue button several times until the fft buffers are filled with data but let's see what we get we'll be able to inspect and see what max is set to all right max is negative 41 continue 19 negative 16 negative 16 negative 16 negative 16 negative 13 negative 12. all right 13 12. okay negative 12 3 6 5 whatever whatever okay i'm happy with that yeah negative three six five whatever okay now why is this not exactly 12 it's because our oscillator's frequency is not the same as that of one of the frequency bins so let's change our oscillator's frequency to match one let's comment out this j assert false and head over to plugin processor dot cpp go to prepare to play all right now we're gonna fix this frequency here we need to test with a frequency that lines up with the center of an fft bin the bins are spaced evenly between zero hertz and the sample rate so we just need to divide the sample rate by the number of bins minus one and that will give us the bin width then from there we just multiply this bin width by any number n to find the center frequency of the nth bin i'm going to go with 50 because it's kind of close to a thousand hertz the fft order is a bit shift value so we need to shift 2 to the left by our fft order to get the number of bins then just subtract one since we don't count the bin with a center frequency of zero hertz that's what this looks like comment this out we're going to do oscillator dot set frequency we start with our sample rate get sample rate and then we divide that by uh our bin order which is fft order um let's see what are we setting that to i think we're doing it at like a low value let's see um the spectrum analyzer where are we doing that is that in the path producer class there it is right there fft order order two zero four eight all right let's copy that go back to plugin processor this is the fft order that we want okay we take this value we shift it we do bit shifting and then we subtract one from that and this gives us the bin width and then we just multiply this whole thing let's see this all needs to be in uh um let's see that needs to go this needs to be in parentheses and this gets multiplied by whatever bin i want so i'll do 50. all right this is going to produce a frequency that lines up with the center of one of the fft bins let's check it out all right look at that boom right on the money negative 12 and if we adjust this let's do negative 24 right on the money and negative 36 right on the money all right bug solved the fft analyzer is accurate again i hope you enjoyed um this whole process because this was a really fun bug to solve for me and i'm excited to share how it gets solved because it's a really interesting problem that was good times let's make a commit of that and we've got some extra stuff in here but that's okay we have these guys we'll just leave them in there for now we can turn this off in a minute okay let's see what do we do in the spectrum analyzer um this is mapped to zero this is mapped to zero uh we moved that function all right that's what that is okay path producer um we gave ourselves a means of supplying negative infinity based on the window position um in path producer this is where we just migrated that function over okay and then fft data generator this is where we figured out the max value um i don't know if we need to commit this we can just remove it later an analyzer path generator this is where we corrected a mapping issue stage that all right all right this is going to say corrected fft mapping inaccuracies i hope i spelled that right inaccuracies don't judge me if that's spelled wrong we need to fix a bug in the path producer the float vector operations copy function is not meant to be used where the destination buffer is the same as the source that's exactly what we are doing here this causes undefined behavior and causes address or thread sanitizer issues if that stuff is turned on i can't remember which one it triggers i just remember that it triggered it at one point and yeah either way we need to fix it so we can use std copy instead we also need to make sure that the temp buffer has the same or fewer number of samples as the mono buffer so let's do this first let's add a js search j assert size is less than or equal to monobuffer dot get num samples and now um we can just force it size equals juice j min size monobuffer get numb samples all right so this makes sure that size is set to monobuffer.getnumsamples or size whichever one is smaller all right for this we will need the read and write pointers in the monobuffer auto right pointer equals monobuffer get right pointer channel num is uh we need channel number is zero and our sample index is zero we need our read pointer auto read pointer equals monobuffer get read pointer this one we're reading channel zero and we're starting at index size basically these two lines right here all right now for std copy the first parameter the first parameter is the location of the first sample in the source buffer that we want to copy so that's going to be our read pointer the second parameter is the location of the last sample that we want to copy plus one so wherever we want to copy to the end of that all right read pointer plus here we have our monobuffer dot get num samples minus size all right and then the third parameter is the destination right pointer second parameter is kind of confusing so let's break out the whiteboard just to explain uh before we do that let's comment out the old code okay std copy is annoying because of how it works but it's the right tool for the job in this situation so i'm going to explain what is happening i've got rp representing read pointer i've got um wp representing the right pointer this is the same block of memory okay it's just i'm just showing eight eight bytes for right now okay our goal is to add three samples to the end of our array the way we're going to do that with std copy is to provide the right the read pointer which is at the third index and then our read pointer plus num samples minus the size is the end of the chunk we want to we want to read from and then we say hey where do we want to put this the destination that's the very beginning so again one more time we the first argument is the read pointer this is where we're gonna start reading from then we say all right where's the end and that's the read pointer plus the number of samples minus our size our size is three our number of samples is eight so we get three minus three plus eight is eleven minus three gives us one past um it's basically gives us the index after um the range we wanna copy it's that same thing with like um string uh substring where you say here's the first index and then go up to but not including this other index they're doing the exact same thing here we start at this index we go to this we copy from here up until this index but don't include this index and then we say all right we want to copy all that stuff to the right pointer which is at the beginning and this is going to shift this whole chunk over here which is going to give us our three samples it's going to give us room for our three samples at the end that's how std copy works like i said it's not the most intuitive thing to use but it does not trigger the thread sanitizer or address sanitizer errors that float vector operations do okay so that's um that's how the std copy operation works okay all right we commented out the old float vector operations so we can go ahead and test this out all right no visual difference this is still at zero uh still negative 12 still accurate negative 24 all right cool so that's fine okay cool so we can get back to our roadmap now that the spectrum analyzer has been dialed in and it is now ready for modifying let's go take a look and see what we have left to do all right this is done and this is done all right so we need to do this next all right let's make a commit because that was um that was a pretty decent um pretty decent bug that we fixed fixed um i think it's a sand i think it's address center issue in um path producer stage and stage okay all right let's disable our test oscillator this is extremely simple go to process block and change this to if false we can remove this stuff later if we want to i'm going to leave it in in case i need to do more testing this is more convenient than just com commenting it all out we're just left with a simple warning um let's see all right the next thing to do is we're going to tweak some of these graphics a little bit and then once we do that we're going to do a little bit of refactoring and then we're going to tweak the labels and then that's going to wrap up the spectrum analyzer so let's adjust these background graphics first all right go to spectrum analyzer dot cpp go to the paint function now i want to reorganize this a little bit i want to use the draw module background first that i've been using in other classes so that's the main motivation is i want this to have that same cool border that our other modules have the global controls and the compressor band controls draw module background is in the utilities file so we need to include that that's up here at the top include let's go find it setting is that in the guise yes it is in the gui so it's just right there in utilities i go back to the paint function okay right here let's call draw module background okay this function does not return anything but i wanted to return the area inside the module bounce this area will be where we draw everything and it is smaller than the local bounce so let's change the drawable so let's change the draw module function to give us this autobounds equals that all right we're just kind of saying hey this is going to give us something back all right let's go fix that next let's go to our utilities utilities.cpp all right bounds is what it is going to return bounds is the inner reduced rectangle so let's return that let's uh say that it's going to return a rectangle here and now let's change the return type in the declaration there is that function down here at the bottom rectangle okay cool back to the spectrum analyzer all right the next step is to revise how the background grid is drawn it is currently drawn relative to the local bounds and we need to make it relative to this bounding box that was returned from draw module background so let's revise the declaration first and then pass these bounds to it where we are calling it right here all right go to the header file all right comment out the old one and add a juice rectangle as the second parameter let's copy and paste juice rectangle int bounce all right go back to the cpp file cpp file now we can pass our bounds to this function let's update the implementation next go to the implementation draw background grid let's update this to take a rectangle as the second parameter all right next we need to make this analysis area function take a rectangle as its parameter let's change the declaration first and then the call site and then the implementation go to the header file get analysis area add a juice rectangle as the parameter all right that updates the declaration go back to the cpp file all right let's pass in the bounds now and let's update the implementation next this is way down here get an get analysis area change this juice rectangle int okay we need to make get render area compute its result based on this bounce that we're passing in so let's revise that function as well and then after we finish that revision we will update the implementation let's go to the declaration and add a rectangle as the parameter back to the cpp file and now let's update the call site here we can say bounds equals that and this is no longer an auto now we can update this implementation here pass inbounds all right we are providing a bounding box now so we do not need to get the local bounce okay let's go back to where we were in the paint function because we have a few errors now since revising get render area and get analysis area we're going to get to those though let's go back to the paint function okay let's get this compiling before we continue first of all we need to pass our bounds to this uh to these functions that want a parameter so response area um is provided by get analysis area and that requires bounds in draw text labels let's draw text labels let's see what error is our first spectrum analyzer okay this one um let's see just looking at my notes here draw text labels is what it says to do next all right draw text labels needs a rectangle because get analysis needs a rectangle so let's make draw text labels receive a rectangle as the second parameter and let's call that here bounce and let's update that declaration real quick go to the header file draw text labels okay go back to our cpp file go to that paint function one more time okay we're down here and draw text labels let's pass our bounding box here um let's add our bounds here into this get render area and in this one as well bounds are there any others in here okay let's do a quick build okay we need to pass our local bounds here in our get analysis area so let's get that auto bounds equals get local bounds bounce and we can dri dry this one right here this should just be bounce all right let's see what do we have next okay the last place is um right here let's get analysis area so let's dry this getting the local bounds auto bounds equals get local bounds and now we can pass bounce here and we can use our bounce here all right let's test it out it should all look the same except for having the module border around it all right no module border all right let's investigate paint and see if we missed something aha this fill path is covering up the background let's comment it out see what we get all right excellent we have a module border and we've got this uh line right there we'll deal with that in a little bit um and then we can also tweak these positions for the text labels next that was a lot that was very surgical let's make commit of that added uh what do we do we added module border to spectrum analyzer also disabled disabled test oscillator okay here's where we modify draw draw module background to return the rectangle that it ends up yeah it returns the rectangle that is being reduced right here's where we updated our declarations to work with bounding boxes and then here's all the code surgery that we did all right let's move all of this code into its own function let's declare a private member function spectrum analyzer dot h down at the bottom void draw fft analysis we need a graphics and a bounding box we can take that from here all right we're going to pass the bounding box because we're going to draw the paths within this bounding box all right let's go call it spectrum analyzer.cpp draw fft analysis g bounce all right let's implement it we just need to copy this code and then remove it i'm going to put that right up here void spectrum analyzer draw fft analysis and uh wants the juice namespace using namespace juice all right let's get rid of this code here all right let's go to our function because it's got it we have a few errors all right first error is it wants the response area so let's take that from here got that since it's not used anymore that can go here all right let's run this all right everything seems to look okay uh let's do the um we still have that white line but let's run this let's actually run some signal through this now just to make sure you can grab your headphones if you want all right that's still working cool all right let's take care of that white line that's being drawn we can use the graphics reduce clip region function to shrink the area that we are allowed to draw within if we combine this with graphics scoped save state this reduced clip region will stop being reduced once we leave this function so this lets us draw only within this response area which is pretty handy so first create a graphics save state juice uh we don't need to write that graphics scoped stave save state triple s passing in our graphics instance and then let's do g dot reduce clip region response area all right let's take a look at it all right i don't see that white line anymore that's fantastic all right and it's only drawing it within the negative 48 0. that's awesome okay the next thing is to fix these text labels and the grid itself because uh we don't care about you know plus 24 to negative 24. we carry about um plus 12 to negative 60 because that's what our threshold range is that's what we want to see on here okay let's commit this since that was a decent bug to fix fixed um negative infinity line being visible in spectrum analyzer also refactored how fft paths are drawn all right cool all right let's continue cleaning up the spectrum analyzer go to the paint function all right let's get rid of this border we already have a border that's the uh draw module background so let's comment out everything except the draw text labels get rid of that and get rid of this all right let's test it out standalone editor all right cool it looks good all right let's dial in the text labels next all right let's take a look at this all right first things first notice that this text along the top is colliding with uh this border so let's fix that that's in the text labels function let's go to that all right this is where we draw our frequencies right in this chunk right here all right this is where we draw it okay the y position should be the y position of the bounds that we're passing in not one so that's the first fix right there r dot set y bounds dot get y remember we're passing in a bounding box that is inside of our uh module background all right let's look at that all right cool they are no longer colliding that's great see next the text on the right okay this text is colliding with the edge let's fix that again it needs to be relative to the bounding box that we are passing in not the components bounding box let's go where that is that's in the gains that's gonna be this uh set x it's currently based off the components right edge and we need it to be based off of our bounding box right edge r dot set x bounds dot get right minus text width all right the text on the left let's see how that is i'm pretty sure that's colliding too and i can see where right there where did this go all right yep that text is colliding all right so this is good this is no longer colliding that's great this is colliding this needs to be not one to the right of the component left edge it needs to be one to the right of the bounds dot the bounding box left edge oops plus let's look at that okay great our text labels no longer collide let's do a quick commit of that surgical edit corrected uh no fixed text collisions with component edge also uh removed old border all right it is now time to introduce the concept of negative infinity and max decibels as well as min frequency and max frequency these values are constants that we are going to use in this project to ensure we aren't typing magic numbers whenever we need to supply a frequency range we will use min frequency and max frequency let's go define those now head over to utility.h utilities.h plural all right define these up at the top put these right here define min frequency 20 hertz and define max frequency 20 000 hertz next let's define our decibel ranges define negative infinity this is going to be negative 72 and then max decibels will be plus 12. define max decibels 12 dot f finally we need to define our minimum threshold for our compressor bands define min threshold whoops all caps negative 60. our next job is to replace all instances of these values with our macros we will start with the plugin processor there i go to uh what's the name of this function this is create parameter layout let's change this threshold range right here this needs to be min threshold and max decibels whoops max decibels all right let's do a quick build am i including utilities here apparently i am all right cool i did not think i was but i guess one of these classes is including it all right back to the spectrum analyzer all right let's change our mapping first all right we're not going to do negative 24 to positive 24. we are going to do negative infinity to max decibels so comment this out replace it auto y equals jmap our source value is gdp we got negative infinity max decibels and then this is let's see this is going to be um bottom but cast doesn't float and then top cast as a float all right good times all right we need to do this again where else do we need to do that um right here in draw background grid so we're doing it in draw text labels and then we're doing it in draw background grid so we can just copy this first just copy this stuff and let's fix this indentation and you should be all the way to the left all right let's go to the resized function because there's a negative 48 over there all right comment out this line and add negative infinity and max decibels that's the choices all right let's test this out and see how it looks with our test signal we're going to reenable our test signal so be sure to take off your headphones or turn down your speakers when you press the go button put this on true all right let's test it out all right we're missing grid lines it still lines up with the grid line uh but our labels are wrong it says plus 12 to minus 24 and then 12 to the negative 48. so let's fix that next back to spectrum analyzer all right we need to go to the get gains function all right let's change what we are returning here first of all uh let's dynamically create the vector instead all right if we change what negative infinity and max decibels mean it can be automatically reflected here so let's start at negative infinity and increment to max decibels using an increment size of 12. start with a vector of values let's return this return values now we can do auto increment equals max decibels we can change this if we want for now this is 12 db steps now we do 4 auto db equals negative infinity db is less than or equal to max decibels and we are incrementing by our increment db plus equals increment all right let's do values.pushback db all right let's test this out see if that solves our issue with the gains all right that looks good to me 12 to 96. uh why does that say negative okay this one says the right range it says plus 12 to negative 72 which is what we want and all right this is off it's showing negative 12 and it should be showing that should be showing here we'll deal with that all right let's make both sides show the same range first all right let's get rid of the code go to the draw text labels function um there's code in here that shifts the value yes this code right here okay let's get rid of that don't clear it don't shift it all right the only thing that we need to actually change here is the x position because we're drawing the same string uh that we set here this string right here this is the only thing we need to change or sorry this is the only thing we're drawing so we don't need to change the text width we don't need to change the size we don't need to change the color we're just drawing the same string in a different position all right let's test this out we should see the same range same scale range on both sides of the fft now there we go plus 12 negative 72 plus 12 negative 72. all right great all right now uh our fft is not mapping correctly this is negative 12 and it's showing up as zero so let's fix that next go to the analyzer path generator this is the source of the problem the problem here is that we are mapping our y position to the screen coordinates and notice that the upper range is zero and not max decibels so let's change that we want to make this max decibels instead negative infinity max decibels there we go um let's see if do we need to include the utility header for that let's do a build and see see what it does maybe it'll complain maybe it won't all right no complaints that's cool let's run this now all right all right this is pretty good all right let's change this to negative 24. also pretty accurate let's change it to zero all right it might be off by like you know one db or half a db uh but for the sake of this tutorial which is free i'm going to call this good if you really want to know how to make this stuff absolutely perfect you can check out project 11 or project 12 where we create a perfect spectrum analyzer that is perfectly accurate all right let's turn off the test oscillator we no longer need that discard change all right one last test um let's do it with um let's see why did i run the standalone that looks clean now let's let's run some actual audio through it make sure it looks okay run it grab your headphones turn the volume back up so you can hear what it's doing all right fantastic okay cool all right next we're going to draw the crossovers then we're going to draw thresholds then we are going to draw gain reduction and that will conclude the spectrum analyzer let's make a commit of the work that we did what did we do um let's see um standardized how ranges are defined that's that that's what that is um fixed spectrum analyzer labels these should be reversed let's switch that all right fix spectrum analyzer labels and then we standardized how the ranges are defined all right sounds good all right before we go and implement crossovers and thresholds and gain reduction let's go through the code and replace any 20 hertz and 20 000 hertz with min frequency and max frequency where does that happen first all right here's one in analyzer paths generator right here okay this needs to be min frequency and max frequency okay there is another in spectrum analyzer um we just need to search for twenty thousand twenty one two three dot all right spectrum analyzer all right right here in uh the get x's function we're doing min freak and max all right and there should be two more let's just look for 20 000. only look in the actual project source code okay um spectrum analyzer um we're going to keep these hard coded all right plugin processor okay here's one right here this should be min min frequency and then this should be max frequency all right i believe those are the only two that remain all right yes okay cool all right those are the only two let's make sure all right our gain sliders still works our threshold slider still cool our frequency still goes 20 hertz to 20k all right cool good enough for me let's draw some crossovers next if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programmingformusions.com and you can message me directly in the slack workspace and i will help you directly we are going to draw our crossovers next to accomplish this all we need to do is get the frequency value from the crossover parameter map it to an x position and then draw a vertical line the timer callback is taking care of repainting the screen at a regular rate let's go look at um our spectrum analyzer.cpp so you can see what i'm talking about go to the timer callback okay this is repainting at a regular rate so that's good times okay so we don't need to do anything special to refresh whenever the crossover slider is dragged we just need to declare some stuff and add some functions and whatnot that can get the parameter and pull the crossovers and produce x values for us to draw from top to bottom okay let's declare a function for drawing the crossovers and call it first go to the header file spectrum analyzer.h let's do this at the bottom i'm just going to copy this draw fft analysis and rename it to be draw crossovers okay super simple let's go call it go back to that paint function and we're going to do this before we draw our text labels draw crossovers g bounds all right let's go implement it next i'm just going to put this right below the paint function because i'm lazy void spectrum analyzer draw crossovers all right i don't feel like scrolling to put it in the order that it was declared in which would mean it's after that draw fft analysis function okay we are going to be using a lot of juice functions in here so let's set up the namespace alias as always using names namespace juice okay then let's get our bounding box bounds equals get analysis area from our input argument all right next we need to give ourselves access to the two crossover parameters let's go back to the header file let's declare two member variables to do that one for the low mid and one for the mid high all right let's initialize these up to the constructor where is the constructor way at the top all right let's do this before we start our timer using namespace params whoops let's spell space correctly let's get our params map auto param equals get params all right um let's see it doesn't know where params come from so let's include where those come from include dot dot slash dsp params oh uh conflict so let's make this param names all right let's copy the float helper lambda from the plugin processor constructor plugin processor all the way to the top where's that lambda float helper this thing right here copy that go back to spectrum analyzer let's put that here and we need to change the capture stuff a little bit differently we're not using that let's go like that and then this needs to be param names and this is going to be apvts equals audioprocessor.apbts and this we're capturing param names not params there we go okay now we can use it to initialize our members float helper low mid crossover and we want our names low mid crossover freak float helper mid high names mid high crossover freak cool all right we are going to draw a vertical line from the top of our bounds to the bottom of our bounds so let's go to that uh function we were working on draw crossovers and we need to cache the top and bottom let's do that next const auto top equals bounce dot get y and then const auto bottom equals balance dot get bottom all right first we need to map the frequency to a screen position so let's copy the mapping code from our get x's function wherever that is get x's all right here's the mapping code and we can turn we can uh dry this later use a free function if we want let's change this push back into a return statement we're going to stuff this into a lambda go back to our draw crossovers all right auto map x equals lambda lambda lambda all right and here's where we're going to take our norm x and we're going to return left plus width times norm x all right what do we need we need left left equals bounds dot get x we need the width width equals bounce.get width we need our frequency indent that please all right float frequency um let's make this say all right that's nice and readable all right now we can draw our crossovers use the map x function to convert the low mid into an x coordinate auto low mid x equals map x frequency is going to be low mid x over pram get all right uh let's draw a vertical line from top to bottom g dot set color colors let's do orange because that'll stick out and we can do g dot draw vertical line our x is going to be low mid x and our top is top and our float our bottom is all right let's do the same for the mid high auto mid high x equals map x mid high pram get the value drop g dot draw vertical mid high from the top to the bottom let's test it out all right we see some crossovers let's put this right at 200 perfect works like a charm but a 2k default value default value all right awesome let's do thresholds next let's do the same thing for the thresholds that we did for the crossovers go to the um header file we have three compressor bands so we need three threshold parameters let's go um yeah just copy these rename them and we will initialize them in the constructor next let's do one more all right low threshold param let's just copy the word threshold and change this to say hi whoops hi h i g h mid threshold all right cool that takes care of the declarations let's go construct these again go to the uh constructor let's use our float helper to make our life very simple i'm just gonna copy this three times and rename it two three low threshold mid threshold high thresh low threshold threshold low thresh mid and thresh hi perfect okay let's go draw let's go to the draw crossover function and update it to also draw thresholds all right draw crossovers okay here is how we are going to draw these thresholds number one we draw a horizontal line from the left edge to the low mid crossover let me pull the plugin up so you can see what i'm talking about all right we are going to draw a horizontal line from the left edge to this crossover right here all right we're going to use uh the y value is going to be the low threshold param mapped to this decibel range okay then we're going to draw a horizontal line from the low mid crossover to the mid high crossover again using the same y value is mapped onto these screen coordinates then we're going to draw a horizontal line from the mid high to the right edge of our analysis area so we're going to need the left x and we're going to need the right x too all right let's get those guys const auto left equals bounds dot get x const auto right equals bounds dot get right now we can map our thresholds to their y position and then draw horizontal lines let's grab the y mapping code from draw background grid that's this stuff right here and turn it into a lambda copy this go back up to draw crossovers let's make a lambda real quick auto map y equals lambda lambda lambda guts of it is this mapping function we need to capture the top and bottom bottom top and we need to pass in our decibels so change that name db float db and now we just need to return it okay great now we can use it i want to use a different color than the color that i used for the crossover so i'm going to go with yellow colors yellow now we're going to draw the low band threshold from the left edge to the low mid crossover so g dot draw horizontal line our y is going to be map y and we are mapping our low threshold parameter and our left side is going to be the left edge and our right is going to be low mid x okay pretty simple let's test it out just to make sure it works we should see a yellow horizontal line for the low band depending on what it is set to all right cool it is set to negative 23 and i see that this line is right above the gray so that's cool let's put this on 12. all right nice and accurate awesome that is working as expected that means we can do the other ones uh this line is a little bit hard to see i might change this later to draw a rectangle that is you know taller with a center y of this thing whatever this y value is uh but for now i'm just going to leave this as is and we're going to draw the other lines draw horizontal draw horizontal okay we are mapping the mid threshold param and we're mapping the high threshold param our left side is going to be the low mid x and our right side is going to be the mid high x for the mid threshold for the high threshold our left side is the mid high x and our right side is the right all right let's test it out all right let's adjust the mid threshold cool and let's adjust our crossovers fantastic now if you want to make these draggable or if you want to learn how to make these draggable when you click and drag on them you can learn how to do that in project 12. we cover how to make this a very interactive gui so you can adjust all this stuff all right the last thing to do is to draw gain reduction all right we are nearing the end of our road map let's go mark off a few items ah let's make a commit first actually what did we do we um added a spectrum let's see spectrum analyzer shows crossovers and thresholds that's what we did stage um we also adjusted um used macros for min max frequencies all right here's our spectrum analyzer with our draw crossover fanciness we're nearing the end of our road map so let's mark off a few more items plugin processor.h we are drawing the crossovers that's done um and we need to draw the gain reduction so let's do that next let's go to the compressor band class all right first of all we're going to need some atomic members that will store the rms levels one for the input and one for the output all right these should be initialized to negative infinity uh we're going to need to include our header file to make use of negative infinity um these are going to get the rms level of the buffer before and after processing all right let's put these here in the private section std uh let's see i'm doing two of them so i don't want to type twice so let's do the old option drag and do std atomic float um let's see rms level db curly brace negative infinity closing curly brace semicolon all right let's change this to be input and this is output cool let's include um utilities for that include uh let's see yeah utility so dot dot slash dot dot slash all right gui utilities dot h let's just make sure that that's cool all right all right build succeeded all right next we need some getter functions so let's write a pair again i'm going to type it twice float get rms level db these are const functions and they return rms level db colon all right let's fix these names get rms output level and get rms input level and this is going to return the input returns input output returns output cool all right let's go to the compressor band uh cpp file we just need to sample the rms level before we compress and then after we compress our buffer has multiple channels so we want to compute the average rms level over all of these channels we're going to need to write a function to do that i am lazy and do not want to figure out the types that we are passing in so i'm going to template this function because templates are awesome okay go back to the compressor band header file put this after these guys all right this is fairly simple to write first of all we need the number of channels let's uh write a template function now template type name t float compute rms rms level const t buffer okay first we need to compute the rms level of each channel um let me start over first of all we need the number of channels in the number of samples then we are going to need to compute the rms of each channel and add them all together then we just divide this summed value by the number of channels and that gives us our averaged rms level for the buffer let's do that all right so first we get the number of channels and the number of samples then we get a we set an rms level to zero and now we walk through every channel and get the rms level for that particular channel for all samples then after summing them all together we just divided by the number of channels and that is our averaged rms level for the buffer nice and simple all right let's go use this function next compressorband.cpp go to the process function all right let's get the prerms level of the buffer and remember this is not expressed in decibels so auto prerms equals compute rms level buffer okay and then let's get the post rms level compute rms level buffer and i don't want to write juice decibels gain to decibels twice so i'm going to do a helper lambda return juice decibels gain two decibels and now we can use it to store our pre and post rms levels as decibels in the atomic members so rms input level dot store convert to decibels the prerms then rms output dot store convert to db post rms all right the next thing to do is to get these values into our spectrum analyzer head on over to the editor for that plugin editor dot h we need to pull these compressor rms levels poll we need to pull these compressor rms levels at a regular interval so let's inherit from timer next juice timer let's add the appropriate callback void timer callback let's go start the timer in our constructor let's do this after set size i'm going to do a 60 hertz timer so it's refreshing 60 times a second and now let's go implement it let's do this after resized void simple mbcomp editor timer callback all right the compressor bands are not public so let's make them public first before we start polling them here go to uh pluginprocessor.h way down to the bottom move these to the public section all right go back to plugin editor timer callback now that those compressors are public we can create a vector and get these rms levels so i'm going to create a vector so i only have to pass one object to the spectrum analyzer instead of six this means that the function that i write i only have to type one parameter uh declaration instead of six so you know simplify my life a little bit here we go declare a vector and grab the input and output rms levels from each band let's go write a function in our spectrum analyzer to receive this vector spectrum analyzer dot h let's make an update function in the public section void update now we're going to need to compute the gain reduction from the values that we are getting so let's let's see i'm getting ahead of myself all right first let's declare this it's going to take an std vector of float values all right we're going to need to compute the gain reduction from the values that were passed to us let's declare three variables that can hold those values all right three floats let's put these at the bottom way down here with our params float low band gr initialize them all to zero since no gain reduction is happening to begin with float mid band gr okay cool back to the editor let's pass that vector to the um spectrum analyzer uh analyzer is that what i'm calling it updates values all right our analyzer has been updated with fresh rms levels of uh input and output uh gain buffer levels whatever we're calling it rms input levels let's go implement this update function next all right let's go to spectrum analyzer.cpp i'm going to put these below the uh draw crossovers function all right void spectrum analyzer update first let's make sure we have six values j asserts values dot size equals six um i don't know why it wouldn't be that but you know just to make sure all right next i am going to help myself out and give myself an enumeration that i can use to index into this vector and keep track of which indexes point to which rms levels that looks like this all right now i can simply update my gain reduction my gain reduction member variables and then repaint the gain reduction is a negative value usually so we want to subtract the input from the output as the output is almost always lower than the input level so that looks like this low band gr equals values low band out minus values low band in all right very simple all right let's do the rest and then repaint all right in order to draw the gain reduction correctly we need to know the following coordinates per band this is going to happen in where are we doing this we're doing this in our draw crossovers draw crossovers is where we need to go in order to draw the gain reduction correctly we need to know the following coordinates per band the left x the right x where 0 db is as a screen coordinate and whereas the gain reduction is expressed as decibels again as a screen coordinate so let's um compute zero db auto zero db equals map y zero dot f all right we've got the left x and the right x that's what this stuff is and this stuff here so we just need to map the gain reduction before we can draw our gain reduction that's pretty easy to get so let's get our color first i'm just going to give it some alpha so it doesn't cover up the grid lines g dot set color i'm going to use hot pink because i want something that sticks out colors hot pink with alpha give me an alpha of 0.3 f all right now i am going to use the rectangle static function left top right bottom to create the rectangles that will represent the gain reduction and then i'm going to fill them up so here we go and i'm going to draw these behind i'm going to draw these behind the actual threshold levels all right g dot phil rect and we're gonna do rectangle um we're gonna do float and we want the left top right bottom okay our left is going to be left our top is 0 db our right side is going to be the low mid x and our bottom is going to be the low band gain reduction mapped map y low band gain reduction all right let's put that all separate lines okay let's do this again for the next um for the mid band all right so this is mid band it midband gain reduction this one is high band gain reduction okay our left side for this one is the low mid x and our right side is the mid high x for this one it's mid high x and then the right edge all right let's feed some audio through the plugin we're going to test this out we should see some gain reduction uh not standalone we're going to use um audio plugandhost we're going to feed some actual audio through this and we should see some gain reduction rectangles light up let's see what happens do we have any errors nope just the warning about that stuff that's marked false the test signal all right here we go there we go look at that rectangle that's awesome let's adjust the midband get that squishing all right all right very cool awesome okay there are only three things left to do in this project let's save and quit this let's make a commit and then we'll talk about those three things that remain uh this was added added gain reduction display is that all we did yeah that's right game reduction uh timer is part of that here's the gain reduction that's where we passed it to the spectrum analyzer those are our members that display the gain reduction and here's how we actually made it happen and then here's where we compute the gain reduction so this was cool bit of code surgery on this one pretty involved but good times all right let's talk about the major three things we have left to do let's look at our road map plugin processor.h at the top all right we are currently drawing our gain reduction done all right analyze your bypass button that's not going to be difficult um global bypass button that's got a few tricks to it and then the color scheme and the color helper stuff i want to talk about that at the very end so we are nearing the completion of this project i hope you are enjoying the journey let's tackle the control bar next uh the first thing we will do is add the analyzer button just like in the simple eq project this button will toggle the analyzer on and off let's go to the plugin editor.h let's just put this right here all right first things first let's define a class for it okay we already copied the code for this button over earlier that's right here here's our analyzer button so we just need to include that file include gui custom buttons and then we can give ourselves an instance let's put this in the uh just toss it right here analyzer button analyzer button all right next we need a constructor to make it visible and a resized function to give it some bounds plugin editor dot cpp go to the top stick that right here add and make visible analyze button uh let's make it uh toggled on by default analyzer button dot set toggle state should be on true uh don't send a notification all right let's make it sit on the left and be about 50 pixels wide i'm gonna want a small gap between the top of the component let's start our resized function void control bar resized um as i was saying let's make it sit on the left side of the gui be about 50 maybe 60 pixels wide i'm gonna want a small gap between the top of the component and the bottom um and also between the component and the spectrum analyzer so i'm going to trim a little bit off of the top and the bottom of our local bounce auto bounds equals get local bounds an analyzer button dot set bounds and we're going to do bounds dot remove from left 50 and then we need to take some off the top dot remove from top just a little bit with trimmed uh not remove from top we want with trimmed top with trimmed top all right this returns a version of this rectangle with the given amount removed from its top edge so that's what we want with trim to top four and with trimmed bottom all right because we're removing four from the top of this rectangle the rectangle that's 50 pixels that was removed from the left edge we're trimming four off of the top of that thing all right that's the width trimmed stuff versus the remove stuff can be kind of tricky the first few times you use it all right let's get rid of our placeholder once and for all go to the plugin editor get rid of the placeholder control bar and make it a control bar awesome get rid of all this stuff all right plugin editor.cpp let's connect the control bar analyzer button uh to the actual analyzer and toggle enablement accordingly let's do this before we make it visible control bar dot analyzer button dot on click equals lambda lambda lambda semicolon you go on a new line oops and we're going to capture this and we're going to do analyzer dot toggle analyzer analysis enablement and it should be on if the analyzer control button if the control bar analyzer button toggle state says so so let's just get that state bool should i'll use auto auto should be on equals control bar analyzer button get toggle state all right now we just need to make it visible let's uncomment this line let's test her out run some audio see if the spectrum analyzer turns on and off all right let's test her out all right we're going to run some audio we're going to click that button all right perfect save stop quit perfect all right um global bypass is next all right we have included uh let's see where's our header editor file all right all right we already included our custom buttons so let's add our power button next super easy um declare an instance power button global bypass button all right great let's add it as a child go to the plugin editor dot cpp up here add and make visible global bypass button all right let's give it some bounds and um see what we got all right i'm going to make it 60 wide maybe that'll look cool let's see i'm going to stick it on the right side globalbypassbutton.setbounds bounds.remove from right 60 and i'm going to trim off the top and trim off the bottom with trimmed top i'm gonna do a little less than four so i'll do two with that width with trimmed bottom see i might change that later let's see how we see how it looks should see a little power button in the upper right hand corner alright perfect it doesn't do anything let's make it do something alright clicking the bypass button should toggle the bypass parameter of each band before we set up the bypass buttons on click lambda let's declare a function that will toggle the global bypass state all right let's go declare this as private plugin editor.h go down to the bottom put this here void toggle global bypass state all right let's go set up the lambda plug in editor.cpp and do the lambda right after our control bar control bar dot um whoops let me spell that right dot global bypass button dot on click equals lambda oops equals lambda lambda lambda we're going to capture this one more time all right we're going to call our toggle global bypass function all right let's go implement that let's put this after timer callback void simple editor toggle global bypass okay first we need to get the toggle state of the button if the button is off meaning it's green everything should be enabled so auto should enable everything equals control bar global bypass button get toggle state all right again if this is on sorry if this button is off meaning it is currently drawing as green everything should be enabled so if it's off then this should be true if this is off that means it's false which means this should be true so we want the opposite of that all right next we need to get all of the bypass parameters let's write a function to give us that plugin editor.h put it after this uh let's return an array std array all right we are returning three instances of audio parameter bull it's called get bypass params nice and convenient all right let's get to the params auto params equals get bypass per amps let's write this function next all right put this down here std array juice audio parameter bool three of them simple editor get bypass params we need to query the audio processor value tree state for these parameters so we will need the usual namespace aliases and references when looking up the parameters let's do that now all right let's copy the bool helper uh first i need to include the right params file include dot dot slash dsp is that where dsp is no dsp is right there params all right let's copy the bool helper from plugin processors constructor and modify it for our needs plugin processor scroll down for the bool helper copy and put it right here all right so specifically we needed to return a pointer instead of a reference right now this is returning a reference and this is also modifying um it's modifying the input parameter we don't care about that so we're not doing that we're going to return whatever it figures out return param and then ap vts um we can just capture that that should be that um then we need auto declaration here auto param equals whatever param we get from the ap vts casted to a audio parameter bool if the cast is cool this will not fire and hopefully we will return a pointer okay great now we can use the helper to get three boolean parameters auto low bypass param equals bool helper names bypassed low band all right let's do that for the other two bands there we go mid band high band bypass all right now we can just package them into an array return low bypass mid bypass high bypass all right cool all right we have our parameters now whenever we change audio parameters we need to tell the host that it is part of a guester this is so that the host can store these changes in automation let's write a helper lambda to do this we are going to be updating three parameters so the first lambda argument will be the parameter second will be whether or not the parameter should be bypass auto bypass param helper equals lambda lambda lambda first param is the parameter auto param second is whether or not it should be bypassed bool should be bypassed all right now we can begin our change guester param begin change gesture then we can set the params value based on if it should be bypassed or not param set value notifying host should be bypassed then it should be one otherwise should be zero um it's important to remember that set notifying set value notifying hosts wants a normalized value between zero and one all right and then we can end our change guesser param and change guess now we can loop through our parameters for auto param params if everything should be enabled then should be bypassed should be false that means we want the opposite of should enable everything passed in as the parameter so bypass program helper passing the param and should be bypassed is the opposite of should enable everything all right let's test that out all right let's do this okay so the active compressor bands band select button changes the other band select buttons do not for instance this is showing as bypassed but this state is not updated and if we click on those bands like same for the high one it's bypassed but this button is not reflecting that state so we need to fix that we need to update the colors of the band select buttons that are not the active band whenever we toggle the global bypass button let's do that next we need to add a member function in compressor band controls that will update these bands colors so head on over to compressor band controls all right let's declare a public function void toggle all bands bool should be bypassed all right let's put this below button clicked in the implementation button clicked void compressor band controls toggle all bands here is how this function is going to work we're going to use an array of pointers to all three band select buttons and we're going to loop through that array here's the logic we are going to implement if the global bypass button is clicked off meaning that everything is bypassed we need to set every band buttons on color to the bypass fill color and then we need to set every band's off color to the bypass color as well if the global bypass button is clicked on meaning nothing is bypassed we need to set every band buttons on color to the default fill color and we need to set every band's off color to black as this is the default off color when the band select button is bypassed and not the active band it will still display the correct fill color and finally we need to manually repaint after we change a button's color let's implement that now here's my here's my vector of buttons we're going to loop through each button we're going to set the color based on if we should be bypassed we're going to pull it from the bypass button if it should be bypassed and if not we're going to use our default gray color and then we are also going to set the off color if it should be bypassed we're going to use that on color again otherwise we're going to use black and then we're going to manually repaint okay very simple all right head back over to plugin plugineditor.cpp let's call our function now below this band controls dot toggle all bands and if it's if it's if everything should be enabled then it should not be bypassed so we're doing this again all right let's test it out all right all right awesome toggle them on and off okay very cool the next thing to do is to update the global bypass button if we manually bypass each button separately for example if i go low as bypassed mid button is bypassed high band is bypassed this should turn off and then likewise if we have all bands bypassed when the plugin loads then the global bypass should also reflect this let's tackle that next all right the final task is to make the global bypass button reflect the bypass state of the bands if we toggle them manually we are going to use our timer callback to do this let's go look at that real quick all right we are going to declare a function to update the global bypass and then we're going to call it here and implement it next let's go to the header file plugin editor.h declare a private function void update global bypass button go to timer callback and we will call it after we update our analyzer all right it's gonna i'm gonna put it right below timer callback void simple editor update global bypass all right the logic here is pretty simple we need to get all the params all of the bypass parameters we need to figure out if all of them are set to true and then we set the global bypass buttons toggle state accordingly and we need to make sure that we don't send a notification when setting the toggle state if we were to send a notification it would trigger that on click lambda which is something we don't need to have happen because that's gonna fire all this stuff let's get all of our params auto params equals get bypass params we can use std all of to check if all of the params are true bool all bands are bypassed equals std all of params.begin params oops params.end and our predicate is a lambda i am the lambda lambda const auto param we want to see if the param is true or not so return param get finally now that we know whether or not all of the bands are bypassed we just need to set the toggle state so control bar dot global bypass button set toggle state and remember do not send that notification juice notification type don't send okay so remember if all of the bands are bypassed then the button should not appear as green if it only appears as green when the toggle state is off so this is most likely false which means all bands are bypassed which means our toggle stage should be false all right let's test this out here's what we're going to do we're going to enable all the bands we're going to manually bypass them one by one and see if that button switches all right let's turn this on turn this on and if we bypass this is this one going to change it does all right great and clicking it turns them all back off okay so the next test is if we do this if they're all on and then i turn off a band is this going to turn on yes it does awesome that works as expected now what happens if we close the gui when all bands are bypassed is this button going to be set correct let's save and quit and rerun and see what it does all right perfect that works as expected okay that wraps up the functionality for the plugin for this tutorial the last thing that i want to do is customize some of these colors and show a few tricks that i use to do that let's make a commit of our work uh implemented global controls implemented global controls um let's go to our plugin processor let's mark these guys off done and global bypass done our roadmap is now complete that is fantastic all right plug an editor here's our control bar here's where we did all this bypass stuff there's our editor here's all the bypass code that we implemented control band this is how we update the colors of the control band based on whether or not it should or should not be bypassed all right commit six files all right do color stuff next all right head over to look and feel i'm going to show you a trick that is going to help you dial in your colors the first thing is to declare a macro that toggles whether we use juice live constant or not put this right here define use live constant all right next i'm going to write a helper macro that will make use of this macro right here this macro doesn't do anything except return what was passed to it if the macro is true then the juice live constant editor is true otherwise this function just returns what was given to it the only downside here is that the juice live constant editor doesn't show the relevant code in the code snippet viewer and it triggers a jsert but who cares you know it's for what we needed to do it's awesome if use live constant we're gonna define a color helper function where we pass in c and we use juice live constant c like that else define color helper and if okay the next piece of the puzzle is to declare a namespace that holds all of the colors i plan on using and it wraps these colors and getter functions so i'm going to demonstrate one first all right in this function all i do is call the color helper function with whatever color i want so return color helper i'm going to go with blue for right now okay now i just need to replace whatever color i'm using when setting the slider's border with a call to this function instead let's go to lookingfield.cpp let's go find where that is drawn that's going to be drawn in the draw rotary slider at the top all right this is where i draw the border so i'm going to replace this line uh with a call to the um get slider border color g dot set color enabled if it's enabled use color scheme get slider border color otherwise do uh colors gray otherwise do this thing all right let's test it out and it will trigger a j assert but we can just continue past that it'll still work as expected oh um sorry let's do this in the standalone version and why is this showing an error redefinition i don't know why it's saying that all right here's that j assert i was talking about okay let's pull up our plugin here all right so you can click on this color right here and adjust all of the colors directly which is a great way to dial in um you know your colors in your gui once you find a color that you like oh that's a cool color um yeah copy the hexadecimal value and paste it where you were passing the default color to color helper that was over here in not look and feel that was over here in lookandfeel.h this color right here so i would just paste this instead and then wrap it in a juice color constructor juice color like that because there's a juice color constructor that takes a hexadecimal value all right let's do another let's do the module border all right let's go declare this function inline juice color get module color return color helper juice colors blue violet all right we're returning the color we want now let's use the function as needed in uh look and feel that'll go right here g dot set color if it's enabled use color scheme get slide uh get module border otherwise use dark gray and then let's head over to the draw module border color find that in utilities dot cpp there you go all right we need to include our look and feel so we can use the color scheme um look and feel all right and now we can set the color to the module border instead of that blue violet we can do color scheme get module border color all right let's run this it's going to j assert all right that's one there's the other all right let's find our plugin window here we go so what's cool about this is we get two colors now so we can adjust all of these like that you can see how it's adjusting the fill color of the knobs as well as the um border color and then we can dial in this thing and again once we find a color that we like that's kind of cool once we find a color that we like we just copy the hexadecimal over to our um copy it over here and replace the colors all right so there you go that's a nice helpful tip for how to dial in the colors you know once you get this color set to what you want if you want this like red color or not so much this uh maybe you want this to be like an alpha color and you can do that too that looks kind of cool this pop out more once you get this color dialed in to what you want um just copy the hexadecimal and replace it in your color scheme helper and you'll have your colors dialed in so it's you know a pretty handy way if you don't have a graphic designer to provide you colors and like give you like a real fancy gui it's just one of those things that we can use to tweak our gui and make it um a bit easier to make changes in a dynamic way that are easy to update okay so i hope you found that tip useful um i've used it a few times and i think it's a pretty it's a pretty efficient way to dial in gooey colors all right all right so there you go that wraps up the tutorial i am going to dial in some more of these colors and tweak the gui a bit to my liking i'm going to encourage you to do the same you can check out the completed project at the link in the description and if you want to learn how to build the big brother of this plugin check out my course project 12 which is available at www.programming4 you will be building it from instructions written in a jira board i will be reviewing your code every step of the way it is not a followalong course like this video was you're going to be getting your hands dirty and figuring it all out for yourself alright thank you so much for watching and supporting this be sure to check out my youtube channel my instagram and my twitter accounts check the links in the description including me starting from scratch videos as well as simple eq and my other courses and as always if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming4musicians.com and you can message me directly in the slack workspace and i will help you directly thank you for tuning in i hope you appreciated this tutorial and i hope you learned a lot from it i will see you in the next one
