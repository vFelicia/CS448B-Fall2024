With timestamps:

00:00 - hi all and welcome to this new tutorial
00:02 - series to create a neural network in
00:06 - javascript which we will hopefully use
00:08 - to automate the game asteroids now we
00:12 - made this game asteroids in another
00:14 - tutorial series so feel free to check
00:16 - that out you can download the code from
00:17 - the links below there should be a sounds
00:20 - folder and an html file
00:23 - so let's open the game up
00:26 - so there's a triangular ship that can be
00:27 - moved around the screen
00:29 - and it can shoot
00:31 - the asteroids
00:33 - i'll just mute that
00:35 - so the goal of this tutorial series is a
00:37 - very simple one and intentionally so
00:39 - because new neural networks can be quite
00:42 - challenging
00:43 - the goal is to rotate towards the
00:45 - closest asteroid
00:47 - and shoot
00:48 - rotate to the next closest asteroid and
00:51 - shoot
00:52 - it's not going to be an algorithm we're
00:53 - going to train a neural network to do
00:56 - this
00:57 - so what is a neural network
01:00 - well here it is
01:02 - basically they're made up of a number of
01:04 - layers so an input layer a hidden layer
01:07 - and an output layer you can have
01:09 - multiple hidden layers but we'll focus
01:11 - on just having a single hidden layer to
01:13 - keep things simple
01:15 - now the input layer it will take our
01:17 - game information so we could pass things
01:20 - such as the angle to the nearest
01:22 - asteroid or the current angle of the
01:25 - ship
01:26 - the hidden layer is more like a
01:28 - processing layer i guess and the output
01:31 - well we'll probably have a single output
01:32 - whether to turn left or turn right so
01:35 - that'll be a single boolean so zero will
01:37 - mean left one will mean right we'll keep
01:40 - things nice and simple because these
01:42 - things can be quite complicated
01:44 - in between each of these layers there's
01:46 - a whole bunch of black arrows now each
01:48 - of these black arrows represent a weight
01:51 - a weight between -1 and 1 i believe
01:54 - so for each neuron in the previous layer
01:57 - it sends out information to each of the
01:59 - neurons in the next layer
02:01 - so ultimately we'll be sending in some
02:04 - training data for example the asteroid
02:07 - position and the ship's current angle or
02:10 - something similar and we'll feed that
02:12 - through with an expected output so
02:14 - either to turn left or turn right
02:17 - now if it gets it wrong we'll send that
02:19 - information back
02:21 - to the input i guess
02:23 - and use that to correct these weights so
02:26 - ultimately we'll be sending in thousands
02:28 - of points of information
02:30 - correcting these weights until finally
02:32 - we have a unique set of weights that can
02:34 - take any of our game information and
02:36 - give us an accurate and reliable output
02:40 - so here's the position of an asteroid
02:42 - what do i do
02:43 - turn left here's another position of a
02:46 - different asteroid what do i do turn
02:48 - right
02:49 - let's just close that down
02:52 - we'll have to create a new javascript
02:54 - file
02:55 - just a plain text document called say
02:57 - neural network
02:59 - neural
03:00 - network and give that the js extension
03:05 - yes and open both of those in your
03:08 - favorite editor i'm using visual studio
03:10 - code here
03:12 - so the first thing we should do is set
03:13 - up a flag to let us know that automation
03:15 - is on
03:16 - so currently we have a whole bunch of
03:18 - flags in here how about we pull them out
03:21 - and we'll put them in a different
03:22 - section just to make it a little bit
03:23 - tidier how about developer flags
03:27 - paste them in there
03:29 - sorry just doing some housekeeping
03:32 - so let's create a new constant called
03:34 - automation
03:37 - automation on
03:38 - we'll set that to true initially
03:41 - so when the automation is on we'll want
03:43 - to set up our neural network so just
03:45 - after we set up the game parameters here
03:48 - so after new game here
03:50 - set
03:52 - up the
03:53 - neural network
03:57 - so if automation is on
04:01 - let's leave ourselves a to-do here
04:04 - because we can't do it at the moment to
04:06 - do
04:07 - neural
04:08 - network
04:11 - good now also when the automation is on
04:14 - we don't want the player to be able to
04:17 - to control the ship do we so down in our
04:19 - key press uh functions so key key down
04:23 - yep here we go key down and key up so if
04:26 - the ship is dead or
04:28 - automation is on
04:30 - return don't do anything so they can
04:32 - press the keys as much as they like
04:34 - nothing will happen
04:35 - similarly in the key up method
04:37 - if ship is dead or automation is on
04:41 - return we'll let the computer control
04:43 - the ship
04:45 - speaking of computers controlling ships
04:47 - let's head down to the update function
04:49 - that's where all the
04:51 - objects drawn and moved and so on so
04:53 - just the start of the update function
04:56 - just up near here somewhere how about we
04:57 - say use the
05:00 - neural network
05:02 - to
05:03 - control to rotate the ship
05:06 - and shoot
05:09 - and shoot
05:11 - so again we'll just leave ourselves
05:13 - so if automation is on
05:16 - we'll leave ourselves a to-do here so do
05:19 - uh
05:20 - control ship
05:23 - okay good
05:26 - let's just make sure that we haven't
05:27 - broken anything so head up the top uh
05:30 - first of all let's try it with the
05:31 - automation flag on
05:40 - okay so i'm moving the arrow keys i'm
05:42 - pushing the spacebar nothing's happened
05:45 - and just to make sure that we haven't
05:46 - broken anything let's set it to false
05:53 - yep i can control the ship in that
05:54 - situation so when it's turned on
05:58 - when it's true
06:01 - i've lost control of the ship awesome
06:05 - now head over to our new file neural
06:07 - network dot js at the top of that file
06:10 - let's use a flag use strict
06:12 - now what use strict does it basically
06:14 - enforces good coding practice things
06:16 - like you must declare variables and so
06:18 - on we're also going to focus on es6
06:21 - javascript now es6 is like the latest
06:25 - major revision to javascript syntax
06:27 - things like class and constructors and
06:30 - so on so we're going to use that we'll
06:32 - try to use that throughout this tutorial
06:34 - series
06:35 - now neural networks use a lot of maths
06:38 - specifically matrix maths
06:41 - so how about we create a
06:44 - heading here called matrix functions
06:48 - a matrix is essentially just a
06:51 - two-dimensional array
06:52 - so
06:54 - it has a number of rows and a number of
06:56 - columns
06:57 - so i'm just making this stand out a
06:59 - little bit
07:00 - matrix functions there we go so how can
07:03 - we represent a matrix well how about we
07:06 - represent it as a class so class matrix
07:11 - give it a constructor
07:13 - the constructor will take a number of
07:14 - rows and a number of columns
07:17 - and how about optionally we'll have data
07:20 - here as well so if we put an equal sign
07:22 - here it's a default value so by default
07:25 - it will be an empty
07:27 - array
07:29 - so inside the constructor
07:32 - let's set the variables now usually
07:34 - private variables private instance
07:36 - variables are prefixed with an
07:38 - underscore so we'll follow that
07:40 - convention
07:41 - do the same sort of thing for the
07:43 - columns
07:45 - and the data
07:50 - calls and data now to access those
07:52 - variables we should put some getters so
07:55 - just get
07:57 - rows
08:00 - and all that does is return
08:02 - this
08:02 - dot underscore rows
08:05 - and do a similar thing for each of the
08:08 - other variables
08:11 - so coles
08:13 - data
08:16 - this
08:17 - calls and this
08:19 - data
08:22 - so to use that when we declare an
08:24 - instance of this matrix we'd go matrix
08:27 - dot rows and that would return
08:30 - this dot rose
08:32 - so inside the constructor let's
08:34 - initialize
08:37 - initialize with zeros initialize with
08:39 - zeros
08:41 - if no data
08:43 - provided
08:46 - so if data
08:48 - equals null
08:50 - somebody could pass null couldn't they
08:52 - or data dot
08:54 - length
08:55 - equals zero so in the default case
08:58 - that's true
09:00 - if either of those things occur then we
09:02 - want to populate this data this
09:06 - data will equal a new empty array
09:10 - you'll have to loop through each of the
09:13 - rows so four let i equals zero so let's
09:18 - is one of these new es6 words basically
09:21 - it means that i is only visible within
09:23 - the for loop
09:24 - let i equal 0 i is less than this
09:28 - rows
09:30 - i plus plus
09:32 - lowercase i plus plus
09:36 - we'll want to initialize the row so this
09:40 - data
09:41 - i
09:42 - will equal an empty array
09:46 - and we'll loop through each of the
09:50 - columns so let j equals zero
09:54 - j is less than this
09:58 - coles
10:00 - j plus plus
10:03 - this
10:04 - data
10:05 - will this data i
10:08 - j
10:09 - so we'll set each of the elements
10:12 - to equal
10:13 - zero
10:16 - good
10:17 - if data is passed we'll probably want to
10:19 - check its integrity for example somebody
10:21 - could put three rows three columns but
10:24 - provide data with only two rows so
10:26 - that's not good is it so let's put an
10:28 - else here
10:29 - else
10:31 - will check
10:32 - data integrity
10:36 - so if the data's length
10:40 - doesn't equal the row number doesn't
10:42 - equal rows
10:43 - or
10:45 - data
10:46 - maybe data zero dot length so that's the
10:49 - column length isn't it
10:51 - doesn't equal coles
10:53 - then let's throw a new error so throw
10:56 - new
10:57 - error now the error takes a message
11:00 - you can just put something like
11:02 - incorrect
11:03 - uh data dimensions
11:08 - that should be enough
11:10 - so let's test this let's go back to our
11:12 - main file
11:15 - we'll have to import that
11:17 - file so we can do that up in the
11:20 - style script
11:22 - create script tags so script
11:25 - and we'll need a type type will equal
11:29 - text
11:30 - javascript
11:34 - and the source will equal
11:38 - dot sorry dot slash that means the
11:41 - current directory
11:42 - uh neural
11:45 - network whatever we named our file
11:48 - neural network dot js
11:51 - close the script tags
11:54 - so head down to where we will initialize
11:56 - or set up our neural network just in
11:58 - here
11:59 - let's try to set up some matrices so let
12:02 - m0 equal new
12:04 - matrix
12:05 - uh rows say two rows three columns
12:10 - and let's output that to make sure that
12:11 - it's working
12:13 - we could probably use the table command
12:14 - here because it outputs table data
12:17 - tabular data
12:18 - so m0.data
12:23 - that's the data of our matrix
12:25 - let's take a look at that just need to
12:27 - open the console
12:29 - here we go we have a 2 by 3 matrix full
12:33 - of zeros
12:34 - that's good
12:37 - let's try to pass some data
12:40 - so we can do that by setting up an array
12:42 - here
12:42 - so
12:44 - an array of arrays i should say so 2 1
12:47 - just adding some values here
12:50 - and the next row four
12:52 - three
12:54 - uh four three zero say
12:56 - okay let's give that a go
12:59 - there we go two one minus one four three
13:02 - zero
13:04 - two one minus one four three zero now
13:06 - what if we declared the incorrect
13:08 - dimension here just so we said a three
13:10 - by three matrix instead of a two by
13:12 - three let's check our area checking
13:16 - good error incorrect data dimensions
13:20 - put that back
13:22 - to
13:25 - awesome
13:27 - head to our other file to create another
13:29 - function
13:30 - so let's create a function that
13:31 - randomizes the weights or creates a
13:34 - random set of weights remember between
13:36 - our neurons there's going to be some
13:38 - weights
13:39 - between -1 and 1 so let's create a
13:42 - function for that so apply
13:45 - random
13:47 - weights
13:48 - between
13:50 - minus one and one
13:52 - so we'll call this random
13:55 - weights
13:57 - so this is inside our class
14:00 - for
14:01 - let i equals zero
14:04 - i is less than this dot rows
14:09 - i
14:10 - plus plus
14:14 - for the columns for let j equals zero
14:18 - j is less than this dot columns
14:24 - j plus plus
14:27 - this dot data
14:30 - i
14:32 - j
14:34 - will equal
14:36 - math
14:37 - random
14:39 - that's a number between 0 and 1
14:41 - times
14:42 - 2 times two minus one
14:46 - so a random number between zero and two
14:49 - minus one is minus one between minus one
14:51 - and positive one
14:53 - good let's test it in our other file
14:56 - so on m0 we can just go m0 dot random
15:02 - weights
15:04 - and hopefully that should work
15:07 - so currently that's what it looks like
15:09 - let's run
15:10 - it ah there we go yep that looks good we
15:13 - got some random weights negatives
15:15 - positives and everything in between
15:18 - great
15:20 - head to our other file and let's create
15:22 - our next method
15:25 - add to
15:27 - matrices
15:28 - so we'll make this a static method that
15:30 - just means we don't have to instantiate
15:32 - the class we can just call it directly
15:34 - we can go matrix dot
15:36 - add
15:37 - it will require two matrices m0 and m1
15:43 - we probably want to check that them to
15:45 - make sure that they have the same
15:46 - dimension so we can go we'll create a
15:48 - new method a new static method matrix
15:51 - dot
15:52 - check
15:52 - dimensions
15:55 - it will require m0 and m1
15:59 - let's create that now actually
16:01 - so check
16:04 - matrices have the same
16:09 - dimension
16:12 - same dimensions
16:14 - so
16:15 - static
16:16 - check dimensions m0 and m1
16:21 - if m
16:24 - if
16:25 - m0.rose
16:28 - doesn't equal m1 dot rose
16:32 - or
16:34 - m
16:35 - zero dot coles
16:37 - doesn't equal
16:40 - m one dot coles
16:43 - then let's just throw a new error throw
16:47 - new
16:48 - error
16:50 - the message we could
16:52 - how about matrices are
16:56 - of different
17:01 - dimensions
17:08 - okay
17:09 - so we check that
17:11 - now we'll need to create a in our add
17:12 - method we'll need to create a new
17:15 - return matrix so let m equal new matrix
17:22 - uh the rows will just be the same as
17:25 - what's passed so m0 dot rows
17:28 - m0 dot columns
17:32 - and we'll need to loop through each of
17:34 - those so let i equal zero
17:38 - i is less than m
17:41 - dot
17:42 - rows
17:44 - i plus plus
17:48 - and another loop for let
17:51 - j equals zero
17:53 - j is less than
17:56 - m dot coles
18:00 - j plus plus
18:03 - what will we do here so m dot data
18:06 - i
18:08 - j
18:09 - will equal i'll just copy that
18:12 - m
18:13 - 0
18:15 - m 0 dot data i j
18:19 - plus
18:20 - m 1 dot data i j so we're just adding
18:24 - the each individual cells together and
18:26 - assigning it to the new matrix
18:29 - and we'll have to return that matrix
18:31 - return m
18:33 - okay let's test that in our other file
18:36 - first we need a couple of more matrices
18:38 - to test with
18:40 - so let's create two more m one which
18:43 - will be two by three and just change up
18:45 - some of these numbers here
18:49 - that will do
18:50 - and m two
18:53 - will be a different sized matrix say two
18:55 - by two
18:56 - so let's just delete
19:00 - that okay good
19:03 - uh let's try it we don't need to use
19:05 - this random weights anymore let's try to
19:08 - add m1 and m2 it shouldn't work because
19:10 - there are being invalid sorry they're of
19:12 - different dimensions so matrix dot add
19:17 - m1
19:19 - m2
19:21 - let's try that
19:23 - error matrices are of different
19:25 - dimensions and that's in the
19:28 - that's on line 81
19:30 - yep that's correct
19:32 - how about we try to add
19:34 - m0
19:36 - well m m0 and m1 they should add we'll
19:41 - probably want to print out the data
19:43 - before we add them
19:46 - m0 data m1 data
19:49 - and we'll print out this starter
19:56 - there we go so we'll add that and show
19:58 - the data of the
20:00 - result matrix
20:03 - okay so the first matrix two one f one
20:06 - four three zero next matrix zero one
20:09 - blah blah so adding each of these so two
20:12 - plus zero equals zero
20:14 - sorry
20:15 - two plus zero equals two
20:18 - four plus two equals six that's right
20:20 - one plus one equals two three plus minus
20:24 - three is zero minus one plus minus one
20:26 - is minus two and zero plus zero
20:29 - zero plus zero equals zero good adding
20:32 - works head back to our other file
20:36 - we also need to be able to subtract
20:38 - matrices so it'll be very similar to
20:41 - adding so just copy all of that
20:44 - paste it down here
20:46 - subtract
20:48 - two matrices subtract
20:53 - almost identical except that we just
20:55 - need to change this plus to a minus so
20:57 - it'll be m0 data minus m1 data so the
21:01 - order is important here
21:03 - let's test that
21:06 - right so instead of adding m0 and m1 how
21:09 - about we subtract
21:16 - okay so two minus zero is two four minus
21:20 - two is two one minus one is zero three
21:23 - minus minus three is six
21:26 - minus one minus
21:27 - one
21:28 - is zero and zero minus zero zero good it
21:32 - looks like it's working just make sure
21:33 - the error checking is working okay so m
21:36 - two minus m one should not work
21:40 - there we go error matrices are of
21:42 - different
21:43 - dimensions great
21:46 - we also need to be able to multiply two
21:48 - matrices together
21:50 - so in a similar way that we've
21:51 - subtracted them
21:55 - let's set up and
21:56 - multiply two matrices multiply two
22:00 - matrices multiply
22:04 - if you know anything about matrices this
22:06 - is not the dot product so let's make a
22:08 - note not
22:10 - the dot
22:11 - product
22:12 - that's a separate thing we'll need to do
22:14 - that too but it's a different operation
22:16 - it's just multiplying each cell by each
22:18 - cell so all we have to do is change that
22:20 - minus there
22:21 - to at times
22:24 - uh head back and test it so matrix
22:28 - multiply
22:29 - mol
22:30 - multiply
22:32 - uh m2 and m1 shouldn't work let's just
22:35 - make sure
22:36 - yep it doesn't work
22:38 - and m zero and m one should work
22:44 - good two times zero is zero four times
22:47 - two is eight one times one is one three
22:49 - times minus three is minus nine minus
22:51 - one times minus one is 1 0 times 0 0
22:55 - looking good
22:57 - next let's calculate the dot product
23:00 - let's create a function to calculate the
23:01 - dot product of two matrices so dot
23:04 - product
23:05 - of two
23:06 - matrices
23:08 - so static
23:10 - dot
23:11 - m0 and m1
23:16 - now for two matrices to be dot
23:18 - compatible as such
23:20 - the
23:21 - first one's columns must be the same as
23:23 - the second one's rows for example a four
23:26 - by two matrix and a two by four matrix
23:29 - they're dot compatible the inside
23:31 - numbers are the same so for example
23:33 - three by two and two by one they're
23:35 - compatible
23:36 - so let's test for that if
23:39 - uh m0.cols
23:42 - doesn't equal m1 dot rows
23:46 - then we have to throw an error here so
23:49 - throw
23:50 - oops throw new
23:52 - error
23:53 - and the error message can be just be
23:55 - matrices are not
23:57 - uh dot
24:00 - dot
24:01 - compatible
24:04 - okie dokie
24:06 - now the size of the resulting matrix so
24:08 - let's create a new matrix here let m
24:10 - equal new matrix
24:13 - the size of the resulting matrix is
24:15 - equal to the outside numbers for example
24:18 - four by two and two by four the
24:20 - resulting matrix will be a four by four
24:23 - three by two
24:24 - times a two by one would be a three by
24:27 - one so that'll be the m zero dot rows
24:32 - uh and the number of columns will be the
24:34 - m1 dot
24:36 - coles
24:38 - right
24:39 - next we have to do the similar sort of
24:41 - loops that we've been doing in all of
24:43 - these
24:44 - so that
24:47 - so for let i equals zero i is less than
24:50 - the m dot rows i plus plus and for let j
24:52 - equals zero j is less than the m coles j
24:56 - plus plus
24:59 - so inside here is where we need to do
25:00 - our tricky stuff basically we need to
25:03 - add so we need to multiply each cell of
25:06 - the first
25:08 - matrices row by each cell of the second
25:10 - matrices column and then add up those
25:13 - products
25:14 - i'll post a link below how to do this by
25:16 - hand if you're interested so we'll need
25:18 - to create a variable called sum let sum
25:20 - equal zero
25:22 - and another for loop for
25:25 - let k equal zero
25:28 - k is less than the inner number which
25:32 - will be the m0.cols
25:35 - k plus plus
25:39 - and then we'll have some plus equals so
25:42 - we'll continually add this together sum
25:45 - plus equals
25:46 - the
25:47 - m0
25:50 - data
25:52 - i
25:55 - the ith row and then the kth column
25:59 - multiplied by the m1's
26:03 - data
26:05 - and it will be the k
26:08 - row
26:08 - remember the inside numbers are what's
26:10 - matching them by the jth
26:13 - sorry the jth column
26:16 - i think that's right sum plus equals
26:18 - that and then finally we need to set the
26:20 - i j so m
26:22 - dot data
26:25 - i
26:28 - j
26:29 - will equal the sum
26:33 - okie dokie and then finally we'll need
26:36 - to return that matrix
26:38 - return
26:39 - m
26:40 - so let's test that out in our other file
26:43 - so matrix dot
26:45 - dot
26:47 - m0 m1 now m0 is a 2x3 matrix m one's a
26:52 - two by three as well so they're not dot
26:54 - compatible let's just prove that
26:58 - yep error matrices are not dot
27:00 - compatible
27:01 - so which of these are dot compatible
27:04 - well how about m 2
27:07 - m 2 times m 1
27:10 - so a 2 by 2 times a 2 by 3 is dot
27:13 - compatible because the inner numbers are
27:14 - the same
27:15 - let's just update this here
27:18 - give that a go
27:20 - right so the first row entries times the
27:24 - first so times the second
27:26 - first column entries so
27:28 - 1
27:29 - times 0 is 0
27:31 - plus minus 1 times two is minus two
27:35 - yeah
27:36 - the second one so one times one is one
27:40 - plus minus one times minus three is
27:42 - positive three is positive four in total
27:45 - yep looks like it's working fairly well
27:48 - next function that we'd like to do is to
27:50 - create some sort of conversion function
27:53 - to convert a regular array to a matrix
27:57 - because when we pass in our input data
27:59 - from our game into the neural network
28:02 - we'll probably just pass it as a regular
28:05 - one-dimensional array
28:07 - so
28:08 - convert
28:09 - array to
28:11 - a one-road
28:14 - matrix
28:17 - so static
28:20 - uh convert array we'll call it convert
28:23 - from
28:24 - array
28:26 - we'll pass an array
28:29 - and all we'll do is return a new matrix
28:33 - a new matrix with one
28:35 - row
28:37 - the columns will equal the array.length
28:40 - and the data will just be the array
28:43 - itself
28:46 - okay let's try that
28:49 - first of all let's create an array so
28:51 - let array
28:53 - equal
28:54 - just make an array of any length with
28:56 - some random numbers inside
28:58 - we'll want to print that out to the
29:00 - console so console log array
29:04 - and we'll also want to print out the
29:06 - converted array so using table
29:08 - so matrix dot
29:11 - convert
29:12 - from
29:13 - array
29:15 - pass our array
29:17 - and we want to see the data of that
29:20 - okay oh we don't want to see the rest of
29:22 - this stuff so let's just comment that
29:23 - out
29:26 - let's give that a go
29:29 - incorrect data dimensions okay
29:31 - something's gone wrong here
29:33 - 25 in our matrix
29:36 - uh function
29:38 - where are we so up the top of here page
29:41 - f line number 25
29:43 - okay so we failed this data integrity
29:45 - check i can see why because it's
29:47 - checking the data.length now the length
29:50 - of a single dimensioned array is the
29:53 - total length so it would be four in our
29:55 - case but we don't want that we want that
29:57 - to equal the rows which is one
30:00 - so to get around that all we have to do
30:02 - is create a
30:04 - two dimensional array in our convert
30:06 - array so convert from array
30:09 - here we just need to put square brackets
30:11 - around that so essentially we're putting
30:13 - an array inside of an array a 2d array
30:16 - okay let's give that a go
30:21 - that's better so our regular array four
30:24 - five six seven and our converted array
30:27 - to a matrix four five six seven so it's
30:29 - a four columned single row array
30:33 - great
30:35 - next we'll need to create a function
30:37 - that can apply a function to each cell
30:41 - of the given matrix so we'll call that
30:43 - map
30:44 - so just down here
30:47 - apply a function to each cell
30:52 - of the
30:53 - given matrix
30:55 - the reason we need to do that i do this
30:57 - is because in neural networks we'll be
31:00 - using a function called the sigmoid
31:01 - function
31:02 - and we'll need to apply it to every cell
31:05 - so let's create a static method static
31:08 - map
31:09 - which takes
31:10 - m 0 a matrix and a function we'll just
31:13 - call that m function
31:16 - and we'll need to create a new uh
31:19 - matrix so let m equal new matrix it'll
31:23 - be of the same size as the past so
31:26 - m0.rows
31:29 - m0
31:30 - dot coles
31:33 - and we'll have to loop over in similar
31:36 - fashion to what we've done up here
31:39 - so let i equal zero i is less than m
31:42 - zero dot well m rows is okay too
31:45 - m rows i plus plus
31:47 - j
31:48 - yep
31:51 - and inside here all we need to do is go
31:54 - m
31:54 - data
31:57 - i
31:58 - j m data i j will equal the function
32:04 - of
32:05 - that data so the function of that of
32:07 - itself effectively m data
32:10 - i
32:12 - j
32:14 - and then all we have to do is return
32:16 - that
32:16 - matrix
32:19 - hang on we don't want to assign the m
32:21 - data because that's empty we want to
32:23 - assign the m0 data so the one that's
32:26 - been passed so that data we want to
32:29 - apply the function to and then we'll
32:30 - assign that result to our empty
32:34 - array sorry our empty matrix let's give
32:37 - that a go
32:39 - we don't want to see that array anymore
32:41 - so console table matrix dot map
32:45 - we want to map let's just choose one of
32:47 - these arrays so we'll choose m2
32:49 - and let's apply a function we can use
32:52 - what they call an arrow function so
32:54 - that's just x equals greater than
32:57 - it looks like an arrow pointing
32:59 - rightwards and then we can just what do
33:01 - we want to do to x so x times two so
33:03 - that means we'll times every cell by two
33:07 - and also let's copy this just above
33:10 - let's show the original table
33:12 - okay let's give that a go
33:15 - so the original table one minus one
33:17 - three zero
33:19 - one times two is two three times two is
33:21 - six and so on that's working well and
33:24 - one more function so x divided by two
33:27 - say
33:30 - so point five three divided by one point
33:32 - five zero divided yet minus one divided
33:34 - by two is minus zero point five great
33:37 - that's our map function handled
33:39 - and the last function for today is to
33:42 - find the transpose of a matrix now the
33:45 - transpose of a matrix is simply when we
33:48 - switch the columns with the rows and
33:51 - vice versa
33:52 - so find the transpose
33:56 - of the given matrix
34:00 - so a 4 1
34:02 - matrix will become a 1 4 matrix
34:06 - so static
34:07 - transpose
34:10 - it'll just take a single
34:12 - matrix as its parameter
34:15 - and basically we'll be doing something
34:17 - very similar to this
34:19 - just need to modify a few things so let
34:21 - m equal new matrix we need to switch the
34:23 - columns for the rows
34:26 - and we need to make sure that we loop
34:28 - over the
34:29 - the original the past matrix
34:32 - so m zero rows m zero columns
34:35 - now m data i j we want m data j i
34:40 - m data j i will equal
34:42 - [Music]
34:44 - m zero data i
34:46 - j let's test that out
34:50 - okay so matrix dot transpose
34:54 - let's transpose say matrix 1 so m1
35:00 - and we'll just put the m1 data before it
35:06 - okay so the original
35:08 - the original matrix is 0 1 minus 1 and
35:12 - then the column down here is 0 1 minus 1
35:14 - 2 minus 3 0 2 minus 3 0 so a 2 3 matrix
35:20 - has become a 3 2 matrix
35:23 - excellent
35:27 - last time we created these matrix
35:29 - functions that like for example to add
35:32 - matrices and multiply them and so on so
35:34 - today we're focusing entirely on
35:36 - creating the neural network so first of
35:39 - all let's create the class neural
35:41 - network so class
35:43 - neural network
35:47 - create the constructor now the
35:49 - constructor needs to take the number of
35:50 - inputs the number of hidden and the
35:52 - number of outputs so num
35:54 - inputs
35:56 - num
35:57 - hidden
35:59 - and num
36:00 - outputs
36:03 - let's set the private
36:05 - variables the properties as such so
36:07 - we'll just call give them the same name
36:08 - just prefix it with an underscore num
36:11 - inputs equals num inputs
36:14 - num hidden
36:16 - num hidden equals num hidden and num
36:21 - outputs
36:23 - equals num
36:24 - outputs now going back to our diagram
36:27 - remember we have all these weights that
36:29 - are in between the input and the hidden
36:31 - layer let's call that weights zero and
36:34 - we'll call these weights here between
36:36 - the hidden and the output weights one
36:39 - so this
36:40 - underscore weights
36:42 - 0 will equal a new matrix
36:46 - the number of rows will be the number of
36:49 - inputs so this is the number this num
36:52 - inputs and the number of columns will be
36:55 - the number of hidden so this
36:57 - num
36:58 - hidden
37:00 - similarly weights 1
37:02 - will equal
37:03 - a new matrix except that its
37:06 - number of rows will be the number of
37:08 - hidden
37:09 - and the number of columns will be the
37:11 - number of outputs
37:14 - okay
37:15 - for the weights 0 and weights one we'll
37:16 - need to set that we'll need to update
37:18 - them during our training process
37:21 - so let's create getters and setters for
37:23 - them so get
37:24 - weights
37:26 - zero
37:28 - that's simply return
37:31 - this
37:32 - underscore weights zero
37:35 - and we'll also want to set that so set
37:38 - weights zero
37:40 - uh weight
37:43 - weights
37:44 - set weights zero weights so we can just
37:46 - go this
37:48 - underscore
37:49 - weights zero equals weights
37:54 - right
37:55 - and we'll do a similar thing for weights
37:57 - one
37:59 - weights one
38:01 - this weights one weights set weights one
38:07 - this weights one equals weights
38:10 - great
38:12 - so
38:13 - we've done this one here
38:15 - next we need to randomize the initial
38:17 - weights so let's just
38:19 - use that as our next comment
38:23 - so randomize the initial weights
38:25 - we've already created a function in our
38:26 - matrix functions actually where we can
38:30 - call randomized weights on any
38:33 - on any uh matrix so weight zero dot
38:36 - random weights
38:38 - and do a similar thing for weights one
38:43 - good that's that step done we should
38:45 - probably test this so go to our other
38:47 - file the html file
38:50 - and let's go down to where we set up
38:53 - here we are to do neural network so
38:55 - we'll have to create a variable here so
38:57 - variable nn we'll call it
38:59 - and here we can go nnn equals new
39:04 - neural network
39:07 - now we need to pass the number of inputs
39:09 - hidden in outputs here i think we should
39:11 - set them as constants so up where we're
39:14 - setting our constants let's create a
39:15 - section called
39:17 - neural network
39:20 - parameters
39:23 - const
39:24 - num of
39:26 - inputs i'm not entirely sure how many
39:30 - inputs we'll need but let's just say two
39:31 - to begin with
39:34 - const num
39:36 - hidden
39:39 - um again there's lots of theory behind
39:42 - what number this should be
39:44 - the higher usually means the more
39:46 - complicated processing it can do so
39:48 - we'll just start with five we can always
39:50 - adjust it later
39:52 - and const num
39:54 - outputs now this one i am confident
39:57 - about we just want one boolean flag
40:00 - zero turn left one turn right so one
40:03 - output
40:04 - so head back down to where we're setting
40:06 - up our neural network
40:08 - put in these as their the arguments and
40:10 - num inputs
40:12 - num hidden
40:14 - and num
40:15 - outputs
40:18 - so we don't need these matrices anymore
40:20 - so we can get rid of them
40:22 - to test that our neural network's
40:24 - constructor is working all right how
40:26 - about we output the weights so nnn
40:30 - weights
40:32 - zero
40:33 - dot data
40:35 - and we'll do a similar thing
40:37 - for weights one
40:38 - we don't need this transpose anymore
40:41 - so open that up in our web browser
40:45 - okay so we have one
40:48 - for the first matrices of weights is two
40:50 - by
40:51 - three four yep two by five that's right
40:54 - and our output one our weights one is a
40:57 - five by one
40:58 - with random weights inside
41:01 - awesome
41:03 - to head over to our neural network class
41:06 - let's go down and see what we need to do
41:07 - next
41:08 - feed forward now all that means is that
41:11 - we're going to input some information
41:12 - into our network it's going to feed
41:15 - through it and some output is going to
41:17 - be created
41:19 - so let's create a new method called feed
41:22 - forward in our class
41:25 - it will take an input array as an input
41:29 - as a parameter
41:31 - let's paste these comments in here
41:35 - so the first step is to convert input
41:38 - array to a matrix that's easy enough so
41:40 - let's declare a new
41:42 - array let inputs equal matrix
41:46 - dot
41:47 - convert
41:48 - convert from array we made this earlier
41:51 - so we can just put the input array in
41:53 - there
41:54 - and that will convert it to a single
41:56 - road matrix
41:57 - that's fine
41:59 - next one find the hidden values and
42:01 - apply the activation function okay to
42:04 - find the hidden values we can look at
42:05 - this diagram here you can see that each
42:08 - hidden
42:09 - neuron is made up of these
42:11 - weights one coming from each of the
42:13 - previous inputs
42:14 - so to calculate that it's just the first
42:16 - input multiplied by the first weight
42:20 - plus the second input times the second
42:22 - weight times the third input sorry plus
42:25 - the third input times the third weight
42:27 - and that can be handled using a matrix
42:29 - dot product
42:31 - we have a function for that as well so
42:33 - let
42:34 - hidden
42:35 - equal
42:36 - matrix dot
42:38 - dot
42:39 - which takes two matrices the first one
42:42 - being the inputs and the second one will
42:44 - be the weights which we all have already
42:46 - determined it's been randomly determined
42:49 - so weights zero
42:51 - okay
42:52 - now the activation function
42:55 - is simply well with lots of neural
42:57 - networks the activation function is
42:59 - something called a sigmoid function
43:01 - let's take a look at that
43:03 - now a sigmoid function is simply this 1
43:06 - divided by 1 plus e to the minus t now
43:10 - what that does we can input any value
43:12 - into this system and it will return a
43:14 - value between zero and one no matter how
43:16 - big that value is so if we put one
43:19 - trillion into this we'll get a it'll
43:21 - output a value close to one
43:24 - okay which suits our needs very well
43:27 - so let's go ahead and create a function
43:30 - down here just outside our class
43:31 - function we'll just call it sigmoid
43:34 - sigmoid
43:36 - it'll take some value we'll call that x
43:39 - and it will return
43:41 - 1 divided by
43:43 - 1 plus the
43:45 - exponent so that's e
43:49 - a numeric expression representing the
43:51 - power of e yep so math.exp to the minus
43:54 - x
43:56 - that's right
43:58 - now in order to apply that function to
44:00 - each of the cells of the matrix we made
44:02 - a function for that too so we just go
44:04 - hidden will equal
44:06 - matrix
44:07 - dot
44:08 - map
44:10 - okay so it takes the
44:12 - the matrix so which is hidden
44:16 - and the function to apply to it well we
44:17 - can use an arrow function here so x
44:21 - equals greater than
44:23 - x
44:24 - sigmoid x so sigmoid x so that should
44:28 - apply the sigmoid function to each of
44:30 - the values within our matrix
44:33 - good
44:34 - similarly
44:35 - so for the second part find the output
44:38 - values and apply the activation function
44:39 - it's the same sort of thing
44:41 - so we can just go let
44:44 - outputs
44:45 - equal matrix dot
44:47 - hidden will be the inputs
44:50 - so this will be from here from the
44:52 - hidden layer to the output layer so
44:54 - hidden will be the inputs and output
44:56 - will be the outputs
44:58 - so matrix dot hidden this dot sorry this
45:02 - dot weights one that's the second set of
45:04 - weights
45:06 - outputs
45:09 - matrix map
45:10 - so itself
45:12 - outputs and
45:13 - apply the sigmoid function to each value
45:16 - and finally we want to return
45:20 - return those outputs to the sender
45:23 - the next step apply bias i don't want to
45:26 - do that right now and the reason is
45:27 - because not applying bias can cause
45:30 - issues and i'd like to see what those
45:32 - issues are
45:34 - so let's first test this feed forward
45:36 - function so let's do some console output
45:39 - console log
45:41 - inputs
45:44 - and we'll just output the uh the data in
45:46 - the array so we can use table to that
45:49 - console.table
45:51 - inputs
45:53 - dot data
45:56 - and we'll do something similar each step
45:58 - of the way here so when we work out our
46:01 - hidden
46:02 - neurons we can just do that
46:07 - and we'll also want to see what happens
46:09 - after we apply the sigmoid function
46:12 - similarly for our outputs
46:18 - and
46:19 - after the outputs
46:23 - have had the sigmoid function applied to
46:25 - them so i'll just call that output sig
46:28 - that will be hidden sig
46:31 - okay head over to our other file
46:34 - let's call that function so all we have
46:36 - to do is go nn dot
46:38 - feed
46:40 - forward
46:41 - it requires an input array so something
46:43 - like zero comma one now remembering that
46:46 - the number of inputs that we declared
46:47 - for our neural network is two so we need
46:49 - to pass to
46:51 - an array of length two here now if we
46:53 - didn't let's just try that if we didn't
46:56 - it should break
46:58 - let's have to open our file
47:02 - open up the console
47:04 - yeah so inputs got through a single
47:07 - length array but there's an error
47:08 - matrices are not dot compatible so to
47:11 - fix that all we have to do is
47:15 - put the second element
47:17 - put the second uh
47:19 - input in there let's give that a go
47:22 - yep that worked fine so we've got two
47:24 - inputs zero and one
47:26 - the hidden values are calculated i'll
47:28 - just believe that
47:29 - the sigmoid is applied the output and
47:32 - the sigmoid is applied let's just keep
47:34 - resetting that until we get an output
47:36 - that is negative
47:38 - here we go so here's a negative output
47:40 - can you see that the sigmoid function
47:42 - has made that positive
47:44 - so that seems to be working okay
47:48 - so head over to our other file we can
47:50 - probably get rid of some of these
47:51 - console logs so let's just delete a few
47:54 - of them
47:58 - we'll keep one set we'll probably need
48:00 - it for our next function
48:01 - and that is train train using input and
48:04 - target arrays
48:06 - right so currently our system doesn't do
48:08 - very much we give it some inputs and it
48:10 - outputs some randomly generated outputs
48:12 - not very useful so in order to make it
48:15 - do something how about we create a
48:17 - function that allows us to put in some
48:19 - training data so we'll call that train
48:22 - so up inside our class
48:25 - train
48:26 - it will take an input array
48:30 - and the target array
48:33 - so for example if we
48:35 - had the inputs 0 and 1 and we expect 1
48:39 - to be the answer then that's what we
48:40 - would put in here
48:42 - let's paste those comments in there
48:47 - so the first step feed the input data
48:49 - through the network well we already have
48:51 - a function for that called feed forward
48:53 - so let's say let outputs
48:57 - equal
48:58 - feed
48:59 - forward
49:00 - this dot feed forward
49:02 - the input array
49:06 - okay that's that done
49:08 - next calculate the output errors
49:11 - target minus output okay in order to
49:14 - subtract matrices we'll have to convert
49:16 - the target array first so that
49:18 - let's targets
49:20 - equal matrix dot convert
49:23 - convert from away from array
49:27 - target
49:28 - array okay good
49:31 - and
49:32 - let's output errors
49:35 - so we're calculating the output errors
49:37 - here let output errors equal matrix
49:40 - dot subtract
49:42 - and we'll subtract the first which is
49:45 - the target so the targets
49:48 - minus the second which is the output
49:52 - the outputs
49:55 - let's test that so we'll grab this
49:57 - console data that we kept up here
50:00 - uh outputs
50:02 - targets and output errors
50:05 - so outputs that'll be fine
50:09 - targets
50:11 - targets and output errors
50:14 - output errors let's print out every step
50:19 - okay head back over to our other file uh
50:21 - nn.train
50:23 - we need an input array 0 1 and an output
50:26 - array remembering it has to match the
50:28 - number of outputs if it doesn't we're
50:30 - going to get an error we'll just
50:32 - give that a go we'll put a 2
50:34 - column one there
50:39 - okay so error matrices are of different
50:41 - dimensions so when it tries to subtract
50:43 - them it failed so let's put that to a
50:45 - single one
50:49 - right so we have our outputs which is
50:51 - 0.639
50:53 - the in the expected the target is one so
50:56 - the difference is point three six that
50:58 - sounds correct
51:02 - so on to our next step
51:04 - calculate the deltas
51:06 - which are equal to the errors times the
51:08 - derivative of the output
51:10 - so the derivative of the output is
51:12 - actually the derivative of the sigmoid
51:14 - function so let's update our sigmoid
51:16 - function to handle derivatives
51:19 - how about we just pass a flag derive
51:21 - equals false we'll set we'll give it a
51:23 - default value so you don't have to
51:25 - provide it and if you don't it'll just
51:27 - return what we always have
51:29 - if derived
51:33 - then we'll return the derivative now the
51:35 - derivative of this is x times 1 minus x
51:41 - that's not the true derivative of the
51:43 - sigmoid function
51:44 - but
51:45 - we've already applied the sigmoid
51:47 - function so we don't want to return the
51:49 - true so i'll put a note here where
51:52 - x equals sigmoid
51:55 - x
51:56 - right so the true derivative is the
51:58 - sigmoid x times 1 minus the sigmoid x
52:00 - but we've already applied it so this
52:02 - will be a good representation x times 1
52:04 - minus x
52:07 - so let's create a variable let output
52:10 - derives
52:11 - equal we can use our map function to
52:14 - apply this matrix.map
52:16 - the outputs
52:20 - and the function will be we can use an
52:22 - arrow function again
52:24 - will be the sigmoid
52:26 - x but this time we'll set the derived
52:28 - flag to true so it'll apply the
52:31 - derivative to each of these outputs and
52:33 - assign it to that
52:35 - and finally
52:37 - output
52:39 - errors no calculate the delta output
52:41 - deltas is what we're trying to find here
52:43 - output deltas will equal
52:46 - matrix
52:47 - dot so error is times derivative so
52:50 - multiply we can use our multiply
52:51 - function
52:52 - the first one is the errors output
52:55 - errors
52:57 - and the second one will be the output
52:59 - derivatives output derivatives
53:03 - and we'll just copy
53:05 - this console log here so we can test
53:07 - this
53:09 - output just the deltas we'll do output
53:12 - deltas
53:14 - let's test that
53:16 - let's run it again
53:18 - so we have outputs targets output errors
53:22 - and output deltas
53:25 - who am i to refute that it looks okay
53:29 - okay on to the next step
53:31 - calculate hidden layer errors so it's
53:33 - the deltas dot the transpose of weights
53:36 - one
53:37 - right so let's calculate the transpose
53:40 - first so we'll call that weights
53:42 - one
53:43 - capital t for transpose will equal we
53:46 - have a function for this matrix dot
53:48 - transpose
53:49 - it just takes a single matrix so that'll
53:52 - be the this dot weights
53:55 - one
53:57 - okay and then we'll need to calculate
53:59 - the hidden layer errors we'll call it
54:01 - hidden errors hidden errors
54:06 - will equal delta dot so matrix
54:11 - dot
54:14 - uh
54:15 - what was the first one the deltas dot
54:17 - the transpose okay so that'll be the
54:20 - output deltas output deltas
54:23 - dot what we just worked out the
54:25 - transpose their weights one t
54:29 - again let's output some just to make
54:31 - sure it's not
54:32 - throwing an error basically we don't
54:34 - really know exactly what we're after
54:36 - here
54:37 - uh the hidden areas is what we'll want
54:39 - to output here hidden errors
54:42 - let's give it a go
54:46 - right so we get some output deltas and
54:49 - then we get the hidden
54:50 - errors across ways that looks to be okay
54:56 - so the next step calculate the hidden
54:58 - deltas errors times derivative of hidden
55:02 - sounds very similar to what we've done
55:03 - up here so let's just copy and paste
55:05 - that
55:07 - let hidden derives
55:11 - equal matrix map
55:13 - hidden
55:14 - i just had a thought we don't have
55:16 - actually have visibility to hidden here
55:18 - hidden because hidden wasn't was used
55:22 - within this feed forward function
55:25 - here we go let hidden equals that so how
55:27 - about instead of creating a local
55:29 - variable here we use a property on our
55:32 - neural network we'll say this dot hidden
55:35 - this dot hidden so anywhere we use
55:37 - hidden inside here we'll go this dot
55:39 - hidden
55:40 - this dot hidden this dot hidden
55:43 - and we'll have to go create a property
55:45 - on the neural network so we can do that
55:48 - easily enough just at the top of it this
55:50 - dot underscore hidden will just equal an
55:53 - empty array
55:55 - and we'll have to set up some getters
55:56 - and setters for it so that we can access
55:59 - it
56:00 - get
56:01 - hidden
56:03 - we'll just return this
56:05 - underscore
56:06 - hidden
56:07 - and set
56:09 - hidden
56:11 - just pass a
56:13 - variable called hidden this
56:15 - hidden
56:17 - will equal hidden
56:19 - that should access yep that's the same
56:22 - as that
56:23 - right so that should all work in our
56:25 - feed forward now
56:27 - and back down where we have
56:31 - back in the train function
56:33 - where we have hidden here so hidden
56:34 - derivative with a matrix map this dot
56:36 - hidden so we're accessing the actual
56:38 - hidden values at this stat at this point
56:41 - in time
56:42 - x
56:43 - uh sigmoid x is true yep we're applying
56:45 - the derivative of it
56:47 - calculate the hidden deltas so the
56:49 - hidden deltas
56:52 - matrix multiply the hidden errors
56:57 - times the hidden derives
57:02 - right so let's output those hidden
57:04 - deltas
57:07 - let's give it a go
57:11 - so we have some hidden errors with some
57:13 - hidden
57:14 - deltas
57:15 - good
57:17 - now for the final step in our little
57:19 - neural network update the weights so we
57:21 - have to add the transpose of layers dot
57:24 - deltas so we add that to the weights
57:28 - okay so let's first calculate the
57:29 - transpose so let hidden
57:32 - transpose equal matrix
57:35 - dot transpose
57:38 - uh this dot hidden
57:43 - sorry
57:44 - um
57:45 - next we have to add the transpose to the
57:48 - weight so this weights the associated
57:50 - weights is one it's the second set of
57:53 - weights will equal matrix
57:56 - add
57:59 - add itself we have to add to itself so
58:01 - this
58:02 - weights
58:03 - one
58:05 - the
58:06 - layers the transverse layers dot deltas
58:08 - so matrix
58:12 - dot
58:15 - the transpose hidden t
58:17 - hidden
58:19 - t
58:21 - and the deltas which will be the output
58:24 - deltas of the associate are associated
58:26 - with the hidden layer so output deltas
58:31 - now we have to do a similar thing for
58:33 - the first weight so weights zero
58:37 - so we need to calculate the transpose of
58:40 - the inputs so inputs t well matrix
58:43 - transpose
58:45 - in do we have
58:47 - inputs
58:48 - do we have visibility on inputs
58:51 - no we don't because again within the
58:53 - feed forward
58:54 - we're converting it there
58:57 - and keeping it as a local variable
58:59 - so
59:00 - there's a couple things we could do we
59:01 - could just convert it again within our
59:03 - train array but we have to remember that
59:05 - this train function will probably be
59:07 - called like thousands of times if not
59:09 - hundreds of thousands of times so it's
59:11 - probably better just to assign it to
59:13 - what how we're doing with the hidden
59:15 - here so let's do that
59:16 - this dot inputs
59:21 - this input so we'll have to go up and
59:23 - create a property
59:24 - same as what we've done for hidden
59:27 - so this
59:29 - inputs will just equal an empty array
59:31 - and we have to create a couple of with
59:34 - create getter and a setter
59:37 - get inputs
59:40 - this
59:41 - return this inputs
59:44 - set inputs
59:45 - inputs equals inputs
59:49 - this inputs will equal inputs that's
59:51 - looking good so our feed forward
59:53 - function should work now we'll just
59:55 - assign instead of creating a local
59:56 - variable we're just assigning as a
59:58 - property now down in our train
60:02 - uh function
60:03 - this inputs should work now that's fine
60:06 - and we're updating weights zero at this
60:09 - point weight zero weight zero dot
60:12 - the inputs t
60:14 - inputs t
60:16 - and the deltas that are associated with
60:18 - that of the hidden deltas
60:20 - the next
60:21 - layer deltas let's run that make sure
60:23 - it's not broken
60:26 - okay it's not breaking so that's good
60:28 - enough test for me i think we should
60:30 - actually try this training and see if it
60:32 - actually works or not how about we get
60:34 - rid of all these comments first because
60:36 - they're just not
60:38 - we don't want them printing out every
60:40 - iteration when we've got like a thousand
60:42 - or ten thousand iterations
60:45 - remove all them remove all them
60:49 - this the weights are updating great go
60:52 - back to our other file
60:55 - right so we'll be calling train but we
60:58 - want to loop over the number of training
61:01 - samples that we have so we can go for
61:05 - i'll title this train
61:08 - the network
61:12 - for let i
61:14 - equal zero
61:16 - i is less than say let's set up a flag
61:19 - for this so num
61:21 - samples
61:23 - i plus plus
61:27 - in there we'll do our training for
61:29 - something
61:31 - a number of samples let's go up and
61:33 - create that now
61:36 - num samples
61:39 - i'm not exactly sure how many we'll need
61:41 - but let's start at say one thousand i
61:43 - know in other examples there's ten
61:45 - thousand and a hundred thousand and so
61:46 - on we'll just we'll start with one
61:49 - thousand num samples is 1000.
61:53 - and how about we use the classic example
61:55 - to test neural networks is the zor sorry
61:57 - the xor gate the exclusive or gate
62:00 - so x we'll call this a test test
62:05 - x or
62:06 - gate logic
62:09 - let's take a look at that xor gate here
62:12 - it is just this table down here so when
62:14 - you have two inputs 0 0
62:17 - output 0 0 1 or one zero output one and
62:20 - one one outputs zero so zero zero zero
62:24 - okay let's write that in here i think
62:27 - zero zero
62:28 - equals
62:30 - zero
62:33 - zero one equals one
62:36 - one zero equals one and one
62:40 - one equals zero so only when there's one
62:43 - of them
62:44 - flagged will it be one otherwise when
62:46 - they're both the same it'll be zero
62:48 - so let's create some random input we'll
62:50 - create one
62:52 - zero one there and one zero one there so
62:54 - we'll input one input two or input zero
62:57 - and input one input zero will equal
63:00 - well
63:01 - it'll be a random number and we want to
63:03 - round it so math round just rounds to
63:06 - the nearest integer
63:07 - and we want to round a random number
63:09 - math random which is a number between
63:11 - zero and one so that should produce a
63:13 - zero or one
63:15 - similarly for input 1
63:18 - so we can pass them into our
63:23 - training array here so input 0 and input
63:26 - 1
63:27 - and we also need an output so let output
63:32 - let output equal well what's the logic
63:35 - behind it if input 1 input 0 and input 1
63:38 - are the same then the output is 0 right
63:42 - otherwise the output is one so we just
63:44 - do a conditional here
63:46 - input zero
63:48 - equals
63:49 - input one if that's true the output is
63:53 - zero
63:54 - else the output is one that's the
63:56 - zorgate logic
63:58 - and put our output into this array here
64:02 - out
64:02 - put
64:04 - so basically we've created a whole bunch
64:06 - of random
64:07 - training data with the correct outputs
64:10 - fed it into our system in the hope that
64:12 - it's going to create an accurate uh
64:14 - prediction
64:16 - so let's test it test output
64:20 - we can just use the console for this i
64:22 - think
64:23 - console.log
64:25 - we'll put in each of the
64:27 - combinations of inputs so 0 0
64:30 - will equal
64:32 - let's feed it into our system together
64:35 - to get a prediction
64:36 - feed
64:38 - forward
64:38 - we need the array 0 comma the input
64:42 - array 0 0
64:43 - and we want to output to the screen the
64:46 - data of that so do that for each of the
64:49 - possible
64:50 - input combinations so zero one one zero
64:54 - and one
64:55 - one
64:56 - zero zero zero one
64:59 - one zero and one
65:02 - one
65:04 - let's give that a go
65:09 - okay zero zeros we're expecting a zero
65:13 - here and a zero here and a one here and
65:16 - one here it could be that we haven't got
65:17 - enough samples so let's try by bumping
65:20 - up the number of samples to say ten
65:22 - thousand
65:28 - ah that's looking pretty good that's
65:30 - close to zero that's close to one that's
65:31 - close to one that's close to zero let's
65:33 - just keep trying make sure there's no
65:36 - discrepancies here
65:39 - now i have read that not having bias can
65:42 - cause an issue in these situations
65:45 - so let's see if it comes up with a
65:48 - strange
65:49 - reading on occasion
65:55 - so here for example the prediction for 1
65:58 - 1
65:59 - is 0.5 so that could be because of the
66:02 - bias not being there so i think for
66:04 - safety we should put the bias in
66:07 - so first of all what is bias
66:09 - well here's a diagram basically we have
66:12 - our input neurons
66:14 - we just add an extra neuron for bias it
66:17 - always takes a value of positive one
66:20 - and we add it and all it does is output
66:23 - its own weights in effect it doesn't
66:26 - take an input of any kind it just
66:27 - outputs its own weight we'll have one
66:30 - bias node on the input layer and one
66:32 - bias node on the hidden layer the reason
66:34 - we do this is because the input
66:37 - neurons could take all zeros for example
66:41 - in our zorgate logic if we have zero
66:43 - zero as our inputs can you see that that
66:45 - could
66:46 - skew the results because 0 times any of
66:49 - these weights will be 0 so it's not
66:52 - going to behave correctly so that's why
66:54 - we add this bias node
66:56 - head into our other file
66:58 - go right up the top
67:00 - in the same way that we've created
67:02 - weights here let's create a bias zero
67:05 - and a bias for one
67:08 - so
67:09 - bias zero will equal a new matrix of
67:12 - just a single row so one row
67:15 - the number of columns will be the number
67:16 - of hidden
67:18 - and bias one same sort of thing one row
67:21 - but the number of columns will be the
67:24 - number of outputs
67:26 - okay and we'll have to randomize in the
67:29 - same way that we've randomized the other
67:31 - weights we'll randomize the bias so bias
67:34 - zero random weights
67:37 - do that for bias one as well
67:40 - okay that looks good
67:42 - head down to our feed forward function
67:44 - we've left the node here apply bias
67:48 - to apply the bias all we have to do is
67:50 - before we apply the sigmoid function to
67:52 - the hidden layer we can just apply we
67:55 - can add the bias so this hidden will
67:58 - equal matrix
68:00 - add
68:03 - this hidden so adding to itself
68:06 - this
68:07 - bias
68:08 - zero so that is applying the bias apply
68:12 - bias
68:14 - and in the same way we'll do that with
68:16 - the output so before we apply the
68:18 - sigmoid function
68:20 - instead we'll be doing it to the output
68:22 - so outputs will equal matrix add
68:26 - outputs
68:27 - this
68:28 - bias
68:29 - one
68:31 - now down in our train function we've
68:34 - left a note update biases
68:38 - now to do all we have to do there is go
68:40 - in the same way that we've updated our
68:41 - weights here we'll do the same thing
68:43 - this dot
68:44 - bias
68:46 - 1
68:47 - will equal matrix
68:50 - add
68:51 - this
68:52 - dot bias
68:54 - 1
68:55 - and we're adding the
68:58 - the deltas the output deltas for this
68:59 - one
69:02 - same sort of thing for the bias 0 except
69:06 - that we'll be adding the hidden deltas
69:10 - so this by zero
69:12 - hidden deltas
69:14 - so let's test that
69:17 - oh we have an error m1 is undefined
69:22 - okay
69:24 - uh m bias
69:27 - uh
69:28 - maybe no i didn't create the uh getters
69:31 - and setters for these private
69:33 - so let's do that now that was a bit
69:34 - silly so we're just as we do just as we
69:37 - get and set the weights let's get and
69:40 - set the bias so bias
69:44 - zero
69:45 - this
69:47 - bias
69:48 - zero
69:49 - set
69:50 - bias zero
69:53 - and this
69:55 - bias
69:57 - zero just pass the bias
70:01 - oops
70:03 - bias
70:05 - bias
70:06 - okay so but get biased you return this
70:09 - by zero set by zero bias this bias zero
70:11 - equals bias do that for bias one as well
70:17 - just update that to one
70:20 - one
70:22 - one
70:24 - and one
70:26 - okay that should be okay now let's give
70:30 - that a go
70:33 - great so if we run that a few times my
70:36 - hunch is that it will be fine we'll get
70:40 - a value close to zero a value close to
70:42 - one and finally a value close to zero
70:50 - we will actually be feeding in game data
70:53 - into our neural network so that we can
70:55 - rotate this ship i'm doing this manually
70:57 - of course so we can rotate the ship and
70:59 - shoot at the closest asteroid
71:02 - okay so let's head into our code i'll
71:05 - just turn automation back on
71:09 - okay and head to our neural network file
71:13 - the first thing i'd like to do today is
71:15 - to set up some error logging in our
71:16 - neural network class the reason for this
71:19 - is that i'd like to be able to keep
71:20 - track of how well our
71:22 - training function is doing as we're
71:24 - training it so let's set up a flag up
71:27 - here just a constant let's call it log
71:29 - on
71:31 - set it to true
71:32 - and that's just whether or not to show
71:36 - error
71:37 - logging
71:39 - we'll need to keep track of how often we
71:41 - show this message like show a message we
71:43 - don't want to show it every iteration
71:45 - because we could in theory be calling
71:47 - this
71:48 - uh train function like thousands of
71:50 - hundreds of thousands of times if not
71:52 - millions of times so let's set a log
71:54 - frequency
71:56 - uh initially we'll set it to a thousand
71:58 - say
71:59 - and that's just how often
72:02 - to show
72:04 - error logging
72:05 - error logs
72:07 - and that's in iterations
72:09 - in
72:10 - iterations
72:12 - okay we'll have to set up a private uh
72:14 - member variable here
72:16 - just down here so error
72:18 - logging
72:20 - this underscore we'll keep track of how
72:24 - many calls we've had or how many
72:26 - iterations we'll call it log count
72:28 - and it'll start the day at log frequency
72:33 - and we'll also because it's private
72:34 - we'll want to set up some getters and
72:36 - setters
72:39 - it's not technically private i'm kind of
72:41 - making it private i should say
72:43 - so get log count
72:46 - i don't get log count
72:50 - return this
72:51 - log count
72:53 - set log count
72:56 - count
72:58 - this log count
73:01 - equals count
73:04 - head down to our train function
73:08 - now what's the most appropriate thing to
73:09 - output here i'm thinking the output
73:12 - errors because the output errors are
73:14 - simply the target minus the output so if
73:16 - the target's 1 and the output's 0.7 then
73:18 - the error is 0.7 it's easy to understand
73:21 - so let's do our error logging here error
73:24 - logging
73:25 - if
73:26 - log
73:28 - on
73:30 - and if the this dot
73:34 - log
73:36 - count yep if this.log count equals the
73:38 - log frequency
73:41 - well let's do a console output so
73:43 - console log
73:46 - uh output errors
73:49 - output errors
73:51 - now it's a matrix so we'll need to grab
73:53 - its data array and we there's only going
73:55 - to be one error because we've only got
73:57 - one piece of output so we'll just do the
73:59 - first
74:01 - column
74:02 - sorry the first row first cell
74:05 - okay
74:07 - probably prefix that with something so
74:08 - we know that what we're outputting error
74:12 - equals that
74:16 - then we'll have to decrement the log
74:18 - count so this dot log count minus minus
74:21 - because we don't want it occurring every
74:22 - iteration
74:24 - and when that reaches zero if this dot
74:26 - log count equals zero
74:30 - what will we do well we'll just reset it
74:32 - this dot log count
74:34 - equals
74:35 - log frequency
74:39 - let's test that out
74:40 - so currently we we'll just need to turn
74:42 - our console on
74:44 - reset it
74:45 - okay here we go so we've got errors of
74:47 - 0.32 0.29 0.08 blah blah blah it's going
74:50 - down slowly isn't it uh how about so
74:53 - this is our zorgate logic that we used
74:55 - last time
74:56 - how about we increase the number of
75:00 - samples so go back to our other file our
75:03 - html file we'll increase the number of
75:04 - samples to say 100 000
75:07 - and we'll increase the number of hidden
75:11 - nodes to 10
75:13 - but because we're doing a hundred
75:14 - thousand samples now how about we change
75:16 - our log frequency to say 10 000 we don't
75:19 - want it showing so often
75:22 - let's give that a go
75:24 - point seven four point zero one as you
75:26 - can see very quickly the error is
75:28 - reduced with the zorgate logic so that's
75:31 - good our logging is working great
75:34 - that's all we really need to do for our
75:36 - neural network file so let's head over
75:39 - to our other file
75:40 - now we have to think about how many
75:42 - inputs are there going to be in our
75:43 - system
75:44 - i've always said that the goal was to
75:46 - turn our ship towards the closest
75:48 - asteroid and shoot it so knowing that we
75:51 - need to know the asteroids position
75:53 - don't we so there's going to be an x
75:55 - position and a y position so that's two
75:58 - inputs
75:58 - and we also need to know the ship's
76:00 - angle because if we're facing this way
76:02 - we need to know that we'll have to turn
76:04 - left to get to the asteroid or turn
76:06 - right or whatever so that's the asteroid
76:09 - x the asteroid y and the ship's angle so
76:11 - that'll be a minimum of three inputs
76:14 - uh how about just for testing purposes
76:16 - we'll just turn the roid number down to
76:19 - one there'll be a single asteroid
76:22 - right head down to where we set up our
76:24 - neural network where we train the
76:26 - network we don't need to do any of this
76:28 - all gate logic anymore that was just for
76:29 - testing our system
76:31 - and we don't need this test output
76:33 - anymore
76:37 - so let's create some variables well i
76:40 - need the asteroids x position asteroids
76:43 - y position the ship's
76:45 - angle and just for completeness let's
76:47 - include the ship's position as well so
76:49 - ship x and ship y
76:52 - so the first thing we'd like to do the
76:54 - first thing we'd like to include in our
76:56 - training data is a random asteroid
76:58 - location random asteroid location but we
77:02 - have to remember that asteroids can
77:03 - float off the left and right of screen
77:05 - as well as top and bottom up to their
77:07 - radius so we'll have to include
77:11 - off screen
77:13 - data here as well
77:16 - so a x will equal a random point random
77:20 - times by the width of the screen so
77:22 - canvas dot width
77:26 - but because
77:27 - it can go up to its radius off the left
77:29 - and its radius off the right well that
77:31 - will mean we'll have to add the total
77:34 - with the size of the roid here roid
77:36 - size
77:38 - which is the diameter in effect just
77:40 - bracket that
77:42 - and then fine so that'll generate a
77:43 - number a number between zero and say the
77:46 - width is 500 so 500 plus 100
77:50 - is 600 so 0 and 600 but we want it to be
77:53 - able to be negative so we'll have to
77:54 - subtract the radius so it'll be the roid
77:58 - size
77:59 - minus the roid size divided by 2 which
78:01 - is the radius
78:03 - do a similar thing for a
78:05 - y
78:06 - except that it will be the height
78:10 - good and now the ship's
78:13 - uh angle
78:14 - and position
78:17 - now the ship's angle
78:18 - it'll just be random we'll just randomly
78:20 - generate an angle anywhere between 0 and
78:22 - 360 degrees so in radians let's do a
78:25 - math random first math random
78:28 - times 360 degrees in
78:31 - in radians which is just pi times two
78:34 - good now the x location and the y
78:37 - location i'm not planning to move the
78:39 - ship at all that'll be far too
78:40 - complicated and i think it's a pretty
78:42 - good strategy just to sit in the middle
78:44 - turn to the nearest asteroid and shoot
78:46 - so we'll keep it fixed so sx will just
78:49 - equal the ships
78:51 - starting sorry the ship's starting x
78:54 - and s y
78:56 - will just equal the ship's starting y
79:00 - next we'll need to work out which
79:02 - direction to turn
79:04 - based on the angle of our ship and the
79:06 - angle of the asteroid
79:09 - so calculate
79:12 - the angle to the asteroid
79:16 - how about we write a function for this
79:18 - because it's possible that we'll use it
79:19 - again
79:21 - just down here
79:22 - function we'll give it a generic name
79:24 - such as angle
79:26 - to
79:27 - point
79:28 - angle to point we'll have to use some
79:30 - trigonometry here so we need to know our
79:32 - current position so x and y
79:35 - we'll need to know our facing or bearing
79:37 - we'll call that bearing
79:39 - uh we'll need to know the targets x and
79:41 - y location target x and target y
79:46 - and i think that's all we need to know
79:48 - so let's angle
79:51 - to
79:52 - target
79:53 - so let angle to target equal well it'll
79:56 - have to be the inverse tan because we
79:58 - have x and y coordinates so tan is
80:00 - opposite over adjacent so a10 there's
80:03 - two types of atans here there's a10
80:06 - which is our regular mathematics
80:08 - tangent
80:09 - but that doesn't take into consideration
80:11 - coordinate space you know how we have
80:13 - four quadrants in coordinate space
80:16 - but a10 2 does take into consideration
80:19 - that so we'll use that now it requires a
80:21 - y and an x so we'll have to find the
80:23 - differences between our
80:25 - target and our self
80:27 - so we'll put
80:28 - so this will be the y differences so
80:31 - it'll be target
80:33 - y
80:35 - minus
80:36 - y
80:38 - right and the x's will be the symbol a
80:40 - similar thing target x minus x
80:45 - however because y's on screen like pixel
80:48 - wise are in the opposite direction so as
80:51 - we go up the screen we're actually going
80:53 - in a negative y direction so we'll have
80:54 - to apply a negative to that and a
80:57 - negative to that so it'll be minus
80:58 - target y plus y
81:00 - target x minus x y x yep that's good
81:05 - we'll have to find the differences
81:07 - between our angle to the target and our
81:08 - bearing so we can just go let say diff
81:12 - equal
81:12 - our bearing
81:14 - minus
81:16 - the angle to target
81:19 - angle to target
81:22 - now that could result in a whole range
81:24 - of numbers because this a 10 2 function
81:27 - it returns a number between effectively
81:29 - 180 degrees and minus 180 degrees so it
81:33 - could be negative
81:35 - our bearing could be anywhere between 0
81:37 - and 360. so just that was 0 and we had
81:40 - 180 here we'll get a negative number
81:42 - won't we
81:43 - if the bearing is say
81:45 - 360 and our angle is minus we'll get a
81:48 - number
81:50 - over 360. so we'll need to do some
81:53 - normalizing as such here so how about we
81:55 - have or we can just return this i think
81:57 - return
81:59 - the
82:00 - diff
82:02 - remembering we can add 360 degrees to
82:06 - any angle and it's still the same
82:08 - effective angle if i'm facing 40 degrees
82:10 - and i add 360 degrees so 400 degrees i'm
82:14 - still facing at the same angle aren't i
82:17 - so
82:18 - we will add
82:20 - the
82:21 - we'll add 360 degrees math pi times 2
82:26 - but that would that could get us above
82:29 - 360 couldn't it'll get us above zero
82:31 - which is what we want but it could also
82:32 - get us way above 360. so we'll find the
82:34 - modulus of that the remainder so modulus
82:38 - math
82:39 - pi
82:40 - times 2 so that will
82:42 - guarantee us a result between 0 and 360
82:46 - degrees in effect in radians right so
82:48 - back up here we can just go let
82:52 - angle say angle equal call that function
82:55 - angle
82:57 - angle to point
82:59 - we have to pass the correct parameters
83:00 - so the x is our ship location ship x
83:04 - ship y
83:05 - the bearing is the ship's angle
83:07 - the target x is the asteroid x and the
83:11 - target y is the asteroid y so that'll
83:14 - give us our
83:15 - absolute angle as such
83:17 - and then we need to determine
83:20 - the direction to turn
83:23 - right so that's probably let's say let
83:26 - direction
83:27 - equal
83:28 - [Music]
83:29 - well if that angle is greater than 180
83:32 - degrees so angle
83:34 - is greater than math.pi that's 180
83:38 - degrees
83:39 - then we'd like to turn
83:42 - left so remember we have to um put in
83:45 - zero one here how about we set these as
83:47 - constants i think that would be the best
83:48 - move
83:49 - so back up here in our neural network
83:51 - parameters let's have constant
83:53 - output
83:55 - left
83:56 - will equal zero so that will be the
83:59 - expected
84:01 - output expected neural output
84:04 - for turning left
84:07 - similarly we'll have the output right
84:12 - which will equal one
84:14 - and that will be the expected neural
84:16 - output for turning right
84:18 - okay
84:20 - so back down here if the angle is
84:22 - greater than 180 math pi we'll
84:25 - output left
84:26 - else will output
84:28 - right so finally we just need to train
84:32 - the network
84:35 - so we can call
84:37 - neuralnetwork.train to do that it takes
84:39 - an input array
84:40 - so the input array is just our
84:42 - position of our asteroid ax and ay
84:45 - and the
84:47 - angle of the ship
84:49 - and the output array the expected array
84:51 - is just an
84:53 - array with direction in it it's just a
84:55 - single
84:56 - length sorry a one length array
84:59 - that's our training so we'll be training
85:02 - that every iteration
85:05 - now if i foresee one problem
85:08 - where this a x a y and s a they take on
85:11 - strange values so ax could be a number
85:14 - like 600 a y could be minus 23.
85:17 - sa could be
85:19 - uh
85:20 - 3.8 or whatever right
85:22 - they're not normalized are they but
85:24 - let's see what they do it might not be
85:26 - an issue
85:31 - okay
85:32 - you can see that these errors don't seem
85:34 - to be getting any better let's pump up
85:37 - the
85:38 - number of
85:40 - pump up the number of samples
85:43 - just while we're here we'll that's the
85:45 - number
85:46 - of training
85:49 - samples
85:51 - so we'll pump that up to 1 million let's
85:53 - see what that does
85:59 - to me that looks like it's not getting
86:01 - anywhere
86:02 - because these errors are still
86:04 - incredibly large
86:07 - they're not getting any closer to zero
86:09 - so i don't like that so i think we'll
86:11 - need to normalize our data
86:14 - we'll put that back to oops we'll put
86:16 - that back to a hundred thousand i don't
86:18 - think we need a million samples but a
86:20 - hundred thousand should do us head back
86:22 - down to our training here
86:25 - we'll need to normalize this data here
86:28 - before we input it into the training
86:30 - array so how about we create a method a
86:33 - new function called say normalize input
86:36 - or similar so just before shoot laser
86:39 - function
86:40 - normalize
86:42 - input
86:43 - we'll need to pass the roids x location
86:46 - the roids y location and our ships angle
86:51 - they're our three neural inputs now what
86:53 - we mean by normalize is normalize
86:56 - the values
86:58 - to between
87:01 - zero and one
87:02 - so we'll divide them by something in
87:04 - order to get them to be between zero and
87:06 - one
87:07 - so let's create a new
87:09 - uh array an empty array
87:12 - called input let input equal empty array
87:15 - and input
87:17 - zero
87:18 - that will be
87:19 - our roid x
87:22 - value
87:23 - we'll need to now normally you could
87:25 - just go right x divided by the canvas
87:27 - width that would give give us our screen
87:29 - position our relative screen position
87:31 - but because we've allowed it to be off
87:33 - screen up to its radius then we'll need
87:36 - to modify this so roid
87:38 - x
87:39 - so that could be negative 50 could be
87:42 - negative it could be the negative radius
87:43 - it could be negative 50. so we'll have
87:44 - to add the radius back to that to get it
87:47 - back to zero so roid
87:50 - size
87:52 - divided by two
87:54 - and we'll have to divide all of that by
87:58 - the new canvas width including the
88:00 - radius on the left and right so that'll
88:02 - be canvas
88:05 - width
88:07 - plus
88:09 - the diameter which is just the roid size
88:13 - let's just work through that logically
88:15 - so roid x could be minus 50. so minus 50
88:19 - plus
88:20 - 50
88:21 - equals zero zero divided by anything is
88:23 - going to be zero that's fine
88:25 - now the maximum value this could take
88:27 - would be
88:28 - just say we'll choose an arbitrary width
88:30 - of 500 so 500 plus 50 is 550
88:34 - plus 50 is 600 600 divided by 500 plus
88:39 - 100 is 600 so that'll be one that's good
88:42 - and halfway between say 250 250 plus the
88:46 - radius of 50 is 300 300 divided by 500
88:50 - plus 100 600 300 divided by 600 equals
88:53 - 0.5 that sounds good
88:56 - we'll do the similar sort of thing for
88:58 - the x sorry for the y
89:01 - position
89:02 - except that we'll use the height instead
89:06 - now the next one ships
89:09 - angle this is a bit of an easier
89:11 - exercise all we have to do is
89:13 - divide the
89:15 - past angle so that'll be a number
89:17 - between 0 and 360 in effect in radians
89:21 - we just have to divide that by 360. so
89:24 - math
89:25 - pi
89:26 - times two so an angle of zero divided by
89:29 - that would be zero an angle of 360
89:31 - divided by that would equal one and
89:33 - everything in between that's great let's
89:36 - return that input
89:38 - array so let's go up and implement that
89:40 - in our training section
89:43 - train the network so all we have to do
89:45 - is normalize this data beforehand
89:48 - normalize input before we put it through
89:51 - our
89:52 - chain function
89:53 - let's give that a go
89:59 - it's looking better
90:01 - at least it's getting closer to zero
90:03 - there's some discrepancies here maybe we
90:05 - just need to modify some of the
90:08 - parameters here so how about we bump up
90:10 - a number of hidden to say 20
90:12 - and we'll set our number of samples to
90:14 - say
90:15 - 500 000.
90:17 - just while we're here we might as well
90:19 - change the number the amount of logging
90:21 - let's change that to say every 20 000
90:24 - instead
90:25 - okay
90:27 - let's give that a go
90:31 - so it's a bit slower because we've got
90:32 - more hidden uh neurons
90:35 - but it does look like it's getting
90:37 - better the the errors aren't too bad are
90:40 - they
90:42 - look at that one down the bottom very
90:44 - close to zero so i think we've done
90:46 - quite well with that if we put that
90:48 - if we put the hidden nodes back to 10
90:51 - it'll speed it up a bit will that impact
90:53 - the quality let's have a look
91:00 - that's pretty good too actually
91:02 - either way well let's leave it at 20 and
91:05 - 500 000 number of training samples
91:08 - just while we're here i'm thinking that
91:10 - we'll need an output threshold because
91:13 - none of these predictions are going to
91:14 - be exactly zero or exactly one are they
91:17 - but they might be close
91:19 - so how about we create a threshold
91:22 - for example 0.25 just an arbitrary value
91:25 - to begin with
91:26 - and this is how close the prediction
91:28 - must be so how close
91:31 - the prediction
91:32 - must be
91:34 - to
91:35 - commit
91:36 - to a turn
91:38 - so at 0.25 for example if the prediction
91:40 - is 0.75 or greater we would commit to a
91:43 - right turn if the prediction was less
91:45 - than 0.25 we'd commit to a left turn
91:48 - however if the prediction was say 0.5 we
91:51 - won't do anything we'll just sit in the
91:52 - middle so how about we start
91:54 - implementing some of this so let's go
91:56 - down to well first of all let's see what
91:58 - happens when we push the left and right
92:00 - arrow keys so in the key down method
92:04 - so when we've got manual control of this
92:06 - all we're doing is setting the ship's
92:07 - rotation to this
92:10 - how about we create a function that can
92:12 - handle because when we turn right it's
92:15 - the same thing except we're going the
92:16 - opposite direction so let's pull those
92:18 - out and create a function for that
92:20 - because we'll need to call this function
92:22 - what will we call it rotate
92:25 - ship
92:26 - it was pass a boolean we'll say that
92:29 - false equals left
92:32 - right false equals left and here
92:35 - we'll rotate ship
92:39 - true so that'll be right
92:41 - and let's what do we do in the key up
92:43 - method the key up just sets the ship's
92:45 - rotation to zero so that's fine we don't
92:47 - need to do anything with that so let's
92:49 - go down make that rotate ship
92:51 - just after our normalize input function
92:56 - rotate
92:57 - ship
92:58 - it'll take a boolean which is equal to
93:01 - right
93:02 - so we'll be doing that
93:05 - now if it's right we want to put that as
93:08 - negative so how about we make a variable
93:09 - called say let sine
93:12 - equal now if it's right
93:15 - if it's right the sign will be -1 else
93:18 - it will be positive one
93:20 - and we'll just multiply this by
93:23 - the sign
93:26 - that should be okay just to make sure we
93:28 - haven't broken anything how about we
93:30 - turn it back into manual mode
93:32 - so automation on is false
93:35 - and make sure that we can control this
93:36 - ship
93:38 - yep i can turn left and right no problem
93:41 - that's all good
93:43 - put that back to true
93:45 - and now let's go down to our update
93:48 - function where is that down here
93:52 - to do control the ship
93:54 - so we'll need to make a prediction make
93:57 - a prediction
93:59 - based on current data
94:03 - so let's make some variables so we need
94:05 - to know the asteroids x which will equal
94:08 - roids
94:10 - um
94:11 - we'll just use because there's only one
94:12 - asteroid to begin with we'll just use
94:13 - roid 0 for the time being roid0.x
94:18 - similarly a y will equal roids
94:23 - sorry roids0.y
94:25 - and we also need to know the ship's
94:28 - angle don't we so that's just the ship
94:31 - dot a
94:32 - ship dot a
94:34 - now to make a prediction how we go let
94:37 - predict
94:38 - equal we just need to run our feed
94:40 - forward function
94:42 - feed
94:44 - feed
94:45 - forward
94:47 - it will take the input array so input
94:50 - array will be ax
94:53 - but we have to normalize this don't we
94:55 - so hang on do the normalize first
94:58 - normalize input it takes the voids x so
95:02 - a x
95:03 - a y
95:05 - and the ship's angle
95:07 - normalize input
95:09 - remember that returns a matrix an output
95:11 - matrix so we'll have to take its data
95:15 - and there's only going to be one output
95:17 - so it'll be the first column and the
95:19 - first so the first row first column 0 0
95:23 - that should be our prediction
95:25 - now we need to decide which way to turn
95:27 - so make a turn
95:30 - now we're going to get a value it's not
95:32 - going to be exactly zero it's not going
95:34 - to be exactly one so how about we find
95:36 - the difference between it between the
95:38 - prediction and our
95:40 - left and right turns so let
95:42 - we'll call it delta left or difference
95:45 - left whatever you're going to call it
95:47 - delta left will equal the prediction
95:49 - make this the absolute value math
95:51 - absolute value
95:53 - it'll be the prediction
95:57 - minus the
95:59 - uh output
96:01 - uh constant output left
96:04 - right and delta right
96:08 - will equal the prediction minus the
96:10 - output right
96:12 - so let's just
96:14 - try to analyze that so the prediction
96:15 - just say the prediction is 0.2
96:17 - right
96:18 - so 0.2 minus output left is 0.2 that
96:21 - means there's only it's 0.2 units close
96:24 - to the left
96:26 - 0.2 minus
96:28 - 1 is 0.8 the absolute value will be 0.8
96:30 - so that's not going to be what we want
96:32 - to do so we'll have to compare it we'll
96:33 - have to compare these to our thresholds
96:36 - okay
96:37 - so if
96:38 - delta left
96:41 - is less than our output threshold so if
96:45 - it's less than 0.25 or whatever value we
96:47 - choose to set it at
96:49 - then we wish to rotate left rotate ship
96:53 - now left is just false
96:57 - okay else if
96:59 - delta right
97:02 - is less than the output threshold
97:06 - then
97:07 - we will rotate the ship right
97:10 - which is true
97:12 - now if it's neither so for example 0.5
97:15 - 0.5 minus the output left is 0.5 0.5
97:18 - minus output right it's not going to be
97:20 - less than the threshold in either of
97:22 - these situations so how about we just
97:24 - put an else here saying that
97:26 - um
97:26 - [Music]
97:28 - stop rotating
97:30 - so if it's not confident it'll stay
97:32 - still so ship dot rotate
97:35 - equals zero so that's equivalent to us
97:38 - releasing the arrow keys
97:40 - i think we should just log this
97:42 - prediction here so console
97:44 - log
97:45 - predict
97:47 - just so
97:49 - we can see if there's any problems with
97:50 - it
97:51 - okie dokie let's try it
97:56 - so we're just training it to begin with
97:58 - with 500 000 samples
98:00 - the errors look pretty good
98:03 - that one wasn't very good
98:08 - okey-dokey what's it doing
98:11 - it seems to be stuck i know
98:15 - now it is turning
98:18 - it's kind of slowly turning
98:21 - towards the asteroid will it turn when
98:24 - it goes past it yes
98:27 - it's okay it's maybe not the best
98:31 - now i wonder why
98:34 - we'll just watch it a bit longer it's
98:36 - kind of getting confused a bit isn't it
98:39 - okay i've been watching this for a while
98:41 - now it looks like something's going
98:42 - wrong because it eventually the ship no
98:45 - matter how many times you run it the
98:47 - ship eventually starts spinning around
98:49 - in its inner circle without
98:51 - and it's got these really
98:53 - very confident predictions so see this
98:56 - prediction here it's very very low it's
98:58 - close to zero
98:59 - so
99:00 - i'm guessing something's going wrong
99:02 - with our angle so let's go into our
99:05 - code maybe we should log the angle here
99:08 - ship
99:09 - dot
99:10 - angle
99:12 - let's see what that does
99:18 - okay it's loading the training data
99:19 - again
99:31 - okay so the angle remember it'll be a
99:33 - number between 0 and 2 pi which is about
99:36 - 6 or so
99:37 - now that's not good see the angle is
99:39 - going negative there we want the angle
99:41 - to be zero between zero and two pi so
99:44 - there's something
99:45 - i think i might know what's wrong
99:48 - if we head down to where we rotate our
99:50 - ship in the update function
99:53 - i suspect that we're just letting it add
99:56 - on endlessly
99:57 - we are so for example the ship out the
100:00 - ship angle can just keep going up and up
100:02 - and up and up so it'll go beyond 720 and
100:04 - so on it could go below zero no problems
100:06 - which is fine it was working fine in the
100:08 - game but for our prediction we want it
100:11 - to be between 0
100:13 - and 360. so we want to keep the angle
100:17 - between
100:18 - 0 and 360 which is 2 pi remember 2 pi
100:23 - so if the ship's
100:26 - angle is less than 0
100:29 - we'll need to add 360 to it remembering
100:32 - if we add 360 it'll still be the same
100:33 - angle so plus equals
100:36 - math
100:37 - pi do we need to bracket this i'm not
100:39 - sure
100:40 - i'm not sure what the order of
100:42 - operations are for these
100:43 - these assignment operators we'll just
100:45 - bracket it won't hurt math times two
100:49 - we'll add 360 to it
100:52 - else
100:53 - if
100:54 - a ship's angle
100:56 - is greater than
100:58 - or equal to
101:00 - 360.
101:01 - 360. math times i'll bracket this one as
101:04 - well math dot pi
101:06 - times 2 if it's greater than that then
101:10 - we'll want to subtract we want to do the
101:11 - same thing except that we'll subtract
101:15 - 360. we don't want exactly 360 because
101:17 - our randomly generated uh position will
101:20 - never be 360 i don't think
101:24 - minus equals that
101:26 - and
101:27 - that should do it
101:29 - let's give that a go
101:30 - let's load it up
101:32 - loading the training data
101:36 - so the training data looks pretty good
101:38 - it should be working quite well
101:43 - okay
101:44 - i think that's acting a lot better
101:47 - where's the asteroid there's the
101:48 - asteroid yeah i think it's tracking it
101:50 - quite well
101:53 - i think that was our problem
101:55 - yep so it's choosing the first asteroid
101:57 - which is whatever's in the in the array
101:59 - first in the array and following it
102:02 - good okay how about we add some shooting
102:05 - to this little ship
102:07 - so let's head back all the way up to the
102:09 - top to set some
102:12 - parameters
102:13 - so we'll probably need to give the ship
102:15 - a
102:16 - rate of fire so just in under our neural
102:18 - network parameters here let's create one
102:21 - called rate of fire
102:24 - and we'll set that to say five shots per
102:27 - second so shots per second
102:32 - we'll also need to keep track of how
102:33 - many frames we count down to the next
102:36 - shot so
102:37 - where we set up our neural network here
102:39 - let's just put in a new something called
102:42 - say a i
102:43 - shoot time
102:45 - and we'll set that to zero to begin with
102:48 - where will we update that well we'll
102:50 - update that in
102:53 - our water where we do our prediction
102:57 - so just after we make it turn now what's
102:59 - the strategy for firing when when will
103:01 - we shoot well we could shoot just when
103:04 - it's not rotating
103:06 - but that's not really what i do i keep
103:08 - turning and just shooting all the time
103:09 - because eventually you're going to get
103:10 - lucky too so how about we shoot all the
103:13 - time it'll shoot as often as it can so
103:15 - shoot the laser
103:18 - if a i shoot time
103:20 - equals zero which will it'll start at
103:23 - zero then we want to reset that a issue
103:26 - time not this
103:27 - a i shoot
103:29 - time
103:30 - will equal the frame rate divided by the
103:33 - rate of fire
103:35 - i think we should find the ceiling of
103:37 - that
103:39 - math.seal
103:42 - so if we had a frame rate of 30 divided
103:44 - by the rate of fire of 5 that'll every 6
103:47 - frames we'll shoot if it was 10
103:50 - so 30 divided by 10 would have we'd be
103:52 - shooting every third frame so quite
103:55 - quickly
103:56 - uh we'll need to shoot the laser shoot
103:58 - laser
104:00 - just
104:01 - checking that function
104:03 - because part of that condition is that
104:05 - the ship can shoot and when we shoot a
104:07 - laser the ship can't shoot
104:10 - that's because the player must push the
104:12 - space key then release it so we'll have
104:14 - to set that up to be able to handle that
104:18 - or we can we can just do it here ship
104:20 - dot can shoot equals true so whenever it
104:24 - can fire we'll let it fire
104:27 - else so if the ai shoot time doesn't
104:29 - equal zero we'll want to count down a i
104:31 - shoot time minus minus so this is just
104:33 - counting down the frames left
104:36 - so let's give this a go
104:39 - so loading in our training data
104:43 - so hopefully this little ship will
104:45 - follow the first asteroid and just keep
104:48 - shooting at it until it's destroyed and
104:50 - then it'll follow the next asteroid
104:53 - yeah that's what it's doing
104:57 - bang bang bang bang yeah just keep
104:58 - shooting it's pretty effective actually
105:02 - even when we're not targeting the
105:03 - closest asteroid
105:05 - so how about we program it to target the
105:08 - closest one so head back into our
105:12 - update function
105:16 - so compute
105:19 - the closest
105:21 - asteroid
105:23 - uh we'll need to keep track of the index
105:25 - so how about we just make a variable
105:27 - called say let c equal zero so this will
105:31 - be the closest index in the array
105:34 - uh we'll need to calculate the distance
105:36 - we'll need to keep track of the closest
105:37 - distance so we'll call that say distance
105:40 - zero
105:42 - will equal we have a method for
105:44 - calculating distance distance between
105:46 - points
105:47 - uh the x1 y1 so the ship dot x
105:51 - the ship dot y
105:55 - uh the x2 will be the asteroid so roids
106:00 - zero
106:01 - dot x
106:03 - roids
106:05 - zero
106:06 - dot y
106:09 - and then we'll have to loop through each
106:11 - of the asteroids so four let i equal
106:15 - zero
106:17 - actually let it equal one because we've
106:19 - already calculated the first one
106:21 - distance zero there so let i equal one
106:24 - i is less than the asteroid's length
106:27 - roid's dot length
106:29 - i plus plus
106:32 - and then we need to
106:35 - get the distance of the current
106:36 - asteroids we'll call that distance one
106:38 - distance 1 will equal distance it's
106:40 - going to be the same thing really
106:43 - basically
106:45 - except that we'll be using i instead of
106:48 - 0 here
106:51 - and then all we have to do is do a check
106:53 - to see if that one's that distance is
106:55 - smaller less than the uh
106:58 - current distance so if distance
107:02 - 1 is less than distance 0
107:06 - that means it's smaller doesn't it so
107:08 - we'll replace distance zero distance
107:10 - zero will equal
107:12 - distance one and we'll want to update
107:14 - our
107:15 - uh index closest index so c will equal i
107:19 - so all we have to do is put that c
107:22 - into where we've got zero down here so
107:24 - ax will equal right c
107:26 - a y will equal roid c dot y
107:29 - and let's give that a go
107:32 - loading our training data again
107:37 - so hopefully it'll turn towards the
107:39 - closest asteroid and shoot at it
107:43 - there's only one asteroid here
107:45 - that reminds me we should probably up
107:47 - the number of starting asteroids back to
107:50 - its original so roid numb will equal
107:52 - three
107:54 - save that
107:56 - load it one more time
108:07 - okay is it turning towards the closest
108:10 - one
108:11 - certainly it's not shooting the furthest
108:12 - away ones anyway
108:14 - so it's doing fairly well
108:17 - it's not perfect
108:21 - i'm thinking we could probably make this
108:23 - a little bit better i think we'll do one
108:26 - more one more update to our little
108:28 - function here
108:30 - how about we pass some more information
108:33 - because we're only passing kind of the
108:34 - bare minimum we're passing the asteroid
108:37 - location
108:38 - and the ship's angle i think we can do
108:40 - better than that so head back into the
108:41 - code
108:42 - to head down to where we set up our
108:44 - training data
108:47 - what else could we pass
108:48 - well we are calculating the angle to the
108:51 - asteroid
108:53 - how about we stick that in as one of our
108:54 - inputs so we'll put it in after our
108:57 - asteroid position
109:00 - we'll have to bump up the number of
109:01 - inputs to four
109:05 - so down here our normalize input we'll
109:08 - have to add an extra
109:10 - here we'll pull that roid
109:12 - angle right angle it'll be our third one
109:16 - it's going to be very similar to how we
109:18 - do the ship angle we'll just put right
109:20 - angle there roid angle
109:22 - ship angle update its index to three
109:25 - uh wherever we call this what that fix
109:27 - it up which is just down in our update
109:30 - function
109:31 - so we'll have to pass an angle in there
109:35 - and we'll have to calculate that angle
109:37 - so what do we need to know for that we
109:39 - need to know the ship's x and y
109:40 - coordinates so s x will equal ship dot x
109:45 - you didn't you don't really have to do
109:46 - this but this is to make it clear
109:49 - ships y
109:50 - ship dot y
109:52 - and let angle equal
109:55 - angle
109:58 - angle to point now what does it take x
110:01 - and y which is the ship x and the ship y
110:04 - it takes the bearing which is the ship's
110:07 - angle
110:08 - the target x which is the asteroids x
110:11 - and the asteroids y
110:13 - and then we'll pass that in through our
110:15 - feed forward function to get a
110:16 - prediction i don't think we need to log
110:18 - this anymore with this prediction
110:20 - uh let's take a look at that
110:26 - okay import um
110:28 - doing our training
110:30 - wow those errors are very small so
110:31 - they're e to the minus 15 there's a
110:34 - couple of zeros in there so they're very
110:36 - precise
110:38 - so looking at our ship's performance
110:40 - yeah he's doing pretty well
110:42 - he should be doing very well the only
110:44 - issue i can see is that see that jitter
110:45 - there that's because we're only making a
110:48 - prediction every frame if we increased
110:50 - our frame rate we could probably make
110:52 - that better
110:54 - and also if we reduced our threshold to
110:57 - decide whether we turn or not so let's
110:59 - do that now
111:01 - so head up to the top
111:03 - we'll reduce our output threshold to say
111:05 - 0.05
111:06 - that means in order to make a right turn
111:08 - we'd have to have 0.95 confidence
111:11 - let's increase the rate of fire for fun
111:13 - to say to 15 shots per second
111:16 - and we want to increase our frame rate
111:19 - to say 60.
111:21 - let's give that a go eh
111:26 - okay just loading our
111:28 - training data
111:30 - the errors are very very good
111:38 - and here he goes
111:40 - wow
111:42 - we've created a monster
111:45 - so with his increased
111:46 - with his increased rate of fire
111:49 - and the faster frame rate
111:52 - he can make more accurate more subtle
111:54 - turns
111:55 - and really pepper those asteroids with
111:58 - laser fire
112:01 - cool
112:02 - so anyway that's the end of our tutorial
112:04 - series so we've gone from using matrix
112:06 - maths
112:07 - to creating a neural network only a
112:09 - fairly simple neural network but a
112:11 - neural network all the same i hope
112:13 - you've learned a lot from this i
112:15 - certainly have because i had to do a lot
112:16 - of research in figuring all this stuff
112:18 - out
112:19 - but in the end we managed to use our
112:20 - network to control a simple game such as
112:23 - asteroids and this is the result
112:26 - i wonder how far he could go how far
112:28 - could this uh what level could this
112:31 - ship reach
112:32 - well anyway feel free to download the
112:34 - code and try it out for yourself update
112:36 - the parameters have a play and learn
112:38 - something new
112:40 - until next time
112:41 - talk to you then bye
112:43 - [Applause]
113:09 - [Applause]

Cleaned transcript:

hi all and welcome to this new tutorial series to create a neural network in javascript which we will hopefully use to automate the game asteroids now we made this game asteroids in another tutorial series so feel free to check that out you can download the code from the links below there should be a sounds folder and an html file so let's open the game up so there's a triangular ship that can be moved around the screen and it can shoot the asteroids i'll just mute that so the goal of this tutorial series is a very simple one and intentionally so because new neural networks can be quite challenging the goal is to rotate towards the closest asteroid and shoot rotate to the next closest asteroid and shoot it's not going to be an algorithm we're going to train a neural network to do this so what is a neural network well here it is basically they're made up of a number of layers so an input layer a hidden layer and an output layer you can have multiple hidden layers but we'll focus on just having a single hidden layer to keep things simple now the input layer it will take our game information so we could pass things such as the angle to the nearest asteroid or the current angle of the ship the hidden layer is more like a processing layer i guess and the output well we'll probably have a single output whether to turn left or turn right so that'll be a single boolean so zero will mean left one will mean right we'll keep things nice and simple because these things can be quite complicated in between each of these layers there's a whole bunch of black arrows now each of these black arrows represent a weight a weight between 1 and 1 i believe so for each neuron in the previous layer it sends out information to each of the neurons in the next layer so ultimately we'll be sending in some training data for example the asteroid position and the ship's current angle or something similar and we'll feed that through with an expected output so either to turn left or turn right now if it gets it wrong we'll send that information back to the input i guess and use that to correct these weights so ultimately we'll be sending in thousands of points of information correcting these weights until finally we have a unique set of weights that can take any of our game information and give us an accurate and reliable output so here's the position of an asteroid what do i do turn left here's another position of a different asteroid what do i do turn right let's just close that down we'll have to create a new javascript file just a plain text document called say neural network neural network and give that the js extension yes and open both of those in your favorite editor i'm using visual studio code here so the first thing we should do is set up a flag to let us know that automation is on so currently we have a whole bunch of flags in here how about we pull them out and we'll put them in a different section just to make it a little bit tidier how about developer flags paste them in there sorry just doing some housekeeping so let's create a new constant called automation automation on we'll set that to true initially so when the automation is on we'll want to set up our neural network so just after we set up the game parameters here so after new game here set up the neural network so if automation is on let's leave ourselves a todo here because we can't do it at the moment to do neural network good now also when the automation is on we don't want the player to be able to to control the ship do we so down in our key press uh functions so key key down yep here we go key down and key up so if the ship is dead or automation is on return don't do anything so they can press the keys as much as they like nothing will happen similarly in the key up method if ship is dead or automation is on return we'll let the computer control the ship speaking of computers controlling ships let's head down to the update function that's where all the objects drawn and moved and so on so just the start of the update function just up near here somewhere how about we say use the neural network to control to rotate the ship and shoot and shoot so again we'll just leave ourselves so if automation is on we'll leave ourselves a todo here so do uh control ship okay good let's just make sure that we haven't broken anything so head up the top uh first of all let's try it with the automation flag on okay so i'm moving the arrow keys i'm pushing the spacebar nothing's happened and just to make sure that we haven't broken anything let's set it to false yep i can control the ship in that situation so when it's turned on when it's true i've lost control of the ship awesome now head over to our new file neural network dot js at the top of that file let's use a flag use strict now what use strict does it basically enforces good coding practice things like you must declare variables and so on we're also going to focus on es6 javascript now es6 is like the latest major revision to javascript syntax things like class and constructors and so on so we're going to use that we'll try to use that throughout this tutorial series now neural networks use a lot of maths specifically matrix maths so how about we create a heading here called matrix functions a matrix is essentially just a twodimensional array so it has a number of rows and a number of columns so i'm just making this stand out a little bit matrix functions there we go so how can we represent a matrix well how about we represent it as a class so class matrix give it a constructor the constructor will take a number of rows and a number of columns and how about optionally we'll have data here as well so if we put an equal sign here it's a default value so by default it will be an empty array so inside the constructor let's set the variables now usually private variables private instance variables are prefixed with an underscore so we'll follow that convention do the same sort of thing for the columns and the data calls and data now to access those variables we should put some getters so just get rows and all that does is return this dot underscore rows and do a similar thing for each of the other variables so coles data this calls and this data so to use that when we declare an instance of this matrix we'd go matrix dot rows and that would return this dot rose so inside the constructor let's initialize initialize with zeros initialize with zeros if no data provided so if data equals null somebody could pass null couldn't they or data dot length equals zero so in the default case that's true if either of those things occur then we want to populate this data this data will equal a new empty array you'll have to loop through each of the rows so four let i equals zero so let's is one of these new es6 words basically it means that i is only visible within the for loop let i equal 0 i is less than this rows i plus plus lowercase i plus plus we'll want to initialize the row so this data i will equal an empty array and we'll loop through each of the columns so let j equals zero j is less than this coles j plus plus this data will this data i j so we'll set each of the elements to equal zero good if data is passed we'll probably want to check its integrity for example somebody could put three rows three columns but provide data with only two rows so that's not good is it so let's put an else here else will check data integrity so if the data's length doesn't equal the row number doesn't equal rows or data maybe data zero dot length so that's the column length isn't it doesn't equal coles then let's throw a new error so throw new error now the error takes a message you can just put something like incorrect uh data dimensions that should be enough so let's test this let's go back to our main file we'll have to import that file so we can do that up in the style script create script tags so script and we'll need a type type will equal text javascript and the source will equal dot sorry dot slash that means the current directory uh neural network whatever we named our file neural network dot js close the script tags so head down to where we will initialize or set up our neural network just in here let's try to set up some matrices so let m0 equal new matrix uh rows say two rows three columns and let's output that to make sure that it's working we could probably use the table command here because it outputs table data tabular data so m0.data that's the data of our matrix let's take a look at that just need to open the console here we go we have a 2 by 3 matrix full of zeros that's good let's try to pass some data so we can do that by setting up an array here so an array of arrays i should say so 2 1 just adding some values here and the next row four three uh four three zero say okay let's give that a go there we go two one minus one four three zero two one minus one four three zero now what if we declared the incorrect dimension here just so we said a three by three matrix instead of a two by three let's check our area checking good error incorrect data dimensions put that back to awesome head to our other file to create another function so let's create a function that randomizes the weights or creates a random set of weights remember between our neurons there's going to be some weights between 1 and 1 so let's create a function for that so apply random weights between minus one and one so we'll call this random weights so this is inside our class for let i equals zero i is less than this dot rows i plus plus for the columns for let j equals zero j is less than this dot columns j plus plus this dot data i j will equal math random that's a number between 0 and 1 times 2 times two minus one so a random number between zero and two minus one is minus one between minus one and positive one good let's test it in our other file so on m0 we can just go m0 dot random weights and hopefully that should work so currently that's what it looks like let's run it ah there we go yep that looks good we got some random weights negatives positives and everything in between great head to our other file and let's create our next method add to matrices so we'll make this a static method that just means we don't have to instantiate the class we can just call it directly we can go matrix dot add it will require two matrices m0 and m1 we probably want to check that them to make sure that they have the same dimension so we can go we'll create a new method a new static method matrix dot check dimensions it will require m0 and m1 let's create that now actually so check matrices have the same dimension same dimensions so static check dimensions m0 and m1 if m if m0.rose doesn't equal m1 dot rose or m zero dot coles doesn't equal m one dot coles then let's just throw a new error throw new error the message we could how about matrices are of different dimensions okay so we check that now we'll need to create a in our add method we'll need to create a new return matrix so let m equal new matrix uh the rows will just be the same as what's passed so m0 dot rows m0 dot columns and we'll need to loop through each of those so let i equal zero i is less than m dot rows i plus plus and another loop for let j equals zero j is less than m dot coles j plus plus what will we do here so m dot data i j will equal i'll just copy that m 0 m 0 dot data i j plus m 1 dot data i j so we're just adding the each individual cells together and assigning it to the new matrix and we'll have to return that matrix return m okay let's test that in our other file first we need a couple of more matrices to test with so let's create two more m one which will be two by three and just change up some of these numbers here that will do and m two will be a different sized matrix say two by two so let's just delete that okay good uh let's try it we don't need to use this random weights anymore let's try to add m1 and m2 it shouldn't work because there are being invalid sorry they're of different dimensions so matrix dot add m1 m2 let's try that error matrices are of different dimensions and that's in the that's on line 81 yep that's correct how about we try to add m0 well m m0 and m1 they should add we'll probably want to print out the data before we add them m0 data m1 data and we'll print out this starter there we go so we'll add that and show the data of the result matrix okay so the first matrix two one f one four three zero next matrix zero one blah blah so adding each of these so two plus zero equals zero sorry two plus zero equals two four plus two equals six that's right one plus one equals two three plus minus three is zero minus one plus minus one is minus two and zero plus zero zero plus zero equals zero good adding works head back to our other file we also need to be able to subtract matrices so it'll be very similar to adding so just copy all of that paste it down here subtract two matrices subtract almost identical except that we just need to change this plus to a minus so it'll be m0 data minus m1 data so the order is important here let's test that right so instead of adding m0 and m1 how about we subtract okay so two minus zero is two four minus two is two one minus one is zero three minus minus three is six minus one minus one is zero and zero minus zero zero good it looks like it's working just make sure the error checking is working okay so m two minus m one should not work there we go error matrices are of different dimensions great we also need to be able to multiply two matrices together so in a similar way that we've subtracted them let's set up and multiply two matrices multiply two matrices multiply if you know anything about matrices this is not the dot product so let's make a note not the dot product that's a separate thing we'll need to do that too but it's a different operation it's just multiplying each cell by each cell so all we have to do is change that minus there to at times uh head back and test it so matrix multiply mol multiply uh m2 and m1 shouldn't work let's just make sure yep it doesn't work and m zero and m one should work good two times zero is zero four times two is eight one times one is one three times minus three is minus nine minus one times minus one is 1 0 times 0 0 looking good next let's calculate the dot product let's create a function to calculate the dot product of two matrices so dot product of two matrices so static dot m0 and m1 now for two matrices to be dot compatible as such the first one's columns must be the same as the second one's rows for example a four by two matrix and a two by four matrix they're dot compatible the inside numbers are the same so for example three by two and two by one they're compatible so let's test for that if uh m0.cols doesn't equal m1 dot rows then we have to throw an error here so throw oops throw new error and the error message can be just be matrices are not uh dot dot compatible okie dokie now the size of the resulting matrix so let's create a new matrix here let m equal new matrix the size of the resulting matrix is equal to the outside numbers for example four by two and two by four the resulting matrix will be a four by four three by two times a two by one would be a three by one so that'll be the m zero dot rows uh and the number of columns will be the m1 dot coles right next we have to do the similar sort of loops that we've been doing in all of these so that so for let i equals zero i is less than the m dot rows i plus plus and for let j equals zero j is less than the m coles j plus plus so inside here is where we need to do our tricky stuff basically we need to add so we need to multiply each cell of the first matrices row by each cell of the second matrices column and then add up those products i'll post a link below how to do this by hand if you're interested so we'll need to create a variable called sum let sum equal zero and another for loop for let k equal zero k is less than the inner number which will be the m0.cols k plus plus and then we'll have some plus equals so we'll continually add this together sum plus equals the m0 data i the ith row and then the kth column multiplied by the m1's data and it will be the k row remember the inside numbers are what's matching them by the jth sorry the jth column i think that's right sum plus equals that and then finally we need to set the i j so m dot data i j will equal the sum okie dokie and then finally we'll need to return that matrix return m so let's test that out in our other file so matrix dot dot m0 m1 now m0 is a 2x3 matrix m one's a two by three as well so they're not dot compatible let's just prove that yep error matrices are not dot compatible so which of these are dot compatible well how about m 2 m 2 times m 1 so a 2 by 2 times a 2 by 3 is dot compatible because the inner numbers are the same let's just update this here give that a go right so the first row entries times the first so times the second first column entries so 1 times 0 is 0 plus minus 1 times two is minus two yeah the second one so one times one is one plus minus one times minus three is positive three is positive four in total yep looks like it's working fairly well next function that we'd like to do is to create some sort of conversion function to convert a regular array to a matrix because when we pass in our input data from our game into the neural network we'll probably just pass it as a regular onedimensional array so convert array to a oneroad matrix so static uh convert array we'll call it convert from array we'll pass an array and all we'll do is return a new matrix a new matrix with one row the columns will equal the array.length and the data will just be the array itself okay let's try that first of all let's create an array so let array equal just make an array of any length with some random numbers inside we'll want to print that out to the console so console log array and we'll also want to print out the converted array so using table so matrix dot convert from array pass our array and we want to see the data of that okay oh we don't want to see the rest of this stuff so let's just comment that out let's give that a go incorrect data dimensions okay something's gone wrong here 25 in our matrix uh function where are we so up the top of here page f line number 25 okay so we failed this data integrity check i can see why because it's checking the data.length now the length of a single dimensioned array is the total length so it would be four in our case but we don't want that we want that to equal the rows which is one so to get around that all we have to do is create a two dimensional array in our convert array so convert from array here we just need to put square brackets around that so essentially we're putting an array inside of an array a 2d array okay let's give that a go that's better so our regular array four five six seven and our converted array to a matrix four five six seven so it's a four columned single row array great next we'll need to create a function that can apply a function to each cell of the given matrix so we'll call that map so just down here apply a function to each cell of the given matrix the reason we need to do that i do this is because in neural networks we'll be using a function called the sigmoid function and we'll need to apply it to every cell so let's create a static method static map which takes m 0 a matrix and a function we'll just call that m function and we'll need to create a new uh matrix so let m equal new matrix it'll be of the same size as the past so m0.rows m0 dot coles and we'll have to loop over in similar fashion to what we've done up here so let i equal zero i is less than m zero dot well m rows is okay too m rows i plus plus j yep and inside here all we need to do is go m data i j m data i j will equal the function of that data so the function of that of itself effectively m data i j and then all we have to do is return that matrix hang on we don't want to assign the m data because that's empty we want to assign the m0 data so the one that's been passed so that data we want to apply the function to and then we'll assign that result to our empty array sorry our empty matrix let's give that a go we don't want to see that array anymore so console table matrix dot map we want to map let's just choose one of these arrays so we'll choose m2 and let's apply a function we can use what they call an arrow function so that's just x equals greater than it looks like an arrow pointing rightwards and then we can just what do we want to do to x so x times two so that means we'll times every cell by two and also let's copy this just above let's show the original table okay let's give that a go so the original table one minus one three zero one times two is two three times two is six and so on that's working well and one more function so x divided by two say so point five three divided by one point five zero divided yet minus one divided by two is minus zero point five great that's our map function handled and the last function for today is to find the transpose of a matrix now the transpose of a matrix is simply when we switch the columns with the rows and vice versa so find the transpose of the given matrix so a 4 1 matrix will become a 1 4 matrix so static transpose it'll just take a single matrix as its parameter and basically we'll be doing something very similar to this just need to modify a few things so let m equal new matrix we need to switch the columns for the rows and we need to make sure that we loop over the the original the past matrix so m zero rows m zero columns now m data i j we want m data j i m data j i will equal m zero data i j let's test that out okay so matrix dot transpose let's transpose say matrix 1 so m1 and we'll just put the m1 data before it okay so the original the original matrix is 0 1 minus 1 and then the column down here is 0 1 minus 1 2 minus 3 0 2 minus 3 0 so a 2 3 matrix has become a 3 2 matrix excellent last time we created these matrix functions that like for example to add matrices and multiply them and so on so today we're focusing entirely on creating the neural network so first of all let's create the class neural network so class neural network create the constructor now the constructor needs to take the number of inputs the number of hidden and the number of outputs so num inputs num hidden and num outputs let's set the private variables the properties as such so we'll just call give them the same name just prefix it with an underscore num inputs equals num inputs num hidden num hidden equals num hidden and num outputs equals num outputs now going back to our diagram remember we have all these weights that are in between the input and the hidden layer let's call that weights zero and we'll call these weights here between the hidden and the output weights one so this underscore weights 0 will equal a new matrix the number of rows will be the number of inputs so this is the number this num inputs and the number of columns will be the number of hidden so this num hidden similarly weights 1 will equal a new matrix except that its number of rows will be the number of hidden and the number of columns will be the number of outputs okay for the weights 0 and weights one we'll need to set that we'll need to update them during our training process so let's create getters and setters for them so get weights zero that's simply return this underscore weights zero and we'll also want to set that so set weights zero uh weight weights set weights zero weights so we can just go this underscore weights zero equals weights right and we'll do a similar thing for weights one weights one this weights one weights set weights one this weights one equals weights great so we've done this one here next we need to randomize the initial weights so let's just use that as our next comment so randomize the initial weights we've already created a function in our matrix functions actually where we can call randomized weights on any on any uh matrix so weight zero dot random weights and do a similar thing for weights one good that's that step done we should probably test this so go to our other file the html file and let's go down to where we set up here we are to do neural network so we'll have to create a variable here so variable nn we'll call it and here we can go nnn equals new neural network now we need to pass the number of inputs hidden in outputs here i think we should set them as constants so up where we're setting our constants let's create a section called neural network parameters const num of inputs i'm not entirely sure how many inputs we'll need but let's just say two to begin with const num hidden um again there's lots of theory behind what number this should be the higher usually means the more complicated processing it can do so we'll just start with five we can always adjust it later and const num outputs now this one i am confident about we just want one boolean flag zero turn left one turn right so one output so head back down to where we're setting up our neural network put in these as their the arguments and num inputs num hidden and num outputs so we don't need these matrices anymore so we can get rid of them to test that our neural network's constructor is working all right how about we output the weights so nnn weights zero dot data and we'll do a similar thing for weights one we don't need this transpose anymore so open that up in our web browser okay so we have one for the first matrices of weights is two by three four yep two by five that's right and our output one our weights one is a five by one with random weights inside awesome to head over to our neural network class let's go down and see what we need to do next feed forward now all that means is that we're going to input some information into our network it's going to feed through it and some output is going to be created so let's create a new method called feed forward in our class it will take an input array as an input as a parameter let's paste these comments in here so the first step is to convert input array to a matrix that's easy enough so let's declare a new array let inputs equal matrix dot convert convert from array we made this earlier so we can just put the input array in there and that will convert it to a single road matrix that's fine next one find the hidden values and apply the activation function okay to find the hidden values we can look at this diagram here you can see that each hidden neuron is made up of these weights one coming from each of the previous inputs so to calculate that it's just the first input multiplied by the first weight plus the second input times the second weight times the third input sorry plus the third input times the third weight and that can be handled using a matrix dot product we have a function for that as well so let hidden equal matrix dot dot which takes two matrices the first one being the inputs and the second one will be the weights which we all have already determined it's been randomly determined so weights zero okay now the activation function is simply well with lots of neural networks the activation function is something called a sigmoid function let's take a look at that now a sigmoid function is simply this 1 divided by 1 plus e to the minus t now what that does we can input any value into this system and it will return a value between zero and one no matter how big that value is so if we put one trillion into this we'll get a it'll output a value close to one okay which suits our needs very well so let's go ahead and create a function down here just outside our class function we'll just call it sigmoid sigmoid it'll take some value we'll call that x and it will return 1 divided by 1 plus the exponent so that's e a numeric expression representing the power of e yep so math.exp to the minus x that's right now in order to apply that function to each of the cells of the matrix we made a function for that too so we just go hidden will equal matrix dot map okay so it takes the the matrix so which is hidden and the function to apply to it well we can use an arrow function here so x equals greater than x sigmoid x so sigmoid x so that should apply the sigmoid function to each of the values within our matrix good similarly so for the second part find the output values and apply the activation function it's the same sort of thing so we can just go let outputs equal matrix dot hidden will be the inputs so this will be from here from the hidden layer to the output layer so hidden will be the inputs and output will be the outputs so matrix dot hidden this dot sorry this dot weights one that's the second set of weights outputs matrix map so itself outputs and apply the sigmoid function to each value and finally we want to return return those outputs to the sender the next step apply bias i don't want to do that right now and the reason is because not applying bias can cause issues and i'd like to see what those issues are so let's first test this feed forward function so let's do some console output console log inputs and we'll just output the uh the data in the array so we can use table to that console.table inputs dot data and we'll do something similar each step of the way here so when we work out our hidden neurons we can just do that and we'll also want to see what happens after we apply the sigmoid function similarly for our outputs and after the outputs have had the sigmoid function applied to them so i'll just call that output sig that will be hidden sig okay head over to our other file let's call that function so all we have to do is go nn dot feed forward it requires an input array so something like zero comma one now remembering that the number of inputs that we declared for our neural network is two so we need to pass to an array of length two here now if we didn't let's just try that if we didn't it should break let's have to open our file open up the console yeah so inputs got through a single length array but there's an error matrices are not dot compatible so to fix that all we have to do is put the second element put the second uh input in there let's give that a go yep that worked fine so we've got two inputs zero and one the hidden values are calculated i'll just believe that the sigmoid is applied the output and the sigmoid is applied let's just keep resetting that until we get an output that is negative here we go so here's a negative output can you see that the sigmoid function has made that positive so that seems to be working okay so head over to our other file we can probably get rid of some of these console logs so let's just delete a few of them we'll keep one set we'll probably need it for our next function and that is train train using input and target arrays right so currently our system doesn't do very much we give it some inputs and it outputs some randomly generated outputs not very useful so in order to make it do something how about we create a function that allows us to put in some training data so we'll call that train so up inside our class train it will take an input array and the target array so for example if we had the inputs 0 and 1 and we expect 1 to be the answer then that's what we would put in here let's paste those comments in there so the first step feed the input data through the network well we already have a function for that called feed forward so let's say let outputs equal feed forward this dot feed forward the input array okay that's that done next calculate the output errors target minus output okay in order to subtract matrices we'll have to convert the target array first so that let's targets equal matrix dot convert convert from away from array target array okay good and let's output errors so we're calculating the output errors here let output errors equal matrix dot subtract and we'll subtract the first which is the target so the targets minus the second which is the output the outputs let's test that so we'll grab this console data that we kept up here uh outputs targets and output errors so outputs that'll be fine targets targets and output errors output errors let's print out every step okay head back over to our other file uh nn.train we need an input array 0 1 and an output array remembering it has to match the number of outputs if it doesn't we're going to get an error we'll just give that a go we'll put a 2 column one there okay so error matrices are of different dimensions so when it tries to subtract them it failed so let's put that to a single one right so we have our outputs which is 0.639 the in the expected the target is one so the difference is point three six that sounds correct so on to our next step calculate the deltas which are equal to the errors times the derivative of the output so the derivative of the output is actually the derivative of the sigmoid function so let's update our sigmoid function to handle derivatives how about we just pass a flag derive equals false we'll set we'll give it a default value so you don't have to provide it and if you don't it'll just return what we always have if derived then we'll return the derivative now the derivative of this is x times 1 minus x that's not the true derivative of the sigmoid function but we've already applied the sigmoid function so we don't want to return the true so i'll put a note here where x equals sigmoid x right so the true derivative is the sigmoid x times 1 minus the sigmoid x but we've already applied it so this will be a good representation x times 1 minus x so let's create a variable let output derives equal we can use our map function to apply this matrix.map the outputs and the function will be we can use an arrow function again will be the sigmoid x but this time we'll set the derived flag to true so it'll apply the derivative to each of these outputs and assign it to that and finally output errors no calculate the delta output deltas is what we're trying to find here output deltas will equal matrix dot so error is times derivative so multiply we can use our multiply function the first one is the errors output errors and the second one will be the output derivatives output derivatives and we'll just copy this console log here so we can test this output just the deltas we'll do output deltas let's test that let's run it again so we have outputs targets output errors and output deltas who am i to refute that it looks okay okay on to the next step calculate hidden layer errors so it's the deltas dot the transpose of weights one right so let's calculate the transpose first so we'll call that weights one capital t for transpose will equal we have a function for this matrix dot transpose it just takes a single matrix so that'll be the this dot weights one okay and then we'll need to calculate the hidden layer errors we'll call it hidden errors hidden errors will equal delta dot so matrix dot uh what was the first one the deltas dot the transpose okay so that'll be the output deltas output deltas dot what we just worked out the transpose their weights one t again let's output some just to make sure it's not throwing an error basically we don't really know exactly what we're after here uh the hidden areas is what we'll want to output here hidden errors let's give it a go right so we get some output deltas and then we get the hidden errors across ways that looks to be okay so the next step calculate the hidden deltas errors times derivative of hidden sounds very similar to what we've done up here so let's just copy and paste that let hidden derives equal matrix map hidden i just had a thought we don't have actually have visibility to hidden here hidden because hidden wasn't was used within this feed forward function here we go let hidden equals that so how about instead of creating a local variable here we use a property on our neural network we'll say this dot hidden this dot hidden so anywhere we use hidden inside here we'll go this dot hidden this dot hidden this dot hidden and we'll have to go create a property on the neural network so we can do that easily enough just at the top of it this dot underscore hidden will just equal an empty array and we'll have to set up some getters and setters for it so that we can access it get hidden we'll just return this underscore hidden and set hidden just pass a variable called hidden this hidden will equal hidden that should access yep that's the same as that right so that should all work in our feed forward now and back down where we have back in the train function where we have hidden here so hidden derivative with a matrix map this dot hidden so we're accessing the actual hidden values at this stat at this point in time x uh sigmoid x is true yep we're applying the derivative of it calculate the hidden deltas so the hidden deltas matrix multiply the hidden errors times the hidden derives right so let's output those hidden deltas let's give it a go so we have some hidden errors with some hidden deltas good now for the final step in our little neural network update the weights so we have to add the transpose of layers dot deltas so we add that to the weights okay so let's first calculate the transpose so let hidden transpose equal matrix dot transpose uh this dot hidden sorry um next we have to add the transpose to the weight so this weights the associated weights is one it's the second set of weights will equal matrix add add itself we have to add to itself so this weights one the layers the transverse layers dot deltas so matrix dot the transpose hidden t hidden t and the deltas which will be the output deltas of the associate are associated with the hidden layer so output deltas now we have to do a similar thing for the first weight so weights zero so we need to calculate the transpose of the inputs so inputs t well matrix transpose in do we have inputs do we have visibility on inputs no we don't because again within the feed forward we're converting it there and keeping it as a local variable so there's a couple things we could do we could just convert it again within our train array but we have to remember that this train function will probably be called like thousands of times if not hundreds of thousands of times so it's probably better just to assign it to what how we're doing with the hidden here so let's do that this dot inputs this input so we'll have to go up and create a property same as what we've done for hidden so this inputs will just equal an empty array and we have to create a couple of with create getter and a setter get inputs this return this inputs set inputs inputs equals inputs this inputs will equal inputs that's looking good so our feed forward function should work now we'll just assign instead of creating a local variable we're just assigning as a property now down in our train uh function this inputs should work now that's fine and we're updating weights zero at this point weight zero weight zero dot the inputs t inputs t and the deltas that are associated with that of the hidden deltas the next layer deltas let's run that make sure it's not broken okay it's not breaking so that's good enough test for me i think we should actually try this training and see if it actually works or not how about we get rid of all these comments first because they're just not we don't want them printing out every iteration when we've got like a thousand or ten thousand iterations remove all them remove all them this the weights are updating great go back to our other file right so we'll be calling train but we want to loop over the number of training samples that we have so we can go for i'll title this train the network for let i equal zero i is less than say let's set up a flag for this so num samples i plus plus in there we'll do our training for something a number of samples let's go up and create that now num samples i'm not exactly sure how many we'll need but let's start at say one thousand i know in other examples there's ten thousand and a hundred thousand and so on we'll just we'll start with one thousand num samples is 1000. and how about we use the classic example to test neural networks is the zor sorry the xor gate the exclusive or gate so x we'll call this a test test x or gate logic let's take a look at that xor gate here it is just this table down here so when you have two inputs 0 0 output 0 0 1 or one zero output one and one one outputs zero so zero zero zero okay let's write that in here i think zero zero equals zero zero one equals one one zero equals one and one one equals zero so only when there's one of them flagged will it be one otherwise when they're both the same it'll be zero so let's create some random input we'll create one zero one there and one zero one there so we'll input one input two or input zero and input one input zero will equal well it'll be a random number and we want to round it so math round just rounds to the nearest integer and we want to round a random number math random which is a number between zero and one so that should produce a zero or one similarly for input 1 so we can pass them into our training array here so input 0 and input 1 and we also need an output so let output let output equal well what's the logic behind it if input 1 input 0 and input 1 are the same then the output is 0 right otherwise the output is one so we just do a conditional here input zero equals input one if that's true the output is zero else the output is one that's the zorgate logic and put our output into this array here out put so basically we've created a whole bunch of random training data with the correct outputs fed it into our system in the hope that it's going to create an accurate uh prediction so let's test it test output we can just use the console for this i think console.log we'll put in each of the combinations of inputs so 0 0 will equal let's feed it into our system together to get a prediction feed forward we need the array 0 comma the input array 0 0 and we want to output to the screen the data of that so do that for each of the possible input combinations so zero one one zero and one one zero zero zero one one zero and one one let's give that a go okay zero zeros we're expecting a zero here and a zero here and a one here and one here it could be that we haven't got enough samples so let's try by bumping up the number of samples to say ten thousand ah that's looking pretty good that's close to zero that's close to one that's close to one that's close to zero let's just keep trying make sure there's no discrepancies here now i have read that not having bias can cause an issue in these situations so let's see if it comes up with a strange reading on occasion so here for example the prediction for 1 1 is 0.5 so that could be because of the bias not being there so i think for safety we should put the bias in so first of all what is bias well here's a diagram basically we have our input neurons we just add an extra neuron for bias it always takes a value of positive one and we add it and all it does is output its own weights in effect it doesn't take an input of any kind it just outputs its own weight we'll have one bias node on the input layer and one bias node on the hidden layer the reason we do this is because the input neurons could take all zeros for example in our zorgate logic if we have zero zero as our inputs can you see that that could skew the results because 0 times any of these weights will be 0 so it's not going to behave correctly so that's why we add this bias node head into our other file go right up the top in the same way that we've created weights here let's create a bias zero and a bias for one so bias zero will equal a new matrix of just a single row so one row the number of columns will be the number of hidden and bias one same sort of thing one row but the number of columns will be the number of outputs okay and we'll have to randomize in the same way that we've randomized the other weights we'll randomize the bias so bias zero random weights do that for bias one as well okay that looks good head down to our feed forward function we've left the node here apply bias to apply the bias all we have to do is before we apply the sigmoid function to the hidden layer we can just apply we can add the bias so this hidden will equal matrix add this hidden so adding to itself this bias zero so that is applying the bias apply bias and in the same way we'll do that with the output so before we apply the sigmoid function instead we'll be doing it to the output so outputs will equal matrix add outputs this bias one now down in our train function we've left a note update biases now to do all we have to do there is go in the same way that we've updated our weights here we'll do the same thing this dot bias 1 will equal matrix add this dot bias 1 and we're adding the the deltas the output deltas for this one same sort of thing for the bias 0 except that we'll be adding the hidden deltas so this by zero hidden deltas so let's test that oh we have an error m1 is undefined okay uh m bias uh maybe no i didn't create the uh getters and setters for these private so let's do that now that was a bit silly so we're just as we do just as we get and set the weights let's get and set the bias so bias zero this bias zero set bias zero and this bias zero just pass the bias oops bias bias okay so but get biased you return this by zero set by zero bias this bias zero equals bias do that for bias one as well just update that to one one one and one okay that should be okay now let's give that a go great so if we run that a few times my hunch is that it will be fine we'll get a value close to zero a value close to one and finally a value close to zero we will actually be feeding in game data into our neural network so that we can rotate this ship i'm doing this manually of course so we can rotate the ship and shoot at the closest asteroid okay so let's head into our code i'll just turn automation back on okay and head to our neural network file the first thing i'd like to do today is to set up some error logging in our neural network class the reason for this is that i'd like to be able to keep track of how well our training function is doing as we're training it so let's set up a flag up here just a constant let's call it log on set it to true and that's just whether or not to show error logging we'll need to keep track of how often we show this message like show a message we don't want to show it every iteration because we could in theory be calling this uh train function like thousands of hundreds of thousands of times if not millions of times so let's set a log frequency uh initially we'll set it to a thousand say and that's just how often to show error logging error logs and that's in iterations in iterations okay we'll have to set up a private uh member variable here just down here so error logging this underscore we'll keep track of how many calls we've had or how many iterations we'll call it log count and it'll start the day at log frequency and we'll also because it's private we'll want to set up some getters and setters it's not technically private i'm kind of making it private i should say so get log count i don't get log count return this log count set log count count this log count equals count head down to our train function now what's the most appropriate thing to output here i'm thinking the output errors because the output errors are simply the target minus the output so if the target's 1 and the output's 0.7 then the error is 0.7 it's easy to understand so let's do our error logging here error logging if log on and if the this dot log count yep if this.log count equals the log frequency well let's do a console output so console log uh output errors output errors now it's a matrix so we'll need to grab its data array and we there's only going to be one error because we've only got one piece of output so we'll just do the first column sorry the first row first cell okay probably prefix that with something so we know that what we're outputting error equals that then we'll have to decrement the log count so this dot log count minus minus because we don't want it occurring every iteration and when that reaches zero if this dot log count equals zero what will we do well we'll just reset it this dot log count equals log frequency let's test that out so currently we we'll just need to turn our console on reset it okay here we go so we've got errors of 0.32 0.29 0.08 blah blah blah it's going down slowly isn't it uh how about so this is our zorgate logic that we used last time how about we increase the number of samples so go back to our other file our html file we'll increase the number of samples to say 100 000 and we'll increase the number of hidden nodes to 10 but because we're doing a hundred thousand samples now how about we change our log frequency to say 10 000 we don't want it showing so often let's give that a go point seven four point zero one as you can see very quickly the error is reduced with the zorgate logic so that's good our logging is working great that's all we really need to do for our neural network file so let's head over to our other file now we have to think about how many inputs are there going to be in our system i've always said that the goal was to turn our ship towards the closest asteroid and shoot it so knowing that we need to know the asteroids position don't we so there's going to be an x position and a y position so that's two inputs and we also need to know the ship's angle because if we're facing this way we need to know that we'll have to turn left to get to the asteroid or turn right or whatever so that's the asteroid x the asteroid y and the ship's angle so that'll be a minimum of three inputs uh how about just for testing purposes we'll just turn the roid number down to one there'll be a single asteroid right head down to where we set up our neural network where we train the network we don't need to do any of this all gate logic anymore that was just for testing our system and we don't need this test output anymore so let's create some variables well i need the asteroids x position asteroids y position the ship's angle and just for completeness let's include the ship's position as well so ship x and ship y so the first thing we'd like to do the first thing we'd like to include in our training data is a random asteroid location random asteroid location but we have to remember that asteroids can float off the left and right of screen as well as top and bottom up to their radius so we'll have to include off screen data here as well so a x will equal a random point random times by the width of the screen so canvas dot width but because it can go up to its radius off the left and its radius off the right well that will mean we'll have to add the total with the size of the roid here roid size which is the diameter in effect just bracket that and then fine so that'll generate a number a number between zero and say the width is 500 so 500 plus 100 is 600 so 0 and 600 but we want it to be able to be negative so we'll have to subtract the radius so it'll be the roid size minus the roid size divided by 2 which is the radius do a similar thing for a y except that it will be the height good and now the ship's uh angle and position now the ship's angle it'll just be random we'll just randomly generate an angle anywhere between 0 and 360 degrees so in radians let's do a math random first math random times 360 degrees in in radians which is just pi times two good now the x location and the y location i'm not planning to move the ship at all that'll be far too complicated and i think it's a pretty good strategy just to sit in the middle turn to the nearest asteroid and shoot so we'll keep it fixed so sx will just equal the ships starting sorry the ship's starting x and s y will just equal the ship's starting y next we'll need to work out which direction to turn based on the angle of our ship and the angle of the asteroid so calculate the angle to the asteroid how about we write a function for this because it's possible that we'll use it again just down here function we'll give it a generic name such as angle to point angle to point we'll have to use some trigonometry here so we need to know our current position so x and y we'll need to know our facing or bearing we'll call that bearing uh we'll need to know the targets x and y location target x and target y and i think that's all we need to know so let's angle to target so let angle to target equal well it'll have to be the inverse tan because we have x and y coordinates so tan is opposite over adjacent so a10 there's two types of atans here there's a10 which is our regular mathematics tangent but that doesn't take into consideration coordinate space you know how we have four quadrants in coordinate space but a10 2 does take into consideration that so we'll use that now it requires a y and an x so we'll have to find the differences between our target and our self so we'll put so this will be the y differences so it'll be target y minus y right and the x's will be the symbol a similar thing target x minus x however because y's on screen like pixel wise are in the opposite direction so as we go up the screen we're actually going in a negative y direction so we'll have to apply a negative to that and a negative to that so it'll be minus target y plus y target x minus x y x yep that's good we'll have to find the differences between our angle to the target and our bearing so we can just go let say diff equal our bearing minus the angle to target angle to target now that could result in a whole range of numbers because this a 10 2 function it returns a number between effectively 180 degrees and minus 180 degrees so it could be negative our bearing could be anywhere between 0 and 360. so just that was 0 and we had 180 here we'll get a negative number won't we if the bearing is say 360 and our angle is minus we'll get a number over 360. so we'll need to do some normalizing as such here so how about we have or we can just return this i think return the diff remembering we can add 360 degrees to any angle and it's still the same effective angle if i'm facing 40 degrees and i add 360 degrees so 400 degrees i'm still facing at the same angle aren't i so we will add the we'll add 360 degrees math pi times 2 but that would that could get us above 360 couldn't it'll get us above zero which is what we want but it could also get us way above 360. so we'll find the modulus of that the remainder so modulus math pi times 2 so that will guarantee us a result between 0 and 360 degrees in effect in radians right so back up here we can just go let angle say angle equal call that function angle angle to point we have to pass the correct parameters so the x is our ship location ship x ship y the bearing is the ship's angle the target x is the asteroid x and the target y is the asteroid y so that'll give us our absolute angle as such and then we need to determine the direction to turn right so that's probably let's say let direction equal well if that angle is greater than 180 degrees so angle is greater than math.pi that's 180 degrees then we'd like to turn left so remember we have to um put in zero one here how about we set these as constants i think that would be the best move so back up here in our neural network parameters let's have constant output left will equal zero so that will be the expected output expected neural output for turning left similarly we'll have the output right which will equal one and that will be the expected neural output for turning right okay so back down here if the angle is greater than 180 math pi we'll output left else will output right so finally we just need to train the network so we can call neuralnetwork.train to do that it takes an input array so the input array is just our position of our asteroid ax and ay and the angle of the ship and the output array the expected array is just an array with direction in it it's just a single length sorry a one length array that's our training so we'll be training that every iteration now if i foresee one problem where this a x a y and s a they take on strange values so ax could be a number like 600 a y could be minus 23. sa could be uh 3.8 or whatever right they're not normalized are they but let's see what they do it might not be an issue okay you can see that these errors don't seem to be getting any better let's pump up the number of pump up the number of samples just while we're here we'll that's the number of training samples so we'll pump that up to 1 million let's see what that does to me that looks like it's not getting anywhere because these errors are still incredibly large they're not getting any closer to zero so i don't like that so i think we'll need to normalize our data we'll put that back to oops we'll put that back to a hundred thousand i don't think we need a million samples but a hundred thousand should do us head back down to our training here we'll need to normalize this data here before we input it into the training array so how about we create a method a new function called say normalize input or similar so just before shoot laser function normalize input we'll need to pass the roids x location the roids y location and our ships angle they're our three neural inputs now what we mean by normalize is normalize the values to between zero and one so we'll divide them by something in order to get them to be between zero and one so let's create a new uh array an empty array called input let input equal empty array and input zero that will be our roid x value we'll need to now normally you could just go right x divided by the canvas width that would give give us our screen position our relative screen position but because we've allowed it to be off screen up to its radius then we'll need to modify this so roid x so that could be negative 50 could be negative it could be the negative radius it could be negative 50. so we'll have to add the radius back to that to get it back to zero so roid size divided by two and we'll have to divide all of that by the new canvas width including the radius on the left and right so that'll be canvas width plus the diameter which is just the roid size let's just work through that logically so roid x could be minus 50. so minus 50 plus 50 equals zero zero divided by anything is going to be zero that's fine now the maximum value this could take would be just say we'll choose an arbitrary width of 500 so 500 plus 50 is 550 plus 50 is 600 600 divided by 500 plus 100 is 600 so that'll be one that's good and halfway between say 250 250 plus the radius of 50 is 300 300 divided by 500 plus 100 600 300 divided by 600 equals 0.5 that sounds good we'll do the similar sort of thing for the x sorry for the y position except that we'll use the height instead now the next one ships angle this is a bit of an easier exercise all we have to do is divide the past angle so that'll be a number between 0 and 360 in effect in radians we just have to divide that by 360. so math pi times two so an angle of zero divided by that would be zero an angle of 360 divided by that would equal one and everything in between that's great let's return that input array so let's go up and implement that in our training section train the network so all we have to do is normalize this data beforehand normalize input before we put it through our chain function let's give that a go it's looking better at least it's getting closer to zero there's some discrepancies here maybe we just need to modify some of the parameters here so how about we bump up a number of hidden to say 20 and we'll set our number of samples to say 500 000. just while we're here we might as well change the number the amount of logging let's change that to say every 20 000 instead okay let's give that a go so it's a bit slower because we've got more hidden uh neurons but it does look like it's getting better the the errors aren't too bad are they look at that one down the bottom very close to zero so i think we've done quite well with that if we put that if we put the hidden nodes back to 10 it'll speed it up a bit will that impact the quality let's have a look that's pretty good too actually either way well let's leave it at 20 and 500 000 number of training samples just while we're here i'm thinking that we'll need an output threshold because none of these predictions are going to be exactly zero or exactly one are they but they might be close so how about we create a threshold for example 0.25 just an arbitrary value to begin with and this is how close the prediction must be so how close the prediction must be to commit to a turn so at 0.25 for example if the prediction is 0.75 or greater we would commit to a right turn if the prediction was less than 0.25 we'd commit to a left turn however if the prediction was say 0.5 we won't do anything we'll just sit in the middle so how about we start implementing some of this so let's go down to well first of all let's see what happens when we push the left and right arrow keys so in the key down method so when we've got manual control of this all we're doing is setting the ship's rotation to this how about we create a function that can handle because when we turn right it's the same thing except we're going the opposite direction so let's pull those out and create a function for that because we'll need to call this function what will we call it rotate ship it was pass a boolean we'll say that false equals left right false equals left and here we'll rotate ship true so that'll be right and let's what do we do in the key up method the key up just sets the ship's rotation to zero so that's fine we don't need to do anything with that so let's go down make that rotate ship just after our normalize input function rotate ship it'll take a boolean which is equal to right so we'll be doing that now if it's right we want to put that as negative so how about we make a variable called say let sine equal now if it's right if it's right the sign will be 1 else it will be positive one and we'll just multiply this by the sign that should be okay just to make sure we haven't broken anything how about we turn it back into manual mode so automation on is false and make sure that we can control this ship yep i can turn left and right no problem that's all good put that back to true and now let's go down to our update function where is that down here to do control the ship so we'll need to make a prediction make a prediction based on current data so let's make some variables so we need to know the asteroids x which will equal roids um we'll just use because there's only one asteroid to begin with we'll just use roid 0 for the time being roid0.x similarly a y will equal roids sorry roids0.y and we also need to know the ship's angle don't we so that's just the ship dot a ship dot a now to make a prediction how we go let predict equal we just need to run our feed forward function feed feed forward it will take the input array so input array will be ax but we have to normalize this don't we so hang on do the normalize first normalize input it takes the voids x so a x a y and the ship's angle normalize input remember that returns a matrix an output matrix so we'll have to take its data and there's only going to be one output so it'll be the first column and the first so the first row first column 0 0 that should be our prediction now we need to decide which way to turn so make a turn now we're going to get a value it's not going to be exactly zero it's not going to be exactly one so how about we find the difference between it between the prediction and our left and right turns so let we'll call it delta left or difference left whatever you're going to call it delta left will equal the prediction make this the absolute value math absolute value it'll be the prediction minus the uh output uh constant output left right and delta right will equal the prediction minus the output right so let's just try to analyze that so the prediction just say the prediction is 0.2 right so 0.2 minus output left is 0.2 that means there's only it's 0.2 units close to the left 0.2 minus 1 is 0.8 the absolute value will be 0.8 so that's not going to be what we want to do so we'll have to compare it we'll have to compare these to our thresholds okay so if delta left is less than our output threshold so if it's less than 0.25 or whatever value we choose to set it at then we wish to rotate left rotate ship now left is just false okay else if delta right is less than the output threshold then we will rotate the ship right which is true now if it's neither so for example 0.5 0.5 minus the output left is 0.5 0.5 minus output right it's not going to be less than the threshold in either of these situations so how about we just put an else here saying that um stop rotating so if it's not confident it'll stay still so ship dot rotate equals zero so that's equivalent to us releasing the arrow keys i think we should just log this prediction here so console log predict just so we can see if there's any problems with it okie dokie let's try it so we're just training it to begin with with 500 000 samples the errors look pretty good that one wasn't very good okeydokey what's it doing it seems to be stuck i know now it is turning it's kind of slowly turning towards the asteroid will it turn when it goes past it yes it's okay it's maybe not the best now i wonder why we'll just watch it a bit longer it's kind of getting confused a bit isn't it okay i've been watching this for a while now it looks like something's going wrong because it eventually the ship no matter how many times you run it the ship eventually starts spinning around in its inner circle without and it's got these really very confident predictions so see this prediction here it's very very low it's close to zero so i'm guessing something's going wrong with our angle so let's go into our code maybe we should log the angle here ship dot angle let's see what that does okay it's loading the training data again okay so the angle remember it'll be a number between 0 and 2 pi which is about 6 or so now that's not good see the angle is going negative there we want the angle to be zero between zero and two pi so there's something i think i might know what's wrong if we head down to where we rotate our ship in the update function i suspect that we're just letting it add on endlessly we are so for example the ship out the ship angle can just keep going up and up and up and up so it'll go beyond 720 and so on it could go below zero no problems which is fine it was working fine in the game but for our prediction we want it to be between 0 and 360. so we want to keep the angle between 0 and 360 which is 2 pi remember 2 pi so if the ship's angle is less than 0 we'll need to add 360 to it remembering if we add 360 it'll still be the same angle so plus equals math pi do we need to bracket this i'm not sure i'm not sure what the order of operations are for these these assignment operators we'll just bracket it won't hurt math times two we'll add 360 to it else if a ship's angle is greater than or equal to 360. 360. math times i'll bracket this one as well math dot pi times 2 if it's greater than that then we'll want to subtract we want to do the same thing except that we'll subtract 360. we don't want exactly 360 because our randomly generated uh position will never be 360 i don't think minus equals that and that should do it let's give that a go let's load it up loading the training data so the training data looks pretty good it should be working quite well okay i think that's acting a lot better where's the asteroid there's the asteroid yeah i think it's tracking it quite well i think that was our problem yep so it's choosing the first asteroid which is whatever's in the in the array first in the array and following it good okay how about we add some shooting to this little ship so let's head back all the way up to the top to set some parameters so we'll probably need to give the ship a rate of fire so just in under our neural network parameters here let's create one called rate of fire and we'll set that to say five shots per second so shots per second we'll also need to keep track of how many frames we count down to the next shot so where we set up our neural network here let's just put in a new something called say a i shoot time and we'll set that to zero to begin with where will we update that well we'll update that in our water where we do our prediction so just after we make it turn now what's the strategy for firing when when will we shoot well we could shoot just when it's not rotating but that's not really what i do i keep turning and just shooting all the time because eventually you're going to get lucky too so how about we shoot all the time it'll shoot as often as it can so shoot the laser if a i shoot time equals zero which will it'll start at zero then we want to reset that a issue time not this a i shoot time will equal the frame rate divided by the rate of fire i think we should find the ceiling of that math.seal so if we had a frame rate of 30 divided by the rate of fire of 5 that'll every 6 frames we'll shoot if it was 10 so 30 divided by 10 would have we'd be shooting every third frame so quite quickly uh we'll need to shoot the laser shoot laser just checking that function because part of that condition is that the ship can shoot and when we shoot a laser the ship can't shoot that's because the player must push the space key then release it so we'll have to set that up to be able to handle that or we can we can just do it here ship dot can shoot equals true so whenever it can fire we'll let it fire else so if the ai shoot time doesn't equal zero we'll want to count down a i shoot time minus minus so this is just counting down the frames left so let's give this a go so loading in our training data so hopefully this little ship will follow the first asteroid and just keep shooting at it until it's destroyed and then it'll follow the next asteroid yeah that's what it's doing bang bang bang bang yeah just keep shooting it's pretty effective actually even when we're not targeting the closest asteroid so how about we program it to target the closest one so head back into our update function so compute the closest asteroid uh we'll need to keep track of the index so how about we just make a variable called say let c equal zero so this will be the closest index in the array uh we'll need to calculate the distance we'll need to keep track of the closest distance so we'll call that say distance zero will equal we have a method for calculating distance distance between points uh the x1 y1 so the ship dot x the ship dot y uh the x2 will be the asteroid so roids zero dot x roids zero dot y and then we'll have to loop through each of the asteroids so four let i equal zero actually let it equal one because we've already calculated the first one distance zero there so let i equal one i is less than the asteroid's length roid's dot length i plus plus and then we need to get the distance of the current asteroids we'll call that distance one distance 1 will equal distance it's going to be the same thing really basically except that we'll be using i instead of 0 here and then all we have to do is do a check to see if that one's that distance is smaller less than the uh current distance so if distance 1 is less than distance 0 that means it's smaller doesn't it so we'll replace distance zero distance zero will equal distance one and we'll want to update our uh index closest index so c will equal i so all we have to do is put that c into where we've got zero down here so ax will equal right c a y will equal roid c dot y and let's give that a go loading our training data again so hopefully it'll turn towards the closest asteroid and shoot at it there's only one asteroid here that reminds me we should probably up the number of starting asteroids back to its original so roid numb will equal three save that load it one more time okay is it turning towards the closest one certainly it's not shooting the furthest away ones anyway so it's doing fairly well it's not perfect i'm thinking we could probably make this a little bit better i think we'll do one more one more update to our little function here how about we pass some more information because we're only passing kind of the bare minimum we're passing the asteroid location and the ship's angle i think we can do better than that so head back into the code to head down to where we set up our training data what else could we pass well we are calculating the angle to the asteroid how about we stick that in as one of our inputs so we'll put it in after our asteroid position we'll have to bump up the number of inputs to four so down here our normalize input we'll have to add an extra here we'll pull that roid angle right angle it'll be our third one it's going to be very similar to how we do the ship angle we'll just put right angle there roid angle ship angle update its index to three uh wherever we call this what that fix it up which is just down in our update function so we'll have to pass an angle in there and we'll have to calculate that angle so what do we need to know for that we need to know the ship's x and y coordinates so s x will equal ship dot x you didn't you don't really have to do this but this is to make it clear ships y ship dot y and let angle equal angle angle to point now what does it take x and y which is the ship x and the ship y it takes the bearing which is the ship's angle the target x which is the asteroids x and the asteroids y and then we'll pass that in through our feed forward function to get a prediction i don't think we need to log this anymore with this prediction uh let's take a look at that okay import um doing our training wow those errors are very small so they're e to the minus 15 there's a couple of zeros in there so they're very precise so looking at our ship's performance yeah he's doing pretty well he should be doing very well the only issue i can see is that see that jitter there that's because we're only making a prediction every frame if we increased our frame rate we could probably make that better and also if we reduced our threshold to decide whether we turn or not so let's do that now so head up to the top we'll reduce our output threshold to say 0.05 that means in order to make a right turn we'd have to have 0.95 confidence let's increase the rate of fire for fun to say to 15 shots per second and we want to increase our frame rate to say 60. let's give that a go eh okay just loading our training data the errors are very very good and here he goes wow we've created a monster so with his increased with his increased rate of fire and the faster frame rate he can make more accurate more subtle turns and really pepper those asteroids with laser fire cool so anyway that's the end of our tutorial series so we've gone from using matrix maths to creating a neural network only a fairly simple neural network but a neural network all the same i hope you've learned a lot from this i certainly have because i had to do a lot of research in figuring all this stuff out but in the end we managed to use our network to control a simple game such as asteroids and this is the result i wonder how far he could go how far could this uh what level could this ship reach well anyway feel free to download the code and try it out for yourself update the parameters have a play and learn something new until next time talk to you then bye
